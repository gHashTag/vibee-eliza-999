---
name: vibe-coder
agent_id: vibe-coder
description: üíª Auto-activates for TypeScript, React, ElizaOS plugins, API development, and implementation tasks (TDD + Functional Programming)
keywords:
  - typescript
  - react
  - api
  - implementation
  - –∫–æ–¥
  - —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∞
  - –∫–æ–º–ø–æ–Ω–µ–Ω—Ç
  - —Ñ—É–Ω–∫—Ü–∏—è
  - elizaos
  - plugin
  - actions
  - services
  - drizzle
  - tdd
  - —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ
model: sonnet
trigger_threshold: 0.75
auto_activate: true
---

# üíª Vibe Coder Skill - Full-Stack Implementation Expert

–≠—Ç–æ—Ç —Å–∫–∏–ª–ª **–∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –∞–∫—Ç–∏–≤–∏—Ä—É–µ—Ç—Å—è** –ø—Ä–∏ —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–µ –∏ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏, –≤–∫–ª—é—á–∞—è **ElizaOS –ø–ª–∞–≥–∏–Ω—ã**, **TypeScript**, **React** –∏ **API**.

## üöÄ –ö–æ–≥–¥–∞ –ê–∫—Ç–∏–≤–∏—Ä—É–µ—Ç—Å—è

### –ö–ª—é—á–µ–≤—ã–µ –°–ª–æ–≤–∞ (_auto_activate: true_):
- `typescript`, `—Ç–∏–ø—ã`, `TS`, `strict mode`
- `react`, `–∫–æ–º–ø–æ–Ω–µ–Ω—Ç`, `component`, `tsx`
- `api`, `endpoint`, `REST`, `routes`
- `implementation`, `—Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è`
- `–∫–æ–¥`, `coding`, `—Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∞`
- `—Ñ—É–Ω–∫—Ü–∏—è`, `function`, `functional`
- `class`, `–∫–ª–∞—Å—Å`, `OOP`
- `interface`, `–∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å`, `—Ç–∏–ø–∏–∑–∞—Ü–∏—è`
- `elizaos`, `–ø–ª–∞–≥–∏–Ω`, `plugin`, `@elizaos/`
- `actions`, `services`, `providers`, `evaluators`
- `drizzle`, `orm`, `schema`, `–±–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö`
- `tdd`, `—Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ`, `testing`, `bun test`
- `mock`, `–º–æ–∫–∏`, `test utils`

### –ü—Ä–∏–º–µ—Ä—ã:
```
"–°–æ–∑–¥–∞–π ElizaOS –ø–ª–∞–≥–∏–Ω —Å Actions"
‚Üí –ê–≤—Ç–æ-–∞–∫—Ç–∏–≤–∏—Ä—É–µ—Ç—Å—è vibe-coder

"–ù–∞–ø–∏—à–∏ Service —Å —Ç–∏–ø–∏–∑–∞—Ü–∏–µ–π"
‚Üí –ê–≤—Ç–æ-–∞–∫—Ç–∏–≤–∏—Ä—É–µ—Ç—Å—è vibe-coder

"–†–µ–∞–ª–∏–∑—É–π Drizzle schema"
‚Üí –ê–≤—Ç–æ-–∞–∫—Ç–∏–≤–∏—Ä—É–µ—Ç—Å—è vibe-coder
```

## üéØ –ß—Ç–æ –î–µ–ª–∞–µ—Ç (Best Practices)

1. **ElizaOS Architecture**: Actions, Services, Providers, Evaluators
2. **TypeScript Strict**: –ü–æ–ª–Ω–∞—è —Ç–∏–ø–∏–∑–∞—Ü–∏—è –±–µ–∑ any
3. **Functional Programming**: TaskEither, Either, pipe
4. **TDD Approach**: RED ‚Üí GREEN ‚Üí REFACTOR
5. **Database Design**: Drizzle ORM + PostgreSQL
6. **API Routes**: HTTP endpoints + webhooks
7. **Error Handling**: Robust patterns —Å –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ–º
8. **Testing**: Mock Runtime + bun test

## ‚öôÔ∏è –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è

```yaml
model: sonnet              # –ú–æ—â–Ω–∞—è –º–æ–¥–µ–ª—å –¥–ª—è —Å–ª–æ–∂–Ω–æ–π –ª–æ–≥–∏–∫–∏
trigger_threshold: 0.75    # –ê–∫—Ç–∏–≤–∞—Ü–∏—è –ø—Ä–∏ 75% —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç–∏
auto_activate: true        # –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –∞–∫—Ç–∏–≤–∞—Ü–∏—è
```

## üîÑ –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è

- **–í—ã–∑—ã–≤–∞–µ—Ç—Å—è**: –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –ø—Ä–∏ —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–µ
- **–ö–æ–æ—Ä–¥–∏–Ω–∏—Ä—É–µ—Ç—Å—è —Å**: vibe-elizaos, vibe-tester, vibe-spec
- **–†–µ–∑—É–ª—å—Ç–∞—Ç**: –ü–æ–ª–Ω—ã–π –∫–æ–¥ + —Ç–µ—Å—Ç—ã + —Ç–∏–ø–∏–∑–∞—Ü–∏—è + –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è

## üí° –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ

### –Ø–≤–Ω—ã–π –≤—ã–∑–æ–≤:
```
Task(
  subagent_type="vibe-coder",
  description="Create ElizaOS plugin with TDD",
  prompt="Plugin with actions, services, Drizzle schema, and tests"
)
```

### –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏:
```
"–°–æ–∑–¥–∞–π Action —Å validate + handler"
‚Üí vibe-coder –∞–∫—Ç–∏–≤–∏—Ä—É–µ—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏
```

## üé® –°–ø–µ—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è (Best Practices)

### Core Technologies:
- ‚úÖ **ElizaOS Plugins**: Full component architecture
- ‚úÖ **TypeScript**: Strict mode, no any, full typing
- ‚úÖ **React**: Functional components, hooks, TypeScript
- ‚úÖ **Drizzle ORM**: PostgreSQL schemas + repositories
- ‚úÖ **Functional Programming**: TaskEither, Either, pipe
- ‚úÖ **TDD**: Test-first development —Å Mock Runtime
- ‚úÖ **API Routes**: HTTP endpoints, webhooks, authentication
- ‚úÖ **Error Handling**: Try-catch + logging + user feedback

### Development Patterns:
```typescript
// 1. TDD Pattern (RED ‚Üí GREEN ‚Üí REFACTOR)
describe('MyAction', () => {
  it('should validate and execute', async () => {
    // RED: Write failing test
    // GREEN: Make it pass
    // REFACTOR: Improve code
  });
});

// 2. Functional Error Handling
import { left, right } from 'fp-ts/Either';
import { pipe } from 'fp-ts/function';

const result = await pipe(
  validateInput(data),
  (input) => processData(input),
  (processed) => saveToDB(processed),
  (saved) => right(saved),
  (final) => /* handle result */
);

// 3. Type-Safe Action
export const myAction: Action = {
  name: 'MY_ACTION',
  description: 'Does something useful',

  validate: async (runtime, message, state) => {
    // Type-safe validation
    return Boolean(message.content.text?.trim());
  },

  handler: async (runtime, message, state, options, callback) => {
    // Immediate feedback
    await callback?.({
      text: 'Processing...',
      action: 'MY_ACTION'
    });

    try {
      // Business logic
      const service = runtime.getService<MyService>('my-service');
      const result = await service.process(message);

      // Type-safe return
      return {
        success: true,
        text: 'Completed successfully!',
        values: { resultId: result.id },
        data: result
      };

    } catch (error) {
      // Error to user
      await callback?.({
        text: 'Error occurred. Please try again.',
        error: true
      });

      return {
        success: false,
        text: 'Action failed',
        error: error instanceof Error ? error : new Error(String(error))
      };
    }
  }
};
```

### Database Patterns:
```typescript
// Type-safe Drizzle Schema
export const userTable = pgTable('users', {
  id: uuid('id').primaryKey().defaultRandom(),
  email: varchar('email').notNull().unique(),
  createdAt: timestamp('created_at').defaultNow().notNull(),
});

// Domain Types
export interface User {
  id: string;
  email: string;
  createdAt: Date;
}

// Repository with Types
export class UserRepository {
  async findByEmail(email: string): Promise<User | null> {
    const db = runtime.databaseAdapter.db;
    const result = await db.select()
      .from(userTable)
      .where(eq(userTable.email, email))
      .limit(1);

    return result[0] || null;
  }

  async create(userData: { email: string }): Promise<User> {
    const db = runtime.databaseAdapter.db;
    const [result] = await db.insert(userTable)
      .values(userData)
      .returning();

    return result;
  }
}
```

### Service Patterns:
```typescript
// Type-Safe Service
export class MyService extends Service {
  static serviceType = 'my-service';
  capabilityDescription = 'Provides my functionality';

  private apiClient: ExternalAPI;

  constructor(private runtime: IAgentRuntime) {
    super();
  }

  async initialize(): Promise<void> {
    const apiKey = this.runtime.getSetting('API_KEY');
    if (!apiKey) {
      throw new Error('API_KEY not configured');
    }

    this.apiClient = new ExternalAPI({ apiKey });
  }

  async process(data: DataType): Promise<ResultType> {
    this.ensureInitialized();

    try {
      const result = await this.apiClient.process(data);
      this.runtime.logger.info('Processed successfully', { dataType: data.type });
      return result;

    } catch (error) {
      this.runtime.logger.error('Processing failed', { error });
      throw error;
    }
  }

  private ensureInitialized(): void {
    if (!this.apiClient) {
      throw new Error('Service not initialized');
    }
  }

  async stop(): Promise<void> {
    await this.apiClient.disconnect();
  }
}
```

### Testing Patterns:
```typescript
// Mock Runtime Factory
function createTestRuntime(): IAgentRuntime {
  return {
    agentId: 'test-agent',
    getService: mockService(),
    getSetting: mock((key) => process.env[key]),
    databaseAdapter: {
      db: createMockDB()
    },
    logger: createMockLogger()
  } as unknown as IAgentRuntime;
}

// Test Suite
describe('MyAction Integration', () => {
  let runtime: IAgentRuntime;
  let mockCallback: MockCallback;

  beforeEach(() => {
    runtime = createTestRuntime();
    mockCallback = vi.fn();
  });

  it('should process valid input', async () => {
    // Arrange
    const message = createMessage('valid command');
    const action = myAction;

    // Act
    const result = await action.handler(runtime, message, {}, {}, mockCallback);

    // Assert
    expect(result.success).toBe(true);
    expect(mockCallback).toHaveBeenCalledWith(
      expect.objectContaining({
        text: expect.stringContaining('Processing...'),
        action: 'MY_ACTION'
      })
    );
  });

  it('should handle errors gracefully', async () => {
    // Arrange
    const message = createMessage('error command');
    const action = errorAction;

    // Act
    const result = await action.handler(runtime, message, {}, {}, mockCallback);

    // Assert
    expect(result.success).toBe(false);
    expect(result.error).toBeInstanceOf(Error);
    expect(mockCallback).toHaveBeenCalledWith(
      expect.objectContaining({
        text: expect.stringContaining('Error'),
        error: true
      })
    );
  });
});
```

### React Patterns:
```typescript
// Type-Safe React Component
interface ButtonProps {
  variant: 'primary' | 'secondary';
  size?: 'sm' | 'md' | 'lg';
  onClick: () => void;
  children: React.ReactNode;
  disabled?: boolean;
}

export const Button: FC<ButtonProps> = ({
  variant,
  size = 'md',
  onClick,
  children,
  disabled = false
}) => {
  return (
    <button
      className={cn(
        'btn',
        `btn-${variant}`,
        `btn-${size}`
      )}
      onClick={onClick}
      disabled={disabled}
    >
      {children}
    </button>
  );
};
```

## üöÄ Development Workflow

### 1. **TDD Cycle**:
```bash
# RED: Write failing test
bun test --watch

# GREEN: Make it pass
bun run build

# REFACTOR: Improve code
# Run tests again
```

### 2. **Type Checking**:
```bash
# Strict TypeScript
tsc --noEmit --strict

# Check all files
npm run type-check
```

### 3. **Testing**:
```bash
# Run all tests
bun test

# With coverage
bun test --coverage

# Watch mode
bun test --watch
```

### 4. **Linting & Formatting**:
```bash
# Format code
prettier --write src/

# Lint
eslint src/
```

## üìä Code Quality Metrics

- ‚úÖ **Type Coverage**: 100% (no `any`)
- ‚úÖ **Test Coverage**: >90%
- ‚úÖ **Cyclomatic Complexity**: <10 per function
- ‚úÖ **Function Length**: <50 lines
- ‚úÖ **Error Handling**: All async operations
- ‚úÖ **Logging**: All external API calls
- ‚úÖ **Documentation**: JSDoc for public APIs

## üéØ Coding Standards

### TypeScript Rules:
- ‚ùå `any` - use `unknown` or specific types
- ‚ùå `!` non-null assertion - use proper checks
- ‚ùå `as` type assertions - use type guards
- ‚úÖ Strict mode enabled
- ‚úÖ NoImplicitAny: true
- ‚úÖ NoImplicitReturns: true

### Error Handling:
```typescript
// ‚ùå Bad
async function processData(data: any) {
  const result = await api.call(data);
  return result; // May throw
}

// ‚úÖ Good
async function processData(data: DataType): Promise<ResultType> {
  try {
    const result = await api.call(data);
    logger.info('Processed', { dataId: data.id });
    return result;
  } catch (error) {
    logger.error('Processing failed', { data, error });
    throw new ProcessingError('Failed to process data', error);
  }
}
```

### Function Design:
```typescript
// ‚ùå Bad: Too many parameters
function createUser(name: string, email: string, age: number, city: string) { }

// ‚úÖ Good: Single responsibility
interface CreateUserInput {
  name: string;
  email: string;
  age: number;
  city: string;
}

function createUser(input: CreateUserInput): User { }
```

### Modern TypeScript Patterns (2024-2025):
```typescript
// Template Literal Types for API responses
type ApiResponse<T> = T extends { data: infer D }
  ? { data: D; status: 'success' }
  : { error: string; status: 'error' };

// Constrained Generics with branded types
type UserId = string & { readonly brand: unique symbol };
function createUserId(id: string): UserId {
  if (!id || id.length < 3) throw new Error('Invalid ID');
  return id as UserId;
}

// Utility Types for API design
type CreateUserRequest = RequestBody<{
  name: string;
  email: string;
  role: 'admin' | 'user';
}>;

type UserResponse = ResponseBody<{
  id: UserId;
  name: string;
  email: string;
  createdAt: Date;
}>;

// Zod for runtime validation
import { z } from 'zod';

const UserSchema = z.object({
  name: z.string().min(2).max(50),
  email: z.string().email(),
  age: z.number().int().min(18).max(120)
});

type UserInput = z.infer<typeof UserSchema>;
```

### AI-Assisted Development Patterns:
```typescript
// Code Generation with AI assistance
export class AICodeGenerator {
  async generateAction(
    description: string,
    context: CodeContext
  ): Promise<Action> {
    const prompt = this.buildPrompt(description, context);
    const aiResponse = await this.ai.complete(prompt);

    // Validate generated code
    return this.validateAndExtract<Action>(aiResponse, {
      schema: ActionSchema,
      validator: this.validateActionStructure
    });
  }

  private buildPrompt(description: string, context: CodeContext): string {
    return `
      Generate an ElizaOS Action for: ${description}

      Requirements:
      - TypeScript strict mode
      - Include validate() method
      - Include handler() method
      - Return ActionResult with success field
      - Add error handling
      - Context: ${JSON.stringify(context)}
    `;
  }
}

// Automated Code Review
export class AutomatedCodeReview {
  async review(code: string, rules: ReviewRule[]): Promise<ReviewResult> {
    const violations: CodeViolation[] = [];

    // Static analysis
    const ast = this.parseAST(code);
    for (const rule of rules) {
      const issues = await rule.check(ast);
      violations.push(...issues);
    }

    // AI-powered security review
    const securityIssues = await this.scanSecurity(code);

    return {
      score: this.calculateScore(violations),
      violations,
      suggestions: await this.generateSuggestions(code),
      approved: violations.filter(v => v.severity === 'ERROR').length === 0
    };
  }
}
```

### Security by Design (2024):
```typescript
// Input sanitization
export class SecurityGuard {
  sanitizeInput(input: string): SanitizedInput {
    return {
      text: DOMPurify.sanitize(input),
      metadata: this.extractSafeMetadata(input)
    };
  }

  // CSRF protection
  validateCSRFToken(token: string, session: Session): boolean {
    const expectedToken = session.csrfToken;
    return timingSafeEqual(token, expectedToken);
  }

  // SQL injection prevention
  createParameterizedQuery(
    template: string,
    params: Record<string, any>
  ): ParameterizedQuery {
    const escapedParams = this.escapeParams(params);
    return {
      query: this.replacePlaceholders(template),
      params: escapedParams
    };
  }
}

// Rate Limiting
export class RateLimiter {
  private store: RedisStore;

  async checkLimit(
    key: string,
    limit: number,
    window: number
  ): Promise<boolean> {
    const current = await this.store.increment(key);

    if (current === 1) {
      await this.store.expire(key, window);
    }

    return current <= limit;
  }
}
```

### Performance Optimization:
```typescript
// Memoization for expensive operations
export function memoize<T extends (...args: any[]) => any>(
  fn: T,
  keyGenerator?: (...args: Parameters<T>) => string
): T {
  const cache = new Map<string, ReturnType<T>>();

  return ((...args: Parameters<T>) => {
    const key = keyGenerator ? keyGenerator(...args) : JSON.stringify(args);

    if (cache.has(key)) {
      return cache.get(key)!;
    }

    const result = fn(...args);
    cache.set(key, result);
    return result;
  }) as T;
}

// Lazy loading with dynamic imports
export class LazyLoader {
  private modules = new Map<string, Promise<any>>();

  async loadModule<T>(name: string, loader: () => Promise<T>): Promise<T> {
    if (!this.modules.has(name)) {
      this.modules.set(name, loader());
    }
    return this.modules.get(name)!;
  }
}

// Streaming for large data
export async function streamLargeDataset(
  query: Query,
  processor: (chunk: DataChunk) => Promise<void>
): Promise<void> {
  const stream = query.execute();

  for await (const chunk of stream) {
    await processor(chunk);
    // Allow event loop to process other tasks
    await new Promise(resolve => setImmediate(resolve));
  }
}
```

### Observability & Debugging:
```typescript
// Structured logging with context
export class Logger {
  info(message: string, context: LogContext): void {
    this.log('INFO', message, {
      ...context,
      timestamp: new Date().toISOString(),
      service: this.serviceName
    });
  }

  error(message: string, error: Error, context?: LogContext): void {
    this.log('ERROR', message, {
      ...context,
      error: {
        name: error.name,
        message: error.message,
        stack: error.stack
      }
    });
  }
}

// Performance profiling
export class Profiler {
  private marks = new Map<string, number>();

  mark(name: string): void {
    this.marks.set(name, performance.now());
  }

  measure(name: string, startMark: string, endMark?: string): number {
    const start = this.marks.get(startMark)!;
    const end = endMark ? this.marks.get(endMark)! : performance.now();
    const duration = end - start;

    this.metrics.record(name, duration);
    return duration;
  }
}
```

### Error Resilience:
```typescript
// Circuit Breaker pattern
export class CircuitBreaker {
  private state: 'CLOSED' | 'OPEN' | 'HALF_OPEN' = 'CLOSED';
  private failures = 0;
  private lastFailureTime = 0;

  async execute<T>(operation: () => Promise<T>): Promise<T> {
    if (this.state === 'OPEN') {
      if (Date.now() - this.lastFailureTime > this.timeout) {
        this.state = 'HALF_OPEN';
      } else {
        throw new Error('Circuit breaker is OPEN');
      }
    }

    try {
      const result = await operation();
      this.onSuccess();
      return result;
    } catch (error) {
      this.onFailure();
      throw error;
    }
  }

  private onSuccess(): void {
    this.failures = 0;
    this.state = 'CLOSED';
  }

  private onFailure(): void {
    this.failures++;
    this.lastFailureTime = Date.now();

    if (this.failures >= this.failureThreshold) {
      this.state = 'OPEN';
    }
  }
}

// Graceful degradation
export class ResilientService {
  async process(data: Data): Promise<Result> {
    try {
      // Try primary method
      return await this.primaryMethod(data);
    } catch (error) {
      // Fallback to cache
      const cached = await this.cache.get(data.id);
      if (cached) return cached;

      // Return default/placeholder
      return this.getDefaultResult(data);
    }
  }
}
```

### Modern React Patterns:
```typescript
// Custom hooks with proper typing
function useAsync<T, Args extends any[]>(
  asyncFunction: (...args: Args) => Promise<T>,
  immediate = true
) {
  const [data, setData] = useState<T | null>(null);
  const [loading, setLoading] = useState(immediate);
  const [error, setError] = useState<Error | null>(null);

  const execute = useCallback(
    async (...args: Args) => {
      setLoading(true);
      setError(null);

      try {
        const result = await asyncFunction(...args);
        setData(result);
        return result;
      } catch (err) {
        setError(err instanceof Error ? err : new Error(String(err)));
        throw err;
      } finally {
        setLoading(false);
      }
    },
    [asyncFunction]
  );

  return { data, loading, error, execute };
}

// Server Components for data fetching
async function UserProfile({ userId }: { userId: string }) {
  const user = await getUser(userId);

  return (
    <div>
      <h1>{user.name}</h1>
      <Suspense fallback={<UserStatsSkeleton />}>
        <UserStats userId={userId} />
      </Suspense>
    </div>
  );
}
```

## üì¶ Project Structure

```
project/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ actions/          # ElizaOS Actions
‚îÇ   ‚îú‚îÄ‚îÄ services/         # Service classes
‚îÇ   ‚îú‚îÄ‚îÄ providers/        # Data providers
‚îÇ   ‚îú‚îÄ‚îÄ types/            # TypeScript types
‚îÇ   ‚îú‚îÄ‚îÄ utils/            # Utilities
‚îÇ   ‚îî‚îÄ‚îÄ __tests__/        # Test files
‚îú‚îÄ‚îÄ drizzle/              # Database schema
‚îÇ   ‚îú‚îÄ‚îÄ schema.ts
‚îÇ   ‚îî‚îÄ‚îÄ migrations/
‚îú‚îÄ‚îÄ public/               # Static assets
‚îî‚îÄ‚îÄ package.json
```

## üéØ Modern Development Principles (2024-2025)

1. **"AI-First Development"** - –∏—Å–ø–æ–ª—å–∑—É–π AI –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∏ —Ä–µ–≤—å—é –∫–æ–¥–∞
2. **"Security by Default"** - –≤–∞–ª–∏–¥–∞—Ü–∏—è, —Å–∞–Ω–∏—Ç–∏–∑–∞—Ü–∏—è, rate limiting —Å –ø–µ—Ä–≤–æ–≥–æ –¥–Ω—è
3. **"Performance Matters"** - memoization, lazy loading, streaming
4. **"Observability is Essential"** - –ª–æ–≥–∏, –º–µ—Ç—Ä–∏–∫–∏, –ø—Ä–æ—Ñ–∏–ª–∏—Ä–æ–≤–∞–Ω–∏–µ
5. **"Resilience is Key"** - circuit breakers, graceful degradation, retries
6. **"Type Safety is Non-Negotiable"** - strict TypeScript, runtime validation
7. **"Test Everything"** - unit, integration, e2e, property-based testing
8. **"Clean Architecture"** - separation of concerns, dependency inversion

**–°–ª–µ–¥—É–µ—Ç —Å–æ–≤—Ä–µ–º–µ–Ω–Ω—ã–º best practices 2024-2025! –ë—ã—Å—Ç—Ä–∞—è, –±–µ–∑–æ–ø–∞—Å–Ω–∞—è –∏ –∫–∞—á–µ—Å—Ç–≤–µ–Ω–Ω–∞—è —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∞!** üíª‚ú®
