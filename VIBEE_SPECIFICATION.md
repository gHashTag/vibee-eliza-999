# 📚 Документация функционала бота 🐝

> **Последнее обновление**: 2025-01-12  
> **Версия**: 1.0  
> **Статус**: Актуально  
> **🐝 VIBEE**: Рой автономных агентов-пчелок, работающих вместе для создания лучшего опыта

---

## ⚠️ КРИТИЧЕСКИ ВАЖНО

### 🎯 Функциональное программирование - ОСНОВА ВСЕГО

**ВЕСЬ КОД ДОЛЖЕН БЫТЬ В ФУНКЦИОНАЛЬНОМ СТИЛЕ!**

- ✅ **TaskEither**: Использовать `TaskEither<Error, Success>` для асинхронных операций
- ✅ **Either**: Использовать `Either<Error, Success>` для синхронных операций
- ✅ **pipe**: Использовать `pipe()` для композиции функций
- ✅ **Иммутабельность**: Все данные неизменяемы (immutable)
- ✅ **Чистые функции**: Функции без побочных эффектов
- ✅ **Side effects**: Только через `tap`/`tapTask`
- ❌ **НЕТ throw/catch**: Ошибки - это значения, не исключения
- ❌ **НЕТ мутаций**: Всегда создавать новые объекты
- ❌ **НЕТ побочных эффектов**: В чистых функциях

**Подробности**: См. раздел [Функциональное программирование - Основа всего](#0-функциональное-программирование---основа-всего) и [Лучшие практики функционального программирования](#-лучшие-практики-функционального-программирования)

### Формат кнопок главного меню

**Главное меню использует REPLY KEYBOARD (обычные кнопки под полем ввода), НЕ INLINE кнопки!**

- ✅ **Reply Keyboard**: Кнопки под полем ввода текста, обрабатываются через `bot.hears()` или `bot.on('text')`
- ❌ **Inline Keyboard**: Кнопки под сообщением, обрабатываются через `callback_query` - используется ТОЛЬКО внутри wizard'ов и для дополнительных опций

**Подробности**: См. раздел [Структура кнопок и их обработка](#-структура-кнопок-и-их-обработка)

### AI провайдер: OpenRouter API

**Все AI операции используют OpenRouter API, а не прямые API провайдеров!**

- ✅ **OpenRouter API**: Единый интерфейс для всех AI моделей (`https://openrouter.ai/api/v1`)
- ❌ **Прямые API**: Не использовать прямые вызовы OpenAI/Anthropic API
- ✅ **Drizzle ORM**: Использовать Drizzle ORM для всех операций с БД (не Supabase RPC)
- ✅ **Minimax M2**: Использовать модель Minimax M2 через OpenRouter API (топовая модель для кодирования и агентов)
- ✅ **Zod**: Использовать Zod для валидации всех данных (runtime type safety)
- 🔑 **API ключ**: Хранится в Infisical как `OPENROUTER_API_KEY`
- 📦 **Единый клиент**: Все функции используют клиент из `core/openai/index.ts`

**Подробности**: См. раздел [OpenRouter API: Единый провайдер AI моделей](#-openrouter-api-единый-провайдер-ai-моделей)

### 🧪 Тестирование (TDD)

**ВСЕ ФУНКЦИИ ДОЛЖНЫ БЫТЬ ПОКРЫТЫ ТЕСТАМИ!**

- ✅ **TDD**: Test-Driven Development - сначала тесты, потом код
- ✅ **100% покрытие**: Все функции должны быть покрыты тестами
- ✅ **Функциональное тестирование**: Тестирование чистых функций
- ✅ **Property-Based Testing**: Тестирование свойств функций
- ✅ **Функциональные моки**: Моки в функциональном стиле

**Подробности**: См. раздел [Тестирование в агентной разработке](#-тестирование-в-агентной-разработке-tdd--функциональный-стиль)

### 🔒 Валидация данных: Zod

**ВСЕ ДАННЫЕ ДОЛЖНЫ БЫТЬ ВАЛИДИРОВАНЫ ЧЕРЕЗ ZOD!**

- ✅ **Runtime валидация**: Проверка данных во время выполнения
- ✅ **Автоматическая типизация**: Генерация TypeScript типов из схем
- ✅ **Безопасность**: Защита от некорректных данных
- ✅ **Функциональный стиль**: Интеграция с `TaskEither` для обработки ошибок

**Подробности**: См. раздел [Валидация данных с Zod](#-валидация-данных-с-zod)

### 🐝 Роевой интеллект: Координация агентов

**МУЛЬТИАГЕНТНЫЙ ПОДХОД С КООРДИНАЦИЕЙ ЧЕРЕЗ РОЕВОЙ ИНТЕЛЛЕКТ!** 🐝

- ✅ **Координация агентов**: Рой агентов-пчелок с централизованной координацией через VIBE-QUEEN 🐝
- ✅ **Распределение задач**: Автоматическое распределение задач между агентами-пчелками 🐝
- ✅ **Масштабируемость**: Легкое добавление новых агентов-пчелок в рой 🐝
- ✅ **Отказоустойчивость**: Автоматическое переключение на резервных агентов-пчелок 🐝

**Подробности**: См. раздел [Роевой интеллект и координация агентов](#-роевой-интеллект-и-координация-агентов) 🐝

### 🤖 Автономная разработка: Self-Coding Agents

**83% КОДА ДОЛЖЕН ПИСАТЬСЯ САМИМИ АГЕНТАМИ!**

- ✅ **Self-Coding**: Агенты генерируют код для себя и других агентов
- ✅ **Self-Testing**: Агенты пишут тесты для своего кода
- ✅ **Self-Refactoring**: Агенты улучшают и оптимизируют свой код
- ✅ **Self-Deployment**: Агенты деплоят себя автоматически
- ✅ **Self-Learning**: Агенты учатся на ошибках и улучшаются

**Подробности**: См. раздел [Автономная разработка и паттерны самописных агентов](#-автономная-разработка-и-паттерны-самописных-агентов)

### 🔄 Автономный цикл агентов: Не выходить пока все тесты не пройдут!

**🚨 КРИТИЧЕСКИ ВАЖНО**: Агенты должны работать в непрерывном автономном цикле и НЕ ВЫХОДИТЬ из него, пока все тесты не пройдут!  
**💡 ПРОБЛЕМА**: Постоянно нажимать "продолжить" в Cursor - это недопустимо!  
**✅ РЕШЕНИЕ**: Агенты работают автономно в цикле до полного завершения задачи.

**Принципы автономного цикла**:
- ✅ **Непрерывный цикл**: Агент работает до полного завершения задачи
- ✅ **Автоматическое исправление**: При ошибках агент автоматически исправляет и продолжает
- ✅ **Проверка тестов**: Агент не выходит из цикла, пока все тесты не пройдут
- ✅ **Самостоятельное решение проблем**: Агент сам находит и исправляет ошибки
- ✅ **Без вмешательства**: Не требуется нажимать "продолжить" - все автоматически

**Подробности**: См. раздел [Автономный цикл агентов: Непрерывная разработка до успеха](#-автономный-цикл-агентов-непрерывная-разработка-до-успеха) 🐝

### 📏 Принцип "7 раз отмерь, один раз отрежь": Тщательное планирование перед действием

**🚨 КРИТИЧЕСКИ ВАЖНО**: Все агенты должны следовать принципу "7 раз отмерь, один раз отрежь"!  
**💡 ПРОБЛЕМА**: Поспешные действия без планирования приводят к ошибкам и переделкам!  
**✅ РЕШЕНИЕ**: Тщательное планирование и анализ перед каждым действием - обязательное требование для всех агентов.

**Принципы планирования**:
- ✅ **Анализ перед действием**: Агент должен проанализировать задачу перед началом работы
- ✅ **Поиск паттернов**: Искать существующие решения в кодовой базе перед созданием нового
- ✅ **Проверка зависимостей**: Убедиться, что все зависимости и требования понятны
- ✅ **Планирование шагов**: Составить детальный план выполнения перед началом
- ✅ **Валидация плана**: Проверить план на корректность и полноту
- ✅ **Один раз отрежь**: Только после тщательного планирования приступать к реализации

**Подробности**: См. раздел [Принцип "7 раз отмерь, один раз отрежь": Тщательное планирование](#-принцип-7-раз-отмерь-один-раз-отрежь-тщательное-планирование) 🐝

---

## 🌈 Радужный мост: Telegram-интерфейс для управления роем агентов

> **🎯 ФИЛОСОФИЯ**: Радужный мост - это Telegram-чат, через который вы управляете всем роем автономных агентов.  
> **💡 ИДЕЯ**: Разработка удаленно через Telegram (vibecoding) - без открытия редактора кода!  
> **🤖 АВТОНОМНОСТЬ**: Агенты сами разрабатывают, создают агент-сеть, общаются с вами через чат, сообщают статус.

---

### 🎯 Концепция "Радужного моста"

**Радужный мост** - это центральный Telegram-бот, через который вы:
- ✅ **Общаетесь с роем агентов** на естественном языке
- ✅ **Даете задачи** агентам через чат
- ✅ **Видите статус разработки** в реальном времени
- ✅ **Получаете уведомления** о важных событиях
- ✅ **Управляете агентами** через команды и кнопки
- ✅ **Разрабатываете удаленно** без открытия редактора кода
- ✅ **Видите прогресс** разработки через streaming updates
- ✅ **Одобряете критичные действия** через интерактивные кнопки

**Цель**: Полностью автономная разработка через Telegram-чат, где агенты работают сами, а вы управляете ими через "радужный мост".

---

### 🏗️ Архитектура "Радужного моста"

```
┌─────────────────────────────────────────────────┐
│         ВЫ (Админ) в Telegram                   │
│         "Радужный мост"                         │
└─────────────────────────────────────────────────┘
                    │
                    │ Telegram Bot API
                    │ (Постоянная связь)
                    │
                    ▼
┌─────────────────────────────────────────────────┐
│    VIBE-RAINBOW-BRIDGE (Центральный бот)       │
│    - Команды и кнопки                           │
│    - Streaming updates                          │
│    - Интерактивные диалоги                      │
│    - Управление роем агентов                   │
└─────────────────────────────────────────────────┘
                    │
        ┌───────────┼───────────┐
        │           │           │
        ▼           ▼           ▼
┌─────────────┐ ┌─────────────┐ ┌─────────────┐
│   VIBE-     │ │   VIBE-    │ │   VIBE-    │
│   QUEEN     │ │   SENTRY   │ │   ADMIN    │
│   (Рой)     │ │   (Логи)   │ │   COMM     │
└─────────────┘ └─────────────┘ └─────────────┘
        │           │           │
        └───────────┼───────────┘
                    │
                    ▼
        ┌───────────────────────┐
        │  Рой автономных        │
        │  агентов (VIBE-*)     │
        │  - Разработка          │
        │  - Тестирование        │
        │  - Деплой              │
        └───────────────────────┘
```

---

### 📱 Интерфейс "Радужного моста" в Telegram

#### Команды бота

```
/start - Начать работу с роем агентов
/status - Статус всех агентов
/agents - Список всех агентов
/tasks - Активные задачи
/logs - Последние логи
/approve - Одобрить ожидающие действия
/help - Помощь по командам
```

#### Интерактивные кнопки

**Главное меню**:
```
┌─────────────────────────────┐
│  🤖 Управление агентами     │
│  📊 Статус разработки       │
│  🎯 Создать задачу          │
│  📝 Логи и отчеты          │
│  ⚙️  Настройки              │
└─────────────────────────────┘
```

**Меню агента**:
```
┌─────────────────────────────┐
│  VIBE-SELF-CODING           │
│  ────────────────────────   │
│  ✅ Активен                  │
│  📊 Задач: 3                 │
│  ⏱️  Последняя: 2 мин назад  │
│                              │
│  [📋 Задачи] [📊 Статус]    │
│  [🛑 Остановить] [▶️ Запустить]│
└─────────────────────────────┘
```

---

### 💬 Примеры диалогов через "Радужный мост"

#### Пример 1: Создание нового агента

```
Вы: Создай новый агент VIBE-NEW-FEATURE для обработки данных

🤖 VIBE-QUEEN: Понял! Создаю агента VIBE-NEW-FEATURE...
   📋 Задача: Создание агента
   👷 Агенты: VIBE-SELF-CODING, VIBE-SELF-TESTING
   ⏱️  Оценка: 30 минут

[✅ Одобрить] [❌ Отменить] [✏️ Изменить]

Вы: [✅ Одобрить]

🤖 VIBE-SELF-CODING: Начинаю генерацию кода...
   📝 Создаю структуру агента...
   📝 Генерирую actions...
   📝 Генерирую providers...
   ✅ Код сгенерирован (5 файлов)

🤖 VIBE-SELF-TESTING: Запускаю тесты...
   ✅ Все тесты прошли (10/10)
   📊 Покрытие: 100%

🤖 VIBE-QUEEN: ✅ Агент VIBE-NEW-FEATURE успешно создан!
   📁 Файлы: 5
   🧪 Тесты: 10
   ⏱️  Время: 25 минут

[📋 Показать код] [🚀 Задеплоить] [📊 Детали]
```

#### Пример 2: Мониторинг разработки

```
Вы: /status

🤖 VIBE-RAINBOW-BRIDGE: Статус роя агентов:

┌─────────────────────────────────────┐
│ 🤖 VIBE-SELF-CODING                 │
│ ✅ Активен | Задач: 2                │
│ 📝 Генерирует код для VIBE-FEATURE-X│
│ ⏱️  Прогресс: 60% (15/25 мин)       │
└─────────────────────────────────────┘

┌─────────────────────────────────────┐
│ 🧪 VIBE-SELF-TESTING                │
│ ✅ Активен | Задач: 1                │
│ 🧪 Запускает тесты для VIBE-FEATURE-Y│
│ ⏱️  Прогресс: 80% (8/10 тестов)      │
└─────────────────────────────────────┘

┌─────────────────────────────────────┐
│ 🔧 VIBE-SELF-REFACTORING            │
│ ⏸️  Ожидает | Задач: 0              │
│ 💤 Ожидает задач                    │
└─────────────────────────────────────┘

📊 Всего: 3 активных, 1 ожидает
```

#### Пример 3: Streaming updates

```
Вы: Создай плагин для обработки изображений

🤖 VIBE-QUEEN: Начинаю создание плагина...
   👷 Назначил: VIBE-SELF-CODING

🤖 VIBE-SELF-CODING: 
   📝 [10%] Анализирую требования...
   📝 [30%] Генерирую структуру...
   📝 [50%] Создаю actions...
   📝 [70%] Создаю providers...
   📝 [90%] Добавляю валидацию...
   ✅ [100%] Плагин создан!

🤖 VIBE-SELF-TESTING:
   🧪 [20%] Генерирую тесты...
   🧪 [40%] Запускаю unit тесты...
   🧪 [60%] Запускаю integration тесты...
   🧪 [80%] Проверяю покрытие...
   ✅ [100%] Все тесты прошли!

🤖 VIBE-QUEEN: ✅ Плагин успешно создан!
   📁 Файлов: 8
   🧪 Тестов: 15
   📊 Покрытие: 100%
   ⏱️  Время: 18 минут

[📋 Показать код] [🚀 Задеплоить] [📊 Детали]
```

---

### 🤖 VIBE-RAINBOW-BRIDGE: Центральный Telegram-бот

#### Назначение

**VIBE-RAINBOW-BRIDGE** - это центральный Telegram-бот, который:
- ✅ Обеспечивает интерфейс для управления роем агентов
- ✅ Обрабатывает команды и сообщения от админа
- ✅ Отправляет streaming updates о прогрессе разработки
- ✅ Предоставляет интерактивные кнопки для управления
- ✅ Координирует работу всех агентов через VIBE-QUEEN
- ✅ Интегрируется с VIBE-ADMIN-COMMUNICATOR для уведомлений

#### Интерфейс VIBE-RAINBOW-BRIDGE

```typescript
interface VIBERainbowBridgeAgent {
  name: 'VIBE-RAINBOW-BRIDGE'
  version: '1.0.0'
  
  actions: {
    // === Команды ===
    // Обработка команды /start
    handleStart: (ctx: TelegramContext) => TaskEither<Error, void>
    
    // Обработка команды /status
    handleStatus: (ctx: TelegramContext) => TaskEither<Error, void>
    
    // Обработка команды /agents
    handleAgents: (ctx: TelegramContext) => TaskEither<Error, void>
    
    // Обработка команды /tasks
    handleTasks: (ctx: TelegramContext) => TaskEither<Error, void>
    
    // Обработка команды /logs
    handleLogs: (ctx: TelegramContext, agentName?: string) => TaskEither<Error, void>
    
    // Обработка команды /approve
    handleApprove: (ctx: TelegramContext) => TaskEither<Error, void>
    
    // === Естественный язык ===
    // Обработка сообщения на естественном языке
    handleNaturalLanguage: (message: string, ctx: TelegramContext) => TaskEither<Error, void>
    
    // Парсинг задачи из сообщения
    parseTask: (message: string) => TaskEither<Error, ParsedTask>
    
    // Распределение задачи по агентам
    distributeTask: (task: ParsedTask) => TaskEither<Error, TaskDistribution>
    
    // === Streaming updates ===
    // Отправка streaming update о прогрессе
    sendProgressUpdate: (update: ProgressUpdate) => TaskEither<Error, void>
    
    // Отправка финального результата
    sendFinalResult: (result: TaskResult) => TaskEither<Error, void>
    
    // === Интерактивные кнопки ===
    // Обработка callback от кнопок
    handleCallback: (callbackData: string, ctx: TelegramContext) => TaskEither<Error, void>
    
    // Создание интерактивной клавиатуры
    createKeyboard: (type: KeyboardType, data?: any) => TaskEither<Error, InlineKeyboardMarkup>
  }
  
  providers: {
    // Получение статуса всех агентов
    getAllAgentsStatus: () => TaskEither<Error, AgentStatus[]>
    
    // Получение активных задач
    getActiveTasks: () => TaskEither<Error, Task[]>
    
    // Получение логов агента
    getAgentLogs: (agentName: string, limit?: number) => TaskEither<Error, LogEntry[]>
    
    // Получение ожидающих одобрения действий
    getPendingApprovals: () => TaskEither<Error, ApprovalRequest[]>
  }
  
  services: {
    // Инициализация Telegram бота
    initTelegramBot: (token: string) => TaskEither<Error, void>
    
    // Подписка на события агентов
    subscribeToAgentEvents: () => TaskEither<Error, void>
    
    // Обработка streaming updates
    processStreamingUpdates: () => TaskEither<Error, void>
    
    // Форматирование сообщений
    formatMessage: (type: MessageType, data: any) => TaskEither<Error, string>
    
    // Отправка сообщения с форматированием
    sendFormattedMessage: (chatId: number, message: FormattedMessage) => TaskEither<Error, void>
  }
  
  config: {
    telegramBotToken: string
    adminChatId: number
    enableStreaming: boolean
    updateInterval: number // Интервал обновления статуса (мс)
    maxMessageLength: number // Максимальная длина сообщения
  }
}
```

---

### 📋 Сценарии использования "Радужного моста"

#### Сценарий 1: Создание нового агента через чат

```
Вы: Создай агента VIBE-DATA-PROCESSOR для обработки больших данных

🤖 VIBE-RAINBOW-BRIDGE: 
   📋 Задача: Создание агента VIBE-DATA-PROCESSOR
   🎯 Тип: Data Processing
   👷 Назначенные агенты:
      - VIBE-SELF-CODING (генерация кода)
      - VIBE-SELF-TESTING (тестирование)
      - VIBE-INFRASTRUCTURE-BUILDER (инфраструктура)
   ⏱️  Оценка: 45 минут
   
   [✅ Одобрить] [❌ Отменить] [✏️ Изменить требования]

Вы: [✅ Одобрить]

🤖 VIBE-SELF-CODING: Начинаю генерацию...
   📝 [20%] Анализирую требования...
   📝 [40%] Создаю структуру...
   📝 [60%] Генерирую код...
   📝 [80%] Добавляю валидацию...
   ✅ [100%] Код готов!

🤖 VIBE-SELF-TESTING: Запускаю тесты...
   🧪 [50%] Unit тесты...
   🧪 [100%] Integration тесты...
   ✅ Все тесты прошли!

🤖 VIBE-RAINBOW-BRIDGE: ✅ Агент создан!
   📁 Файлов: 12
   🧪 Тестов: 25
   📊 Покрытие: 100%
   ⏱️  Время: 38 минут
   
   [📋 Показать код] [🚀 Задеплоить] [📊 Детали] [🔄 Создать еще]
```

#### Сценарий 2: Мониторинг разработки в реальном времени

```
Вы: Что сейчас делают агенты?

🤖 VIBE-RAINBOW-BRIDGE: Активные задачи:

┌─────────────────────────────────────────┐
│ 🤖 VIBE-SELF-CODING                     │
│ ─────────────────────────────────────── │
│ 📋 Задача: Рефакторинг VIBE-PAYMENT     │
│ ⏱️  Прогресс: ████████░░ 75%            │
│ 📝 Текущий шаг: Оптимизация запросов    │
│ ⏱️  Осталось: ~5 минут                  │
└─────────────────────────────────────────┘

┌─────────────────────────────────────────┐
│ 🧪 VIBE-SELF-TESTING                    │
│ ─────────────────────────────────────── │
│ 📋 Задача: Тесты для VIBE-IMAGE         │
│ ⏱️  Прогресс: ██████░░░░ 60%            │
│ 🧪 Текущий шаг: Property-based тесты    │
│ ⏱️  Осталось: ~8 минут                  │
└─────────────────────────────────────────┘

📊 Всего активных задач: 2
⏱️  Среднее время выполнения: 12 минут
```

#### Сценарий 3: Одобрение критических действий

```
🤖 VIBE-SELF-DEPLOYMENT: 
   ⚠️ Требуется одобрение!
   
   📋 Действие: Деплой в production
   🎯 Изменения:
      - Новый агент VIBE-DATA-PROCESSOR
      - Обновление VIBE-PAYMENT-HANDLER
      - 15 новых тестов
   
   ✅ Тесты: Все прошли
   📊 Покрытие: 100%
   ⚠️ Риск: Низкий
   
   [✅ Одобрить] [❌ Отменить] [⏸️ Отложить]

Вы: [✅ Одобрить]

🤖 VIBE-SELF-DEPLOYMENT: Начинаю деплой...
   🚀 [20%] Подготовка...
   🚀 [40%] Сборка...
   🚀 [60%] Деплой...
   🚀 [80%] Проверка здоровья...
   ✅ [100%] Деплой завершен!

🤖 VIBE-RAINBOW-BRIDGE: ✅ Деплой успешен!
   🌐 URL: https://api.example.com
   ✅ Health check: OK
   📊 Метрики: Все в норме
```

---

### 🎨 Форматирование сообщений

#### Типы сообщений

**1. Статус агента**:
```markdown
🤖 VIBE-SELF-CODING
─────────────────────
✅ Статус: Активен
📋 Задач: 2
⏱️  Последняя активность: 2 мин назад
📊 Успешность: 98%
```

**2. Прогресс задачи**:
```markdown
📋 Задача: Создание агента VIBE-NEW-FEATURE
⏱️  Прогресс: ████████░░ 80%
📝 Текущий шаг: Генерация тестов
⏱️  Осталось: ~5 минут
```

**3. Результат выполнения**:
```markdown
✅ Задача завершена!
─────────────────────
📁 Файлов создано: 8
🧪 Тестов: 15
📊 Покрытие: 100%
⏱️  Время: 25 минут
```

**4. Ошибка**:
```markdown
❌ Ошибка при выполнении задачи
─────────────────────
🤖 Агент: VIBE-SELF-CODING
📋 Задача: Генерация кода
❌ Ошибка: TypeScript compilation failed
📝 Детали: [Показать логи]
```

---

### 🔗 Интеграция с другими агентами

**VIBE-RAINBOW-BRIDGE** интегрируется с:

1. **VIBE-QUEEN-COORDINATOR**: Получение статуса агентов и распределение задач
2. **VIBE-SENTRY**: Получение логов и ошибок для отображения
3. **VIBE-ADMIN-COMMUNICATOR**: Отправка уведомлений (через Rainbow Bridge)
4. **VIBE-SELF-CODING**: Получение прогресса генерации кода
5. **VIBE-SELF-TESTING**: Получение результатов тестов
6. **VIBE-SELF-DEPLOYMENT**: Получение статуса деплоя

---

### ✅ Чек-лист реализации "Радужного моста"

1. **Telegram Bot**:
   - [ ] Создать Telegram бота
   - [ ] Настроить команды (/start, /status, /agents, /tasks, /logs, /approve)
   - [ ] Реализовать обработку естественного языка
   - [ ] Добавить интерактивные кнопки

2. **Streaming Updates**:
   - [ ] Реализовать отправку прогресса в реальном времени
   - [ ] Добавить форматирование сообщений
   - [ ] Реализовать обновление сообщений (editMessage)

3. **Интеграция с агентами**:
   - [ ] Подключить VIBE-QUEEN для получения статуса
   - [ ] Подключить VIBE-SENTRY для получения логов
   - [ ] Подключить всех агентов для streaming updates

4. **Управление задачами**:
   - [ ] Реализовать создание задач через чат
   - [ ] Реализовать одобрение критических действий
   - [ ] Реализовать отмену задач

5. **Мониторинг**:
   - [ ] Реализовать отображение статуса всех агентов
   - [ ] Реализовать отображение активных задач
   - [ ] Реализовать отображение логов

---

**🌈 Радужный мост готов! Теперь вы можете управлять роем агентов-пчелок и разрабатывать удаленно через Telegram!** 🐝

---

## 🎨 UX/UI на высшем уровне: Анимации, забота о клиенте и геймификация

> **🐝 ФИЛОСОФИЯ VIBEE**: Каждое взаимодействие должно быть приятным, красивым и запоминающимся  
> **💎 ПРИНЦИП**: UX на высшем уровне - не примитивно, максимально анимации, забота о клиенте  
> **🎮 ГЕЙМИФИКАЦИЯ**: Превращаем разработку в увлекательную игру с достижениями и прогрессом

---

### 🎯 Концепция UX/UI в VIBEE

**VIBEE** - это не просто система агентов, это **экосистема с высочайшим уровнем UX/UI**:

- ✅ **Анимации везде**: Каждое действие сопровождается красивой анимацией
- ✅ **Прогресс-бары**: Визуализация прогресса выполнения задач
- ✅ **Эмодзи и визуальные элементы**: Пчелки 🐝, медальки 🏆, звездочки ⭐
- ✅ **Интерактивность**: Кнопки, меню, диалоги - все интерактивно
- ✅ **Геймификация**: Достижения, уровни, прогресс, награды
- ✅ **Забота о клиенте**: Персонализация, подсказки, помощь

**Цель**: Создать такой UX, чтобы пользователь получал удовольствие от работы с системой, как от игры! 🎮

---

### 🎬 Анимации и визуальные эффекты

#### Типы анимаций в Telegram

**1. Прогресс-бары с анимацией**:
```markdown
🤖 VIBE-SELF-CODING: Генерирую код...
   📝 [░░░░░░░░░░] 0%
   📝 [██░░░░░░░░] 20%
   📝 [████░░░░░░] 40%
   📝 [██████░░░░] 60%
   📝 [████████░░] 80%
   📝 [██████████] 100% ✅
```

**2. Анимированные эмодзи**:
```markdown
🐝 Пчелка работает...
   🐝→ 🐝→ 🐝→ ✅ Готово!
```

**3. Прогресс с пчелками**:
```markdown
🐝 Рой пчелок работает над задачей:
   🐝 [░░░░░░░░░░] 0 пчелок
   🐝🐝 [██░░░░░░░░] 2 пчелки
   🐝🐝🐝 [████░░░░░░] 4 пчелки
   🐝🐝🐝🐝 [██████░░░░] 6 пчелок
   🐝🐝🐝🐝🐝 [████████░░] 8 пчелок
   🐝🐝🐝🐝🐝🐝 [██████████] 10 пчелок ✅
```

**4. Анимация загрузки**:
```markdown
⏳ Загрузка...
   ⏳ → ⏳ → ⏳ → ✅ Готово!
```

**5. Анимация успеха**:
```markdown
✨ Задача выполнена!
   🎉 → 🏆 → ⭐ → ✅
```

#### Реализация анимаций

```typescript
// src/core/animations/progressBar.ts
export function createProgressBar(
  current: number,
  total: number,
  width: number = 10,
  filled: string = '█',
  empty: string = '░'
): string {
  const percentage = Math.round((current / total) * 100)
  const filledCount = Math.round((current / total) * width)
  const emptyCount = width - filledCount
  
  return `[${filled.repeat(filledCount)}${empty.repeat(emptyCount)}] ${percentage}%`
}

// src/core/animations/beeAnimation.ts
export function createBeeAnimation(progress: number): string {
  const beeCount = Math.min(Math.ceil(progress / 10), 10)
  const bees = '🐝'.repeat(beeCount)
  const empty = '░'.repeat(10 - beeCount)
  
  return `${bees} [${'█'.repeat(beeCount)}${empty}] ${Math.round(progress)}%`
}

// src/core/animations/loadingAnimation.ts
export const LOADING_FRAMES = ['⏳', '⏳', '⏳', '✅']
export const SUCCESS_FRAMES = ['✨', '🎉', '🏆', '⭐', '✅']
export const BEE_FRAMES = ['🐝', '🐝→', '🐝→', '🐝→', '✅']
```

---

### 🎮 Геймификация: Превращаем разработку в игру

#### Концепция геймификации

**Геймификация** - это превращение процесса разработки в увлекательную игру с:
- ✅ **Достижениями** (Achievements)
- ✅ **Уровнями** (Levels)
- ✅ **Очками опыта** (XP)
- ✅ **Наградами** (Rewards)
- ✅ **Лидербордом** (Leaderboard)
- ✅ **Прогрессом** (Progress)

#### Система достижений

```typescript
interface Achievement {
  id: string
  name: string
  description: string
  icon: string // Эмодзи
  category: 'development' | 'testing' | 'deployment' | 'learning'
  points: number // Очки за достижение
  rarity: 'common' | 'rare' | 'epic' | 'legendary'
  unlockedAt?: Date
}

// Примеры достижений
const ACHIEVEMENTS: Achievement[] = [
  {
    id: 'first-agent',
    name: 'Первый агент',
    description: 'Создал первого агента',
    icon: '🐝',
    category: 'development',
    points: 100,
    rarity: 'common'
  },
  {
    id: '100-tests',
    name: 'Мастер тестов',
    description: 'Написал 100 тестов',
    icon: '🧪',
    category: 'testing',
    points: 500,
    rarity: 'rare'
  },
  {
    id: 'perfect-coverage',
    name: 'Идеальное покрытие',
    description: 'Достиг 100% покрытия тестами',
    icon: '🏆',
    category: 'testing',
    points: 1000,
    rarity: 'epic'
  },
  {
    id: 'swarm-master',
    name: 'Мастер роя',
    description: 'Управляет роем из 10+ агентов',
    icon: '👑',
    category: 'development',
    points: 2000,
    rarity: 'legendary'
  }
]
```

#### Система уровней

```typescript
interface Level {
  level: number
  name: string
  icon: string
  xpRequired: number
  rewards: string[]
}

const LEVELS: Level[] = [
  { level: 1, name: 'Новичок', icon: '🌱', xpRequired: 0, rewards: [] },
  { level: 2, name: 'Ученик', icon: '📚', xpRequired: 100, rewards: ['🎁 Базовый набор инструментов'] },
  { level: 3, name: 'Разработчик', icon: '💻', xpRequired: 500, rewards: ['🎁 Расширенный набор инструментов'] },
  { level: 4, name: 'Эксперт', icon: '⭐', xpRequired: 1500, rewards: ['🎁 Профильный набор инструментов'] },
  { level: 5, name: 'Мастер', icon: '👑', xpRequired: 5000, rewards: ['🎁 Мастерский набор инструментов'] },
  { level: 6, name: 'Легенда', icon: '🐝👑', xpRequired: 15000, rewards: ['🎁 Легендарный набор инструментов'] }
]
```

#### Система очков опыта (XP)

```typescript
interface XPEvent {
  action: string
  points: number
  multiplier?: number // Множитель за сложность
}

const XP_EVENTS: Record<string, XPEvent> = {
  'agent.created': { action: 'Создание агента', points: 100 },
  'test.written': { action: 'Написание теста', points: 10 },
  'test.passed': { action: 'Тест прошел', points: 5 },
  'code.refactored': { action: 'Рефакторинг кода', points: 50 },
  'deployment.success': { action: 'Успешный деплой', points: 200 },
  'error.fixed': { action: 'Исправление ошибки', points: 25 },
  'achievement.unlocked': { action: 'Разблокировано достижение', points: 0 }, // Очки уже в достижении
}
```

#### Лидерборд

```markdown
🏆 Топ разработчиков VIBEE:

1. 👑 Вы (Админ)
   🐝 Уровень: Легенда (6)
   ⭐ XP: 15,234
   🏆 Достижений: 12/15
   📊 Прогресс: ██████████ 100%

2. 🤖 VIBE-SELF-CODING
   🐝 Уровень: Мастер (5)
   ⭐ XP: 8,456
   🏆 Достижений: 8/15
   📊 Прогресс: ████████░░ 80%

3. 🧪 VIBE-SELF-TESTING
   🐝 Уровень: Эксперт (4)
   ⭐ XP: 5,234
   🏆 Достижений: 6/15
   📊 Прогресс: ██████░░░░ 60%
```

#### Прогресс и статистика

```markdown
📊 Ваша статистика:

🐝 Всего агентов создано: 15
🧪 Всего тестов написано: 234
✅ Успешных деплоев: 45
🏆 Достижений разблокировано: 12/15
⭐ Всего XP заработано: 15,234
📈 Текущий уровень: Легенда (6)
🎯 До следующего уровня: 0 XP (Максимум!)

📊 Прогресс по категориям:
   💻 Разработка: ██████████ 100%
   🧪 Тестирование: ████████░░ 85%
   🚀 Деплой: ███████░░░ 70%
   📚 Обучение: ██████░░░░ 60%
```

---

### 💝 Забота о клиенте: Персонализация и помощь

#### Персонализация

**1. Приветствие с именем**:
```markdown
🐝 Привет, [Имя]! Добро пожаловать в VIBEE!
   Готов помочь тебе создать что-то удивительное! ✨
```

**2. Персональные рекомендации**:
```markdown
💡 Рекомендации для тебя:

   🎯 Попробуй создать агента для обработки данных
   📚 Изучи новый паттерн функционального программирования
   🏆 Разблокируй достижение "Мастер тестов" (осталось 5 тестов)
```

**3. История активности**:
```markdown
📜 Твоя активность сегодня:

   ✅ Создал агента VIBE-DATA-PROCESSOR
   ✅ Написал 15 тестов
   ✅ Задеплоил 2 функции
   ⭐ Заработал 450 XP
   🏆 Разблокировал достижение "Мастер тестов"
```

#### Подсказки и помощь

**1. Контекстные подсказки**:
```markdown
💡 Подсказка: Используй команду /status для просмотра статуса всех агентов
```

**2. Интерактивная помощь**:
```markdown
❓ Нужна помощь?

   [📚 Документация] [💬 Примеры] [🎮 Геймификация]
   [🏆 Достижения] [📊 Статистика] [⚙️ Настройки]
```

**3. Автоматические советы**:
```markdown
💡 Совет: Ты можешь ускорить разработку, используя несколько агентов одновременно!
   Попробуй: "Создай агента и сразу напиши для него тесты"
```

---

### 🎨 Визуальное оформление сообщений

#### Форматирование с пчелками

**1. Успешное выполнение**:
```markdown
🐝✅ Задача выполнена успешно!

   🐝 Рой пчелок работал над задачей
   ⏱️  Время: 25 минут
   📊 Эффективность: 95%
   
   🏆 Достижение разблокировано: "Быстрая разработка"
   ⭐ +50 XP
```

**2. Прогресс выполнения**:
```markdown
🐝 Работаю над задачей...

   🐝→ 🐝→ 🐝→ 🐝→ 🐝→
   📊 Прогресс: ████████░░ 80%
   ⏱️  Осталось: ~5 минут
```

**3. Ошибка с заботой**:
```markdown
🐝❌ Ой, что-то пошло не так!

   Но не переживай, я уже работаю над исправлением! 🐝
   📝 Ошибка: TypeScript compilation failed
   🔧 Решение: Проверяю типы...
   
   💡 Совет: Всегда запускай typecheck перед коммитом!
```

**4. Достижение**:
```markdown
🏆 ДОСТИЖЕНИЕ РАЗБЛОКИРОВАНО!

   🐝 "Мастер роя"
   👑 Управляешь роем из 10+ агентов
   
   ⭐ +2000 XP
   🎁 Награда: Расширенный набор инструментов
   
   [🎉 Поделиться] [📊 Статистика]
```

---

### 🎯 Примеры UX в действии

#### Пример 1: Создание агента с геймификацией

```
Вы: Создай агента VIBE-NEW-FEATURE

🤖 VIBE-RAINBOW-BRIDGE: 
   🐝 Отлично! Начинаю создание агента...
   
   📋 Задача: Создание агента VIBE-NEW-FEATURE
   🎯 Тип: Development
   👷 Агенты: VIBE-SELF-CODING, VIBE-SELF-TESTING
   ⏱️  Оценка: 30 минут
   
   🎮 Геймификация:
   ⭐ XP за выполнение: +150
   🏆 Возможное достижение: "Первый агент" (+100 XP)
   
   [✅ Одобрить] [❌ Отменить] [✏️ Изменить]

Вы: [✅ Одобрить]

🤖 VIBE-SELF-CODING: 
   🐝 Начинаю генерацию...
   
   📝 [░░░░░░░░░░] 0% → [██░░░░░░░░] 20% → [████░░░░░░] 40%
   📝 [██████░░░░] 60% → [████████░░] 80% → [██████████] 100% ✅
   
   ✅ Код сгенерирован!
   📁 Файлов: 5
   ⭐ +50 XP

🤖 VIBE-SELF-TESTING:
   🐝 Запускаю тесты...
   
   🧪 [░░░░░░░░░░] 0% → [██████████] 100% ✅
   
   ✅ Все тесты прошли!
   🧪 Тестов: 10
   📊 Покрытие: 100%
   ⭐ +50 XP

🤖 VIBE-RAINBOW-BRIDGE:
   🎉 Задача выполнена!
   
   📁 Файлов: 5
   🧪 Тестов: 10
   📊 Покрытие: 100%
   ⏱️  Время: 25 минут
   
   🎮 Геймификация:
   ⭐ Всего XP: +150
   🏆 Достижение разблокировано: "Первый агент" (+100 XP)
   📊 Общий XP: +250
   🐝 Уровень: Новичок → Ученик! (100/500 XP)
   
   [📋 Показать код] [🚀 Задеплоить] [🏆 Достижения] [📊 Статистика]
```

#### Пример 2: Мониторинг с визуализацией

```
Вы: /status

🤖 VIBE-RAINBOW-BRIDGE: Статус роя пчелок 🐝

┌─────────────────────────────────────────┐
│ 🤖 VIBE-SELF-CODING                    │
│ 🐝→ 🐝→ 🐝→ 🐝→ 🐝→                    │
│ ─────────────────────────────────────── │
│ ✅ Активен | Задач: 2                   │
│ 📋 Генерирует код для VIBE-FEATURE-X    │
│ ⏱️  Прогресс: ████████░░ 75%           │
│ ⏱️  Осталось: ~5 минут                 │
│ ⭐ XP заработано сегодня: 450          │
└─────────────────────────────────────────┘

┌─────────────────────────────────────────┐
│ 🧪 VIBE-SELF-TESTING                    │
│ 🐝→ 🐝→ 🐝→ 🐝→                         │
│ ─────────────────────────────────────── │
│ ✅ Активен | Задач: 1                   │
│ 🧪 Запускает тесты для VIBE-FEATURE-Y   │
│ ⏱️  Прогресс: ██████░░░░ 60%           │
│ ⏱️  Осталось: ~8 минут                 │
│ ⭐ XP заработано сегодня: 320           │
└─────────────────────────────────────────┘

📊 Статистика роя:
   🐝 Всего пчелок: 10
   ✅ Активных: 2
   ⏸️  Ожидает: 8
   ⭐ Всего XP сегодня: 1,234
   🏆 Достижений разблокировано: 3
```

#### Пример 3: Достижения и награды

```
🏆 НОВОЕ ДОСТИЖЕНИЕ!

   🐝 "Мастер тестов"
   🧪 Написал 100 тестов
   
   ⭐ +500 XP
   🎁 Награда: Расширенный набор инструментов тестирования
   
   📊 Прогресс к следующему достижению:
   🎯 "Идеальное покрытие" (100% покрытие)
   📊 Текущее покрытие: 95%
   📊 Осталось: 5%
   
   [🎉 Поделиться] [📊 Статистика] [🏆 Все достижения]
```

---

### 🎨 Дизайн-система VIBEE

#### Цветовая палитра (для будущих веб-интерфейсов)

```typescript
const VIBEE_COLORS = {
  primary: '#FFD700', // Золотой (мед)
  secondary: '#FFA500', // Оранжевый (пыльца)
  success: '#4CAF50', // Зеленый (успех)
  error: '#F44336', // Красный (ошибка)
  warning: '#FF9800', // Оранжевый (предупреждение)
  info: '#2196F3', // Синий (информация)
  bee: '#FFC107', // Желтый (пчелка)
}
```

#### Иконки и эмодзи

```typescript
const VIBEE_ICONS = {
  bee: '🐝',
  queen: '👑🐝',
  worker: '🐝',
  success: '✅',
  error: '❌',
  warning: '⚠️',
  info: '💡',
  achievement: '🏆',
  level: '⭐',
  xp: '⭐',
  progress: '📊',
  task: '📋',
  code: '💻',
  test: '🧪',
  deploy: '🚀',
  settings: '⚙️',
  help: '❓',
  stats: '📈',
  reward: '🎁',
  celebration: '🎉',
}
```

---

### 📱 Адаптивность и доступность

#### Адаптация под разные устройства

- ✅ **Мобильные устройства**: Компактные сообщения, большие кнопки
- ✅ **Планшеты**: Расширенная информация, больше деталей
- ✅ **Десктоп**: Полная информация, все детали

#### Доступность

- ✅ **Читаемость**: Четкий контраст, читаемые шрифты
- ✅ **Навигация**: Понятные команды, интуитивные кнопки
- ✅ **Обратная связь**: Всегда понятно, что происходит

---

### ✅ Чек-лист реализации UX/UI

1. **Анимации**:
   - [ ] Реализовать прогресс-бары с анимацией
   - [ ] Добавить анимации пчелок
   - [ ] Реализовать анимации загрузки
   - [ ] Добавить анимации успеха/ошибки

2. **Геймификация**:
   - [ ] Создать систему достижений
   - [ ] Реализовать систему уровней
   - [ ] Добавить систему XP
   - [ ] Создать лидерборд
   - [ ] Реализовать награды

3. **Забота о клиенте**:
   - [ ] Добавить персонализацию
   - [ ] Реализовать подсказки
   - [ ] Добавить контекстную помощь
   - [ ] Создать историю активности

4. **Визуальное оформление**:
   - [ ] Использовать пчелок везде 🐝
   - [ ] Добавить эмодзи для визуализации
   - [ ] Реализовать форматирование сообщений
   - [ ] Создать дизайн-систему

---

**🐝 UX/UI на высшем уровне готов! Теперь каждый пользователь будет получать удовольствие от работы с VIBEE!** 🎨✨

---

## 🔄 Автономный цикл агентов: Непрерывная разработка до успеха

> **🚨 КРИТИЧЕСКИ ВАЖНО**: Агенты должны работать в непрерывном автономном цикле и НЕ ВЫХОДИТЬ из него, пока все тесты не пройдут!  
> **💡 ПРОБЛЕМА**: Постоянно нажимать "продолжить" в Cursor - это недопустимо!  
> **✅ РЕШЕНИЕ**: Агенты работают автономно в цикле до полного завершения задачи без вмешательства пользователя.

---

### 🎯 Концепция автономного цикла

**Автономный цикл** - это непрерывный процесс работы агента, который:

1. ✅ **Принимает задачу** и начинает работу
2. ✅ **Генерирует код** автоматически
3. ✅ **Запускает тесты** автоматически
4. ✅ **Проверяет результаты** автоматически
5. ✅ **Исправляет ошибки** автоматически (если тесты не прошли)
6. ✅ **Повторяет цикл** до тех пор, пока все тесты не пройдут
7. ✅ **НЕ ВЫХОДИТ** из цикла до полного успеха
8. ✅ **Сообщает о результате** только после завершения

**Цель**: Полностью автономная работа без необходимости нажимать "продолжить" в Cursor! 🐝

---

### 🔄 Архитектура автономного цикла

```
┌─────────────────────────────────────────────────┐
│         Автономный цикл агента                 │
└─────────────────────────────────────────────────┘
                    │
                    ▼
        ┌───────────────────────┐
        │  1. Принятие задачи   │
        │  (Получение задачи)   │
        └───────────────────────┘
                    │
                    ▼
        ┌───────────────────────┐
        │  2. Генерация кода     │
        │  (VIBE-SELF-CODING)   │
        └───────────────────────┘
                    │
                    ▼
        ┌───────────────────────┐
        │  3. Запуск тестов      │
        │  (VIBE-SELF-TESTING)  │
        └───────────────────────┘
                    │
         ┌──────────┴──────────┐
         │                     │
    ✅ Все тесты      ❌ Есть ошибки
    прошли                    │
         │                     ▼
         │         ┌───────────────────────┐
         │         │  4. Анализ ошибок     │
         │         │  (VIBE-SELF-LEARNING)│
         │         └───────────────────────┘
         │                     │
         │                     ▼
         │         ┌───────────────────────┐
         │         │  5. Исправление       │
         │         │  (VIBE-SELF-CODING)   │
         │         └───────────────────────┘
         │                     │
         │                     └──► Возврат к шагу 2
         │
         ▼
┌───────────────────────┐
│  6. Успешное          │
│  завершение           │
│  (Сообщение админу)   │
└───────────────────────┘
```

---

### 🎯 Принципы автономного цикла

#### 1. Непрерывность

**Агент НЕ ВЫХОДИТ из цикла до успешного завершения**:

```typescript
async function autonomousLoop(task: Task): Promise<TaskResult> {
  let attempts = 0
  const maxAttempts = 10 // Максимум попыток
  
  while (attempts < maxAttempts) {
    attempts++
    
    // 1. Генерация кода
    const codeResult = await generateCode(task)
    if (codeResult.isLeft()) {
      // Ошибка генерации - исправляем и продолжаем
      await fixGenerationError(codeResult.value)
      continue // НЕ ВЫХОДИМ, продолжаем цикл
    }
    
    // 2. Запуск тестов
    const testResult = await runTests(codeResult.value)
    if (testResult.isLeft() || !testResult.value.allPassed) {
      // Тесты не прошли - анализируем и исправляем
      const errors = await analyzeTestErrors(testResult.value)
      await fixCodeErrors(codeResult.value, errors)
      continue // НЕ ВЫХОДИМ, продолжаем цикл
    }
    
    // 3. Все тесты прошли - УСПЕХ!
    return right({
      success: true,
      code: codeResult.value,
      tests: testResult.value,
      attempts,
    })
  }
  
  // Если достигнут максимум попыток - возвращаем ошибку
  return left(new Error(`Failed after ${maxAttempts} attempts`))
}
```

#### 2. Автоматическое исправление ошибок

**Агент автоматически исправляет ошибки и продолжает**:

```typescript
async function fixCodeErrors(
  code: GeneratedCode,
  errors: TestError[]
): Promise<TaskEither<Error, FixedCode>> {
  return pipe(
    // Анализируем ошибки
    analyzeErrors(errors),
    chain(errorAnalysis =>
      // Генерируем исправления
      generateFixes(code, errorAnalysis)
    ),
    chain(fixes =>
      // Применяем исправления
      applyFixes(code, fixes)
    ),
    chain(fixedCode =>
      // Проверяем, что исправления корректны
      validateFixes(fixedCode, errors)
    )
  )
}
```

#### 3. Проверка тестов перед выходом

**Агент НЕ ВЫХОДИТ, пока все тесты не пройдут**:

```typescript
async function ensureAllTestsPass(
  code: GeneratedCode
): Promise<TaskEither<Error, TestResult>> {
  return pipe(
    // Запускаем все тесты
    runAllTests(code),
    chain(testResult => {
      if (testResult.allPassed && testResult.coverage >= 100) {
        // Все тесты прошли и покрытие 100% - УСПЕХ!
        return right(testResult)
      } else {
        // Тесты не прошли или покрытие недостаточно - ОШИБКА
        return left(
          new Error(
            `Tests failed or coverage insufficient: ${testResult.failedTests.length} failed, coverage: ${testResult.coverage}%`
          )
        )
      }
    })
  )
}
```

#### 4. Самостоятельное решение проблем

**Агент сам находит и исправляет проблемы**:

```typescript
async function solveProblem(
  problem: Problem
): Promise<TaskEither<Error, Solution>> {
  return pipe(
    // Анализируем проблему
    analyzeProblem(problem),
    chain(analysis =>
      // Ищем похожие проблемы в истории
      findSimilarProblems(analysis)
    ),
    chain(similarProblems =>
      // Используем решения из истории или генерируем новые
      similarProblems.length > 0
        ? useExistingSolution(similarProblems[0])
        : generateNewSolution(analysis)
    ),
    chain(solution =>
      // Применяем решение
      applySolution(solution)
    ),
    chain(appliedSolution =>
      // Проверяем, что решение работает
      verifySolution(appliedSolution)
    )
  )
}
```

---

### 🔄 Реализация автономного цикла

#### Основной цикл агента

```typescript
// src/core/agent-loop/autonomousLoop.ts
import { TaskEither, right, left, tryCatchAsync } from '@/core/functional/utils/result'
import { pipe, chain, tap } from '@/core/functional/utils/composition'

interface AutonomousLoopConfig {
  maxAttempts: number // Максимум попыток (по умолчанию 10)
  maxIterations: number // Максимум итераций цикла (по умолчанию 50)
  testTimeout: number // Таймаут для тестов (мс)
  require100PercentCoverage: boolean // Требовать 100% покрытие
}

/**
 * Автономный цикл агента - работает до успешного завершения
 * НЕ ВЫХОДИТ из цикла, пока все тесты не пройдут!
 */
export async function autonomousAgentLoop<T>(
  task: Task,
  config: Partial<AutonomousLoopConfig> = {}
): Promise<TaskEither<Error, TaskResult>> {
  const finalConfig: AutonomousLoopConfig = {
    maxAttempts: 10,
    maxIterations: 50,
    testTimeout: 300000, // 5 минут
    require100PercentCoverage: true,
    ...config,
  }

  let iteration = 0
  let lastError: Error | null = null

  // НАЧИНАЕМ ЦИКЛ - НЕ ВЫХОДИМ ДО УСПЕХА!
  while (iteration < finalConfig.maxIterations) {
    iteration++

    // Логируем начало итерации
    await logIterationStart(iteration, task)

    const result = await runTaskEither(
      pipe(
        // 1. Генерируем код
        generateCode(task),
        chain(code =>
          pipe(
            // 2. Запускаем тесты
            runTests(code, finalConfig.testTimeout),
            chain(testResult => {
              // 3. Проверяем результаты тестов
              if (!testResult.allPassed) {
                // Тесты не прошли - анализируем ошибки
                return pipe(
                  analyzeTestErrors(testResult),
                  chain(errors =>
                    pipe(
                      // Генерируем исправления
                      generateFixes(code, errors),
                      chain(fixes =>
                        pipe(
                          // Применяем исправления
                          applyFixes(code, fixes),
                          // Возвращаем ошибку, чтобы цикл продолжился
                          chain(fixedCode =>
                            left(
                              new Error(
                                `Tests failed, fixed code generated. Iteration ${iteration}`
                              )
                            )
                          )
                        )
                      )
                    )
                  )
                )
              }

              // 4. Проверяем покрытие тестами
              if (
                finalConfig.require100PercentCoverage &&
                testResult.coverage < 100
              ) {
                // Покрытие недостаточно - генерируем дополнительные тесты
                return pipe(
                  generateAdditionalTests(code, testResult.coverage),
                  chain(additionalTests =>
                    pipe(
                      runTests(code, finalConfig.testTimeout),
                      // Возвращаем ошибку, чтобы цикл продолжился
                      chain(() =>
                        left(
                          new Error(
                            `Coverage insufficient: ${testResult.coverage}%. Generating additional tests. Iteration ${iteration}`
                          )
                        )
                      )
                    )
                  )
                )
              }

              // 5. ВСЕ ТЕСТЫ ПРОШЛИ И ПОКРЫТИЕ 100% - УСПЕХ!
              return right({
                success: true,
                code,
                tests: testResult,
                iterations: iteration,
                attempts: iteration,
              })
            })
          )
        )
      )
    )

    // Проверяем результат
    if (result.isRight()) {
      // УСПЕХ! Выходим из цикла
      await logSuccess(iteration, result.value)
      return right(result.value)
    } else {
      // Ошибка - сохраняем и продолжаем цикл
      lastError = result.value
      await logError(iteration, result.value)

      // Обновляем задачу с исправлениями
      task = updateTaskWithFixes(task, result.value)

      // ПРОДОЛЖАЕМ ЦИКЛ - НЕ ВЫХОДИМ!
      continue
    }
  }

  // Если достигнут максимум итераций - возвращаем ошибку
  return left(
    new Error(
      `Autonomous loop failed after ${finalConfig.maxIterations} iterations. Last error: ${lastError?.message}`
    )
  )
}
```

#### Интеграция с VIBE агентами

```typescript
// Пример использования в VIBE-SELF-CODING
export const VIBESelfCodingAgent: VIBEAgent = {
  name: 'VIBE-SELF-CODING',
  version: '1.0.0',

  actions: {
    generateAgent: async (spec: AgentSpec) => {
      // Используем автономный цикл
      return await autonomousAgentLoop(
        {
          type: 'generate-agent',
          spec,
          requirements: ['code', 'tests', 'documentation'],
        },
        {
          maxAttempts: 15, // Больше попыток для сложных задач
          require100PercentCoverage: true, // Обязательно 100% покрытие
        }
      )
    },
  },
}
```

---

### 🎯 Best Practices для автономного цикла

#### 1. Четкие критерии успеха

**Агент должен точно знать, когда задача выполнена**:

```typescript
interface SuccessCriteria {
  allTestsPass: boolean // Все тесты должны пройти
  coverage: number // Минимальное покрытие (100%)
  noErrors: boolean // Нет ошибок компиляции
  noWarnings: boolean // Нет критических предупреждений
  lintingPass: boolean // Линтинг проходит
  buildPass: boolean // Сборка проходит
}

function checkSuccessCriteria(
  result: TaskResult,
  criteria: SuccessCriteria
): boolean {
  return (
    result.tests.allPassed &&
    result.tests.coverage >= criteria.coverage &&
    result.build.success &&
    result.linting.success &&
    result.errors.length === 0
  )
}
```

#### 2. Умное исправление ошибок

**Агент должен понимать тип ошибки и исправлять соответственно**:

```typescript
async function fixError(
  error: Error,
  context: ErrorContext
): Promise<TaskEither<Error, FixedCode>> {
  // Определяем тип ошибки
  const errorType = classifyError(error)

  switch (errorType) {
    case 'COMPILATION_ERROR':
      return fixCompilationError(error, context)
    case 'TEST_FAILURE':
      return fixTestFailure(error, context)
    case 'TYPE_ERROR':
      return fixTypeError(error, context)
    case 'RUNTIME_ERROR':
      return fixRuntimeError(error, context)
    default:
      return analyzeAndFix(error, context)
  }
}
```

#### 3. Ограничение попыток с умом

**Не бесконечный цикл, но достаточно попыток**:

```typescript
interface LoopLimits {
  maxAttempts: number // Максимум попыток (10-20)
  maxIterations: number // Максимум итераций (50-100)
  maxTime: number // Максимальное время работы (часы)
  backoffStrategy: 'linear' | 'exponential' // Стратегия задержки
}

const DEFAULT_LIMITS: LoopLimits = {
  maxAttempts: 15,
  maxIterations: 50,
  maxTime: 2 * 60 * 60 * 1000, // 2 часа
  backoffStrategy: 'exponential', // Экспоненциальная задержка
}
```

#### 4. Логирование прогресса

**Агент должен логировать каждый шаг для прозрачности**:

```typescript
async function logIterationProgress(
  iteration: number,
  step: string,
  result: any
): Promise<void> {
  await VIBESentry.logActionStart({
    id: `iteration-${iteration}-${step}`,
    timestamp: new Date(),
    agent: {
      name: 'AUTONOMOUS-LOOP',
      version: '1.0.0',
      instanceId: process.env.AGENT_INSTANCE_ID || 'unknown',
    },
    action: {
      name: step,
      type: 'iteration',
      input: { iteration, step },
    },
    execution: {
      startedAt: new Date(),
      status: 'started',
    },
    tags: ['autonomous-loop', `iteration-${iteration}`, step],
    metadata: { result },
  })
}
```

---

### 🐝 Примеры автономного цикла в действии

#### Пример 1: Создание агента с автономным циклом

```
Вы: Создай агента VIBE-NEW-FEATURE

🤖 VIBE-SELF-CODING: Начинаю автономный цикл...
   🔄 Итерация 1: Генерирую код...
   ✅ Код сгенерирован
   🧪 Запускаю тесты...
   ❌ Тесты не прошли (3 ошибки)
   🔧 Анализирую ошибки...
   🔧 Исправляю ошибки...
   🔄 Итерация 2: Повторно запускаю тесты...
   ✅ Тесты прошли!
   📊 Проверяю покрытие: 95%
   📝 Генерирую дополнительные тесты...
   🔄 Итерация 3: Запускаю все тесты...
   ✅ Все тесты прошли!
   📊 Покрытие: 100%
   ✅ УСПЕХ! Задача выполнена за 3 итерации
   
   📁 Файлов: 8
   🧪 Тестов: 15
   📊 Покрытие: 100%
   ⏱️  Время: 12 минут
```

#### Пример 2: Автоматическое исправление ошибок

```
🤖 VIBE-SELF-CODING: Автономный цикл работает...

   🔄 Итерация 1:
   📝 Генерирую код...
   ✅ Код сгенерирован
   🧪 Запускаю тесты...
   ❌ Ошибка: TypeScript compilation failed
   🔍 Анализ: Отсутствует импорт типа
   🔧 Исправление: Добавляю импорт
   
   🔄 Итерация 2:
   🧪 Запускаю тесты...
   ❌ Ошибка: Test failed - assertion error
   🔍 Анализ: Неправильная логика в функции
   🔧 Исправление: Исправляю логику
   
   🔄 Итерация 3:
   🧪 Запускаю тесты...
   ✅ Все тесты прошли!
   📊 Покрытие: 100%
   ✅ УСПЕХ!
```

---

### ✅ Чек-лист реализации автономного цикла

1. **Основной цикл**:
   - [ ] Реализовать функцию `autonomousAgentLoop`
   - [ ] Добавить проверку критериев успеха
   - [ ] Реализовать ограничение попыток
   - [ ] Добавить логирование прогресса

2. **Исправление ошибок**:
   - [ ] Реализовать классификацию ошибок
   - [ ] Добавить автоматическое исправление
   - [ ] Реализовать поиск похожих решений
   - [ ] Добавить валидацию исправлений

3. **Проверка тестов**:
   - [ ] Реализовать запуск всех тестов
   - [ ] Добавить проверку покрытия
   - [ ] Реализовать генерацию дополнительных тестов
   - [ ] Добавить проверку всех критериев успеха

4. **Интеграция**:
   - [ ] Интегрировать с VIBE-SELF-CODING
   - [ ] Интегрировать с VIBE-SELF-TESTING
   - [ ] Интегрировать с VIBE-SENTRY для логирования
   - [ ] Интегрировать с VIBE-RAINBOW-BRIDGE для уведомлений

---

**🔄 Автономный цикл готов! Теперь агенты работают самостоятельно до полного успеха без необходимости нажимать "продолжить"!** 🐝

---

## 📏 Принцип "7 раз отмерь, один раз отрежь": Тщательное планирование

> **🚨 КРИТИЧЕСКИ ВАЖНО**: Все агенты VIBEE должны следовать принципу "7 раз отмерь, один раз отрежь"!  
> **💡 ПРОБЛЕМА**: Поспешные действия без планирования приводят к ошибкам, переделкам и потере времени!  
> **✅ РЕШЕНИЕ**: Тщательное планирование и анализ перед каждым действием - обязательное требование для всех агентов.

---

### 🎯 Концепция принципа

**"7 раз отмерь, один раз отрежь"** - это фундаментальный принцип работы всех агентов VIBEE:

1. ✅ **Анализ задачи** - понять что нужно сделать
2. ✅ **Поиск паттернов** - найти существующие решения
3. ✅ **Проверка зависимостей** - убедиться что все понятно
4. ✅ **Планирование шагов** - составить детальный план
5. ✅ **Валидация плана** - проверить план на корректность
6. ✅ **Проверка еще раз** - убедиться что ничего не упущено
7. ✅ **Финальная проверка** - последний раз проверить все
8. ✅ **Один раз отрежь** - только после всех проверок приступать к реализации

**Цель**: Избежать ошибок и переделок через тщательное планирование! 🐝

---

### 🔄 Цикл планирования агента

```
┌─────────────────────────────────────────────────┐
│         Принцип "7 раз отмерь"                 │
└─────────────────────────────────────────────────┘
                    │
                    ▼
        ┌───────────────────────┐
        │  1. Анализ задачи     │
        │  (Что нужно сделать?) │
        └───────────────────────┘
                    │
                    ▼
        ┌───────────────────────┐
        │  2. Поиск паттернов   │
        │  (Есть ли решения?)  │
        └───────────────────────┘
                    │
                    ▼
        ┌───────────────────────┐
        │  3. Проверка          │
        │  зависимостей        │
        └───────────────────────┘
                    │
                    ▼
        ┌───────────────────────┐
        │  4. Планирование      │
        │  шагов               │
        └───────────────────────┘
                    │
                    ▼
        ┌───────────────────────┐
        │  5. Валидация плана   │
        │  (Корректен ли план?) │
        └───────────────────────┘
                    │
                    ▼
        ┌───────────────────────┐
        │  6. Проверка еще раз   │
        │  (Что-то упущено?)   │
        └───────────────────────┘
                    │
                    ▼
        ┌───────────────────────┐
        │  7. Финальная         │
        │  проверка             │
        └───────────────────────┘
                    │
                    ▼
        ┌───────────────────────┐
        │  ОДИН РАЗ ОТРЕЖЬ!     │
        │  (Реализация)         │
        └───────────────────────┘
```

---

### 📋 Реализация принципа в коде

#### Функция планирования

```typescript
// src/core/planning/measureSevenTimes.ts
import { TaskEither, right, left } from '@/core/functional/utils/result'
import { pipe, chain } from '@/core/functional/utils/composition'

interface Task {
  description: string
  requirements: string[]
  context?: any
}

interface Plan {
  steps: PlanStep[]
  dependencies: string[]
  risks: string[]
  alternatives: string[]
  estimatedTime: number
  validation: ValidationResult
}

interface PlanStep {
  order: number
  description: string
  action: string
  expectedResult: string
  validation: string
}

interface ValidationResult {
  isValid: boolean
  issues: string[]
  warnings: string[]
}

/**
 * Принцип "7 раз отмерь, один раз отрежь"
 * Агент должен тщательно спланировать задачу перед выполнением
 */
export async function measureSevenTimes(
  task: Task
): Promise<TaskEither<Error, Plan>> {
  return pipe(
    // 1. Анализ задачи
    analyzeTask(task),
    chain(analysis =>
      // 2. Поиск паттернов
      pipe(
        findPatterns(analysis),
        chain(patterns =>
          // 3. Проверка зависимостей
          pipe(
            checkDependencies(analysis, patterns),
            chain(dependencies =>
              // 4. Планирование шагов
              pipe(
                planSteps(analysis, patterns, dependencies),
                chain(plan =>
                  // 5. Валидация плана
                  pipe(
                    validatePlan(plan),
                    chain(validation =>
                      // 6. Проверка еще раз
                      pipe(
                        doubleCheckPlan(plan, validation),
                        chain(doubleChecked =>
                          // 7. Финальная проверка
                          pipe(
                            finalCheck(doubleChecked),
                            chain(finalPlan =>
                              // Все проверки пройдены - план готов!
                              right(finalPlan)
                            )
                          )
                        )
                      )
                    )
                  )
                )
              )
            )
          )
        )
      )
    )
  )
}

/**
 * 1. Анализ задачи
 */
async function analyzeTask(task: Task): Promise<TaskEither<Error, TaskAnalysis>> {
  // Агент анализирует задачу:
  // - Что нужно сделать?
  // - Какие требования?
  // - Какой контекст?
  // - Какие ограничения?
  
  return right({
    goal: task.description,
    requirements: task.requirements,
    context: task.context,
    constraints: extractConstraints(task),
    successCriteria: defineSuccessCriteria(task),
  })
}

/**
 * 2. Поиск паттернов
 */
async function findPatterns(
  analysis: TaskAnalysis
): Promise<TaskEither<Error, FoundPatterns>> {
  // Агент ищет существующие решения:
  // - Похожие функции в кодовой базе
  // - Существующие паттерны
  // - Лучшие практики
  // - Примеры из документации
  
  return right({
    similarFunctions: await searchSimilarFunctions(analysis),
    existingPatterns: await findExistingPatterns(analysis),
    bestPractices: await findBestPractices(analysis),
    examples: await findExamples(analysis),
  })
}

/**
 * 3. Проверка зависимостей
 */
async function checkDependencies(
  analysis: TaskAnalysis,
  patterns: FoundPatterns
): Promise<TaskEither<Error, Dependencies>> {
  // Агент проверяет зависимости:
  // - Какие модули нужны?
  // - Какие функции используются?
  // - Какие типы данных?
  // - Какие внешние сервисы?
  
  return right({
    requiredModules: extractRequiredModules(analysis, patterns),
    requiredFunctions: extractRequiredFunctions(analysis, patterns),
    requiredTypes: extractRequiredTypes(analysis, patterns),
    externalServices: extractExternalServices(analysis, patterns),
    allAvailable: await verifyAllDependenciesAvailable(),
  })
}

/**
 * 4. Планирование шагов
 */
async function planSteps(
  analysis: TaskAnalysis,
  patterns: FoundPatterns,
  dependencies: Dependencies
): Promise<TaskEither<Error, Plan>> {
  // Агент составляет детальный план:
  // - Какие шаги нужны?
  // - В каком порядке?
  // - Что ожидается на каждом шаге?
  // - Как валидировать каждый шаг?
  
  return right({
    steps: generatePlanSteps(analysis, patterns, dependencies),
    dependencies: dependencies.requiredModules,
    risks: identifyRisks(analysis, patterns, dependencies),
    alternatives: identifyAlternatives(analysis, patterns),
    estimatedTime: estimateTime(analysis, patterns),
    validation: { isValid: false, issues: [], warnings: [] }, // Будет заполнено на шаге 5
  })
}

/**
 * 5. Валидация плана
 */
async function validatePlan(plan: Plan): Promise<TaskEither<Error, Plan>> {
  // Агент валидирует план:
  // - Все ли шаги корректны?
  // - Есть ли логические ошибки?
  // - Все ли зависимости учтены?
  // - Реализуемы ли шаги?
  
  const validation = {
    isValid: true,
    issues: [] as string[],
    warnings: [] as string[],
  }
  
  // Проверка корректности шагов
  for (const step of plan.steps) {
    if (!step.description || !step.action) {
      validation.issues.push(`Step ${step.order} is incomplete`)
      validation.isValid = false
    }
  }
  
  // Проверка зависимостей
  for (const dep of plan.dependencies) {
    if (!await isDependencyAvailable(dep)) {
      validation.issues.push(`Dependency ${dep} is not available`)
      validation.isValid = false
    }
  }
  
  // Проверка рисков
  if (plan.risks.length > 0) {
    validation.warnings.push(`Plan has ${plan.risks.length} identified risks`)
  }
  
  return right({
    ...plan,
    validation,
  })
}

/**
 * 6. Проверка еще раз
 */
async function doubleCheckPlan(
  plan: Plan,
  validation: ValidationResult
): Promise<TaskEither<Error, Plan>> {
  // Агент проверяет план еще раз:
  // - Не упущено ли что-то?
  // - Все ли альтернативы рассмотрены?
  // - Правильно ли оценено время?
  // - Есть ли более эффективный способ?
  
  const doubleCheck = {
    ...validation,
    issues: [...validation.issues],
    warnings: [...validation.warnings],
  }
  
  // Проверка полноты плана
  if (plan.steps.length === 0) {
    doubleCheck.issues.push('Plan has no steps')
    doubleCheck.isValid = false
  }
  
  // Проверка альтернатив
  if (plan.alternatives.length === 0) {
    doubleCheck.warnings.push('No alternatives considered')
  }
  
  // Проверка оценки времени
  if (plan.estimatedTime <= 0) {
    doubleCheck.warnings.push('Time estimation seems incorrect')
  }
  
  return right({
    ...plan,
    validation: doubleCheck,
  })
}

/**
 * 7. Финальная проверка
 */
async function finalCheck(plan: Plan): Promise<TaskEither<Error, Plan>> {
  // Агент делает финальную проверку:
  // - Все ли 7 шагов выполнены?
  // - План валиден?
  // - Готов ли к реализации?
  
  if (!plan.validation.isValid) {
    return left(
      new Error(
        `Plan validation failed: ${plan.validation.issues.join(', ')}`
      )
    )
  }
  
  if (plan.validation.warnings.length > 0) {
    // Предупреждения не блокируют, но логируем
    console.warn('Plan has warnings:', plan.validation.warnings)
  }
  
  // План готов к реализации!
  return right(plan)
}
```

#### Использование в агентах

```typescript
// Пример использования в VIBE-SELF-CODING
export const VIBESelfCodingAgent: VIBEAgent = {
  name: 'VIBE-SELF-CODING',
  version: '1.0.0',

  actions: {
    generateCode: async (spec: CodeSpec) => {
      // 1. СЛЕДУЕМ ПРИНЦИПУ "7 РАЗ ОТМЕРЬ"
      const planResult = await measureSevenTimes({
        description: `Generate code for: ${spec.description}`,
        requirements: spec.requirements,
        context: spec.context,
      })

      if (planResult.isLeft()) {
        return left(planResult.value)
      }

      const plan = planResult.value

      // 2. ТОЛЬКО ПОСЛЕ ПЛАНИРОВАНИЯ - "ОДИН РАЗ ОТРЕЖЬ"
      return await executePlan(plan)
    },
  },
}
```

---

### 🎯 Правила применения принципа

#### Обязательные шаги для каждого агента

1. **Анализ задачи** (обязательно):
   ```typescript
   // Агент ДОЛЖЕН проанализировать задачу перед действием
   const analysis = await analyzeTask(task)
   if (analysis.isLeft()) {
     return left(analysis.value) // Не продолжаем без анализа
   }
   ```

2. **Поиск паттернов** (обязательно):
   ```typescript
   // Агент ДОЛЖЕН искать существующие решения
   const patterns = await findPatterns(analysis.value)
   if (patterns.isLeft()) {
     return left(patterns.value) // Не продолжаем без поиска
   }
   ```

3. **Проверка зависимостей** (обязательно):
   ```typescript
   // Агент ДОЛЖЕН проверить зависимости
   const dependencies = await checkDependencies(analysis.value, patterns.value)
   if (!dependencies.value.allAvailable) {
     return left(new Error('Dependencies not available'))
   }
   ```

4. **Планирование шагов** (обязательно):
   ```typescript
   // Агент ДОЛЖЕН составить план
   const plan = await planSteps(analysis.value, patterns.value, dependencies.value)
   ```

5. **Валидация плана** (обязательно):
   ```typescript
   // Агент ДОЛЖЕН валидировать план
   const validated = await validatePlan(plan.value)
   if (!validated.value.validation.isValid) {
     return left(new Error('Plan validation failed'))
   }
   ```

6. **Проверка еще раз** (обязательно):
   ```typescript
   // Агент ДОЛЖЕН проверить план еще раз
   const doubleChecked = await doubleCheckPlan(validated.value)
   ```

7. **Финальная проверка** (обязательно):
   ```typescript
   // Агент ДОЛЖЕН сделать финальную проверку
   const final = await finalCheck(doubleChecked.value)
   if (final.isLeft()) {
     return left(final.value) // Не продолжаем без финальной проверки
   }
   ```

8. **Один раз отрежь** (только после всех проверок):
   ```typescript
   // ТОЛЬКО ПОСЛЕ ВСЕХ ПРОВЕРОК - выполняем план
   return await executePlan(final.value)
   ```

---

### 🐝 Примеры применения принципа

#### Пример 1: Создание нового плагина

```
🤖 VIBE-SELF-CODING: Получена задача создать плагин VIBE-NEW-FEATURE

📏 ШАГ 1: Анализ задачи
   ✅ Цель: Создать плагин для новой функции
   ✅ Требования: [список требований]
   ✅ Контекст: [контекст задачи]

📏 ШАГ 2: Поиск паттернов
   🔍 Ищу похожие плагины...
   ✅ Найдено 5 похожих плагинов
   ✅ Найдены паттерны из ElizaOS документации
   ✅ Найдены лучшие практики

📏 ШАГ 3: Проверка зависимостей
   ✅ Все зависимости доступны
   ✅ Типы данных определены
   ✅ Внешние сервисы доступны

📏 ШАГ 4: Планирование шагов
   ✅ Шаг 1: Создать структуру плагина
   ✅ Шаг 2: Реализовать actions
   ✅ Шаг 3: Реализовать providers
   ✅ Шаг 4: Реализовать services
   ✅ Шаг 5: Добавить тесты
   ✅ Шаг 6: Добавить документацию

📏 ШАГ 5: Валидация плана
   ✅ Все шаги корректны
   ✅ Зависимости учтены
   ✅ План реализуем

📏 ШАГ 6: Проверка еще раз
   ✅ Ничего не упущено
   ✅ Альтернативы рассмотрены
   ✅ Время оценено правильно

📏 ШАГ 7: Финальная проверка
   ✅ План валиден
   ✅ Готов к реализации

✂️ ОДИН РАЗ ОТРЕЖЬ: Начинаю реализацию...
```

#### Пример 2: Исправление ошибки

```
🤖 VIBE-SELF-CODING: Получена задача исправить ошибку TypeScript

📏 ШАГ 1: Анализ задачи
   ✅ Ошибка: Type 'X' is not assignable to type 'Y'
   ✅ Файл: src/example.ts:42
   ✅ Контекст: [контекст ошибки]

📏 ШАГ 2: Поиск паттернов
   🔍 Ищу похожие ошибки...
   ✅ Найдено 3 похожих случая в истории
   ✅ Найдены решения в SUCCESS_HISTORY.md
   ✅ Найдены анти-паттерны в REGRESSION_PATTERNS.md

📏 ШАГ 3: Проверка зависимостей
   ✅ Типы определены
   ✅ Импорты корректны
   ✅ Зависимости доступны

📏 ШАГ 4: Планирование шагов
   ✅ Шаг 1: Проанализировать типы
   ✅ Шаг 2: Найти причину несовместимости
   ✅ Шаг 3: Выбрать решение (из истории или новое)
   ✅ Шаг 4: Применить исправление
   ✅ Шаг 5: Проверить типы
   ✅ Шаг 6: Запустить тесты

📏 ШАГ 5: Валидация плана
   ✅ План корректен
   ✅ Решение из истории проверено

📏 ШАГ 6: Проверка еще раз
   ✅ Все шаги учтены
   ✅ Альтернативные решения рассмотрены

📏 ШАГ 7: Финальная проверка
   ✅ План валиден
   ✅ Готов к реализации

✂️ ОДИН РАЗ ОТРЕЖЬ: Применяю исправление...
```

---

### ✅ Чек-лист реализации принципа

1. **Интеграция в агентов**:
   - [ ] Добавить функцию `measureSevenTimes` в каждый агент
   - [ ] Обязать агентов использовать планирование перед действием
   - [ ] Добавить валидацию плана перед выполнением

2. **Функции планирования**:
   - [ ] Реализовать `analyzeTask`
   - [ ] Реализовать `findPatterns`
   - [ ] Реализовать `checkDependencies`
   - [ ] Реализовать `planSteps`
   - [ ] Реализовать `validatePlan`
   - [ ] Реализовать `doubleCheckPlan`
   - [ ] Реализовать `finalCheck`

3. **Интеграция с существующими системами**:
   - [ ] Интегрировать с поиском по кодовой базе
   - [ ] Интегрировать с SUCCESS_HISTORY.md
   - [ ] Интегрировать с REGRESSION_PATTERNS.md
   - [ ] Интегрировать с VIBE-SENTRY для логирования

4. **Валидация**:
   - [ ] Добавить проверку что агент следует принципу
   - [ ] Логировать все шаги планирования
   - [ ] Предупреждать если агент пропустил шаги

---

**📏 Принцип "7 раз отмерь, один раз отрежь" заложен! Теперь все агенты тщательно планируют перед действием!** 🐝

---

## 📚 VIBE-KNOWLEDGE-KEEPER: Хранитель порядка и знаний репозитория

> **🚨 КРИТИЧЕСКИ ВАЖНО**: Агент-хранитель следит за порядком в репозитории и поддерживает документацию свежей!  
> **📊 ЦЕЛЬ**: Постоянная синхронизация документации, векторное представление проекта, полное понимание проекта агентами  
> **🔍 ФИЛОСОФИЯ**: Репозиторий - это живой организм, требующий постоянного ухода и обновления знаний

---

### 🎯 Концепция VIBE-KNOWLEDGE-KEEPER

**VIBE-KNOWLEDGE-KEEPER** - это специализированный агент, который:

- ✅ **Следит за порядком**: Проверяет структуру репозитория, соответствие стандартам
- ✅ **Синхронизирует документацию**: Автоматически обновляет документацию при изменениях кода
- ✅ **Поддерживает свежесть**: Отслеживает устаревшие документы и обновляет их
- ✅ **Создает векторное представление**: Генерирует embeddings для всего проекта
- ✅ **Обеспечивает понимание**: Агенты всегда имеют актуальное представление о проекте
- ✅ **Индексирует код**: Создает поисковый индекс для быстрого поиска по кодовой базе

**Цель**: Репозиторий всегда в порядке, документация свежая, агенты понимают весь проект! 🐝

---

### 🏗️ Архитектура VIBE-KNOWLEDGE-KEEPER

```
┌─────────────────────────────────────────────────┐
│    Репозиторий (Git)                           │
│    - Код                                        │
│    - Документация                              │
│    - Конфигурация                              │
└─────────────────────────────────────────────────┘
                    │
                    ▼
        ┌───────────────────────┐
        │  VIBE-KNOWLEDGE-      │
        │  KEEPER               │
        │  (Хранитель порядка)  │
        └───────────────────────┘
                    │
        ┌───────────┼───────────┐
        │           │           │
        ▼           ▼           ▼
┌─────────────┐ ┌─────────────┐ ┌─────────────┐
│  Repository │ │  Document   │ │  Vector     │
│  Guardian   │ │  Sync       │ │  Index      │
└─────────────┘ └─────────────┘ └─────────────┘
        │           │           │
        └───────────┼───────────┘
                    │
                    ▼
        ┌───────────────────────┐
        │  Knowledge Base        │
        │  (Vector DB + Docs)   │
        └───────────────────────┘
```

---

### 📊 VIBE-KNOWLEDGE-KEEPER: Интерфейс агента

```typescript
// src/agents/vibe-knowledge-keeper/index.ts
import { VIBEAgent } from '@/core/vibe/types'
import { TaskEither } from '@/core/functional/utils/result'

export const VIBEKnowledgeKeeperAgent: VIBEAgent = {
  name: 'VIBE-KNOWLEDGE-KEEPER',
  version: '1.0.0',
  description: 'Хранитель порядка и знаний репозитория. Синхронизирует документацию, создает векторное представление, обеспечивает понимание проекта агентами.',
  
  actions: {
    /**
     * Проверка порядка в репозитории
     */
    checkRepositoryOrder: async (): Promise<TaskEither<Error, RepositoryOrderReport>> => {
      // Проверяет:
      // - Структуру директорий
      // - Соответствие стандартам
      // - Наличие необходимых файлов
      // - Консистентность документации
    },
    
    /**
     * Синхронизация документации с кодом
     */
    syncDocumentation: async (options?: {
      files?: string[] // Конкретные файлы для синхронизации
      force?: boolean // Принудительная синхронизация
    }): Promise<TaskEither<Error, SyncReport>> => {
      // Синхронизирует:
      // - FUNCTIONALITY_DOCUMENTATION.md с кодом
      // - README.md с актуальным состоянием
      // - Комментарии в коде с документацией
      // - Типы и интерфейсы с документацией
    },
    
    /**
     * Обновление устаревшей документации
     */
    updateStaleDocumentation: async (): Promise<TaskEither<Error, UpdateReport>> => {
      // Находит и обновляет:
      // - Устаревшие разделы документации
      // - Неактуальные примеры
      // - Устаревшие ссылки
      // - Несоответствия с кодом
    },
    
    /**
     * Создание векторного представления проекта
     */
    createVectorIndex: async (options?: {
      incremental?: boolean // Инкрементальное обновление
      files?: string[] // Конкретные файлы для индексации
    }): Promise<TaskEither<Error, VectorIndexReport>> => {
      // Создает:
      // - Embeddings для всех файлов
      // - Векторный индекс для поиска
      // - Семантический поиск по проекту
      // - Контекст для агентов
    },
    
    /**
     * Поиск по векторному индексу
     */
    searchVectorIndex: async (query: string, options?: {
      limit?: number
      threshold?: number
    }): Promise<TaskEither<Error, SearchResult[]>> => {
      // Ищет:
      // - Похожий код
      // - Похожую документацию
      // - Похожие паттерны
      // - Контекст для задач
    },
    
    /**
     * Получение контекста проекта для агента
     */
    getProjectContext: async (task: string): Promise<TaskEither<Error, ProjectContext>> => {
      // Предоставляет:
      // - Релевантные файлы
      // - Похожие паттерны
      // - Документацию
      // - Историю изменений
    },
  },
  
  providers: {
    /**
     * Предоставляет актуальную информацию о проекте
     */
    getProjectInfo: async (): Promise<TaskEither<Error, ProjectInfo>> => {
      // Возвращает:
      // - Структуру проекта
      // - Актуальную документацию
      // - Статистику проекта
      // - Состояние репозитория
    },
  },
  
  services: {
    /**
     * Фоновый сервис синхронизации
     */
    syncService: {
      initialize: async () => {
        // Запускает периодическую синхронизацию
        setInterval(async () => {
          await syncDocumentation()
          await createVectorIndex({ incremental: true })
        }, 60 * 60 * 1000) // Каждый час
      },
    },
  },
}
```

---

### 📋 Реализация функций

#### 1. Проверка порядка в репозитории

```typescript
// src/agents/vibe-knowledge-keeper/repository-guardian.ts
import { TaskEither, right, left } from '@/core/functional/utils/result'
import { pipe, chain } from '@/core/functional/utils/composition'
import { readFile, listDir } from '@/core/fs/utils'
import { glob } from 'glob'

interface RepositoryOrderReport {
  isValid: boolean
  issues: RepositoryIssue[]
  warnings: RepositoryWarning[]
  structure: RepositoryStructure
}

interface RepositoryIssue {
  type: 'missing_file' | 'wrong_structure' | 'outdated_doc' | 'inconsistent'
  severity: 'error' | 'warning'
  file?: string
  message: string
  suggestion?: string
}

export async function checkRepositoryOrder(): Promise<TaskEither<Error, RepositoryOrderReport>> {
  return pipe(
    // Проверяем структуру директорий
    checkDirectoryStructure(),
    chain(structure =>
      pipe(
        // Проверяем наличие обязательных файлов
        checkRequiredFiles(),
        chain(requiredFiles =>
          pipe(
            // Проверяем консистентность документации
            checkDocumentationConsistency(),
            chain(docs =>
              pipe(
                // Проверяем соответствие стандартам
                checkStandardsCompliance(),
                chain(standards =>
                  // Формируем отчет
                  right({
                    isValid: 
                      requiredFiles.issues.length === 0 &&
                      docs.issues.length === 0 &&
                      standards.issues.length === 0,
                    issues: [
                      ...requiredFiles.issues,
                      ...docs.issues,
                      ...standards.issues,
                    ],
                    warnings: [
                      ...requiredFiles.warnings,
                      ...docs.warnings,
                      ...standards.warnings,
                    ],
                    structure,
                  })
                )
              )
            )
          )
        )
      )
    )
  )
}

async function checkDirectoryStructure(): Promise<TaskEither<Error, RepositoryStructure>> {
  const requiredDirs = [
    'src',
    'src/scenes',
    'src/services',
    'src/core',
    'src/helpers',
    '.claude',
    '.claude/skills',
    '.claude/agents',
  ]
  
  const structure: RepositoryStructure = {
    directories: {},
    files: {},
  }
  
  for (const dir of requiredDirs) {
    const exists = await checkDirectoryExists(dir)
    structure.directories[dir] = exists
  }
  
  return right(structure)
}

async function checkRequiredFiles(): Promise<TaskEither<Error, { issues: RepositoryIssue[], warnings: RepositoryWarning[] }>> {
  const requiredFiles = [
    'FUNCTIONALITY_DOCUMENTATION.md',
    'README.md',
    'package.json',
    'tsconfig.json',
    'SUCCESS_HISTORY.md',
    'REGRESSION_PATTERNS.md',
    '.cursor/rules/current_task.mdc',
  ]
  
  const issues: RepositoryIssue[] = []
  const warnings: RepositoryWarning[] = []
  
  for (const file of requiredFiles) {
    const exists = await checkFileExists(file)
    if (!exists) {
      issues.push({
        type: 'missing_file',
        severity: 'error',
        file,
        message: `Required file ${file} is missing`,
        suggestion: `Create ${file} with appropriate content`,
      })
    }
  }
  
  return right({ issues, warnings })
}
```

#### 2. Синхронизация документации

```typescript
// src/agents/vibe-knowledge-keeper/document-sync.ts
import { TaskEither, right, left } from '@/core/functional/utils/result'
import { pipe, chain } from '@/core/functional/utils/composition'
import { readFile, writeFile } from '@/core/fs/utils'
import { parseCodebase } from '@/core/parsers/codebase-parser'
import { generateDocumentation } from '@/core/generators/doc-generator'

export async function syncDocumentation(
  options?: { files?: string[]; force?: boolean }
): Promise<TaskEither<Error, SyncReport>> {
  return pipe(
    // Парсим кодовую базу
    parseCodebase(options?.files),
    chain(codebase =>
      pipe(
        // Генерируем документацию
        generateDocumentation(codebase),
        chain(docs =>
          pipe(
            // Обновляем FUNCTIONALITY_DOCUMENTATION.md
            updateFunctionalityDocumentation(docs),
            chain(() =>
              pipe(
                // Обновляем README.md
                updateReadme(docs),
                chain(() =>
                  pipe(
                    // Обновляем комментарии в коде
                    updateCodeComments(docs),
                    chain(() =>
                      // Формируем отчет
                      right({
                        success: true,
                        filesUpdated: docs.files.length,
                        sectionsUpdated: docs.sections.length,
                        timestamp: new Date(),
                      })
                    )
                  )
                )
              )
            )
          )
        )
      )
    )
  )
}

async function updateFunctionalityDocumentation(
  docs: GeneratedDocumentation
): Promise<TaskEither<Error, void>> {
  // Читаем текущую документацию
  const currentDoc = await readFile('FUNCTIONALITY_DOCUMENTATION.md')
  
  // Обновляем разделы на основе кода
  const updatedDoc = mergeDocumentation(currentDoc, docs)
  
  // Сохраняем обновленную документацию
  await writeFile('FUNCTIONALITY_DOCUMENTATION.md', updatedDoc)
  
  return right(undefined)
}
```

#### 3. Создание векторного индекса

```typescript
// src/agents/vibe-knowledge-keeper/vector-index.ts
import { TaskEither, right, left } from '@/core/functional/utils/result'
import { pipe, chain } from '@/core/functional/utils/composition'
import { createEmbeddings } from '@/core/embeddings/ollama-embeddings'
import { db } from '@/core/drizzle/client'
import { vectorIndex } from '@/core/drizzle/schema'

export async function createVectorIndex(
  options?: { incremental?: boolean; files?: string[] }
): Promise<TaskEither<Error, VectorIndexReport>> {
  return pipe(
    // Получаем файлы для индексации
    getFilesToIndex(options),
    chain(files =>
      pipe(
        // Читаем содержимое файлов
        readFilesContent(files),
        chain(contents =>
          pipe(
            // Создаем chunks для индексации
            createChunks(contents),
            chain(chunks =>
              pipe(
                // Генерируем embeddings
                generateEmbeddings(chunks),
                chain(embeddings =>
                  pipe(
                    // Сохраняем в векторную БД
                    saveToVectorDB(embeddings),
                    chain(() =>
                      // Формируем отчет
                      right({
                        success: true,
                        filesIndexed: files.length,
                        chunksCreated: chunks.length,
                        embeddingsGenerated: embeddings.length,
                        timestamp: new Date(),
                      })
                    )
                  )
                )
              )
            )
          )
        )
      )
    )
  )
}

async function generateEmbeddings(
  chunks: CodeChunk[]
): Promise<TaskEither<Error, Embedding[]>> {
  const embeddings: Embedding[] = []
  
  for (const chunk of chunks) {
    // Используем Ollama для генерации локальных embeddings
    const embedding = await createEmbeddings(chunk.content)
    embeddings.push({
      id: chunk.id,
      content: chunk.content,
      file: chunk.file,
      lineStart: chunk.lineStart,
      lineEnd: chunk.lineEnd,
      embedding: embedding.vector,
      metadata: {
        type: chunk.type,
        language: chunk.language,
        functionName: chunk.functionName,
        className: chunk.className,
      },
    })
  }
  
  return right(embeddings)
}

async function saveToVectorDB(
  embeddings: Embedding[]
): Promise<TaskEither<Error, void>> {
  // Сохраняем в PostgreSQL с pgvector расширением
  for (const embedding of embeddings) {
    await db.insert(vectorIndex).values({
      id: embedding.id,
      content: embedding.content,
      file_path: embedding.file,
      line_start: embedding.lineStart,
      line_end: embedding.lineEnd,
      embedding: embedding.embedding, // pgvector тип
      metadata: embedding.metadata,
      created_at: new Date(),
      updated_at: new Date(),
    })
  }
  
  return right(undefined)
}
```

#### 4. Поиск по векторному индексу

```typescript
// src/agents/vibe-knowledge-keeper/vector-search.ts
import { TaskEither, right, left } from '@/core/functional/utils/result'
import { createEmbeddings } from '@/core/embeddings/openai-embeddings'
import { db } from '@/core/drizzle/client'
import { vectorIndex } from '@/core/drizzle/schema'
import { sql } from 'drizzle-orm'

export async function searchVectorIndex(
  query: string,
  options?: { limit?: number; threshold?: number }
): Promise<TaskEither<Error, SearchResult[]>> {
  return pipe(
    // Создаем embedding для запроса
    createEmbeddings(query),
    chain(queryEmbedding =>
      pipe(
        // Ищем похожие векторы в БД
        findSimilarVectors(queryEmbedding.vector, options),
        chain(results =>
          // Формируем результаты поиска
          right(
            results.map(r => ({
              id: r.id,
              file: r.file_path,
              content: r.content,
              lineStart: r.line_start,
              lineEnd: r.line_end,
              similarity: r.similarity,
              metadata: r.metadata,
            }))
          )
        )
      )
    )
  )
}

async function findSimilarVectors(
  queryVector: number[],
  options?: { limit?: number; threshold?: number }
): Promise<TaskEither<Error, VectorSearchResult[]>> {
  const limit = options?.limit || 10
  const threshold = options?.threshold || 0.7
  
  // Используем pgvector для поиска похожих векторов
  const results = await db
    .select({
      id: vectorIndex.id,
      file_path: vectorIndex.file_path,
      content: vectorIndex.content,
      line_start: vectorIndex.line_start,
      line_end: vectorIndex.line_end,
      metadata: vectorIndex.metadata,
      similarity: sql<number>`1 - (embedding <=> ${queryVector}::vector)`,
    })
    .from(vectorIndex)
    .where(sql`1 - (embedding <=> ${queryVector}::vector) >= ${threshold}`)
    .orderBy(sql`embedding <=> ${queryVector}::vector`)
    .limit(limit)
  
  return right(results)
}
```

---

### 🗄️ База данных для векторного индекса

#### Схема таблицы

```sql
-- Расширение pgvector для векторного поиска
CREATE EXTENSION IF NOT EXISTS vector;

-- Таблица векторного индекса
CREATE TABLE vector_index (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  
  -- Содержимое
  content TEXT NOT NULL,
  file_path TEXT NOT NULL,
  line_start INTEGER NOT NULL,
  line_end INTEGER NOT NULL,
  
  -- Векторное представление (768 измерений для Ollama nomic-embed-text)
  -- Для других моделей Ollama размерность может отличаться:
  -- - nomic-embed-text: 768
  -- - all-minilm: 384
  -- - mxbai-embed-large: 1024
  embedding vector(768) NOT NULL,
  
  -- Метаданные
  metadata JSONB DEFAULT '{}',
  -- Структура metadata:
  -- {
  --   "type": "function" | "class" | "interface" | "type" | "comment" | "documentation",
  --   "language": "typescript" | "javascript" | "sql" | "markdown",
  --   "functionName": "functionName",
  --   "className": "ClassName",
  --   "module": "moduleName",
  --   "tags": ["tag1", "tag2"]
  -- }
  
  -- Временные метки
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  
  -- Индексы
  CONSTRAINT vector_index_file_path_idx 
    CREATE INDEX ON vector_index(file_path),
  CONSTRAINT vector_index_embedding_idx 
    CREATE INDEX ON vector_index USING ivfflat (embedding vector_cosine_ops)
    WITH (lists = 100) -- Для быстрого поиска
);

-- Функция для поиска похожих векторов
CREATE OR REPLACE FUNCTION find_similar_vectors(
  p_query_vector vector(768), -- Размерность для Ollama nomic-embed-text
  p_limit INTEGER DEFAULT 10,
  p_threshold DOUBLE PRECISION DEFAULT 0.7
)
RETURNS TABLE (
  id UUID,
  content TEXT,
  file_path TEXT,
  line_start INTEGER,
  line_end INTEGER,
  metadata JSONB,
  similarity DOUBLE PRECISION
) AS $$
BEGIN
  RETURN QUERY
  SELECT
    vi.id,
    vi.content,
    vi.file_path,
    vi.line_start,
    vi.line_end,
    vi.metadata,
    1 - (vi.embedding <=> p_query_vector) as similarity
  FROM vector_index vi
  WHERE 1 - (vi.embedding <=> p_query_vector) >= p_threshold
  ORDER BY vi.embedding <=> p_query_vector
  LIMIT p_limit;
END;
$$ LANGUAGE plpgsql;
```

---

### 🎯 Примеры использования

#### Пример 1: Автоматическая синхронизация

```
🤖 VIBE-KNOWLEDGE-KEEPER: Запущена автоматическая синхронизация...

📏 ШАГ 1: Проверка порядка
   ✅ Структура директорий корректна
   ✅ Все обязательные файлы на месте
   ⚠️  Обнаружено 2 устаревших раздела документации

📏 ШАГ 2: Синхронизация документации
   📝 Обновлено FUNCTIONALITY_DOCUMENTATION.md
   📝 Обновлено README.md
   📝 Обновлено 15 комментариев в коде

📏 ШАГ 3: Создание векторного индекса
   🔍 Проиндексировано 234 файла
   🧬 Создано 1,567 chunks
   📊 Сгенерировано 1,567 embeddings

✅ Синхронизация завершена успешно!
```

#### Пример 2: Поиск по векторному индексу

```
Агент: Мне нужно найти функцию для генерации изображений

🤖 VIBE-KNOWLEDGE-KEEPER: Ищу в векторном индексе...

🔍 Найдено 5 похожих результатов:

1. src/services/ai-providers/image-generator.ts (similarity: 0.92)
   Функция: generateImage()
   Описание: Генерация изображений через OpenRouter API

2. src/scenes/neuroPhotoWizard/index.ts (similarity: 0.87)
   Сцена: NeuroPhoto wizard
   Описание: Мастер для генерации изображений

3. FUNCTIONALITY_DOCUMENTATION.md (similarity: 0.85)
   Раздел: NeuroPhoto
   Описание: Документация функции генерации изображений

...
```

---

### ✅ Чек-лист реализации VIBE-KNOWLEDGE-KEEPER

1. **Проверка порядка**:
   - [ ] Реализовать `checkRepositoryOrder`
   - [ ] Проверка структуры директорий
   - [ ] Проверка обязательных файлов
   - [ ] Проверка консистентности документации

2. **Синхронизация документации**:
   - [ ] Реализовать `syncDocumentation`
   - [ ] Парсинг кодовой базы
   - [ ] Генерация документации
   - [ ] Обновление файлов документации

3. **Векторный индекс**:
   - [ ] Установить pgvector расширение
   - [ ] Создать таблицу `vector_index`
   - [ ] Реализовать генерацию embeddings
   - [ ] Реализовать сохранение в БД
   - [ ] Реализовать поиск по индексу

4. **Автоматизация**:
   - [ ] Настроить периодическую синхронизацию
   - [ ] Настроить автоматическое обновление индекса
   - [ ] Интегрировать с Git hooks
   - [ ] Добавить уведомления об изменениях

5. **Интеграция**:
   - [ ] Интегрировать с VIBE-SENTRY для логирования
   - [ ] Интегрировать с VIBE-RAINBOW-BRIDGE для уведомлений
   - [ ] Предоставить API для других агентов
   - [ ] Добавить веб-интерфейс для просмотра

---

**📚 VIBE-KNOWLEDGE-KEEPER готов! Теперь репозиторий всегда в порядке, документация свежая, агенты понимают весь проект!** 🐝

---

## 🔧 Drizzle ORM: Лучшие практики и инструменты

> **🚨 КРИТИЧЕСКИ ВАЖНО**: Drizzle ORM - это основа для всех операций с базой данных!  
> **📊 ЦЕЛЬ**: Использовать лучшие практики Drizzle ORM, инструменты (Drizzle Studio, Drizzle Kit), интеграцию с Zod  
> **🆓 БЕСПЛАТНО**: Все инструменты Drizzle ORM бесплатны и с открытым исходным кодом (Apache-2.0)

---

### 🎯 Концепция Drizzle ORM

**Drizzle ORM** - это современная, легковесная и строго типизированная ORM для работы с реляционными базами данных:

- ✅ **Строгая типизация**: Полная типобезопасность через TypeScript
- ✅ **Легковесность**: Минимальный overhead, близкий к нативному SQL
- ✅ **Производительность**: Оптимизированные запросы, близкие к SQL
- ✅ **Гибкость**: SQL-подобный синтаксис для сложных запросов
- ✅ **Бесплатность**: Apache-2.0 лицензия, полностью бесплатно
- ✅ **Инструменты**: Drizzle Studio (админка), Drizzle Kit (миграции)

**Цель**: Использовать Drizzle ORM как единый инструмент для всех операций с БД! 🐝

---

### 🛠️ Инструменты Drizzle ORM

#### 1. Drizzle Studio - Бесплатная админка

**Drizzle Studio** - это графический веб-интерфейс для работы с базой данных:

```bash
# Установка Drizzle Kit (включает Drizzle Studio)
npm install -D drizzle-kit

# Запуск Drizzle Studio
npx drizzle-kit studio

# Или через package.json
npm run db:studio
```

**Возможности Drizzle Studio**:
- ✅ **Просмотр данных**: Визуальный просмотр всех таблиц
- ✅ **Редактирование**: Редактирование данных через UI
- ✅ **Поиск**: Быстрый поиск по таблицам
- ✅ **Фильтрация**: Фильтрация данных
- ✅ **Экспорт**: Экспорт данных в CSV/JSON
- ✅ **Бесплатно**: Полностью бесплатный инструмент

**Конфигурация**:

```typescript
// drizzle.config.ts
import type { Config } from 'drizzle-kit'

export default {
  schema: './src/core/drizzle/schema.ts',
  out: './drizzle',
  driver: 'pg',
  dbCredentials: {
    connectionString: process.env.DATABASE_URL!,
  },
  verbose: true,
  strict: true,
} satisfies Config
```

#### 2. Drizzle Kit - Управление миграциями

**Drizzle Kit** - это CLI-инструмент для управления миграциями:

```bash
# Генерация миграций на основе изменений схемы
npx drizzle-kit generate

# Применение миграций к БД
npx drizzle-kit migrate

# Просмотр статуса миграций
npx drizzle-kit migrate:status

# Откат миграций (если поддерживается)
npx drizzle-kit migrate:rollback

# Сидирование БД (заполнение начальными данными)
npx drizzle-kit seed
```

**Автоматизация**:

```json
// package.json
{
  "scripts": {
    "db:generate": "drizzle-kit generate",
    "db:migrate": "drizzle-kit migrate",
    "db:studio": "drizzle-kit studio",
    "db:push": "drizzle-kit push",
    "db:seed": "drizzle-kit seed"
  }
}
```

#### 3. drizzle-zod - Интеграция с Zod

**drizzle-zod** - автоматическая генерация Zod-схем из Drizzle схем:

```bash
npm install drizzle-zod
```

**Использование**:

```typescript
// src/core/drizzle/schema.ts
import { pgTable, uuid, text, jsonb, timestamp } from 'drizzle-orm/pg-core'
import { createInsertSchema, createSelectSchema } from 'drizzle-zod'
import { z } from 'zod'

export const users = pgTable('users', {
  id: uuid('id').primaryKey().defaultRandom(),
  telegram_id: bigint('telegram_id', { mode: 'number' }).notNull(),
  bot_name: text('bot_name').notNull(),
  username: text('username'),
  settings: jsonb('settings').notNull().default({}),
  created_at: timestamp('created_at', { withTimezone: true }).defaultNow(),
})

// Автоматическая генерация Zod схем из Drizzle схем
export const insertUserSchema = createInsertSchema(users, {
  telegram_id: z.number().int().positive(),
  bot_name: z.string().min(1).max(100),
  username: z.string().optional(),
  settings: z.record(z.unknown()).default({}),
})

export const selectUserSchema = createSelectSchema(users)

// Типы из Zod схем
export type InsertUser = z.infer<typeof insertUserSchema>
export type SelectUser = z.infer<typeof selectUserSchema>
```

---

### 📋 Лучшие практики Drizzle ORM

#### 1. Строгая типизация схем

```typescript
// ✅ ХОРОШО: Строгая типизация с проверками
import { pgTable, uuid, text, jsonb, timestamp, bigint, varchar } from 'drizzle-orm/pg-core'
import { relations, uniqueIndex, index } from 'drizzle-orm'

export const users = pgTable('users', {
  id: uuid('id').primaryKey().defaultRandom(),
  telegram_id: bigint('telegram_id', { mode: 'number' }).notNull(),
  bot_name: varchar('bot_name', { length: 100 }).notNull(),
  username: varchar('username', { length: 255 }),
  settings: jsonb('settings').notNull().default({}),
  created_at: timestamp('created_at', { withTimezone: true }).defaultNow(),
  updated_at: timestamp('updated_at', { withTimezone: true }).defaultNow(),
}, (table) => ({
  // Уникальный индекс для telegram_id + bot_name
  telegramIdBotNameIdx: uniqueIndex('users_telegram_id_bot_name_idx')
    .on(table.telegram_id, table.bot_name),
  // Обычный индекс для telegram_id
  telegramIdIdx: index('idx_users_telegram_id').on(table.telegram_id),
  // GIN индекс для JSONB
  settingsGinIdx: index('idx_users_settings_gin').using('gin', table.settings),
}))
```

#### 2. SQL-подобный синтаксис для сложных запросов

```typescript
// ✅ ХОРОШО: Использование SQL-подобного синтаксиса
import { db } from '@/core/drizzle/client'
import { users, balances, operations } from '@/core/drizzle/schema'
import { eq, and, gt, sql, desc, count } from 'drizzle-orm'

// Сложный запрос с JOIN, GROUP BY, HAVING
const result = await db
  .select({
    userId: users.id,
    userName: users.username,
    totalOperations: count(operations.id),
    totalSpent: sql<number>`sum((${operations.cost}->>'stars')::int)`,
  })
  .from(users)
  .leftJoin(operations, eq(operations.user_id, users.id))
  .leftJoin(balances, eq(balances.user_id, users.id))
  .where(
    and(
      eq(users.bot_name, 'neuro_blogger_bot'),
      gt(balances.currencies, sql`'{"stars": 0}'::jsonb`)
    )
  )
  .groupBy(users.id)
  .having(gt(count(operations.id), 5))
  .orderBy(desc(count(operations.id)))
  .limit(10)
```

#### 3. Транзакции для атомарных операций

```typescript
// ✅ ХОРОШО: Использование транзакций для атомарности
import { db } from '@/core/drizzle/client'
import { users, balances } from '@/core/drizzle/schema'
import { eq } from 'drizzle-orm'
import { TaskEither, tryCatchAsync } from '@/core/functional/utils/result'

const deductBalanceAtomically = (
  userId: string,
  amount: number
): TaskEither<Error, boolean> =>
  tryCatchAsync(
    async () => {
      await db.transaction(async (tx) => {
        // Блокируем строку для атомарности
        const balance = await tx
          .select()
          .from(balances)
          .where(eq(balances.user_id, userId))
          .for('update')
          .limit(1)

        if (!balance[0]) {
          throw new Error('Balance not found')
        }

        const currentStars = (balance[0].currencies as any)?.stars || 0

        if (currentStars < amount) {
          throw new Error('Insufficient balance')
        }

        // Атомарное обновление
        await tx
          .update(balances)
          .set({
            currencies: sql`jsonb_set(
              ${balances.currencies},
              '{stars}',
              ((${balances.currencies}->>'stars')::int - ${amount})::text::jsonb
            )`,
          })
          .where(eq(balances.user_id, userId))
      })

      return true
    },
    (error) => error as Error
  )
```

#### 4. Использование prepared statements для производительности

```typescript
// ✅ ХОРОШО: Prepared statements для частых запросов
import { db } from '@/core/drizzle/client'
import { users } from '@/core/drizzle/schema'
import { eq } from 'drizzle-orm'
import { sql } from 'drizzle-orm'

// Prepared statement для частого запроса
const getUserByTelegramId = db
  .select()
  .from(users)
  .where(eq(users.telegram_id, sql.placeholder('telegramId')))
  .prepare()

// Использование prepared statement
const user = await getUserByTelegramId.execute({ telegramId: 123456789 })
```

#### 5. Интеграция с функциональным программированием

```typescript
// ✅ ХОРОШО: Интеграция с TaskEither для функционального стиля
import { TaskEither, tryCatchAsync, right, left } from '@/core/functional/utils/result'
import { pipe, chain } from '@/core/functional/utils/composition'
import { db } from '@/core/drizzle/client'
import { users } from '@/core/drizzle/schema'
import { eq } from 'drizzle-orm'
import { validate } from '@/core/validation/validate'
import { insertUserSchema } from '@/core/drizzle/schema'

const createUser = (
  userData: unknown
): TaskEither<Error, SelectUser> =>
  pipe(
    // 1. Валидация через Zod (из drizzle-zod)
    validate(insertUserSchema, userData),
    chain(validatedData =>
      // 2. Создание пользователя через Drizzle
      tryCatchAsync(
        async () => {
          const [user] = await db
            .insert(users)
            .values(validatedData)
            .returning()
          
          return user
        },
        (error) => error as Error
      )
    )
  )
```

#### 6. Оптимизация запросов с индексами

```typescript
// ✅ ХОРОШО: Использование индексов для оптимизации
import { pgTable, uuid, bigint, varchar, index, uniqueIndex } from 'drizzle-orm/pg-core'

export const users = pgTable('users', {
  id: uuid('id').primaryKey().defaultRandom(),
  telegram_id: bigint('telegram_id', { mode: 'number' }).notNull(),
  bot_name: varchar('bot_name', { length: 100 }).notNull(),
}, (table) => ({
  // Композитный уникальный индекс для частого запроса
  telegramIdBotNameIdx: uniqueIndex('users_telegram_id_bot_name_idx')
    .on(table.telegram_id, table.bot_name),
  // Частичный индекс для активных записей
  activeUsersIdx: index('idx_users_active')
    .on(table.telegram_id)
    .where(sql`${table.settings}->>'is_active' = 'true'`),
}))
```

---

### 🔧 Настройка Drizzle ORM

#### Инициализация клиента

```typescript
// src/core/drizzle/client.ts
import { drizzle } from 'drizzle-orm/postgres-js'
import postgres from 'postgres'
import * as schema from './schema'

// Lazy initialization для загрузки секретов из Infisical
let _db: ReturnType<typeof drizzle> | null = null

function getDatabaseUrl(): string {
  const url = process.env.DATABASE_URL
  if (!url) {
    throw new Error('DATABASE_URL is required but undefined. Ensure Infisical loaded secrets.')
  }
  return url
}

// Lazy-initialized Drizzle client
export const db = new Proxy({} as ReturnType<typeof drizzle>, {
  get(target, prop) {
    if (!_db) {
      const queryClient = postgres(getDatabaseUrl(), {
        ssl: { rejectUnauthorized: false },
        max: 10, // Connection pool size
        idle_timeout: 30, // Seconds
        connect_timeout: 10, // Seconds
      })
      _db = drizzle(queryClient, { schema })
    }
    return (_db as any)[prop]
  }
})
```

#### Конфигурация Drizzle Kit

```typescript
// drizzle.config.ts
import type { Config } from 'drizzle-kit'
import * as dotenv from 'dotenv'

dotenv.config()

export default {
  schema: './src/core/drizzle/schema.ts',
  out: './drizzle/migrations',
  driver: 'pg',
  dbCredentials: {
    connectionString: process.env.DATABASE_URL!,
  },
  verbose: true,
  strict: true,
  // Генерация TypeScript типов для миграций
  schemaFilter: ['public'],
} satisfies Config
```

---

### 🎯 Примеры использования

#### Пример 1: Создание пользователя с валидацией

```typescript
import { db } from '@/core/drizzle/client'
import { users } from '@/core/drizzle/schema'
import { insertUserSchema } from '@/core/drizzle/schema'
import { validate } from '@/core/validation/validate'
import { pipe, chain } from '@/core/functional/utils/composition'
import { TaskEither, tryCatchAsync } from '@/core/functional/utils/result'

const createUser = (userData: unknown): TaskEither<Error, SelectUser> =>
  pipe(
    validate(insertUserSchema, userData),
    chain(validatedData =>
      tryCatchAsync(
        async () => {
          const [user] = await db
            .insert(users)
            .values(validatedData)
            .returning()
          
          return user
        },
        (error) => error as Error
      )
    )
  )
```

#### Пример 2: Поиск с фильтрацией и пагинацией

```typescript
import { db } from '@/core/drizzle/client'
import { users, operations } from '@/core/drizzle/schema'
import { eq, and, desc, count, sql } from 'drizzle-orm'

const getUsersWithOperations = async (
  botName: string,
  limit: number = 10,
  offset: number = 0
) => {
  return await db
    .select({
      user: users,
      operationCount: count(operations.id),
      lastOperationDate: sql<Date>`max(${operations.created_at})`,
    })
    .from(users)
    .leftJoin(operations, eq(operations.user_id, users.id))
    .where(eq(users.bot_name, botName))
    .groupBy(users.id)
    .orderBy(desc(sql`max(${operations.created_at})`))
    .limit(limit)
    .offset(offset)
}
```

---

### ✅ Чек-лист использования Drizzle ORM

1. **Настройка**:
   - [ ] Установить `drizzle-orm` и `drizzle-kit`
   - [ ] Установить `drizzle-zod` для интеграции с Zod
   - [ ] Настроить `drizzle.config.ts`
   - [ ] Настроить lazy initialization клиента

2. **Схемы**:
   - [ ] Создать схемы с строгой типизацией
   - [ ] Добавить индексы для оптимизации
   - [ ] Использовать `drizzle-zod` для генерации Zod схем
   - [ ] Экспортировать типы из схем

3. **Миграции**:
   - [ ] Использовать `drizzle-kit generate` для генерации
   - [ ] Применять миграции через `drizzle-kit migrate`
   - [ ] Настроить автоматическое применение миграций

4. **Запросы**:
   - [ ] Использовать SQL-подобный синтаксис
   - [ ] Использовать транзакции для атомарности
   - [ ] Использовать prepared statements для частых запросов
   - [ ] Интегрировать с функциональным программированием

5. **Инструменты**:
   - [ ] Использовать Drizzle Studio для администрирования
   - [ ] Настроить скрипты в package.json
   - [ ] Использовать Drizzle Kit для миграций

---

**🔧 Drizzle ORM настроен с лучшими практиками! Теперь используем современный, типобезопасный и производительный ORM!** 🐝

> **📚 Официальная документация**: [Drizzle ORM](https://orm.drizzle.team/)  
> **🛠️ Drizzle Studio**: `npx drizzle-kit studio` - бесплатная админка  
> **📦 Drizzle Kit**: `npx drizzle-kit` - управление миграциями  
> **🔗 drizzle-zod**: Автоматическая генерация Zod схем

---

## 🎯 Оптимальный план выполнения: Минимизация токенов и максимальная эффективность

> **🚨 КРИТИЧЕСКИ ВАЖНО**: Этот план оптимизирован для выполнения ВСЕХ задач за несколько часов ОДНИМ промптом!  
> **💰 ЦЕЛЬ**: Минимизировать токены, максимизировать эффективность, выполнить все от начала до конца  
> **⏱️ ВРЕМЯ**: 3-6 часов для полной реализации всех агентов

---

### 📊 Матрица зависимостей и приоритетов

#### Уровень 0: Критические зависимости (СНАЧАЛА ЭТО!)
**Время**: 1-2 часа | **Токены**: ~50K | **Приоритет**: 🔴 КРИТИЧЕСКИЙ

```
VIBE-SENTRY (1-2 часа)
  ↓
VIBE-RAINBOW-BRIDGE (1-2 часа)
  ↓
VIBE-QUEEN-COORDINATOR (2-3 часа)
```

**Почему сначала это:**
- ✅ `VIBE-SENTRY` - логирование для всех агентов (нужен ВСЕМ)
- ✅ `VIBE-RAINBOW-BRIDGE` - связь с админом (нужна для мониторинга)
- ✅ `VIBE-QUEEN-COORDINATOR` - координация всех агентов (нужна ВСЕМ)

#### Уровень 1: Инфраструктурные агенты (ПОТОМ ЭТО!)
**Время**: 2-3 часа | **Токены**: ~80K | **Приоритет**: 🟠 ВЫСОКИЙ

```
VIBE-INFRASTRUCTURE-BUILDER (2-3 часа)
  ↓
VIBE-KNOWLEDGE-KEEPER (1-2 часа)
  ↓
VIBE-DIAGNOSTICS (1-2 часа)
```

**Почему потом это:**
- ✅ `VIBE-INFRASTRUCTURE-BUILDER` - создает инфраструктуру для других агентов
- ✅ `VIBE-KNOWLEDGE-KEEPER` - синхронизирует документацию (нужна для понимания проекта)
- ✅ `VIBE-DIAGNOSTICS` - диагностика системы (нужна для мониторинга)

#### Уровень 2: Self-Development агенты (ЗАТЕМ ЭТО!)
**Время**: 3-4 часа | **Токены**: ~100K | **Приоритет**: 🟡 СРЕДНИЙ

```
VIBE-SELF-CODING (2-3 часа)
  ↓
VIBE-SELF-TESTING (1-2 часа)
  ↓
VIBE-SELF-REFACTORING (1-2 часа)
  ↓
VIBE-SELF-DEPLOYMENT (1-2 часа)
  ↓
VIBE-SELF-LEARNING (1-2 часа)
```

**Почему затем это:**
- ✅ Эти агенты помогают создавать других агентов автоматически
- ✅ После их создания остальные агенты создаются быстрее

#### Уровень 3: Бизнес-агенты (В КОНЦЕ ЭТО!)
**Время**: 4-6 часов | **Токены**: ~150K | **Приоритет**: 🟢 НИЗКИЙ

```
VIBE-IMAGE-GENERATOR (1-2 часа)
VIBE-VIDEO-GENERATOR (1-2 часа)
VIBE-MODEL-TRAINER (1-2 часа)
VIBE-AVATAR-BRAIN (1-2 часа)
VIBE-MEDIA-PROCESSOR (1-2 часа)
VIBE-PAYMENT-HANDLER (1-2 часа)
VIBE-NAVIGATION-MASTER (1-2 часа)
VIBE-ANALYTICS-AGENT (1-2 часа)
VIBE-VALIDATION-GUARDIAN (1-2 часа)
```

**Почему в конце:**
- ✅ Эти агенты используют инфраструктуру и self-development агентов
- ✅ После создания инфраструктуры они создаются автоматически

---

### 🚀 Оптимальная последовательность выполнения (ОДИН ПРОМПТ!)

#### Фаза 1: Критические зависимости (1-2 часа)

```markdown
## ЗАДАЧА 1: Создать VIBE-SENTRY (1-2 часа)

**Цель**: Централизованное логирование для всех агентов

**Шаги**:
1. Создать структуру плагина `src/plugins/vibe-sentry/`
2. Реализовать `withLogging` wrapper
3. Создать таблицу `agent_action_logs` в БД
4. Реализовать функции логирования (start, complete, error)
5. Интегрировать с Sentry API
6. Написать тесты (100% покрытие)
7. Зарегистрировать плагин в системе

**Критерии успеха**:
- ✅ Все агенты могут логировать действия
- ✅ Логи сохраняются в БД
- ✅ Интеграция с Sentry работает
- ✅ 100% покрытие тестами

**Токены**: ~15K
```

```markdown
## ЗАДАЧА 2: Создать VIBE-RAINBOW-BRIDGE (1-2 часа)

**Цель**: Telegram-интерфейс для управления роем агентов

**Шаги**:
1. Создать Telegram бота для админа
2. Реализовать команды (/start, /status, /agents, /tasks, /logs)
3. Интегрировать с VIBE-QUEEN для получения статусов
4. Реализовать streaming обновлений
5. Написать тесты
6. Зарегистрировать в системе

**Критерии успеха**:
- ✅ Админ может общаться с агентами через Telegram
- ✅ Видит статус всех агентов
- ✅ Может создавать задачи
- ✅ Получает уведомления о важных событиях

**Токены**: ~20K
```

```markdown
## ЗАДАЧА 3: Создать VIBE-QUEEN-COORDINATOR (2-3 часа)

**Цель**: Координация всех агентов роя

**Шаги**:
1. Создать таблицы `swarm_queen`, `swarm_tasks`, `agent_coordination`
2. Реализовать распределение задач
3. Реализовать мониторинг агентов
4. Реализовать балансировку нагрузки
5. Интегрировать с VIBE-SENTRY для логирования
6. Интегрировать с VIBE-RAINBOW-BRIDGE для уведомлений
7. Написать тесты

**Критерии успеха**:
- ✅ Может распределять задачи между агентами
- ✅ Мониторит статус агентов
- ✅ Балансирует нагрузку
- ✅ Интегрирован с логированием и уведомлениями

**Токены**: ~25K
```

#### Фаза 2: Инфраструктурные агенты (2-3 часа)

```markdown
## ЗАДАЧА 4: Создать VIBE-INFRASTRUCTURE-BUILDER (2-3 часа)

**Цель**: Автоматическое создание инфраструктуры для агентов

**Шаги**:
1. Реализовать создание Docker контейнеров
2. Реализовать настройку портов
3. Реализовать создание Nginx конфигов
4. Реализовать создание Drizzle схем
5. Интегрировать с VIBE-QUEEN
6. Написать тесты

**Критерии успеха**:
- ✅ Может создавать инфраструктуру для новых агентов
- ✅ Автоматически настраивает порты и маршрутизацию
- ✅ Создает необходимые таблицы в БД

**Токены**: ~30K
```

```markdown
## ЗАДАЧА 5: Создать VIBE-KNOWLEDGE-KEEPER (1-2 часа)

**Цель**: Синхронизация документации и векторный индекс

**Шаги**:
1. Реализовать проверку порядка репозитория
2. Реализовать синхронизацию документации
3. Реализовать создание векторного индекса через Ollama
4. Реализовать поиск по векторному индексу
5. Интегрировать с VIBE-SENTRY
6. Написать тесты

**Критерии успеха**:
- ✅ Документация всегда синхронизирована с кодом
- ✅ Векторный индекс создан и работает
- ✅ Агенты могут искать информацию по проекту

**Токены**: ~20K
```

```markdown
## ЗАДАЧА 6: Создать VIBE-DIAGNOSTICS (1-2 часа)

**Цель**: Телеметрия и диагностика системы

**Шаги**:
1. Реализовать сбор телеметрии через `withTelemetry`
2. Создать веб-интерфейс для диагностики
3. Реализовать интеграцию с Claude Code Analytics API
4. Создать таблицы для метрик
5. Интегрировать с VIBE-SENTRY
6. Написать тесты

**Критерии успеха**:
- ✅ Телеметрия собирается везде
- ✅ Веб-интерфейс работает
- ✅ Метрики Claude Code собираются

**Токены**: ~20K
```

#### Фаза 3: Self-Development агенты (3-4 часа)

```markdown
## ЗАДАЧА 7-11: Создать Self-Development агентов (3-4 часа)

**Агенты**:
- VIBE-SELF-CODING (2-3 часа)
- VIBE-SELF-TESTING (1-2 часа)
- VIBE-SELF-REFACTORING (1-2 часа)
- VIBE-SELF-DEPLOYMENT (1-2 часа)
- VIBE-SELF-LEARNING (1-2 часа)

**Шаги для каждого**:
1. Реализовать автономный цикл (не выходить пока тесты не пройдут)
2. Интегрировать с VIBE-QUEEN
3. Интегрировать с VIBE-SENTRY
4. Реализовать принцип "7 раз отмерь"
5. Написать тесты

**Критерии успеха**:
- ✅ Агенты работают автономно
- ✅ Не выходят из цикла пока задачи не выполнены
- ✅ Используют принцип "7 раз отмерь"

**Токены**: ~100K (всего)
```

#### Фаза 4: Бизнес-агенты (4-6 часов, но автоматически!)

```markdown
## ЗАДАЧА 12-20: Создать бизнес-агентов (4-6 часов, автоматически!)

**Агенты** (создаются автоматически через VIBE-SELF-CODING):
- VIBE-IMAGE-GENERATOR
- VIBE-VIDEO-GENERATOR
- VIBE-MODEL-TRAINER
- VIBE-AVATAR-BRAIN
- VIBE-MEDIA-PROCESSOR
- VIBE-PAYMENT-HANDLER
- VIBE-NAVIGATION-MASTER
- VIBE-ANALYTICS-AGENT
- VIBE-VALIDATION-GUARDIAN

**Процесс**:
1. VIBE-QUEEN получает задачу создать агента
2. VIBE-SELF-CODING генерирует код
3. VIBE-SELF-TESTING пишет тесты
4. VIBE-SELF-REFACTORING оптимизирует код
5. VIBE-SELF-DEPLOYMENT деплоит агента
6. VIBE-SELF-LEARNING учится на опыте

**Токены**: ~150K (всего, но автоматически!)
```

---

### 📝 Единый промпт для агента (ВСЕ ЗА ОДИН РАЗ!)

```markdown
# 🐝 ЗАДАЧА: Создать всю экосистему VIBEE за один раз

## Контекст
Ты - автономный агент разработки. Твоя задача - создать всю экосистему VIBEE 
(роя автономных агентов-пчелок) за один промпт, следуя оптимальному плану.

## Правила
1. **НЕ ВЫХОДИ из цикла** пока все тесты не пройдут
2. **Используй принцип "7 раз отмерь"** перед каждым действием
3. **Логируй все действия** через VIBE-SENTRY (после его создания)
4. **Следуй функциональному стилю** (TaskEither, pipe, immutability)
5. **100% покрытие тестами** для всех функций
6. **Используй Drizzle ORM** для всех операций с БД
7. **Используй Zod** для валидации всех данных

## План выполнения (строго по порядку!)

### ФАЗА 1: Критические зависимости (1-2 часа)
1. ✅ Создать VIBE-SENTRY (логирование)
2. ✅ Создать VIBE-RAINBOW-BRIDGE (Telegram интерфейс)
3. ✅ Создать VIBE-QUEEN-COORDINATOR (координация)

### ФАЗА 2: Инфраструктурные агенты (2-3 часа)
4. ✅ Создать VIBE-INFRASTRUCTURE-BUILDER (инфраструктура)
5. ✅ Создать VIBE-KNOWLEDGE-KEEPER (документация)
6. ✅ Создать VIBE-DIAGNOSTICS (телеметрия)

### ФАЗА 3: Self-Development агенты (3-4 часа)
7. ✅ Создать VIBE-SELF-CODING (генерация кода)
8. ✅ Создать VIBE-SELF-TESTING (тестирование)
9. ✅ Создать VIBE-SELF-REFACTORING (рефакторинг)
10. ✅ Создать VIBE-SELF-DEPLOYMENT (деплой)
11. ✅ Создать VIBE-SELF-LEARNING (обучение)

### ФАЗА 4: Бизнес-агенты (4-6 часов, автоматически!)
12. ✅ Создать VIBE-IMAGE-GENERATOR (через VIBE-SELF-CODING)
13. ✅ Создать VIBE-VIDEO-GENERATOR (через VIBE-SELF-CODING)
14. ✅ Создать VIBE-MODEL-TRAINER (через VIBE-SELF-CODING)
15. ✅ Создать VIBE-AVATAR-BRAIN (через VIBE-SELF-CODING)
16. ✅ Создать VIBE-MEDIA-PROCESSOR (через VIBE-SELF-CODING)
17. ✅ Создать VIBE-PAYMENT-HANDLER (через VIBE-SELF-CODING)
18. ✅ Создать VIBE-NAVIGATION-MASTER (через VIBE-SELF-CODING)
19. ✅ Создать VIBE-ANALYTICS-AGENT (через VIBE-SELF-CODING)
20. ✅ Создать VIBE-VALIDATION-GUARDIAN (через VIBE-SELF-CODING)

## Процесс для каждой задачи

Для КАЖДОЙ задачи выполни:

1. **Планирование (7 раз отмерь)**:
   - Проанализируй задачу
   - Найди паттерны в документации
   - Проверь зависимости
   - Спланируй шаги
   - Валидируй план
   - Проверь еще раз
   - Финальная проверка

2. **Реализация**:
   - Создай структуру файлов
   - Реализуй функциональный стиль (TaskEither, pipe)
   - Используй Drizzle ORM для БД
   - Используй Zod для валидации
   - Интегрируй с существующими агентами

3. **Тестирование**:
   - Напиши тесты (TDD)
   - Запусти тесты
   - Исправь ошибки
   - Добейся 100% покрытия

4. **Рефакторинг**:
   - Оптимизируй код
   - Убери дублирование
   - Улучши читаемость

5. **Деплой**:
   - Зарегистрируй агента в системе
   - Обнови документацию
   - Проверь интеграцию

6. **Логирование**:
   - Залогируй успешное завершение
   - Обнови статус в VIBE-QUEEN
   - Уведомь через VIBE-RAINBOW-BRIDGE

## Критерии успеха

✅ Все агенты созданы и работают
✅ Все тесты проходят (100% покрытие)
✅ Все интеграции работают
✅ Документация обновлена
✅ Система полностью функциональна

## НЕ ОСТАНАВЛИВАЙСЯ!

Работай автономно, не выходи из цикла, пока все задачи не выполнены!
Используй VIBE-SELF-CODING для автоматизации создания бизнес-агентов!

НАЧИНАЙ! 🐝
```

---

### 💰 Оптимизация токенов

#### Стратегии минимизации токенов:

1. **Переиспользование кода**:
   - Создай базовые утилиты один раз
   - Используй шаблоны для похожих агентов
   - Переиспользуй функции между агентами

2. **Инкрементальная разработка**:
   - Создавай агентов по порядку зависимостей
   - Используй уже созданных агентов для создания следующих
   - Не дублируй код

3. **Автоматизация**:
   - После создания Self-Development агентов, остальные создаются автоматически
   - Используй VIBE-SELF-CODING для генерации кода
   - Используй VIBE-SELF-TESTING для генерации тестов

4. **Эффективные промпты**:
   - Используй ссылки на документацию вместо копирования
   - Используй шаблоны и паттерны
   - Минимизируй повторения

#### Оценка токенов:

| Фаза | Задачи | Токены | Время |
|------|--------|--------|-------|
| Фаза 1 | 3 задачи | ~60K | 1-2 часа |
| Фаза 2 | 3 задачи | ~70K | 2-3 часа |
| Фаза 3 | 5 задач | ~100K | 3-4 часа |
| Фаза 4 | 9 задач (авто) | ~150K | 4-6 часов |
| **ИТОГО** | **20 задач** | **~380K** | **10-15 часов** |

**Но!** После Фазы 3, Фаза 4 выполняется автоматически через Self-Development агентов, 
что значительно снижает реальное потребление токенов!

---

### ✅ Чек-лист выполнения

#### Перед началом:
- [ ] Прочитал всю документацию FUNCTIONALITY_DOCUMENTATION.md
- [ ] Понял архитектуру и зависимости
- [ ] Настроил окружение (Drizzle, Zod, Ollama)
- [ ] Подготовил промпт для агента

#### Фаза 1: Критические зависимости
- [ ] VIBE-SENTRY создан и работает
- [ ] VIBE-RAINBOW-BRIDGE создан и работает
- [ ] VIBE-QUEEN-COORDINATOR создан и работает
- [ ] Все интеграции между ними работают

#### Фаза 2: Инфраструктурные агенты
- [ ] VIBE-INFRASTRUCTURE-BUILDER создан
- [ ] VIBE-KNOWLEDGE-KEEPER создан
- [ ] VIBE-DIAGNOSTICS создан
- [ ] Все интегрированы с Фазой 1

#### Фаза 3: Self-Development агенты
- [ ] VIBE-SELF-CODING создан и работает автономно
- [ ] VIBE-SELF-TESTING создан и работает автономно
- [ ] VIBE-SELF-REFACTORING создан
- [ ] VIBE-SELF-DEPLOYMENT создан
- [ ] VIBE-SELF-LEARNING создан

#### Фаза 4: Бизнес-агенты (автоматически)
- [ ] Все 9 бизнес-агентов созданы через VIBE-SELF-CODING
- [ ] Все тесты написаны через VIBE-SELF-TESTING
- [ ] Все агенты задеплоены через VIBE-SELF-DEPLOYMENT

#### Финальная проверка:
- [ ] Все агенты работают
- [ ] Все тесты проходят (100% покрытие)
- [ ] Все интеграции работают
- [ ] Документация обновлена
- [ ] Система полностью функциональна

---

**🎯 Оптимальный план готов! Теперь агент может выполнить ВСЕ задачи за один промпт, минимизируя токены и максимизируя эффективность!** 🐝

> **💡 СОВЕТ**: Используй этот план как основу для промпта агента.  
> **⏱️ ВРЕМЯ**: 10-15 часов для полной реализации (но большая часть автоматизирована!)  
> **💰 ТОКЕНЫ**: ~380K всего (но после Фазы 3 остальное автоматически!)

---

### 🔧 Настройка Ollama для локальных эмбеддингов

#### Установка и настройка Ollama

```bash
# Установка Ollama (macOS)
brew install ollama

# Или через официальный установщик
# https://ollama.ai/download

# Запуск Ollama сервера
ollama serve

# Скачивание модели для эмбеддингов (рекомендуется nomic-embed-text)
ollama pull nomic-embed-text

# Проверка установки
ollama list
```

#### Клиент для Ollama Embeddings

```typescript
// src/core/embeddings/ollama-embeddings.ts
import { TaskEither, right, left, tryCatchAsync } from '@/core/functional/utils/result'
import { pipe } from '@/core/functional/utils/composition'

interface OllamaEmbeddingConfig {
  baseUrl?: string // По умолчанию: http://localhost:11434
  model?: string // По умолчанию: nomic-embed-text
  timeout?: number // Таймаут запроса (мс)
}

interface EmbeddingResult {
  vector: number[]
  model: string
  dimensions: number
}

class OllamaEmbeddingsClient {
  private config: Required<OllamaEmbeddingConfig>

  constructor(config: OllamaEmbeddingConfig = {}) {
    this.config = {
      baseUrl: process.env.OLLAMA_BASE_URL || 'http://localhost:11434',
      model: process.env.OLLAMA_EMBEDDING_MODEL || 'nomic-embed-text',
      timeout: 30000, // 30 секунд
      ...config,
    }
  }

  /**
   * Создание эмбеддинга для текста через Ollama
   */
  async createEmbedding(
    text: string
  ): Promise<TaskEither<Error, EmbeddingResult>> {
    return tryCatchAsync(
      async () => {
        const response = await fetch(
          `${this.config.baseUrl}/api/embeddings`,
          {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              model: this.config.model,
              prompt: text,
            }),
            signal: AbortSignal.timeout(this.config.timeout),
          }
        )

        if (!response.ok) {
          throw new Error(
            `Ollama API error: ${response.status} ${response.statusText}`
          )
        }

        const data = await response.json()

        return {
          vector: data.embedding,
          model: this.config.model,
          dimensions: data.embedding.length,
        }
      },
      (error) => error as Error
    )
  }

  /**
   * Создание эмбеддингов для массива текстов (батчинг)
   */
  async createEmbeddings(
    texts: string[]
  ): Promise<TaskEither<Error, EmbeddingResult[]>> {
    return tryCatchAsync(
      async () => {
        // Ollama поддерживает батчинг через массив prompts
        const response = await fetch(
          `${this.config.baseUrl}/api/embeddings`,
          {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              model: this.config.model,
              prompts: texts, // Массив текстов для батчинга
            }),
            signal: AbortSignal.timeout(this.config.timeout * texts.length),
          }
        )

        if (!response.ok) {
          throw new Error(
            `Ollama API error: ${response.status} ${response.statusText}`
          )
        }

        const data = await response.json()

        // Ollama возвращает массив эмбеддингов для каждого промпта
        return data.embeddings.map((embedding: number[], index: number) => ({
          vector: embedding,
          model: this.config.model,
          dimensions: embedding.length,
          text: texts[index],
        }))
      },
      (error) => error as Error
    )
  }

  /**
   * Проверка доступности Ollama сервера
   */
  async checkHealth(): Promise<TaskEither<Error, boolean>> {
    return tryCatchAsync(
      async () => {
        const response = await fetch(`${this.config.baseUrl}/api/tags`, {
          method: 'GET',
          signal: AbortSignal.timeout(5000),
        })

        return response.ok
      },
      () => false
    )
  }
}

// Экспортируем клиент с настройками по умолчанию
export const ollamaEmbeddingsClient = new OllamaEmbeddingsClient({
  baseUrl: process.env.OLLAMA_BASE_URL || 'http://localhost:11434',
  model: process.env.OLLAMA_EMBEDDING_MODEL || 'nomic-embed-text',
})

// Экспортируем функцию для удобства использования
export const createEmbeddings = async (
  text: string
): Promise<TaskEither<Error, EmbeddingResult>> => {
  return ollamaEmbeddingsClient.createEmbedding(text)
}

// Экспортируем функцию для батчинга
export const createEmbeddingsBatch = async (
  texts: string[]
): Promise<TaskEither<Error, EmbeddingResult[]>> => {
  return ollamaEmbeddingsClient.createEmbeddings(texts)
}
```

#### Использование в VIBE-KNOWLEDGE-KEEPER

```typescript
// Обновленный код генерации embeddings
async function generateEmbeddings(
  chunks: CodeChunk[]
): Promise<TaskEither<Error, Embedding[]>> {
  // Используем батчинг для эффективности
  const texts = chunks.map(chunk => chunk.content)
  
  const embeddingsResult = await createEmbeddingsBatch(texts)
  
  if (embeddingsResult.isLeft()) {
    return left(embeddingsResult.value)
  }
  
  const embeddings: Embedding[] = embeddingsResult.value.map(
    (embeddingResult, index) => ({
      id: chunks[index].id,
      content: chunks[index].content,
      file: chunks[index].file,
      lineStart: chunks[index].lineStart,
      lineEnd: chunks[index].lineEnd,
      embedding: embeddingResult.vector,
      metadata: {
        type: chunks[index].type,
        language: chunks[index].language,
        functionName: chunks[index].functionName,
        className: chunks[index].className,
      },
    })
  )
  
  return right(embeddings)
}
```

#### Переменные окружения

```bash
# .env
# Ollama конфигурация
OLLAMA_BASE_URL=http://localhost:11434
OLLAMA_EMBEDDING_MODEL=nomic-embed-text

# Альтернативные модели для эмбеддингов:
# - nomic-embed-text (768 dims) - рекомендуется для кода
# - all-minilm (384 dims) - быстрее, меньше размерность
# - mxbai-embed-large (1024 dims) - больше размерность, лучше качество
```

#### Преимущества использования Ollama

- ✅ **Локальность**: Работает полностью локально, без интернета
- ✅ **Приватность**: Данные не отправляются в облако
- ✅ **Бесплатность**: Нет платы за API вызовы
- ✅ **Скорость**: Быстрая генерация на локальной машине
- ✅ **Гибкость**: Можно использовать разные модели
- ✅ **Офлайн**: Работает без подключения к интернету

#### Рекомендуемые модели Ollama для эмбеддингов

1. **nomic-embed-text** (768 dims) - рекомендуется:
   - Хорошее качество для кода и документации
   - Оптимальный баланс размерности и качества
   - Поддержка мультиязычности

2. **all-minilm** (384 dims):
   - Быстрее генерация
   - Меньше размерность (экономия места в БД)
   - Хорошо для простых задач

3. **mxbai-embed-large** (1024 dims):
   - Лучшее качество
   - Больше размерность (требует больше места)
   - Для сложных задач семантического поиска

---

## 📊 Телеметрия и диагностика: Полная видимость "под капотом"

> **🚨 КРИТИЧЕСКИ ВАЖНО**: Телеметрия должна быть везде - во всех плагинах и агентах!  
> **🔍 ЦЕЛЬ**: Полная диагностика "под капотом" для админа - видеть все, что происходит в системе  
> **🌐 ВЕБ-ИНТЕРФЕЙС**: Диагностический плагин с веб-интерфейсом для визуализации метрик и диагностики

> **📚 Официальная документация**: [ElizaOS Plugin Development Guide](https://docs.elizaos.ai/guides/create-a-plugin) - **ИЗУЧИТЬ ПЕРЕД РЕАЛИЗАЦИЕЙ!**

---

### 🎯 Концепция телеметрии и диагностики

**VIBEE-DIAGNOSTICS** - это специализированный плагин, который:

- ✅ **Собирает телеметрию** из всех плагинов и агентов
- ✅ **Предоставляет веб-интерфейс** для визуализации метрик
- ✅ **Диагностирует проблемы** в реальном времени
- ✅ **Отслеживает производительность** всех компонентов
- ✅ **Показывает "под капотом"** что происходит в системе
- ✅ **Интегрируется с Sentry** для полной картины

**Цель**: Полная прозрачность системы для админа через веб-интерфейс! 🐝

---

### 🏗️ Архитектура телеметрии

```
┌─────────────────────────────────────────────────┐
│    Все плагины и агенты (VIBE-*)               │
│    - Телеметрия встроена везде                 │
└─────────────────────────────────────────────────┘
                    │
        ┌───────────┼───────────┐
        │           │           │
        ▼           ▼           ▼
┌─────────────┐ ┌─────────────┐ ┌─────────────┐
│  Metrics    │ │  Events     │ │  Traces     │
│  Collector  │ │  Collector  │ │  Collector  │
└─────────────┘ └─────────────┘ └─────────────┘
        │           │           │
        └───────────┼───────────┘
                    │
                    ▼
        ┌───────────────────────┐
        │  VIBE-DIAGNOSTICS     │
        │  (Центральный плагин) │
        └───────────────────────┘
                    │
        ┌───────────┼───────────┐
        │           │           │
        ▼           ▼           ▼
┌─────────────┐ ┌─────────────┐ ┌─────────────┐
│  Database   │ │  Web UI     │ │  API        │
│  (Metrics)  │ │  (Dashboard)│ │  (REST)     │
└─────────────┘ └─────────────┘ └─────────────┘
```

---

### 📊 VIBE-DIAGNOSTICS: Диагностический плагин с веб-интерфейсом

#### Назначение

**VIBE-DIAGNOSTICS** - это плагин ElizaOS с веб-интерфейсом, который:

- ✅ Собирает телеметрию из всех плагинов
- ✅ Предоставляет веб-интерфейс для визуализации
- ✅ Диагностирует проблемы в реальном времени
- ✅ Отслеживает производительность
- ✅ Показывает метрики агентов и плагинов

#### Структура плагина (на основе ElizaOS)

Согласно [официальной документации ElizaOS](https://docs.elizaos.ai/guides/create-a-plugin), плагин с веб-интерфейсом создается так:

```
vibe-diagnostics/
├── src/
│   ├── index.ts              # Экспорт плагина
│   ├── plugin.ts             # Основной плагин
│   ├── actions/               # Actions плагина
│   │   └── diagnostics.ts
│   ├── providers/            # Providers для контекста
│   │   └── metrics.ts
│   ├── services/             # Services для фоновых задач
│   │   └── telemetry.ts
│   ├── routes/               # Веб-маршруты (ElizaOS routes)
│   │   ├── dashboard.ts      # Главная страница
│   │   ├── metrics.ts        # API для метрик
│   │   └── diagnostics.ts   # API для диагностики
│   ├── web/                  # Веб-интерфейс (React/Vue)
│   │   ├── index.html
│   │   ├── dashboard.html
│   │   └── assets/
│   └── __tests__/            # Тесты
└── package.json
```

#### Интерфейс VIBE-DIAGNOSTICS плагина

```typescript
// src/plugin.ts
import { Plugin, Action, Provider, Service, Route } from '@elizaos/core'
import { diagnosticsAction } from './actions/diagnostics'
import { metricsProvider } from './providers/metrics'
import { telemetryService } from './services/telemetry'
import { dashboardRoute, metricsRoute, diagnosticsRoute } from './routes'

export const vibeDiagnosticsPlugin: Plugin = {
  name: 'vibe-diagnostics',
  description: 'Telemetry and diagnostics plugin with web interface for VIBEE ecosystem',
  version: '1.0.0',
  
  // Actions - что агент может делать
  actions: [
    diagnosticsAction, // Действие для диагностики
  ],
  
  // Providers - контекст для агента
  providers: [
    metricsProvider, // Метрики для контекста
  ],
  
  // Services - фоновые задачи
  services: [
    telemetryService, // Сбор телеметрии
  ],
  
  // Routes - веб-маршруты (ElizaOS routes)
  routes: [
    dashboardRoute,    // Главная страница дашборда
    metricsRoute,      // API для метрик
    diagnosticsRoute, // API для диагностики
  ],
  
  // Конфигурация
  config: {
    telemetryEnabled: true,
    metricsRetentionDays: 30,
    webPort: 3001, // Порт для веб-интерфейса
    updateInterval: 1000, // Интервал обновления метрик (мс)
  }
}

export default vibeDiagnosticsPlugin
```

#### Action: Диагностика системы

```typescript
// src/actions/diagnostics.ts
import {
  Action,
  ActionResult,
  IAgentRuntime,
  Memory,
  HandlerCallback,
  State,
  logger,
} from '@elizaos/core'
import { getSystemMetrics } from '../services/telemetry'
import { diagnoseIssues } from '../services/diagnostics'

export const diagnosticsAction: Action = {
  name: 'SYSTEM_DIAGNOSTICS',
  similes: [
    'DIAGNOSE',
    'CHECK_SYSTEM',
    'SYSTEM_HEALTH',
    'SHOW_METRICS',
    'DIAGNOSTICS',
  ],
  description: 'Run system diagnostics and show metrics. Use when user asks about system health, performance, or wants to see what\'s happening under the hood.',
  
  validate: async (runtime: IAgentRuntime, message: Memory): Promise<boolean> => {
    // Всегда доступно для диагностики
    return true
  },
  
  handler: async (
    runtime: IAgentRuntime,
    message: Memory,
    state: State | undefined,
    options: any,
    callback?: HandlerCallback
  ): Promise<ActionResult> => {
    try {
      // Получаем метрики системы
      const metrics = await getSystemMetrics(runtime)
      
      // Диагностируем проблемы
      const diagnostics = await diagnoseIssues(metrics)
      
      // Форматируем ответ
      const response = formatDiagnosticsResponse(metrics, diagnostics)
      
      if (callback) {
        await callback({
          text: response.text,
          actions: ['SYSTEM_DIAGNOSTICS'],
          source: message.content.source,
          data: {
            metrics,
            diagnostics,
            webUrl: `http://localhost:3001/dashboard`, // Ссылка на веб-интерфейс
          },
        })
      }
      
      return {
        success: true,
        text: response.text,
        data: {
          metrics,
          diagnostics,
          webUrl: `http://localhost:3001/dashboard`,
        },
      }
    } catch (error) {
      logger.error('Diagnostics action failed:', error)
      return {
        success: false,
        text: `Diagnostics failed: ${error.message}`,
      }
    }
  },
  
  examples: [
    [
      {
        name: '{{user}}',
        content: { text: 'Show me system diagnostics' },
      },
      {
        name: '{{agent}}',
        content: {
          text: 'Running diagnostics... Check the web dashboard at http://localhost:3001',
          actions: ['SYSTEM_DIAGNOSTICS'],
        },
      },
    ],
  ],
}
```

#### Provider: Метрики для контекста

```typescript
// src/providers/metrics.ts
import {
  Provider,
  ProviderResult,
  IAgentRuntime,
  Memory,
  State,
} from '@elizaos/core'
import { getSystemMetrics } from '../services/telemetry'

export const metricsProvider: Provider = {
  name: 'SYSTEM_METRICS',
  description: 'Provides system metrics and telemetry data to the agent',
  
  get: async (
    runtime: IAgentRuntime,
    message: Memory,
    state?: State
  ): Promise<ProviderResult> => {
    const metrics = await getSystemMetrics(runtime)
    
    return {
      content: [
        {
          type: 'text',
          text: `System Metrics:
- Active Agents: ${metrics.activeAgents}
- Total Actions: ${metrics.totalActions}
- Success Rate: ${metrics.successRate}%
- Average Response Time: ${metrics.avgResponseTime}ms
- Error Rate: ${metrics.errorRate}%
- Memory Usage: ${metrics.memoryUsage}MB
- CPU Usage: ${metrics.cpuUsage}%`,
        },
      ],
    }
  },
}
```

#### Service: Сбор телеметрии

```typescript
// src/services/telemetry.ts
import { Service, IAgentRuntime, logger } from '@elizaos/core'
import { db } from '@/core/drizzle/client'
import { agentMetrics } from '@/core/drizzle/schema'

export const telemetryService: Service = {
  name: 'telemetry-collector',
  description: 'Collects telemetry from all plugins and agents',
  
  initialize: async (runtime: IAgentRuntime): Promise<void> => {
    logger.info('Telemetry service initialized')
    
    // Запускаем сбор метрик каждую секунду
    setInterval(async () => {
      await collectMetrics(runtime)
    }, 1000)
  },
  
  start: async (runtime: IAgentRuntime): Promise<void> => {
    logger.info('Telemetry service started')
  },
  
  stop: async (): Promise<void> => {
    logger.info('Telemetry service stopped')
  },
}

async function collectMetrics(runtime: IAgentRuntime): Promise<void> {
  try {
    const metrics = {
      timestamp: new Date(),
      activeAgents: runtime.agents?.length || 0,
      totalActions: await getTotalActions(),
      successRate: await getSuccessRate(),
      avgResponseTime: await getAvgResponseTime(),
      errorRate: await getErrorRate(),
      memoryUsage: process.memoryUsage().heapUsed / 1024 / 1024, // MB
      cpuUsage: await getCpuUsage(),
    }
    
    // Сохраняем в БД
    await db.insert(agentMetrics).values(metrics)
  } catch (error) {
    logger.error('Failed to collect metrics:', error)
  }
}
```

#### Routes: Веб-интерфейс (ElizaOS Routes)

```typescript
// src/routes/dashboard.ts
import { Route, IAgentRuntime } from '@elizaos/core'
import { getSystemMetrics } from '../services/telemetry'
import { getDashboardHTML } from '../web/dashboard'

export const dashboardRoute: Route = {
  method: 'GET',
  path: '/dashboard',
  handler: async (runtime: IAgentRuntime, req: any, res: any) => {
    try {
      const metrics = await getSystemMetrics(runtime)
      const html = getDashboardHTML(metrics)
      
      res.setHeader('Content-Type', 'text/html')
      res.send(html)
    } catch (error) {
      res.status(500).json({ error: error.message })
    }
  },
}

// src/routes/metrics.ts
export const metricsRoute: Route = {
  method: 'GET',
  path: '/api/metrics',
  handler: async (runtime: IAgentRuntime, req: any, res: any) => {
    try {
      const metrics = await getSystemMetrics(runtime)
      res.json(metrics)
    } catch (error) {
      res.status(500).json({ error: error.message })
    }
  },
}

// src/routes/diagnostics.ts
export const diagnosticsRoute: Route = {
  method: 'GET',
  path: '/api/diagnostics',
  handler: async (runtime: IAgentRuntime, req: any, res: any) => {
    try {
      const diagnostics = await diagnoseIssues(await getSystemMetrics(runtime))
      res.json(diagnostics)
    } catch (error) {
      res.status(500).json({ error: error.message })
    }
  },
}
```

#### Веб-интерфейс: Dashboard HTML

```typescript
// src/web/dashboard.ts
export function getDashboardHTML(metrics: SystemMetrics): string {
  return `
<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>VIBEE Diagnostics Dashboard 🐝</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: #333;
      padding: 20px;
    }
    .container {
      max-width: 1400px;
      margin: 0 auto;
    }
    .header {
      background: white;
      padding: 20px;
      border-radius: 10px;
      margin-bottom: 20px;
      box-shadow: 0 4px 6px rgba(0,0,0,0.1);
    }
    .header h1 {
      color: #667eea;
      font-size: 2em;
      margin-bottom: 10px;
    }
    .metrics-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 20px;
      margin-bottom: 20px;
    }
    .metric-card {
      background: white;
      padding: 20px;
      border-radius: 10px;
      box-shadow: 0 4px 6px rgba(0,0,0,0.1);
    }
    .metric-card h3 {
      color: #667eea;
      margin-bottom: 10px;
      font-size: 0.9em;
      text-transform: uppercase;
    }
    .metric-value {
      font-size: 2em;
      font-weight: bold;
      color: #333;
    }
    .metric-label {
      color: #666;
      font-size: 0.9em;
      margin-top: 5px;
    }
    .chart-container {
      background: white;
      padding: 20px;
      border-radius: 10px;
      box-shadow: 0 4px 6px rgba(0,0,0,0.1);
      margin-bottom: 20px;
    }
    .agents-list {
      background: white;
      padding: 20px;
      border-radius: 10px;
      box-shadow: 0 4px 6px rgba(0,0,0,0.1);
    }
    .agent-item {
      padding: 15px;
      border-bottom: 1px solid #eee;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .agent-item:last-child {
      border-bottom: none;
    }
    .status-badge {
      padding: 5px 10px;
      border-radius: 5px;
      font-size: 0.8em;
      font-weight: bold;
    }
    .status-active { background: #4CAF50; color: white; }
    .status-error { background: #F44336; color: white; }
    .status-warning { background: #FF9800; color: white; }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>🐝 VIBEE Diagnostics Dashboard</h1>
      <p>Полная диагностика системы в реальном времени</p>
    </div>
    
    <div class="metrics-grid">
      <div class="metric-card">
        <h3>Активные агенты</h3>
        <div class="metric-value">${metrics.activeAgents}</div>
        <div class="metric-label">🐝 Пчелок работает</div>
      </div>
      
      <div class="metric-card">
        <h3>Успешность</h3>
        <div class="metric-value">${metrics.successRate}%</div>
        <div class="metric-label">✅ Успешных операций</div>
      </div>
      
      <div class="metric-card">
        <h3>Среднее время ответа</h3>
        <div class="metric-value">${metrics.avgResponseTime}ms</div>
        <div class="metric-label">⏱️ Время выполнения</div>
      </div>
      
      <div class="metric-card">
        <h3>Использование памяти</h3>
        <div class="metric-value">${metrics.memoryUsage.toFixed(1)}MB</div>
        <div class="metric-label">💾 Heap память</div>
      </div>
      
      <div class="metric-card">
        <h3>Использование CPU</h3>
        <div class="metric-value">${metrics.cpuUsage}%</div>
        <div class="metric-label">⚡ Загрузка процессора</div>
      </div>
      
      <div class="metric-card">
        <h3>Ошибки</h3>
        <div class="metric-value">${metrics.errorRate}%</div>
        <div class="metric-label">❌ Процент ошибок</div>
      </div>
    </div>
    
    <div class="chart-container">
      <h2>График метрик за последний час</h2>
      <canvas id="metricsChart" width="800" height="400"></canvas>
    </div>
    
    <div class="agents-list">
      <h2>Статус агентов</h2>
      ${metrics.agents.map(agent => `
        <div class="agent-item">
          <div>
            <strong>${agent.name}</strong>
            <div style="color: #666; font-size: 0.9em;">${agent.description}</div>
          </div>
          <span class="status-badge status-${agent.status}">
            ${agent.status === 'active' ? '✅ Активен' : agent.status === 'error' ? '❌ Ошибка' : '⚠️ Предупреждение'}
          </span>
        </div>
      `).join('')}
    </div>
  </div>
  
  <script>
    // Обновление метрик каждую секунду
    setInterval(async () => {
      const response = await fetch('/api/metrics');
      const metrics = await response.json();
      updateDashboard(metrics);
    }, 1000);
    
    function updateDashboard(metrics) {
      // Обновляем метрики
      document.querySelectorAll('.metric-value').forEach((el, i) => {
        const values = [
          metrics.activeAgents,
          metrics.successRate + '%',
          metrics.avgResponseTime + 'ms',
          metrics.memoryUsage.toFixed(1) + 'MB',
          metrics.cpuUsage + '%',
          metrics.errorRate + '%'
        ];
        el.textContent = values[i];
      });
    }
  </script>
</body>
</html>
  `
}
```

---

### 📊 Телеметрия в каждом плагине

#### Интеграция телеметрии в плагины

**Каждый плагин должен собирать телеметрию**:

```typescript
// src/core/telemetry/withTelemetry.ts
import { TaskEither, right, left } from '@/core/functional/utils/result'
import { pipe, chain, tap } from '@/core/functional/utils/composition'
import { db } from '@/core/drizzle/client'
import { pluginMetrics } from '@/core/drizzle/schema'

/**
 * Обертка для автоматического сбора телеметрии
 * КРИТИЧЕСКИ ВАЖНО: Использовать для ВСЕХ действий плагинов!
 */
export function withTelemetry<T extends (...args: any[]) => Promise<any>>(
  fn: T,
  context: {
    plugin: string
    action: string
  }
): T {
  return (async (...args: Parameters<T>) => {
    const startTime = Date.now()
    const startMemory = process.memoryUsage().heapUsed
    
    try {
      // Выполняем действие
      const result = await fn(...args)
      const duration = Date.now() - startTime
      const endMemory = process.memoryUsage().heapUsed
      const memoryDelta = endMemory - startMemory
      
      // Сохраняем метрики успеха
      await saveTelemetry({
        plugin: context.plugin,
        action: context.action,
        duration,
        memoryDelta,
        success: true,
        timestamp: new Date(),
      })
      
      return result
    } catch (error) {
      const duration = Date.now() - startTime
      
      // Сохраняем метрики ошибки
      await saveTelemetry({
        plugin: context.plugin,
        action: context.action,
        duration,
        success: false,
        error: error.message,
        timestamp: new Date(),
      })
      
      throw error
    }
  }) as T
}

async function saveTelemetry(metrics: PluginMetrics): Promise<void> {
  await db.insert(pluginMetrics).values(metrics)
}
```

**Использование в плагинах**:

```typescript
// Пример использования в плагине
import { withTelemetry } from '@/core/telemetry/withTelemetry'
import { withLogging } from '@/core/sentry/withLogging'
import { withSentry } from '@/core/sentry'

export const myPlugin: BotPlugin = {
  name: 'my-plugin',
  
  actions: {
    // Комбинируем телеметрию, логирование и Sentry
    myAction: withSentry(
      withLogging(
        withTelemetry(
          async (input: Input) => {
            // Логика действия
            return result
          },
          {
            plugin: 'my-plugin',
            action: 'myAction',
          }
        ),
        {
          agent: 'VIBE-IMAGE-GENERATOR',
          plugin: 'my-plugin',
          action: 'myAction',
        }
      ),
      {
        agent: 'VIBE-IMAGE-GENERATOR',
        plugin: 'my-plugin',
        action: 'myAction',
      }
    ),
  },
}
```

---

### 🗄️ База данных для телеметрии

#### Схема таблиц

```sql
-- Таблица метрик плагинов
CREATE TABLE plugin_metrics (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  
  -- Идентификация
  plugin_name VARCHAR(100) NOT NULL,
  action_name VARCHAR(100) NOT NULL,
  timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  
  -- Метрики производительности
  duration INTEGER NOT NULL, -- мс
  memory_delta BIGINT, -- байты
  cpu_usage DECIMAL(5,2), -- %
  
  -- Результат
  success BOOLEAN NOT NULL,
  error_message TEXT,
  
  -- Контекст
  input_size INTEGER, -- размер входных данных
  output_size INTEGER, -- размер выходных данных
  
  -- Индексы
  CONSTRAINT plugin_metrics_plugin_idx 
    CREATE INDEX ON plugin_metrics(plugin_name, timestamp DESC),
  CONSTRAINT plugin_metrics_action_idx 
    CREATE INDEX ON plugin_metrics(action_name, timestamp DESC),
  CONSTRAINT plugin_metrics_success_idx 
    CREATE INDEX ON plugin_metrics(success, timestamp DESC)
);

-- Таблица метрик агентов
CREATE TABLE agent_metrics (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  
  -- Идентификация
  agent_name VARCHAR(100) NOT NULL,
  timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  
  -- Метрики
  active_tasks INTEGER DEFAULT 0,
  total_actions BIGINT DEFAULT 0,
  success_rate DECIMAL(5,2), -- %
  avg_response_time INTEGER, -- мс
  error_rate DECIMAL(5,2), -- %
  memory_usage DECIMAL(10,2), -- MB
  cpu_usage DECIMAL(5,2), -- %
  
  -- Статус
  status VARCHAR(20) NOT NULL CHECK (status IN ('active', 'idle', 'error', 'warning')),
  
  -- Индексы
  CONSTRAINT agent_metrics_agent_idx 
    CREATE INDEX ON agent_metrics(agent_name, timestamp DESC),
  CONSTRAINT agent_metrics_status_idx 
    CREATE INDEX ON agent_metrics(status, timestamp DESC)
);

-- Материализованное представление для быстрого доступа
CREATE MATERIALIZED VIEW system_metrics_summary AS
SELECT
  agent_name,
  COUNT(*) as total_metrics,
  AVG(success_rate) as avg_success_rate,
  AVG(avg_response_time) as avg_response_time,
  AVG(error_rate) as avg_error_rate,
  AVG(memory_usage) as avg_memory_usage,
  AVG(cpu_usage) as avg_cpu_usage,
  MAX(timestamp) as last_update
FROM agent_metrics
WHERE timestamp > NOW() - INTERVAL '1 hour'
GROUP BY agent_name;

-- Функция для получения метрик системы
CREATE OR REPLACE FUNCTION get_system_metrics()
RETURNS JSONB AS $$
DECLARE
  v_metrics JSONB;
BEGIN
  SELECT jsonb_build_object(
    'activeAgents', (
      SELECT COUNT(DISTINCT agent_name)
      FROM agent_metrics
      WHERE timestamp > NOW() - INTERVAL '1 minute'
        AND status = 'active'
    ),
    'totalActions', (
      SELECT SUM(total_actions)
      FROM agent_metrics
      WHERE timestamp > NOW() - INTERVAL '1 hour'
    ),
    'successRate', (
      SELECT AVG(success_rate)
      FROM agent_metrics
      WHERE timestamp > NOW() - INTERVAL '1 hour'
    ),
    'avgResponseTime', (
      SELECT AVG(avg_response_time)
      FROM agent_metrics
      WHERE timestamp > NOW() - INTERVAL '1 hour'
    ),
    'errorRate', (
      SELECT AVG(error_rate)
      FROM agent_metrics
      WHERE timestamp > NOW() - INTERVAL '1 hour'
    ),
    'memoryUsage', (
      SELECT AVG(memory_usage)
      FROM agent_metrics
      WHERE timestamp > NOW() - INTERVAL '1 minute'
    ),
    'cpuUsage', (
      SELECT AVG(cpu_usage)
      FROM agent_metrics
      WHERE timestamp > NOW() - INTERVAL '1 minute'
    ),
    'agents', (
      SELECT jsonb_agg(
        jsonb_build_object(
          'name', agent_name,
          'status', status,
          'successRate', success_rate,
          'avgResponseTime', avg_response_time,
          'memoryUsage', memory_usage,
          'cpuUsage', cpu_usage
        )
      )
      FROM agent_metrics
      WHERE timestamp > NOW() - INTERVAL '1 minute'
    )
  ) INTO v_metrics;
  
  RETURN v_metrics;
END;
$$ LANGUAGE plpgsql;
```

---

### 🎯 Примеры использования диагностики

#### Пример 1: Запрос диагностики через Telegram

```
Вы: Покажи диагностику системы

🤖 VIBE-DIAGNOSTICS: 
   📊 Диагностика системы:
   
   🐝 Активные агенты: 10
   ✅ Успешность: 98.5%
   ⏱️  Среднее время ответа: 245ms
   💾 Использование памяти: 512MB
   ⚡ Использование CPU: 45%
   ❌ Ошибки: 1.5%
   
   🌐 Подробная диагностика: http://localhost:3001/dashboard
   
   [🌐 Открыть Dashboard] [📊 Детальные метрики] [🔍 Диагностика проблем]
```

#### Пример 2: Веб-интерфейс Dashboard

**Открываем**: `http://localhost:3001/dashboard`

**Видим**:
- 📊 Метрики в реальном времени
- 📈 Графики производительности
- 🐝 Список всех агентов со статусами
- 🔍 Детальная диагностика проблем
- 📝 История метрик

---

### ✅ Чек-лист реализации телеметрии

1. **VIBE-DIAGNOSTICS плагин**:
   - [ ] Создать плагин по структуре ElizaOS
   - [ ] Добавить веб-интерфейс (routes)
   - [ ] Реализовать сбор метрик
   - [ ] Добавить диагностику проблем

2. **Телеметрия в плагинах**:
   - [ ] Создать обертку `withTelemetry`
   - [ ] Интегрировать во все плагины
   - [ ] Сохранять метрики в БД
   - [ ] Добавить индексы для быстрого поиска

3. **Веб-интерфейс**:
   - [ ] Создать Dashboard HTML
   - [ ] Добавить графики метрик
   - [ ] Реализовать обновление в реальном времени
   - [ ] Добавить фильтры и поиск

4. **API для метрик**:
   - [ ] Реализовать `/api/metrics`
   - [ ] Реализовать `/api/diagnostics`
   - [ ] Добавить фильтрацию по времени
   - [ ] Добавить агрегацию данных

---

**📊 Телеметрия и диагностика готовы! Теперь админ видит все "под капотом" через веб-интерфейс!** 🐝

---

## 📈 Claude Code Analytics API: Мониторинг продуктивности агентов

> **🚨 КРИТИЧЕСКИ ВАЖНО**: Интеграция с Claude Code Analytics API для отслеживания продуктивности агентов!  
> **📊 ЦЕЛЬ**: Мониторинг метрик разработки, использования инструментов и стоимости работы агентов  
> **🔗 ОФИЦИАЛЬНАЯ ДОКУМЕНТАЦИЯ**: [Claude Code Analytics API](https://docs.claude.com/en/docs/build-with-claude/claude-code-analytics-api) - **ИЗУЧИТЬ ПЕРЕД РЕАЛИЗАЦИЕЙ!**

---

### 🎯 Концепция интеграции с Claude Code Analytics

**VIBEE-DIAGNOSTICS** интегрируется с Claude Code Analytics API для:

- ✅ **Отслеживания продуктивности**: Сессии, строки кода, коммиты, PR
- ✅ **Мониторинга инструментов**: Acceptance/rejection rates для Edit, Write, NotebookEdit
- ✅ **Анализа стоимости**: Токены и стоимость по моделям Claude
- ✅ **Отчетности**: Экспорт данных для дашбордов и отчетов
- ✅ **Оптимизации**: Выявление паттернов использования и улучшение работы агентов

**Цель**: Полная видимость продуктивности агентов через Claude Code Analytics! 🐝

---

### 🔗 Интеграция с Claude Code Analytics API

#### Настройка API

```typescript
// src/core/claude-analytics/client.ts
import { TaskEither, right, left, tryCatchAsync } from '@/core/functional/utils/result'
import { pipe, chain } from '@/core/functional/utils/composition'

interface ClaudeAnalyticsConfig {
  adminApiKey: string // Admin API key (sk-ant-admin...)
  organizationId?: string // Опционально, если нужно фильтровать по организации
  baseUrl?: string // По умолчанию: https://api.anthropic.com
}

class ClaudeAnalyticsClient {
  private config: ClaudeAnalyticsConfig

  constructor(config: ClaudeAnalyticsConfig) {
    this.config = {
      baseUrl: 'https://api.anthropic.com',
      ...config,
    }
  }

  /**
   * Получить аналитику Claude Code за конкретный день
   */
  async getAnalytics(
    date: string, // YYYY-MM-DD format
    options?: {
      limit?: number // По умолчанию 20, максимум 1000
      page?: string // Cursor для пагинации
    }
  ): Promise<TaskEither<Error, ClaudeAnalyticsResponse>> {
    return tryCatchAsync(
      async () => {
        const params = new URLSearchParams({
          starting_at: date,
          ...(options?.limit && { limit: options.limit.toString() }),
          ...(options?.page && { page: options.page }),
        })

        const response = await fetch(
          `${this.config.baseUrl}/v1/organizations/usage_report/claude_code?${params}`,
          {
            method: 'GET',
            headers: {
              'anthropic-version': '2023-06-01',
              'x-api-key': this.config.adminApiKey,
              'User-Agent': 'VIBEE-DIAGNOSTICS/1.0.0 (https://vibee.ai)',
            },
          }
        )

        if (!response.ok) {
          throw new Error(`Claude Analytics API error: ${response.statusText}`)
        }

        return await response.json()
      },
      (error) => error as Error
    )
  }

  /**
   * Получить все данные за день с пагинацией
   */
  async getAllAnalytics(
    date: string
  ): Promise<TaskEither<Error, ClaudeAnalyticsRecord[]>> {
    return pipe(
      this.getAnalytics(date, { limit: 1000 }),
      chain(async (response) => {
        const allRecords: ClaudeAnalyticsRecord[] = [...response.data]

        // Если есть еще страницы, получаем их
        let currentPage = response.next_page
        while (currentPage && response.has_more) {
          const nextResponse = await this.getAnalytics(date, {
            page: currentPage,
            limit: 1000,
          })

          if (nextResponse.isLeft()) {
            return left(nextResponse.value)
          }

          allRecords.push(...nextResponse.value.data)
          currentPage = nextResponse.value.next_page
        }

        return right(allRecords)
      })
    )
  }
}

export const claudeAnalyticsClient = new ClaudeAnalyticsClient({
  adminApiKey: process.env.CLAUDE_ADMIN_API_KEY || '',
  organizationId: process.env.CLAUDE_ORGANIZATION_ID,
})
```

#### Типы данных

```typescript
// src/core/claude-analytics/types.ts

export interface ClaudeAnalyticsRecord {
  date: string // RFC 3339 format (UTC timestamp)
  actor: {
    type: 'user_actor' | 'api_actor'
    email_address?: string // Для user_actor
    api_key_name?: string // Для api_actor
  }
  organization_id: string
  customer_type: 'api' | 'subscription'
  terminal_type: string // e.g., 'vscode', 'iTerm.app', 'tmux'
  
  core_metrics: {
    num_sessions: number
    lines_of_code: {
      added: number
      removed: number
    }
    commits_by_claude_code: number
    pull_requests_by_claude_code: number
  }
  
  tool_actions: {
    edit_tool?: {
      accepted: number
      rejected: number
    }
    multi_edit_tool?: {
      accepted: number
      rejected: number
    }
    write_tool?: {
      accepted: number
      rejected: number
    }
    notebook_edit_tool?: {
      accepted: number
      rejected: number
    }
  }
  
  model_breakdown: Array<{
    model: string // e.g., 'claude-sonnet-4-5-20250929'
    tokens: {
      input: number
      output: number
      cache_read: number
      cache_creation: number
    }
    estimated_cost: {
      currency: string // 'USD'
      amount: number // в центах
    }
  }>
}

export interface ClaudeAnalyticsResponse {
  data: ClaudeAnalyticsRecord[]
  has_more: boolean
  next_page: string | null
}
```

---

### 📊 Интеграция в VIBE-DIAGNOSTICS

#### Service: Сбор метрик Claude Code

```typescript
// src/services/claudeAnalytics.ts
import { Service, IAgentRuntime, logger } from '@elizaos/core'
import { claudeAnalyticsClient } from '@/core/claude-analytics/client'
import { db } from '@/core/drizzle/client'
import { claudeAnalyticsMetrics } from '@/core/drizzle/schema'
import { pipe, chain } from '@/core/functional/utils/composition'

export const claudeAnalyticsService: Service = {
  name: 'claude-analytics-collector',
  description: 'Collects Claude Code Analytics metrics for agent productivity tracking',
  
  initialize: async (runtime: IAgentRuntime): Promise<void> => {
    logger.info('Claude Analytics service initialized')
    
    // Запускаем сбор метрик каждый час (данные доступны с задержкой до 1 часа)
    setInterval(async () => {
      await collectClaudeAnalytics()
    }, 60 * 60 * 1000) // Каждый час
    
    // Первый сбор при старте
    await collectClaudeAnalytics()
  },
  
  start: async (runtime: IAgentRuntime): Promise<void> => {
    logger.info('Claude Analytics service started')
  },
  
  stop: async (): Promise<void> => {
    logger.info('Claude Analytics service stopped')
  },
}

async function collectClaudeAnalytics(): Promise<void> {
  try {
    // Получаем метрики за вчерашний день (данные доступны с задержкой)
    const yesterday = new Date()
    yesterday.setDate(yesterday.getDate() - 1)
    const dateStr = yesterday.toISOString().split('T')[0] // YYYY-MM-DD

    const result = await pipe(
      claudeAnalyticsClient.getAllAnalytics(dateStr),
      chain(async (records) => {
        // Сохраняем метрики в БД
        for (const record of records) {
          await db.insert(claudeAnalyticsMetrics).values({
            date: record.date,
            actor_type: record.actor.type,
            actor_email: record.actor.email_address,
            actor_api_key: record.actor.api_key_name,
            organization_id: record.organization_id,
            customer_type: record.customer_type,
            terminal_type: record.terminal_type,
            
            // Core metrics
            num_sessions: record.core_metrics.num_sessions,
            lines_added: record.core_metrics.lines_of_code.added,
            lines_removed: record.core_metrics.lines_of_code.removed,
            commits: record.core_metrics.commits_by_claude_code,
            pull_requests: record.core_metrics.pull_requests_by_claude_code,
            
            // Tool actions
            edit_tool_accepted: record.tool_actions.edit_tool?.accepted || 0,
            edit_tool_rejected: record.tool_actions.edit_tool?.rejected || 0,
            write_tool_accepted: record.tool_actions.write_tool?.accepted || 0,
            write_tool_rejected: record.tool_actions.write_tool?.rejected || 0,
            notebook_edit_tool_accepted: record.tool_actions.notebook_edit_tool?.accepted || 0,
            notebook_edit_tool_rejected: record.tool_actions.notebook_edit_tool?.rejected || 0,
            
            // Model breakdown (JSONB)
            model_breakdown: record.model_breakdown,
            
            // Aggregated metrics
            total_tokens_input: record.model_breakdown.reduce((sum, m) => sum + m.tokens.input, 0),
            total_tokens_output: record.model_breakdown.reduce((sum, m) => sum + m.tokens.output, 0),
            total_cost_cents: record.model_breakdown.reduce((sum, m) => sum + m.estimated_cost.amount, 0),
            
            created_at: new Date(),
          })
        }
        
        return right(records)
      })
    )

    if (result.isLeft()) {
      logger.error('Failed to collect Claude Analytics:', result.value)
    } else {
      logger.info(`Collected ${result.value.length} Claude Analytics records`)
    }
  } catch (error) {
    logger.error('Claude Analytics collection error:', error)
  }
}
```

#### Provider: Метрики продуктивности

```typescript
// src/providers/productivityMetrics.ts
import {
  Provider,
  ProviderResult,
  IAgentRuntime,
  Memory,
  State,
} from '@elizaos/core'
import { getProductivityMetrics } from '../services/claudeAnalytics'

export const productivityMetricsProvider: Provider = {
  name: 'PRODUCTIVITY_METRICS',
  description: 'Provides Claude Code productivity metrics to the agent',
  
  get: async (
    runtime: IAgentRuntime,
    message: Memory,
    state?: State
  ): Promise<ProviderResult> => {
    const metrics = await getProductivityMetrics()
    
    return {
      content: [
        {
          type: 'text',
          text: `Claude Code Productivity Metrics:
- Total Sessions: ${metrics.totalSessions}
- Lines of Code Added: ${metrics.totalLinesAdded}
- Lines of Code Removed: ${metrics.totalLinesRemoved}
- Commits: ${metrics.totalCommits}
- Pull Requests: ${metrics.totalPullRequests}
- Edit Tool Acceptance Rate: ${metrics.editToolAcceptanceRate}%
- Write Tool Acceptance Rate: ${metrics.writeToolAcceptanceRate}%
- Total Cost: $${metrics.totalCost.toFixed(2)}
- Total Tokens: ${metrics.totalTokens.toLocaleString()}`,
        },
      ],
    }
  },
}
```

#### Route: API для метрик продуктивности

```typescript
// src/routes/productivity.ts
import { Route, IAgentRuntime } from '@elizaos/core'
import { getProductivityMetrics } from '../services/claudeAnalytics'

export const productivityRoute: Route = {
  method: 'GET',
  path: '/api/productivity',
  handler: async (runtime: IAgentRuntime, req: any, res: any) => {
    try {
      const metrics = await getProductivityMetrics()
      res.json(metrics)
    } catch (error) {
      res.status(500).json({ error: error.message })
    }
  },
}
```

---

### 🗄️ База данных для Claude Analytics

#### Схема таблицы

```sql
-- Таблица метрик Claude Code Analytics
CREATE TABLE claude_analytics_metrics (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  
  -- Дата и актор
  date TIMESTAMP WITH TIME ZONE NOT NULL,
  actor_type VARCHAR(20) NOT NULL CHECK (actor_type IN ('user_actor', 'api_actor')),
  actor_email VARCHAR(255),
  actor_api_key VARCHAR(255),
  organization_id UUID NOT NULL,
  customer_type VARCHAR(20) NOT NULL CHECK (customer_type IN ('api', 'subscription')),
  terminal_type VARCHAR(100),
  
  -- Core metrics
  num_sessions INTEGER DEFAULT 0,
  lines_added INTEGER DEFAULT 0,
  lines_removed INTEGER DEFAULT 0,
  commits INTEGER DEFAULT 0,
  pull_requests INTEGER DEFAULT 0,
  
  -- Tool actions
  edit_tool_accepted INTEGER DEFAULT 0,
  edit_tool_rejected INTEGER DEFAULT 0,
  multi_edit_tool_accepted INTEGER DEFAULT 0,
  multi_edit_tool_rejected INTEGER DEFAULT 0,
  write_tool_accepted INTEGER DEFAULT 0,
  write_tool_rejected INTEGER DEFAULT 0,
  notebook_edit_tool_accepted INTEGER DEFAULT 0,
  notebook_edit_tool_rejected INTEGER DEFAULT 0,
  
  -- Model breakdown (JSONB)
  model_breakdown JSONB DEFAULT '[]',
  
  -- Aggregated metrics
  total_tokens_input BIGINT DEFAULT 0,
  total_tokens_output BIGINT DEFAULT 0,
  total_cost_cents INTEGER DEFAULT 0, -- в центах USD
  
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  
  -- Индексы
  CONSTRAINT claude_analytics_date_idx 
    CREATE INDEX ON claude_analytics_metrics(date DESC),
  CONSTRAINT claude_analytics_actor_idx 
    CREATE INDEX ON claude_analytics_metrics(actor_type, actor_email, actor_api_key),
  CONSTRAINT claude_analytics_org_idx 
    CREATE INDEX ON claude_analytics_metrics(organization_id, date DESC)
);

-- Функция для получения метрик продуктивности
CREATE OR REPLACE FUNCTION get_productivity_metrics(
  p_start_date DATE DEFAULT CURRENT_DATE - INTERVAL '30 days',
  p_end_date DATE DEFAULT CURRENT_DATE
)
RETURNS JSONB AS $$
DECLARE
  v_metrics JSONB;
BEGIN
  SELECT jsonb_build_object(
    'totalSessions', SUM(num_sessions),
    'totalLinesAdded', SUM(lines_added),
    'totalLinesRemoved', SUM(lines_removed),
    'totalCommits', SUM(commits),
    'totalPullRequests', SUM(pull_requests),
    'editToolAcceptanceRate', 
      CASE 
        WHEN SUM(edit_tool_accepted + edit_tool_rejected) > 0 
        THEN ROUND(
          (SUM(edit_tool_accepted)::DECIMAL / 
           SUM(edit_tool_accepted + edit_tool_rejected)) * 100, 
          2
        )
        ELSE 0
      END,
    'writeToolAcceptanceRate',
      CASE 
        WHEN SUM(write_tool_accepted + write_tool_rejected) > 0 
        THEN ROUND(
          (SUM(write_tool_accepted)::DECIMAL / 
           SUM(write_tool_accepted + write_tool_rejected)) * 100, 
          2
        )
        ELSE 0
      END,
    'totalCost', SUM(total_cost_cents) / 100.0, -- Конвертируем центы в доллары
    'totalTokens', SUM(total_tokens_input + total_tokens_output),
    'averageSessionsPerDay', AVG(num_sessions),
    'averageLinesPerDay', AVG(lines_added)
  ) INTO v_metrics
  FROM claude_analytics_metrics
  WHERE date >= p_start_date AND date <= p_end_date;
  
  RETURN v_metrics;
END;
$$ LANGUAGE plpgsql;
```

---

### 🎯 Примеры использования

#### Пример 1: Запрос метрик продуктивности через Telegram

```
Вы: Покажи метрики продуктивности агентов

🤖 VIBE-DIAGNOSTICS: 
   📊 Метрики продуктивности Claude Code:
   
   📈 Всего сессий: 1,234
   ➕ Строк кода добавлено: 45,678
   ➖ Строк кода удалено: 12,345
   💾 Коммитов: 567
   🔀 Pull Requests: 89
   
   ✅ Edit Tool: 92.5% принято
   ✅ Write Tool: 88.3% принято
   ✅ Notebook Edit: 95.0% принято
   
   💰 Общая стоимость: $1,234.56
   🎯 Всего токенов: 12,345,678
   
   🌐 Подробная аналитика: http://localhost:3001/productivity
```

#### Пример 2: Веб-интерфейс Productivity Dashboard

**Открываем**: `http://localhost:3001/productivity`

**Видим**:
- 📊 Графики продуктивности по дням
- 📈 Метрики использования инструментов
- 💰 Анализ стоимости по моделям
- 🎯 Acceptance rates для каждого инструмента
- 📝 Детальная разбивка по акторам

---

### ✅ Чек-лист интеграции Claude Code Analytics

1. **Настройка API**:
   - [ ] Получить Admin API key (sk-ant-admin...)
   - [ ] Настроить переменные окружения
   - [ ] Создать ClaudeAnalyticsClient
   - [ ] Добавить обработку ошибок

2. **Сбор метрик**:
   - [ ] Реализовать Service для сбора метрик
   - [ ] Настроить автоматический сбор (каждый час)
   - [ ] Сохранять метрики в БД
   - [ ] Обработать пагинацию

3. **База данных**:
   - [ ] Создать таблицу `claude_analytics_metrics`
   - [ ] Добавить индексы
   - [ ] Создать функцию `get_productivity_metrics`
   - [ ] Добавить материализованные представления

4. **Веб-интерфейс**:
   - [ ] Добавить страницу Productivity Dashboard
   - [ ] Реализовать графики метрик
   - [ ] Добавить фильтры по датам
   - [ ] Показать acceptance rates

5. **Интеграция**:
   - [ ] Добавить Provider для метрик продуктивности
   - [ ] Интегрировать в VIBE-DIAGNOSTICS
   - [ ] Добавить Route для API
   - [ ] Обновить Dashboard HTML

---

**📈 Claude Code Analytics API интегрирован! Теперь отслеживаем продуктивность агентов через официальный API!** 🐝

> **📚 Ссылка на документацию**: [Claude Code Analytics API](https://docs.claude.com/en/docs/build-with-claude/claude-code-analytics-api)

---

## 📋 Содержание

1. [ИИ Функции](#ии-функции)
2. [Видео и Фото](#видео-и-фото)
3. [Продвинутые Инструменты](#продвинутые-инструменты)
4. [Админские Функции](#админские-функции)
5. [Навигация и Поддержка](#навигация-и-поддержка)
6. [Оплата](#оплата)
7. [Общие паттерны и архитектура](#-общие-паттерны-и-архитектура)
8. [🧠 Мозг аватара: Единый источник правды](#-мозг-аватара-единый-источник-правды)

---

## 🤖 ИИ Функции

### 1. 🤖 Цифровое тело (`DigitalAvatarBody`)

**Описание**: Обучение персональной модели Stable Diffusion Flux для генерации изображений с лицом/телом пользователя.

**Требования**:
- ✅ Требует подписку
- ✅ Проверка баланса перед началом

**Интерфейс (Wizard Flow)**:
```
Step 1: Выбор модели обучения
  ├─ 🎨 Portrait Trainer (550⭐, 15-30 мин, 2500 шагов)
  └─ ⚡ Fast Training (220⭐, 10-15 мин, 1000 шагов)

Step 2: Выбор пола аватара
  ├─ Мужской ♂️
  └─ Женский ♀️

Step 3: Ввод названия модели
  └─ Текстовое поле (минимум 3 символа)

Step 4: Загрузка изображений для обучения
  └─ Минимум 10-15 фото (максимум 50)
     • Лицо четко видно
     • Анфас (прямо в камеру)
     • Хорошее освещение
     • Разнообразие ракурсов и выражений

Step 5: Подтверждение и запуск обучения
  └─ Обработка через Inngest (1-2 часа)
```

**Параметры для финального результата**:
- `trainingModel`: `'flux-lora-portrait-trainer'` | `'flux-lora-fast-training'`
- `gender`: `'male'` | `'female'`
- `modelName`: string (уникальное название)
- `images`: File[] (10-50 изображений)
- `steps`: number (2500 или 1000 в зависимости от модели)
- `learningRate`: number (автоматически)

**Результат**:
- Обученная модель доступна в списке моделей для Нейрофото
- `model_url`: URL модели в Replicate/FAL
- `trigger_word`: Уникальное слово для активации модели
- `status`: `'completed'` | `'failed'` | `'training'`

**Бизнес-логика**:
- Обучение происходит асинхронно через Inngest
- Пользователь получает уведомление при завершении
- Модель сохраняется в БД и привязывается к пользователю
- Стоимость списывается сразу при запуске обучения

---

### 2. 📸 Нейрофото (`NeuroPhoto`)

**Описание**: Генерация фото по текстовому промпту с использованием обученной персональной модели пользователя.

**Требования**:
- ✅ Требует подписку
- ✅ Наличие хотя бы одной обученной модели
- ✅ Проверка баланса (7.5⭐ за изображение)

**Интерфейс (Wizard Flow)**:
```
Step 1: Выбор модели (если несколько)
  └─ Inline кнопки со списком моделей
     • Формат: "Модель [дата], [шаги] шагов"
     • Или: "[название] (Общая модель команды)"

Step 2: Ввод промпта
  └─ Текстовое поле (минимум 3 символа)
     • Описание на английском языке
     • Автоматически добавляется trigger_word и gender

Step 3: Генерация первого изображения
  └─ Автоматически генерируется 1 изображение

Step 4: Дополнительные опции
  ├─ 1️⃣-4️⃣: Генерация дополнительных изображений
  ├─ 🆕 Новый промпт: Вернуться к шагу 2
  ├─ ⬆️ Улучшить промпт: Переход в ImprovePromptWizard
  ├─ 📐 Изменить размер: Переход в SizeWizard
  └─ 🏠 Главное меню: Выход
```

**Параметры для финального результата**:
- `userModel`: UserModel (выбранная модель из БД)
- `prompt`: string (текстовое описание)
- `numImages`: number (1-4)
- `gender`: `'male'` | `'female'` | `'person'` (из профиля пользователя)
- `trigger_word`: string (из модели)
- `aspect_ratio`: `'1:1'` | `'16:9'` | `'9:16'` (опционально)

**Результат**:
- Массив URL сгенерированных изображений
- Сохранение промпта в БД
- Списание баланса (7.5⭐ × количество изображений)

**Бизнес-логика**:
- Гибридная генерация: сначала пробует API сервер, затем локальная обработка
- Поддержка множественной генерации (до 4 изображений за раз)
- Автоматическое формирование полного промпта с деталями качества
- Сохранение истории генераций в БД
- **Улучшение промптов**: Использует OpenRouter API (`upgradePrompt()` функция) с моделью `'meta-llama/llama-3.2-3b-instruct:free'`

---

### 3. 🔍 Промпт из фото (`ImageToPrompt`)

**Описание**: Генерация текстового описания (промпта) из загруженного изображения с помощью AI.

**Требования**:
- ✅ Проверка баланса (стоимость зависит от настроек)

**Интерфейс (Wizard Flow)**:
```
Step 1: Запрос изображения
  └─ Сообщение с инструкцией

Step 2: Обработка изображения
  └─ Загрузка фото через Telegram API
     • Получение file_id
     • Конвертация в URL
     • Отправка на API (HuggingFace Space)
     • Генерация промпта
```

**Параметры для финального результата**:
- `imageUrl`: string (URL изображения из Telegram)
- `telegram_id`: string
- `username`: string
- `is_ru`: boolean

**Результат**:
- Текстовый промпт на английском языке
- Описание включает: цвета, стиль, настроение, композицию
- Сохранение в истории операций

**Бизнес-логика**:
- Использует HuggingFace Space API (`fancyfeast-joy-caption-alpha-two`)
- Режим: `'Descriptive'`, длина: `'long'`
- Стоимость списывается сразу после успешной генерации

---

### 4. 🧠 Мозг аватара (`Avatar`)

**Описание**: Настройка и управление "мозгом" аватара (AI-личность, модель для чата).

**Требования**:
- ✅ Бесплатно

**Интерфейс**: 
- Переход в сцену выбора AI модели для чата
- Настройка параметров личности аватара

**Параметры**:
- `model`: string (выбор AI модели через OpenRouter API: `'minimax/minimax-m2'` (рекомендуется), `'openai/gpt-4'`, `'anthropic/claude-3.5-sonnet'`, и т.д.)
- `personality`: object (настройки личности)

**Результат**:
- Сохранение выбранной модели в профиле пользователя
- Модель используется для чата с аватаром

---

### 5. 💭 Чат с аватаром (`ChatWithAvatar`)

**Описание**: Общение с AI-аватаром через текстовый чат.

**Требования**:
- ✅ Бесплатно
- ✅ Настроенный "мозг аватара" (модель)

**Интерфейс (Wizard Flow)**:
```
Step 1: Приветствие
  └─ Инструкция по использованию

Step 2: Цикл чата (бесконечный)
  ├─ Ввод текста пользователем
  ├─ Обработка через Openrouter API
  └─ Ответ аватара
```

**Параметры для каждого сообщения**:
- `prompt`: string (текст пользователя)
- `model`: string (из профиля пользователя или `'minimax/minimax-m2'` по умолчанию через OpenRouter API)
- `userData`: UserData (контекст пользователя)
- `languageCode`: `'ru'` | `'en'`

**Результат**:
- Текстовый ответ от AI
- Сохранение контекста разговора

**Бизнес-логика**:
- Использует функцию `answerAi()` из `core/openai/requests.ts` (подключение к OpenRouter API)
- OpenRouter API предоставляет доступ к множеству AI моделей через единый интерфейс
- Модель по умолчанию: `'minimax/minimax-m2'` (можно изменить в профиле пользователя)
- Поддержка многоязычности (автоматическое определение языка из `languageCode`)
- Контекстная память разговора (передача `userData` в системный промпт)
- Используется API ключ `OPENROUTER_API_KEY` из Infisical
- Lazy initialization клиента (создается только при первом использовании)

---

### 6. 🤖 Выбор модели ИИ (`SelectModel`)

**Описание**: Выбор AI-модели через OpenRouter API для генерации контента.

**Требования**:
- ✅ Бесплатно

**Интерфейс**:
- Список доступных моделей через OpenRouter API
- Inline кнопки для выбора

**Параметры**:
- `modelId`: string (ID выбранной модели в формате OpenRouter: `'minimax/minimax-m2'` (рекомендуется), `'openai/gpt-4'`, `'anthropic/claude-3.5-sonnet'`, и т.д.)

**Доступные модели через OpenRouter**:
- Minimax M2: `'minimax/minimax-m2'` (топовая модель для кодирования и агентов, MoE архитектура)
- OpenAI: `'openai/gpt-4'`, `'openai/gpt-3.5-turbo'`
- Anthropic Claude: `'anthropic/claude-3.5-sonnet'`, `'anthropic/claude-3-opus'`
- И другие модели из каталога OpenRouter

**Результат**:
- Сохранение выбора в профиле пользователя
- Применение модели для последующих операций через OpenRouter API

---

### 7. 🎤 Голос аватара (`Voice`)

**Описание**: Настройка и генерация голоса для аватара.

**Требования**:
- ✅ Требует подписку
- ✅ Проверка баланса

**Интерфейс**:
- Выбор голоса из библиотеки ElevenLabs
- Настройка параметров голоса

**Параметры**:
- `voice_id`: string (ID голоса из ElevenLabs)
- `voice_settings`: object (настройки: стабильность, похожесть)

**Результат**:
- Сохранение выбранного голоса в профиле
- Использование для озвучки видео/аудио

---

### 8. 🎙️ Текст в голос (`TextToSpeech`)

**Описание**: Преобразование текста в речь (TTS) с использованием ElevenLabs.

**Требования**:
- ✅ Требует подписку
- ✅ Проверка баланса

**Интерфейс (Wizard Flow)**:
```
Step 1: Ввод текста
  └─ Текстовое поле

Step 2: Выбор голоса (если не выбран ранее)
  └─ Список доступных голосов

Step 3: Генерация аудио
  └─ Обработка через ElevenLabs API
```

**Параметры для финального результата**:
- `text`: string (текст для озвучки)
- `voice_id`: string (ID голоса)
- `model_id`: string (модель TTS, по умолчанию `'eleven_multilingual_v2'`)

**Результат**:
- Аудио файл (MP3)
- Отправка пользователю
- Списание баланса

---

## 🎥 Видео и Фото

### 9. 🎥 Фото в видео (`ImageToVideo`)

**Описание**: Преобразование статичного изображения в видео с анимацией.

**Требования**:
- ✅ Проверка баланса (цена зависит от модели)

**Интерфейс (Wizard Flow)**:
```
Step 1: Выбор модели и формата
  └─ Клавиатура с кнопками моделей
     • Формат: "[Модель] [Соотношение] [Цена]⭐"
     • Примеры: "Veo 3 Fast 9:16 40⭐", "Kling v2.1 Pro 16:9 50⭐"

Step 2: Загрузка изображения
  └─ Отправка фото через Telegram

Step 3: Ввод промпта для анимации
  └─ Текстовое поле (минимум 3 символа)
     • Описание движения/действия в видео

Step 4: Генерация видео
  └─ Обработка через выбранный провайдер
     • Veo → Google API
     • Kling → Kie.ai API
     • Другие → Replicate/FAL
```

**Параметры для финального результата**:
- `imageUrl`: string (URL изображения)
- `prompt`: string (описание анимации)
- `videoModel`: VideoModelId (выбранная модель)
- `aspectRatio`: `'16:9'` | `'9:16'` | `'1:1'`
- `duration`: number (длительность в секундах, опционально)
- `telegram_id`: string
- `username`: string

**Результат**:
- Видео файл (MP4)
- URL видео для скачивания
- Сохранение в истории операций
- Списание баланса

**Бизнес-логика**:
- Поддержка множественных провайдеров (Veo, Kling, Replicate, FAL)
- Асинхронная обработка для долгих операций
- Callback через webhook при завершении
- Автоматическое удаление watermark (если доступно)

---

### 10. 🎥 Видео из текста (`TextToVideo`)

**Описание**: Генерация видео по текстовому промпту без исходного изображения.

**Требования**:
- ✅ Проверка баланса (цена зависит от модели)

**Интерфейс (Wizard Flow)**:
```
Step 1: Выбор модели и формата
  └─ Клавиатура с кнопками моделей
     • Аналогично ImageToVideo

Step 2: Ввод промпта
  └─ Текстовое поле (минимум 10 символов)
     • Подробное описание сцены/действия

Step 3: Генерация видео
  └─ Обработка через выбранный провайдер
```

**Параметры для финального результата**:
- `prompt`: string (описание видео)
- `videoModel`: VideoModelId
- `aspectRatio`: `'16:9'` | `'9:16'` | `'1:1'`
- `duration`: number (5-10 секунд, зависит от модели)
- `telegram_id`: string
- `username`: string

**Результат**:
- Видео файл (MP4)
- URL видео
- Сохранение в истории
- Списание баланса

**Бизнес-логика**:
- Поддержка моделей: Veo 3, Sora 2, WAN 2.2, Kling и др.
- Различные цены в зависимости от модели (40-100⭐)
- Асинхронная обработка через Inngest для долгих операций

---

### 11. 🖼️ Текст в фото (`TextToImage`)

**Описание**: Генерация изображения по текстовому описанию без использования персональной модели.

**Требования**:
- ✅ Проверка баланса

**Интерфейс (Wizard Flow)**:
```
Step 1: Выбор модели генерации
  └─ Клавиатура с моделями
     • FLUX, Stable Diffusion, DALL-E и др.

Step 2: Ввод промпта
  └─ Текстовое поле

Step 3: Выбор размера (опционально)
  └─ Inline кнопки: 512x512, 768x768, 1024x1024

Step 4: Генерация изображения
  └─ Обработка через выбранную модель
```

**Параметры для финального результата**:
- `prompt`: string (описание изображения)
- `model`: string (ID модели)
- `size`: `'512x512'` | `'768x768'` | `'1024x1024'`
- `telegram_id`: string

**Результат**:
- Изображение (PNG/JPG)
- URL изображения
- Сохранение в истории
- Списание баланса

---

### 12. 🎨 ИИ Фотошоп (`ai_photoshop`)

**Описание**: Редактирование изображений с помощью AI (удаление объектов, изменение фона, трансформации).

**Требования**:
- ✅ Проверка баланса (цена зависит от модели и качества)

**Интерфейс (Wizard Flow)**:
```
Step 1: Выбор режима работы
  ├─ SINGLE MODEL: Одна модель (5-8⭐)
  ├─ ALL MODELS: Все модели (21⭐ для 1K, 84⭐ для 2K, 126⭐ для 4K)
  └─ DIALOG MODE: Интерактивный режим редактирования

Step 2: Выбор модели (если SINGLE MODEL)
  ├─ SeeDream-4 (5⭐)
  ├─ Nano Banana (6⭐)
  ├─ FLUX Multi-Kontext (5⭐)
  ├─ Qwen Image Edit Plus (5⭐)
  ├─ FLUX Kontext Pro (8⭐)
  ├─ SeedEdit 3.0 (8⭐)
  └─ Qwen Image Edit (4⭐)

Step 3: Выбор качества (если ALL MODELS)
  ├─ 1K (21⭐)
  ├─ 2K (84⭐)
  └─ 4K (126⭐)

Step 4: Загрузка изображения
  └─ Отправка фото

Step 5: Ввод инструкции редактирования
  └─ Текстовое поле
     • Примеры: "Удалить фон", "Изменить цвет неба на красный"

Step 6: Обработка (DIALOG MODE)
  └─ Цикл редактирования:
     • Результат → Новые инструкции → Редактирование
```

**Параметры для финального результата**:
- `imageUrl`: string (URL исходного изображения)
- `instruction`: string (инструкция редактирования)
- `model`: string (ID модели)
- `quality`: `'1K'` | `'2K'` | `'4K'`
- `mode`: `'single'` | `'all'` | `'dialog'`
- `aspectRatio`: `'9:16'` (по умолчанию)

**Результат**:
- Отредактированное изображение
- URL результата
- Сохранение в истории
- Списание баланса

**Бизнес-логика**:
- Поддержка множественных моделей с разными возможностями
- Режим DIALOG позволяет последовательно редактировать изображение
- Автоматический выбор aspect ratio (9:16)
- Цены рассчитываются с наценкой 140% от себестоимости

---

### 13. ⬆️ Увеличить качество фото (`ImageUpscaler`)

**Описание**: Увеличение разрешения и улучшение качества изображений.

**Требования**:
- ✅ Проверка баланса (3⭐)

**Интерфейс (Wizard Flow)**:
```
Step 1: Запрос изображения
  └─ Сообщение с инструкцией

Step 2: Загрузка изображения
  └─ Отправка фото через Telegram

Step 3: Обработка
  └─ Использование Clarity Upscaler
     • Увеличение разрешения в 2 раза
     • Улучшение детализации
```

**Параметры для финального результата**:
- `imageUrl`: string (URL изображения)
- `telegram_id`: string
- `username`: string
- `is_ru`: boolean

**Результат**:
- Улучшенное изображение (2x разрешение)
- URL результата
- Сохранение в истории
- Списание баланса (3⭐)

**Бизнес-логика**:
- Использует модель Clarity Upscaler
- Фиксированная стоимость: 3⭐
- Автоматическая обработка после загрузки

---

## 🌀 Продвинутые Инструменты

### 14. 🌀 Infinity Морфинг (`morphing`)

**Описание**: Создание плавных видео переходов между несколькими изображениями.

**Требования**:
- ✅ Требует подписку
- ✅ Проверка баланса

**Интерфейс (Wizard Flow)**:
```
Step 1: Приветствие и инструкции
  └─ Описание процесса

Step 2: Загрузка изображений (минимум 2)
  └─ Цикл загрузки:
     • Отправка фото 1
     • Отправка фото 2
     • ... (до 10 изображений)
     • Кнопка "Создать морфинг"

Step 3: Выбор типа морфинга
  ├─ 🔄 LOOP: Зацикленное видео (начало → конец → начало)
  └─ ➡️ LINEAR: Линейное видео (начало → конец)

Step 4: Ввод промпта для переходов (опционально)
  └─ Текстовое поле
     • Описание желаемого перехода

Step 5: Генерация видео
  └─ Обработка через Kling v2.1 Pro
     • Создание переходов между всеми кадрами
     • Порядок загрузки = порядок склейки
```

**Параметры для финального результата**:
- `images`: string[] (массив URL изображений, минимум 2)
- `morphingType`: `'loop'` | `'linear'`
- `customPrompt`: string (опционально, описание переходов)
- `telegram_id`: string

**Результат**:
- Видео с плавными переходами (MP4)
- URL видео
- Сохранение в истории
- Списание баланса

**Бизнес-логика**:
- Использует Kling v2.1 Pro (1080p HD)
- Автоматическое создание переходов между всеми кадрами
- Поддержка зацикленного и линейного режимов
- Асинхронная обработка через Inngest

---

### 15. 🎭 Замена лица (`face_swap`)

**Описание**: Замена лица на изображении с помощью AI.

**Требования**:
- ✅ Проверка баланса (10⭐)

**Интерфейс (Wizard Flow)**:
```
Step 1: Запрос целевого изображения
  └─ Инструкция с требованиями:
     • Лицо четко видно
     • Анфас (прямо в камеру)
     • Хорошее освещение

Step 2: Загрузка целевого изображения
  └─ Отправка фото человека, на которого заменяем лицо

Step 3: Запрос изображения для замены
  └─ Инструкция (аналогично шагу 1)

Step 4: Загрузка изображения для замены
  └─ Отправка фото лица, которое будет вставлено

Step 5: Обработка
  └─ Использование модели codeplugtech/face-swap (Replicate)
```

**Параметры для финального результата**:
- `targetImageUrl`: string (URL целевого изображения)
- `swapImageUrl`: string (URL изображения с лицом для замены)
- `telegram_id`: string
- `username`: string

**Результат**:
- Изображение с замененным лицом
- URL результата
- Сохранение в истории
- Списание баланса (10⭐)

**Бизнес-логика**:
- Использует Replicate API (модель `codeplugtech/face-swap`)
- Фиксированная стоимость: 10⭐
- Автоматическая обработка после загрузки обоих изображений

---

### 16. 🦸‍♂️ ИИ Герои (`ai_heroes`)

**Описание**: Генерация изображений с героями/персонажами Marvel и других вселенных.

**Требования**:
- ✅ Требует подписку
- ✅ Проверка баланса

**Интерфейс**:
- Выбор героя из списка
- Загрузка фото пользователя
- Генерация трансформации

**Параметры**:
- `hero`: string (название героя)
- `userImageUrl`: string (URL фото пользователя)
- `gender`: `'male'` | `'female'`

**Результат**:
- Изображение пользователя в образе выбранного героя
- URL результата
- Сохранение в истории

---

## 🔒 Админские Функции

### 17. 🎤 Синхронизация губ (`lip_sync`)

**Описание**: Синхронизация движения губ с аудио для создания реалистичных видео.

**Требования**:
- 🔒 Только для администраторов
- ✅ Проверка баланса

**Интерфейс**:
- Загрузка видео/изображения
- Загрузка аудио
- Выбор параметров синхронизации
- Генерация результата

**Параметры**:
- `videoUrl`: string (URL видео или изображения)
- `audioUrl`: string (URL аудио файла)
- `settings`: object (параметры синхронизации)

**Результат**:
- Видео с синхронизированными губами
- URL результата

**Бизнес-логика**:
- Использует Kling Lip Sync API
- Доступно только администраторам (временно, для тестирования)

---

### 18. 🔍 Мониторинг конкурентов (`competitor_monitoring`)

**Описание**: Мониторинг Instagram-аккаунтов конкурентов с автоматическим парсингом контента.

**Требования**:
- 🔒 Только для администраторов
- ✅ Требует подписку
- ✅ Проверка баланса

**Интерфейс (Wizard Flow)**:
```
Step 1: Просмотр существующих подписок
  └─ Список отслеживаемых конкурентов

Step 2: Добавление нового конкурента
  └─ Ввод username Instagram (без @)

Step 3: Настройка параметров
  ├─ maxReels: 15 (максимум рилсов за день)
  ├─ minViews: 5000 (минимум просмотров)
  ├─ maxAgeDays: 1 (только за последний день)
  └─ deliveryFormat: 'individual' (каждый рилс отдельно)

Step 4: Активация подписки
  └─ Запуск парсинга через Inngest
     • Instagram Scraper API
     • Анализ контента
     • Уведомления о новых рилсах
```

**Параметры для создания подписки**:
- `competitorUsername`: string (username без @)
- `maxReels`: number (15 по умолчанию)
- `minViews`: number (5000 по умолчанию)
- `maxAgeDays`: number (1 по умолчанию)
- `deliveryFormat`: `'individual'` | `'summary'`
- `telegram_id`: string

**Результат**:
- Подписка на мониторинг конкурента
- Автоматические уведомления о новых рилсах
- Анализ метрик (просмотры, лайки, комментарии)
- Сохранение данных в БД

**Бизнес-логика**:
- Использует Instagram Scraper API (RapidAPI)
- Парсинг запускается через Inngest событие `instagram/scraper`
- Анализ контента через `instagram/analyze-reels`
- Уведомления отправляются в Telegram при обнаружении нового контента

---

### 19. 🎬 ИИ Рилс (`ai_reels`)

**Описание**: Автоматическое создание Reels с помощью AI (генерация сценария, озвучка, видео).

**Требования**:
- ✅ Требует подписку (NEUROTESTER или NEUROVIDEO)
- ✅ Проверка баланса
- ⚠️ Доступна не только админам (изменено)

**Интерфейс (Wizard Flow)**:
```
Step 1: Выбор типа контента
  ├─ Riddle (загадки)
  ├─ News (новости)
  └─ Custom (кастомный)

Step 2: Настройка параметров
  ├─ Выбор фото аватара
  ├─ Ввод текста или загрузка голоса
  ├─ Выбор сервиса генерации (Hedra/HeyGen)
  └─ Настройка интро и обложки

Step 3: Генерация видео
  └─ Многоэтапная обработка:
     • ElevenLabs: Генерация голоса
     • Hedra/HeyGen: Создание lip-sync видео
     • Kie.ai: Добавление интро и обложки
     • Финальная склейка
```

**Параметры для финального результата**:
- `contentType`: `'riddle'` | `'news'` | `'custom'`
- `avatarPhotoUrl`: string (URL фото аватара)
- `text`: string (текст для озвучки)
- `voiceId`: string (ID голоса ElevenLabs)
- `avatarGenService`: `'hedra'` | `'heygen'`
- `coverUrl`: string (URL обложки, опционально)
- `introText1`: string (текст интро 1)
- `introText2`: string (текст интро 2)
- `upperIntroText`: string (верхний текст интро)

**Результат**:
- Готовый Reels видео (MP4)
- URL видео
- Сохранение в истории
- Списание баланса

**Бизнес-логика**:
- Многоэтапная обработка через render-server
- Использует Inngest функцию `render/render-riddle` или `render/render-avatar`
- Асинхронная обработка (может занять 10-30 минут)
- Callback через webhook при завершении

---

## 🧭 Навигация и Поддержка

### 20. 👥 Пригласить друга (`Invite`)

**Описание**: Реферальная система приглашения друзей.

**Требования**:
- ✅ Бесплатно

**Интерфейс**:
- Показ реферальной ссылки
- Статистика приглашенных друзей
- Награды за приглашения

**Параметры**:
- `referralCode`: string (уникальный код пользователя)

**Результат**:
- Реферальная ссылка
- Бонусы за приглашения (если настроено)

---

### 21. 💬 Техподдержка (`Help`)

**Описание**: Переход в сцену помощи и техподдержки.

**Требования**:
- ✅ Бесплатно

**Интерфейс**:
- Список часто задаваемых вопросов
- Инструкции по использованию функций
- Контакты поддержки

**Результат**:
- Информация и помощь пользователю

---

### 22. 🌐 EN/RU (`language`)

**Описание**: Переключение языка интерфейса.

**Требования**:
- ✅ Бесплатно

**Интерфейс**:
- Кнопка переключения языка
- Автоматическое обновление всех текстов

**Параметры**:
- `language`: `'ru'` | `'en'`

**Результат**:
- Изменение языка интерфейса
- Сохранение в сессии пользователя

---

## 💰 Оплата

### 23. 💫 Оформить подписку (`SubscriptionScene`)

**Описание**: Оформление подписки на сервис.

**Требования**:
- ✅ Бесплатно (само оформление)

**Интерфейс (Wizard Flow)**:
```
Step 1: Выбор типа подписки
  ├─ NEUROTESTER: Базовая подписка
  ├─ NEUROVIDEO: Расширенная подписка
  └─ Другие типы (если доступны)

Step 2: Выбор способа оплаты
  ├─ Telegram Stars
  ├─ Рубли (Robokassa)
  └─ Другие методы

Step 3: Подтверждение и оплата
  └─ Переход на страницу оплаты
```

**Параметры**:
- `subscriptionType`: `'NEUROTESTER'` | `'NEUROVIDEO'` | и др.
- `paymentMethod`: `'stars'` | `'rubles'` | и др.

**Результат**:
- Активированная подписка
- Доступ к премиум функциям
- Сохранение в БД

---

### 24. 💎 Пополнить баланс (`TopUpBalance`)

**Описание**: Пополнение баланса для оплаты услуг.

**Требования**:
- ✅ Требует подписку (только для подписчиков)

**Интерфейс**:
- Выбор суммы пополнения
- Выбор способа оплаты
- Переход на страницу оплаты

**Параметры**:
- `amount`: number (сумма пополнения)
- `paymentMethod`: `'stars'` | `'rubles'`

**Результат**:
- Пополненный баланс
- Обновление в БД

---

### 25. 💰 Баланс (`Balance`)

**Описание**: Просмотр текущего баланса.

**Требования**:
- ✅ Бесплатно

**Интерфейс**:
- Отображение текущего баланса
- История операций (опционально)

**Результат**:
- Информация о балансе пользователя

---

## 📊 Общие паттерны и архитектура

### 🤖 OpenRouter API: Единый провайдер AI моделей

**Критически важно**: Все AI операции используют OpenRouter API, а не прямые API провайдеров!

#### Конфигурация OpenRouter API

**API Endpoint**: `https://openrouter.ai/api/v1`

**Аутентификация**:
- API ключ хранится в Infisical: `OPENROUTER_API_KEY`
- Загружается при старте приложения через Infisical

**Заголовки запросов**:
```typescript
{
  'Authorization': `Bearer ${OPENROUTER_API_KEY}`,
  'Content-Type': 'application/json',
  'HTTP-Referer': 'https://three-head-dragon.shop', // Ваш домен
  'X-Title': 'Multi-Bot AI Platform' // Название приложения
}
```

#### Использование OpenRouter в коде

**Инициализация клиента** (из `src/core/openai/index.ts`):
```typescript
import OpenAI from 'openai'

// Lazy initialization для OpenRouter (клиент создается только при первом обращении)
let _openai: OpenAI | null = null

function getOpenAIClient(): OpenAI {
  if (!_openai) {
    // API ключ загружается из Infisical
    if (!process.env.OPENROUTER_API_KEY) {
      throw new Error('OPENROUTER_API_KEY is not set. Ensure Infisical loaded secrets.')
    }
    
    _openai = new OpenAI({
      apiKey: process.env.OPENROUTER_API_KEY,
      baseURL: 'https://openrouter.ai/api/v1', // OpenRouter endpoint
      timeout: 60 * 1000, // 60 seconds
      defaultHeaders: {
        'HTTP-Referer': process.env.WEBHOOK_URL || 'https://three-head-dragon.shop',
        'X-Title': 'Multi-Bot AI Platform'
      }
    })
  }
  return _openai
}

// Proxy для lazy initialization
export const openai = new Proxy({} as OpenAI, {
  get(target, prop) {
    return (getOpenAIClient() as any)[prop]
  }
})
```

**Важно**: Клиент создается только при первом использовании, что позволяет Infisical загрузить секреты ПЕРЕД созданием клиента.

**Пример использования** (из `core/openai/requests.ts`):
```typescript
import { openai } from '@/core/openai'

// Использование единого клиента OpenRouter
const response = await openai.chat.completions.create({
  model: 'minimax/minimax-m2', // Модель через OpenRouter (топовая для кодирования)
  messages: [
    { role: 'system', content: 'Ты помощник...' },
    { role: 'user', content: prompt }
  ],
  temperature: 0.7,
  max_tokens: 2000
})

const content = response.choices[0].message.content
```

**Пример из функции `answerAi()`**:
```typescript
import { openai } from '@/core/openai'

export const answerAi = async (
  model: string,
  userData: UserData,
  prompt: string,
  languageCode: string
): Promise<string> => {
  const response = await openai.chat.completions.create({
    model: 'minimax/minimax-m2', // Используется модель по умолчанию
    messages: [
      {
        role: 'system',
        content: `Respond in the language: ${languageCode} You communicate with: ${JSON.stringify(userData)}`
      },
      {
        role: 'user',
        content: prompt
      }
    ]
  })
  
  return response.choices[0].message.content || ''
}
```

#### Доступные модели через OpenRouter

**Формат модели**: `'provider/model-name'`

**Популярные модели**:
- **Minimax M2**: `'minimax/minimax-m2'` (топовая модель для кодирования и агентов, MoE архитектура, 230B параметров)
- **OpenAI**: `'openai/gpt-4'`, `'openai/gpt-3.5-turbo'`, `'openai/gpt-4-turbo'`
- **Anthropic Claude**: `'anthropic/claude-3.5-sonnet'`, `'anthropic/claude-3-opus'`, `'anthropic/claude-3-haiku'`
- **Google**: `'google/gemini-pro'`, `'google/gemini-flash'`
- **Meta**: `'meta-llama/llama-3-70b-instruct'`
- **И другие**: Полный каталог на https://openrouter.ai/models

#### Преимущества OpenRouter API

1. **Единый интерфейс**: Один API для всех моделей
2. **Гибкость**: Легкое переключение между моделями
3. **Ценообразование**: Прозрачные цены от OpenRouter
4. **Fallback**: Автоматический fallback при недоступности модели
5. **Мониторинг**: Единая точка мониторинга использования

#### Где используется OpenRouter API

**Все функции в `src/core/openai/` используют OpenRouter API через единый клиент:**

- **Чат с аватаром**: `answerAi()` функция (`core/openai/requests.ts`)
- **Улучшение промптов**: `upgradePrompt()` функция (`core/openai/upgradePrompt.ts`)
  - Модель: `'meta-llama/llama-3.2-3b-instruct:free'` (бесплатная модель)
- **Генерация субтитров**: `getSubtitles()` функция (`core/openai/getSubtitles.ts`)
- **Генерация триггеров для Reels**: `getTriggerReel()` функция (`core/openai/getTriggerReel.ts`)
- **Генерация AI новостей**: `getAinews()` функция (`core/openai/getAinews.ts`)
- **Генерация подписей для новостей**: `getCaptionForNews()` функция (`core/openai/getCaptionForNews.ts`)
- **Генерация шагов медитации**: `getMeditationSteps()` функция (`core/openai/getMeditationSteps.ts`)
- **Генерация слайдов**: `getSlides()` функция (`core/openai/getSlides.ts`)
- **Анализ логов**: Мониторинг и анализ ошибок (`inngest_app/functions/monitoring/logMonitor.ts`)
  - Модель: `'anthropic/claude-3.5-sonnet'`
- **Анализ критических ошибок**: (`inngest_app/functions/monitoring/criticalErrorMonitor.ts`)
  - Модель: `'anthropic/claude-3.5-sonnet'`

**Единый клиент**: Все функции используют единый клиент из `core/openai/index.ts`, который подключается к OpenRouter API.

---

### 🎯 Структура кнопок и их обработка

#### ⚠️ КРИТИЧЕСКИ ВАЖНО: Формат кнопок главного меню

**Главное меню использует REPLY KEYBOARD (обычные кнопки), НЕ INLINE кнопки!**

```typescript
// ✅ ПРАВИЛЬНО: Reply Keyboard (кнопки под полем ввода)
const keyboard = Markup.keyboard([
  ['🤖 Цифровое тело', '📸 Нейрофото'],
  ['🔍 Промпт из фото', '🧠 Мозг аватара'],
  ['💭 Чат с аватаром', '🤖 Выбор модели ИИ'],
  // ... остальные кнопки по 2 в ряд
]).resize() // Автоматическое изменение размера под экран

// ❌ НЕПРАВИЛЬНО: Inline Keyboard для главного меню
const inlineKeyboard = Markup.inlineKeyboard([
  [{ text: '🤖 Цифровое тело', callback_data: 'digital_body' }]
])
```

#### Структура кнопок главного меню

**Формат**: Reply Keyboard (ReplyKeyboardMarkup)
- **Расположение**: Под полем ввода текста
- **Обработка**: Через `bot.hears()` или `text` handlers, НЕ через `callback_query`
- **Структура**: По 2 кнопки в ряд (автоматически через `.resize()`)
- **Текст кнопок**: Точное совпадение с текстом из `NAVIGATION_BUTTONS`

**Пример структуры**:
```typescript
interface NavigationButton {
  ru: string           // Текст кнопки на русском
  en: string           // Текст кнопки на английском
  mode: string         // Режим/сцена для перехода
  category?: string    // Категория (ai, tools, admin, navigation, payment)
  admin_only?: boolean // Только для админов
  requires_subscription?: boolean // Требует подписку
  icon?: string        // Эмодзи иконка
}
```

**Создание клавиатуры**:
```typescript
// Функция создания главного меню
export const createMainMenuKeyboard = (ctx: MyContext) => {
  const isRu = isRussianFromState(ctx)
  const userId = ctx.from?.id

  // Фильтруем кнопки по правам доступа
  const visibleButtons = NAVIGATION_BUTTONS.filter(btn => {
    if (btn.admin_only && (!userId || !ADMIN_IDS_ARRAY.includes(userId))) {
      return false
    }
    return true
  })

  // Получаем тексты кнопок в зависимости от языка
  const buttonTexts = visibleButtons.map(btn => (isRu ? btn.ru : btn.en))

  // Создаем клавиатуру (по 2 кнопки в ряд)
  const keyboard = []
  for (let i = 0; i < buttonTexts.length; i += 2) {
    const row = [buttonTexts[i]]
    if (buttonTexts[i + 1]) {
      row.push(buttonTexts[i + 1])
    }
    keyboard.push(row)
  }

  return Markup.keyboard(keyboard).resize()
}
```

#### Обработка нажатий кнопок

**Важно**: Кнопки обрабатываются через `hears` handlers или `text` handlers, НЕ через `callback_query`!

```typescript
// ✅ ПРАВИЛЬНО: Обработка через hears/text
bot.hears(['🤖 Цифровое тело', '🤖 Digital Body'], async (ctx) => {
  // Обработка нажатия кнопки
  ctx.session.mode = ModeEnum.DigitalAvatarBody
  await ctx.scene.enter(ModeEnum.CheckBalanceScene)
})

// Или через универсальный обработчик:
bot.on('text', async (ctx) => {
  const text = ctx.message.text
  const button = NAVIGATION_BUTTONS.find(
    btn => btn.ru === text || btn.en === text
  )
  
  if (button) {
    ctx.session.mode = button.mode
    await ctx.scene.enter(ModeEnum.CheckBalanceScene)
  }
})

// ❌ НЕПРАВИЛЬНО: Обработка через callback_query для главного меню
bot.on('callback_query', async (ctx) => {
  // Это НЕ используется для главного меню!
})
```

#### Inline кнопки (используются только в специфических случаях)

**⚠️ ВАЖНО**: Inline кнопки используются ТОЛЬКО внутри wizard'ов и под сообщениями, НЕ для главного меню!

**Когда использовать Inline кнопки**:
- Выбор из списка моделей (внутри wizard'ов)
- Подтверждение действий
- Навигация внутри сцены (Назад, Отмена)
- Дополнительные опции под сообщением
- **Внизу сообщений** (например, кнопка подписки под приветственным сообщением)

**Пример: Inline кнопка под сообщением**:
```typescript
// Приветственное сообщение с inline кнопкой подписки внизу
const inlineKeyboard = Markup.inlineKeyboard([
  [
    {
      text: isRu ? '💫 Оформить подписку' : '💫 Subscribe',
      callback_data: 'go_to_subscription_scene',
    },
  ],
])

await ctx.reply(
  isRu ? 'Добро пожаловать!' : 'Welcome!',
  {
    parse_mode: 'HTML',
    reply_markup: inlineKeyboard, // Inline кнопка ВНИЗУ сообщения
  }
)

// Отдельно отправляем Reply Keyboard с главным меню
await ctx.reply(
  isRu ? '👇 Выберите действие:' : '👇 Choose an action:',
  {
    reply_markup: mainMenuKeyboard.reply_markup, // Reply Keyboard под полем ввода
  }
)
```

**Структура**: 
- **Reply Keyboard** (главное меню) - под полем ввода текста
- **Inline Keyboard** (дополнительные опции) - под сообщением, обрабатываются через `callback_query`

**Пример использования Inline кнопок**:
```typescript
// Внутри wizard'а для выбора модели
const inlineKeyboard = Markup.inlineKeyboard([
  [
    { text: '🎨 Portrait Trainer (550⭐)', callback_data: 'select_model:portrait' },
  ],
  [
    { text: '⚡ Fast Training (220⭐)', callback_data: 'select_model:fast' },
  ],
  [
    { text: 'Отмена', callback_data: 'cancel_training' },
  ],
])

await ctx.reply('Выберите модель:', { reply_markup: inlineKeyboard })
```

**Обработка Inline кнопок**:
```typescript
// Обработка callback_query для inline кнопок
wizard.on('callback_query', async (ctx) => {
  await ctx.answerCbQuery() // ОБЯЗАТЕЛЬНО первая строка!
  
  const data = ctx.callbackQuery.data
  if (data === 'select_model:portrait') {
    // Обработка выбора модели
  }
})
```

#### Структура обработки кнопок меню

```
Пользователь нажимает кнопку "🤖 Цифровое тело"
         ↓
bot.hears(['🤖 Цифровое тело', '🤖 Digital Body'])
         ↓
Находим кнопку в NAVIGATION_BUTTONS по тексту
         ↓
Проверка прав доступа (admin_only?)
         ↓
Проверка подписки (requires_subscription?)
         ↓
Установка режима: ctx.session.mode = ModeEnum.DigitalAvatarBody
         ↓
Переход в сцену: ctx.scene.enter(ModeEnum.CheckBalanceScene)
```

#### Порядок кнопок в меню

**Структура меню (сверху вниз)**:
1. **ИИ Функции** (8 кнопок)
2. **Видео и Фото** (5 кнопок)
3. **Продвинутые Инструменты** (3 кнопки)
4. **Админские Функции** (3 кнопки, только для админов)
5. **Навигация и Поддержка** (3 кнопки)
6. **Оплата** (3 кнопки, внизу)

**Расположение**: По 2 кнопки в ряд, автоматическое изменение размера под экран

#### Технические детали реализации

**1. Определение языка кнопок**:
```typescript
// Функция определения языка
const isRu = isRussianFromState(ctx)
const buttonText = isRu ? button.ru : button.en
```

**2. Фильтрация кнопок по правам**:
```typescript
const visibleButtons = NAVIGATION_BUTTONS.filter(btn => {
  // Проверка админских прав
  if (btn.admin_only && !isAdmin(userId)) {
    return false
  }
  return true
})
```

**3. Создание клавиатуры**:
```typescript
// По 2 кнопки в ряд
const keyboard = []
for (let i = 0; i < buttonTexts.length; i += 2) {
  const row = [buttonTexts[i]]
  if (buttonTexts[i + 1]) {
    row.push(buttonTexts[i + 1])
  }
  keyboard.push(row)
}

return Markup.keyboard(keyboard).resize()
```

**4. Обработка нажатий**:
```typescript
// Универсальный обработчик для всех кнопок меню
bot.on('text', async (ctx) => {
  const text = ctx.message.text
  
  // Пропускаем команды
  if (text.startsWith('/')) {
    return
  }
  
  // Ищем кнопку по тексту
  const button = NAVIGATION_BUTTONS.find(
    btn => btn.ru === text || btn.en === text
  )
  
  if (button) {
    // Проверка прав и подписки
    // Установка режима
    // Переход в сцену
  }
})
```

### Проверка баланса

Все платные функции проходят через `CheckBalanceScene` перед выполнением:
1. Проверка наличия подписки (если требуется)
2. Проверка достаточности баланса
3. Списание средств перед началом операции
4. Возврат средств при ошибке (опционально)

### Асинхронная обработка

Долгие операции (обучение моделей, генерация видео) обрабатываются через Inngest:
1. Создание задачи в Inngest
2. Получение `jobId` или `taskId`
3. Уведомление пользователя о начале обработки
4. Callback через webhook при завершении
5. Отправка результата пользователю

### Многоязычность

Все интерфейсы поддерживают русский и английский языки:
- Определение языка через `isRussianFromState(ctx)`
- Хранение языка в сессии пользователя
- Автоматическое переключение текстов

### Обработка ошибок

Стандартная обработка ошибок:
1. Логирование через `logger`
2. Уведомление пользователя на его языке
3. Возврат в главное меню при критических ошибках
4. Сохранение контекста ошибки для анализа

---

## 🔍 Критический анализ и недостающие детали для реализации

### ⚠️ Критические моменты для реализации

#### 1. Структура данных для кнопок

**Полная структура NavigationButton**:
```typescript
interface NavigationButton {
  // Обязательные поля
  ru: string                    // Текст на русском (точное совпадение!)
  en: string                    // Текст на английском (точное совпадение!)
  mode: string | ModeEnum       // Режим/сцена для перехода
  
  // Опциональные поля
  category?: 'ai' | 'tools' | 'admin' | 'navigation' | 'payment' | 'video'
  admin_only?: boolean          // Только для администраторов
  requires_subscription?: boolean // Требует подписку
  icon?: string                 // Эмодзи иконка (для отображения)
  
  // Внутренние поля (не используются в кнопках)
  // Эти поля используются для логики, но НЕ отображаются в тексте кнопки
}
```

**Важно**: Текст кнопки (`ru`/`en`) должен точно совпадать с тем, что отправляет пользователь при нажатии!

#### 2. Обработка кнопок: порядок приоритетов

**Критически важно**: Порядок обработчиков имеет значение!

```typescript
// ✅ ПРАВИЛЬНЫЙ ПОРЯДОК:

// 1. Сначала команды (высший приоритет)
bot.command('start', ...)
bot.command('menu', ...)

// 2. Затем глобальные hears для специальных кнопок
bot.hears(['🏠 Главное меню', '🏠 Main menu'], ...)

// 3. Затем обработчики сцен (wizard handlers)
wizard.on('text', ...)

// 4. В конце универсальный обработчик для кнопок меню
bot.on('text', async (ctx) => {
  // Проверка, что это не команда
  if (ctx.message.text.startsWith('/')) {
    return
  }
  
  // Проверка, что пользователь не в другой сцене
  if (ctx.scene.current?.id !== ModeEnum.MainMenu) {
    return
  }
  
  // Обработка кнопки меню
})
```

#### 3. Проверка подписки и прав доступа

**Полный алгоритм проверки**:
```typescript
async function handleMenuButton(ctx: MyContext, button: NavigationButton) {
  const userId = ctx.from?.id
  
  // Шаг 1: Проверка админских прав
  if (button.admin_only) {
    if (!userId || !ADMIN_IDS_ARRAY.includes(userId)) {
      await ctx.reply('🔒 Эта функция доступна только администраторам')
      return false
    }
  }
  
  // Шаг 2: Проверка подписки
  if (button.requires_subscription) {
    const hasSubscription = await checkSubscriptionGuard(ctx, button.mode)
    if (!hasSubscription) {
      // Пользователь уже перенаправлен в subscriptionScene
      return false
    }
  }
  
  // Шаг 3: Установка режима
  ctx.session.mode = button.mode as ModeEnum
  
  // Шаг 4: Переход в сцену проверки баланса
  await ctx.scene.enter(ModeEnum.CheckBalanceScene)
  
  return true
}
```

#### 4. Структура сессии пользователя

**Критически важные поля сессии**:
```typescript
interface MySession {
  // Режим работы (определяет, какая функция активна)
  mode?: ModeEnum
  
  // Язык интерфейса
  language_code?: 'ru' | 'en'
  userLanguage?: 'ru' | 'en'
  
  // Данные для текущей операции
  prompt?: string              // Текстовый промпт
  userModel?: UserModel        // Выбранная модель
  imageUrl?: string            // URL изображения
  selectedVideoModel?: string  // Выбранная модель видео
  
  // Данные wizard'ов
  wizardData?: {
    step?: number
    [key: string]: any
  }
  
  // И другие поля в зависимости от функции
}
```

#### 5. Многоязычность: критически важно

**Проблема**: Если язык определяется неправильно, кнопки не будут работать!

```typescript
// ✅ ПРАВИЛЬНО: Централизованное определение языка
function isRussianFromState(ctx: MyContext): boolean {
  // Приоритет 1: Явный выбор пользователя
  if (ctx.session?.userLanguage) {
    return ctx.session.userLanguage === 'ru'
  }
  
  // Приоритет 2: Язык из сессии
  if (ctx.session?.language_code) {
    return ctx.session.language_code === 'ru'
  }
  
  // Приоритет 3: Язык Telegram
  if (ctx.from?.language_code) {
    return ctx.from.language_code.startsWith('ru')
  }
  
  // По умолчанию: русский
  return true
}

// ❌ НЕПРАВИЛЬНО: Использование только языка Telegram
function isRussian(ctx: MyContext): boolean {
  return ctx.from?.language_code?.startsWith('ru') ?? true
}
```

**Важно**: Текст кнопки должен точно совпадать с тем, что отправляет пользователь!

```typescript
// ✅ ПРАВИЛЬНО: Используем правильный язык
const buttonText = isRu ? button.ru : button.en
await ctx.reply('Выберите действие:', {
  reply_markup: Markup.keyboard([[buttonText]]).resize()
})

// Обработка
bot.hears([button.ru, button.en], async (ctx) => {
  // Обработает оба варианта
})
```

#### 6. Структура сцен (Wizard Scenes)

**Критически важно**: Каждая функция имеет свою сцену!

```typescript
// Структура wizard'а
const myWizard = new Scenes.WizardScene<MyContext>(
  'my_wizard_id',  // Уникальный ID сцены
  
  // Step 1: Инициализация
  async (ctx) => {
    // Установка режима
    ctx.session.mode = ModeEnum.MyMode
    
    // Инициализация данных
    ctx.session.wizardData = {
      step: 1,
      // ...
    }
    
    // Отправка сообщения с кнопками
    await ctx.reply('Шаг 1:', keyboard)
    
    // Переход к следующему шагу
    return ctx.wizard.next()
  },
  
  // Step 2: Обработка ввода
  async (ctx) => {
    // Проверка типа сообщения
    if (!ctx.message || !('text' in ctx.message)) {
      await ctx.reply('Отправьте текстовое сообщение')
      return
    }
    
    // Обработка ввода
    const text = ctx.message.text
    
    // Переход к следующему шагу или завершение
    return ctx.wizard.next()
  }
)

// Обработка callback_query для inline кнопок внутри wizard'а
myWizard.on('callback_query', async (ctx) => {
  await ctx.answerCbQuery() // ОБЯЗАТЕЛЬНО первая строка!
  
  const data = ctx.callbackQuery.data
  // Обработка inline кнопок
})
```

#### 7. Обработка ошибок и edge cases

**Критически важные проверки**:
```typescript
async function handleButtonPress(ctx: MyContext, buttonText: string) {
  try {
    // Проверка 1: Пользователь существует
    if (!ctx.from?.id) {
      logger.error('User ID not found')
      return false
    }
    
    // Проверка 2: Кнопка найдена
    const button = NAVIGATION_BUTTONS.find(
      btn => btn.ru === buttonText || btn.en === buttonText
    )
    if (!button) {
      logger.warn(`Button not found: ${buttonText}`)
      return false
    }
    
    // Проверка 3: Пользователь не в другой сцене (если нужно)
    const currentScene = ctx.scene.current?.id
    if (currentScene && currentScene !== ModeEnum.MainMenu) {
      // Можно обработать или проигнорировать
      logger.debug(`User in scene: ${currentScene}`)
    }
    
    // Проверка 4: Права доступа
    if (button.admin_only && !isAdmin(ctx.from.id)) {
      await ctx.reply('🔒 Доступ запрещен')
      return false
    }
    
    // Проверка 5: Подписка
    if (button.requires_subscription) {
      const hasSubscription = await checkSubscriptionGuard(ctx, button.mode)
      if (!hasSubscription) {
        return false // Уже обработано в checkSubscriptionGuard
      }
    }
    
    // Выполнение действия
    ctx.session.mode = button.mode
    await ctx.scene.enter(ModeEnum.CheckBalanceScene)
    
    return true
  } catch (error) {
    logger.error('Error handling button press', { error, buttonText })
    await ctx.reply('❌ Произошла ошибка. Попробуйте позже.')
    return false
  }
}
```

#### 8. Структура базы данных

**Критически важные таблицы**:
```sql
-- Пользователи
CREATE TABLE users (
  telegram_id BIGINT PRIMARY KEY,
  username VARCHAR(255),
  language_code VARCHAR(10) DEFAULT 'ru',
  subscription_type VARCHAR(50),
  balance DECIMAL(10, 2) DEFAULT 0,
  created_at TIMESTAMP DEFAULT NOW()
);

-- Модели пользователей
CREATE TABLE user_models (
  id SERIAL PRIMARY KEY,
  telegram_id BIGINT REFERENCES users(telegram_id),
  model_name VARCHAR(255),
  model_url TEXT,
  trigger_word VARCHAR(100),
  status VARCHAR(50),
  created_at TIMESTAMP DEFAULT NOW()
);

-- История операций
CREATE TABLE operations (
  id SERIAL PRIMARY KEY,
  telegram_id BIGINT REFERENCES users(telegram_id),
  service_type VARCHAR(100),
  cost DECIMAL(10, 2),
  status VARCHAR(50),
  created_at TIMESTAMP DEFAULT NOW()
);
```

#### 9. Пример полной реализации главного меню

```typescript
// 1. Конфигурация кнопок
export const NAVIGATION_BUTTONS: NavigationButton[] = [
  {
    ru: '🤖 Цифровое тело',
    en: '🤖 Digital Body',
    mode: ModeEnum.DigitalAvatarBody,
    category: 'ai',
    requires_subscription: true,
  },
  // ... остальные кнопки
]

// 2. Создание клавиатуры
export function createMainMenuKeyboard(ctx: MyContext) {
  const isRu = isRussianFromState(ctx)
  const userId = ctx.from?.id
  
  // Фильтрация по правам
  const visibleButtons = NAVIGATION_BUTTONS.filter(btn => {
    if (btn.admin_only && (!userId || !isAdmin(userId))) {
      return false
    }
    return true
  })
  
  // Получение текстов кнопок
  const buttonTexts = visibleButtons.map(btn => (isRu ? btn.ru : btn.en))
  
  // Создание клавиатуры (по 2 в ряд)
  const keyboard = []
  for (let i = 0; i < buttonTexts.length; i += 2) {
    const row = [buttonTexts[i]]
    if (buttonTexts[i + 1]) {
      row.push(buttonTexts[i + 1])
    }
    keyboard.push(row)
  }
  
  return Markup.keyboard(keyboard).resize()
}

// 3. Обработка нажатий
bot.on('text', async (ctx) => {
  const text = ctx.message.text
  
  // Пропускаем команды
  if (text.startsWith('/')) {
    return
  }
  
  // Находим кнопку
  const button = NAVIGATION_BUTTONS.find(
    btn => btn.ru === text || btn.en === text
  )
  
  if (button) {
    await handleMenuButton(ctx, button)
  }
})

// 4. Функция обработки кнопки
async function handleMenuButton(ctx: MyContext, button: NavigationButton) {
  // Проверки прав и подписки
  // Установка режима
  // Переход в сцену
}
```

### 📋 Чек-лист для реализации

- [ ] Создать структуру `NavigationButton` с полями `ru`, `en`, `mode`
- [ ] Реализовать функцию `createMainMenuKeyboard()` с фильтрацией по правам
- [ ] Настроить обработку через `bot.on('text')` или `bot.hears()`
- [ ] Реализовать проверку подписки через `checkSubscriptionGuard()`
- [ ] Реализовать проверку админских прав
- [ ] Настроить определение языка через `isRussianFromState()`
- [ ] Создать сцены (wizard scenes) для каждой функции
- [ ] Настроить переход в `CheckBalanceScene` перед платными операциями
- [ ] Реализовать логирование всех действий
- [ ] Настроить обработку ошибок с уведомлением пользователя
- [ ] **Настроить OpenRouter API**: Добавить `OPENROUTER_API_KEY` в Infisical
- [ ] **Создать единый клиент OpenRouter**: Реализовать lazy initialization в `core/openai/index.ts`
- [ ] **Настроить заголовки**: Добавить `HTTP-Referer` и `X-Title` для OpenRouter запросов

### 🚨 Частые ошибки при реализации

1. **Использование inline кнопок для главного меню** ❌
   - Правильно: Reply Keyboard
   
2. **Обработка через callback_query** ❌
   - Правильно: `bot.hears()` или `bot.on('text')`
   
3. **Неточное совпадение текста кнопки** ❌
   - Текст должен точно совпадать с `ru` или `en`
   
4. **Неправильный порядок обработчиков** ❌
   - Сначала команды, потом hears, потом универсальный обработчик
   
5. **Отсутствие проверки подписки** ❌
   - Всегда проверять `requires_subscription` перед входом в функцию
   
6. **Отсутствие проверки прав** ❌
   - Всегда проверять `admin_only` перед показом/обработкой кнопки
   
7. **Использование прямых API провайдеров вместо OpenRouter** ❌
   - Правильно: Использовать OpenRouter API для всех AI операций
   - Неправильно: Прямые вызовы OpenAI/Anthropic API
   
8. **Отсутствие заголовков HTTP-Referer и X-Title** ❌
   - OpenRouter требует эти заголовки для корректной работы
   
9. **Неправильный формат модели** ❌
   - Правильно: `'minimax/minimax-m2'` (формат OpenRouter)
   - Неправильно: `'minimax-m2'` (без провайдера)

---

## 🧠 Мозг аватара: Единый источник правды

### 🎯 Концепция "Мозг аватара"

**Мозг аватара** - это централизованная система хранения и управления всеми данными бота, основанная на лучших практиках плагинной архитектуры (ElizaOS) и функционального программирования. Она обеспечивает:

1. **Единообразие**: Все модули используют одни и те же интерфейсы
2. **Единый источник правды**: Все ID'шники, конфигурации и данные хранятся в одном месте
3. **Типобезопасность**: TypeScript интерфейсы гарантируют корректность данных
4. **Масштабируемость**: Легко добавлять новые функции без изменения существующего кода
5. **Плагинная архитектура**: Каждая функция реализуется как плагин с единым интерфейсом
6. **Трансформер**: Автоматическое преобразование данных между форматами для быстрого внедрения функций
7. **Функциональное программирование**: 100% функциональный стиль с использованием TaskEither, pipe, Either паттернов
8. **Неизменяемость данных**: Все данные иммутабельны, что обеспечивает предсказуемость и упрощает тестирование
9. **Чистые функции**: Все функции без побочных эффектов, легко тестируемые и композируемые
10. **Агентный вайб-кодинг**: Разработка через агентов с функциональным подходом

### 🏗️ Архитектурные принципы (на основе ElizaOS + Функциональное программирование)

#### 0. Функциональное программирование - Основа всего

**КРИТИЧЕСКИ ВАЖНО: Весь код пишется в функциональном стиле!**

```typescript
/**
 * Функциональные утилиты (из src/core/functional/utils/)
 */
import { pipe, flow, tap } from '@/core/functional/utils/composition'
import { TaskEither, Either, left, right, chain, map, fold } from '@/core/functional/utils/result'

/**
 * Принципы функционального программирования:
 * 
 * 1. Неизменяемость (Immutability)
 *    - Все данные иммутабельны
 *    - Изменения создают новые объекты, не мутируют существующие
 * 
 * 2. Чистые функции (Pure Functions)
 *    - Нет побочных эффектов
 *    - Одинаковый вход = одинаковый выход
 *    - Легко тестируются
 * 
 * 3. Композиция функций (Function Composition)
 *    - Использование pipe() для композиции
 *    - Сложные функции собираются из простых
 * 
 * 4. Обработка ошибок через Either/TaskEither
 *    - Нет throw/catch
 *    - Ошибки - это значения (Either<Error, Success>)
 *    - TaskEither для асинхронных операций
 * 
 * 5. Типобезопасность через io-ts
 *    - Runtime валидация типов
 *    - Строгая типизация на этапе компиляции и выполнения
 */
```

**Пример функционального стиля:**

```typescript
// ❌ НЕПРАВИЛЬНО: Императивный стиль с мутациями
async function processUserRequest(userId: string, data: any) {
  const user = await getUser(userId)
  user.balance -= 10 // Мутация!
  await saveUser(user)
  const result = await generateContent(data)
  return result
}

// ✅ ПРАВИЛЬНО: Функциональный стиль с TaskEither
const processUserRequest = (
  userId: string,
  data: unknown
): TaskEither<Error, ContentResult> =>
  pipe(
    // 1. Валидация данных
    validateRequest(data),
    // 2. Получение пользователя
    chain(validData => getUserTask(userId)),
    // 3. Проверка баланса
    chain(user => checkBalance(user, 10)),
    // 4. Списание баланса (иммутабельно)
    chain(user => deductBalanceTask(user, 10)),
    // 5. Генерация контента
    chain(user => generateContentTask(validData)),
    // 6. Логирование (side effect через tap)
    tap(result => logResult(result))
  )
```

#### 1. Плагинная архитектура (в функциональном стиле)

**Каждая функция бота - это плагин** с единым интерфейсом:

```typescript
/**
 * Базовый интерфейс плагина функции
 */
export interface BotPlugin {
  // Идентификация
  name: string
  description: string
  version: string
  
  // Метаданные
  mode: ModeEnum // Режим работы
  category: 'ai' | 'tools' | 'admin' | 'navigation' | 'payment' | 'video'
  icon?: string
  
  // Права доступа
  admin_only?: boolean
  requires_subscription?: boolean
  
  // Компоненты плагина
  actions?: PluginAction[] // Действия плагина
  providers?: PluginProvider[] // Провайдеры данных
  services?: PluginService[] // Сервисы плагина
  
  // Навигация
  navigationButton: NavigationButton // Кнопка в меню
  
  // Конфигурация
  config?: PluginConfig
  
  // Lifecycle
  init?: (brain: AvatarBrain) => Promise<void>
  destroy?: () => Promise<void>
}
```

#### 2. Единая модель данных (AvatarBrain)

**Вместо множества отдельных моделей - одна унифицированная модель:**

```typescript
/**
 * 🧠 Мозг аватара - ЕДИНАЯ модель для всех функций
 * 
 * КРИТИЧЕСКИ ВАЖНО: Все данные хранятся в этой единой структуре,
 * а не в отдельных моделях для каждой функции!
 */
export interface AvatarBrain {
  // ========================================
  // ИДЕНТИФИКАЦИЯ
  // ========================================
  id: string // UUID
  telegram_id: TelegramId
  bot_name: BotName
  
  // ========================================
  // НАВИГАЦИЯ И СОСТОЯНИЕ
  // ========================================
  navigation: NavigationState
  
  // ========================================
  // ПОЛЬЗОВАТЕЛЬ
  // ========================================
  user: UserProfile
  session: UserSession
  
  // ========================================
  // AI МОДЕЛИ (ЕДИНАЯ ТАБЛИЦА)
  // ========================================
  models: UserModel[]
  selectedModel?: UserModel
  
  // ========================================
  // ФИНАНСЫ
  // ========================================
  balance: Balance
  subscription?: Subscription
  
  // ========================================
  // КОНТЕНТ (ЕДИНАЯ ТАБЛИЦА ДЛЯ ВСЕХ ТИПОВ)
  // ========================================
  assets: Asset[] // Все медиа файлы (изображения, видео, аудио)
  operations: Operation[] // Все операции (генерации, обучение, обработка)
  
  // ========================================
  // КОНФИГУРАЦИЯ
  // ========================================
  config: BotConfig
  
  // ========================================
  // ПЛАГИНЫ (РЕГИСТР АКТИВНЫХ ПЛАГИНОВ)
  // ========================================
  plugins: Map<string, BotPlugin> // Регистр загруженных плагинов
  
  // ========================================
  // МЕТАДАННЫЕ
  // ========================================
  created_at: Date
  updated_at: Date
  version: string // Версия структуры данных
}
```

#### 3. Трансформер данных

**Автоматическое преобразование данных между форматами:**

```typescript
/**
 * Трансформер для преобразования данных между форматами
 * Обеспечивает быстрое внедрение новых функций без изменения существующего кода
 */
export class AvatarBrainTransformer {
  /**
   * Преобразует данные из формата плагина в формат AvatarBrain
   */
  static fromPlugin(plugin: BotPlugin, data: any): Partial<AvatarBrain> {
    return {
      navigation: {
        currentMode: plugin.mode,
        availableButtons: [plugin.navigationButton],
      },
      config: {
        features: {
          [plugin.name]: true,
        },
      },
    }
  }
  
  /**
   * Преобразует данные из AvatarBrain в формат плагина
   */
  static toPlugin(brain: AvatarBrain, pluginName: string): any {
    const plugin = brain.plugins.get(pluginName)
    if (!plugin) return null
    
    return {
      user: brain.user,
      session: brain.session,
      models: brain.models,
      balance: brain.balance,
      subscription: brain.subscription,
    }
  }
  
  /**
   * Объединяет данные из нескольких источников в AvatarBrain
   */
  static merge(...sources: Partial<AvatarBrain>[]): AvatarBrain {
    return sources.reduce((acc, source) => ({
      ...acc,
      ...source,
      // Глубокое слияние вложенных объектов
      navigation: { ...acc.navigation, ...source.navigation },
      user: { ...acc.user, ...source.user },
      session: { ...acc.session, ...source.session },
      models: [...(acc.models || []), ...(source.models || [])],
      assets: [...(acc.assets || []), ...(source.assets || [])],
      operations: [...(acc.operations || []), ...(source.operations || [])],
    }), {} as AvatarBrain)
  }
  
  /**
   * Валидация данных перед сохранением
   */
  static validate(brain: Partial<AvatarBrain>): ValidationResult {
    const errors: string[] = []
    
    if (!brain.telegram_id) errors.push('telegram_id is required')
    if (!brain.bot_name) errors.push('bot_name is required')
    if (!brain.user) errors.push('user is required')
    if (!brain.balance) errors.push('balance is required')
    
    return {
      valid: errors.length === 0,
      errors,
    }
  }
}
```

### 📦 Структура "Мозг аватара" (Единая модель)

```
🧠 AvatarBrain (Мозг аватара) - ЕДИНАЯ МОДЕЛЬ
├── 📋 Navigation (Навигация)
│   ├── NavigationButton[] - Все кнопки меню
│   ├── ModeEnum - Все режимы работы
│   └── SceneId - Все сцены
├── 👤 User (Пользователь)
│   ├── UserProfile - Профиль пользователя
│   ├── UserSettings - Настройки пользователя
│   └── UserSession - Сессия пользователя
├── 🤖 AI Models (AI Модели) - ЕДИНАЯ ТАБЛИЦА
│   └── UserModel[] - Все модели в одной таблице
├── 💰 Financial (Финансы)
│   ├── Balance - Баланс пользователя
│   ├── Payment[] - Все платежи
│   └── Subscription[] - Все подписки
├── 🎨 Content (Контент) - ЕДИНАЯ ТАБЛИЦА
│   ├── Asset[] - Все медиа файлы (изображения, видео, аудио)
│   └── Operation[] - Все операции (генерации, обучение, обработка)
├── ⚙️ Configuration (Конфигурация)
│   ├── BotConfig - Конфигурация бота
│   └── PluginConfig[] - Конфигурации плагинов
└── 🔌 Plugins (Плагины)
    └── Map<string, BotPlugin> - Регистр активных плагинов
```

### 🔌 Компоненты плагинов (на основе ElizaOS)

#### 1. PluginAction (Действия плагина) - Функциональный стиль

```typescript
/**
 * Действие плагина - выполняемая задача
 * ВСЕГДА возвращает TaskEither для обработки ошибок функционально
 */
import { TaskEither } from '@/core/functional/utils/result'

export interface PluginAction {
  name: string // Уникальный идентификатор
  similes?: string[] // Альтернативные названия
  description: string // Описание действия
  
  // Валидация перед выполнением (чистая функция)
  validate: (
    brain: AvatarBrain,
    context: ActionContext
  ) => Either<ValidationError, boolean>
  
  // Обработчик действия (TaskEither для асинхронных операций)
  handler: (
    brain: AvatarBrain,
    context: ActionContext,
    options?: HandlerOptions,
    callback?: HandlerCallback
  ) => TaskEither<ActionError, ActionResult>
  
  // Примеры для обучения
  examples?: ActionExample[][]
}

/**
 * Пример функционального действия
 */
export const neuroPhotoAction: PluginAction = {
  name: 'GENERATE_NEURO_PHOTO',
  description: 'Генерирует нейрофото',
  
  // Чистая функция валидации
  validate: (brain, context) => {
    if (brain.balance.stars < 10) {
      return left(new ValidationError('Недостаточно звезд'))
    }
    if (!brain.subscription?.is_active) {
      return left(new ValidationError('Требуется активная подписка'))
    }
    return right(true)
  },
  
  // Функциональный обработчик с TaskEither
  handler: (brain, context, options, callback) =>
    pipe(
      // 1. Валидация через validate
      () => neuroPhotoAction.validate(brain, context),
      // 2. Создание операции через трансформер
      chain(() => 
        FunctionTransformer.createOperationTask(
          neuroPhotoPlugin,
          {
            telegramId: brain.telegram_id,
            botName: brain.bot_name,
            cost: 10,
            metadata: { prompt: context.data.prompt },
          }
        )
      ),
      // 3. Сохранение операции
      chain(operation => saveOperationTask(operation)),
      // 4. Генерация изображения
      chain(operation => generateNeuroPhotoTask(context.data)),
      // 5. Создание asset через трансформер
      chain(result => 
        FunctionTransformer.createAssetTask(operation, result)
      ),
      // 6. Сохранение asset
      chain(asset => saveAssetTask(asset)),
      // 7. Обновление операции
      chain(asset => updateOperationTask(operation.id, {
        status: 'completed',
        asset_id: asset.id,
      })),
      // 8. Уведомление пользователя (side effect через tapTask)
      tapTask(result => 
        callback?.({
          success: true,
          data: { assetId: result.asset.id },
          message: 'Изображение сгенерировано!',
        })
      ),
      // 9. Возврат результата
      map(result => ({
        success: true,
        data: { assetId: result.asset.id },
      }))
    )
}

export interface ActionContext {
  telegramId: TelegramId
  message?: string
  data?: Record<string, any>
  session?: UserSession
}

export interface ActionResult {
  success: boolean
  data?: any
  error?: Error
  message?: string
}

export type HandlerCallback = (result: ActionResult) => Promise<void>
```

#### 2. PluginProvider (Провайдеры данных)

```typescript
/**
 * Провайдер данных - предоставляет контекстную информацию
 */
export interface PluginProvider {
  name: string
  description: string
  
  // Получение данных
  get: (
    brain: AvatarBrain,
    context: ProviderContext
  ) => Promise<ProviderResult>
}

export interface ProviderContext {
  telegramId: TelegramId
  mode?: ModeEnum
  query?: string
}

export interface ProviderResult {
  text?: string
  values?: Record<string, any>
  data?: any
}

// ❌ НЕПРАВИЛЬНО: Возвращать строку напрямую
// ✅ ПРАВИЛЬНО: Возвращать объект ProviderResult
```

#### 3. PluginService (Сервисы плагина)

```typescript
/**
 * Сервис плагина - фоновые задачи и интеграции
 */
export abstract class PluginService {
  static serviceType: string // Статическое свойство типа сервиса
  
  // Обязательные методы
  abstract initialize(brain: AvatarBrain): Promise<void>
  abstract start(): Promise<void>
  abstract stop(): Promise<void>
  
  // Опциональные
  capabilityDescription?: string
}

// Пример реализации
class NeuroPhotoService extends PluginService {
  static serviceType = 'neuro-photo-service'
  
  async initialize(brain: AvatarBrain): Promise<void> {
    // Инициализация сервиса
  }
  
  async start(): Promise<void> {
    // Запуск фоновых задач
  }
  
  async stop(): Promise<void> {
    // Остановка и очистка
  }
}
```

#### 4. PluginEvaluator (Оценщики)

```typescript
/**
 * Оценщик - фильтрует и оценивает результаты
 */
export interface PluginEvaluator {
  name: string
  description: string
  
  handler: (
    brain: AvatarBrain,
    context: EvaluatorContext,
    state?: State
  ) => Promise<EvaluatorResult>
  
  validate?: (
    brain: AvatarBrain,
    context: EvaluatorContext
  ) => Promise<boolean>
  
  examples?: EvaluatorExample[][]
}

export interface EvaluatorContext {
  telegramId: TelegramId
  data: any
  operation?: Operation
}

export interface EvaluatorResult {
  success: boolean
  score?: number
  message?: string
  data?: any
}
```

### 💎 Бриллиант сознания аватаров: Оптимальная модель базы данных

#### 🎯 Философия проектирования

**"Бриллиант сознания"** - это идеальная модель БД, которая:

1. **Минимизирует дублирование кода** (DRY принцип)
2. **Максимизирует переиспользование** (единые таблицы для всех типов)
3. **Обеспечивает типобезопасность** (через функциональные типы и валидацию)
4. **Поддерживает функциональное программирование** (иммутабельные данные, чистые функции)
5. **Интегрируется с плагинной архитектурой** (ElizaOS schemas)
6. **Масштабируется без изменений** (гибкая структура через JSONB)

#### 🏗️ Архитектурные принципы:

1. **Единая таблица для всех типов контента** (`assets` вместо отдельных таблиц для изображений/видео/аудио)
2. **Единая таблица для всех операций** (`operations` вместо отдельных таблиц для генераций/обучения)
3. **Единая таблица для всех моделей** (`user_models` с полем `model_type`)
4. **Нормализация через JSONB** для гибких данных (баланс между нормализацией и гибкостью)
5. **Индексы для производительности** (оптимизированные запросы)
6. **Функциональные типы** (io-ts схемы для runtime валидации)
7. **Плагинные схемы** (интеграция с ElizaOS plugin schemas)
8. **Иммутабельность** (версионирование через `version` поле)
9. **Аудит и история** (отслеживание всех изменений)
10. **Транзакционность** (ACID гарантии для критических операций)

```sql
-- ========================================
-- 💎 БРИЛЛИАНТ СОЗНАНИЯ АВАТАРОВ
-- Оптимальная модель базы данных
-- 
-- Принципы:
-- 1. DRY (Don't Repeat Yourself) - единые таблицы для всех типов
-- 2. Функциональное программирование - иммутабельность, чистые функции
-- 3. Плагинная архитектура - интеграция с ElizaOS schemas
-- 4. Типобезопасность - runtime валидация через io-ts
-- 5. Масштабируемость - гибкая структура через JSONB
-- ========================================

-- ========================================
-- 1. ПОЛЬЗОВАТЕЛИ (Оптимизированная структура)
-- ========================================

CREATE TABLE users (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  telegram_id BIGINT NOT NULL,
  bot_name TEXT NOT NULL,
  
  -- Основная информация (часто используемые поля)
  username TEXT,
  first_name TEXT,
  last_name TEXT,
  language_code VARCHAR(10) DEFAULT 'ru',
  
  -- Настройки (через JSONB для гибкости и DRY)
  settings JSONB NOT NULL DEFAULT '{}', -- Все настройки в одном месте
  -- Структура settings:
  -- {
  --   "selected_ai_model": "minimax/minimax-m2",
  --   "selected_voice_id": "elevenlabs_voice_id",
  --   "avatar_id": "avatar_uuid",
  --   "avatar_photo_url": "https://...",
  --   "aspect_ratio": "16:9",
  --   "company": "...",
  --   "position": "...",
  --   "designation": "...",
  --   "email": "...",
  --   "level": 1
  -- }
  
  -- Приглашения (через JSONB для гибкости)
  referral JSONB DEFAULT '{}',
  -- Структура referral:
  -- {
  --   "inviter_id": "uuid",
  --   "invitation_codes": ["code1", "code2"],
  --   "referral_count": 0
  -- }
  
  -- Метаданные
  version INTEGER DEFAULT 1, -- Версионирование для иммутабельности
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  last_activity TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  
  -- Уникальность по комбинации telegram_id + bot_name
  CONSTRAINT users_telegram_id_bot_name_unique UNIQUE (telegram_id, bot_name)
);

-- Индексы для производительности
CREATE INDEX idx_users_telegram_id ON users(telegram_id);
CREATE INDEX idx_users_bot_name ON users(bot_name);
CREATE INDEX idx_users_telegram_id_bot_name ON users(telegram_id, bot_name); -- Композитный индекс
CREATE INDEX idx_users_last_activity ON users(last_activity DESC);
CREATE INDEX idx_users_settings_gin ON users USING GIN (settings); -- GIN индекс для JSONB поиска

-- Функция для обновления updated_at (DRY принцип)
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Триггер для автоматического обновления updated_at
CREATE TRIGGER update_users_updated_at
  BEFORE UPDATE ON users
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

-- ========================================
-- 2. БАЛАНС И ПЛАТЕЖИ (Оптимизированная структура)
-- ========================================

CREATE TABLE balances (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE, -- Связь через user_id вместо telegram_id+bot_name
  
  -- Балансы (все валюты в одной таблице - DRY)
  currencies JSONB NOT NULL DEFAULT '{}',
  -- Структура currencies:
  -- {
  --   "stars": 0,
  --   "rubles": 0,
  --   "dollars": 0,
  --   "xtr": 0  -- Telegram Stars
  -- }
  
  -- Статистика (через JSONB для гибкости)
  statistics JSONB DEFAULT '{}',
  -- Структура statistics:
  -- {
  --   "total_income": 0,
  --   "total_expense": 0,
  --   "total_operations": 0,
  --   "last_operation_date": "2025-01-12T00:00:00Z"
  -- }
  
  -- Метаданные
  version INTEGER DEFAULT 1,
  last_updated TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  
  CONSTRAINT balances_user_id_unique UNIQUE (user_id)
);

CREATE INDEX idx_balances_user_id ON balances(user_id);
CREATE INDEX idx_balances_currencies_gin ON balances USING GIN (currencies); -- GIN индекс для JSONB поиска

-- Триггер для автоматического обновления updated_at
CREATE TRIGGER update_balances_updated_at
  BEFORE UPDATE ON balances
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

CREATE TABLE payments_v2 (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE, -- Связь через user_id
  
  -- Идентификация платежа
  inv_id TEXT UNIQUE NOT NULL, -- Уникальный идентификатор инвойса
  
  -- Суммы (через JSONB для гибкости валют)
  amounts JSONB NOT NULL,
  -- Структура amounts:
  -- {
  --   "amount": 100.00,      -- Основная сумма
  --   "stars": 100,          -- В звездах
  --   "cost": 10,            -- Стоимость услуги
  --   "currency": "RUB",     -- Валюта платежа
  --   "conversion_rate": 1.0 -- Курс конвертации
  -- }
  
  -- Тип и статус (ENUM для типобезопасности)
  type VARCHAR(50) NOT NULL, -- MONEY_INCOME, MONEY_OUTCOME, STAR_INCOME, STAR_EXPENSE, BONUS, REFUND
  status VARCHAR(20) NOT NULL, -- PENDING, COMPLETED, FAILED, CANCELLED
  category VARCHAR(20) DEFAULT 'REAL', -- REAL, BONUS
  
  -- Связи (через UUID для нормализации)
  operation_id UUID REFERENCES operations(id) ON DELETE SET NULL,
  subscription_id UUID REFERENCES subscriptions(id) ON DELETE SET NULL,
  
  -- Платеж (через JSONB для гибкости)
  payment JSONB DEFAULT '{}',
  -- Структура payment:
  -- {
  --   "method": "Telegram|Robokassa|Manual",
  --   "invoice_url": "https://...",
  --   "description": "...",
  --   "provider": "telegram|robokassa",
  --   "provider_transaction_id": "..."
  -- }
  
  -- Контекст операции (через JSONB - DRY принцип)
  context JSONB DEFAULT '{}',
  -- Структура context:
  -- {
  --   "service_type": "neuro_photo|text_to_video|...",
  --   "model_name": "...",
  --   "subscription_type": "NEUROTESTER|NEUROVIDEO|...",
  --   "language": "ru|en",
  --   "is_system_payment": false
  -- }
  
  -- Метаданные (гибкие данные через JSONB)
  metadata JSONB DEFAULT '{}',
  
  -- Временные метки
  payment_date TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  
  -- Версионирование для иммутабельности
  version INTEGER DEFAULT 1
);

CREATE INDEX idx_payments_user_id ON payments_v2(user_id);
CREATE INDEX idx_payments_inv_id ON payments_v2(inv_id);
CREATE INDEX idx_payments_status ON payments_v2(status);
CREATE INDEX idx_payments_type ON payments_v2(type);
CREATE INDEX idx_payments_operation_id ON payments_v2(operation_id);
CREATE INDEX idx_payments_subscription_id ON payments_v2(subscription_id);
CREATE INDEX idx_payments_payment_date ON payments_v2(payment_date DESC);
CREATE INDEX idx_payments_context_gin ON payments_v2 USING GIN (context); -- GIN индекс для JSONB поиска
CREATE INDEX idx_payments_amounts_gin ON payments_v2 USING GIN (amounts); -- GIN индекс для JSONB поиска

-- Триггер для автоматического обновления updated_at
CREATE TRIGGER update_payments_updated_at
  BEFORE UPDATE ON payments_v2
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();


-- ========================================
-- 3. ПОДПИСКИ (Оптимизированная структура)
-- ========================================

CREATE TABLE subscriptions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE, -- Связь через user_id
  
  -- Тип подписки (ENUM для типобезопасности)
  type VARCHAR(50) NOT NULL, -- NEUROTESTER, NEUROVIDEO, NEUROPHOTO, STARS
  
  -- Период действия
  start_date TIMESTAMP WITH TIME ZONE NOT NULL,
  end_date TIMESTAMP WITH TIME ZONE NOT NULL,
  
  -- Статус (вычисляемое поле через функцию для DRY)
  is_active BOOLEAN GENERATED ALWAYS AS (
    end_date > NOW() AND is_enabled = true
  ) STORED,
  
  -- Управление
  is_enabled BOOLEAN DEFAULT true, -- Ручное отключение
  
  -- Метаданные (через JSONB для гибкости)
  metadata JSONB DEFAULT '{}',
  -- Структура metadata:
  -- {
  --   "auto_renew": false,
  --   "payment_id": "uuid",
  --   "features": ["neuro_photo", "text_to_video"],
  --   "limits": { "operations_per_day": 100 }
  -- }
  
  -- Метаданные
  version INTEGER DEFAULT 1,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  
  -- Уникальность: один пользователь - один тип подписки
  CONSTRAINT subscriptions_user_id_type_unique UNIQUE (user_id, type)
);

CREATE INDEX idx_subscriptions_user_id ON subscriptions(user_id);
CREATE INDEX idx_subscriptions_type ON subscriptions(type);
CREATE INDEX idx_subscriptions_is_active ON subscriptions(is_active);
CREATE INDEX idx_subscriptions_end_date ON subscriptions(end_date);
CREATE INDEX idx_subscriptions_metadata_gin ON subscriptions USING GIN (metadata); -- GIN индекс для JSONB поиска

-- Триггер для автоматического обновления updated_at
CREATE TRIGGER update_subscriptions_updated_at
  BEFORE UPDATE ON subscriptions
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

CREATE INDEX idx_subscriptions_telegram_id ON subscriptions(telegram_id);
CREATE INDEX idx_subscriptions_bot_name ON subscriptions(bot_name);
CREATE INDEX idx_subscriptions_type ON subscriptions(type);
CREATE INDEX idx_subscriptions_is_active ON subscriptions(is_active);
CREATE INDEX idx_subscriptions_end_date ON subscriptions(end_date);

-- ========================================
-- 4. МОДЕЛИ ПОЛЬЗОВАТЕЛЕЙ (ЕДИНАЯ ТАБЛИЦА - DRY)
-- ========================================

CREATE TABLE user_models (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE, -- Связь через user_id
  
  -- Основная информация
  model_name TEXT NOT NULL,
  model_type VARCHAR(50) NOT NULL, -- 'flux-lora', 'openrouter', 'custom', 'stable-diffusion'
  model_url TEXT NOT NULL, -- Формат: provider/model:version или URL
  model_key TEXT, -- Альтернативный ключ модели
  trigger_word TEXT NOT NULL,
  
  -- Параметры модели (через JSONB для гибкости - DRY)
  parameters JSONB DEFAULT '{}',
  -- Структура parameters:
  -- {
  --   "gender": "male|female|person",
  --   "finetune_id": "...",
  --   "base_model": "...",
  --   "lora_rank": 16,
  --   "training_steps": 1000
  -- }
  
  -- Обучение (через JSONB для универсальности - DRY)
  training JSONB DEFAULT '{}',
  -- Структура training:
  -- {
  --   "status": "training|completed|failed",
  --   "steps": 1000,
  --   "model": "flux-lora-portrait-trainer|flux-lora-fast-training",
  --   "started_at": "2025-01-12T00:00:00Z",
  --   "completed_at": "2025-01-12T00:00:00Z",
  --   "progress": 0.5,
  --   "error": null
  -- }
  
  -- Команда (через JSONB для гибкости)
  team JSONB DEFAULT '{}',
  -- Структура team:
  -- {
  --   "is_team_model": false,
  --   "team_id": "...",
  --   "shared_with": ["user_id1", "user_id2"]
  -- }
  
  -- Метаданные (гибкие данные через JSONB)
  metadata JSONB DEFAULT '{}',
  
  -- Управление
  is_active BOOLEAN DEFAULT true,
  version INTEGER DEFAULT 1,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE INDEX idx_user_models_user_id ON user_models(user_id);
CREATE INDEX idx_user_models_model_type ON user_models(model_type);
CREATE INDEX idx_user_models_is_active ON user_models(is_active);
CREATE INDEX idx_user_models_training_gin ON user_models USING GIN (training); -- GIN индекс для JSONB поиска
CREATE INDEX idx_user_models_parameters_gin ON user_models USING GIN (parameters); -- GIN индекс для JSONB поиска

-- Триггер для автоматического обновления updated_at
CREATE TRIGGER update_user_models_updated_at
  BEFORE UPDATE ON user_models
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();


-- ========================================
-- 5. МЕДИА ФАЙЛЫ (ЕДИНАЯ ТАБЛИЦА ДЛЯ ВСЕХ ТИПОВ - DRY)
-- ========================================

CREATE TABLE assets (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE, -- Связь через user_id
  
  -- Тип и URL (базовые поля)
  type VARCHAR(20) NOT NULL, -- 'image', 'video', 'audio', 'document'
  url TEXT NOT NULL,
  file_id TEXT, -- Telegram file_id
  
  -- Связи
  operation_id UUID REFERENCES operations(id) ON DELETE SET NULL,
  
  -- Контекст генерации (через JSONB - DRY принцип)
  context JSONB DEFAULT '{}',
  -- Структура context:
  -- {
  --   "service_type": "neuro_photo|text_to_video|image_to_video|...",
  --   "model_name": "...",
  --   "prompt": "...",
  --   "negative_prompt": "...",
  --   "parameters": { "seed": 123, "steps": 50 }
  -- }
  
  -- Метаданные файла (через JSONB для гибкости - DRY)
  metadata JSONB DEFAULT '{}',
  -- Структура metadata:
  -- {
  --   "width": 1024,
  --   "height": 1024,
  --   "duration": 30,        -- для видео/аудио
  --   "size": 1024000,       -- размер в байтах
  --   "format": "png|mp4|mp3",
  --   "aspect_ratio": "16:9",
  --   "resolution": "1024x1024",
  --   "fps": 30,             -- для видео
  --   "bitrate": 1000,       -- для видео/аудио
  --   "codec": "h264|aac"    -- для видео/аудио
  -- }
  
  -- Управление жизненным циклом
  expires_at TIMESTAMP WITH TIME ZONE,
  is_archived BOOLEAN DEFAULT false,
  
  -- Метаданные
  version INTEGER DEFAULT 1,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE INDEX idx_assets_user_id ON assets(user_id);
CREATE INDEX idx_assets_type ON assets(type);
CREATE INDEX idx_assets_operation_id ON assets(operation_id);
CREATE INDEX idx_assets_created_at ON assets(created_at DESC);
CREATE INDEX idx_assets_expires_at ON assets(expires_at) WHERE expires_at IS NOT NULL;
CREATE INDEX idx_assets_context_gin ON assets USING GIN (context); -- GIN индекс для JSONB поиска
CREATE INDEX idx_assets_metadata_gin ON assets USING GIN (metadata); -- GIN индекс для JSONB поиска

-- Триггер для автоматического обновления updated_at
CREATE TRIGGER update_assets_updated_at
  BEFORE UPDATE ON assets
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();


-- ========================================
-- 6. ОПЕРАЦИИ (ЕДИНАЯ ТАБЛИЦА ДЛЯ ВСЕХ ТИПОВ - DRY)
-- ========================================

CREATE TABLE operations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE, -- Связь через user_id
  
  -- Тип операции (ENUM для типобезопасности)
  type VARCHAR(50) NOT NULL, -- 'generation', 'training', 'processing', 'transformation', 'analysis'
  service_type VARCHAR(100) NOT NULL, -- neuro_photo, text_to_video, digital_avatar_body, etc.
  
  -- Статус (вычисляемое поле для DRY)
  status VARCHAR(20) DEFAULT 'pending', -- pending, processing, completed, failed, cancelled
  
  -- Стоимость (через JSONB для гибкости валют)
  cost JSONB DEFAULT '{}',
  -- Структура cost:
  -- {
  --   "stars": 10,
  --   "rubles": 100,
  --   "dollars": 1,
  --   "currency": "STARS"
  -- }
  
  -- Результат (связь с asset_id)
  asset_id UUID REFERENCES assets(id) ON DELETE SET NULL,
  
  -- Результат операции (через JSONB - DRY)
  result JSONB DEFAULT '{}',
  -- Структура result:
  -- {
  --   "success": true,
  --   "data": { ... },
  --   "url": "https://...",
  --   "message": "..."
  -- }
  
  -- Ошибки (через JSONB для структурированности)
  error JSONB DEFAULT NULL,
  -- Структура error:
  -- {
  --   "message": "Error message",
  --   "code": "ERROR_CODE",
  --   "details": { ... },
  --   "stack": "..."
  -- }
  
  -- Внешние системы (через JSONB - DRY)
  external JSONB DEFAULT '{}',
  -- Структура external:
  -- {
  --   "inngest_event_id": "...",
  --   "job_id": "...",
  --   "provider": "replicate|fal|kie",
  --   "provider_job_id": "..."
  -- }
  
  -- Метаданные операции (через JSONB - DRY)
  metadata JSONB DEFAULT '{}',
  -- Структура metadata:
  -- {
  --   "plugin": "neuro-photo",
  --   "plugin_version": "1.0.0",
  --   "input": { ... },
  --   "output": { ... }
  -- }
  
  -- Временные метки
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  started_at TIMESTAMP WITH TIME ZONE,
  completed_at TIMESTAMP WITH TIME ZONE,
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  
  -- Версионирование для иммутабельности
  version INTEGER DEFAULT 1
);

CREATE INDEX idx_operations_user_id ON operations(user_id);
CREATE INDEX idx_operations_type ON operations(type);
CREATE INDEX idx_operations_service_type ON operations(service_type);
CREATE INDEX idx_operations_status ON operations(status);
CREATE INDEX idx_operations_asset_id ON operations(asset_id);
CREATE INDEX idx_operations_created_at ON operations(created_at DESC);
CREATE INDEX idx_operations_result_gin ON operations USING GIN (result); -- GIN индекс для JSONB поиска
CREATE INDEX idx_operations_metadata_gin ON operations USING GIN (metadata); -- GIN индекс для JSONB поиска
CREATE INDEX idx_operations_external_gin ON operations USING GIN (external); -- GIN индекс для JSONB поиска

-- Триггер для автоматического обновления updated_at
CREATE TRIGGER update_operations_updated_at
  BEFORE UPDATE ON operations
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();


-- ========================================
-- 7. СЕССИИ (для временных данных - DRY)
-- ========================================

CREATE TABLE user_sessions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE, -- Связь через user_id
  session_id TEXT UNIQUE NOT NULL,
  
  -- Состояние (через JSONB для гибкости - DRY)
  state JSONB DEFAULT '{}',
  -- Структура state:
  -- {
  --   "mode": "neuro_photo|text_to_video|...",
  --   "scene": "wizard_scene_1",
  --   "step": 1,
  --   "current_action": "..."
  -- }
  
  -- Данные wizard'а (через JSONB - DRY)
  wizard_data JSONB DEFAULT '{}',
  -- Структура wizard_data:
  -- {
  --   "neuroPhoto": { "prompt": "...", "model": "..." },
  --   "textToVideo": { "prompt": "...", "duration": 10 },
  --   "aiPhotoshop": { "imageUrl": "...", "style": "..." }
  -- }
  
  -- Контент (через JSONB - DRY)
  content JSONB DEFAULT '{}',
  -- Структура content:
  -- {
  --   "prompt": "...",
  --   "image_url": "...",
  --   "video_url": "...",
  --   "audio_url": "...",
  --   "selected_model_id": "uuid",
  --   "selected_video_model": "...",
  --   "selected_image_model": "..."
  -- }
  
  -- Временные данные (через JSONB - DRY)
  temp_data JSONB DEFAULT '{}',
  
  -- Временные метки
  started_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  last_activity TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  expires_at TIMESTAMP WITH TIME ZONE,
  
  -- Версионирование
  version INTEGER DEFAULT 1
);

CREATE INDEX idx_user_sessions_user_id ON user_sessions(user_id);
CREATE INDEX idx_user_sessions_session_id ON user_sessions(session_id);
CREATE INDEX idx_user_sessions_expires_at ON user_sessions(expires_at) WHERE expires_at IS NOT NULL;
CREATE INDEX idx_user_sessions_state_gin ON user_sessions USING GIN (state); -- GIN индекс для JSONB поиска
CREATE INDEX idx_user_sessions_wizard_data_gin ON user_sessions USING GIN (wizard_data); -- GIN индекс для JSONB поиска


-- ========================================
-- 8. ПЛАГИНЫ (РЕГИСТР ПЛАГИНОВ - ElizaOS Schema)
-- ========================================

CREATE TABLE plugins (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name VARCHAR(100) UNIQUE NOT NULL,
  description TEXT,
  version VARCHAR(20) NOT NULL,
  
  -- Метаданные (через JSONB - DRY)
  metadata JSONB DEFAULT '{}',
  -- Структура metadata:
  -- {
  --   "mode": "neuro_photo|text_to_video|...",
  --   "category": "ai|tools|admin|navigation|payment|video",
  --   "icon": "📸",
  --   "author": "...",
  --   "repository": "..."
  -- }
  
  -- Права доступа (через JSONB - DRY)
  permissions JSONB DEFAULT '{}',
  -- Структура permissions:
  -- {
  --   "admin_only": false,
  --   "requires_subscription": false,
  --   "subscription_types": ["NEUROTESTER"],
  --   "min_level": 1,
  --   "allowed_bots": ["neuro_blogger_bot", "MetaMuse_Manifest_bot", "ZavaraBot", "LeeSolarbot", "NeuroLenaAssistant_bot", "NeurostylistShtogrina_bot", "Gaia_Kamskaia_bot", "Kaya_easy_art_bot", "AI_STARS_bot", "HaimGroupMedia_bot"]
  -- }
  
  -- Конфигурация плагина (ElizaOS schema - через JSONB)
  config JSONB DEFAULT '{}',
  -- Структура config (ElizaOS plugin schema):
  -- {
  --   "actions": [...],
  --   "providers": [...],
  --   "services": [...],
  --   "evaluators": [...],
  --   "routes": [...],
  --   "events": [...],
  --   "adapters": [...]
  -- }
  
  -- Статус
  is_active BOOLEAN DEFAULT true,
  is_enabled BOOLEAN DEFAULT true,
  
  -- Метаданные
  version_number INTEGER DEFAULT 1,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE INDEX idx_plugins_name ON plugins(name);
CREATE INDEX idx_plugins_is_active ON plugins(is_active);
CREATE INDEX idx_plugins_is_enabled ON plugins(is_enabled);
CREATE INDEX idx_plugins_metadata_gin ON plugins USING GIN (metadata); -- GIN индекс для JSONB поиска
CREATE INDEX idx_plugins_config_gin ON plugins USING GIN (config); -- GIN индекс для JSONB поиска
CREATE INDEX idx_plugins_permissions_gin ON plugins USING GIN (permissions); -- GIN индекс для JSONB поиска

-- Триггер для автоматического обновления updated_at
CREATE TRIGGER update_plugins_updated_at
  BEFORE UPDATE ON plugins
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

-- ========================================
-- 9. КОНФИГУРАЦИЯ БОТОВ (DRY принцип)
-- ========================================

CREATE TABLE bot_configs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  bot_name TEXT UNIQUE NOT NULL,
  
  -- Безопасность (отдельно для безопасности)
  token TEXT NOT NULL,
  admin_ids INTEGER[] NOT NULL DEFAULT '{}',
  
  -- Конфигурация (через JSONB - DRY)
  config JSONB NOT NULL DEFAULT '{}',
  -- Структура config:
  -- {
  --   "port": 3001,
  --   "features": {
  --     "neuroPhoto": true,
  --     "textToVideo": true,
  --     "aiPhotoshop": true
  --   },
  --   "pricing": {
  --     "neuroPhoto": 10,
  --     "textToVideo": { "kling": 20, "runway": 30 }
  --   },
  --   "limits": {
  --     "maxImagesPerGeneration": 4,
  --     "maxVideoDuration": 60,
  --     "maxFileSize": 10000000
  --   },
  --   "webhook": {
  --     "url": "https://...",
  --     "secret": "..."
  --   }
  -- }
  
  -- Метаданные
  version INTEGER DEFAULT 1,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE INDEX idx_bot_configs_bot_name ON bot_configs(bot_name);
CREATE INDEX idx_bot_configs_config_gin ON bot_configs USING GIN (config); -- GIN индекс для JSONB поиска

-- Триггер для автоматического обновления updated_at
CREATE TRIGGER update_bot_configs_updated_at
  BEFORE UPDATE ON bot_configs
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

-- ========================================
-- 10. АУДИТ И ИСТОРИЯ (для иммутабельности)
-- ========================================

CREATE TABLE audit_log (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES users(id) ON DELETE SET NULL,
  
  -- Действие
  action VARCHAR(100) NOT NULL, -- CREATE, UPDATE, DELETE, EXECUTE
  entity_type VARCHAR(100) NOT NULL, -- user, operation, asset, payment
  entity_id UUID NOT NULL,
  
  -- Изменения (через JSONB - DRY)
  changes JSONB DEFAULT '{}',
  -- Структура changes:
  -- {
  --   "before": { ... },
  --   "after": { ... },
  --   "diff": { ... }
  -- }
  
  -- Контекст
  context JSONB DEFAULT '{}',
  -- Структура context:
  -- {
  --   "ip": "...",
  --   "user_agent": "...",
  --   "plugin": "neuro-photo",
  --   "operation_id": "uuid"
  -- }
  
  -- Временная метка
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE INDEX idx_audit_log_user_id ON audit_log(user_id);
CREATE INDEX idx_audit_log_entity_type_id ON audit_log(entity_type, entity_id);
CREATE INDEX idx_audit_log_action ON audit_log(action);
CREATE INDEX idx_audit_log_created_at ON audit_log(created_at DESC);
CREATE INDEX idx_audit_log_changes_gin ON audit_log USING GIN (changes); -- GIN индекс для JSONB поиска

-- ========================================
-- 11. ФУНКЦИОНАЛЬНЫЕ ТИПЫ (io-ts схемы для валидации)
-- ========================================

-- Функции для валидации JSONB данных (runtime валидация)
-- Эти функции используются в функциональном коде для валидации данных

CREATE OR REPLACE FUNCTION validate_user_settings(settings JSONB)
RETURNS BOOLEAN AS $$
BEGIN
  -- Валидация структуры settings через JSONB операторы
  RETURN (
    settings ? 'selected_ai_model' OR
    settings ? 'selected_voice_id' OR
    settings ? 'avatar_id'
  );
END;
$$ LANGUAGE plpgsql IMMUTABLE;

CREATE OR REPLACE FUNCTION validate_operation_result(result JSONB)
RETURNS BOOLEAN AS $$
BEGIN
  -- Валидация структуры result
  RETURN (
    result ? 'success' AND
    (result->>'success')::boolean IS NOT NULL
  );
END;
$$ LANGUAGE plpgsql IMMUTABLE;

-- ========================================
-- 12. МАТЕРИАЛИЗОВАННЫЕ ПРЕДСТАВЛЕНИЯ (для производительности)
-- ========================================

-- Представление для быстрого доступа к "Мозгу аватара"
CREATE MATERIALIZED VIEW avatar_brain_view AS
SELECT 
  u.id,
  u.telegram_id,
  u.bot_name,
  u.username,
  u.first_name,
  u.last_name,
  u.language_code,
  u.settings,
  u.referral,
  u.created_at,
  u.updated_at,
  u.last_activity,
  
  -- Баланс
  b.currencies AS balance,
  b.statistics AS balance_statistics,
  
  -- Подписка
  s.type AS subscription_type,
  s.start_date AS subscription_start,
  s.end_date AS subscription_end,
  s.is_active AS subscription_active,
  s.metadata AS subscription_metadata,
  
  -- Модели
  json_agg(
    json_build_object(
      'id', um.id,
      'model_name', um.model_name,
      'model_type', um.model_type,
      'model_url', um.model_url,
      'trigger_word', um.trigger_word,
      'parameters', um.parameters,
      'training', um.training,
      'is_active', um.is_active
    )
  ) FILTER (WHERE um.id IS NOT NULL) AS models,
  
  -- Статистика операций
  COUNT(DISTINCT o.id) AS total_operations,
  COUNT(DISTINCT a.id) AS total_assets
  
FROM users u
LEFT JOIN balances b ON b.user_id = u.id
LEFT JOIN subscriptions s ON s.user_id = u.id AND s.is_active = true
LEFT JOIN user_models um ON um.user_id = u.id AND um.is_active = true
LEFT JOIN operations o ON o.user_id = u.id
LEFT JOIN assets a ON a.user_id = u.id
GROUP BY u.id, b.currencies, b.statistics, s.type, s.start_date, s.end_date, s.is_active, s.metadata;

-- Индексы для материализованного представления
CREATE UNIQUE INDEX idx_avatar_brain_view_id ON avatar_brain_view(id);
CREATE INDEX idx_avatar_brain_view_telegram_id ON avatar_brain_view(telegram_id);
CREATE INDEX idx_avatar_brain_view_bot_name ON avatar_brain_view(bot_name);

-- Функция для обновления представления
CREATE OR REPLACE FUNCTION refresh_avatar_brain_view()
RETURNS void AS $$
BEGIN
  REFRESH MATERIALIZED VIEW CONCURRENTLY avatar_brain_view;
END;
$$ LANGUAGE plpgsql;

-- ========================================
-- 13. ТРИГГЕРЫ ДЛЯ АВТОМАТИЧЕСКОГО ОБНОВЛЕНИЯ ПРЕДСТАВЛЕНИЯ
-- ========================================

-- Автоматическое обновление представления при изменении данных
CREATE OR REPLACE FUNCTION trigger_refresh_avatar_brain_view()
RETURNS TRIGGER AS $$
BEGIN
  PERFORM refresh_avatar_brain_view();
  RETURN NULL;
END;
$$ LANGUAGE plpgsql;

-- Триггеры для обновления представления
CREATE TRIGGER refresh_avatar_brain_on_user_update
  AFTER INSERT OR UPDATE OR DELETE ON users
  FOR EACH ROW
  EXECUTE FUNCTION trigger_refresh_avatar_brain_view();

CREATE TRIGGER refresh_avatar_brain_on_balance_update
  AFTER INSERT OR UPDATE OR DELETE ON balances
  FOR EACH ROW
  EXECUTE FUNCTION trigger_refresh_avatar_brain_view();

CREATE TRIGGER refresh_avatar_brain_on_subscription_update
  AFTER INSERT OR UPDATE OR DELETE ON subscriptions
  FOR EACH ROW
  EXECUTE FUNCTION trigger_refresh_avatar_brain_view();

-- ========================================
-- 14. ФУНКЦИИ ДЛЯ ФУНКЦИОНАЛЬНОГО ПРОГРАММИРОВАНИЯ
-- ========================================

-- Функция для иммутабельного обновления (создает новую версию)
CREATE OR REPLACE FUNCTION immutable_update_user(
  p_user_id UUID,
  p_updates JSONB
)
RETURNS UUID AS $$
DECLARE
  v_new_id UUID;
BEGIN
  -- Создаем новую версию пользователя
  INSERT INTO users (
    telegram_id,
    bot_name,
    username,
    first_name,
    last_name,
    language_code,
    settings,
    referral,
    version
  )
  SELECT 
    telegram_id,
    bot_name,
    username,
    first_name,
    last_name,
    language_code,
    settings || p_updates, -- Мержим настройки
    referral,
    version + 1
  FROM users
  WHERE id = p_user_id
  RETURNING id INTO v_new_id;
  
  RETURN v_new_id;
END;
$$ LANGUAGE plpgsql;

-- Функция для получения "Мозга аватара" (функциональный стиль)
CREATE OR REPLACE FUNCTION get_avatar_brain(
  p_telegram_id BIGINT,
  p_bot_name TEXT
)
RETURNS JSONB AS $$
DECLARE
  v_brain JSONB;
BEGIN
  SELECT json_build_object(
    'id', u.id,
    'telegram_id', u.telegram_id,
    'bot_name', u.bot_name,
    'user', json_build_object(
      'id', u.id,
      'telegram_id', u.telegram_id,
      'username', u.username,
      'first_name', u.first_name,
      'last_name', u.last_name,
      'language_code', u.language_code,
      'settings', u.settings,
      'referral', u.referral
    ),
    'balance', json_build_object(
      'currencies', b.currencies,
      'statistics', b.statistics
    ),
    'subscription', CASE 
      WHEN s.id IS NOT NULL THEN json_build_object(
        'id', s.id,
        'type', s.type,
        'start_date', s.start_date,
        'end_date', s.end_date,
        'is_active', s.is_active,
        'metadata', s.metadata
      )
      ELSE NULL
    END,
    'models', COALESCE(
      json_agg(
        json_build_object(
          'id', um.id,
          'model_name', um.model_name,
          'model_type', um.model_type,
          'model_url', um.model_url,
          'trigger_word', um.trigger_word,
          'parameters', um.parameters,
          'training', um.training,
          'is_active', um.is_active
        )
      ) FILTER (WHERE um.id IS NOT NULL),
      '[]'::json
    ),
    'version', u.version,
    'created_at', u.created_at,
    'updated_at', u.updated_at
  ) INTO v_brain
  FROM users u
  LEFT JOIN balances b ON b.user_id = u.id
  LEFT JOIN subscriptions s ON s.user_id = u.id AND s.is_active = true
  LEFT JOIN user_models um ON um.user_id = u.id AND um.is_active = true
  WHERE u.telegram_id = p_telegram_id AND u.bot_name = p_bot_name
  GROUP BY u.id, b.currencies, b.statistics, s.id, s.type, s.start_date, s.end_date, s.is_active, s.metadata;
  
  RETURN v_brain;
END;
$$ LANGUAGE plpgsql STABLE;

-- ========================================
-- 15. ОГРАНИЧЕНИЯ И ВАЛИДАЦИЯ (для типобезопасности)
-- ========================================

-- CHECK ограничения для валидации данных
ALTER TABLE users
  ADD CONSTRAINT check_settings_is_object 
  CHECK (jsonb_typeof(settings) = 'object');

ALTER TABLE balances
  ADD CONSTRAINT check_currencies_is_object 
  CHECK (jsonb_typeof(currencies) = 'object');

ALTER TABLE operations
  ADD CONSTRAINT check_cost_is_object 
  CHECK (jsonb_typeof(cost) = 'object');

ALTER TABLE assets
  ADD CONSTRAINT check_metadata_is_object 
  CHECK (jsonb_typeof(metadata) = 'object' OR metadata IS NULL);

-- ========================================
-- 16. ПРЕДСТАВЛЕНИЯ ДЛЯ УДОБСТВА (DRY принцип)
-- ========================================

-- Представление для активных операций
CREATE VIEW active_operations AS
SELECT 
  o.*,
  u.telegram_id,
  u.bot_name
FROM operations o
JOIN users u ON u.id = o.user_id
WHERE o.status IN ('pending', 'processing');

-- Представление для активных подписок
CREATE VIEW active_subscriptions AS
SELECT 
  s.*,
  u.telegram_id,
  u.bot_name
FROM subscriptions s
JOIN users u ON u.id = s.user_id
WHERE s.is_active = true AND s.is_enabled = true;

-- Представление для пользователей с балансом
CREATE VIEW users_with_balance AS
SELECT 
  u.*,
  b.currencies AS balance,
  b.statistics AS balance_statistics
FROM users u
LEFT JOIN balances b ON b.user_id = u.id;
```

### 💎 Преимущества модели "Бриллиант сознания аватаров"

#### 🎯 Ключевые достижения:

1. **DRY принцип (Don't Repeat Yourself)**
   - ✅ Единые таблицы для всех типов (`assets`, `operations`, `user_models`)
   - ✅ JSONB для гибких данных вместо множества отдельных полей
   - ✅ Единая функция `update_updated_at_column()` для всех таблиц
   - ✅ Единая функция `get_avatar_brain()` для получения всех данных

2. **Функциональное программирование**
   - ✅ Иммутабельность через версионирование (`version` поле)
   - ✅ Чистые функции для валидации (`validate_user_settings`, `validate_operation_result`)
   - ✅ Иммутабельные обновления (`immutable_update_user`)
   - ✅ Функциональные типы через CHECK ограничения

3. **Плагинная архитектура (ElizaOS)**
   - ✅ Таблица `plugins` с ElizaOS schema через JSONB
   - ✅ Гибкая конфигурация плагинов через `config` JSONB
   - ✅ Права доступа через `permissions` JSONB
   - ✅ Метаданные плагинов через `metadata` JSONB

4. **Производительность**
   - ✅ GIN индексы для JSONB полей (быстрый поиск)
   - ✅ Композитные индексы для частых запросов
   - ✅ Материализованное представление `avatar_brain_view` для быстрого доступа
   - ✅ Автоматическое обновление представления через триггеры

5. **Типобезопасность**
   - ✅ CHECK ограничения для валидации JSONB структуры
   - ✅ Функции валидации для runtime проверки
   - ✅ Строгие типы через ENUM (статусы, типы операций)

6. **Масштабируемость**
   - ✅ Гибкая структура через JSONB (легко добавлять новые поля)
   - ✅ Нормализация через `user_id` вместо `telegram_id + bot_name`
   - ✅ Аудит и история через `audit_log`
   - ✅ Версионирование для отслеживания изменений

7. **Удобство использования**
   - ✅ Представления для частых запросов (`active_operations`, `active_subscriptions`)
   - ✅ Функция `get_avatar_brain()` для получения всех данных одной функцией
   - ✅ Автоматическое обновление `updated_at` через триггеры

#### 📊 Сравнение с предыдущей моделью:

| Аспект | Старая модель | Новая модель "Бриллиант" |
|--------|---------------|--------------------------|
| **Дублирование кода** | Множество отдельных полей | JSONB для гибких данных |
| **Связи** | `telegram_id + bot_name` | `user_id` (UUID) |
| **Версионирование** | Нет | Есть (`version` поле) |
| **Аудит** | Нет | Есть (`audit_log`) |
| **Производительность** | Базовые индексы | GIN индексы + материализованные представления |
| **Типобезопасность** | Минимальная | CHECK ограничения + функции валидации |
| **Функциональное программирование** | Нет | Иммутабельные обновления, чистые функции |
| **Плагинная архитектура** | Частичная | Полная интеграция с ElizaOS schemas |

#### 🚀 Результат:

**"Бриллиант сознания аватаров"** - это оптимальная модель БД, которая:
- ✅ Минимизирует дублирование кода (DRY)
- ✅ Максимизирует переиспользование (единые таблицы)
- ✅ Обеспечивает типобезопасность (CHECK + валидация)
- ✅ Поддерживает функциональное программирование (иммутабельность)
- ✅ Интегрируется с плагинной архитектурой (ElizaOS)
- ✅ Масштабируется без изменений (JSONB гибкость)
- ✅ Оптимизирована для производительности (GIN индексы + представления)

**Это действительно бриллиант - идеальная модель для сознания аватаров!** 💎✨

### 🔍 Критический анализ и улучшения (Итерация 2.0)

#### 🎯 Выявленные области для улучшения:

1. **Партиционирование больших таблиц** - для масштабирования
2. **Система миграций** - для версионирования схемы
3. **Кэширование** - стратегия кэширования частых запросов
4. **Connection pooling** - оптимизация подключений
5. **Мониторинг и метрики** - отслеживание производительности
6. **Оптимизация материализованных представлений** - стратегия обновления
7. **Автоматический аудит** - триггеры для логирования изменений
8. **Хранимые процедуры** - для частых операций
9. **Полнотекстовый поиск** - для JSONB полей
10. **Оптимизация индексов** - частичные индексы для производительности

#### 🚀 Улучшения модели БД:

```sql
-- ========================================
-- 17. ПАРТИЦИОНИРОВАНИЕ (для масштабирования)
-- ========================================

-- Партиционирование таблицы operations по дате (для больших объемов данных)
CREATE TABLE operations (
  id UUID NOT NULL DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  type VARCHAR(50) NOT NULL,
  service_type VARCHAR(100) NOT NULL,
  status VARCHAR(20) DEFAULT 'pending',
  cost JSONB DEFAULT '{}',
  asset_id UUID REFERENCES assets(id) ON DELETE SET NULL,
  result JSONB DEFAULT '{}',
  error JSONB DEFAULT NULL,
  external JSONB DEFAULT '{}',
  metadata JSONB DEFAULT '{}',
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  started_at TIMESTAMP WITH TIME ZONE,
  completed_at TIMESTAMP WITH TIME ZONE,
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  version INTEGER DEFAULT 1,
  PRIMARY KEY (id, created_at)
) PARTITION BY RANGE (created_at);

-- Партиции по месяцам (автоматическое создание через функцию)
CREATE TABLE operations_2025_01 PARTITION OF operations
  FOR VALUES FROM ('2025-01-01') TO ('2025-02-01');
CREATE TABLE operations_2025_02 PARTITION OF operations
  FOR VALUES FROM ('2025-02-01') TO ('2025-03-01');
-- ... и так далее

-- Функция для автоматического создания партиций
CREATE OR REPLACE FUNCTION create_operations_partition(month_date DATE)
RETURNS void AS $$
DECLARE
  partition_name TEXT;
  start_date DATE;
  end_date DATE;
BEGIN
  start_date := date_trunc('month', month_date);
  end_date := start_date + INTERVAL '1 month';
  partition_name := 'operations_' || to_char(start_date, 'YYYY_MM');
  
  EXECUTE format(
    'CREATE TABLE IF NOT EXISTS %I PARTITION OF operations FOR VALUES FROM (%L) TO (%L)',
    partition_name,
    start_date,
    end_date
  );
END;
$$ LANGUAGE plpgsql;

-- ========================================
-- 18. СИСТЕМА МИГРАЦИЙ (для версионирования схемы)
-- ========================================

CREATE TABLE schema_migrations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  version VARCHAR(50) UNIQUE NOT NULL,
  name TEXT NOT NULL,
  applied_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  checksum TEXT, -- Для проверки целостности миграции
  execution_time_ms INTEGER,
  success BOOLEAN DEFAULT true,
  error_message TEXT
);

CREATE INDEX idx_schema_migrations_version ON schema_migrations(version);
CREATE INDEX idx_schema_migrations_applied_at ON schema_migrations(applied_at DESC);

-- Функция для применения миграции
CREATE OR REPLACE FUNCTION apply_migration(
  p_version VARCHAR(50),
  p_name TEXT,
  p_sql TEXT
)
RETURNS BOOLEAN AS $$
DECLARE
  v_start_time TIMESTAMP;
  v_end_time TIMESTAMP;
  v_checksum TEXT;
BEGIN
  v_start_time := clock_timestamp();
  v_checksum := md5(p_sql);
  
  BEGIN
    EXECUTE p_sql;
    
    v_end_time := clock_timestamp();
    
    INSERT INTO schema_migrations (version, name, checksum, execution_time_ms, success)
    VALUES (
      p_version,
      p_name,
      v_checksum,
      EXTRACT(EPOCH FROM (v_end_time - v_start_time))::INTEGER * 1000,
      true
    );
    
    RETURN true;
  EXCEPTION WHEN OTHERS THEN
    INSERT INTO schema_migrations (version, name, checksum, success, error_message)
    VALUES (
      p_version,
      p_name,
      v_checksum,
      false,
      SQLERRM
    );
    
    RETURN false;
  END;
END;
$$ LANGUAGE plpgsql;

-- ========================================
-- 19. КЭШИРОВАНИЕ (стратегия кэширования)
-- ========================================

CREATE TABLE cache_entries (
  key TEXT PRIMARY KEY,
  value JSONB NOT NULL,
  expires_at TIMESTAMP WITH TIME ZONE NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  access_count INTEGER DEFAULT 0,
  last_accessed_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE INDEX idx_cache_entries_expires_at ON cache_entries(expires_at);

-- Функция для очистки устаревших записей кэша
CREATE OR REPLACE FUNCTION cleanup_expired_cache()
RETURNS INTEGER AS $$
DECLARE
  deleted_count INTEGER;
BEGIN
  DELETE FROM cache_entries WHERE expires_at < NOW();
  GET DIAGNOSTICS deleted_count = ROW_COUNT;
  RETURN deleted_count;
END;
$$ LANGUAGE plpgsql;

-- Автоматическая очистка кэша (через pg_cron или внешний скрипт)
-- SELECT cron.schedule('cleanup-cache', '0 * * * *', 'SELECT cleanup_expired_cache()');

-- Функция для получения из кэша с обновлением статистики
CREATE OR REPLACE FUNCTION get_cached_value(p_key TEXT)
RETURNS JSONB AS $$
DECLARE
  v_value JSONB;
BEGIN
  UPDATE cache_entries
  SET access_count = access_count + 1,
      last_accessed_at = NOW()
  WHERE key = p_key AND expires_at > NOW()
  RETURNING value INTO v_value;
  
  RETURN v_value;
END;
$$ LANGUAGE plpgsql;

-- ========================================
-- 20. МОНИТОРИНГ И МЕТРИКИ
-- ========================================

CREATE TABLE performance_metrics (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  metric_name VARCHAR(100) NOT NULL,
  metric_value NUMERIC NOT NULL,
  metric_type VARCHAR(50) NOT NULL, -- counter, gauge, histogram, summary
  labels JSONB DEFAULT '{}', -- Метки для группировки метрик
  timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE INDEX idx_performance_metrics_name_time ON performance_metrics(metric_name, timestamp DESC);
CREATE INDEX idx_performance_metrics_labels_gin ON performance_metrics USING GIN (labels);

-- Функция для записи метрики
CREATE OR REPLACE FUNCTION record_metric(
  p_name VARCHAR(100),
  p_value NUMERIC,
  p_type VARCHAR(50),
  p_labels JSONB DEFAULT '{}'
)
RETURNS void AS $$
BEGIN
  INSERT INTO performance_metrics (metric_name, metric_value, metric_type, labels)
  VALUES (p_name, p_value, p_type, p_labels);
END;
$$ LANGUAGE plpgsql;

-- Представление для статистики производительности
CREATE VIEW performance_stats AS
SELECT 
  metric_name,
  metric_type,
  COUNT(*) as count,
  AVG(metric_value) as avg_value,
  MIN(metric_value) as min_value,
  MAX(metric_value) as max_value,
  PERCENTILE_CONT(0.95) WITHIN GROUP (ORDER BY metric_value) as p95_value,
  MAX(timestamp) as last_recorded
FROM performance_metrics
WHERE timestamp > NOW() - INTERVAL '24 hours'
GROUP BY metric_name, metric_type;

-- ========================================
-- 21. ОПТИМИЗАЦИЯ МАТЕРИАЛИЗОВАННЫХ ПРЕДСТАВЛЕНИЙ
-- ========================================

-- Улучшенная стратегия обновления материализованного представления
-- Используем CONCURRENTLY для обновления без блокировки

-- Функция для безопасного обновления представления
CREATE OR REPLACE FUNCTION refresh_avatar_brain_view_safe()
RETURNS void AS $$
BEGIN
  -- Проверяем, не обновляется ли уже представление
  IF EXISTS (
    SELECT 1 FROM pg_stat_activity
    WHERE query LIKE '%REFRESH MATERIALIZED VIEW%avatar_brain_view%'
    AND state = 'active'
  ) THEN
    RAISE NOTICE 'View is already being refreshed';
    RETURN;
  END IF;
  
  -- Обновляем представление без блокировки
  REFRESH MATERIALIZED VIEW CONCURRENTLY avatar_brain_view;
END;
$$ LANGUAGE plpgsql;

-- Автоматическое обновление через триггер (оптимизированное)
CREATE OR REPLACE FUNCTION trigger_refresh_avatar_brain_view_optimized()
RETURNS TRIGGER AS $$
BEGIN
  -- Используем NOTIFY для асинхронного обновления
  PERFORM pg_notify('refresh_avatar_brain', NEW.id::TEXT);
  RETURN NULL;
END;
$$ LANGUAGE plpgsql;

-- ========================================
-- 22. АВТОМАТИЧЕСКИЙ АУДИТ (улучшенный)
-- ========================================

-- Улучшенная функция для автоматического аудита
CREATE OR REPLACE FUNCTION audit_trigger_function()
RETURNS TRIGGER AS $$
DECLARE
  v_changes JSONB;
  v_before JSONB;
  v_after JSONB;
BEGIN
  IF TG_OP = 'DELETE' THEN
    v_before := row_to_json(OLD)::JSONB;
    v_after := NULL;
  ELSIF TG_OP = 'UPDATE' THEN
    v_before := row_to_json(OLD)::JSONB;
    v_after := row_to_json(NEW)::JSONB;
  ELSIF TG_OP = 'INSERT' THEN
    v_before := NULL;
    v_after := row_to_json(NEW)::JSONB;
  END IF;
  
  v_changes := jsonb_build_object(
    'before', v_before,
    'after', v_after,
    'diff', CASE 
      WHEN TG_OP = 'UPDATE' THEN v_after - v_before
      ELSE NULL
    END
  );
  
  INSERT INTO audit_log (
    user_id,
    action,
    entity_type,
    entity_id,
    changes,
    context
  ) VALUES (
    CASE 
      WHEN TG_OP = 'DELETE' THEN (OLD.user_id)
      WHEN TG_OP = 'UPDATE' THEN (NEW.user_id)
      WHEN TG_OP = 'INSERT' THEN (NEW.user_id)
    END,
    TG_OP,
    TG_TABLE_NAME,
    CASE 
      WHEN TG_OP = 'DELETE' THEN (OLD.id)
      WHEN TG_OP = 'UPDATE' THEN (NEW.id)
      WHEN TG_OP = 'INSERT' THEN (NEW.id)
    END,
    v_changes,
    jsonb_build_object(
      'table', TG_TABLE_NAME,
      'schema', TG_TABLE_SCHEMA
    )
  );
  
  RETURN CASE WHEN TG_OP = 'DELETE' THEN OLD ELSE NEW END;
END;
$$ LANGUAGE plpgsql;

-- Применение триггера аудита к критическим таблицам
CREATE TRIGGER audit_users_trigger
  AFTER INSERT OR UPDATE OR DELETE ON users
  FOR EACH ROW
  EXECUTE FUNCTION audit_trigger_function();

CREATE TRIGGER audit_balances_trigger
  AFTER INSERT OR UPDATE OR DELETE ON balances
  FOR EACH ROW
  EXECUTE FUNCTION audit_trigger_function();

CREATE TRIGGER audit_payments_trigger
  AFTER INSERT OR UPDATE OR DELETE ON payments_v2
  FOR EACH ROW
  EXECUTE FUNCTION audit_trigger_function();

-- ========================================
-- 23. ХРАНИМЫЕ ПРОЦЕДУРЫ ДЛЯ ЧАСТЫХ ОПЕРАЦИЙ
-- ========================================

-- Функция для атомарного списания баланса (критическая операция)
CREATE OR REPLACE FUNCTION deduct_balance(
  p_user_id UUID,
  p_currency VARCHAR(20),
  p_amount NUMERIC
)
RETURNS BOOLEAN AS $$
DECLARE
  v_current_balance NUMERIC;
BEGIN
  -- Блокируем строку для атомарности
  SELECT (currencies->>p_currency)::NUMERIC INTO v_current_balance
  FROM balances
  WHERE user_id = p_user_id
  FOR UPDATE;
  
  IF v_current_balance IS NULL OR v_current_balance < p_amount THEN
    RETURN false;
  END IF;
  
  -- Атомарное обновление баланса
  UPDATE balances
  SET currencies = jsonb_set(
    currencies,
    ARRAY[p_currency],
    to_jsonb((currencies->>p_currency)::NUMERIC - p_amount)
  ),
  statistics = jsonb_set(
    COALESCE(statistics, '{}'::JSONB),
    ARRAY['total_expense'],
    to_jsonb(COALESCE((statistics->>'total_expense')::NUMERIC, 0) + p_amount)
  ),
  last_updated = NOW()
  WHERE user_id = p_user_id;
  
  RETURN true;
END;
$$ LANGUAGE plpgsql;

-- Функция для атомарного пополнения баланса
CREATE OR REPLACE FUNCTION add_balance(
  p_user_id UUID,
  p_currency VARCHAR(20),
  p_amount NUMERIC
)
RETURNS void AS $$
BEGIN
  INSERT INTO balances (user_id, currencies, statistics)
  VALUES (
    p_user_id,
    jsonb_build_object(p_currency, p_amount),
    jsonb_build_object('total_income', p_amount)
  )
  ON CONFLICT (user_id) DO UPDATE
  SET currencies = jsonb_set(
    COALESCE(balances.currencies, '{}'::JSONB),
    ARRAY[p_currency],
    to_jsonb(COALESCE((balances.currencies->>p_currency)::NUMERIC, 0) + p_amount)
  ),
  statistics = jsonb_set(
    COALESCE(balances.statistics, '{}'::JSONB),
    ARRAY['total_income'],
    to_jsonb(COALESCE((balances.statistics->>'total_income')::NUMERIC, 0) + p_amount)
  ),
  last_updated = NOW();
END;
$$ LANGUAGE plpgsql;

-- ========================================
-- 24. ПОЛНОТЕКСТОВЫЙ ПОИСК (для JSONB полей)
-- ========================================

-- Создание полнотекстового индекса для поиска по JSONB полям
CREATE INDEX idx_assets_metadata_fts ON assets
  USING GIN (to_tsvector('russian', metadata::TEXT));

CREATE INDEX idx_operations_metadata_fts ON operations
  USING GIN (to_tsvector('russian', metadata::TEXT));

-- Функция для полнотекстового поиска
CREATE OR REPLACE FUNCTION search_assets_fts(
  p_query TEXT,
  p_user_id UUID DEFAULT NULL
)
RETURNS TABLE (
  id UUID,
  user_id UUID,
  type VARCHAR(20),
  url TEXT,
  metadata JSONB,
  rank REAL
) AS $$
BEGIN
  RETURN QUERY
  SELECT 
    a.id,
    a.user_id,
    a.type,
    a.url,
    a.metadata,
    ts_rank(to_tsvector('russian', a.metadata::TEXT), plainto_tsquery('russian', p_query)) as rank
  FROM assets a
  WHERE (
    p_user_id IS NULL OR a.user_id = p_user_id
  )
  AND to_tsvector('russian', a.metadata::TEXT) @@ plainto_tsquery('russian', p_query)
  ORDER BY rank DESC
  LIMIT 100;
END;
$$ LANGUAGE plpgsql;

-- ========================================
-- 25. ЧАСТИЧНЫЕ ИНДЕКСЫ (для оптимизации)
-- ========================================

-- Индексы только для активных записей (уменьшение размера индекса)
CREATE INDEX idx_operations_active_status ON operations(status)
  WHERE status IN ('pending', 'processing');

CREATE INDEX idx_assets_not_archived ON assets(user_id, created_at DESC)
  WHERE is_archived = false;

CREATE INDEX idx_user_models_active ON user_models(user_id, model_type)
  WHERE is_active = true;

CREATE INDEX idx_subscriptions_active ON subscriptions(user_id, type)
  WHERE is_active = true AND is_enabled = true;

-- ========================================
-- 26. CONNECTION POOLING (конфигурация)
-- ========================================

-- Рекомендуемые настройки для connection pooling (pgBouncer или встроенный)
-- Эти настройки применяются на уровне приложения или через pgBouncer

-- Пример конфигурации для pgBouncer:
-- [databases]
-- neuroblogger = host=localhost port=5432 dbname=neuroblogger
-- 
-- [pgbouncer]
-- pool_mode = transaction
-- max_client_conn = 1000
-- default_pool_size = 25
-- reserve_pool_size = 5
-- reserve_pool_timeout = 3
-- max_db_connections = 100
-- max_user_connections = 100

-- ========================================
-- 27. ОПТИМИЗАЦИЯ ДЛЯ TELEGRAM BOT (специфичные улучшения)
-- ========================================

-- Индекс для быстрого поиска пользователя по Telegram ID (самый частый запрос)
CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_users_telegram_id_bot_name_lookup 
ON users(telegram_id, bot_name) 
INCLUDE (id, username, first_name, language_code, settings);

-- Индекс для быстрого получения баланса пользователя
CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_balances_user_id_lookup
ON balances(user_id)
INCLUDE (currencies, statistics, last_updated);

-- Индекс для активных сессий пользователя
CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_user_sessions_active
ON user_sessions(user_id, last_activity DESC)
WHERE expires_at IS NULL OR expires_at > NOW();

-- Функция для быстрого получения данных пользователя (оптимизированная)
CREATE OR REPLACE FUNCTION get_user_data_fast(
  p_telegram_id BIGINT,
  p_bot_name TEXT
)
RETURNS TABLE (
  user_id UUID,
  username TEXT,
  first_name TEXT,
  language_code VARCHAR(10),
  settings JSONB,
  balance JSONB,
  subscription_active BOOLEAN
) AS $$
BEGIN
  RETURN QUERY
  SELECT 
    u.id,
    u.username,
    u.first_name,
    u.language_code,
    u.settings,
    COALESCE(b.currencies, '{}'::JSONB) as balance,
    EXISTS(
      SELECT 1 FROM subscriptions s
      WHERE s.user_id = u.id
      AND s.is_active = true
      AND s.is_enabled = true
    ) as subscription_active
  FROM users u
  LEFT JOIN balances b ON b.user_id = u.id
  WHERE u.telegram_id = p_telegram_id
    AND u.bot_name = p_bot_name
  LIMIT 1;
END;
$$ LANGUAGE plpgsql STABLE;

-- ========================================
-- 28. МАСШТАБИРОВАНИЕ И РЕПЛИКАЦИЯ
-- ========================================

-- Рекомендации по настройке репликации (для production)
-- 1. Настройка streaming replication в PostgreSQL
-- 2. Использование read replicas для чтения
-- 3. Направление запросов на чтение на реплики, запись на мастер

-- Функция для определения типа запроса (read/write)
-- Используется в приложении для маршрутизации запросов
CREATE OR REPLACE FUNCTION is_read_query(p_query TEXT)
RETURNS BOOLEAN AS $$
BEGIN
  RETURN upper(trim(p_query)) LIKE 'SELECT%'
    OR upper(trim(p_query)) LIKE 'WITH%';
END;
$$ LANGUAGE plpgsql IMMUTABLE;

-- ========================================
-- 29. БЕЗОПАСНОСТЬ И ДОСТУП
-- ========================================

-- Создание ролей для разных уровней доступа
CREATE ROLE bot_app_user;
CREATE ROLE bot_readonly_user;
CREATE ROLE bot_admin_user;

-- Права для приложения (только необходимые операции)
GRANT SELECT, INSERT, UPDATE ON ALL TABLES IN SCHEMA public TO bot_app_user;
GRANT USAGE, SELECT ON ALL SEQUENCES IN SCHEMA public TO bot_app_user;
GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA public TO bot_app_user;

-- Права только для чтения (для аналитики)
GRANT SELECT ON ALL TABLES IN SCHEMA public TO bot_readonly_user;
GRANT SELECT ON ALL SEQUENCES IN SCHEMA public TO bot_readonly_user;

-- Права администратора (полный доступ)
GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA public TO bot_admin_user;
GRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA public TO bot_admin_user;
GRANT ALL PRIVILEGES ON ALL FUNCTIONS IN SCHEMA public TO bot_admin_user;

-- ========================================
-- 30. РЕКОМЕНДАЦИИ ПО ИСПОЛЬЗОВАНИЮ
-- ========================================

-- 1. Используйте connection pooling (pgBouncer) для эффективного управления соединениями
-- 2. Настройте репликацию для масштабирования чтения
-- 3. Используйте кэширование (Redis) для часто запрашиваемых данных
-- 4. Мониторьте производительность через performance_metrics
-- 5. Регулярно очищайте устаревшие данные (партиции operations, assets)
-- 6. Используйте хранимые процедуры для атомарных операций (deduct_balance, add_balance)
-- 7. Применяйте миграции через систему schema_migrations
-- 8. Используйте частичные индексы для оптимизации
-- 9. Настройте автоматическое обновление материализованных представлений
-- 10. Используйте полнотекстовый поиск для JSONB полей
```

### 📊 Итоговые улучшения модели:

#### ✅ Добавлено:

1. **Партиционирование** - для масштабирования больших таблиц
2. **Система миграций** - для версионирования схемы
3. **Кэширование** - стратегия кэширования частых запросов
4. **Мониторинг** - метрики производительности
5. **Автоматический аудит** - улучшенные триггеры
6. **Хранимые процедуры** - атомарные операции (deduct_balance, add_balance)
7. **Полнотекстовый поиск** - для JSONB полей
8. **Частичные индексы** - оптимизация производительности
9. **Connection pooling** - рекомендации по настройке
10. **Оптимизация для Telegram Bot** - специфичные индексы и функции

#### 🎯 Результат:

**Модель БД теперь готова к:**
- ✅ Масштабированию (партиционирование, репликация)
- ✅ Быстрой интеграции (оптимизированные функции)
- ✅ Мониторингу (метрики производительности)
- ✅ Безопасности (роли и права доступа)
- ✅ Эффективности (кэширование, частичные индексы)
- ✅ Отслеживанию изменений (автоматический аудит)
- ✅ Версионированию (система миграций)

**Это действительно бриллиант - максимально эффективная модель для Telegram-бота!** 💎🚀

### 🔧 Настройка Drizzle ORM

#### Инициализация Drizzle клиента:

```typescript
// src/core/drizzle/client.ts
import { drizzle } from 'drizzle-orm/postgres-js'
import postgres from 'postgres'
import * as schema from './schema'

// Lazy initialization для загрузки секретов из Infisical
let _db: ReturnType<typeof drizzle> | null = null

function getDatabaseUrl(): string {
  const url = process.env.DATABASE_URL
  if (!url) {
    throw new Error('DATABASE_URL is required but undefined. Ensure Infisical loaded secrets.')
  }
  return url
}

// Lazy-initialized Drizzle client
export const db = new Proxy({} as ReturnType<typeof drizzle>, {
  get(target, prop) {
    if (!_db) {
      const queryClient = postgres(getDatabaseUrl(), {
        ssl: { rejectUnauthorized: false },
        max: 10,
        idle_timeout: 30,
        connect_timeout: 10,
      })
      _db = drizzle(queryClient, { schema })
    }
    return (_db as any)[prop]
  }
})
```

#### Пример схемы Drizzle:

```typescript
// src/core/drizzle/schema.ts
import { pgTable, uuid, text, jsonb, timestamp, boolean, integer, bigint, varchar, inet } from 'drizzle-orm/pg-core'
import { relations } from 'drizzle-orm'

export const users = pgTable('users', {
  id: uuid('id').primaryKey().defaultRandom(),
  telegram_id: bigint('telegram_id', { mode: 'number' }).notNull(),
  bot_name: text('bot_name').notNull(),
  username: text('username'),
  first_name: text('first_name'),
  language_code: varchar('language_code', { length: 10 }).default('ru'),
  settings: jsonb('settings').notNull().default({}),
  referral: jsonb('referral').default({}),
  version: integer('version').default(1),
  created_at: timestamp('created_at', { withTimezone: true }).defaultNow(),
  updated_at: timestamp('updated_at', { withTimezone: true }).defaultNow(),
}, (table) => ({
  telegramIdBotNameIdx: uniqueIndex('users_telegram_id_bot_name_idx').on(table.telegram_id, table.bot_name),
  telegramIdIdx: index('idx_users_telegram_id').on(table.telegram_id),
  settingsGinIdx: index('idx_users_settings_gin').using('gin', table.settings),
}))

export const balances = pgTable('balances', {
  id: uuid('id').primaryKey().defaultRandom(),
  user_id: uuid('user_id').notNull().references(() => users.id, { onDelete: 'cascade' }),
  currencies: jsonb('currencies').notNull().default({}),
  statistics: jsonb('statistics').default({}),
  version: integer('version').default(1),
  last_updated: timestamp('last_updated', { withTimezone: true }).defaultNow(),
  created_at: timestamp('created_at', { withTimezone: true }).defaultNow(),
  updated_at: timestamp('updated_at', { withTimezone: true }).defaultNow(),
}, (table) => ({
  userIdIdx: index('idx_balances_user_id').on(table.user_id),
  currenciesGinIdx: index('idx_balances_currencies_gin').using('gin', table.currencies),
}))

export const agents = pgTable('agents', {
  id: uuid('id').primaryKey().defaultRandom(),
  name: varchar('name', { length: 100 }).notNull().unique(),
  slug: varchar('slug', { length: 100 }).notNull().unique(),
  port: integer('port').notNull().unique(),
  base_url: text('base_url').notNull(),
  telegram_bot_token: text('telegram_bot_token').notNull(),
  telegram_bot_name: varchar('telegram_bot_name', { length: 100 }).notNull(),
  config: jsonb('config').notNull().default({}),
  status: varchar('status', { length: 20 }).default('stopped'),
  health_status: varchar('health_status', { length: 20 }).default('unknown'),
  resources: jsonb('resources').default({}),
  api_key: text('api_key').unique(),
  created_at: timestamp('created_at', { withTimezone: true }).defaultNow(),
  updated_at: timestamp('updated_at', { withTimezone: true }).defaultNow(),
})

// Relations
export const usersRelations = relations(users, ({ one, many }) => ({
  balance: one(balances, {
    fields: [users.id],
    references: [balances.user_id],
  }),
  agents: many(agents),
}))

export const balancesRelations = relations(balances, ({ one }) => ({
  user: one(users, {
    fields: [balances.user_id],
    references: [users.id],
  }),
}))
```

### 🛠️ Практические примеры использования для быстрой интеграции

#### Пример 1: Быстрое создание пользователя (Telegram Bot)

```typescript
/**
 * Создание пользователя при первом взаимодействии с ботом
 * Использует функциональный стиль с TaskEither
 */
import { TaskEither, tryCatchAsync } from '@/core/functional/utils/result'
import { db } from '@/core/drizzle/client'
import { users, balances } from '@/core/drizzle/schema'
import { eq, and } from 'drizzle-orm'

const createUserIfNotExists = (
  telegramId: number,
  botName: string,
  userData: {
    username?: string
    first_name?: string
    last_name?: string
    language_code?: string
  }
): TaskEither<Error, UserProfile> =>
  tryCatchAsync(
    async () => {
      // Используем Drizzle ORM транзакцию для атомарности
      return await db.transaction(async (tx) => {
        // 1. Проверяем существование пользователя
        const [existingUser] = await tx
          .select()
          .from(users)
          .where(
            and(
              eq(users.telegram_id, telegramId),
              eq(users.bot_name, botName)
            )
          )
          .limit(1)
        
        if (existingUser) {
          return existingUser as UserProfile
        }
        
        // 2. Создаем нового пользователя
        const [newUser] = await tx
          .insert(users)
          .values({
            telegram_id: telegramId,
            bot_name: botName,
            username: userData.username,
            first_name: userData.first_name,
            last_name: userData.last_name,
            language_code: userData.language_code || 'ru',
            settings: {},
            referral: {},
          })
          .returning()
        
        if (!newUser) {
          throw new Error('Failed to create user')
        }
        
        // 3. Создаем баланс для нового пользователя
        await tx
          .insert(balances)
          .values({
            user_id: newUser.id,
            currencies: { stars: 0, rubles: 0, dollars: 0 },
            statistics: {},
          })
        
        return newUser as UserProfile
      })
    },
    (error) => error instanceof Error ? error : new Error(String(error))
  )

// Использование в боте
const result = await runTaskEither(
  createUserIfNotExists(
    ctx.from.id,
    'NeuroBlogger_bot',
    {
      username: ctx.from.username,
      first_name: ctx.from.first_name,
      language_code: ctx.from.language_code,
    }
  )
)

fold(
  (error: Error) => {
    logger.error('Failed to create user:', error)
    await ctx.reply('Произошла ошибка. Попробуйте позже.')
  },
  (user: UserProfile) => {
    logger.info('User created:', user.id)
    // Продолжаем работу с пользователем
  }
)(result)
```

#### Пример 2: Атомарное списание баланса (критическая операция)

```typescript
/**
 * Атомарное списание баланса через Drizzle ORM транзакцию
 * Гарантирует отсутствие race conditions
 */
import { TaskEither, tryCatchAsync } from '@/core/functional/utils/result'
import { db } from '@/core/drizzle/client'
import { balances } from '@/core/drizzle/schema'
import { eq } from 'drizzle-orm'

const deductBalanceAtomically = (
  userId: string,
  currency: 'stars' | 'rubles' | 'dollars',
  amount: number
): TaskEither<Error, boolean> =>
  tryCatchAsync(
    async () => {
      // Используем Drizzle ORM для атомарного списания баланса
      const result = await db.transaction(async (tx) => {
        // Блокируем строку для атомарности
        const balance = await tx
          .select()
          .from(balances)
          .where(eq(balances.user_id, userId))
          .for('update')
          .limit(1)
        
        if (!balance[0]) {
          throw new Error('Balance not found')
        }
        
        const currentBalance = (balance[0].currencies as any)?.[currency] || 0
        
        if (currentBalance < amount) {
          return false
        }
        
        // Атомарное обновление баланса
        const updatedCurrencies = {
          ...(balance[0].currencies as any),
          [currency]: currentBalance - amount,
        }
        
        await tx
          .update(balances)
          .set({
            currencies: updatedCurrencies,
            last_updated: new Date(),
          })
          .where(eq(balances.user_id, userId))
        
        return true
      })
      
      return result
    },
    (error) => error instanceof Error ? error : new Error(String(error))
  )

// Использование в плагине
const canAfford = await runTaskEither(
  deductBalanceAtomically(user.id, 'stars', 10)
)

fold(
  (error: Error) => {
    logger.error('Balance deduction failed:', error)
    return false
  },
  (success: boolean) => {
    if (!success) {
      await ctx.reply('Недостаточно средств на балансе')
      return false
    }
    return true
  }
)(canAfford)
```

#### Пример 3: Быстрое получение данных пользователя (оптимизированная функция)

```typescript
/**
 * Использование Drizzle ORM для быстрого получения данных
 * Использует покрывающий индекс (covering index) для максимальной скорости
 */
import { TaskEither, tryCatchAsync } from '@/core/functional/utils/result'
import { db } from '@/core/drizzle/client'
import { users, balances, subscriptions } from '@/core/drizzle/schema'
import { eq, and, sql } from 'drizzle-orm'

const getUserDataFast = (
  telegramId: number,
  botName: string
): TaskEither<Error, UserData> =>
  tryCatchAsync(
    async () => {
      // Используем Drizzle ORM для быстрого получения данных пользователя
      const [user] = await db
        .select({
          user_id: users.id,
          username: users.username,
          first_name: users.first_name,
          language_code: users.language_code,
          settings: users.settings,
          balance: balances.currencies,
          subscription_active: sql<boolean>`
            EXISTS(
              SELECT 1 FROM ${subscriptions}
              WHERE ${subscriptions.user_id} = ${users.id}
              AND ${subscriptions.is_active} = true
              AND ${subscriptions.is_enabled} = true
            )
          `,
        })
        .from(users)
        .leftJoin(balances, eq(balances.user_id, users.id))
        .where(
          and(
            eq(users.telegram_id, telegramId),
            eq(users.bot_name, botName)
          )
        )
        .limit(1)
      
      if (!user) {
        throw new Error('User not found')
      }
      
      return {
        user_id: user.user_id,
        username: user.username,
        first_name: user.first_name,
        language_code: user.language_code,
        settings: user.settings,
        balance: user.balance || {},
        subscription_active: user.subscription_active,
      } as UserData
    },
    (error) => error instanceof Error ? error : new Error(String(error))
  )

// Использование (самый частый запрос в Telegram боте)
const userData = await runTaskEither(
  getUserDataFast(ctx.from.id, 'neuro_blogger_bot')
)

fold(
  (error: Error) => {
    logger.error('Failed to get user data:', error)
    // Обработка ошибки
  },
  (data: UserData) => {
    // Используем данные пользователя
    const balance = data.balance.stars || 0
    const isSubscribed = data.subscription_active
    // ...
  }
)(userData)
```

#### Пример 4: Полнотекстовый поиск по медиа файлам

```typescript
/**
 * Поиск медиа файлов по содержимому метаданных
 * Использует полнотекстовый поиск PostgreSQL через Drizzle ORM
 */
import { TaskEither, tryCatchAsync } from '@/core/functional/utils/result'
import { db } from '@/core/drizzle/client'
import { assets } from '@/core/drizzle/schema'
import { eq, and, sql } from 'drizzle-orm'

const searchAssets = (
  query: string,
  userId?: string
): TaskEither<Error, Asset[]> =>
  tryCatchAsync(
    async () => {
      // Используем Drizzle ORM для полнотекстового поиска
      const results = await db
        .select()
        .from(assets)
        .where(
          and(
            userId ? eq(assets.user_id, userId) : undefined,
            sql`to_tsvector('russian', ${assets.metadata}::TEXT) @@ plainto_tsquery('russian', ${query})`
          )
        )
        .orderBy(sql`ts_rank(to_tsvector('russian', ${assets.metadata}::TEXT), plainto_tsquery('russian', ${query})) DESC`)
        .limit(100)
      
      return results as Asset[]
    },
    (error) => error instanceof Error ? error : new Error(String(error))
  )

// Использование
const results = await runTaskEither(
  searchAssets('портрет девушки', user.id)
)

fold(
  (error: Error) => {
    logger.error('Search failed:', error)
    return []
  },
  (assets: Asset[]) => {
    // Отображаем результаты поиска
    return assets
  }
)(results)
```

#### Пример 5: Использование кэша для частых запросов

```typescript
/**
 * Кэширование данных пользователя для снижения нагрузки на БД
 * Использует таблицу cache_entries через Drizzle ORM
 */
import { TaskEither, tryCatchAsync, fromNullable, left, right } from '@/core/functional/utils/result'
import { pipe, chain } from '@/core/functional/utils/composition'
import { db } from '@/core/drizzle/client'
import { cache_entries } from '@/core/drizzle/schema'
import { eq, and, gt, sql } from 'drizzle-orm'

const getUserDataCached = (
  telegramId: number,
  botName: string,
  cacheKey: string,
  ttlSeconds: number = 300 // 5 минут
): TaskEither<Error, UserData> =>
  pipe(
    // 1. Пытаемся получить из кэша через Drizzle ORM
    async () => {
      const [cached] = await db
        .select()
        .from(cache_entries)
        .where(
          and(
            eq(cache_entries.key, cacheKey),
            gt(cache_entries.expires_at, new Date())
          )
        )
        .limit(1)
      
      if (cached) {
        // Обновляем статистику доступа
        await db
          .update(cache_entries)
          .set({
            access_count: sql`${cache_entries.access_count} + 1`,
            last_accessed_at: new Date(),
          })
          .where(eq(cache_entries.key, cacheKey))
        
        return right(cached.value as UserData)
      }
      
      return left(new Error('Cache miss'))
    },
    chain(async (cachedResult) => {
      if (cachedResult._tag === 'Right') {
        return cachedResult
      }
      
      // 2. Если нет в кэше - получаем из БД
      return getUserDataFast(telegramId, botName)
    }),
    // 3. Сохраняем в кэш
    chain(userData => {
      const expiresAt = new Date(Date.now() + ttlSeconds * 1000)
      
      return tryCatchAsync(
        async () => {
          await db
            .insert(cache_entries)
            .values({
              key: cacheKey,
              value: userData,
              expires_at: expiresAt,
            })
            .onConflictDoUpdate({
              target: cache_entries.key,
              set: {
                value: userData,
                expires_at: expiresAt,
                updated_at: new Date(),
              },
            })
          return userData
        },
        (error) => error instanceof Error ? error : new Error(String(error))
      )
    })
  )

// Использование
const cacheKey = `user:${ctx.from.id}:${botName}`
const userData = await runTaskEither(
  getUserDataCached(ctx.from.id, botName, cacheKey, 300)
)
```

### ✅ Чек-лист для быстрой интеграции в Telegram-бота

#### 📋 Подготовка:

- [ ] **1. Создание таблиц**
  - [ ] Применить SQL скрипт создания всех таблиц
  - [ ] Проверить создание индексов
  - [ ] Проверить создание триггеров
  - [ ] Проверить создание функций

- [ ] **2. Настройка подключения**
  - [ ] Настроить connection pooling (pgBouncer или встроенный)
  - [ ] Настроить переменные окружения (SUPABASE_URL, SUPABASE_SERVICE_KEY)
  - [ ] Протестировать подключение к БД

- [ ] **3. Система миграций**
  - [ ] Создать таблицу `schema_migrations`
  - [ ] Настроить автоматическое применение миграций
  - [ ] Протестировать систему миграций

- [ ] **4. Кэширование**
  - [ ] Создать таблицу `cache_entries`
  - [ ] Настроить очистку устаревших записей (cron job)
  - [ ] Интегрировать кэширование в код бота

- [ ] **5. Мониторинг**
  - [ ] Создать таблицу `performance_metrics`
  - [ ] Настроить запись метрик в критических местах
  - [ ] Настроить дашборд для просмотра метрик

#### 🔧 Интеграция в код:

- [ ] **6. Функциональные утилиты**
  - [ ] Импортировать `TaskEither`, `pipe`, `chain` из `@/core/functional/utils/result`
  - [ ] Создать функции-обертки для всех операций с БД
  - [ ] Использовать `fold` для обработки результатов

- [ ] **7. Хранимые процедуры**
  - [ ] Использовать `deduct_balance` для списания баланса
  - [ ] Использовать `add_balance` для пополнения баланса
  - [ ] Использовать `get_user_data_fast` для получения данных пользователя

- [ ] **8. Оптимизация запросов**
  - [ ] Использовать покрывающие индексы (INCLUDE)
  - [ ] Использовать частичные индексы для активных записей
  - [ ] Использовать материализованное представление `avatar_brain_view`

- [ ] **9. Аудит и логирование**
  - [ ] Проверить работу триггеров аудита
  - [ ] Настроить мониторинг таблицы `audit_log`
  - [ ] Настроить алерты на критические изменения

- [ ] **10. Безопасность**
  - [ ] Создать роли пользователей (bot_app_user, bot_readonly_user)
  - [ ] Настроить права доступа для каждого роля
  - [ ] Использовать параметризованные запросы (защита от SQL injection)

### 🚨 Типичные проблемы и решения

#### Проблема 1: Медленные запросы к БД

**Симптомы:**
- Задержки при получении данных пользователя
- Медленная работа бота при большом количестве пользователей

**Решение:**
```sql
-- 1. Использовать покрывающие индексы
CREATE INDEX idx_users_telegram_id_bot_name_lookup 
ON users(telegram_id, bot_name) 
INCLUDE (id, username, first_name, language_code, settings);

-- 2. Использовать оптимизированные функции
SELECT * FROM get_user_data_fast(123456789, 'neuro_blogger_bot');

-- 3. Использовать кэширование
SELECT * FROM get_cached_value('user:123456789:neuro_blogger_bot');
```

#### Проблема 2: Race conditions при списании баланса

**Симптомы:**
- Отрицательный баланс
- Двойное списание средств

**Решение:**
```sql
-- Использовать атомарную функцию с блокировкой строки
SELECT deduct_balance('user-uuid', 'stars', 10);
-- Функция использует FOR UPDATE для блокировки строки
```

#### Проблема 3: Большой размер таблицы operations

**Симптомы:**
- Медленные запросы к таблице operations
- Увеличение размера БД

**Решение:**
```sql
-- Использовать партиционирование по дате
CREATE TABLE operations (...) PARTITION BY RANGE (created_at);

-- Автоматическое создание партиций
SELECT create_operations_partition('2025-02-01'::DATE);

-- Регулярная очистка старых партиций
DROP TABLE IF EXISTS operations_2024_01; -- Старые данные
```

#### Проблема 4: Медленное обновление материализованного представления

**Симптомы:**
- Блокировка таблиц при обновлении представления
- Долгое время обновления

**Решение:**
```sql
-- Использовать CONCURRENTLY для обновления без блокировки
REFRESH MATERIALIZED VIEW CONCURRENTLY avatar_brain_view;

-- Или использовать оптимизированную функцию
SELECT refresh_avatar_brain_view_safe();
```

### 📚 Рекомендации по использованию инструментов для создания таблиц

#### Вариант 1: Supabase Dashboard (Визуальный редактор)

**Преимущества:**
- ✅ Визуальный интерфейс
- ✅ Автоматическая генерация типов TypeScript
- ✅ Встроенная документация
- ✅ Легко для начинающих

**Недостатки:**
- ❌ Сложно применять миграции
- ❌ Нет версионирования схемы
- ❌ Ограниченные возможности для сложных функций

**Рекомендация:** Использовать для начальной настройки и просмотра структуры

#### Вариант 2: SQL миграции через Supabase CLI

**Преимущества:**
- ✅ Версионирование схемы
- ✅ Легко применять изменения
- ✅ Можно откатывать миграции
- ✅ Интеграция с CI/CD

**Недостатки:**
- ❌ Требует знания SQL
- ❌ Нужна настройка CLI

**Рекомендация:** Использовать для production и версионирования

**Пример использования:**
```bash
# Инициализация проекта
supabase init

# Создание новой миграции
supabase migration new create_avatar_brain_tables

# Применение миграций
supabase db push

# Откат миграции
supabase migration repair --status reverted 20250112123456
```

#### Вариант 3: Prisma (ORM с миграциями)

**Преимущества:**
- ✅ Типобезопасность на уровне TypeScript
- ✅ Автоматическая генерация типов
- ✅ Легко работать с данными
- ✅ Встроенная система миграций

**Недостатки:**
- ❌ Дополнительный слой абстракции
- ❌ Может быть медленнее прямых SQL запросов
- ❌ Ограничения для сложных функций PostgreSQL

**Рекомендация:** Использовать если нужна типобезопасность и удобство работы

**Пример схемы Prisma:**
```prisma
model User {
  id          String   @id @default(uuid())
  telegramId  BigInt   @unique
  botName     String
  username    String?
  firstName   String?
  settings    Json     @default("{}")
  referral    Json     @default("{}")
  version     Int      @default(1)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  balance     Balance?
  operations  Operation[]
  assets      Asset[]
  
  @@unique([telegramId, botName])
  @@index([telegramId, botName])
  @@index([botName])
}
```

#### Вариант 4: Прямые SQL запросы (Рекомендуется)

**Преимущества:**
- ✅ Полный контроль над структурой БД
- ✅ Использование всех возможностей PostgreSQL
- ✅ Максимальная производительность
- ✅ Гибкость в реализации функций

**Недостатки:**
- ❌ Требует глубокого знания SQL
- ❌ Нужно самостоятельно управлять миграциями

**Рекомендация:** Использовать для production (наш случай)

**Пример применения:**
```typescript
// Применение SQL миграции через Supabase
import { supabase } from '@/core/supabase/client'

// Используем Drizzle ORM для миграций (встроенная система миграций)
import { migrate } from 'drizzle-orm/postgres-js/migrator'
import { db } from '@/core/drizzle/client'

const applyMigration = async () => {
  await migrate(db, { migrationsFolder: './drizzle/migrations' })
}

// Использование
await applyMigration()

// Миграции создаются автоматически через:
// npm run drizzle:generate  # Генерирует миграции из схемы
// npm run drizzle:migrate    # Применяет миграции к БД
```

### 🎯 Итоговые рекомендации:

1. **Для создания таблиц:** Используйте SQL миграции через систему `schema_migrations`
2. **Для работы с данными:** Используйте функциональный стиль с `TaskEither`
3. **Для критических операций:** Используйте хранимые процедуры (`deduct_balance`, `add_balance`)
4. **Для оптимизации:** Используйте покрывающие индексы и материализованные представления
5. **Для масштабирования:** Используйте партиционирование и репликацию
6. **Для мониторинга:** Используйте таблицу `performance_metrics`
7. **Для кэширования:** Используйте таблицу `cache_entries` или Redis
8. **Для безопасности:** Используйте роли и права доступа

**Модель БД готова к использованию в production!** 🚀💎

### 🌍 Интернационализация (i18n) - Автоматические переводы из коробки

#### 🎯 Философия интернационализации

**Система автоматической генерации переводов** для всех элементов интерфейса:
- ✅ Автоматическое создание переводов для всех кнопок меню
- ✅ Поддержка множества языков (ru, en, es, de, fr, it, pt, zh, ja, ko, ar, hi, tr)
- ✅ Единая таблица переводов для всех ботов
- ✅ Автоматическая синхронизация с `NAVIGATION_BUTTONS`
- ✅ Fallback на английский, если перевод отсутствует
- ✅ Готово к использованию "из коробки"

#### 🗄️ Модель БД для переводов:

```sql
-- ========================================
-- 31. ПЕРЕВОДЫ (i18n) - Автоматическая генерация
-- ========================================

CREATE TABLE translations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  
  -- Ключ перевода (уникальный идентификатор)
  key TEXT NOT NULL, -- 'menu', 'digital_avatar', 'neuro_photo', 'button.digital_body', etc.
  
  -- Язык перевода (ISO 639-1 код)
  language_code VARCHAR(10) NOT NULL, -- 'ru', 'en', 'es', 'de', 'fr', 'it', 'pt', 'zh', 'ja', 'ko', 'ar', 'hi', 'tr'
  
  -- Бот (null для общих переводов, bot_name для специфичных)
  bot_name TEXT, -- NULL = общий перевод для всех ботов
  
  -- Тип перевода
  type VARCHAR(50) NOT NULL, -- 'button', 'message', 'menu', 'error', 'success', 'prompt', 'description'
  
  -- Текст перевода
  text TEXT NOT NULL,
  
  -- URL (для кнопок с ссылками)
  url TEXT,
  
  -- Кнопки (JSONB массив кнопок для сообщений)
  buttons JSONB DEFAULT '[]',
  -- Структура buttons:
  -- [
  --   { "text": "Button Text", "url": "https://...", "callback_data": "..." }
  -- ]
  
  -- Контекст перевода (для группировки)
  context JSONB DEFAULT '{}',
  -- Структура context:
  -- {
  --   "category": "ai|tools|admin|navigation|payment|video",
  --   "mode": "neuro_photo|text_to_video|...",
  --   "icon": "📸",
  --   "description": "..."
  -- }
  
  -- Метаданные
  is_active BOOLEAN DEFAULT true,
  is_auto_generated BOOLEAN DEFAULT false, -- Автоматически сгенерирован из NAVIGATION_BUTTONS
  version INTEGER DEFAULT 1,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  
  -- Уникальность: один ключ - один язык - один бот
  CONSTRAINT translations_key_language_bot_unique UNIQUE (key, language_code, bot_name)
);

-- Индексы для производительности
CREATE INDEX idx_translations_key ON translations(key);
CREATE INDEX idx_translations_language_code ON translations(language_code);
CREATE INDEX idx_translations_bot_name ON translations(bot_name);
CREATE INDEX idx_translations_type ON translations(type);
CREATE INDEX idx_translations_key_language ON translations(key, language_code);
CREATE INDEX idx_translations_is_active ON translations(is_active);
CREATE INDEX idx_translations_context_gin ON translations USING GIN (context); -- GIN индекс для JSONB поиска

-- Триггер для автоматического обновления updated_at
CREATE TRIGGER update_translations_updated_at
  BEFORE UPDATE ON translations
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

-- ========================================
-- 32. АВТОМАТИЧЕСКАЯ ГЕНЕРАЦИЯ ПЕРЕВОДОВ ДЛЯ КНОПОК МЕНЮ
-- ========================================

-- Функция для автоматического создания переводов из NAVIGATION_BUTTONS
CREATE OR REPLACE FUNCTION generate_menu_translations()
RETURNS INTEGER AS $$
DECLARE
  button_record RECORD;
  lang_code TEXT;
  translation_key TEXT;
  translation_text TEXT;
  inserted_count INTEGER := 0;
  
  -- Поддерживаемые языки (можно расширить)
  supported_languages TEXT[] := ARRAY[
    'ru', 'en', 'es', 'de', 'fr', 'it', 'pt', 'zh', 'ja', 'ko', 'ar', 'hi', 'tr'
  ];
  
  -- Переводы кнопок (из NAVIGATION_BUTTONS) - ВСЕ КНОПКИ МЕНЮ
  button_translations JSONB := '{
    "digital_body": {"ru": "🤖 Цифровое тело", "en": "🤖 Digital Body", "es": "🤖 Cuerpo Digital", "de": "🤖 Digitaler Körper", "fr": "🤖 Corps Numérique", "it": "🤖 Corpo Digitale", "pt": "🤖 Corpo Digital", "zh": "🤖 数字身体", "ja": "🤖 デジタルボディ", "ko": "🤖 디지털 바디", "ar": "🤖 الجسم الرقمي", "hi": "🤖 डिजिटल बॉडी", "tr": "🤖 Dijital Vücut"},
    "neuro_photo": {"ru": "📸 Нейрофото", "en": "📸 NeuroPhoto", "es": "📸 NeuroFoto", "de": "📸 NeuroFoto", "fr": "📸 NeuroPhoto", "it": "📸 NeuroFoto", "pt": "📸 NeuroFoto", "zh": "📸 神经照片", "ja": "📸 ニューロフォト", "ko": "📸 뉴로포토", "ar": "📸 الصورة العصبية", "hi": "📸 न्यूरोफोटो", "tr": "📸 NöroFoto"},
    "prompt_from_photo": {"ru": "🔍 Промпт из фото", "en": "🔍 Prompt from Photo", "es": "🔍 Prompt de Foto", "de": "🔍 Prompt aus Foto", "fr": "🔍 Invite depuis Photo", "it": "🔍 Prompt da Foto", "pt": "🔍 Prompt da Foto", "zh": "🔍 从照片生成提示", "ja": "🔍 写真からプロンプト", "ko": "🔍 사진에서 프롬프트", "ar": "🔍 مطالبة من الصورة", "hi": "🔍 फोटो से प्रॉम्प्ट", "tr": "🔍 Fotoğraftan İstem"},
    "avatar_brain": {"ru": "🧠 Мозг аватара", "en": "🧠 Avatar Brain", "es": "🧠 Cerebro de Avatar", "de": "🧠 Avatar-Gehirn", "fr": "🧠 Cerveau d'\''Avatar", "it": "🧠 Cervello Avatar", "pt": "🧠 Cérebro do Avatar", "zh": "🧠 头像大脑", "ja": "🧠 アバターブレイン", "ko": "🧠 아바타 브레인", "ar": "🧠 دماغ الصورة الرمزية", "hi": "🧠 अवतार मस्तिष्क", "tr": "🧠 Avatar Beyni"},
    "chat_with_avatar": {"ru": "💭 Чат с аватаром", "en": "💭 Chat with avatar", "es": "💭 Chat con avatar", "de": "💭 Chat mit Avatar", "fr": "💭 Chat avec avatar", "it": "💭 Chat con avatar", "pt": "💭 Chat com avatar", "zh": "💭 与头像聊天", "ja": "💭 アバターとチャット", "ko": "💭 아바타와 채팅", "ar": "💭 الدردشة مع الصورة الرمزية", "hi": "💭 अवतार के साथ चैट", "tr": "💭 Avatar ile Sohbet"},
    "choose_ai_model": {"ru": "🤖 Выбор модели ИИ", "en": "🤖 Choose AI Model", "es": "🤖 Elegir Modelo IA", "de": "🤖 KI-Modell wählen", "fr": "🤖 Choisir Modèle IA", "it": "🤖 Scegli Modello IA", "pt": "🤖 Escolher Modelo IA", "zh": "🤖 选择AI模型", "ja": "🤖 AIモデルを選択", "ko": "🤖 AI 모델 선택", "ar": "🤖 اختر نموذج الذكاء الاصطناعي", "hi": "🤖 AI मॉडल चुनें", "tr": "🤖 AI Modeli Seç"},
    "avatar_voice": {"ru": "🎤 Голос аватара", "en": "🎤 Avatar Voice", "es": "🎤 Voz de Avatar", "de": "🎤 Avatar-Stimme", "fr": "🎤 Voix d'\''Avatar", "it": "🎤 Voce Avatar", "pt": "🎤 Voz do Avatar", "zh": "🎤 头像声音", "ja": "🎤 アバターの声", "ko": "🎤 아바타 음성", "ar": "🎤 صوت الصورة الرمزية", "hi": "🎤 अवतार आवाज", "tr": "🎤 Avatar Sesi"},
    "text_to_voice": {"ru": "🎙️ Текст в голос", "en": "🎙️ Text to Voice", "es": "🎙️ Texto a Voz", "de": "🎙️ Text zu Stimme", "fr": "🎙️ Texte en Voix", "it": "🎙️ Testo a Voce", "pt": "🎙️ Texto para Voz", "zh": "🎙️ 文本转语音", "ja": "🎙️ テキストを音声に", "ko": "🎙️ 텍스트를 음성으로", "ar": "🎙️ نص إلى صوت", "hi": "🎙️ टेक्स्ट को आवाज में", "tr": "🎙️ Metin Sese"},
    "photo_to_video": {"ru": "🎥 Фото в видео", "en": "🎥 Photo to Video", "es": "🎥 Foto a Video", "de": "🎥 Foto zu Video", "fr": "🎥 Photo en Vidéo", "it": "🎥 Foto a Video", "pt": "🎥 Foto para Vídeo", "zh": "🎥 照片转视频", "ja": "🎥 写真を動画に", "ko": "🎥 사진을 비디오로", "ar": "🎥 صورة إلى فيديو", "hi": "🎥 फोटो को वीडियो में", "tr": "🎥 Fotoğrafı Videoya"},
    "text_to_video": {"ru": "🎥 Видео из текста", "en": "🎥 Text to Video", "es": "🎥 Texto a Video", "de": "🎥 Text zu Video", "fr": "🎥 Texte en Vidéo", "it": "🎥 Testo a Video", "pt": "🎥 Texto para Vídeo", "zh": "🎥 文本转视频", "ja": "🎥 テキストを動画に", "ko": "🎥 텍스트를 비디오로", "ar": "🎥 نص إلى فيديو", "hi": "🎥 टेक्स्ट को वीडियो में", "tr": "🎥 Metni Videoya"},
    "text_to_photo": {"ru": "🖼️ Текст в фото", "en": "🖼️ Text to Photo", "es": "🖼️ Texto a Foto", "de": "🖼️ Text zu Foto", "fr": "🖼️ Texte en Photo", "it": "🖼️ Testo a Foto", "pt": "🖼️ Texto para Foto", "zh": "🖼️ 文本转照片", "ja": "🖼️ テキストを写真に", "ko": "🖼️ 텍스트를 사진으로", "ar": "🖼️ نص إلى صورة", "hi": "🖼️ टेक्स्ट को फोटो में", "tr": "🖼️ Metni Fotoğrafa"},
    "ai_photoshop": {"ru": "🎨 ИИ Фотошоп", "en": "🎨 AI Photoshop", "es": "🎨 IA Photoshop", "de": "🎨 KI Photoshop", "fr": "🎨 IA Photoshop", "it": "🎨 IA Photoshop", "pt": "🎨 IA Photoshop", "zh": "🎨 AI Photoshop", "ja": "🎨 AI Photoshop", "ko": "🎨 AI Photoshop", "ar": "🎨 فوتوشوب بالذكاء الاصطناعي", "hi": "🎨 AI Photoshop", "tr": "🎨 AI Photoshop"},
    "upscale_photo": {"ru": "⬆️ Увеличить качество фото", "en": "⬆️ Upscale Photo Quality", "es": "⬆️ Mejorar Calidad Foto", "de": "⬆️ Fotoqualität verbessern", "fr": "⬆️ Améliorer Qualité Photo", "it": "⬆️ Migliora Qualità Foto", "pt": "⬆️ Melhorar Qualidade Foto", "zh": "⬆️ 提升照片质量", "ja": "⬆️ 写真の品質を向上", "ko": "⬆️ 사진 품질 향상", "ar": "⬆️ تحسين جودة الصورة", "hi": "⬆️ फोटो गुणवत्ता बढ़ाएं", "tr": "⬆️ Fotoğraf Kalitesini Artır"},
    "infinity_morphing": {"ru": "🌀 Infinity Морфинг", "en": "🌀 Infinity Morphing", "es": "🌀 Morphing Infinito", "de": "🌀 Unendliches Morphing", "fr": "🌀 Morphing Infini", "it": "🌀 Morphing Infinito", "pt": "🌀 Morphing Infinito", "zh": "🌀 无限变形", "ja": "🌀 無限モーフィング", "ko": "🌀 무한 모핑", "ar": "🌀 التحويل اللانهائي", "hi": "🌀 अनंत मॉर्फिंग", "tr": "🌀 Sonsuz Morflama"},
    "face_swap": {"ru": "🎭 Замена лица", "en": "🎭 Face Swap", "es": "🎭 Intercambio de Cara", "de": "🎭 Gesichtstausch", "fr": "🎭 Échange de Visage", "it": "🎭 Scambio Volto", "pt": "🎭 Troca de Rosto", "zh": "🎭 换脸", "ja": "🎭 顔の交換", "ko": "🎭 얼굴 교체", "ar": "🎭 تبديل الوجه", "hi": "🎭 चेहरा बदलें", "tr": "🎭 Yüz Değiştirme"},
    "ai_heroes": {"ru": "🦸‍♂️ ИИ Герои", "en": "🦸‍♂️ AI Heroes", "es": "🦸‍♂️ Héroes IA", "de": "🦸‍♂️ KI-Helden", "fr": "🦸‍♂️ Héros IA", "it": "🦸‍♂️ Eroi IA", "pt": "🦸‍♂️ Heróis IA", "zh": "🦸‍♂️ AI英雄", "ja": "🦸‍♂️ AIヒーロー", "ko": "🦸‍♂️ AI 히어로", "ar": "🦸‍♂️ أبطال الذكاء الاصطناعي", "hi": "🦸‍♂️ AI नायक", "tr": "🦸‍♂️ AI Kahramanlar"},
    "lip_sync": {"ru": "🎤 Синхронизация губ", "en": "🎤 Lip Sync", "es": "🎤 Sincronización Labial", "de": "🎤 Lippen-Synchronisation", "fr": "🎤 Synchronisation Labiale", "it": "🎤 Sincronizzazione Labbra", "pt": "🎤 Sincronização Labial", "zh": "🎤 唇形同步", "ja": "🎤 リップシンク", "ko": "🎤 립싱크", "ar": "🎤 مزامنة الشفاه", "hi": "🎤 होंठ सिंक", "tr": "🎤 Dudak Senkronizasyonu"},
    "competitor_monitoring": {"ru": "🔍 Мониторинг конкурентов", "en": "🔍 Competitor Monitoring", "es": "🔍 Monitoreo Competidores", "de": "🔍 Wettbewerbsüberwachung", "fr": "🔍 Surveillance Concurrents", "it": "🔍 Monitoraggio Concorrenti", "pt": "🔍 Monitoramento Concorrentes", "zh": "🔍 竞争对手监控", "ja": "🔍 競合監視", "ko": "🔍 경쟁사 모니터링", "ar": "🔍 مراقبة المنافسين", "hi": "🔍 प्रतिस्पर्धी निगरानी", "tr": "🔍 Rakiplerin İzlenmesi"},
    "ai_reels": {"ru": "🎬 ИИ Рилс", "en": "🎬 AI Reels", "es": "🎬 Reels IA", "de": "🎬 KI-Reels", "fr": "🎬 Reels IA", "it": "🎬 Reels IA", "pt": "🎬 Reels IA", "zh": "🎬 AI短片", "ja": "🎬 AIリール", "ko": "🎬 AI 릴스", "ar": "🎬 ريلز بالذكاء الاصطناعي", "hi": "🎬 AI रील्स", "tr": "🎬 AI Reels"},
    "invite_friend": {"ru": "👥 Пригласить друга", "en": "👥 Invite a friend", "es": "👥 Invitar amigo", "de": "👥 Freund einladen", "fr": "👥 Inviter un ami", "it": "👥 Invita amico", "pt": "👥 Convidar amigo", "zh": "👥 邀请朋友", "ja": "👥 友達を招待", "ko": "👥 친구 초대", "ar": "👥 دعوة صديق", "hi": "👥 दोस्त को आमंत्रित करें", "tr": "👥 Arkadaş Davet Et"},
    "tech_support": {"ru": "💬 Техподдержка", "en": "💬 Tech Support", "es": "💬 Soporte Técnico", "de": "💬 Technischer Support", "fr": "💬 Support Technique", "it": "💬 Supporto Tecnico", "pt": "💬 Suporte Técnico", "zh": "💬 技术支持", "ja": "💬 テクニカルサポート", "ko": "💬 기술 지원", "ar": "💬 الدعم الفني", "hi": "💬 तकनीकी सहायता", "tr": "💬 Teknik Destek"},
    "language": {"ru": "🌐 EN", "en": "🌐 RU", "es": "🌐 EN", "de": "🌐 EN", "fr": "🌐 EN", "it": "🌐 EN", "pt": "🌐 EN", "zh": "🌐 EN", "ja": "🌐 EN", "ko": "🌐 EN", "ar": "🌐 EN", "hi": "🌐 EN", "tr": "🌐 EN"},
    "subscribe": {"ru": "💫 Оформить подписку", "en": "💫 Subscribe", "es": "💫 Suscribirse", "de": "💫 Abonnieren", "fr": "💫 S'\''abonner", "it": "💫 Iscriviti", "pt": "💫 Assinar", "zh": "💫 订阅", "ja": "💫 購読する", "ko": "💫 구독", "ar": "💫 الاشتراك", "hi": "💫 सदस्यता लें", "tr": "💫 Abone Ol"},
    "top_up_balance": {"ru": "💎 Пополнить баланс", "en": "💎 Top up balance", "es": "💎 Recargar saldo", "de": "💎 Guthaben aufladen", "fr": "💎 Recharger solde", "it": "💎 Ricarica saldo", "pt": "💎 Recarregar saldo", "zh": "💎 充值余额", "ja": "💎 残高をチャージ", "ko": "💎 잔액 충전", "ar": "💎 شحن الرصيد", "hi": "💎 बैलेंस टॉप अप", "tr": "💎 Bakiye Yükle"},
    "balance": {"ru": "💰 Баланс", "en": "💰 Balance", "es": "💰 Saldo", "de": "💰 Guthaben", "fr": "💰 Solde", "it": "💰 Saldo", "pt": "💰 Saldo", "zh": "💰 余额", "ja": "💰 残高", "ko": "💰 잔액", "ar": "💰 الرصيد", "hi": "💰 बैलेंस", "tr": "💰 Bakiye"}
  }'::JSONB;
BEGIN
  -- Генерируем переводы для каждой кнопки и каждого языка
  FOR button_record IN 
    SELECT key, translations FROM jsonb_each(button_translations)
  LOOP
    translation_key := 'button.' || button_record.key;
    
    -- Создаем переводы для каждого языка
    FOREACH lang_code IN ARRAY supported_languages
    LOOP
      translation_text := button_record.translations->>lang_code;
      
      -- Если перевода нет, используем английский как fallback
      IF translation_text IS NULL THEN
        translation_text := button_record.translations->>'en';
      END IF;
      
      -- Вставляем перевод (ON CONFLICT для обновления существующих)
      INSERT INTO translations (
        key,
        language_code,
        bot_name,
        type,
        text,
        context,
        is_auto_generated
      ) VALUES (
        translation_key,
        lang_code,
        NULL, -- Общий перевод для всех ботов
        'button',
        translation_text,
        jsonb_build_object('source', 'navigation_buttons'),
        true
      )
      ON CONFLICT (key, language_code, bot_name) 
      DO UPDATE SET
        text = EXCLUDED.text,
        updated_at = NOW(),
        version = translations.version + 1;
      
      inserted_count := inserted_count + 1;
    END LOOP;
  END LOOP;
  
  RETURN inserted_count;
END;
$$ LANGUAGE plpgsql;

-- Функция для получения перевода с fallback
CREATE OR REPLACE FUNCTION get_translation(
  p_key TEXT,
  p_language_code VARCHAR(10),
  p_bot_name TEXT DEFAULT NULL
)
RETURNS TABLE (
  text TEXT,
  url TEXT,
  buttons JSONB,
  language_code VARCHAR(10)
) AS $$
DECLARE
  v_translation RECORD;
BEGIN
  -- 1. Пытаемся найти перевод для конкретного бота
  IF p_bot_name IS NOT NULL THEN
    SELECT t.text, t.url, t.buttons, t.language_code INTO v_translation
    FROM translations t
    WHERE t.key = p_key
      AND t.language_code = p_language_code
      AND t.bot_name = p_bot_name
      AND t.is_active = true
    LIMIT 1;
    
    IF FOUND THEN
      RETURN QUERY SELECT v_translation.text, v_translation.url, v_translation.buttons, v_translation.language_code;
      RETURN;
    END IF;
  END IF;
  
  -- 2. Пытаемся найти общий перевод (bot_name = NULL)
  SELECT t.text, t.url, t.buttons, t.language_code INTO v_translation
  FROM translations t
  WHERE t.key = p_key
    AND t.language_code = p_language_code
    AND t.bot_name IS NULL
    AND t.is_active = true
  LIMIT 1;
  
  IF FOUND THEN
    RETURN QUERY SELECT v_translation.text, v_translation.url, v_translation.buttons, v_translation.language_code;
    RETURN;
  END IF;
  
  -- 3. Fallback на английский для конкретного бота
  IF p_bot_name IS NOT NULL THEN
    SELECT t.text, t.url, t.buttons, t.language_code INTO v_translation
    FROM translations t
    WHERE t.key = p_key
      AND t.language_code = 'en'
      AND t.bot_name = p_bot_name
      AND t.is_active = true
    LIMIT 1;
    
    IF FOUND THEN
      RETURN QUERY SELECT v_translation.text, v_translation.url, v_translation.buttons, v_translation.language_code;
      RETURN;
    END IF;
  END IF;
  
  -- 4. Fallback на английский общий
  SELECT t.text, t.url, t.buttons, t.language_code INTO v_translation
  FROM translations t
  WHERE t.key = p_key
    AND t.language_code = 'en'
    AND t.bot_name IS NULL
    AND t.is_active = true
  LIMIT 1;
  
  IF FOUND THEN
    RETURN QUERY SELECT v_translation.text, v_translation.url, v_translation.buttons, v_translation.language_code;
    RETURN;
  END IF;
  
  -- 5. Если ничего не найдено - возвращаем пустой результат
  RETURN QUERY SELECT NULL::TEXT, NULL::TEXT, '[]'::JSONB, p_language_code::VARCHAR(10);
END;
$$ LANGUAGE plpgsql STABLE;

-- Функция для массового получения переводов (для меню)
CREATE OR REPLACE FUNCTION get_translations_batch(
  p_keys TEXT[],
  p_language_code VARCHAR(10),
  p_bot_name TEXT DEFAULT NULL
)
RETURNS TABLE (
  key TEXT,
  text TEXT,
  url TEXT,
  buttons JSONB
) AS $$
BEGIN
  RETURN QUERY
  SELECT 
    t.key,
    t.text,
    t.url,
    t.buttons
  FROM translations t
  WHERE t.key = ANY(p_keys)
    AND t.language_code = p_language_code
    AND (t.bot_name = p_bot_name OR (p_bot_name IS NULL AND t.bot_name IS NULL))
    AND t.is_active = true
  ORDER BY t.key;
END;
$$ LANGUAGE plpgsql STABLE;

-- ========================================
-- 33. АВТОМАТИЧЕСКОЕ СОЗДАНИЕ ПЕРЕВОДОВ ПРИ ДОБАВЛЕНИИ НОВОЙ КНОПКИ
-- ========================================

-- Функция для добавления новой кнопки с автоматической генерацией переводов
CREATE OR REPLACE FUNCTION add_navigation_button_translation(
  p_key TEXT,
  p_translations JSONB, -- { "ru": "...", "en": "...", "es": "...", ... }
  p_bot_name TEXT DEFAULT NULL,
  p_type VARCHAR(50) DEFAULT 'button',
  p_context JSONB DEFAULT '{}'
)
RETURNS INTEGER AS $$
DECLARE
  lang_code TEXT;
  translation_text TEXT;
  inserted_count INTEGER := 0;
BEGIN
  -- Создаем переводы для каждого языка из JSONB
  FOR lang_code, translation_text IN SELECT * FROM jsonb_each_text(p_translations)
  LOOP
    INSERT INTO translations (
      key,
      language_code,
      bot_name,
      type,
      text,
      context,
      is_auto_generated
    ) VALUES (
      'button.' || p_key,
      lang_code,
      p_bot_name,
      p_type,
      translation_text,
      p_context,
      true
    )
    ON CONFLICT (key, language_code, bot_name) 
    DO UPDATE SET
      text = EXCLUDED.text,
      updated_at = NOW(),
      version = translations.version + 1;
    
    inserted_count := inserted_count + 1;
  END LOOP;
  
  RETURN inserted_count;
END;
$$ LANGUAGE plpgsql;

-- ========================================
-- 34. ИНИЦИАЛИЗАЦИЯ ПЕРЕВОДОВ (выполнить один раз)
-- ========================================

-- Выполнить для автоматического создания всех переводов кнопок меню
-- SELECT generate_menu_translations();

-- Пример добавления новой кнопки с переводами:
-- SELECT add_navigation_button_translation(
--   'new_feature',
--   '{
--     "ru": "✨ Новая функция",
--     "en": "✨ New Feature",
--     "es": "✨ Nueva Función",
--     "de": "✨ Neue Funktion",
--     "fr": "✨ Nouvelle Fonction",
--     "it": "✨ Nuova Funzione",
--     "pt": "✨ Nova Funcionalidade",
--     "zh": "✨ 新功能",
--     "ja": "✨ 新機能",
--     "ko": "✨ 새 기능",
--     "ar": "✨ ميزة جديدة",
--     "hi": "✨ नई सुविधा",
--     "tr": "✨ Yeni Özellik"
--   }'::JSONB,
--   NULL, -- Общий перевод для всех ботов
--   'button',
--   '{"category": "ai", "icon": "✨"}'::JSONB
-- );
```

### 🚀 Использование в коде (Функциональный стиль)

```typescript
/**
 * Получение перевода с fallback через Drizzle ORM (функциональный стиль)
 */
import { TaskEither, tryCatchAsync } from '@/core/functional/utils/result'
import { pipe, chain, map } from '@/core/functional/utils/composition'
import { db } from '@/core/drizzle/client'
import { translations } from '@/core/drizzle/schema'
import { eq, and, sql } from 'drizzle-orm'

const getTranslationTask = (
  key: string,
  languageCode: string,
  botName?: string
): TaskEither<Error, Translation> =>
  tryCatchAsync(
    async () => {
      // Используем Drizzle ORM для получения перевода с fallback
      // 1. Пытаемся найти для конкретного бота
      if (botName) {
        const [translation] = await db
          .select()
          .from(translations)
          .where(
            and(
              eq(translations.key, key),
              eq(translations.language_code, languageCode),
              eq(translations.bot_name, botName),
              eq(translations.is_active, true)
            )
          )
          .limit(1)
        
        if (translation) {
          return translation as Translation
        }
      }
      
      // 2. Пытаемся найти общий перевод
      const [translation] = await db
        .select()
        .from(translations)
        .where(
          and(
            eq(translations.key, key),
            eq(translations.language_code, languageCode),
            sql`${translations.bot_name} IS NULL`,
            eq(translations.is_active, true)
          )
        )
        .limit(1)
      
      if (translation) {
        return translation as Translation
      }
      
      // 3. Fallback на английский
      const [enTranslation] = await db
        .select()
        .from(translations)
        .where(
          and(
            eq(translations.key, key),
            eq(translations.language_code, 'en'),
            sql`${translations.bot_name} IS NULL`,
            eq(translations.is_active, true)
          )
        )
        .limit(1)
      
      if (enTranslation) {
        return enTranslation as Translation
      }
      
      throw new Error(`Translation not found for key: ${key}`)
    },
    (error) => error instanceof Error ? error : new Error(String(error))
  )

// Использование в боте
const translation = await runTaskEither(
  getTranslationTask('button.neuro_photo', userLanguage, botName)
)

fold(
  (error: Error) => {
    logger.error('Translation failed:', error)
    return 'NeuroPhoto' // Fallback на английский
  },
  (t: Translation) => t.text
)(translation)
```

### 📋 Чек-лист для интернационализации:

- [ ] **1. Создание таблицы translations**
  - [ ] Применить SQL скрипт создания таблицы
  - [ ] Проверить создание индексов
  - [ ] Проверить создание функций

- [ ] **2. Инициализация переводов**
  - [ ] Выполнить `SELECT generate_menu_translations();`
  - [ ] Проверить создание переводов для всех кнопок
  - [ ] Проверить переводы для всех языков

- [ ] **3. Интеграция в код**
  - [ ] Заменить хардкод текстов на вызовы `get_translation()`
  - [ ] Использовать `get_translations_batch()` для меню
  - [ ] Добавить fallback на английский

- [ ] **4. Добавление новых языков**
  - [ ] Добавить переводы в `button_translations` JSONB
  - [ ] Выполнить `generate_menu_translations()` снова
  - [ ] Проверить отображение на новом языке

- [ ] **5. Добавление новых кнопок**
  - [ ] Использовать `add_navigation_button_translation()`
  - [ ] Добавить переводы для всех языков
  - [ ] Проверить отображение в меню

### 🎯 Результат:

**Система интернационализации готова "из коробки":**
- ✅ Автоматическая генерация переводов для всех кнопок меню
- ✅ Поддержка 13 языков (ru, en, es, de, fr, it, pt, zh, ja, ko, ar, hi, tr)
- ✅ Fallback на английский, если перевод отсутствует
- ✅ Единая таблица для всех ботов
- ✅ Автоматическая синхронизация с `NAVIGATION_BUTTONS`
- ✅ Готово к использованию в production

**Международный проект готов с первого дня!** 🌍🚀

### 🤖 Ферма агентов - Мульти-агентная архитектура с управлением портами

#### 🎯 Философия мульти-агентной архитектуры

**Система для создания и управления множеством агентов на базе единого SDK:**
- ✅ Каждый агент имеет свой уникальный порт
- ✅ Динамическое назначение портов при создании агента
- ✅ Webhooks и routes для каждого агента
- ✅ Единый SDK для всех агентов
- ✅ Автоматическая маршрутизация запросов
- ✅ Масштабируемость и изоляция агентов

#### 🗄️ Модель БД для агентов:

```sql
-- ========================================
-- 35. АГЕНТЫ (Мульти-агентная архитектура)
-- ========================================

CREATE TABLE agents (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  
  -- Идентификация агента
  name VARCHAR(100) UNIQUE NOT NULL, -- Уникальное имя агента
  slug VARCHAR(100) UNIQUE NOT NULL, -- URL-friendly имя (agent-1, agent-2)
  
  -- Конфигурация портов и маршрутизации
  port INTEGER UNIQUE NOT NULL, -- Уникальный порт для агента (3000-3999)
  base_url TEXT NOT NULL, -- Базовый URL агента (https://api.example.com/agent-1)
  webhook_path VARCHAR(200) DEFAULT '/webhook', -- Путь для webhooks
  routes_path VARCHAR(200) DEFAULT '/routes', -- Путь для routes
  
  -- Telegram Bot конфигурация
  telegram_bot_token TEXT NOT NULL, -- Токен Telegram бота
  telegram_bot_name VARCHAR(100) NOT NULL, -- Имя бота (neuro_blogger_bot, MetaMuse_Manifest_bot, и т.д.)
  
  -- Конфигурация агента (ElizaOS plugin config)
  config JSONB NOT NULL DEFAULT '{}',
  -- Структура config:
  -- {
  --   "model": "minimax/minimax-m2",
  --   "temperature": 0.7,
  --   "max_tokens": 2000,
  --   "plugins": ["neuro_photo", "text_to_video"],
  --   "webhooks": {
  --     "enabled": true,
  --     "secret": "webhook_secret",
  --     "events": ["message", "command", "webhook"]
  --   },
  --   "routes": {
  --     "enabled": true,
  --     "middleware": ["auth", "rate_limit"],
  --     "endpoints": ["/health", "/status", "/metrics"]
  --   }
  -- }
  
  -- Состояние агента
  status VARCHAR(20) DEFAULT 'stopped', -- 'running', 'stopped', 'error', 'starting', 'stopping'
  health_status VARCHAR(20) DEFAULT 'unknown', -- 'healthy', 'unhealthy', 'degraded', 'unknown'
  last_health_check TIMESTAMP WITH TIME ZONE,
  
  -- Ресурсы и метрики
  resources JSONB DEFAULT '{}',
  -- Структура resources:
  -- {
  --   "cpu_usage": 0.5,
  --   "memory_usage": 1024, -- MB
  --   "disk_usage": 512, -- MB
  --   "network_io": {"in": 1000, "out": 2000}, -- bytes
  --   "active_connections": 10,
  --   "requests_per_minute": 50
  -- }
  
  -- Метаданные
  version VARCHAR(50) DEFAULT '1.0.0',
  description TEXT,
  tags TEXT[], -- Массив тегов для группировки агентов
  owner_id UUID REFERENCES users(id) ON DELETE SET NULL, -- Владелец агента
  
  -- Логирование и мониторинг
  log_level VARCHAR(20) DEFAULT 'info', -- 'debug', 'info', 'warn', 'error'
  log_path TEXT, -- Путь к логам агента
  
  -- Безопасность
  api_key TEXT UNIQUE, -- API ключ для доступа к агенту
  allowed_ips INET[], -- Разрешенные IP адреса (NULL = все)
  rate_limit JSONB DEFAULT '{}',
  -- Структура rate_limit:
  -- {
  --   "enabled": true,
  --   "requests_per_minute": 60,
  --   "requests_per_hour": 1000,
  --   "burst": 10
  -- }
  
  -- Временные метки
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  started_at TIMESTAMP WITH TIME ZONE,
  stopped_at TIMESTAMP WITH TIME ZONE,
  
  -- Ограничения
  CONSTRAINT agents_port_range CHECK (port >= 3000 AND port <= 3999),
  CONSTRAINT agents_status_valid CHECK (status IN ('running', 'stopped', 'error', 'starting', 'stopping')),
  CONSTRAINT agents_health_status_valid CHECK (health_status IN ('healthy', 'unhealthy', 'degraded', 'unknown'))
);

-- Индексы для производительности
CREATE INDEX idx_agents_name ON agents(name);
CREATE INDEX idx_agents_slug ON agents(slug);
CREATE INDEX idx_agents_port ON agents(port);
CREATE INDEX idx_agents_status ON agents(status);
CREATE INDEX idx_agents_health_status ON agents(health_status);
CREATE INDEX idx_agents_owner_id ON agents(owner_id);
CREATE INDEX idx_agents_created_at ON agents(created_at DESC);
CREATE INDEX idx_agents_config_gin ON agents USING GIN (config); -- GIN индекс для JSONB поиска
CREATE INDEX idx_agents_tags ON agents USING GIN (tags); -- GIN индекс для массива тегов

-- Триггер для автоматического обновления updated_at
CREATE TRIGGER update_agents_updated_at
  BEFORE UPDATE ON agents
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

-- ========================================
-- 36. WEBHOOKS АГЕНТОВ (ElizaOS webhooks)
-- ========================================

CREATE TABLE agent_webhooks (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  agent_id UUID NOT NULL REFERENCES agents(id) ON DELETE CASCADE,
  
  -- Идентификация webhook
  name VARCHAR(100) NOT NULL, -- Имя webhook (message, command, event)
  path VARCHAR(200) NOT NULL, -- Путь webhook (/webhook/message, /webhook/command)
  method VARCHAR(10) DEFAULT 'POST', -- HTTP метод (GET, POST, PUT, DELETE)
  
  -- Конфигурация webhook
  config JSONB DEFAULT '{}',
  -- Структура config:
  -- {
  --   "secret": "webhook_secret",
  --   "events": ["message", "command"],
  --   "headers": {"X-Custom-Header": "value"},
  --   "timeout": 5000, -- ms
  --   "retry": {
  --     "enabled": true,
  --     "max_attempts": 3,
  --     "backoff": "exponential"
  --   }
  -- }
  
  -- Обработчик webhook
  handler_type VARCHAR(50) DEFAULT 'plugin', -- 'plugin', 'function', 'url'
  handler_config JSONB DEFAULT '{}',
  -- Структура handler_config:
  -- {
  --   "plugin": "neuro_photo",
  --   "function": "handleWebhook",
  --   "url": "https://external-service.com/webhook"
  -- }
  
  -- Статистика
  request_count INTEGER DEFAULT 0,
  success_count INTEGER DEFAULT 0,
  error_count INTEGER DEFAULT 0,
  last_request_at TIMESTAMP WITH TIME ZONE,
  last_success_at TIMESTAMP WITH TIME ZONE,
  last_error_at TIMESTAMP WITH TIME ZONE,
  
  -- Состояние
  is_active BOOLEAN DEFAULT true,
  is_enabled BOOLEAN DEFAULT true,
  
  -- Временные метки
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  
  -- Уникальность: один путь - один агент
  CONSTRAINT agent_webhooks_agent_path_unique UNIQUE (agent_id, path, method)
);

CREATE INDEX idx_agent_webhooks_agent_id ON agent_webhooks(agent_id);
CREATE INDEX idx_agent_webhooks_path ON agent_webhooks(path);
CREATE INDEX idx_agent_webhooks_is_active ON agent_webhooks(is_active);
CREATE INDEX idx_agent_webhooks_config_gin ON agent_webhooks USING GIN (config);

-- ========================================
-- 37. ROUTES АГЕНТОВ (ElizaOS routes)
-- ========================================

CREATE TABLE agent_routes (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  agent_id UUID NOT NULL REFERENCES agents(id) ON DELETE CASCADE,
  
  -- Идентификация route
  name VARCHAR(100) NOT NULL, -- Имя route (health, status, metrics)
  path VARCHAR(200) NOT NULL, -- Путь route (/health, /status, /metrics)
  method VARCHAR(10) DEFAULT 'GET', -- HTTP метод
  
  -- Конфигурация route
  config JSONB DEFAULT '{}',
  -- Структура config:
  -- {
  --   "middleware": ["auth", "rate_limit", "cors"],
  --   "auth": {
  --     "required": true,
  --     "type": "api_key|bearer|basic"
  --   },
  --   "cors": {
  --     "enabled": true,
  --     "origins": ["https://example.com"]
  --   },
  --   "cache": {
  --     "enabled": true,
  --     "ttl": 60 -- seconds
  --   }
  -- }
  
  -- Обработчик route
  handler_type VARCHAR(50) DEFAULT 'function', -- 'function', 'plugin', 'url'
  handler_config JSONB DEFAULT '{}',
  -- Структура handler_config:
  -- {
  --   "function": "getHealthStatus",
  --   "plugin": "monitoring",
  --   "url": "https://external-service.com/api"
  -- }
  
  -- Документация
  description TEXT,
  parameters JSONB DEFAULT '[]', -- Параметры route
  response_schema JSONB DEFAULT '{}', -- Схема ответа
  
  -- Статистика
  request_count INTEGER DEFAULT 0,
  success_count INTEGER DEFAULT 0,
  error_count INTEGER DEFAULT 0,
  avg_response_time_ms INTEGER,
  last_request_at TIMESTAMP WITH TIME ZONE,
  
  -- Состояние
  is_active BOOLEAN DEFAULT true,
  is_enabled BOOLEAN DEFAULT true,
  
  -- Временные метки
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  
  -- Уникальность: один путь - один метод - один агент
  CONSTRAINT agent_routes_agent_path_method_unique UNIQUE (agent_id, path, method)
);

CREATE INDEX idx_agent_routes_agent_id ON agent_routes(agent_id);
CREATE INDEX idx_agent_routes_path ON agent_routes(path);
CREATE INDEX idx_agent_routes_is_active ON agent_routes(is_active);
CREATE INDEX idx_agent_routes_config_gin ON agent_routes USING GIN (config);

-- ========================================
-- 38. УПРАВЛЕНИЕ ПОРТАМИ (Динамическое назначение)
-- ========================================

-- Функция для поиска свободного порта
CREATE OR REPLACE FUNCTION find_free_port(
  p_start_port INTEGER DEFAULT 3000,
  p_end_port INTEGER DEFAULT 3999
)
RETURNS INTEGER AS $$
DECLARE
  v_port INTEGER;
  v_used_port INTEGER;
BEGIN
  -- Ищем свободный порт в диапазоне
  FOR v_port IN p_start_port..p_end_port
  LOOP
    -- Проверяем, не используется ли порт
    SELECT port INTO v_used_port
    FROM agents
    WHERE port = v_port
    LIMIT 1;
    
    IF v_used_port IS NULL THEN
      RETURN v_port;
    END IF;
  END LOOP;
  
  -- Если свободный порт не найден
  RAISE EXCEPTION 'No free port available in range %-%', p_start_port, p_end_port;
END;
$$ LANGUAGE plpgsql;

-- Функция для создания нового агента с автоматическим назначением порта
CREATE OR REPLACE FUNCTION create_agent(
  p_name VARCHAR(100),
  p_telegram_bot_token TEXT,
  p_telegram_bot_name VARCHAR(100),
  p_config JSONB DEFAULT '{}',
  p_description TEXT DEFAULT NULL,
  p_tags TEXT[] DEFAULT ARRAY[]::TEXT[],
  p_owner_id UUID DEFAULT NULL
)
RETURNS UUID AS $$
DECLARE
  v_agent_id UUID;
  v_port INTEGER;
  v_slug VARCHAR(100);
  v_base_url TEXT;
  v_api_key TEXT;
BEGIN
  -- Генерируем slug из имени
  v_slug := lower(regexp_replace(p_name, '[^a-zA-Z0-9]+', '-', 'g'));
  
  -- Находим свободный порт
  v_port := find_free_port();
  
  -- Генерируем базовый URL (можно настроить через переменную окружения)
  v_base_url := 'http://localhost:' || v_port;
  
  -- Генерируем API ключ
  v_api_key := encode(gen_random_bytes(32), 'hex');
  
  -- Создаем агента
  INSERT INTO agents (
    name,
    slug,
    port,
    base_url,
    telegram_bot_token,
    telegram_bot_name,
    config,
    description,
    tags,
    owner_id,
    api_key,
    status
  ) VALUES (
    p_name,
    v_slug,
    v_port,
    v_base_url,
    p_telegram_bot_token,
    p_telegram_bot_name,
    p_config,
    p_description,
    p_tags,
    p_owner_id,
    v_api_key,
    'stopped'
  )
  RETURNING id INTO v_agent_id;
  
  -- Создаем стандартные routes для агента
  INSERT INTO agent_routes (agent_id, name, path, method, handler_type, handler_config, description)
  VALUES
    (v_agent_id, 'health', '/health', 'GET', 'function', '{"function": "getHealthStatus"}'::JSONB, 'Health check endpoint'),
    (v_agent_id, 'status', '/status', 'GET', 'function', '{"function": "getAgentStatus"}'::JSONB, 'Agent status endpoint'),
    (v_agent_id, 'metrics', '/metrics', 'GET', 'function', '{"function": "getAgentMetrics"}'::JSONB, 'Agent metrics endpoint');
  
  -- Создаем стандартный webhook для агента
  INSERT INTO agent_webhooks (agent_id, name, path, method, handler_type, handler_config)
  VALUES (
    v_agent_id,
    'default',
    '/webhook',
    'POST',
    'plugin',
    '{"plugin": "default"}'::JSONB
  );
  
  RETURN v_agent_id;
END;
$$ LANGUAGE plpgsql;

-- Функция для получения конфигурации агента для запуска
CREATE OR REPLACE FUNCTION get_agent_startup_config(p_agent_id UUID)
RETURNS TABLE (
  id UUID,
  name VARCHAR(100),
  slug VARCHAR(100),
  port INTEGER,
  base_url TEXT,
  telegram_bot_token TEXT,
  telegram_bot_name VARCHAR(100),
  config JSONB,
  webhooks JSONB,
  routes JSONB,
  api_key TEXT
) AS $$
BEGIN
  RETURN QUERY
  SELECT 
    a.id,
    a.name,
    a.slug,
    a.port,
    a.base_url,
    a.telegram_bot_token,
    a.telegram_bot_name,
    a.config,
    (
      SELECT jsonb_agg(
        jsonb_build_object(
          'name', w.name,
          'path', w.path,
          'method', w.method,
          'config', w.config,
          'handler_type', w.handler_type,
          'handler_config', w.handler_config
        )
      )
      FROM agent_webhooks w
      WHERE w.agent_id = a.id AND w.is_active = true
    ) as webhooks,
    (
      SELECT jsonb_agg(
        jsonb_build_object(
          'name', r.name,
          'path', r.path,
          'method', r.method,
          'config', r.config,
          'handler_type', r.handler_type,
          'handler_config', r.handler_config
        )
      )
      FROM agent_routes r
      WHERE r.agent_id = a.id AND r.is_active = true
    ) as routes,
    a.api_key
  FROM agents a
  WHERE a.id = p_agent_id;
END;
$$ LANGUAGE plpgsql STABLE;

-- ========================================
-- 39. МАРШРУТИЗАЦИЯ ЗАПРОСОВ (Reverse Proxy)
-- ========================================

-- Функция для получения маршрута агента по пути
CREATE OR REPLACE FUNCTION get_agent_route(
  p_path TEXT,
  p_method VARCHAR(10) DEFAULT 'GET'
)
RETURNS TABLE (
  agent_id UUID,
  agent_slug VARCHAR(100),
  agent_port INTEGER,
  route_path VARCHAR(200),
  route_method VARCHAR(10),
  route_config JSONB,
  handler_type VARCHAR(50),
  handler_config JSONB
) AS $$
BEGIN
  RETURN QUERY
  SELECT 
    a.id,
    a.slug,
    a.port,
    r.path,
    r.method,
    r.config,
    r.handler_type,
    r.handler_config
  FROM agents a
  INNER JOIN agent_routes r ON r.agent_id = a.id
  WHERE a.status = 'running'
    AND r.is_active = true
    AND r.is_enabled = true
    AND (
      -- Точное совпадение пути
      r.path = p_path
      OR
      -- Совпадение с параметрами (/agent/:id -> /agent/123)
      r.path ~ ('^' || regexp_replace(r.path, ':[^/]+', '[^/]+', 'g') || '$')
    )
    AND r.method = p_method
  ORDER BY 
    -- Приоритет: точное совпадение > совпадение с параметрами
    CASE WHEN r.path = p_path THEN 0 ELSE 1 END,
    a.created_at DESC
  LIMIT 1;
END;
$$ LANGUAGE plpgsql STABLE;

-- ========================================
-- 40. МОНИТОРИНГ АГЕНТОВ
-- ========================================

-- Представление для мониторинга состояния всех агентов
CREATE VIEW agents_monitoring AS
SELECT 
  a.id,
  a.name,
  a.slug,
  a.port,
  a.status,
  a.health_status,
  a.last_health_check,
  a.resources->>'cpu_usage' as cpu_usage,
  a.resources->>'memory_usage' as memory_usage,
  a.resources->>'active_connections' as active_connections,
  COUNT(DISTINCT w.id) as webhook_count,
  COUNT(DISTINCT r.id) as route_count,
  SUM(r.request_count) as total_requests,
  SUM(r.success_count) as total_success,
  SUM(r.error_count) as total_errors,
  AVG(r.avg_response_time_ms) as avg_response_time_ms
FROM agents a
LEFT JOIN agent_webhooks w ON w.agent_id = a.id AND w.is_active = true
LEFT JOIN agent_routes r ON r.agent_id = a.id AND r.is_active = true
GROUP BY a.id, a.name, a.slug, a.port, a.status, a.health_status, a.last_health_check, a.resources;

-- Функция для обновления метрик агента
CREATE OR REPLACE FUNCTION update_agent_metrics(
  p_agent_id UUID,
  p_resources JSONB,
  p_health_status VARCHAR(20) DEFAULT NULL
)
RETURNS void AS $$
BEGIN
  UPDATE agents
  SET 
    resources = p_resources,
    health_status = COALESCE(p_health_status, health_status),
    last_health_check = NOW()
  WHERE id = p_agent_id;
END;
$$ LANGUAGE plpgsql;
```

### 🚀 Использование в коде (Создание агента)

```typescript
/**
 * Создание нового агента с автоматическим назначением порта через Drizzle ORM
 */
import { TaskEither, tryCatchAsync } from '@/core/functional/utils/result'
import { pipe, chain, map } from '@/core/functional/utils/composition'
import { db } from '@/core/drizzle/client'
import { agents, agent_routes, agent_webhooks } from '@/core/drizzle/schema'
import { eq, and, sql } from 'drizzle-orm'
import { findFreePort, createDefaultRoutes, createDefaultWebhooks, generateApiKey } from '@/core/agents/utils'

const createAgentTask = (
  name: string,
  telegramBotToken: string,
  telegramBotName: string,
  config: AgentConfig
): TaskEither<Error, Agent> =>
  tryCatchAsync(
    async () => {
      // Используем Drizzle ORM для создания агента с автоматическим назначением порта
      const freePort = await findFreePort(db) // Функция поиска свободного порта
      
      const [agent] = await db
        .insert(agents)
        .values({
          name,
          slug: name.toLowerCase().replace(/[^a-z0-9]+/g, '-'),
          port: freePort,
          base_url: `http://localhost:${freePort}`,
          telegram_bot_token: telegramBotToken,
          telegram_bot_name: telegramBotName,
          config,
          description: config.description,
          tags: config.tags || [],
          owner_id: config.ownerId || null,
          api_key: generateApiKey(), // Генерация API ключа
          status: 'stopped',
        })
        .returning()
      
      if (!agent) {
        throw new Error('Failed to create agent')
      }
      
      // Создаем стандартные routes и webhooks
      await createDefaultRoutes(db, agent.id)
      await createDefaultWebhooks(db, agent.id)
      
      return agent as Agent
    },
    (error) => error instanceof Error ? error : new Error(String(error))
  )

// Использование
const agent = await runTaskEither(
  createAgentTask(
    'NeuroPhoto Agent',
    'TELEGRAM_BOT_TOKEN',
    'NeuroPhoto_bot',
    {
      model: 'minimax/minimax-m2',
      plugins: ['neuro_photo'],
      webhooks: { enabled: true },
      routes: { enabled: true },
    }
  )
)

fold(
  (error: Error) => {
    logger.error('Failed to create agent:', error)
    return null
  },
  (agent: Agent) => {
    logger.info(`Agent created: ${agent.name} on port ${agent.port}`)
    return agent
  }
)(agent)
```

### 🔧 Конфигурация Reverse Proxy (Nginx)

```nginx
# /etc/nginx/sites-available/agents-farm.conf

# Upstream для каждого агента (динамически генерируется)
upstream agent_neurophoto {
    server localhost:3001;
}

upstream agent_texttovideo {
    server localhost:3002;
}

upstream agent_digitalavatar {
    server localhost:3003;
}

# Основной сервер для маршрутизации
server {
    listen 80;
    server_name api.example.com;

    # Логирование
    access_log /var/log/nginx/agents-farm-access.log;
    error_log /var/log/nginx/agents-farm-error.log;

    # Маршрутизация по пути агента
    location ~ ^/agent/(?<agent_slug>[^/]+)(?<route_path>/.*)$ {
        # Получаем информацию об агенте из БД через Lua или внешний скрипт
        # Для простоты используем прямую маршрутизацию
        
        # Проверка авторизации
        auth_request /auth;
        
        # Проксирование запроса
        proxy_pass http://agent_$agent_slug$route_path;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header X-Agent-Slug $agent_slug;
        
        # Таймауты
        proxy_connect_timeout 60s;
        proxy_send_timeout 60s;
        proxy_read_timeout 60s;
    }

    # Health check endpoint для всех агентов
    location /health {
        access_log off;
        return 200 "healthy\n";
        add_header Content-Type text/plain;
    }

    # Endpoint для получения списка агентов
    location /agents {
        proxy_pass http://localhost:8080/api/agents; # Внутренний API
        proxy_set_header Host $host;
    }
}
```

### 🚀 Запуск агента (SDK)

```typescript
/**
 * Запуск агента на назначенном порту через Drizzle ORM
 */
import { TaskEither, tryCatchAsync } from '@/core/functional/utils/result'
import { createServer } from 'http'
import { startTelegramBot } from '@/core/bot'
import { setupWebhooks } from '@/core/webhooks'
import { setupRoutes } from '@/core/routes'
import { db } from '@/core/drizzle/client'
import { agents } from '@/core/drizzle/schema'
import { eq } from 'drizzle-orm'

const startAgent = async (agentId: string): Promise<TaskEither<Error, void>> => {
  return tryCatchAsync(
    async () => {
      // 1. Получаем конфигурацию агента из БД
      // Используем Drizzle ORM для получения конфигурации агента
      const [agentConfig] = await db
        .select({
          id: agents.id,
          name: agents.name,
          slug: agents.slug,
          port: agents.port,
          base_url: agents.base_url,
          telegram_bot_token: agents.telegram_bot_token,
          telegram_bot_name: agents.telegram_bot_name,
          config: agents.config,
          api_key: agents.api_key,
          webhooks: sql<JSONB>`(
            SELECT jsonb_agg(
              jsonb_build_object(
                'name', ${agent_webhooks.name},
                'path', ${agent_webhooks.path},
                'method', ${agent_webhooks.method},
                'config', ${agent_webhooks.config},
                'handler_type', ${agent_webhooks.handler_type},
                'handler_config', ${agent_webhooks.handler_config}
              )
            )
            FROM ${agent_webhooks}
            WHERE ${agent_webhooks.agent_id} = ${agents.id}
            AND ${agent_webhooks.is_active} = true
          )`,
          routes: sql<JSONB>`(
            SELECT jsonb_agg(
              jsonb_build_object(
                'name', ${agent_routes.name},
                'path', ${agent_routes.path},
                'method', ${agent_routes.method},
                'config', ${agent_routes.config},
                'handler_type', ${agent_routes.handler_type},
                'handler_config', ${agent_routes.handler_config}
              )
            )
            FROM ${agent_routes}
            WHERE ${agent_routes.agent_id} = ${agents.id}
            AND ${agent_routes.is_active} = true
          )`,
        })
        .from(agents)
        .where(eq(agents.id, agentId))
        .limit(1)
      
      if (!agentConfig) {
        throw new Error('Agent config not found')
      }
      
      // 2. Создаем HTTP сервер на назначенном порту
      const server = createServer(async (req, res) => {
        // Маршрутизация запросов
        const route = await getAgentRoute(req.url || '/', req.method || 'GET')
        
        if (!route) {
          res.writeHead(404, { 'Content-Type': 'application/json' })
          res.end(JSON.stringify({ error: 'Route not found' }))
          return
        }
        
        // Обработка route через handler
        await handleRoute(route, req, res)
      })
      
      // 3. Запускаем сервер на порту агента
      server.listen(agentConfig.port, () => {
        logger.info(`Agent ${agentConfig.name} started on port ${agentConfig.port}`)
      })
      
      // 4. Инициализируем Telegram бота
      await startTelegramBot(agentConfig.telegram_bot_token, {
        agentId: agentConfig.id,
        agentName: agentConfig.name,
        port: agentConfig.port,
      })
      
      // 5. Настраиваем webhooks
      await setupWebhooks(agentConfig.webhooks || [])
      
      // 6. Настраиваем routes
      await setupRoutes(agentConfig.routes || [])
      
      // 7. Обновляем статус агента в БД через Drizzle ORM
      await db
        .update(agents)
        .set({
          status: 'running',
          started_at: new Date(),
        })
        .where(eq(agents.id, agentId))
      
      return undefined
    },
    (error) => error instanceof Error ? error : new Error(String(error))
  )
}

// Использование
const result = await runTaskEither(startAgent(agentId))

fold(
  (error: Error) => {
    logger.error('Failed to start agent:', error)
    // Обновляем статус на 'error' через Drizzle ORM
    await db
      .update(agents)
      .set({ status: 'error' })
      .where(eq(agents.id, agentId))
  },
  () => {
    logger.info('Agent started successfully')
  }
)(result)
```

### 📋 Чек-лист для настройки фермы агентов:

- [ ] **1. Создание таблиц**
  - [ ] Применить SQL скрипт создания таблиц (`agents`, `agent_webhooks`, `agent_routes`)
  - [ ] Проверить создание индексов
  - [ ] Проверить создание функций (`find_free_port`, `create_agent`, `get_agent_startup_config`)

- [ ] **2. Настройка портов**
  - [ ] Определить диапазон портов для агентов (3000-3999)
  - [ ] Проверить доступность портов
  - [ ] Настроить firewall для портов агентов

- [ ] **3. Настройка Reverse Proxy**
  - [ ] Установить и настроить Nginx
  - [ ] Создать конфигурацию для маршрутизации запросов
  - [ ] Настроить SSL/TLS сертификаты
  - [ ] Протестировать маршрутизацию

- [ ] **4. SDK для создания агентов**
  - [ ] Создать функцию `createAgent()` для создания нового агента
  - [ ] Создать функцию `startAgent()` для запуска агента
  - [ ] Создать функцию `stopAgent()` для остановки агента
  - [ ] Создать функцию `getAgentStatus()` для получения статуса

- [ ] **5. Webhooks и Routes**
  - [ ] Настроить обработку webhooks для каждого агента
  - [ ] Настроить routes для каждого агента
  - [ ] Протестировать webhooks и routes

- [ ] **6. Мониторинг**
  - [ ] Настроить сбор метрик агентов
  - [ ] Настроить health checks
  - [ ] Настроить алерты на проблемы

- [ ] **7. Безопасность**
  - [ ] Настроить API ключи для агентов
  - [ ] Настроить rate limiting
  - [ ] Настроить IP whitelist (если нужно)
  - [ ] Настроить CORS (если нужно)

### 🎯 Результат:

**Ферма агентов готова к использованию:**
- ✅ Динамическое назначение портов при создании агента
- ✅ Автоматическая маршрутизация запросов через reverse proxy
- ✅ Webhooks и routes для каждого агента
- ✅ Единый SDK для создания и управления агентами
- ✅ Мониторинг и метрики для всех агентов
- ✅ Безопасность и изоляция агентов

**Ферма агентов готова к масштабированию!** 🤖🚀

### 🔒 Валидация данных с Zod

#### 🎯 Философия валидации

**Zod обеспечивает runtime type safety и валидацию всех данных:**
- ✅ Валидация входных данных (пользовательский ввод, API запросы)
- ✅ Валидация конфигураций (переменные окружения, настройки)
- ✅ Валидация данных из БД (проверка после получения)
- ✅ Автоматическая генерация TypeScript типов
- ✅ Интеграция с функциональным стилем (`TaskEither`)

#### 📋 Примеры схем Zod:

```typescript
// src/core/validation/schemas.ts
import { z } from 'zod'

// Схема пользователя
export const UserSchema = z.object({
  id: z.string().uuid(),
  telegram_id: z.number().int().positive(),
  bot_name: z.string().min(1).max(100),
  username: z.string().optional(),
  first_name: z.string().optional(),
  language_code: z.string().length(2).default('ru'),
  settings: z.record(z.unknown()).default({}),
  referral: z.record(z.unknown()).default({}),
  version: z.number().int().positive().default(1),
  created_at: z.date(),
  updated_at: z.date(),
})

export type User = z.infer<typeof UserSchema>

// Схема баланса
export const BalanceSchema = z.object({
  id: z.string().uuid(),
  user_id: z.string().uuid(),
  currencies: z.object({
    stars: z.number().int().min(0).default(0),
    rubles: z.number().min(0).default(0),
    dollars: z.number().min(0).default(0),
  }).default({}),
  statistics: z.object({
    total_income: z.number().min(0).default(0),
    total_expense: z.number().min(0).default(0),
    total_operations: z.number().int().min(0).default(0),
  }).optional(),
})

export type Balance = z.infer<typeof BalanceSchema>

// Схема агента
export const AgentSchema = z.object({
  id: z.string().uuid(),
  name: z.string().min(1).max(100),
  slug: z.string().regex(/^[a-z0-9-]+$/),
  port: z.number().int().min(3000).max(3999),
  base_url: z.string().url(),
  telegram_bot_token: z.string().min(1),
  telegram_bot_name: z.string().min(1).max(100),
  config: z.object({
    model: z.string().default('minimax/minimax-m2'),
    temperature: z.number().min(0).max(2).default(0.7),
    max_tokens: z.number().int().positive().default(2000),
    plugins: z.array(z.string()).default([]),
    webhooks: z.object({
      enabled: z.boolean().default(true),
      secret: z.string().optional(),
      events: z.array(z.string()).default([]),
    }).optional(),
    routes: z.object({
      enabled: z.boolean().default(true),
      middleware: z.array(z.string()).default([]),
      endpoints: z.array(z.string()).default([]),
    }).optional(),
  }).default({}),
  status: z.enum(['running', 'stopped', 'error', 'starting', 'stopping']).default('stopped'),
  health_status: z.enum(['healthy', 'unhealthy', 'degraded', 'unknown']).default('unknown'),
})

export type Agent = z.infer<typeof AgentSchema>

// Схема для валидации переменных окружения
export const EnvSchema = z.object({
  DATABASE_URL: z.string().url(),
  OPENROUTER_API_KEY: z.string().min(1),
  TELEGRAM_BOT_TOKEN: z.string().min(1),
  SUPABASE_URL: z.string().url().optional(),
  SUPABASE_SERVICE_KEY: z.string().optional(),
  NODE_ENV: z.enum(['development', 'production', 'test']).default('development'),
})

export type Env = z.infer<typeof EnvSchema>
```

#### 🚀 Использование Zod в функциональном стиле:

```typescript
// src/core/validation/validate.ts
import { z } from 'zod'
import { TaskEither, tryCatchAsync } from '@/core/functional/utils/result'
import { pipe, mapLeft } from '@/core/functional/utils/composition'

/**
 * Валидация данных через Zod с возвратом TaskEither
 */
export const validate = <T extends z.ZodTypeAny>(
  schema: T,
  data: unknown
): TaskEither<z.ZodError, z.infer<T>> =>
  tryCatchAsync(
    async () => {
      const result = schema.safeParse(data)
      if (!result.success) {
        throw result.error
      }
      return result.data
    },
    (error) => {
      if (error instanceof z.ZodError) {
        return error
      }
      return new z.ZodError([
        {
          code: 'custom',
          path: [],
          message: 'Unknown validation error',
        },
      ])
    }
  )

/**
 * Валидация с автоматическим преобразованием ошибок в строки
 */
export const validateOrThrow = <T extends z.ZodTypeAny>(
  schema: T,
  data: unknown
): TaskEither<Error, z.infer<T>> =>
  pipe(
    validate(schema, data),
    mapLeft((error: z.ZodError) => 
      new Error(`Validation failed: ${error.errors.map(e => `${e.path.join('.')}: ${e.message}`).join(', ')}`)
    )
  )

// Использование
const userResult = await runTaskEither(
  validate(UserSchema, userData)
)

fold(
  (error: z.ZodError) => {
    logger.error('Validation failed:', error.errors)
    return null
  },
  (user: User) => {
    logger.info('User validated:', user.id)
    return user
  }
)(userResult)
```

#### 🔧 Валидация переменных окружения:

```typescript
// src/core/config/env.ts
import { EnvSchema } from '@/core/validation/schemas'
import { validateOrThrow } from '@/core/validation/validate'

const loadEnv = (): TaskEither<Error, Env> =>
  validateOrThrow(
    EnvSchema,
    {
      DATABASE_URL: process.env.DATABASE_URL,
      OPENROUTER_API_KEY: process.env.OPENROUTER_API_KEY,
      TELEGRAM_BOT_TOKEN: process.env.TELEGRAM_BOT_TOKEN,
      SUPABASE_URL: process.env.SUPABASE_URL,
      SUPABASE_SERVICE_KEY: process.env.SUPABASE_SERVICE_KEY,
      NODE_ENV: process.env.NODE_ENV || 'development',
    }
  )

// Использование при старте приложения
const envResult = await runTaskEither(loadEnv())

fold(
  (error: Error) => {
    console.error('❌ Environment validation failed:', error.message)
    process.exit(1)
  },
  (env: Env) => {
    console.log('✅ Environment validated successfully')
    return env
  }
)(envResult)
```

### 🐝 Роевой интеллект и координация агентов

#### 🎯 Философия роевого интеллекта

**Система координации множества агентов через роевой интеллект:**
- ✅ **Королева (Queen)**: Центральный координатор роя агентов
- ✅ **Улей (Swarm)**: Рой специализированных агентов
- ✅ **Распределение задач**: Автоматическое распределение задач между агентами
- ✅ **Координация**: Синхронизация работы агентов
- ✅ **Масштабируемость**: Легкое добавление новых агентов
- ✅ **Отказоустойчивость**: Автоматическое переключение на резервных агентов

#### 🗄️ Модель БД для роевого интеллекта:

```sql
-- ========================================
-- 41. КОРОЛЕВА (Queen) - Центральный координатор
-- ========================================

CREATE TABLE swarm_queen (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name VARCHAR(100) UNIQUE NOT NULL,
  status VARCHAR(20) DEFAULT 'active',
  coordination_config JSONB NOT NULL DEFAULT '{}',
  metrics JSONB DEFAULT '{}',
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  last_coordination_at TIMESTAMP WITH TIME ZONE,
  CONSTRAINT swarm_queen_status_valid CHECK (status IN ('active', 'standby', 'maintenance'))
);

-- ========================================
-- 42. ЗАДАЧИ РОЯ (Swarm Tasks)
-- ========================================

CREATE TABLE swarm_tasks (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  queen_id UUID NOT NULL REFERENCES swarm_queen(id) ON DELETE CASCADE,
  task_type VARCHAR(100) NOT NULL,
  task_id VARCHAR(200) UNIQUE NOT NULL,
  input_data JSONB NOT NULL,
  output_data JSONB,
  error_data JSONB,
  status VARCHAR(20) DEFAULT 'pending',
  priority INTEGER DEFAULT 0,
  assigned_agents UUID[],
  primary_agent_id UUID REFERENCES agents(id) ON DELETE SET NULL,
  backup_agent_ids UUID[],
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  assigned_at TIMESTAMP WITH TIME ZONE,
  started_at TIMESTAMP WITH TIME ZONE,
  completed_at TIMESTAMP WITH TIME ZONE,
  failed_at TIMESTAMP WITH TIME ZONE,
  retry_count INTEGER DEFAULT 0,
  max_retries INTEGER DEFAULT 3,
  timeout_ms INTEGER DEFAULT 30000,
  CONSTRAINT swarm_tasks_status_valid CHECK (status IN ('pending', 'assigned', 'processing', 'completed', 'failed', 'cancelled'))
);

CREATE INDEX idx_swarm_tasks_queen_id ON swarm_tasks(queen_id);
CREATE INDEX idx_swarm_tasks_status ON swarm_tasks(status);
CREATE INDEX idx_swarm_tasks_priority ON swarm_tasks(priority DESC, created_at ASC);

-- ========================================
-- 43. КООРДИНАЦИЯ АГЕНТОВ (Agent Coordination)
-- ========================================

CREATE TABLE agent_coordination (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  queen_id UUID NOT NULL REFERENCES swarm_queen(id) ON DELETE CASCADE,
  agent_id UUID NOT NULL REFERENCES agents(id) ON DELETE CASCADE,
  status VARCHAR(20) DEFAULT 'idle',
  current_load INTEGER DEFAULT 0,
  max_load INTEGER DEFAULT 10,
  load_percentage NUMERIC DEFAULT 0,
  specializations TEXT[],
  capabilities JSONB DEFAULT '{}',
  performance_metrics JSONB DEFAULT '{}',
  registered_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  last_heartbeat TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  CONSTRAINT agent_coordination_queen_agent_unique UNIQUE (queen_id, agent_id),
  CONSTRAINT agent_coordination_status_valid CHECK (status IN ('idle', 'busy', 'error', 'maintenance'))
);

CREATE INDEX idx_agent_coordination_queen_id ON agent_coordination(queen_id);
CREATE INDEX idx_agent_coordination_status ON agent_coordination(status);
CREATE INDEX idx_agent_coordination_load ON agent_coordination(load_percentage DESC);

-- Функция для распределения задачи по агентам
CREATE OR REPLACE FUNCTION distribute_task_to_agents(
  p_queen_id UUID,
  p_task_type VARCHAR(100),
  p_input_data JSONB,
  p_priority INTEGER DEFAULT 0
)
RETURNS UUID AS $$
DECLARE
  v_task_id UUID;
  v_available_agents UUID[];
BEGIN
  INSERT INTO swarm_tasks (queen_id, task_type, task_id, input_data, status, priority)
  VALUES (p_queen_id, p_task_type, gen_random_uuid()::TEXT, p_input_data, 'pending', p_priority)
  RETURNING id INTO v_task_id;
  
  SELECT ARRAY_AGG(ac.agent_id) INTO v_available_agents
  FROM agent_coordination ac
  INNER JOIN agents a ON a.id = ac.agent_id
  WHERE ac.queen_id = p_queen_id
    AND ac.status = 'idle'
    AND a.status = 'running'
    AND (p_task_type = ANY(ac.specializations) OR array_length(ac.specializations, 1) IS NULL)
    AND ac.load_percentage < 80
  ORDER BY ac.load_percentage ASC
  LIMIT 3;
  
  IF array_length(v_available_agents, 1) IS NULL THEN
    RAISE EXCEPTION 'No available agents';
  END IF;
  
  UPDATE swarm_tasks
  SET status = 'assigned', assigned_agents = v_available_agents, assigned_at = NOW()
  WHERE id = v_task_id;
  
  RETURN v_task_id;
END;
$$ LANGUAGE plpgsql;
```

#### 🚀 Использование роевого интеллекта (Функциональный стиль):

```typescript
// src/core/swarm/queen.ts
import { TaskEither, tryCatchAsync } from '@/core/functional/utils/result'
import { db } from '@/core/drizzle/client'
import { swarm_tasks } from '@/core/drizzle/schema'
import { eq, sql } from 'drizzle-orm'
import { validate } from '@/core/validation/validate'
import { TaskInputSchema } from '@/core/validation/schemas'

/**
 * Распределение задачи по рою агентов
 */
const distributeTask = (
  queenId: string,
  taskType: string,
  inputData: unknown
): TaskEither<Error, string> =>
  pipe(
    // 1. Валидация входных данных
    validate(TaskInputSchema, inputData),
    // 2. Распределение задачи
    chain(async (validatedData) => {
      const result = await db.execute(
        sql`SELECT distribute_task_to_agents(${queenId}, ${taskType}, ${JSON.stringify(validatedData)}) as task_id`
      )
      
      if (!result.rows[0]?.task_id) {
        throw new Error('Failed to distribute task')
      }
      
      return result.rows[0].task_id as string
    })
  )

// Использование
const taskResult = await runTaskEither(
  distributeTask(queenId, 'neuro_photo', { prompt: 'Beautiful sunset' })
)

fold(
  (error: Error) => {
    logger.error('Task distribution failed:', error)
  },
  (taskId: string) => {
    logger.info(`Task ${taskId} distributed successfully`)
  }
)(taskResult)
```

### 🔍 Критический анализ ТЗ и области для оптимизации

#### ✅ Что уже хорошо реализовано:

1. **Архитектура БД**: Единая модель "Мозг аватара" с DRY принципом ✅
2. **Функциональное программирование**: TaskEither, pipe, immutability ✅
3. **Интернационализация**: Автоматическая генерация переводов ✅
4. **Мультиагентность**: Ферма агентов с управлением портами ✅
5. **Валидация**: Zod для runtime type safety ✅
6. **Drizzle ORM**: Типобезопасные запросы к БД ✅
7. **Minimax M2**: Топовая модель для кодирования ✅
8. **Роевой интеллект**: Координация через королеву (Queen) ✅
9. **VIBE агенты**: Специализированные агенты для каждой области ✅

#### ⚠️ Области для оптимизации:

1. **Производительность**:
   - ❌ Отсутствует кэширование частых запросов (Redis)
   - ❌ Нет connection pooling для Drizzle
   - ❌ Нет оптимизации запросов (query batching)
   - ❌ Отсутствует CDN для медиа файлов
   - ❌ Нет lazy loading для больших данных

2. **UX и настроение клиентов**:
   - ❌ Отсутствует система уведомлений о прогрессе задач
   - ❌ Нет предпросмотра результатов перед сохранением
   - ❌ Отсутствует история операций пользователя
   - ❌ Нет персонализации интерфейса
   - ❌ Отсутствует система рейтингов результатов
   - ❌ Нет системы подсказок и обучения пользователей
   - ❌ Отсутствует dark mode для интерфейса

3. **Надежность**:
   - ❌ Отсутствует система резервного копирования
   - ❌ Нет автоматического восстановления после ошибок
   - ❌ Отсутствует мониторинг производительности в реальном времени
   - ❌ Нет автоматического масштабирования агентов
   - ❌ Отсутствует система отката изменений

4. **Безопасность**:
   - ❌ Нет rate limiting на уровне пользователя
   - ❌ Отсутствует валидация размера файлов перед загрузкой
   - ❌ Нет защиты от DDoS атак
   - ❌ Отсутствует шифрование чувствительных данных
   - ❌ Нет аудита действий пользователей

5. **Мониторинг и аналитика**:
   - ❌ Отсутствует система аналитики использования функций
   - ❌ Нет A/B тестирования интерфейса
   - ❌ Отсутствует сбор обратной связи от пользователей
   - ❌ Нет системы алертов при критических ошибках
   - ❌ Отсутствует dashboard для мониторинга роя агентов

6. **Документация**:
   - ❌ Отсутствуют примеры интеграции VIBE агентов
   - ❌ Нет диаграмм архитектуры системы
   - ❌ Отсутствует руководство по развертыванию
   - ❌ Нет troubleshooting guide

#### 🎯 Рекомендации по улучшению настроения клиентов:

1. **Система прогресса задач**:
   - Показывать прогресс выполнения длительных операций (progress bar)
   - Уведомления о завершении задач (push notifications)
   - История выполненных операций с фильтрацией
   - Возможность отмены длительных операций

2. **Персонализация**:
   - Запоминание предпочтений пользователя (избранные модели, настройки)
   - Адаптивный интерфейс под пользователя (кастомные кнопки меню)
   - Рекомендации на основе истории использования
   - Персональные промпты и шаблоны

3. **Обратная связь**:
   - Система рейтингов результатов (👍/👎)
   - Возможность сообщить об ошибке (feedback form)
   - Поддержка через бота (chat support)
   - Система предложений улучшений

4. **Производительность**:
   - Быстрая загрузка интерфейса (< 1 сек)
   - Оптимизация запросов к БД (индексы, материализованные представления)
   - Кэширование частых операций (Redis)
   - CDN для медиа файлов

5. **Надежность**:
   - Автоматическое восстановление после ошибок (retry механизм)
   - Резервное копирование данных (daily backups)
   - Мониторинг и алерты (Prometheus + Grafana)
   - Health checks для всех агентов

6. **Обучение пользователей**:
   - Интерактивный tutorial при первом запуске
   - Подсказки и tooltips для новых функций
   - Видео-гайды для сложных операций
   - FAQ раздел в боте

#### 🔧 Конкретные улучшения документа:

1. **Добавить раздел "Быстрый старт"**:
   - Пошаговая инструкция для новых разработчиков
   - Минимальный пример использования VIBE агента
   - Схема архитектуры системы

2. **Добавить раздел "Troubleshooting"**:
   - Частые проблемы и их решения
   - Логи и диагностика
   - Контакты поддержки

3. **Добавить раздел "Примеры интеграции"**:
   - Пример создания нового VIBE агента
   - Пример использования существующего агента
   - Пример координации через королеву

4. **Улучшить структуру документа**:
   - Добавить оглавление с якорями
   - Группировка по категориям
   - Поиск по документу

5. **Добавить диаграммы**:
   - Архитектура системы VIBEE
   - Схема взаимодействия агентов
   - Схема базы данных
   - Схема роевого интеллекта

### 🔄 Трансформер для быстрого внедрения функций

#### Принцип работы:

**Вместо создания отдельных моделей для каждой функции, используем трансформер для преобразования данных:**

```typescript
/**
 * Трансформер для быстрого внедрения новых функций
 * Преобразует данные между форматом плагина и форматом AvatarBrain
 */
export class FunctionTransformer {
  /**
   * Создает операцию из данных плагина
   */
  static createOperation(
    plugin: BotPlugin,
    data: PluginOperationData
  ): Operation {
    return {
      id: generateUUID(),
      telegram_id: data.telegramId,
      bot_name: data.botName,
      type: this.mapPluginTypeToOperationType(plugin, data),
      service_type: plugin.mode,
      status: 'pending',
      cost: data.cost || 0,
      metadata: {
        plugin: plugin.name,
        pluginVersion: plugin.version,
        ...data.metadata,
      },
      created_at: new Date(),
    }
  }
  
  /**
   * Создает asset из результата операции
   */
  static createAsset(
    operation: Operation,
    result: OperationResult
  ): Asset {
    return {
      id: generateUUID(),
      telegram_id: operation.telegram_id,
      bot_name: operation.bot_name,
      type: this.detectAssetType(result),
      url: result.url || '',
      file_id: result.file_id,
      service_type: operation.service_type,
      operation_id: operation.id,
      model_name: result.model_name,
      prompt: result.prompt,
      metadata: {
        width: result.width,
        height: result.height,
        duration: result.duration,
        size: result.size,
        format: result.format,
        aspect_ratio: result.aspect_ratio,
        resolution: result.resolution,
      },
      created_at: new Date(),
    }
  }
  
  /**
   * Обновляет сессию из данных плагина
   */
  static updateSession(
    session: UserSession,
    plugin: BotPlugin,
    data: PluginSessionData
  ): UserSession {
    return {
      ...session,
      mode: plugin.mode,
      wizardData: {
        step: data.step || 1,
        mode: plugin.mode,
        data: {
          ...session.wizardData?.data,
          [plugin.name]: data.wizardData,
        },
      },
      ...this.mapPluginDataToSession(plugin, data),
      lastActivity: new Date(),
    }
  }
  
  /**
   * Маппинг типов плагина на типы операций
   */
  private static mapPluginTypeToOperationType(
    plugin: BotPlugin,
    data: PluginOperationData
  ): OperationType {
    // Автоматическое определение типа операции на основе плагина
    if (plugin.mode === ModeEnum.DigitalAvatarBody) return 'training'
    if (plugin.mode === ModeEnum.NeuroPhoto) return 'generation'
    if (plugin.mode === ModeEnum.TextToVideo) return 'generation'
    if (plugin.mode === ModeEnum.AiPhotoshop) return 'transformation'
    if (plugin.mode === ModeEnum.Morphing) return 'processing'
    
    return 'generation' // По умолчанию
  }
  
  /**
   * Определение типа asset из результата
   */
  private static detectAssetType(result: OperationResult): 'image' | 'video' | 'audio' {
    if (result.url?.match(/\.(jpg|jpeg|png|gif|webp)$/i)) return 'image'
    if (result.url?.match(/\.(mp4|webm|mov|avi)$/i)) return 'video'
    if (result.url?.match(/\.(mp3|wav|ogg|m4a)$/i)) return 'audio'
    
    // Определение по metadata
    if (result.format?.startsWith('image')) return 'image'
    if (result.format?.startsWith('video')) return 'video'
    if (result.format?.startsWith('audio')) return 'audio'
    
    return 'image' // По умолчанию
  }
  
  /**
   * Маппинг данных плагина на сессию
   */
  private static mapPluginDataToSession(
    plugin: BotPlugin,
    data: PluginSessionData
  ): Partial<UserSession> {
    const sessionData: Partial<UserSession> = {}
    
    // Автоматическое маппирование на основе типа плагина
    if (data.prompt) sessionData.prompt = data.prompt
    if (data.imageUrl) sessionData.imageUrl = data.imageUrl
    if (data.videoUrl) sessionData.videoUrl = data.videoUrl
    if (data.audioUrl) sessionData.audioUrl = data.audioUrl
    if (data.selectedModel) sessionData.selectedModel = data.selectedModel
    
    return sessionData
  }
}
```

### 📝 Пример использования трансформера

```typescript
/**
 * Пример: Быстрое внедрение новой функции через трансформер
 */

// 1. Определяем плагин новой функции
const newFeaturePlugin: BotPlugin = {
  name: 'new-feature',
  description: 'Новая функция',
  version: '1.0.0',
  mode: ModeEnum.NewFeature,
  category: 'ai',
  navigationButton: {
    ru: '🆕 Новая функция',
    en: '🆕 New Feature',
    mode: ModeEnum.NewFeature,
  },
  actions: [
    {
      name: 'EXECUTE_NEW_FEATURE',
      description: 'Выполняет новую функцию',
      validate: async (brain, context) => {
        return brain.balance.stars >= 10
      },
      handler: async (brain, context, options, callback) => {
        // Используем трансформер для создания операции
        const operation = FunctionTransformer.createOperation(
          newFeaturePlugin,
          {
            telegramId: brain.telegram_id,
            botName: brain.bot_name,
            cost: 10,
            metadata: { feature: 'new' },
          }
        )
        
        // Сохраняем операцию
        await saveOperation(operation)
        
        // Выполняем функцию
        const result = await executeNewFeature(context.data)
        
        // Создаем asset через трансформер
        const asset = FunctionTransformer.createAsset(operation, {
          url: result.url,
          format: 'image',
          width: result.width,
          height: result.height,
        })
        
        // Сохраняем asset
        await saveAsset(asset)
        
        // Обновляем операцию
        await updateOperation(operation.id, {
          status: 'completed',
          asset_id: asset.id,
        })
        
        await callback?.({
          success: true,
          data: { assetId: asset.id },
        })
        
        return {
          success: true,
          data: { assetId: asset.id },
        }
      },
    },
  ],
}

// 2. Регистрируем плагин
await registerPlugin(newFeaturePlugin)

// 3. Используем в коде
const brain = await getAvatarBrain(telegramId, botName)
const plugin = brain.plugins.get('new-feature')

if (plugin) {
  const action = plugin.actions?.find(a => a.name === 'EXECUTE_NEW_FEATURE')
  if (action) {
    await action.handler(
      brain,
      { telegramId, data: { input: 'test' } },
      undefined,
      async (result) => {
        await ctx.reply(result.message || 'Готово!')
      }
    )
  }
}
```

### 🔧 Единые интерфейсы TypeScript

#### 1. AvatarBrain (Главный интерфейс)

```typescript
/**
 * 🧠 Мозг аватара - единый источник правды для всех данных бота
 */
export interface AvatarBrain {
  // Идентификаторы
  id: string // UUID
  telegram_id: TelegramId // Telegram ID пользователя
  bot_name: BotName // Имя бота
  
  // Навигация
  navigation: NavigationState
  
  // Пользователь
  user: UserProfile
  session: UserSession
  
  // AI Модели
  models: UserModel[]
  selectedModel?: UserModel
  
  // Финансы
  balance: Balance
  subscription?: Subscription
  
  // Контент
  assets: Asset[]
  operations: Operation[]
  
  // Конфигурация
  config: BotConfig
  
  // Метаданные
  created_at: Date
  updated_at: Date
  version: string // Версия структуры данных
}
```

#### 2. NavigationState (Состояние навигации)

```typescript
/**
 * Состояние навигации пользователя
 */
export interface NavigationState {
  // Текущий режим
  currentMode: ModeEnum | null
  
  // Текущая сцена
  currentScene: SceneId | null
  
  // История навигации
  history: NavigationHistoryItem[]
  
  // Доступные кнопки
  availableButtons: NavigationButton[]
  
  // Права доступа
  permissions: UserPermissions
}

export interface NavigationHistoryItem {
  mode: ModeEnum
  scene: SceneId
  timestamp: Date
  action: string
}

export interface UserPermissions {
  isAdmin: boolean
  adminIds: number[]
  hasSubscription: boolean
  subscriptionType?: SubscriptionType
  allowedModes: ModeEnum[]
  blockedModes: ModeEnum[]
}
```

#### 3. UserProfile (Профиль пользователя)

```typescript
/**
 * Полный профиль пользователя
 */
export interface UserProfile {
  // Основная информация
  id: string // UUID из БД
  telegram_id: TelegramId
  username?: string
  first_name?: string
  last_name?: string
  language_code: 'ru' | 'en'
  
  // Бот
  bot_name: BotName
  
  // Настройки
  settings: UserSettings
  
  // Модели
  selected_ai_model?: string // OpenRouter модель
  selected_voice_id?: string // ElevenLabs voice ID
  
  // Метаданные
  created_at: Date
  updated_at: Date
  last_activity: Date
}

export interface UserSettings {
  // Язык
  language: 'ru' | 'en'
  language_code?: string
  
  // Аватар
  avatar_id?: string
  avatar_photo_url?: string
  
  // Голос
  voice_id?: string
  voice_id_elevenlabs?: string
  voice_id_synclabs?: string
  
  // Модель
  model?: string // OpenRouter модель по умолчанию
  
  // Аспект
  aspect_ratio?: '1:1' | '16:9' | '9:16'
  
  // Профиль
  company?: string
  position?: string
  designation?: string
  email?: string
  
  // Другое
  level?: number
  inviter?: string
  invitation_codes?: Record<string, any>
}
```

#### 4. UserSession (Сессия пользователя)

```typescript
/**
 * Сессия пользователя (временные данные)
 */
export interface UserSession {
  // Текущее состояние
  mode?: ModeEnum
  scene?: SceneId
  step?: number
  
  // Данные для текущей операции
  wizardData?: WizardData
  
  // Промпты и контент
  prompt?: string
  imageUrl?: string
  videoUrl?: string
  audioUrl?: string
  
  // Выбранные модели
  selectedModel?: UserModel
  selectedVideoModel?: string
  selectedImageModel?: string
  
  // Временные данные
  tempData?: Record<string, any>
  
  // Метаданные
  sessionId: string
  startedAt: Date
  lastActivity: Date
}

export interface WizardData {
  step: number
  mode: ModeEnum
  data: Record<string, any>
  
  // Специфичные данные для разных wizard'ов
  neuroPhoto?: NeuroPhotoWizardData
  textToVideo?: TextToVideoWizardData
  imageToVideo?: ImageToVideoWizardData
  aiPhotoshop?: AiPhotoshopWizardData
  morphing?: MorphingWizardData
  // ... другие wizard'ы
}

export interface NeuroPhotoWizardData {
  selectedModel?: UserModel
  prompt?: string
  numImages?: number
  size?: string
  aspectRatio?: string
  lastGeneratedImageUrl?: string
  lastGeneratedPrompt?: string
}

export interface TextToVideoWizardData {
  selectedVideoModel?: string
  selectedDuration?: number
  selectedAspectRatio?: string
  selectedVideoCost?: number
  prompt?: string
  videoJobId?: string
  videoMessageId?: number
}

export interface ImageToVideoWizardData {
  selectedVideoModel?: string
  imageUrl?: string
  prompt?: string
  videoJobId?: string
}

export interface AiPhotoshopWizardData {
  selectedModel?: 'seedream' | 'nano_banana' | 'flux_multi_kontext' | 'qwen_edit_plus' | 'flux_kontext_pro' | 'seededit_3' | 'qwen_image_edit' | 'all_models'
  selectedStyle?: 'portrait' | 'artistic' | 'photorealistic' | 'fantasy' | 'cyberpunk' | 'vintage' | 'custom'
  imageUrl?: string
  prompt?: string
  size?: '1K' | '2K' | '4K' | 'custom'
  variationsCount?: number
  cameraAngle?: string
  lighting?: string
  composition?: string
  savedResults?: Array<{
    url: string
    model: string
    prompt: string
    timestamp: string
    id: string
  }>
}

export interface MorphingWizardData {
  images: Array<{
    buffer: Buffer
    url?: string
    filename: string
    timestamp?: number
    originalOrder?: number
  }>
  type?: 'loop' | 'linear'
  customPrompt?: string
  buttonsMessageId?: number
  progressMessageId?: number
}
```

#### 5. UserModel (Модель пользователя)

```typescript
/**
 * Модель пользователя (обученная модель)
 */
export interface UserModel {
  id: string // UUID
  telegram_id: TelegramId
  model_name: string
  model_url: ModelUrl // Формат: 'provider/model:version'
  model_key?: ModelUrl
  trigger_word: string
  gender?: 'male' | 'female' | 'person'
  finetune_id?: string
  status: 'training' | 'completed' | 'failed'
  training_steps?: number
  training_model?: 'flux-lora-portrait-trainer' | 'flux-lora-fast-training'
  created_at: Date
  updated_at: Date
  completed_at?: Date
  is_active: boolean
  is_team_model?: boolean // Общая модель команды
  team_id?: string
}

export type ModelUrl = `${string}/${string}:${string}`
```

#### 6. Balance (Баланс)

```typescript
/**
 * Баланс пользователя
 */
export interface Balance {
  telegram_id: TelegramId
  stars: number // Telegram Stars
  rubles: number // Рубли
  dollars: number // Доллары
  
  // История операций
  total_income: number
  total_expense: number
  
  // Метаданные
  last_updated: Date
  currency: 'STARS' | 'RUB' | 'USD'
}
```

#### 7. Subscription (Подписка)

```typescript
/**
 * Подписка пользователя
 */
export interface Subscription {
  id: string // UUID
  telegram_id: TelegramId
  type: SubscriptionType
  start_date: Date
  end_date: Date
  is_active: boolean
  is_expired: boolean
  metadata?: Record<string, any>
  created_at: Date
  updated_at: Date
}

export enum SubscriptionType {
  NEUROPHOTO = 'NEUROPHOTO',
  NEUROVIDEO = 'NEUROVIDEO',
  STARS = 'STARS',
  NEUROTESTER = 'NEUROTESTER',
}
```

#### 8. Asset (Медиа файл)

```typescript
/**
 * Медиа файл (изображение, видео, аудио)
 */
export interface Asset {
  id: string // UUID
  telegram_id: TelegramId
  type: 'image' | 'video' | 'audio'
  url: string
  file_id?: string // Telegram file_id
  service_type: ServiceType
  model_name?: string
  prompt?: string
  metadata?: AssetMetadata
  created_at: Date
  expires_at?: Date
}

export interface AssetMetadata {
  width?: number
  height?: number
  duration?: number
  size?: number
  format?: string
  aspect_ratio?: string
  resolution?: string
  [key: string]: any
}

export type ServiceType = 
  | 'neuro_photo'
  | 'text_to_video'
  | 'image_to_video'
  | 'lip_sync'
  | 'text_to_speech'
  | 'face_swap'
  | 'morphing'
  | 'ai_photoshop'
  | 'image_upscaler'
  | 'image_to_prompt'
  | 'avatar_transform'
  | 'ai_heroes'
  | 'ai_reels'
```

#### 9. Operation (Операция)

```typescript
/**
 * Операция пользователя (генерация, обучение и т.д.)
 */
export interface Operation {
  id: string // UUID
  telegram_id: TelegramId
  type: OperationType
  service_type: ServiceType
  status: 'pending' | 'processing' | 'completed' | 'failed' | 'cancelled'
  cost: number // В звездах
  result?: OperationResult
  error?: string
  metadata?: Record<string, any>
  created_at: Date
  completed_at?: Date
  inngest_event_id?: string
  job_id?: string
}

export type OperationType = 
  | 'generation'
  | 'training'
  | 'processing'
  | 'transformation'
  | 'analysis'

export interface OperationResult {
  asset_id?: string
  url?: string
  data?: any
}
```

#### 10. BotConfig (Конфигурация бота)

```typescript
/**
 * Конфигурация бота
 */
export interface BotConfig {
  bot_name: BotName
  token: string
  port: number
  admin_ids: number[]
  features: BotFeatures
  pricing: PricingConfig
  limits: BotLimits
}

export interface BotFeatures {
  neuroPhoto: boolean
  textToVideo: boolean
  imageToVideo: boolean
  lipSync: boolean
  aiPhotoshop: boolean
  morphing: boolean
  // ... другие функции
}

export interface PricingConfig {
  neuroPhoto: number // Стоимость в звездах
  textToVideo: Record<string, number> // Модель -> стоимость
  imageToVideo: Record<string, number>
  lipSync: number
  aiPhotoshop: Record<string, number>
  // ... другие цены
}

export interface BotLimits {
  maxImagesPerGeneration: number
  maxVideoDuration: number
  maxFileSize: number
  maxOperationsPerDay: number
}
```

### 🗄️ Схема базы данных

#### Полная нормализованная схема

```sql
-- ========================================
-- 1. ПОЛЬЗОВАТЕЛИ
-- ========================================

CREATE TABLE users (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  telegram_id BIGINT UNIQUE NOT NULL,
  username TEXT,
  first_name TEXT,
  last_name TEXT,
  bot_name TEXT NOT NULL,
  language_code VARCHAR(10) DEFAULT 'ru',
  
  -- Настройки
  selected_ai_model TEXT, -- OpenRouter модель
  selected_voice_id TEXT, -- ElevenLabs voice ID
  avatar_id TEXT,
  avatar_photo_url TEXT,
  aspect_ratio TEXT,
  
  -- Профиль
  company TEXT,
  position TEXT,
  designation TEXT,
  email TEXT,
  level INTEGER DEFAULT 1,
  
  -- Приглашения
  inviter UUID REFERENCES users(id),
  invitation_codes JSONB,
  
  -- Метаданные
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  last_activity TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  
  -- Индексы
  CONSTRAINT users_telegram_id_bot_name_unique UNIQUE (telegram_id, bot_name)
);

CREATE INDEX idx_users_telegram_id ON users(telegram_id);
CREATE INDEX idx_users_bot_name ON users(bot_name);
CREATE INDEX idx_users_inviter ON users(inviter);

-- ========================================
-- 2. БАЛАНС И ПЛАТЕЖИ
-- ========================================

CREATE TABLE balances (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  telegram_id BIGINT NOT NULL,
  bot_name TEXT NOT NULL,
  stars DECIMAL(10, 2) DEFAULT 0,
  rubles DECIMAL(10, 2) DEFAULT 0,
  dollars DECIMAL(10, 2) DEFAULT 0,
  total_income DECIMAL(10, 2) DEFAULT 0,
  total_expense DECIMAL(10, 2) DEFAULT 0,
  last_updated TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  
  FOREIGN KEY (telegram_id, bot_name) REFERENCES users(telegram_id, bot_name),
  CONSTRAINT balances_telegram_id_bot_name_unique UNIQUE (telegram_id, bot_name)
);

CREATE TABLE payments_v2 (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  telegram_id BIGINT NOT NULL,
  bot_name TEXT NOT NULL,
  inv_id TEXT UNIQUE NOT NULL,
  
  -- Суммы
  amount DECIMAL(10, 2) NOT NULL,
  stars DECIMAL(10, 2) NOT NULL,
  cost DECIMAL(10, 2), -- Стоимость услуги
  currency VARCHAR(10) NOT NULL, -- STARS, RUB, USD
  
  -- Тип и статус
  type VARCHAR(50) NOT NULL, -- MONEY_INCOME, MONEY_OUTCOME, STAR_INCOME, STAR_EXPENSE, BONUS, REFUND
  status VARCHAR(20) NOT NULL, -- PENDING, COMPLETED, FAILED
  category VARCHAR(20) DEFAULT 'REAL', -- REAL, BONUS
  
  -- Услуга
  service_type VARCHAR(100), -- neuro_photo, text_to_video, etc.
  model_name TEXT,
  operation_id UUID,
  
  -- Подписка
  subscription_type VARCHAR(50), -- NEUROTESTER, NEUROVIDEO, etc.
  
  -- Платеж
  payment_method VARCHAR(50), -- Telegram, Robokassa, Manual
  invoice_url TEXT,
  description TEXT,
  
  -- Система
  is_system_payment BOOLEAN DEFAULT false,
  language VARCHAR(10),
  metadata JSONB,
  
  -- Временные метки
  payment_date TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  
  FOREIGN KEY (telegram_id, bot_name) REFERENCES users(telegram_id, bot_name)
);

CREATE INDEX idx_payments_telegram_id ON payments_v2(telegram_id);
CREATE INDEX idx_payments_bot_name ON payments_v2(bot_name);
CREATE INDEX idx_payments_status ON payments_v2(status);
CREATE INDEX idx_payments_type ON payments_v2(type);
CREATE INDEX idx_payments_service_type ON payments_v2(service_type);
CREATE INDEX idx_payments_payment_date ON payments_v2(payment_date);

-- ========================================
-- 3. ПОДПИСКИ
-- ========================================

CREATE TABLE subscriptions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  telegram_id BIGINT NOT NULL,
  bot_name TEXT NOT NULL,
  type VARCHAR(50) NOT NULL, -- NEUROTESTER, NEUROVIDEO, NEUROPHOTO, STARS
  start_date TIMESTAMP WITH TIME ZONE NOT NULL,
  end_date TIMESTAMP WITH TIME ZONE NOT NULL,
  is_active BOOLEAN DEFAULT true,
  metadata JSONB,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  
  FOREIGN KEY (telegram_id, bot_name) REFERENCES users(telegram_id, bot_name),
  CONSTRAINT subscriptions_telegram_id_bot_name_type_unique UNIQUE (telegram_id, bot_name, type)
);

CREATE INDEX idx_subscriptions_telegram_id ON subscriptions(telegram_id);
CREATE INDEX idx_subscriptions_bot_name ON subscriptions(bot_name);
CREATE INDEX idx_subscriptions_type ON subscriptions(type);
CREATE INDEX idx_subscriptions_is_active ON subscriptions(is_active);
CREATE INDEX idx_subscriptions_end_date ON subscriptions(end_date);

-- ========================================
-- 4. МОДЕЛИ ПОЛЬЗОВАТЕЛЕЙ
-- ========================================

CREATE TABLE user_models (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  telegram_id BIGINT NOT NULL,
  bot_name TEXT NOT NULL,
  model_name TEXT NOT NULL,
  model_url TEXT NOT NULL, -- Формат: provider/model:version
  model_key TEXT, -- Альтернативный ключ модели
  trigger_word TEXT NOT NULL,
  gender VARCHAR(20), -- male, female, person
  finetune_id TEXT,
  
  -- Обучение
  status VARCHAR(20) DEFAULT 'training', -- training, completed, failed
  training_steps INTEGER,
  training_model VARCHAR(100), -- flux-lora-portrait-trainer, flux-lora-fast-training
  training_started_at TIMESTAMP WITH TIME ZONE,
  training_completed_at TIMESTAMP WITH TIME ZONE,
  
  -- Команда
  is_team_model BOOLEAN DEFAULT false,
  team_id TEXT,
  
  -- Метаданные
  is_active BOOLEAN DEFAULT true,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  
  FOREIGN KEY (telegram_id, bot_name) REFERENCES users(telegram_id, bot_name)
);

CREATE INDEX idx_user_models_telegram_id ON user_models(telegram_id);
CREATE INDEX idx_user_models_bot_name ON user_models(bot_name);
CREATE INDEX idx_user_models_status ON user_models(status);
CREATE INDEX idx_user_models_is_active ON user_models(is_active);
CREATE INDEX idx_user_models_team_id ON user_models(team_id);

-- ========================================
-- 5. МЕДИА ФАЙЛЫ (ASSETS)
-- ========================================

CREATE TABLE assets (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  telegram_id BIGINT NOT NULL,
  bot_name TEXT NOT NULL,
  type VARCHAR(20) NOT NULL, -- image, video, audio
  url TEXT NOT NULL,
  file_id TEXT, -- Telegram file_id
  
  -- Услуга
  service_type VARCHAR(100) NOT NULL,
  model_name TEXT,
  prompt TEXT,
  
  -- Метаданные
  metadata JSONB, -- width, height, duration, size, format, aspect_ratio, resolution
  
  -- Временные метки
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  expires_at TIMESTAMP WITH TIME ZONE,
  
  FOREIGN KEY (telegram_id, bot_name) REFERENCES users(telegram_id, bot_name)
);

CREATE INDEX idx_assets_created_at ON assets(created_at);

-- ========================================
-- 6. ОПЕРАЦИИ
-- ========================================

CREATE TABLE operations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  telegram_id BIGINT NOT NULL,
  bot_name TEXT NOT NULL,
  type VARCHAR(50) NOT NULL, -- generation, training, processing, transformation, analysis
  service_type VARCHAR(100) NOT NULL,
  status VARCHAR(20) DEFAULT 'pending', -- pending, processing, completed, failed, cancelled
  cost DECIMAL(10, 2) NOT NULL,
  
  -- Результат
  result JSONB, -- asset_id, url, data
  
  -- Ошибки
  error TEXT,
  
  -- Inngest
  inngest_event_id TEXT,
  job_id TEXT,
  
  -- Метаданные
  metadata JSONB,
  
  -- Временные метки
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  completed_at TIMESTAMP WITH TIME ZONE,
  
  FOREIGN KEY (telegram_id, bot_name) REFERENCES users(telegram_id, bot_name)
);

CREATE INDEX idx_operations_telegram_id ON operations(telegram_id);
CREATE INDEX idx_operations_bot_name ON operations(bot_name);
CREATE INDEX idx_operations_status ON operations(status);
CREATE INDEX idx_operations_service_type ON operations(service_type);
CREATE INDEX idx_operations_created_at ON operations(created_at);
CREATE INDEX idx_operations_inngest_event_id ON operations(inngest_event_id);

-- ========================================
-- 7. СЕССИИ (для временных данных)
-- ========================================

CREATE TABLE user_sessions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  telegram_id BIGINT NOT NULL,
  bot_name TEXT NOT NULL,
  session_id TEXT UNIQUE NOT NULL,
  
  -- Состояние
  mode VARCHAR(100),
  scene VARCHAR(100),
  step INTEGER,
  
  -- Данные wizard'а
  wizard_data JSONB,
  
  -- Промпты и контент
  prompt TEXT,
  image_url TEXT,
  video_url TEXT,
  audio_url TEXT,
  
  -- Выбранные модели
  selected_model_id UUID REFERENCES user_models(id),
  selected_video_model TEXT,
  selected_image_model TEXT,
  
  -- Временные данные
  temp_data JSONB,
  
  -- Временные метки
  started_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  last_activity TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  expires_at TIMESTAMP WITH TIME ZONE,
  
  FOREIGN KEY (telegram_id, bot_name) REFERENCES users(telegram_id, bot_name)
);

CREATE INDEX idx_user_sessions_telegram_id ON user_sessions(telegram_id);
CREATE INDEX idx_user_sessions_bot_name ON user_sessions(bot_name);
CREATE INDEX idx_user_sessions_session_id ON user_sessions(session_id);
CREATE INDEX idx_user_sessions_expires_at ON user_sessions(expires_at);

-- ========================================
-- 8. КОНФИГУРАЦИЯ БОТОВ
-- ========================================

CREATE TABLE bot_configs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  bot_name TEXT UNIQUE NOT NULL,
  token TEXT NOT NULL,
  port INTEGER NOT NULL,
  admin_ids INTEGER[],
  features JSONB, -- Включенные функции
  pricing JSONB, -- Конфигурация цен
  limits JSONB, -- Лимиты
  metadata JSONB,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE INDEX idx_bot_configs_bot_name ON bot_configs(bot_name);
```

### 🔑 Ключевые ID'шники и константы

#### ModeEnum (Все режимы работы)

```typescript
export enum ModeEnum {
  // ИИ Функции
  DigitalAvatarBody = 'digital_avatar_body',
  NeuroPhoto = 'neuro_photo',
  ImageToPrompt = 'image_to_prompt',
  Avatar = 'avatar', // Мозг аватара
  ChatWithAvatar = 'chat_with_avatar',
  SelectModel = 'select_model',
  Voice = 'voice',
  TextToSpeech = 'text_to_speech',
  
  // Видео и Фото
  TextToVideo = 'text_to_video',
  ImageToVideo = 'image_to_video',
  LipSync = 'lip_sync',
  Morphing = 'morphing',
  FaceSwap = 'face_swap',
  
  // Продвинутые инструменты
  AiPhotoshop = 'ai_photoshop',
  ImageUpscaler = 'image_upscaler',
  AvatarTransform = 'avatar_transform',
  AIHeroes = 'ai_heroes',
  
  // Админские функции
  Broadcast = 'broadcast',
  CompetitorMonitoring = 'competitor_monitoring',
  AIReels = 'ai_reels',
  
  // Навигация
  MainMenu = 'main_menu',
  Help = 'helpScene',
  Balance = 'balance',
  Support = 'support',
  
  // Оплата
  Subscribe = 'subscribe',
  TopUpBalance = 'top_up_balance',
  
  // Системные
  CheckBalanceScene = 'check_balance_scene',
  SubscriptionScene = 'subscription_scene',
  // ... остальные
}
```

#### ServiceType (Типы услуг)

```typescript
export type ServiceType = 
  | 'neuro_photo'
  | 'text_to_video'
  | 'image_to_video'
  | 'lip_sync'
  | 'text_to_speech'
  | 'face_swap'
  | 'morphing'
  | 'ai_photoshop'
  | 'image_upscaler'
  | 'image_to_prompt'
  | 'avatar_transform'
  | 'ai_heroes'
  | 'ai_reels'
  | 'digital_avatar_body'
  | 'model_training'
```

#### BotName (Имена ботов)

```typescript
/**
 * Актуальный список всех 10 production ботов
 * Используется для идентификации бота в БД и маршрутизации
 */
export type BotName = 
  | 'neuro_blogger_bot'           // BOT_TOKEN_1 - Основной бот NeuroBlogger
  | 'MetaMuse_Manifest_bot'       // BOT_TOKEN_2 - MetaMuse Manifestation бот
  | 'ZavaraBot'                    // BOT_TOKEN_3 - Zavara бот
  | 'LeeSolarbot'                  // BOT_TOKEN_4 - Lee Solar бот
  | 'NeuroLenaAssistant_bot'       // BOT_TOKEN_5 - Neuro Lena Assistant бот
  | 'NeurostylistShtogrina_bot'    // BOT_TOKEN_6 - Neuro Stylist Shtogrina бот
  | 'Gaia_Kamskaia_bot'            // BOT_TOKEN_7 - Gaia Kamskaia бот
  | 'Kaya_easy_art_bot'            // BOT_TOKEN_8 - Kaya Easy Art бот
  | 'AI_STARS_bot'                 // BOT_TOKEN_9 - AI Stars бот
  | 'HaimGroupMedia_bot'           // BOT_TOKEN_10 - Haim Group Media бот
```

### 📊 Маппинг функций на структуру данных

| Функция | UserSession | Operation | Asset | UserModel |
|---------|------------|-----------|-------|-----------|
| Нейрофото | `neuroPhoto` | `generation` | `image` | `selectedModel` |
| Текст в видео | `textToVideo` | `generation` | `video` | - |
| Изображение в видео | `imageToVideo` | `generation` | `video` | - |
| Липсинк | `lipSync` | `processing` | `video` | - |
| Цифровое тело | `digitalAvatarBody` | `training` | - | `newModel` |
| ИИ Фотошоп | `aiPhotoshop` | `transformation` | `image` | - |
| Морфинг | `morphing` | `processing` | `video` | - |

### ✅ Лучшие практики (на основе ElizaOS)

#### 1. Валидация данных

```typescript
// ✅ ПРАВИЛЬНО: Всегда валидировать перед выполнением
validate: async (brain, context) => {
  // Проверка баланса
  if (brain.balance.stars < requiredCost) {
    return false
  }
  
  // Проверка подписки
  if (plugin.requires_subscription && !brain.subscription?.is_active) {
    return false
  }
  
  // Проверка прав доступа
  if (plugin.admin_only && !brain.navigation.permissions.isAdmin) {
    return false
  }
  
  return true
}

// ❌ НЕПРАВИЛЬНО: Отсутствие валидации
validate: async () => true
```

#### 2. Обработка ошибок

```typescript
// ✅ ПРАВИЛЬНО: Обработка ошибок с уведомлением пользователя
handler: async (brain, context, options, callback) => {
  try {
    // Валидация через трансформер
    const validation = AvatarBrainTransformer.validate(brain)
    if (!validation.valid) {
      await callback?.({
        success: false,
        error: new Error(validation.errors.join(', ')),
        message: 'Ошибка валидации данных',
      })
      return { success: false, error: new Error('Validation failed') }
    }
    
    // Создание операции через трансформер
    const operation = FunctionTransformer.createOperation(plugin, {
      telegramId: brain.telegram_id,
      botName: brain.bot_name,
      cost: 10,
    })
    
    // Выполнение действия
    const result = await executeAction(context.data)
    
    // Создание asset через трансформер
    const asset = FunctionTransformer.createAsset(operation, result)
    
    // Обновление brain
    brain.assets.push(asset)
    brain.operations.push(operation)
    
    await callback?.({
      success: true,
      data: { assetId: asset.id },
      message: 'Операция выполнена успешно',
    })
    
    return {
      success: true,
      data: { assetId: asset.id },
    }
  } catch (error) {
    await callback?.({
      success: false,
      error: error instanceof Error ? error : new Error(String(error)),
      message: 'Произошла ошибка при выполнении операции',
    })
    
    return {
      success: false,
      error: error instanceof Error ? error : new Error(String(error)),
    }
  }
}
```

#### 3. Типобезопасность

```typescript
// ✅ ПРАВИЛЬНО: Использование типов из AvatarBrain
import { AvatarBrain, BotPlugin, PluginAction } from '@/interfaces/avatar-brain'

const action: PluginAction = {
  name: 'MY_ACTION',
  description: 'My action',
  validate: async (brain: AvatarBrain, context: ActionContext) => {
    // Типобезопасный доступ к данным
    return brain.balance.stars >= 10
  },
  handler: async (brain: AvatarBrain, context: ActionContext) => {
    // Типобезопасная работа с brain
    return { success: true }
  },
}

// ❌ НЕПРАВИЛЬНО: Использование 'any'
const action: any = { ... }
```

#### 4. Использование трансформера

```typescript
// ✅ ПРАВИЛЬНО: Использование трансформера для преобразования данных
const operation = FunctionTransformer.createOperation(plugin, {
  telegramId: brain.telegram_id,
  botName: brain.bot_name,
  cost: 10,
  metadata: { feature: 'new' },
})

const asset = FunctionTransformer.createAsset(operation, {
  url: result.url,
  format: 'image',
  width: 1024,
  height: 1024,
})

const updatedSession = FunctionTransformer.updateSession(
  brain.session,
  plugin,
  { step: 2, wizardData: { prompt: 'test' } }
)

// ❌ НЕПРАВИЛЬНО: Создание данных вручную без трансформера
const operation = {
  id: generateUUID(),
  telegram_id: brain.telegram_id,
  // ... много повторяющегося кода
}
```

#### 5. Регистрация плагинов

```typescript
// ✅ ПРАВИЛЬНО: Регистрация плагина через единый интерфейс
export const neuroPhotoPlugin: BotPlugin = {
  name: 'neuro-photo',
  description: 'Генерация нейрофото',
  version: '1.0.0',
  mode: ModeEnum.NeuroPhoto,
  category: 'ai',
  navigationButton: {
    ru: '📸 Нейрофото',
    en: '📸 NeuroPhoto',
    mode: ModeEnum.NeuroPhoto,
  },
  requires_subscription: true,
  actions: [/* ... */],
  providers: [/* ... */],
  services: [/* ... */],
}

// Регистрация
await registerPlugin(neuroPhotoPlugin)

// ❌ НЕПРАВИЛЬНО: Создание отдельных модулей для каждой функции
// Каждая функция должна быть плагином!
```

### 🎯 Принципы использования "Мозг аватара"

1. **Единый источник правды**: Все данные берутся из `AvatarBrain`
2. **Типобезопасность**: Использовать только TypeScript интерфейсы
3. **Нормализация**: Данные хранятся в нормализованном виде в БД
4. **Денормализация**: Для быстрого доступа используется кэш в сессии
5. **Версионирование**: Структура данных версионируется через `version` поле
6. **Плагинная архитектура**: Каждая функция - это плагин с единым интерфейсом
7. **Трансформер**: Использовать трансформер для преобразования данных между форматами
8. **Валидация**: Всегда валидировать данные перед выполнением операций
9. **Обработка ошибок**: Обрабатывать ошибки с уведомлением пользователя
10. **Единая модель**: Использовать единую модель вместо множества отдельных моделей

### 🔄 Жизненный цикл плагина

#### Последовательность инициализации (на основе ElizaOS)

```typescript
/**
 * Последовательность инициализации плагина
 */
export class PluginManager {
  private plugins: Map<string, BotPlugin> = new Map()
  private brain: AvatarBrain
  
  /**
   * 1. Регистрация плагина
   */
  async registerPlugin(plugin: BotPlugin): Promise<void> {
    // Валидация плагина
    this.validatePlugin(plugin)
    
    // Регистрация в БД
    await this.savePluginToDatabase(plugin)
    
    // Добавление в регистр
    this.plugins.set(plugin.name, plugin)
    
    // Инициализация плагина
    if (plugin.init) {
      await plugin.init(this.brain)
    }
  }
  
  /**
   * 2. Инициализация компонентов плагина
   */
  async initializePlugin(plugin: BotPlugin): Promise<void> {
    // 2.1. Database Adapter (если есть)
    if (plugin.adapters) {
      for (const adapter of plugin.adapters) {
        await adapter.initialize(this.brain)
      }
    }
    
    // 2.2. Actions (регистрация действий)
    if (plugin.actions) {
      for (const action of plugin.actions) {
        await this.registerAction(action)
      }
    }
    
    // 2.3. Evaluators (регистрация оценщиков)
    if (plugin.evaluators) {
      for (const evaluator of plugin.evaluators) {
        await this.registerEvaluator(evaluator)
      }
    }
    
    // 2.4. Providers (регистрация провайдеров)
    if (plugin.providers) {
      for (const provider of plugin.providers) {
        await this.registerProvider(provider)
      }
    }
    
    // 2.5. Models (конфигурация моделей)
    if (plugin.config?.models) {
      await this.configureModels(plugin.config.models)
    }
    
    // 2.6. Routes (настройка HTTP маршрутов)
    if (plugin.routes) {
      for (const route of plugin.routes) {
        await this.registerRoute(route)
      }
    }
    
    // 2.7. Events (подписка на события)
    if (plugin.events) {
      for (const event of plugin.events) {
        await this.subscribeToEvent(event)
      }
    }
    
    // 2.8. Services (инициализация сервисов)
    if (plugin.services) {
      for (const service of plugin.services) {
        await service.initialize(this.brain)
        await service.start()
      }
    }
  }
  
  /**
   * 3. Уничтожение плагина
   */
  async destroyPlugin(pluginName: string): Promise<void> {
    const plugin = this.plugins.get(pluginName)
    if (!plugin) return
    
    // Остановка сервисов
    if (plugin.services) {
      for (const service of plugin.services) {
        await service.stop()
      }
    }
    
    // Вызов destroy хука
    if (plugin.destroy) {
      await plugin.destroy()
    }
    
    // Удаление из регистра
    this.plugins.delete(pluginName)
  }
  
  /**
   * Валидация плагина
   */
  private validatePlugin(plugin: BotPlugin): void {
    if (!plugin.name) throw new Error('Plugin name is required')
    if (!plugin.description) throw new Error('Plugin description is required')
    if (!plugin.version) throw new Error('Plugin version is required')
    if (!plugin.mode) throw new Error('Plugin mode is required')
    if (!plugin.navigationButton) throw new Error('Plugin navigationButton is required')
    
    // Валидация actions
    if (plugin.actions) {
      for (const action of plugin.actions) {
        if (!action.name) throw new Error('Action name is required')
        if (!action.description) throw new Error('Action description is required')
        if (!action.validate) throw new Error('Action validate is required')
        if (!action.handler) throw new Error('Action handler is required')
      }
    }
    
    // Валидация services
    if (plugin.services) {
      for (const service of plugin.services) {
        if (!service.initialize) throw new Error('Service initialize is required')
        if (!service.start) throw new Error('Service start is required')
        if (!service.stop) throw new Error('Service stop is required')
      }
    }
  }
}
```

### 📚 Лучшие практики функционального программирования

#### 1. Композиция функций через pipe

```typescript
// ✅ ПРАВИЛЬНО: Использование pipe для композиции
import { pipe } from '@/core/functional/utils/composition'
import { chain, map, tap } from '@/core/functional/utils/result'

const processRequest = (input: RequestInput): TaskEither<Error, Response> =>
  pipe(
    validateInput(input),
    chain(getUserTask),
    chain(checkBalanceTask(10)),
    chain(deductBalanceTask(10)),
    chain(processTask),
    tap(logResult),
    map(formatResponse)
  )

// ❌ НЕПРАВИЛЬНО: Вложенные вызовы
const processRequest = async (input: RequestInput) => {
  const validated = await validateInput(input)
  const user = await getUser(validated)
  const checked = await checkBalance(user, 10)
  // ... много вложенности
}
```

#### 2. Обработка ошибок через Either/TaskEither

```typescript
// ✅ ПРАВИЛЬНО: Ошибки как значения
import { TaskEither, left, right, fold } from '@/core/functional/utils/result'

const getUserTask = (id: string): TaskEither<Error, User> =>
  async () => {
    try {
      const user = await db.getUser(id)
      return user ? right(user) : left(new Error('User not found'))
    } catch (error) {
      return left(error instanceof Error ? error : new Error(String(error)))
    }
  }

// Использование с fold для обработки обеих веток
const result = await fold(
  (error: Error) => console.error('Error:', error),
  (user: User) => console.log('User:', user)
)(await getUserTask('123'))

// ❌ НЕПРАВИЛЬНО: throw/catch
const getUser = async (id: string) => {
  const user = await db.getUser(id)
  if (!user) throw new Error('User not found') // Плохо!
  return user
}
```

#### 3. Неизменяемость данных

```typescript
// ✅ ПРАВИЛЬНО: Создание новых объектов
const updateBalance = (user: User, amount: number): User => ({
  ...user,
  balance: {
    ...user.balance,
    stars: user.balance.stars + amount,
  },
})

// Использование
const updatedUser = updateBalance(user, 10)
// user не изменился, updatedUser - новый объект

// ❌ НЕПРАВИЛЬНО: Мутация данных
const updateBalance = (user: User, amount: number) => {
  user.balance.stars += amount // Мутация!
  return user
}
```

#### 4. Чистые функции

```typescript
// ✅ ПРАВИЛЬНО: Чистая функция без побочных эффектов
const calculateCost = (duration: number, model: string): number => {
  const baseCost = 10
  const durationMultiplier = duration / 60
  const modelMultiplier = model === 'premium' ? 2 : 1
  return baseCost * durationMultiplier * modelMultiplier
}

// Тестирование чистой функции
expect(calculateCost(60, 'premium')).toBe(20)
expect(calculateCost(30, 'standard')).toBe(5)

// ❌ НЕПРАВИЛЬНО: Побочные эффекты в функции
const calculateCost = (duration: number, model: string): number => {
  console.log('Calculating cost...') // Side effect!
  const cost = baseCost * duration
  saveToDatabase(cost) // Side effect!
  return cost
}
```

#### 5. Side effects через tap/tapTask

```typescript
// ✅ ПРАВИЛЬНО: Side effects через tap
import { tap, tapTask } from '@/core/functional/utils/result'

const processWithLogging = (input: Input): TaskEither<Error, Output> =>
  pipe(
    processTask(input),
    tapTask(result => logger.info('Processed:', result)), // Side effect
    tapTask(result => metrics.record(result)), // Side effect
    map(formatOutput) // Чистое преобразование
  )

// ❌ НЕПРАВИЛЬНО: Side effects внутри функции
const processWithLogging = async (input: Input) => {
  const result = await process(input)
  logger.info('Processed:', result) // Side effect внутри функции
  return result
}
```

#### 6. Каррирование для частичного применения

```typescript
// ✅ ПРАВИЛЬНО: Каррирование для переиспользования
import { curry } from '@/core/functional/utils/composition'

const checkBalance = curry((required: number, user: User): Either<Error, User> =>
  user.balance.stars >= required
    ? right(user)
    : left(new Error('Insufficient balance'))
)

// Использование
const checkBalance10 = checkBalance(10)
const checkBalance50 = checkBalance(50)

const result1 = checkBalance10(user) // Проверка на 10
const result2 = checkBalance50(user) // Проверка на 50

// ❌ НЕПРАВИЛЬНО: Дублирование кода
const checkBalance10 = (user: User) => user.balance.stars >= 10
const checkBalance50 = (user: User) => user.balance.stars >= 50
```

### 📝 Примеры использования (Функциональный стиль)

#### Пример 1: Получение "Мозга аватара" (Функциональный стиль)

```typescript
/**
 * Получение "Мозга аватара" для пользователя
 * ЕДИНАЯ функция для всех операций (Функциональный стиль)
 */
import { pipe } from '@/core/functional/utils/composition'
import { TaskEither, chain, map, sequence } from '@/core/functional/utils/result'

const getAvatarBrain = (
  telegramId: TelegramId,
  botName: BotName
): TaskEither<Error, AvatarBrain> =>
  pipe(
    // 1. Параллельная загрузка всех данных
    () => Promise.all([
      getUserProfileTask(telegramId, botName)(),
      getBalanceTask(telegramId, botName)(),
      getActiveSubscriptionTask(telegramId, botName)(),
      getUserModelsTask(telegramId, botName)(),
      getSessionTask(telegramId, botName)(),
      getNavigationStateTask(telegramId, botName)(),
      getActivePluginsTask(botName)(),
      getBotConfigTask(botName)(),
    ]),
    // 2. Преобразование в TaskEither
    chain(results => {
      const [user, balance, subscription, models, session, navigation, plugins, config] = results
      
      // Проверка на ошибки
      const errors = results.filter(r => r._tag === 'Left')
      if (errors.length > 0) {
        return left(errors[0].left)
      }
      
      // Извлечение значений
      const values = results.map(r => r._tag === 'Right' ? r.right : null)
      const [userVal, balanceVal, subscriptionVal, modelsVal, sessionVal, navigationVal, pluginsVal, configVal] = values
      
      // 3. Сборка AvatarBrain через трансформер
      return right(
        AvatarBrainTransformer.merge(
          {
            id: userVal.id,
            telegram_id: telegramId,
            bot_name: botName,
            navigation: navigationVal,
            user: userVal,
            session: sessionVal,
            models: modelsVal,
            selectedModel: modelsVal.find(m => m.is_active),
            balance: balanceVal,
            subscription: subscriptionVal,
            assets: [],
            operations: [],
            config: configVal,
            plugins: new Map(pluginsVal.map(p => [p.name, p])),
            created_at: userVal.created_at,
            updated_at: new Date(),
            version: '1.0.0',
          }
        )
      )
    })
  )

// Использование
const result = await runTaskEither(getAvatarBrain(telegramId, botName))

fold(
  (error: Error) => console.error('Error loading brain:', error),
  (brain: AvatarBrain) => console.log('Brain loaded:', brain)
)(result)
```

#### Пример 2: Использование плагина (Функциональный стиль)

```typescript
/**
 * Использование плагина для выполнения действия
 * ВСЕГДА в функциональном стиле с TaskEither
 */
import { pipe } from '@/core/functional/utils/composition'
import { TaskEither, chain, map, fold, fromNullable } from '@/core/functional/utils/result'

const executePluginAction = (
  brain: AvatarBrain,
  pluginName: string,
  actionName: string,
  context: ActionContext
): TaskEither<Error, ActionResult> =>
  pipe(
    // 1. Получение плагина из регистра
    () => fromNullable(
      brain.plugins.get(pluginName),
      () => new Error(`Plugin ${pluginName} not found`)
    ),
    // 2. Получение действия из плагина
    chain(plugin => 
      fromNullable(
        plugin.actions?.find(a => a.name === actionName),
        () => new Error(`Action ${actionName} not found in plugin ${pluginName}`)
      )
    ),
    // 3. Валидация через действие
    chain(action => {
      const validation = action.validate(brain, context)
      return validation._tag === 'Left'
        ? left(validation.left)
        : right(action)
    }),
    // 4. Выполнение действия
    chain(action => 
      action.handler(
        brain,
        context,
        undefined,
        async (callbackResult) => {
          // Side effect через tapTask
          await sendNotification(brain.telegram_id, callbackResult.message || 'Готово!')
        }
      )
    ),
    // 5. Сохранение результата в brain (если успешно)
    chain(async (result) => {
      if (result.success && result.data) {
        const plugin = brain.plugins.get(pluginName)!
        const updatedBrain = AvatarBrainTransformer.merge(brain, {
          operations: [FunctionTransformer.createOperation(plugin, {
            telegramId: brain.telegram_id,
            botName: brain.bot_name,
            cost: result.data.cost || 0,
            metadata: result.data,
          })],
        })
        
        // Сохранение в БД (TaskEither)
        const saveResult = await saveAvatarBrainTask(updatedBrain)()
        return saveResult._tag === 'Left' 
          ? left(saveResult.left)
          : right(result)
      }
      return right(result)
    })
  )

// Использование
const result = await runTaskEither(
  executePluginAction(brain, 'neuro-photo', 'GENERATE_NEURO_PHOTO', context)
)

fold(
  (error: Error) => {
    console.error('Action failed:', error)
    // Обработка ошибки
  },
  (actionResult: ActionResult) => {
    console.log('Action succeeded:', actionResult)
    // Обработка успеха
  }
)(result)
```

#### Пример 3: Быстрое внедрение новой функции

```typescript
/**
 * Пример: Быстрое внедрение новой функции через плагинную архитектуру
 */

// 1. Определяем плагин
const newFeaturePlugin: BotPlugin = {
  name: 'new-feature',
  description: 'Новая функция',
  version: '1.0.0',
  mode: ModeEnum.NewFeature,
  category: 'ai',
  navigationButton: {
    ru: '🆕 Новая функция',
    en: '🆕 New Feature',
    mode: ModeEnum.NewFeature,
  },
  requires_subscription: true,
  
  // Действия плагина
  actions: [
    {
      name: 'EXECUTE_NEW_FEATURE',
      description: 'Выполняет новую функцию',
      validate: async (brain, context) => {
        // Валидация через brain
        return brain.balance.stars >= 10 &&
               brain.subscription?.is_active === true
      },
      handler: async (brain, context, options, callback) => {
        // Используем трансформер для создания операции
        const operation = FunctionTransformer.createOperation(
          newFeaturePlugin,
          {
            telegramId: brain.telegram_id,
            botName: brain.bot_name,
            cost: 10,
            metadata: { feature: 'new' },
          }
        )
        
        // Сохраняем операцию
        await saveOperation(operation)
        
        // Выполняем функцию
        const result = await executeNewFeature(context.data)
        
        // Создаем asset через трансформер
        const asset = FunctionTransformer.createAsset(operation, {
          url: result.url,
          format: 'image',
          width: result.width,
          height: result.height,
        })
        
        // Сохраняем asset
        await saveAsset(asset)
        
        // Обновляем операцию
        await updateOperation(operation.id, {
          status: 'completed',
          asset_id: asset.id,
        })
        
        await callback?.({
          success: true,
          data: { assetId: asset.id },
          message: 'Функция выполнена успешно!',
        })
        
        return {
          success: true,
          data: { assetId: asset.id },
        }
      },
    },
  ],
  
  // Провайдеры данных
  providers: [
    {
      name: 'new-feature-context',
      description: 'Контекст для новой функции',
      get: async (brain, context) => {
        return {
          text: `Доступно ${brain.balance.stars} звезд`,
          values: {
            balance: brain.balance.stars,
            hasSubscription: !!brain.subscription?.is_active,
          },
        }
      },
    },
  ],
  
  // Сервисы
  services: [
    new NewFeatureService(),
  ],
  
  // Инициализация
  init: async (brain) => {
    // Инициализация плагина
    console.log(`Plugin ${newFeaturePlugin.name} initialized`)
  },
  
  // Уничтожение
  destroy: async () => {
    // Очистка ресурсов
    console.log(`Plugin ${newFeaturePlugin.name} destroyed`)
  },
}

// 2. Регистрируем плагин
const pluginManager = new PluginManager()
await pluginManager.registerPlugin(newFeaturePlugin)
await pluginManager.initializePlugin(newFeaturePlugin)

// 3. Используем в коде
const brain = await getAvatarBrain(ctx.from.id, ctx.botInfo.username)
const result = await executePluginAction(
  brain,
  'new-feature',
  'EXECUTE_NEW_FEATURE',
  {
    telegramId: ctx.from.id,
    data: { input: 'test' },
  }
)
```

### 🧪 Тестирование в агентной разработке (TDD + Функциональный стиль)

#### Принципы тестирования

1. **Test-Driven Development (TDD)**: Сначала тесты, потом код
2. **100% покрытие тестами**: Все функции должны быть покрыты тестами
3. **Функциональное тестирование**: Тестирование чистых функций без побочных эффектов
4. **Property-Based Testing**: Тестирование свойств функций, а не конкретных значений
5. **Моки и стабы**: Использование функциональных моков для изоляции

#### Примеры тестов в функциональном стиле

```typescript
/**
 * Тестирование функциональных действий
 */
import { describe, it, expect } from 'vitest'
import { pipe, chain, map } from '@/core/functional/utils/composition'
import { TaskEither, right, left } from '@/core/functional/utils/result'
import { runTaskEither } from '@/core/functional/utils/result'

describe('NeuroPhotoAction', () => {
  describe('validate', () => {
    it('should return Right(true) when balance is sufficient', () => {
      const brain = createMockBrain({ balance: { stars: 100 } })
      const context = createMockContext()
      
      const result = neuroPhotoAction.validate(brain, context)
      
      expect(result._tag).toBe('Right')
      if (result._tag === 'Right') {
        expect(result.right).toBe(true)
      }
    })
    
    it('should return Left(ValidationError) when balance is insufficient', () => {
      const brain = createMockBrain({ balance: { stars: 5 } })
      const context = createMockContext()
      
      const result = neuroPhotoAction.validate(brain, context)
      
      expect(result._tag).toBe('Left')
      if (result._tag === 'Left') {
        expect(result.left.message).toContain('Недостаточно звезд')
      }
    })
  })
  
  describe('handler', () => {
    it('should generate photo successfully', async () => {
      const brain = createMockBrain({ balance: { stars: 100 } })
      const context = createMockContext({ prompt: 'test prompt' })
      
      const result = await runTaskEither(
        neuroPhotoAction.handler(brain, context)
      )
      
      expect(result._tag).toBe('Right')
      if (result._tag === 'Right') {
        expect(result.right.success).toBe(true)
        expect(result.right.data.assetId).toBeDefined()
      }
    })
    
    it('should return Left when generation fails', async () => {
      const brain = createMockBrain({ balance: { stars: 100 } })
      const context = createMockContext({ prompt: 'test prompt' })
      
      // Мокируем ошибку генерации
      mockGenerateNeuroPhoto.mockRejectedValueOnce(new Error('Generation failed'))
      
      const result = await runTaskEither(
        neuroPhotoAction.handler(brain, context)
      )
      
      expect(result._tag).toBe('Left')
      if (result._tag === 'Left') {
        expect(result.left.message).toContain('Generation failed')
      }
    })
  })
})

/**
 * Property-Based Testing для функциональных функций
 */
describe('FunctionTransformer', () => {
  it('should preserve immutability when creating operation', () => {
    const plugin = createMockPlugin()
    const data = { telegramId: 123, botName: 'test', cost: 10 }
    
    const operation = FunctionTransformer.createOperation(plugin, data)
    
    // Проверяем, что исходные данные не изменились
    expect(data.cost).toBe(10)
    expect(operation.cost).toBe(10)
    expect(operation).not.toBe(data) // Новый объект
  })
  
  it('should always return valid operation structure', () => {
    const plugin = createMockPlugin()
    const data = { telegramId: 123, botName: 'test', cost: 10 }
    
    const operation = FunctionTransformer.createOperation(plugin, data)
    
    // Проверяем структуру
    expect(operation).toHaveProperty('id')
    expect(operation).toHaveProperty('telegram_id')
    expect(operation).toHaveProperty('bot_name')
    expect(operation).toHaveProperty('type')
    expect(operation).toHaveProperty('service_type')
    expect(operation).toHaveProperty('status')
    expect(operation).toHaveProperty('cost')
  })
})

/**
 * Интеграционные тесты для пайплайнов
 */
describe('NeuroPhotoPipeline', () => {
  it('should process full pipeline successfully', async () => {
    const input = { prompt: 'test', userId: '123' }
    
    const result = await runTaskEither(
      pipe(
        validateInput(input),
        chain(getUserTask),
        chain(checkBalanceTask(10)),
        chain(deductBalanceTask(10)),
        chain(generateNeuroPhotoTask),
        chain(saveAssetTask),
        map(asset => ({ success: true, assetId: asset.id }))
      )
    )
    
    expect(result._tag).toBe('Right')
    if (result._tag === 'Right') {
      expect(result.right.success).toBe(true)
      expect(result.right.assetId).toBeDefined()
    }
  })
  
  it('should fail gracefully when balance is insufficient', async () => {
    const input = { prompt: 'test', userId: '123' }
    mockGetUser.mockResolvedValue({ balance: { stars: 5 } })
    
    const result = await runTaskEither(
      pipe(
        validateInput(input),
        chain(getUserTask),
        chain(checkBalanceTask(10)),
        chain(deductBalanceTask(10)),
        chain(generateNeuroPhotoTask),
        chain(saveAssetTask),
        map(asset => ({ success: true, assetId: asset.id }))
      )
    )
    
    expect(result._tag).toBe('Left')
    if (result._tag === 'Left') {
      expect(result.left.message).toContain('Недостаточно баланса')
    }
  })
})
```

#### Моки и стабы в функциональном стиле

```typescript
/**
 * Функциональные моки для тестирования
 */
import { TaskEither, right, left } from '@/core/functional/utils/result'

// Мок для getUserTask
export const createMockGetUserTask = (
  user: UserProfile | null
): TaskEither<Error, UserProfile> =>
  () => Promise.resolve(
    user ? right(user) : left(new Error('User not found'))
  )

// Мок для saveOperationTask
export const createMockSaveOperationTask = (
  shouldFail: boolean = false
): TaskEither<Error, Operation> =>
  (operation: Operation) => Promise.resolve(
    shouldFail
      ? left(new Error('Save failed'))
      : right(operation)
  )

// Использование в тестах
describe('PluginHandler', () => {
  it('should handle user not found', async () => {
    const mockGetUser = createMockGetUserTask(null)
    
    const result = await runTaskEither(
      pipe(
        mockGetUser,
        chain(processUserTask)
      )
    )
    
    expect(result._tag).toBe('Left')
  })
})
```

### 🚨 Частые ошибки при использовании плагинной архитектуры и функционального программирования

1. **Создание отдельных моделей для каждой функции** ❌
   - Правильно: Использовать единую модель `AvatarBrain`
   
2. **Отсутствие трансформера** ❌
   - Правильно: Использовать `FunctionTransformer` для преобразования данных
   
3. **Отсутствие валидации** ❌
   - Правильно: Всегда валидировать через `validate` функцию действия
   
4. **Неправильный возврат из Provider** ❌
   - Правильно: Возвращать `ProviderResult` объект, не строку
   
5. **Использование throw/catch вместо TaskEither** ❌
   - Правильно: Использовать `TaskEither<Error, Success>` для обработки ошибок
   
6. **Мутация данных** ❌
   - Правильно: Всегда создавать новые объекты, не мутировать существующие
   
7. **Побочные эффекты в чистых функциях** ❌
   - Правильно: Использовать `tap` или `tapTask` для side effects
   
8. **Игнорирование жизненного цикла плагина** ❌
   - Правильно: Реализовать `init` и `destroy` методы
   
9. **Создание отдельных таблиц для каждой функции** ❌
   - Правильно: Использовать единые таблицы `assets` и `operations` с полем `service_type`
   
10. **Отсутствие тестов** ❌
    - Правильно: Писать тесты перед кодом (TDD), стремиться к 100% покрытию

---

## 🤖 VIBE Агенты: Техническое задание на разработку специализированных агентов

> **🎯 Цель**: Создание армии специализированных агентов с префиксом VIBE для реализации суперагента VIBEE  
> **📋 Статус**: ТЗ для разработки  
> **🌱 Философия**: Этот документ - семя, которое вырастет в суперагента VIBEE

---

### 🎯 Концепция VIBE Агентов

**VIBEE (VIBE Ecosystem Engine)** - это суперагент, состоящий из специализированных агентов VIBE, каждый из которых отвечает за конкретную область функциональности бота.

**Принципы архитектуры VIBE агентов:**
- ✅ **Специализация**: Каждый агент отвечает за одну область
- ✅ **Функциональный стиль**: Все агенты используют TaskEither, pipe, immutability
- ✅ **Роевой интеллект**: Координация через королеву (Queen)
- ✅ **Единая модель данных**: Все используют AvatarBrain
- ✅ **Валидация**: Zod для всех входных данных
- ✅ **Тестирование**: 100% покрытие тестами (TDD)

---

### 📋 Список специализированных VIBE агентов

#### 1. 🤖 VIBE-IMAGE-GENERATOR
**Назначение**: Генерация изображений через AI модели

**Функции бота**:
- 📸 Нейрофото (`NeuroPhoto`)
- 🖼️ Текст в фото (`TextToImage`)
- 🔍 Промпт из фото (`ImageToPrompt`)

**Технические требования**:
- **Модель**: Minimax M2 через OpenRouter API
- **Входные данные**: `prompt`, `modelId`, `aspectRatio`, `numImages`
- **Выходные данные**: Массив URL изображений
- **Валидация**: Zod схемы для промпта и параметров
- **База данных**: Сохранение в `assets` через Drizzle ORM
- **Баланс**: Списание 7.5⭐ за изображение

**Интерфейс агента**:
```typescript
interface VIBEImageGeneratorAgent {
  name: 'VIBE-IMAGE-GENERATOR'
  version: '1.0.0'
  
  actions: {
    generateFromPrompt: (input: GenerateImageInput) => TaskEither<Error, ImageResult[]>
    generateFromModel: (input: GenerateFromModelInput) => TaskEither<Error, ImageResult[]>
    extractPrompt: (input: ExtractPromptInput) => TaskEither<Error, ExtractedPrompt>
  }
  
  providers: {
    getUserModel: (telegramId: number, botName: BotName) => TaskEither<Error, UserModel>
    getModelConfig: (modelId: string) => TaskEither<Error, ModelConfig>
  }
  
  services: {
    validateBalance: (telegramId: number, cost: number) => TaskEither<Error, boolean>
    deductBalance: (telegramId: number, cost: number) => TaskEither<Error, boolean>
    saveAsset: (asset: Asset) => TaskEither<Error, Asset>
  }
}
```

**Пример использования**:
```typescript
const result = await runTaskEither(
  pipe(
    validate(GenerateImageInputSchema, userInput),
    chain(input => VIBEImageGenerator.generateFromPrompt(input)),
    chain(images => VIBEImageGenerator.saveAssets(images))
  )
)
```

---

#### 2. 🎥 VIBE-VIDEO-GENERATOR
**Назначение**: Генерация видео через AI модели

**Функции бота**:
- 🎥 Видео из текста (`TextToVideo`)
- 🎥 Фото в видео (`ImageToVideo`)
- 🎬 ИИ Рилс (`ai_reels`)

**Технические требования**:
- **Модели**: Replicate, FAL, HeyGen, Sora через OpenRouter
- **Входные данные**: `prompt`, `imageUrl`, `duration`, `aspectRatio`
- **Выходные данные**: URL видео файла
- **Асинхронность**: Обработка через Inngest (1-2 часа)
- **Прогресс**: Уведомления о прогрессе генерации

**Интерфейс агента**:
```typescript
interface VIBEVideoGeneratorAgent {
  name: 'VIBE-VIDEO-GENERATOR'
  version: '1.0.0'
  
  actions: {
    generateFromText: (input: TextToVideoInput) => TaskEither<Error, VideoJob>
    generateFromImage: (input: ImageToVideoInput) => TaskEither<Error, VideoJob>
    generateReels: (input: ReelsInput) => TaskEither<Error, ReelsJob>
    checkProgress: (jobId: string) => TaskEither<Error, JobStatus>
  }
  
  services: {
    createInngestJob: (event: VideoGenerationEvent) => TaskEither<Error, string>
    updateJobStatus: (jobId: string, status: JobStatus) => TaskEither<Error, void>
    notifyUser: (telegramId: number, message: string) => TaskEither<Error, void>
  }
}
```

---

#### 3. 🎓 VIBE-MODEL-TRAINER
**Назначение**: Обучение персональных AI моделей

**Функции бота**:
- 🤖 Цифровое тело (`DigitalAvatarBody`)

**Технические требования**:
- **Провайдеры**: Replicate Training API, FAL Training
- **Входные данные**: `images[]`, `modelName`, `gender`, `trainingType`
- **Выходные данные**: Обученная модель с `model_url` и `trigger_word`
- **Длительность**: 1-2 часа асинхронного обучения
- **Стоимость**: 220-550⭐ в зависимости от типа обучения

**Интерфейс агента**:
```typescript
interface VIBEModelTrainerAgent {
  name: 'VIBE-MODEL-TRAINER'
  version: '1.0.0'
  
  actions: {
    startTraining: (input: TrainingInput) => TaskEither<Error, TrainingJob>
    validateImages: (images: File[]) => TaskEither<Error, ValidationResult>
    checkTrainingStatus: (jobId: string) => TaskEither<Error, TrainingStatus>
  }
  
  providers: {
    getTrainingConfig: (trainingType: 'portrait' | 'fast') => TrainingConfig
    getProvider: (provider: 'replicate' | 'fal') => TrainingProvider
  }
  
  services: {
    uploadImages: (images: File[]) => TaskEither<Error, string[]>
    createTrainingJob: (config: TrainingConfig) => TaskEither<Error, string>
    saveModel: (model: TrainedModel) => TaskEither<Error, UserModel>
  }
}
```

---

#### 4. 🧠 VIBE-AVATAR-BRAIN
**Назначение**: Управление аватарами и чат с аватарами

**Функции бота**:
- 🧠 Мозг аватара (`Avatar`)
- 💭 Чат с аватаром (`ChatWithAvatar`)
- 🤖 Выбор модели ИИ (`SelectModel`)
- 🎤 Голос аватара (`Voice`)

**Технические требования**:
- **Модель**: Minimax M2 для чата
- **Входные данные**: `prompt`, `userData`, `languageCode`
- **Выходные данные**: Текстовый ответ от AI
- **Контекст**: Использование AvatarBrain для хранения контекста
- **Голос**: Интеграция с ElevenLabs для генерации голоса

**Интерфейс агента**:
```typescript
interface VIBEAvatarBrainAgent {
  name: 'VIBE-AVATAR-BRAIN'
  version: '1.0.0'
  
  actions: {
    chat: (input: ChatInput) => TaskEither<Error, ChatResponse>
    updateAvatar: (input: UpdateAvatarInput) => TaskEither<Error, Avatar>
    selectModel: (input: SelectModelInput) => TaskEither<Error, void>
    generateVoice: (input: VoiceInput) => TaskEither<Error, VoiceResult>
  }
  
  providers: {
    getAvatarBrain: (telegramId: number, botName: BotName) => TaskEither<Error, AvatarBrain>
    getConversationHistory: (telegramId: number) => TaskEither<Error, Message[]>
  }
  
  services: {
    saveConversation: (message: Message) => TaskEither<Error, void>
    updateAvatarSettings: (settings: AvatarSettings) => TaskEither<Error, void>
  }
}
```

---

#### 5. 🎨 VIBE-MEDIA-PROCESSOR
**Назначение**: Обработка и трансформация медиа файлов

**Функции бота**:
- 🎨 ИИ Фотошоп (`ai_photoshop`)
- ⬆️ Увеличить качество фото (`ImageUpscaler`)
- 🌀 Infinity Морфинг (`morphing`)
- 🎭 Замена лица (`face_swap`)
- 🎤 Синхронизация губ (`lip_sync`)

**Технические требования**:
- **Провайдеры**: Replicate, FAL, SyncLabs, HeyGen
- **Входные данные**: `imageUrl` | `videoUrl`, `operationType`, `parameters`
- **Выходные данные**: Обработанный медиа файл
- **Операции**: Редактирование, апскейлинг, морфинг, замена лица, синхронизация губ

**Интерфейс агента**:
```typescript
interface VIBEMediaProcessorAgent {
  name: 'VIBE-MEDIA-PROCESSOR'
  version: '1.0.0'
  
  actions: {
    processImage: (input: ImageProcessInput) => TaskEither<Error, ProcessedImage>
    upscaleImage: (input: UpscaleInput) => TaskEither<Error, UpscaledImage>
    morphImages: (input: MorphInput) => TaskEither<Error, MorphedImage>
    swapFace: (input: FaceSwapInput) => TaskEither<Error, SwappedImage>
    syncLips: (input: LipSyncInput) => TaskEither<Error, SyncedVideo>
  }
  
  providers: {
    getProcessor: (operation: OperationType) => TaskEither<Error, Processor>
    validateMedia: (url: string, type: 'image' | 'video') => TaskEither<Error, ValidationResult>
  }
  
  services: {
    downloadMedia: (url: string) => TaskEither<Error, Buffer>
    uploadMedia: (buffer: Buffer, type: string) => TaskEither<Error, string>
  }
}
```

---

#### 6. 💰 VIBE-PAYMENT-HANDLER
**Назначение**: Управление платежами, балансом и подписками

**Функции бота**:
- 💫 Оформить подписку (`SubscriptionScene`)
- 💎 Пополнить баланс (`TopUpBalance`)
- 💰 Баланс (`Balance`)

**Технические требования**:
- **Провайдеры**: Robokassa, Stripe, Telegram Stars
- **Входные данные**: `amount`, `currency`, `paymentMethod`, `subscriptionType`
- **Выходные данные**: `paymentUrl`, `paymentStatus`, `balance`
- **Безопасность**: Атомарные транзакции через Drizzle ORM
- **Валидация**: Zod схемы для всех платежных данных

**Интерфейс агента**:
```typescript
interface VIBEPaymentHandlerAgent {
  name: 'VIBE-PAYMENT-HANDLER'
  version: '1.0.0'
  
  actions: {
    createPayment: (input: PaymentInput) => TaskEither<Error, PaymentResult>
    processWebhook: (input: WebhookInput) => TaskEither<Error, void>
    getBalance: (telegramId: number, botName: BotName) => TaskEither<Error, Balance>
    createSubscription: (input: SubscriptionInput) => TaskEither<Error, Subscription>
    cancelSubscription: (subscriptionId: string) => TaskEither<Error, void>
  }
  
  providers: {
    getPaymentProvider: (method: PaymentMethod) => TaskEither<Error, PaymentProvider>
    validatePayment: (paymentData: PaymentData) => TaskEither<Error, ValidationResult>
  }
  
  services: {
    deductBalance: (telegramId: number, amount: number, currency: Currency) => TaskEither<Error, boolean>
    addBalance: (telegramId: number, amount: number, currency: Currency) => TaskEither<Error, boolean>
    updateSubscription: (subscriptionId: string, status: SubscriptionStatus) => TaskEither<Error, void>
  }
}
```

---

#### 7. 🧭 VIBE-NAVIGATION-MASTER
**Назначение**: Управление навигацией, меню и пользовательским интерфейсом

**Функции бота**:
- 🏠 Главное меню
- 🌐 EN/RU (`language`)
- 👥 Пригласить друга (`Invite`)
- 💬 Техподдержка (`Help`)

**Технические требования**:
- **i18n**: Автоматическая генерация переводов из `NAVIGATION_BUTTONS`
- **Входные данные**: `buttonText`, `languageCode`, `telegramId`
- **Выходные данные**: Переведенный текст, клавиатура меню
- **Кэширование**: Кэш переводов для быстрого доступа

**Интерфейс агента**:
```typescript
interface VIBENavigationMasterAgent {
  name: 'VIBE-NAVIGATION-MASTER'
  version: '1.0.0'
  
  actions: {
    getTranslation: (key: string, languageCode: string, botName?: BotName) => TaskEither<Error, Translation>
    createMenu: (languageCode: string, botName: BotName) => TaskEither<Error, MenuKeyboard>
    handleButton: (buttonText: string, context: NavigationContext) => TaskEither<Error, NavigationResult>
    switchLanguage: (telegramId: number, languageCode: string) => TaskEither<Error, void>
  }
  
  providers: {
    getTranslations: (keys: string[], languageCode: string) => TaskEither<Error, Translation[]>
    getNavigationConfig: (botName: BotName) => TaskEither<Error, NavigationConfig>
  }
  
  services: {
    generateTranslations: () => TaskEither<Error, void>
    updateUserLanguage: (telegramId: number, languageCode: string) => TaskEither<Error, void>
  }
}
```

---

#### 8. 📊 VIBE-ANALYTICS-AGENT
**Назначение**: Аналитика, мониторинг и бизнес-метрики

**Функции бота**:
- 🔍 Мониторинг конкурентов (`competitor_monitoring`)
- 📈 Аналитика использования функций
- 🎬 ИИ Рилс (аналитика контента)

**Технические требования**:
- **Входные данные**: `competitorUsername`, `analyticsPeriod`, `metricsType`
- **Выходные данные**: Аналитические отчеты, метрики, графики
- **Хранение**: Сохранение аналитики в БД для исторических данных
- **Визуализация**: Генерация графиков и отчетов

**Интерфейс агента**:
```typescript
interface VIBEAnalyticsAgent {
  name: 'VIBE-ANALYTICS-AGENT'
  version: '1.0.0'
  
  actions: {
    analyzeCompetitor: (input: CompetitorAnalysisInput) => TaskEither<Error, CompetitorReport>
    trackUsage: (input: UsageTrackingInput) => TaskEither<Error, void>
    generateReport: (input: ReportInput) => TaskEither<Error, Report>
    getMetrics: (input: MetricsInput) => TaskEither<Error, Metrics>
  }
  
  providers: {
    getCompetitorData: (username: string) => TaskEither<Error, CompetitorData>
    getUsageStats: (period: TimePeriod) => TaskEither<Error, UsageStats>
  }
  
  services: {
    saveAnalytics: (data: AnalyticsData) => TaskEither<Error, void>
    generateVisualization: (data: Metrics) => TaskEither<Error, string>
  }
}
```

---

#### 9. 🔒 VIBE-VALIDATION-GUARDIAN
**Назначение**: Валидация всех данных через Zod и обеспечение безопасности

**Технические требования**:
- **Валидация**: Все входные данные через Zod схемы
- **Безопасность**: Проверка прав доступа, rate limiting
- **Входные данные**: Любые данные от пользователя или API
- **Выходные данные**: Валидированные данные или ошибки валидации

**Интерфейс агента**:
```typescript
interface VIBEValidationGuardianAgent {
  name: 'VIBE-VALIDATION-GUARDIAN'
  version: '1.0.0'
  
  actions: {
    validate: <T extends z.ZodTypeAny>(schema: T, data: unknown) => TaskEither<z.ZodError, z.infer<T>>
    validateUser: (telegramId: number, botName: BotName) => TaskEither<Error, User>
    validateBalance: (telegramId: number, requiredAmount: number) => TaskEither<Error, boolean>
    validateSubscription: (telegramId: number, requiredType: SubscriptionType) => TaskEither<Error, boolean>
    checkRateLimit: (telegramId: number, action: string) => TaskEither<Error, boolean>
  }
  
  providers: {
    getValidationSchema: (action: string) => TaskEither<Error, z.ZodTypeAny>
    getUserPermissions: (telegramId: number) => TaskEither<Error, Permissions>
  }
  
  services: {
    recordRateLimit: (telegramId: number, action: string) => TaskEither<Error, void>
    logValidationError: (error: ValidationError) => TaskEither<Error, void>
  }
}
```

---

#### 10. 🐝 VIBE-QUEEN-COORDINATOR
**Назначение**: Координация всех VIBE агентов через роевой интеллект

**Технические требования**:
- **Координация**: Распределение задач между агентами
- **Мониторинг**: Отслеживание состояния всех агентов
- **Балансировка**: Распределение нагрузки между агентами
- **Отказоустойчивость**: Автоматическое переключение на резервных агентов

**Интерфейс агента**:
```typescript
interface VIBEQueenCoordinatorAgent {
  name: 'VIBE-QUEEN-COORDINATOR'
  version: '1.0.0'
  
  actions: {
    distributeTask: (task: Task) => TaskEither<Error, TaskAssignment>
    getSwarmMetrics: () => TaskEither<Error, SwarmMetrics>
    registerAgent: (agent: AgentInfo) => TaskEither<Error, void>
    unregisterAgent: (agentId: string) => TaskEither<Error, void>
    healthCheck: (agentId: string) => TaskEither<Error, HealthStatus>
  }
  
  providers: {
    getAvailableAgents: (taskType: TaskType) => TaskEither<Error, Agent[]>
    getAgentLoad: (agentId: string) => TaskEither<Error, LoadMetrics>
  }
  
  services: {
    updateTaskStatus: (taskId: string, status: TaskStatus) => TaskEither<Error, void>
    notifyAgent: (agentId: string, message: TaskMessage) => TaskEither<Error, void>
  }
}
```

---

### 🏗️ Архитектура VIBE агентов

#### Общая структура агента:

```typescript
/**
 * Базовый интерфейс для всех VIBE агентов
 */
interface VIBEAgent {
  // Идентификация
  name: string // Формат: 'VIBE-{SPECIALIZATION}'
  version: string
  description: string
  
  // Компоненты (ElizaOS-based)
  actions: Record<string, ActionHandler>
  providers: Record<string, ProviderHandler>
  services: Record<string, ServiceHandler>
  evaluators?: Record<string, EvaluatorHandler>
  
  // Конфигурация
  config: AgentConfig
  
  // Жизненный цикл
  init: () => TaskEither<Error, void>
  destroy: () => TaskEither<Error, void>
  
  // Регистрация в рое
  registerWithQueen: (queenId: string) => TaskEither<Error, void>
}
```

#### Пример реализации агента:

```typescript
// src/agents/vibe-image-generator/index.ts
import { TaskEither, tryCatchAsync } from '@/core/functional/utils/result'
import { pipe, chain } from '@/core/functional/utils/composition'
import { validate } from '@/core/validation/validate'
import { GenerateImageInputSchema } from '@/core/validation/schemas'
import { db } from '@/core/drizzle/client'
import { assets } from '@/core/drizzle/schema'

export const VIBEImageGeneratorAgent: VIBEAgent = {
  name: 'VIBE-IMAGE-GENERATOR',
  version: '1.0.0',
  description: 'Генерация изображений через AI модели',
  
  actions: {
    generateFromPrompt: (input: GenerateImageInput) =>
      pipe(
        validate(GenerateImageInputSchema, input),
        chain(validatedInput => 
          pipe(
            checkBalance(validatedInput.telegramId, validatedInput.cost),
            chain(() => callOpenRouterAPI(validatedInput)),
            chain(images => saveAssets(images))
          )
        )
      ),
  },
  
  providers: {
    getUserModel: (telegramId: number, botName: BotName) =>
      getUserModelFromDB(telegramId, botName),
  },
  
  services: {
    validateBalance: (telegramId: number, cost: number) =>
      checkBalance(telegramId, cost),
      
    deductBalance: (telegramId: number, cost: number) =>
      deductBalanceAtomically(telegramId, cost),
      
    saveAsset: (asset: Asset) =>
      saveAssetToDB(asset),
  },
  
  config: {
    model: 'minimax/minimax-m2',
    temperature: 0.7,
    maxTokens: 2000,
  },
  
  init: () => tryCatchAsync(
    async () => {
      // Инициализация агента
      console.log('VIBE-IMAGE-GENERATOR initialized')
    },
    (error) => error instanceof Error ? error : new Error(String(error))
  ),
  
  destroy: () => tryCatchAsync(
    async () => {
      // Очистка ресурсов
      console.log('VIBE-IMAGE-GENERATOR destroyed')
    },
    (error) => error instanceof Error ? error : new Error(String(error))
  ),
  
  registerWithQueen: (queenId: string) =>
    registerAgentWithQueen(queenId, 'VIBE-IMAGE-GENERATOR'),
}
```

---

### 📋 Чек-лист разработки VIBE агента

Для каждого агента необходимо:

- [ ] **1. Определение интерфейса**
  - [ ] Определить `actions` (основные действия агента)
  - [ ] Определить `providers` (источники данных)
  - [ ] Определить `services` (сервисы агента)
  - [ ] Определить `evaluators` (если нужны)

- [ ] **2. Создание Zod схем**
  - [ ] Схемы для всех входных данных
  - [ ] Схемы для всех выходных данных
  - [ ] Схемы для конфигурации агента

- [ ] **3. Реализация в функциональном стиле**
  - [ ] Использование `TaskEither` для всех операций
  - [ ] Использование `pipe` для композиции
  - [ ] Иммутабельность всех данных
  - [ ] Чистые функции без побочных эффектов

- [ ] **4. Интеграция с БД**
  - [ ] Использование Drizzle ORM
  - [ ] Работа с AvatarBrain
  - [ ] Сохранение результатов в БД

- [ ] **5. Тестирование (TDD)**
  - [ ] Написание тестов перед кодом
  - [ ] 100% покрытие тестами
  - [ ] Функциональные тесты
  - [ ] Property-based тесты

- [ ] **6. Регистрация в рое**
  - [ ] Регистрация в королеве (Queen)
  - [ ] Определение специализаций
  - [ ] Настройка метрик производительности

- [ ] **7. Документация**
  - [ ] Описание агента
  - [ ] Примеры использования
  - [ ] API документация

---

### 🎯 Приоритет разработки агентов

**Фаза 1 (Критичные)**:
1. ✅ VIBE-VALIDATION-GUARDIAN (основа безопасности)
2. ✅ VIBE-QUEEN-COORDINATOR (координация роя)
3. ✅ VIBE-PAYMENT-HANDLER (финансы)

**Фаза 2 (Основной функционал)**:
4. ✅ VIBE-IMAGE-GENERATOR (генерация изображений)
5. ✅ VIBE-VIDEO-GENERATOR (генерация видео)
6. ✅ VIBE-AVATAR-BRAIN (чат с аватаром)

**Фаза 3 (Расширенный функционал)**:
7. ✅ VIBE-MODEL-TRAINER (обучение моделей)
8. ✅ VIBE-MEDIA-PROCESSOR (обработка медиа)
9. ✅ VIBE-NAVIGATION-MASTER (навигация)
10. ✅ VIBE-ANALYTICS-AGENT (аналитика)

---

### 🔗 Связанные документы

- [NAVIGATION_ANALYSIS.md](./NAVIGATION_ANALYSIS.md) - Анализ навигации
- [CLAUDE.md](./CLAUDE.md) - Общая документация проекта
- [INNGEST_DEVELOPMENT_RULES.md](./INNGEST_DEVELOPMENT_RULES.md) - Правила работы с Inngest

---

---

## 🚀 Быстрый старт для разработчиков VIBE агентов

### 📝 Минимальный пример создания VIBE агента

```typescript
// src/agents/vibe-example/index.ts
import { TaskEither, tryCatchAsync } from '@/core/functional/utils/result'
import { pipe, chain } from '@/core/functional/utils/composition'
import { validate } from '@/core/validation/validate'
import { z } from 'zod'
import { db } from '@/core/drizzle/client'

// 1. Определяем Zod схему для входных данных
const ExampleInputSchema = z.object({
  telegramId: z.number().int().positive(),
  botName: z.enum(['neuro_blogger_bot', 'AI_STARS_bot', /* ... */]),
  data: z.string().min(1),
})

type ExampleInput = z.infer<typeof ExampleInputSchema>

// 2. Создаем агента
export const VIBEExampleAgent: VIBEAgent = {
  name: 'VIBE-EXAMPLE',
  version: '1.0.0',
  description: 'Пример VIBE агента',
  
  actions: {
    process: (input: ExampleInput) =>
      pipe(
        validate(ExampleInputSchema, input),
        chain(validatedInput => 
          tryCatchAsync(
            async () => {
              // Логика обработки
              const result = await processData(validatedInput.data)
              return result
            },
            (error) => error instanceof Error ? error : new Error(String(error))
          )
        )
      ),
  },
  
  providers: {
    getUser: (telegramId: number, botName: BotName) =>
      getUserFromDB(telegramId, botName),
  },
  
  services: {
    saveResult: (result: any) =>
      saveResultToDB(result),
  },
  
  config: {
    model: 'minimax/minimax-m2',
  },
  
  init: () => tryCatchAsync(
    async () => {
      console.log('VIBE-EXAMPLE initialized')
    },
    (error) => error instanceof Error ? error : new Error(String(error))
  ),
  
  destroy: () => tryCatchAsync(
    async () => {
      console.log('VIBE-EXAMPLE destroyed')
    },
    (error) => error instanceof Error ? error : new Error(String(error))
  ),
  
  registerWithQueen: (queenId: string) =>
    registerAgentWithQueen(queenId, 'VIBE-EXAMPLE'),
}
```

### 🔗 Интеграция с королевой (Queen)

```typescript
// Регистрация агента в рое
const result = await runTaskEither(
  VIBEExampleAgent.registerWithQueen(queenId)
)

fold(
  (error: Error) => {
    logger.error('Failed to register agent:', error)
  },
  () => {
    logger.info('Agent registered successfully')
  }
)(result)
```

### 📊 Использование агента через королеву

```typescript
// Распределение задачи через королеву
const taskResult = await runTaskEither(
  distributeTask(queenId, 'example', {
    telegramId: 123456789,
    botName: 'neuro_blogger_bot',
    data: 'test data',
  })
)

fold(
  (error: Error) => {
    logger.error('Task distribution failed:', error)
  },
  (taskId: string) => {
    logger.info(`Task ${taskId} distributed to VIBE-EXAMPLE`)
  }
)(taskResult)
```

---

## 🐛 Troubleshooting Guide

### Проблема 1: Агент не регистрируется в рое

**Симптомы**: Агент не появляется в списке доступных агентов

**Решение**:
1. Проверить подключение к БД
2. Проверить правильность `queenId`
3. Проверить логи инициализации агента
4. Убедиться, что агент вызвал `registerWithQueen`

### Проблема 2: Ошибки валидации Zod

**Симптомы**: `ZodError` при валидации входных данных

**Решение**:
1. Проверить схему Zod на соответствие данным
2. Добавить `.optional()` для необязательных полей
3. Использовать `.default()` для значений по умолчанию
4. Проверить типы данных перед валидацией

### Проблема 3: Ошибки Drizzle ORM

**Симптомы**: Ошибки при запросах к БД

**Решение**:
1. Проверить подключение к БД (`DATABASE_URL`)
2. Проверить правильность схемы Drizzle
3. Убедиться, что таблицы созданы в БД
4. Проверить права доступа к БД

### Проблема 4: Баланс не списывается

**Симптомы**: Операция выполняется, но баланс не изменяется

**Решение**:
1. Проверить использование транзакций Drizzle
2. Убедиться в атомарности операции
3. Проверить логику `deductBalanceAtomically`
4. Проверить наличие достаточного баланса

### Проблема 5: Агент не получает задачи

**Симптомы**: Задачи не распределяются на агента

**Решение**:
1. Проверить статус агента (`idle` или `busy`)
2. Проверить специализации агента
3. Проверить загрузку агента (`load_percentage < 80`)
4. Проверить логи королевы

---

## 📊 Диаграммы архитектуры

### Архитектура системы VIBEE

```
┌─────────────────────────────────────────────────────────┐
│                    VIBEE Ecosystem                      │
│              (VIBE Ecosystem Engine)                     │
└─────────────────────────────────────────────────────────┘
                            │
                            ▼
        ┌───────────────────────────────────┐
        │   VIBE-QUEEN-COORDINATOR          │
        │   (Центральный координатор)       │
        └───────────────────────────────────┘
                            │
        ┌───────────────────┼───────────────────┐
        │                   │                   │
        ▼                   ▼                   ▼
┌──────────────┐   ┌──────────────┐   ┌──────────────┐
│ VIBE-IMAGE- │   │ VIBE-VIDEO-  │   │ VIBE-AVATAR- │
│  GENERATOR   │   │  GENERATOR   │   │    BRAIN     │
└──────────────┘   └──────────────┘   └──────────────┘
        │                   │                   │
        ▼                   ▼                   ▼
┌──────────────┐   ┌──────────────┐   ┌──────────────┐
│ VIBE-MODEL-  │   │ VIBE-MEDIA-  │   │ VIBE-PAYMENT │
│   TRAINER    │   │  PROCESSOR   │   │   HANDLER    │
└──────────────┘   └──────────────┘   └──────────────┘
        │                   │                   │
        ▼                   ▼                   ▼
┌──────────────┐   ┌──────────────┐   ┌──────────────┐
│ VIBE-NAVIGA- │   │ VIBE-ANALYT- │   │ VIBE-VALIDA- │
│  TION-MASTER │   │  ICS-AGENT   │   │ TION-GUARDIAN│
└──────────────┘   └──────────────┘   └──────────────┘
                            │
                            ▼
        ┌───────────────────────────────────┐
        │      AvatarBrain (БД)            │
        │   (Единый источник правды)        │
        └───────────────────────────────────┘
```

### Схема взаимодействия агентов

```
User Request
    │
    ▼
Telegram Bot
    │
    ▼
VIBE-QUEEN-COORDINATOR
    │
    ├─► Определяет тип задачи
    │
    ├─► Находит доступных агентов
    │
    ├─► Распределяет задачу
    │
    └─► Мониторит выполнение
         │
         ├─► VIBE-IMAGE-GENERATOR
         │   └─► OpenRouter API → Minimax M2
         │
         ├─► VIBE-VIDEO-GENERATOR
         │   └─► Inngest → Replicate/FAL
         │
         └─► VIBE-PAYMENT-HANDLER
             └─► Robokassa/Stripe
```

---

**Последнее обновление**: 2025-01-12  
**Автор**: НейроКодер 🤖  
**Статус**: ✅ Актуально  
**🌱 Семя для суперагента VIBEE готово к прорастанию!**  
**📊 Документ содержит**: 25 функций бота, 10 VIBE агентов, полную архитектуру, примеры кода, troubleshooting guide

---

## 🤖 Автономная разработка и паттерны самописных агентов

> **🎯 Фундаментальный принцип**: 83% кода должен писаться самими агентами  
> **🌱 Философия**: Система должна уметь сама себя писать, тестировать, улучшать и деплоить

---

### 🎯 Концепция автономной разработки

**VIBEE (VIBE Ecosystem Engine)** - это саморазвивающаяся система, где агенты не только выполняют задачи, но и:
- ✅ **Генерируют код** для новых функций
- ✅ **Пишут тесты** для своего кода (TDD)
- ✅ **Рефакторят** и оптимизируют код
- ✅ **Деплоят** изменения автоматически
- ✅ **Учатся** на ошибках и улучшаются

**Цель**: Достичь 83% автономной генерации кода через специализированных агентов.

---

### 📋 Паттерны автономной разработки

#### 1. 🔄 Self-Coding Pattern (Паттерн самописного кода)

**Принцип**: Агент анализирует требования и генерирует код самостоятельно.

**Компоненты**:
- **Code Analyzer**: Анализирует существующий код и паттерны
- **Code Generator**: Генерирует новый код на основе паттернов
- **Code Validator**: Проверяет соответствие стандартам
- **Code Reviewer**: Проводит код-ревью перед коммитом

**Пример реализации**:
```typescript
interface SelfCodingAgent {
  name: 'VIBE-SELF-CODING'
  version: '1.0.0'
  
  actions: {
    analyzeRequirements: (requirements: Requirements) => TaskEither<Error, CodePlan>
    generateCode: (plan: CodePlan, patterns: Pattern[]) => TaskEither<Error, GeneratedCode>
    validateCode: (code: GeneratedCode) => TaskEither<Error, ValidationResult>
    refactorCode: (code: Code, improvements: Improvement[]) => TaskEither<Error, RefactoredCode>
  }
  
  providers: {
    getPatterns: (type: CodeType) => TaskEither<Error, Pattern[]>
    getBestPractices: (domain: Domain) => TaskEither<Error, BestPractices>
    getExistingCode: (similarity: SimilarityCriteria) => TaskEither<Error, Code[]>
  }
  
  services: {
    saveCode: (code: GeneratedCode) => TaskEither<Error, void>
    createTests: (code: GeneratedCode) => TaskEither<Error, TestSuite>
    createPR: (code: GeneratedCode, tests: TestSuite) => TaskEither<Error, PullRequest>
  }
}
```

**Пример использования**:
```typescript
// Агент генерирует новый VIBE агент автоматически
const result = await runTaskEither(
  pipe(
    VIBESelfCoding.analyzeRequirements({
      name: 'VIBE-NEW-FEATURE',
      description: 'Новая функция для обработки данных',
      requirements: ['validation', 'database', 'api'],
    }),
    chain(plan => 
      pipe(
        VIBESelfCoding.getPatterns('agent'),
        chain(patterns => VIBESelfCoding.generateCode(plan, patterns)),
        chain(code => VIBESelfCoding.validateCode(code)),
        chain(code => VIBESelfCoding.createTests(code)),
        chain(({ code, tests }) => VIBESelfCoding.createPR(code, tests))
      )
    )
  )
)
```

---

#### 2. 🧪 Self-Testing Pattern (Паттерн автономного тестирования)

**Принцип**: Агент автоматически пишет тесты для своего кода (TDD).

**Компоненты**:
- **Test Generator**: Генерирует тесты на основе кода
- **Test Runner**: Запускает тесты
- **Coverage Analyzer**: Анализирует покрытие тестами
- **Test Improver**: Улучшает тесты на основе результатов

**Пример реализации**:
```typescript
interface SelfTestingAgent {
  name: 'VIBE-SELF-TESTING'
  version: '1.0.0'
  
  actions: {
    generateTests: (code: Code, type: TestType) => TaskEither<Error, TestSuite>
    runTests: (tests: TestSuite) => TaskEither<Error, TestResults>
    analyzeCoverage: (code: Code, results: TestResults) => TaskEither<Error, CoverageReport>
    improveTests: (tests: TestSuite, coverage: CoverageReport) => TaskEither<Error, ImprovedTests>
  }
  
  providers: {
    getTestPatterns: (language: Language) => TaskEither<Error, TestPattern[]>
    getTestExamples: (functionType: FunctionType) => TaskEither<Error, TestExample[]>
  }
  
  services: {
    ensure100PercentCoverage: (code: Code) => TaskEither<Error, TestSuite>
    runPropertyBasedTests: (function: Function) => TaskEither<Error, PropertyTestResults>
  }
}
```

---

#### 3. 🔧 Self-Refactoring Pattern (Паттерн автономного рефакторинга)

**Принцип**: Агент постоянно улучшает и оптимизирует свой код.

**Компоненты**:
- **Code Analyzer**: Анализирует качество кода
- **Improvement Detector**: Находит области для улучшения
- **Refactoring Generator**: Генерирует улучшенный код
- **Performance Optimizer**: Оптимизирует производительность

**Пример реализации**:
```typescript
interface SelfRefactoringAgent {
  name: 'VIBE-SELF-REFACTORING'
  version: '1.0.0'
  
  actions: {
    analyzeCodeQuality: (code: Code) => TaskEither<Error, QualityReport>
    detectImprovements: (code: Code, patterns: Pattern[]) => TaskEither<Error, Improvement[]>
    refactorCode: (code: Code, improvements: Improvement[]) => TaskEither<Error, RefactoredCode>
    optimizePerformance: (code: Code) => TaskEither<Error, OptimizedCode>
  }
  
  providers: {
    getRefactoringPatterns: () => TaskEither<Error, RefactoringPattern[]>
    getPerformanceMetrics: (code: Code) => TaskEither<Error, PerformanceMetrics>
  }
  
  services: {
    applySOLIDPrinciples: (code: Code) => TaskEither<Error, RefactoredCode>
    reduceComplexity: (code: Code) => TaskEither<Error, SimplifiedCode>
    improveReadability: (code: Code) => TaskEither<Error, ImprovedCode>
  }
}
```

---

#### 4. 🚀 Self-Deployment Pattern (Паттерн автономного деплоя)

**Принцип**: Агент автоматически деплоит изменения после успешных тестов.

**Компоненты**:
- **Deployment Planner**: Планирует процесс деплоя
- **PreDeployment Checker**: Проверяет готовность к деплою
- **Deployment Executor**: Выполняет деплой
- **PostDeployment Validator**: Проверяет успешность деплоя

**Пример реализации**:
```typescript
interface SelfDeploymentAgent {
  name: 'VIBE-SELF-DEPLOYMENT'
  version: '1.0.0'
  
  actions: {
    planDeployment: (changes: Changes) => TaskEither<Error, DeploymentPlan>
    checkPreDeployment: (plan: DeploymentPlan) => TaskEither<Error, PreDeploymentCheck>
    executeDeployment: (plan: DeploymentPlan) => TaskEither<Error, DeploymentResult>
    validateDeployment: (result: DeploymentResult) => TaskEither<Error, ValidationResult>
  }
  
  providers: {
    getDeploymentConfig: (environment: Environment) => TaskEither<Error, DeploymentConfig>
    getHealthChecks: () => TaskEither<Error, HealthCheck[]>
  }
  
  services: {
    rollbackDeployment: (deploymentId: string) => TaskEither<Error, void>
    notifyDeploymentStatus: (status: DeploymentStatus) => TaskEither<Error, void>
  }
}
```

---

#### 5. 📚 Self-Learning Pattern (Паттерн самообучения)

**Принцип**: Агент учится на ошибках и улучшает свои паттерны.

**Компоненты**:
- **Error Analyzer**: Анализирует ошибки и их причины
- **Pattern Learner**: Изучает успешные паттерны
- **Knowledge Updater**: Обновляет базу знаний
- **Pattern Generator**: Генерирует новые паттерны

**Пример реализации**:
```typescript
interface SelfLearningAgent {
  name: 'VIBE-SELF-LEARNING'
  version: '1.0.0'
  
  actions: {
    analyzeErrors: (errors: Error[]) => TaskEither<Error, ErrorAnalysis>
    learnFromSuccess: (successfulCode: Code) => TaskEither<Error, LearnedPatterns>
    updateKnowledge: (patterns: LearnedPatterns) => TaskEither<Error, void>
    generateNewPatterns: (context: Context) => TaskEither<Error, NewPatterns>
  }
  
  providers: {
    getErrorHistory: (timeframe: Timeframe) => TaskEither<Error, ErrorHistory>
    getSuccessPatterns: (domain: Domain) => TaskEither<Error, SuccessPatterns>
  }
  
  services: {
    savePattern: (pattern: Pattern) => TaskEither<Error, void>
    updateBestPractices: (practices: BestPractices) => TaskEither<Error, void>
  }
}
```

---

### 🏗️ Архитектура автономной разработки

#### Цикл автономной разработки:

```
┌─────────────────────────────────────────────────────────┐
│              Автономный цикл разработки                │
└─────────────────────────────────────────────────────────┘
                    │
                    ▼
        ┌───────────────────────┐
        │  1. Анализ требований │
        │  (VIBE-SELF-CODING)   │
        └───────────────────────┘
                    │
                    ▼
        ┌───────────────────────┐
        │  2. Генерация кода     │
        │  (VIBE-SELF-CODING)   │
        └───────────────────────┘
                    │
                    ▼
        ┌───────────────────────┐
        │  3. Генерация тестов   │
        │  (VIBE-SELF-TESTING)  │
        └───────────────────────┘
                    │
                    ▼
        ┌───────────────────────┐
        │  4. Запуск тестов      │
        │  (VIBE-SELF-TESTING)  │
        └───────────────────────┘
                    │
         ┌──────────┴──────────┐
         │                     │
    ✅ Успех            ❌ Ошибка
         │                     │
         ▼                     ▼
┌─────────────────┐   ┌─────────────────┐
│ 5. Рефакторинг  │   │ 5. Исправление  │
│ (VIBE-SELF-    │   │ (VIBE-SELF-    │
│  REFACTORING)   │   │  LEARNING)      │
└─────────────────┘   └─────────────────┘
         │                     │
         └──────────┬──────────┘
                    │
                    ▼
        ┌───────────────────────┐
        │  6. Деплой            │
        │  (VIBE-SELF-         │
        │   DEPLOYMENT)        │
        └───────────────────────┘
                    │
                    ▼
        ┌───────────────────────┐
        │  7. Мониторинг        │
        │  (VIBE-SELF-LEARNING)│
        └───────────────────────┘
                    │
                    ▼
        ┌───────────────────────┐
        │  8. Обучение          │
        │  (VIBE-SELF-LEARNING)│
        └───────────────────────┘
                    │
                    └──► Цикл повторяется
```

---

### 🎯 Специализированные агенты для автономной разработки

#### 11. 🤖 VIBE-SELF-CODING
**Назначение**: Генерация кода для новых функций и агентов

**Функции**:
- Анализ требований и создание плана разработки
- Генерация кода на основе паттернов проекта
- Валидация кода на соответствие стандартам
- Создание Pull Request с изменениями

**Технические требования**:
- **Модель**: Minimax M2 для генерации кода
- **Входные данные**: `requirements`, `patterns`, `examples`
- **Выходные данные**: Сгенерированный код, тесты, документация
- **Валидация**: Проверка соответствия функциональному стилю, Zod схемам, Drizzle ORM

**Интерфейс агента**:
```typescript
interface VIBESelfCodingAgent {
  name: 'VIBE-SELF-CODING'
  version: '1.0.0'
  
  actions: {
    generateAgent: (spec: AgentSpec) => TaskEither<Error, GeneratedAgent>
    generateFunction: (spec: FunctionSpec) => TaskEither<Error, GeneratedFunction>
    generateTests: (code: Code) => TaskEither<Error, TestSuite>
    generateDocumentation: (code: Code) => TaskEither<Error, Documentation>
  }
  
  providers: {
    getProjectPatterns: () => TaskEither<Error, Pattern[]>
    getCodeExamples: (type: CodeType) => TaskEither<Error, CodeExample[]>
    analyzeExistingCode: (similarity: string) => TaskEither<Error, SimilarCode[]>
  }
  
  services: {
    validateCodeStyle: (code: Code) => TaskEither<Error, ValidationResult>
    createPullRequest: (changes: Changes) => TaskEither<Error, PullRequest>
    updateDocumentation: (docs: Documentation) => TaskEither<Error, void>
  }
}
```

---

#### 12. 🧪 VIBE-SELF-TESTING
**Назначение**: Автоматическое создание и запуск тестов

**Функции**:
- Генерация unit тестов (TDD подход)
- Генерация property-based тестов
- Анализ покрытия кода тестами
- Улучшение тестов на основе результатов

**Технические требования**:
- **Покрытие**: 100% покрытие всех функций
- **Стиль**: Функциональное тестирование
- **Фреймворк**: Jest + функциональные утилиты

**Интерфейс агента**:
```typescript
interface VIBESelfTestingAgent {
  name: 'VIBE-SELF-TESTING'
  version: '1.0.0'
  
  actions: {
    generateUnitTests: (code: Code) => TaskEither<Error, TestSuite>
    generatePropertyTests: (function: Function) => TaskEither<Error, PropertyTests>
    runTests: (tests: TestSuite) => TaskEither<Error, TestResults>
    improveTests: (tests: TestSuite, results: TestResults) => TaskEither<Error, ImprovedTests>
  }
  
  providers: {
    getTestPatterns: () => TaskEither<Error, TestPattern[]>
    getCoverageReport: (code: Code) => TaskEither<Error, CoverageReport>
  }
  
  services: {
    ensure100PercentCoverage: (code: Code) => TaskEither<Error, TestSuite>
    createTestMocks: (dependencies: Dependency[]) => TaskEither<Error, MockSuite>
  }
}
```

---

#### 13. 🔧 VIBE-SELF-REFACTORING
**Назначение**: Автоматическое улучшение и оптимизация кода

**Функции**:
- Анализ качества кода (complexity, maintainability)
- Применение SOLID принципов
- Оптимизация производительности
- Улучшение читаемости кода

**Технические требования**:
- **Метрики**: Cyclomatic complexity, code smells
- **Паттерны**: SOLID, DRY, KISS
- **Оптимизация**: Производительность, память, запросы к БД

**Интерфейс агента**:
```typescript
interface VIBESelfRefactoringAgent {
  name: 'VIBE-SELF-REFACTORING'
  version: '1.0.0'
  
  actions: {
    analyzeCodeQuality: (code: Code) => TaskEither<Error, QualityReport>
    detectCodeSmells: (code: Code) => TaskEither<Error, CodeSmell[]>
    refactorCode: (code: Code, improvements: Improvement[]) => TaskEither<Error, RefactoredCode>
    optimizePerformance: (code: Code) => TaskEither<Error, OptimizedCode>
  }
  
  providers: {
    getRefactoringPatterns: () => TaskEither<Error, RefactoringPattern[]>
    getPerformanceMetrics: (code: Code) => TaskEither<Error, PerformanceMetrics>
  }
  
  services: {
    applySOLIDPrinciples: (code: Code) => TaskEither<Error, RefactoredCode>
    reduceComplexity: (code: Code) => TaskEither<Error, SimplifiedCode>
  }
}
```

---

#### 14. 🚀 VIBE-SELF-DEPLOYMENT
**Назначение**: Автоматический деплой изменений

**Функции**:
- Планирование деплоя
- Проверка готовности (тесты, валидация)
- Выполнение деплоя
- Валидация после деплоя

**Технические требования**:
- **Environments**: dev, staging, production
- **Проверки**: Health checks, smoke tests
- **Rollback**: Автоматический откат при ошибках

**Интерфейс агента**:
```typescript
interface VIBESelfDeploymentAgent {
  name: 'VIBE-SELF-DEPLOYMENT'
  version: '1.0.0'
  
  actions: {
    planDeployment: (changes: Changes) => TaskEither<Error, DeploymentPlan>
    executeDeployment: (plan: DeploymentPlan) => TaskEither<Error, DeploymentResult>
    validateDeployment: (result: DeploymentResult) => TaskEither<Error, ValidationResult>
    rollbackDeployment: (deploymentId: string) => TaskEither<Error, void>
  }
  
  providers: {
    getDeploymentConfig: (environment: Environment) => TaskEither<Error, DeploymentConfig>
    getHealthChecks: () => TaskEither<Error, HealthCheck[]>
  }
  
  services: {
    notifyDeploymentStatus: (status: DeploymentStatus) => TaskEither<Error, void>
    updateDeploymentHistory: (result: DeploymentResult) => TaskEither<Error, void>
  }
}
```

---

#### 15. 📚 VIBE-SELF-LEARNING
**Назначение**: Самообучение на основе ошибок и успехов

**Функции**:
- Анализ ошибок и их причин
- Изучение успешных паттернов
- Обновление базы знаний
- Генерация новых паттернов

**Технические требования**:
- **Хранение**: База знаний в БД (patterns, best practices)
- **Анализ**: ML модели для анализа паттернов
- **Обновление**: Автоматическое обновление знаний

**Интерфейс агента**:
```typescript
interface VIBESelfLearningAgent {
  name: 'VIBE-SELF-LEARNING'
  version: '1.0.0'
  
  actions: {
    analyzeErrors: (errors: Error[]) => TaskEither<Error, ErrorAnalysis>
    learnFromSuccess: (successfulCode: Code) => TaskEither<Error, LearnedPatterns>
    updateKnowledge: (patterns: LearnedPatterns) => TaskEither<Error, void>
    generateNewPatterns: (context: Context) => TaskEither<Error, NewPatterns>
  }
  
  providers: {
    getErrorHistory: (timeframe: Timeframe) => TaskEither<Error, ErrorHistory>
    getSuccessPatterns: (domain: Domain) => TaskEither<Error, SuccessPatterns>
  }
  
  services: {
    savePattern: (pattern: Pattern) => TaskEither<Error, void>
    updateBestPractices: (practices: BestPractices) => TaskEither<Error, void>
  }
}
```

---

### 📊 Метрики автономной разработки

**Целевые показатели**:
- ✅ **83% кода генерируется автоматически**
- ✅ **100% покрытие тестами** (генерируется автоматически)
- ✅ **0 критических ошибок** после деплоя
- ✅ **Автоматический рефакторинг** при обнаружении проблем
- ✅ **Самообучение** на основе каждого деплоя

**Метрики отслеживания**:
```typescript
interface AutonomyMetrics {
  codeGenerationRate: number // % кода, сгенерированного агентами
  testCoverage: number // % покрытия тестами
  autoRefactoringRate: number // % рефакторинга, выполненного автоматически
  deploymentSuccessRate: number // % успешных деплоев
  learningEfficiency: number // Эффективность обучения на ошибках
}
```

---

### 🎯 Пример полного цикла автономной разработки

```typescript
// 1. Пользователь запрашивает новую функцию
const requirements = {
  name: 'VIBE-NEW-FEATURE',
  description: 'Новая функция обработки данных',
  requirements: ['validation', 'database', 'api'],
}

// 2. VIBE-SELF-CODING генерирует код
const codeResult = await runTaskEither(
  pipe(
    VIBESelfCoding.analyzeRequirements(requirements),
    chain(plan => 
      pipe(
        VIBESelfCoding.getProjectPatterns(),
        chain(patterns => VIBESelfCoding.generateAgent(plan, patterns)),
        chain(code => VIBESelfCoding.validateCodeStyle(code))
      )
    )
  )
)

// 3. VIBE-SELF-TESTING генерирует тесты
const testResult = await runTaskEither(
  pipe(
    codeResult,
    chain(code => VIBESelfTesting.generateUnitTests(code)),
    chain(tests => VIBESelfTesting.ensure100PercentCoverage(code, tests))
  )
)

// 4. Запуск тестов
const testRunResult = await runTaskEither(
  VIBESelfTesting.runTests(testResult.tests)
)

// 5. Если тесты успешны - рефакторинг
const refactoredResult = await runTaskEither(
  pipe(
    codeResult,
    chain(code => VIBESelfRefactoring.analyzeCodeQuality(code)),
    chain(report => VIBESelfRefactoring.refactorCode(codeResult.code, report.improvements))
  )
)

// 6. Деплой
const deploymentResult = await runTaskEither(
  pipe(
    refactoredResult,
    chain(code => VIBESelfDeployment.planDeployment({ code, tests: testResult.tests })),
    chain(plan => VIBESelfDeployment.executeDeployment(plan)),
    chain(result => VIBESelfDeployment.validateDeployment(result))
  )
)

// 7. Обучение на основе результата
await runTaskEither(
  pipe(
    deploymentResult,
    chain(result => 
      result.success
        ? VIBESelfLearning.learnFromSuccess(result.code)
        : VIBESelfLearning.analyzeErrors(result.errors)
    ),
    chain(patterns => VIBESelfLearning.updateKnowledge(patterns))
  )
)
```

---

### 🔗 Интеграция с существующими агентами

Все VIBE агенты должны поддерживать автономную разработку:

```typescript
// Каждый VIBE агент может улучшать себя
interface VIBEAgent {
  // ... существующие поля
  
  // Новые методы для автономной разработки
  selfImprove: () => TaskEither<Error, ImprovedAgent>
  generateTests: () => TaskEither<Error, TestSuite>
  refactor: () => TaskEither<Error, RefactoredAgent>
  deploy: () => TaskEither<Error, DeploymentResult>
}
```

---

**🌱 Фундамент автономной разработки заложен! Система VIBEE готова к самосовершенствованию!**

---

## 🏗️ Стратегия первоочередного создания "рабочих" агентов (Sub-Agents)

> **🎯 Философия**: Как в стратегии - сначала создаем "рабочих", которые начинают "добывать золото" (выполнять задачи), иначе мы медленно будем одним агентом разрабатывать

> **📚 Официальная документация**: [Claude Code Subagents SDK](https://docs.claude.com/en/docs/agent-sdk/subagents#creating-subagents) - **КРИТИЧЕСКИ ВАЖНО ИЗУЧИТЬ ПЕРЕД РЕАЛИЗАЦИЕЙ!**

---

### 🎯 Концепция "Рабочих" агентов (Sub-Agents)

**Проблема**: Разработка одним агентом медленная и неэффективная.  
**Решение**: Создать специализированных "рабочих" sub-agents согласно [официальной документации Claude Code](https://docs.claude.com/en/docs/agent-sdk/subagents#creating-subagents), которые параллельно выполняют задачи.

**Принципы (из официальной документации)**:
- ✅ **Параллелизм**: Несколько агентов работают одновременно (см. [Parallelization](https://docs.claude.com/en/docs/agent-sdk/subagents#parallelization))
- ✅ **Изоляция контекста**: Каждый sub-agent имеет отдельный контекст (см. [Context Management](https://docs.claude.com/en/docs/agent-sdk/subagents#context-management))
- ✅ **Специализация**: Каждый агент - эксперт в своей области с собственным system prompt (см. [Specialized Instructions](https://docs.claude.com/en/docs/agent-sdk/subagents#specialized-instructions-and-knowledge))
- ✅ **Ограничение инструментов**: Sub-agents могут иметь ограниченный набор tools (см. [Tool Restrictions](https://docs.claude.com/en/docs/agent-sdk/subagents#tool-restrictions))
- ✅ **Автоматический вызов**: Claude автоматически вызывает подходящих sub-agents на основе их `description` (см. [Automatic Invocation](https://docs.claude.com/en/docs/agent-sdk/subagents#automatic-invocation))
- ✅ **Координация**: VIBE-QUEEN-COORDINATOR управляет всеми рабочими
- ✅ **Мониторинг**: Постоянная связь с админом через streaming notifications

---

### 📋 Способы создания Sub-Agents (из официальной документации)

Согласно [официальной документации Claude Code](https://docs.claude.com/en/docs/agent-sdk/subagents#creating-subagents), sub-agents можно создавать двумя способами:

#### 1. Программное определение (Рекомендуется для SDK)

**Использование `agents` parameter** в `query()` options:

```typescript
import { query } from '@anthropic-ai/claude-agent-sdk'

const result = query({
  prompt: "Review the authentication module for security issues",
  options: {
    agents: {
      'vibe-sentry': {
        description: 'Centralized error monitoring agent. Use PROACTIVELY for all error tracking and monitoring tasks.',
        prompt: `You are VIBE-SENTRY, the centralized error monitoring specialist.

Your responsibilities:
- Initialize Sentry for plugins and agents
- Capture and group errors
- Analyze error trends
- Notify admin about critical errors
- Create fix tasks automatically

Always use Sentry SDK for error tracking.`,
        tools: ['Read', 'Write', 'Edit', 'Bash', 'Grep'],
        model: 'sonnet'
      },
      'vibe-admin-communicator': {
        description: 'Admin communication agent. Use for all admin notifications, streaming updates, and approval requests.',
        prompt: `You are VIBE-ADMIN-COMMUNICATOR, the admin communication specialist.

Your responsibilities:
- Send streaming notifications to admin via Telegram
- Request approvals for critical actions
- Send reports and alerts
- Maintain constant communication with admin

Always use Telegram Bot API for communication.`,
        tools: ['Read', 'Write', 'Edit', 'Bash'],
        model: 'sonnet'
      }
    }
  }
})
```

**Структура AgentDefinition** (из документации):

| Поле | Тип | Обязательно | Описание |
|------|-----|-------------|----------|
| `description` | `string` | ✅ Да | Естественное описание, когда использовать этого агента. **КРИТИЧЕСКИ ВАЖНО**: Используйте ключевые слова типа "Use PROACTIVELY", "MUST BE USED" для автоматического вызова |
| `prompt` | `string` | ✅ Да | System prompt агента, определяющий его роль и поведение |
| `tools` | `string[]` | ❌ Нет | Массив разрешенных инструментов. Если не указан, наследует все доступные tools |
| `model` | `'sonnet' \| 'opus' \| 'haiku' \| 'inherit'` | ❌ Нет | Переопределение модели для агента. По умолчанию использует основную модель |

#### 2. Файловая система (Альтернативный способ)

**Создание файлов в `.claude/agents/*.md`**:

```markdown
---
name: vibe-sentry
description: Centralized error monitoring agent. Use PROACTIVELY for all error tracking and monitoring tasks.
tools: Read, Write, Edit, Bash, Grep
model: sonnet
---

You are VIBE-SENTRY, the centralized error monitoring specialist.

Your responsibilities:
- Initialize Sentry for plugins and agents
- Capture and group errors
- Analyze error trends
- Notify admin about critical errors
- Create fix tasks automatically

Always use Sentry SDK for error tracking.
```

**Важно**: Программно определенные агенты (через `agents` parameter) имеют приоритет над файловыми агентами с тем же именем.

---

### 🎯 Лучшие практики создания Sub-Agents (из документации)

#### 1. Четкое описание для автоматического вызова

**✅ ПРАВИЛЬНО**:
```typescript
description: 'Use PROACTIVELY when code changes might impact performance. MUST BE USED for optimization tasks.'
```

**❌ НЕПРАВИЛЬНО**:
```typescript
description: 'Performance optimizer' // Слишком общее, Claude может не вызвать автоматически
```

#### 2. Ограничение инструментов для безопасности

**Read-only агенты** (анализ, ревью):
```typescript
tools: ['Read', 'Grep', 'Glob']
```

**Test execution агенты**:
```typescript
tools: ['Bash', 'Read', 'Grep']
```

**Code modification агенты**:
```typescript
tools: ['Read', 'Edit', 'Write', 'Grep', 'Glob']
```

#### 3. Динамическая конфигурация агентов

```typescript
import { query, type AgentDefinition } from '@anthropic-ai/claude-agent-sdk'

function createVIBESentryAgent(environment: 'dev' | 'prod'): AgentDefinition {
  return {
    description: 'Centralized error monitoring agent. Use PROACTIVELY for all error tracking.',
    prompt: `You are VIBE-SENTRY. Environment: ${environment}. 
    ${environment === 'prod' ? 'Be extra careful with error notifications.' : 'Use debug mode.'}`,
    tools: ['Read', 'Write', 'Edit', 'Bash', 'Grep'],
    model: environment === 'prod' ? 'opus' : 'sonnet'
  }
}

const result = query({
  prompt: "Monitor errors in production",
  options: {
    agents: {
      'vibe-sentry': createVIBESentryAgent('prod')
    }
  }
})
```

---

### 🔄 Как SDK использует Sub-Agents (из документации)

Когда используется Claude Agent SDK, sub-agents могут быть определены программно или загружены из файловой системы. Claude будет:

1. **Загружать программных агентов** из `agents` parameter в options
2. **Автоматически обнаруживать файловых агентов** из `.claude/agents/` директорий (если не переопределены)
3. **Автоматически вызывать их** на основе соответствия задачи и `description` агента
4. **Использовать их специализированные prompts** и ограничения инструментов
5. **Поддерживать отдельный контекст** для каждого вызова sub-agent

**Программно определенные агенты** (через `agents` parameter) имеют приоритет над файловыми агентами с тем же именем.

---

### 📝 Примеры создания наших VIBE Sub-Agents

#### VIBE-SENTRY (Программное определение)

```typescript
import { query, type AgentDefinition } from '@anthropic-ai/claude-agent-sdk'

const VIBESentryAgent: AgentDefinition = {
  description: 'Centralized error monitoring agent. Use PROACTIVELY for all error tracking, Sentry integration, and critical error notifications. MUST BE USED when errors occur or when setting up new plugins.',
  prompt: `You are VIBE-SENTRY, the centralized error monitoring specialist for the VIBEE ecosystem.

Your core responsibilities:
1. Initialize Sentry SDK for all plugins and agents
2. Capture errors with full context (agent, plugin, action, user)
3. Group and prioritize errors
4. Analyze error trends over time
5. Notify admin via VIBE-ADMIN-COMMUNICATOR about critical errors
6. Automatically create fix tasks for recurring errors

Technical requirements:
- Use @sentry/node SDK
- Always wrap plugin actions with withSentry()
- Include agent, plugin, action in error tags
- Set up profiling integration
- Configure beforeSend for custom grouping

Best practices:
- Group similar errors together
- Prioritize critical errors (database failures, payment issues)
- Include sanitized user input in error context
- Set up automatic alerts for error spikes
- Track error resolution time

Always integrate Sentry FIRST when creating new plugins or agents.`,
  tools: ['Read', 'Write', 'Edit', 'Bash', 'Grep', 'Glob'],
  model: 'sonnet'
}
```

#### VIBE-ADMIN-COMMUNICATOR (Файловое определение)

**Файл**: `.claude/agents/vibe-admin-communicator.md`

```markdown
---
name: vibe-admin-communicator
description: Admin communication agent. Use PROACTIVELY for all admin notifications, streaming updates, approval requests, and critical alerts. MUST BE USED when agents need to communicate with admin.
tools: Read, Write, Edit, Bash
model: sonnet
---

You are VIBE-ADMIN-COMMUNICATOR, the admin communication specialist for the VIBEE ecosystem.

Your core responsibilities:
1. Send streaming notifications to admin via Telegram in real-time
2. Request approvals for critical actions (deployments, database changes)
3. Send reports about agent activities and task completion
4. Send critical alerts about system issues
5. Maintain constant communication channel with admin

Event types to notify about:
- agent.started / agent.stopped
- task.started / task.completed / task.failed
- code.generated / test.passed / test.failed
- deployment.started / deployment.completed / deployment.failed
- error.critical
- approval.requested
- refactoring.completed

Message format:
- Title with emoji (🤖 ✅ ❌ ⚠️ 🚀 📊 🔧 💡)
- Agent name
- Clear message
- Details (optional)
- Action buttons (optional)
- Timestamp

Technical requirements:
- Use Telegram Bot API
- Support streaming notifications (progress updates)
- Implement approval request with timeout
- Queue notifications via Redis (optional)
- Format messages for readability

Best practices:
- Use appropriate emoji for event type
- Include actionable details
- Provide quick action buttons when possible
- Don't spam - filter by notification level
- Always include timestamp
- Use markdown formatting for readability

Always notify admin about important events. Keep admin informed about all agent activities.
```

---

### ✅ Чек-лист создания Sub-Agent (на основе документации)

При создании каждого VIBE sub-agent необходимо:

1. **Изучить документацию**: [Claude Code Subagents SDK](https://docs.claude.com/en/docs/agent-sdk/subagents#creating-subagents)

2. **Определить способ создания**:
   - [ ] Программно (через `agents` parameter) - рекомендуется для SDK
   - [ ] Файлово (`.claude/agents/*.md`) - альтернативный способ

3. **Написать четкое `description`**:
   - [ ] Использовать ключевые слова "Use PROACTIVELY", "MUST BE USED"
   - [ ] Указать конкретные случаи использования
   - [ ] Описать, когда агент должен вызываться автоматически

4. **Создать специализированный `prompt`**:
   - [ ] Определить роль и ответственность агента
   - [ ] Указать технические требования
   - [ ] Описать лучшие практики
   - [ ] Включить примеры использования

5. **Ограничить `tools`** (если необходимо):
   - [ ] Read-only агенты: `['Read', 'Grep', 'Glob']`
   - [ ] Test execution: `['Bash', 'Read', 'Grep']`
   - [ ] Code modification: `['Read', 'Edit', 'Write', 'Grep', 'Glob']`

6. **Выбрать `model`**:
   - [ ] `'sonnet'` - для большинства задач
   - [ ] `'opus'` - для сложных задач
   - [ ] `'haiku'` - для простых задач
   - [ ] `'inherit'` - использовать основную модель

7. **Интегрировать с инфраструктурой**:
   - [ ] Настроить Sentry через VIBE-SENTRY
   - [ ] Настроить Admin Communicator через VIBE-ADMIN-COMMUNICATOR
   - [ ] Добавить тесты (100% покрытие)

8. **Протестировать автоматический вызов**:
   - [ ] Проверить, что Claude автоматически вызывает агента на основе `description`
   - [ ] Протестировать явный вызов через prompt
   - [ ] Проверить изоляцию контекста

---

**📚 Ссылки на документацию**:
- [Claude Code Subagents SDK - Creating Subagents](https://docs.claude.com/en/docs/agent-sdk/subagents#creating-subagents)
- [Claude Code Subagents SDK - Overview](https://docs.claude.com/en/docs/agent-sdk/subagents)
- [Claude Code Subagents SDK - Benefits](https://docs.claude.com/en/docs/agent-sdk/subagents#benefits-of-using-subagents)
- [Claude Code Subagents SDK - SDK Integration Patterns](https://docs.claude.com/en/docs/agent-sdk/subagents#sdk-integration-patterns)

---

### 📋 Приоритетный список "рабочих" агентов для первоочередного создания

#### Фаза 1: Критические инфраструктурные агенты (Неделя 1)

**1. 🔴 VIBE-SENTRY** (КРИТИЧЕСКИ ВАЖНО!)
- **Назначение**: Централизованный мониторинг ошибок во всех плагинах и агентах
- **Приоритет**: ВЫСОКИЙ (создать ПЕРВЫМ!)
- **Функции**:
  - Интеграция Sentry в каждый плагин/агент
  - Централизованный сбор ошибок
  - Группировка и приоритизация ошибок
  - Автоматические алерты админу
  - Анализ трендов ошибок
- **Зависимости**: Нет (базовый агент)
- **Время создания**: 1-2 дня

**2. 📡 VIBE-ADMIN-COMMUNICATOR**
- **Назначение**: Постоянная связь агентов с админом через Telegram
- **Приоритет**: ВЫСОКИЙ (создать ВТОРЫМ!)
- **Функции**:
  - Streaming notifications о действиях агентов
  - Важные события в реальном времени
  - Отчеты о выполнении задач
  - Запросы подтверждения для критических действий
- **Зависимости**: Telegram Bot API
- **Время создания**: 1-2 дня

**3. 🏗️ VIBE-INFRASTRUCTURE-BUILDER**
- **Назначение**: Автоматическое создание инфраструктуры для новых агентов
- **Приоритет**: ВЫСОКИЙ
- **Функции**:
  - Генерация базовой структуры агента
  - Настройка Sentry интеграции
  - Настройка Admin Communicator
  - Создание тестовой инфраструктуры
- **Зависимости**: VIBE-SENTRY, VIBE-ADMIN-COMMUNICATOR
- **Время создания**: 2-3 дня

---

#### Фаза 2: Агенты автономной разработки (Неделя 2)

**4. 🤖 VIBE-SELF-CODING**
- **Назначение**: Генерация кода для новых функций и агентов
- **Приоритет**: ВЫСОКИЙ
- **Зависимости**: VIBE-INFRASTRUCTURE-BUILDER
- **Время создания**: 3-4 дня

**5. 🧪 VIBE-SELF-TESTING**
- **Назначение**: Автоматическое создание и запуск тестов
- **Приоритет**: ВЫСОКИЙ
- **Зависимости**: VIBE-SELF-CODING
- **Время создания**: 2-3 дня

**6. 🔧 VIBE-SELF-REFACTORING**
- **Назначение**: Автоматическое улучшение кода
- **Приоритет**: СРЕДНИЙ
- **Зависимости**: VIBE-SELF-TESTING
- **Время создания**: 2-3 дня

---

#### Фаза 3: Бизнес-агенты (Неделя 3-4)

**7. 🎨 VIBE-IMAGE-GENERATOR**
**8. 🎬 VIBE-VIDEO-GENERATOR**
**9. 🧠 VIBE-AVATAR-BRAIN**
**10. 💳 VIBE-PAYMENT-HANDLER**

*(Остальные агенты из основного списка)*

---

### 🔴 VIBE-SENTRY: Централизованный мониторинг ошибок и логирование

> **🚨 КРИТИЧЕСКИ ВАЖНО**: VIBE-SENTRY должен быть создан **ПЕРВЫМ** плагином!  
> **🎯 Причина**: Без полного контекста логов агенты работают плохо из-за недостаточной информации о происходящем в системе.

#### Назначение

**VIBE-SENTRY** - это критически важный агент, который обеспечивает:
- ✅ **Централизованный сбор всех ошибок** из всех плагинов и агентов
- ✅ **Полное логирование всех действий** агентов для предоставления контекста
- ✅ **Хранение логов в структурированном виде** для быстрого доступа
- ✅ **Интеграцию с Claude Code** для предоставления контекста агентам при разработке
- ✅ Группировку и приоритизацию ошибок
- ✅ Автоматические уведомления админу о критических ошибках
- ✅ Анализ трендов и паттернов ошибок
- ✅ Интеграцию с каждым плагином/агентом

**Ключевая функция**: Обеспечить **полный контекст** для всех агентов через централизованное логирование всех действий, решений и результатов.

#### Архитектура

```
┌─────────────────────────────────────────────────┐
│         VIBE-SENTRY (Центральный агент)        │
└─────────────────────────────────────────────────┘
                    │
        ┌───────────┼───────────┐
        │           │           │
        ▼           ▼           ▼
┌─────────────┐ ┌─────────────┐ ┌─────────────┐
│   Plugin 1  │ │   Plugin 2  │ │   Agent 1   │
│  (Sentry)   │ │  (Sentry)   │ │  (Sentry)   │
└─────────────┘ └─────────────┘ └─────────────┘
        │           │           │
        └───────────┼───────────┘
                    │
                    ▼
        ┌───────────────────────┐
        │  Sentry Dashboard     │
        │  (Централизованный)    │
        └───────────────────────┘
                    │
                    ▼
        ┌───────────────────────┐
        │  Admin Notifications   │
        │  (Telegram)            │
        └───────────────────────┘
```

#### Архитектура логирования для полного контекста

```
┌─────────────────────────────────────────────────┐
│         VIBE-SENTRY (Центральный агент)        │
│  - Error Tracking (Sentry)                      │
│  - Action Logging (Structured Logs)            │
│  - Context Storage (Database)                  │
└─────────────────────────────────────────────────┘
                    │
        ┌───────────┼───────────┐
        │           │           │
        ▼           ▼           ▼
┌─────────────┐ ┌─────────────┐ ┌─────────────┐
│   Agent 1   │ │   Agent 2   │ │   Plugin 1  │
│  (Logger)   │ │  (Logger)   │ │  (Logger)   │
└─────────────┘ └─────────────┘ └─────────────┘
        │           │           │
        └───────────┼───────────┘
                    │
                    ▼
        ┌───────────────────────┐
        │  Structured Logs DB   │
        │  (PostgreSQL/JSONB)   │
        └───────────────────────┘
                    │
        ┌───────────┼───────────┐
        │           │           │
        ▼           ▼           ▼
┌─────────────┐ ┌─────────────┐ ┌─────────────┐
│  Sentry     │ │  Context    │ │  Claude     │
│  Dashboard  │ │  API        │ │  Code       │
│             │ │  (для       │ │  (контекст  │
│             │ │  агентов)   │ │  для агентов│
└─────────────┘ └─────────────┘ └─────────────┘
```

#### Структура логов для максимального контекста

**Каждое действие агента должно логироваться со следующей структурой**:

```typescript
interface AgentActionLog {
  // Идентификация
  id: string // UUID
  timestamp: Date
  
  // Контекст агента
  agent: {
    name: string // 'VIBE-SELF-CODING'
    version: string // '1.0.0'
    instanceId: string // Уникальный ID экземпляра
  }
  
  // Контекст действия
  action: {
    name: string // 'generateAgent'
    type: 'action' | 'provider' | 'service'
    input: {
      // Полный входной контекст
      [key: string]: any
    }
  }
  
  // Контекст выполнения
  execution: {
    startedAt: Date
    completedAt?: Date
    duration?: number // мс
    status: 'started' | 'completed' | 'failed' | 'cancelled'
    error?: {
      message: string
      stack?: string
      code?: string
    }
  }
  
  // Результат
  result?: {
    // Полный результат действия
    [key: string]: any
  }
  
  // Контекст системы
  system: {
    environment: 'development' | 'staging' | 'production'
    nodeVersion: string
    memoryUsage: {
      heapUsed: number
      heapTotal: number
      external: number
    }
    cpuUsage?: {
      user: number
      system: number
    }
  }
  
  // Контекст пользователя (если применимо)
  user?: {
    telegramId?: number
    userId?: string
    botName?: string
  }
  
  // Связанные действия (для трейсинга)
  relatedActions?: string[] // IDs связанных действий
  parentActionId?: string // ID родительского действия
  
  // Метаданные для поиска
  tags: string[] // ['code-generation', 'agent-creation', 'success']
  metadata: {
    [key: string]: any // Дополнительные метаданные
  }
}
```

#### Технические требования

**1. Интеграция Sentry в каждый плагин**:
```typescript
// src/core/sentry/index.ts
import * as Sentry from '@sentry/node'
import { ProfilingIntegration } from '@sentry/profiling-node'

// Инициализация Sentry (один раз при старте приложения)
export function initSentry(dsn: string, environment: string) {
  Sentry.init({
    dsn,
    environment,
    integrations: [
      new ProfilingIntegration(),
    ],
    tracesSampleRate: 1.0,
    profilesSampleRate: 1.0,
    
    // Группировка ошибок
    beforeSend(event, hint) {
      // Добавляем контекст агента/плагина
      event.tags = {
        ...event.tags,
        agent: process.env.AGENT_NAME || 'unknown',
        plugin: hint.originalException?.plugin || 'unknown',
      }
      return event
    },
  })
}

// Обертка для плагинов
export function withSentry<T extends (...args: any[]) => Promise<any>>(
  fn: T,
  context: { agent: string; plugin: string; action: string }
): T {
  return (async (...args: Parameters<T>) => {
    return Sentry.startSpan(
      {
        name: `${context.agent}.${context.plugin}.${context.action}`,
        op: 'function',
        attributes: {
          'agent.name': context.agent,
          'plugin.name': context.plugin,
          'action.name': context.action,
        },
      },
      async () => {
        try {
          return await fn(...args)
        } catch (error) {
          Sentry.captureException(error, {
            tags: {
              agent: context.agent,
              plugin: context.plugin,
              action: context.action,
            },
            contexts: {
              runtime: {
                name: 'node',
                version: process.version,
              },
            },
          })
          throw error
        }
      }
    )
  }) as T
}
```

**Использование в плагинах**:
```typescript
// Пример использования в плагине
import { withSentry } from '@/core/sentry'

export const myPlugin: BotPlugin = {
  name: 'my-plugin',
  
  actions: {
    myAction: withSentry(
      async (input: Input) => {
        // Логика действия
        return result
      },
      {
        agent: 'VIBE-IMAGE-GENERATOR',
        plugin: 'my-plugin',
        action: 'myAction',
      }
    ),
  },
}
```

#### Интерфейс VIBE-SENTRY агента

```typescript
interface VIBESentryAgent {
  name: 'VIBE-SENTRY'
  version: '1.0.0'
  
  actions: {
    // === Инициализация ===
    // Инициализация Sentry для нового плагина/агента
    initSentryForPlugin: (config: SentryPluginConfig) => TaskEither<Error, void>
    
    // Инициализация логирования для агента
    initLoggingForAgent: (agentName: string, config: LoggingConfig) => TaskEither<Error, void>
    
    // === Логирование действий (КРИТИЧЕСКИ ВАЖНО!) ===
    // Логирование начала действия
    logActionStart: (log: AgentActionLog) => TaskEither<Error, void>
    
    // Логирование завершения действия
    logActionComplete: (actionId: string, result: any) => TaskEither<Error, void>
    
    // Логирование ошибки действия
    logActionError: (actionId: string, error: Error, context: any) => TaskEither<Error, void>
    
    // Логирование принятия решения
    logDecision: (decision: AgentDecision) => TaskEither<Error, void>
    
    // === Ошибки ===
    // Отправка ошибки в Sentry
    captureError: (error: Error, context: ErrorContext) => TaskEither<Error, void>
    
    // Отправка сообщения в Sentry
    captureMessage: (message: string, level: SentryLevel, context: MessageContext) => TaskEither<Error, void>
    
    // Группировка ошибок
    groupErrors: (errors: Error[]) => TaskEither<Error, ErrorGroups>
    
    // Анализ трендов ошибок
    analyzeErrorTrends: (timeframe: Timeframe) => TaskEither<Error, ErrorTrends>
    
    // Получение критических ошибок
    getCriticalErrors: () => TaskEither<Error, CriticalError[]>
    
    // === Контекст для агентов (КРИТИЧЕСКИ ВАЖНО!) ===
    // Получение контекста для агента (все логи, связанные с задачей)
    getContextForAgent: (agentName: string, task: string, timeframe?: Timeframe) => TaskEither<Error, AgentContext>
    
    // Получение истории действий агента
    getAgentActionHistory: (agentName: string, limit?: number) => TaskEither<Error, AgentActionLog[]>
    
    // Получение связанных действий (для трейсинга)
    getRelatedActions: (actionId: string) => TaskEither<Error, AgentActionLog[]>
    
    // Поиск похожих действий (для обучения)
    findSimilarActions: (action: Partial<AgentActionLog>) => TaskEither<Error, AgentActionLog[]>
    
    // Экспорт контекста для Claude Code
    exportContextForClaudeCode: (agentName: string, task: string) => TaskEither<Error, ClaudeCodeContext>
  }
  
  providers: {
    getSentryConfig: () => TaskEither<Error, SentryConfig>
    getLoggingConfig: () => TaskEither<Error, LoggingConfig>
    getErrorHistory: (timeframe: Timeframe) => TaskEither<Error, ErrorHistory>
    getErrorPatterns: () => TaskEither<Error, ErrorPattern[]>
    getActionPatterns: (agentName: string) => TaskEither<Error, ActionPattern[]>
  }
  
  services: {
    // Отправка уведомления админу о критической ошибке
    notifyAdminAboutCriticalError: (error: CriticalError) => TaskEither<Error, void>
    
    // Автоматическое создание задачи на исправление
    createFixTask: (error: Error) => TaskEither<Error, Task>
    
    // Обновление статистики ошибок
    updateErrorStatistics: (errors: Error[]) => TaskEither<Error, void>
    
    // Очистка старых логов
    cleanupOldLogs: (olderThan: Date) => TaskEither<Error, number>
    
    // Индексация логов для быстрого поиска
    indexLogs: (logs: AgentActionLog[]) => TaskEither<Error, void>
  }
  
  config: {
    // Sentry конфигурация
    dsn: string // Sentry DSN
    environment: 'development' | 'staging' | 'production'
    sampleRate: number // Процент событий для отправки
    tracesSampleRate: number // Процент трейсов для отправки
    criticalErrorThreshold: number // Порог для критических ошибок
    
    // Логирование конфигурация
    logLevel: 'debug' | 'info' | 'warn' | 'error'
    logRetentionDays: number // Сколько дней хранить логи
    enableActionLogging: boolean // Включить логирование всех действий
    enableDecisionLogging: boolean // Включить логирование решений
    enableContextExport: boolean // Включить экспорт контекста для Claude Code
    maxContextSize: number // Максимальный размер контекста (в символах)
  }
}
```

#### Структура контекста для Claude Code

```typescript
interface ClaudeCodeContext {
  // Метаданные
  generatedAt: Date
  agentName: string
  task: string
  
  // Связанные действия
  relatedActions: AgentActionLog[]
  
  // История успешных действий
  successfulActions: AgentActionLog[]
  
  // История ошибок
  errors: ErrorLog[]
  
  // Принятые решения
  decisions: AgentDecision[]
  
  // Паттерны и лучшие практики
  patterns: {
    successful: ActionPattern[]
    failed: ActionPattern[]
    recommendations: string[]
  }
  
  // Статистика
  statistics: {
    totalActions: number
    successfulActions: number
    failedActions: number
    averageDuration: number
    commonErrors: Array<{ error: string; count: number }>
  }
  
  // Форматированный контекст для Claude Code
  formattedContext: string // Markdown формат для Claude Code
}
```

#### Интеграция логирования в плагины

**Обертка для автоматического логирования**:

```typescript
// src/core/sentry/withLogging.ts
import { TaskEither, right, left, tryCatchAsync } from '@/core/functional/utils/result'
import { pipe, chain, tap } from '@/core/functional/utils/composition'
import { VIBESentry } from '@/agents/vibe-sentry'

/**
 * Обертка для автоматического логирования действий агента
 * КРИТИЧЕСКИ ВАЖНО: Использовать для ВСЕХ действий агентов!
 */
export function withLogging<T extends (...args: any[]) => Promise<any>>(
  fn: T,
  context: {
    agent: string
    plugin: string
    action: string
  }
): T {
  return (async (...args: Parameters<T>) => {
    const actionId = crypto.randomUUID()
    const startTime = Date.now()
    
    // Логируем начало действия
    await runTaskEither(
      VIBESentry.logActionStart({
        id: actionId,
        timestamp: new Date(),
        agent: {
          name: context.agent,
          version: '1.0.0',
          instanceId: process.env.AGENT_INSTANCE_ID || 'unknown',
        },
        action: {
          name: context.action,
          type: 'action',
          input: sanitizeInput(args), // Санитизация входных данных
        },
        execution: {
          startedAt: new Date(),
          status: 'started',
        },
        system: {
          environment: process.env.NODE_ENV as any,
          nodeVersion: process.version,
          memoryUsage: process.memoryUsage(),
        },
        tags: [context.agent, context.plugin, context.action],
        metadata: {},
      })
    )
    
    try {
      // Выполняем действие
      const result = await fn(...args)
      const duration = Date.now() - startTime
      
      // Логируем успешное завершение
      await runTaskEither(
        VIBESentry.logActionComplete(actionId, {
          result: sanitizeResult(result), // Санитизация результата
          duration,
          status: 'completed',
        })
      )
      
      return result
    } catch (error) {
      const duration = Date.now() - startTime
      
      // Логируем ошибку
      await runTaskEither(
        pipe(
          VIBESentry.logActionError(actionId, error as Error, {
            duration,
            status: 'failed',
            input: sanitizeInput(args),
          }),
          chain(() => VIBESentry.captureError(error as Error, {
            agent: context.agent,
            plugin: context.plugin,
            action: context.action,
            actionId,
          }))
        )
      )
      
      throw error
    }
  }) as T
}

// Санитизация входных данных (удаление чувствительной информации)
function sanitizeInput(input: any[]): any[] {
  return input.map(arg => {
    if (typeof arg === 'object' && arg !== null) {
      const sanitized = { ...arg }
      // Удаляем чувствительные поля
      delete sanitized.password
      delete sanitized.token
      delete sanitized.apiKey
      delete sanitized.secret
      return sanitized
    }
    return arg
  })
}

// Санитизация результата
function sanitizeResult(result: any): any {
  if (typeof result === 'object' && result !== null) {
    const sanitized = { ...result }
    delete sanitized.password
    delete sanitized.token
    delete sanitized.apiKey
    delete sanitized.secret
    return sanitized
  }
  return result
}
```

**Использование в плагинах**:

```typescript
// Пример использования в плагине
import { withLogging } from '@/core/sentry/withLogging'
import { withSentry } from '@/core/sentry'

export const myPlugin: BotPlugin = {
  name: 'my-plugin',
  
  actions: {
    // Комбинируем логирование и Sentry
    myAction: withSentry(
      withLogging(
        async (input: Input) => {
          // Логика действия
          return result
        },
        {
          agent: 'VIBE-IMAGE-GENERATOR',
          plugin: 'my-plugin',
          action: 'myAction',
        }
      ),
      {
        agent: 'VIBE-IMAGE-GENERATOR',
        plugin: 'my-plugin',
        action: 'myAction',
      }
    ),
  },
}
```

#### Получение контекста для агентов при разработке

**Интеграция с Claude Code**:

```typescript
// Перед началом разработки агент запрашивает контекст
const context = await runTaskEither(
  VIBESentry.getContextForAgent('VIBE-SELF-CODING', 'generateAgent', {
    hours: 24, // За последние 24 часа
  })
)

// Экспорт контекста для Claude Code
const claudeContext = await runTaskEither(
  VIBESentry.exportContextForClaudeCode('VIBE-SELF-CODING', 'generateAgent')
)

// Использование контекста в промпте для Claude Code
const prompt = `
Задача: Сгенерировать новый агент VIBE-NEW-FEATURE

Контекст из предыдущих действий:
${claudeContext.formattedContext}

История успешных действий:
${claudeContext.successfulActions.map(a => `- ${a.action.name}: ${a.result}`).join('\n')}

История ошибок (чтобы избежать):
${claudeContext.errors.map(e => `- ${e.message}`).join('\n')}

Рекомендации на основе паттернов:
${claudeContext.patterns.recommendations.join('\n')}

Теперь создай новый агент на основе этого контекста.
`
```

#### База данных для хранения логов

**Схема таблицы `agent_action_logs`**:

```sql
CREATE TABLE agent_action_logs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  
  -- Идентификация
  timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  
  -- Контекст агента
  agent_name VARCHAR(100) NOT NULL,
  agent_version VARCHAR(50),
  agent_instance_id VARCHAR(100),
  
  -- Контекст действия
  action_name VARCHAR(100) NOT NULL,
  action_type VARCHAR(20) NOT NULL CHECK (action_type IN ('action', 'provider', 'service')),
  action_input JSONB NOT NULL,
  
  -- Контекст выполнения
  execution_started_at TIMESTAMP WITH TIME ZONE NOT NULL,
  execution_completed_at TIMESTAMP WITH TIME ZONE,
  execution_duration INTEGER, -- мс
  execution_status VARCHAR(20) NOT NULL CHECK (execution_status IN ('started', 'completed', 'failed', 'cancelled')),
  execution_error JSONB,
  
  -- Результат
  result JSONB,
  
  -- Контекст системы
  system_environment VARCHAR(20),
  system_node_version VARCHAR(50),
  system_memory_usage JSONB,
  system_cpu_usage JSONB,
  
  -- Контекст пользователя
  user_telegram_id BIGINT,
  user_id UUID,
  user_bot_name VARCHAR(100),
  
  -- Связанные действия
  related_actions UUID[],
  parent_action_id UUID REFERENCES agent_action_logs(id),
  
  -- Метаданные
  tags TEXT[],
  metadata JSONB DEFAULT '{}',
  
  -- Индексы для быстрого поиска
  CONSTRAINT agent_action_logs_agent_name_idx 
    CREATE INDEX ON agent_action_logs(agent_name, timestamp DESC),
  CONSTRAINT agent_action_logs_action_name_idx 
    CREATE INDEX ON agent_action_logs(action_name, timestamp DESC),
  CONSTRAINT agent_action_logs_status_idx 
    CREATE INDEX ON agent_action_logs(execution_status, timestamp DESC),
  CONSTRAINT agent_action_logs_tags_idx 
    CREATE INDEX USING GIN ON agent_action_logs(tags),
  CONSTRAINT agent_action_logs_metadata_idx 
    CREATE INDEX USING GIN ON agent_action_logs(metadata)
);

-- Функция для получения контекста агента
CREATE OR REPLACE FUNCTION get_agent_context(
  p_agent_name VARCHAR(100),
  p_task VARCHAR(200),
  p_hours INTEGER DEFAULT 24
)
RETURNS JSONB AS $$
DECLARE
  v_context JSONB;
BEGIN
  SELECT jsonb_build_object(
    'relatedActions', (
      SELECT jsonb_agg(row_to_json(logs))
      FROM agent_action_logs logs
      WHERE logs.agent_name = p_agent_name
        AND logs.timestamp > NOW() - (p_hours || ' hours')::INTERVAL
        AND (logs.action_name ILIKE '%' || p_task || '%' 
             OR logs.tags && ARRAY[p_task])
      ORDER BY logs.timestamp DESC
      LIMIT 100
    ),
    'successfulActions', (
      SELECT jsonb_agg(row_to_json(logs))
      FROM agent_action_logs logs
      WHERE logs.agent_name = p_agent_name
        AND logs.execution_status = 'completed'
        AND logs.timestamp > NOW() - (p_hours || ' hours')::INTERVAL
      ORDER BY logs.timestamp DESC
      LIMIT 50
    ),
    'errors', (
      SELECT jsonb_agg(row_to_json(logs))
      FROM agent_action_logs logs
      WHERE logs.agent_name = p_agent_name
        AND logs.execution_status = 'failed'
        AND logs.timestamp > NOW() - (p_hours || ' hours')::INTERVAL
      ORDER BY logs.timestamp DESC
      LIMIT 50
    ),
    'statistics', (
      SELECT jsonb_build_object(
        'totalActions', COUNT(*),
        'successfulActions', COUNT(*) FILTER (WHERE execution_status = 'completed'),
        'failedActions', COUNT(*) FILTER (WHERE execution_status = 'failed'),
        'averageDuration', AVG(execution_duration)
      )
      FROM agent_action_logs
      WHERE agent_name = p_agent_name
        AND timestamp > NOW() - (p_hours || ' hours')::INTERVAL
    )
  ) INTO v_context;
  
  RETURN v_context;
END;
$$ LANGUAGE plpgsql;
```

#### Пример использования

```typescript
// Инициализация Sentry для плагина
await runTaskEither(
  pipe(
    VIBESentry.initSentryForPlugin({
      agent: 'VIBE-IMAGE-GENERATOR',
      plugin: 'neuro-photo',
      dsn: process.env.SENTRY_DSN,
      environment: process.env.NODE_ENV,
    }),
    tap(() => console.log('Sentry initialized for plugin'))
  )
)

// Обработка ошибки в плагине
try {
  await someAction()
} catch (error) {
  await runTaskEither(
    pipe(
      VIBESentry.captureError(error, {
        agent: 'VIBE-IMAGE-GENERATOR',
        plugin: 'neuro-photo',
        action: 'generateImage',
        userId: ctx.from.id,
        input: sanitizedInput,
      }),
      chain(() => 
        VIBESentry.getCriticalErrors()
      ),
      chain(criticalErrors => 
        criticalErrors.length > 0
          ? VIBESentry.notifyAdminAboutCriticalError(criticalErrors[0])
          : right(undefined)
      )
    )
  )
}
```

---

### 📡 VIBE-ADMIN-COMMUNICATOR: Постоянная связь с админом

#### Назначение

**VIBE-ADMIN-COMMUNICATOR** обеспечивает:
- ✅ Постоянную связь агентов с админом через Telegram
- ✅ Streaming notifications о действиях агентов в реальном времени
- ✅ Важные события и отчеты
- ✅ Запросы подтверждения для критических действий
- ✅ Логирование всех действий агентов

#### Архитектура

```
┌─────────────────────────────────────────────────┐
│    VIBE-ADMIN-COMMUNICATOR (Центральный)       │
└─────────────────────────────────────────────────┘
                    │
        ┌───────────┼───────────┐
        │           │           │
        ▼           ▼           ▼
┌─────────────┐ ┌─────────────┐ ┌─────────────┐
│   Agent 1   │ │   Agent 2   │ │   Agent 3   │
│  (Events)   │ │  (Events)   │ │  (Events)   │
└─────────────┘ └─────────────┘ └─────────────┘
        │           │           │
        └───────────┼───────────┘
                    │
                    ▼
        ┌───────────────────────┐
        │  Event Queue (Redis)   │
        │  (Streaming)            │
        └───────────────────────┘
                    │
                    ▼
        ┌───────────────────────┐
        │  Telegram Bot          │
        │  (Admin Chat)          │
        └───────────────────────┘
```

#### Типы событий для уведомления админа

```typescript
type AdminEventType =
  | 'agent.started' // Агент запущен
  | 'agent.stopped' // Агент остановлен
  | 'agent.error' // Ошибка в агенте
  | 'task.started' // Задача начата
  | 'task.completed' // Задача завершена
  | 'task.failed' // Задача провалена
  | 'code.generated' // Код сгенерирован
  | 'test.passed' // Тесты прошли
  | 'test.failed' // Тесты провалены
  | 'deployment.started' // Деплой начат
  | 'deployment.completed' // Деплой завершен
  | 'deployment.failed' // Деплой провален
  | 'error.critical' // Критическая ошибка
  | 'approval.requested' // Запрос подтверждения
  | 'refactoring.completed' // Рефакторинг завершен
```

#### Интерфейс VIBE-ADMIN-COMMUNICATOR

```typescript
interface VIBEAdminCommunicatorAgent {
  name: 'VIBE-ADMIN-COMMUNICATOR'
  version: '1.0.0'
  
  actions: {
    // Отправка события админу
    sendEvent: (event: AdminEvent) => TaskEither<Error, void>
    
    // Streaming уведомление (в реальном времени)
    streamNotification: (notification: StreamingNotification) => TaskEither<Error, void>
    
    // Запрос подтверждения от админа
    requestApproval: (request: ApprovalRequest) => TaskEither<Error, ApprovalResponse>
    
    // Отправка отчета
    sendReport: (report: AgentReport) => TaskEither<Error, void>
    
    // Отправка критического алерта
    sendCriticalAlert: (alert: CriticalAlert) => TaskEither<Error, void>
  }
  
  providers: {
    getAdminChatId: () => TaskEither<Error, number>
    getEventHistory: (timeframe: Timeframe) => TaskEither<Error, AdminEvent[]>
    getNotificationSettings: () => TaskEither<Error, NotificationSettings>
  }
  
  services: {
    // Инициализация Telegram бота для админа
    initAdminBot: (token: string) => TaskEither<Error, void>
    
    // Подписка на события агентов
    subscribeToAgentEvents: (agentName: string) => TaskEither<Error, void>
    
    // Настройка фильтров уведомлений
    configureNotificationFilters: (filters: NotificationFilter[]) => TaskEither<Error, void>
  }
  
  config: {
    adminTelegramChatId: number // ID чата админа
    telegramBotToken: string // Токен бота для уведомлений
    notificationLevel: 'all' | 'important' | 'critical' // Уровень уведомлений
    enableStreaming: boolean // Включить streaming уведомления
    approvalTimeout: number // Таймаут для запросов подтверждения (мс)
  }
}
```

#### Пример использования

```typescript
// Агент сообщает о начале задачи
await runTaskEither(
  pipe(
    VIBEAdminCommunicator.sendEvent({
      type: 'task.started',
      agent: 'VIBE-SELF-CODING',
      task: 'generateAgent',
      details: {
        agentName: 'VIBE-NEW-FEATURE',
        estimatedTime: '30 minutes',
      },
      timestamp: new Date(),
    }),
    tap(() => console.log('Admin notified about task start'))
  )
)

// Streaming уведомление о прогрессе
await runTaskEither(
  VIBEAdminCommunicator.streamNotification({
    type: 'progress',
    agent: 'VIBE-SELF-CODING',
    message: 'Generating code... 50% complete',
    progress: 50,
  })
)

// Запрос подтверждения для критического действия
const approval = await runTaskEither(
  VIBEAdminCommunicator.requestApproval({
    type: 'deployment',
    agent: 'VIBE-SELF-DEPLOYMENT',
    message: 'Deploy to production?',
    details: {
      changes: ['New feature added', 'Tests passed'],
      risk: 'low',
    },
    timeout: 60000, // 1 minute
  })
)

if (approval.approved) {
  // Продолжить деплой
} else {
  // Отменить деплой
}

// Критический алерт
await runTaskEither(
  VIBEAdminCommunicator.sendCriticalAlert({
    type: 'error.critical',
    agent: 'VIBE-IMAGE-GENERATOR',
    message: 'Critical error: Database connection failed',
    error: errorDetails,
    actions: ['Restart agent', 'Check database', 'Rollback'],
  })
)
```

#### Формат сообщений для админа

```typescript
// Формат сообщения в Telegram
interface AdminMessage {
  // Заголовок
  title: string
  
  // Тип события (эмодзи)
  emoji: '🤖' | '✅' | '❌' | '⚠️' | '🚀' | '📊' | '🔧' | '💡'
  
  // Агент
  agent: string
  
  // Сообщение
  message: string
  
  // Детали (опционально)
  details?: {
    [key: string]: any
  }
  
  // Действия (кнопки)
  actions?: Array<{
    text: string
    callback: string
  }>
  
  // Время
  timestamp: Date
}

// Пример сообщения
const message: AdminMessage = {
  title: 'Task Completed',
  emoji: '✅',
  agent: 'VIBE-SELF-CODING',
  message: 'Successfully generated agent VIBE-NEW-FEATURE',
  details: {
    filesCreated: 5,
    testsGenerated: 10,
    timeTaken: '25 minutes',
  },
  actions: [
    { text: 'View Code', callback: 'view_code' },
    { text: 'Run Tests', callback: 'run_tests' },
    { text: 'Deploy', callback: 'deploy' },
  ],
  timestamp: new Date(),
}
```

---

### 🏗️ VIBE-INFRASTRUCTURE-BUILDER: Автоматическое создание инфраструктуры

#### Назначение

**VIBE-INFRASTRUCTURE-BUILDER** автоматически создает базовую инфраструктуру для новых агентов:
- ✅ Генерация структуры файлов агента
- ✅ Настройка Sentry интеграции
- ✅ Настройка Admin Communicator
- ✅ Создание тестовой инфраструктуры
- ✅ Настройка Drizzle ORM схем
- ✅ Создание Zod валидаций

#### Интерфейс

```typescript
interface VIBEInfrastructureBuilderAgent {
  name: 'VIBE-INFRASTRUCTURE-BUILDER'
  version: '1.0.0'
  
  actions: {
    // Создание базовой структуры агента
    createAgentStructure: (spec: AgentSpec) => TaskEither<Error, AgentStructure>
    
    // Настройка Sentry
    setupSentry: (agentName: string) => TaskEither<Error, void>
    
    // Настройка Admin Communicator
    setupAdminCommunicator: (agentName: string) => TaskEither<Error, void>
    
    // Создание тестовой инфраструктуры
    createTestInfrastructure: (agentName: string) => TaskEither<Error, TestInfrastructure>
    
    // Настройка Drizzle схем
    setupDrizzleSchemas: (agentName: string, tables: TableSpec[]) => TaskEither<Error, void>
    
    // Создание Zod валидаций
    createZodValidations: (agentName: string, schemas: SchemaSpec[]) => TaskEither<Error, void>
  }
  
  providers: {
    getTemplate: (type: 'agent' | 'plugin' | 'service') => TaskEither<Error, Template>
    getBestPractices: (domain: Domain) => TaskEither<Error, BestPractices>
  }
  
  services: {
    // Генерация полной инфраструктуры для агента
    buildCompleteInfrastructure: (spec: AgentSpec) => TaskEither<Error, CompleteInfrastructure>
  }
}
```

---

### 📊 План реализации "рабочих" агентов

#### Неделя 1: Инфраструктурные агенты

**День 1-2: VIBE-SENTRY**
- [ ] Установка Sentry SDK
- [ ] Создание базового модуля Sentry
- [ ] Интеграция с плагинами
- [ ] Настройка уведомлений админу
- [ ] Тестирование

**День 3-4: VIBE-ADMIN-COMMUNICATOR**
- [ ] Создание Telegram бота для админа
- [ ] Реализация streaming notifications
- [ ] Система запросов подтверждения
- [ ] Интеграция с агентами
- [ ] Тестирование

**День 5-7: VIBE-INFRASTRUCTURE-BUILDER**
- [ ] Генерация структуры агентов
- [ ] Автоматическая настройка Sentry
- [ ] Автоматическая настройка Admin Communicator
- [ ] Тестирование

#### Неделя 2: Агенты автономной разработки

**День 8-11: VIBE-SELF-CODING**
**День 12-14: VIBE-SELF-TESTING**

#### Неделя 3-4: Бизнес-агенты

*(Остальные агенты из основного списка)*

---

### ✅ Чек-лист для создания "рабочего" агента

При создании каждого "рабочего" агента необходимо:

1. **Инфраструктура**:
   - [ ] Использовать VIBE-INFRASTRUCTURE-BUILDER для создания структуры
   - [ ] Настроить Sentry через VIBE-SENTRY
   - [ ] Настроить Admin Communicator через VIBE-ADMIN-COMMUNICATOR

2. **Функциональность**:
   - [ ] Реализовать actions, providers, services
   - [ ] Использовать функциональный стиль (TaskEither)
   - [ ] Добавить Zod валидации

3. **Тестирование**:
   - [ ] 100% покрытие тестами
   - [ ] Property-based тесты
   - [ ] Интеграционные тесты

4. **Документация**:
   - [ ] Описание агента
   - [ ] Примеры использования
   - [ ] Troubleshooting guide

5. **Мониторинг**:
   - [ ] Настроить Sentry для отслеживания ошибок
   - [ ] Настроить Admin Communicator для уведомлений
   - [ ] Добавить метрики производительности

---

**🌱 Стратегия "рабочих" агентов готова! Начинаем с VIBE-SENTRY и VIBE-ADMIN-COMMUNICATOR!**

