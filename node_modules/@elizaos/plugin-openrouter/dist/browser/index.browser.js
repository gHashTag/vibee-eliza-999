var __create = Object.create;
var __getProtoOf = Object.getPrototypeOf;
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};
var __esm = (fn, res) => () => (fn && (res = fn(fn = 0)), res);
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});

// node:path
var exports_path = {};
__export(exports_path, {
  sep: () => sep,
  resolve: () => resolve,
  relative: () => relative,
  posix: () => posix,
  parse: () => parse,
  normalize: () => normalize,
  join: () => join,
  isAbsolute: () => isAbsolute,
  format: () => format,
  extname: () => extname,
  dirname: () => dirname,
  delimiter: () => delimiter,
  default: () => path_default,
  basename: () => basename,
  _makeLong: () => _makeLong
});
function assertPath(path) {
  if (typeof path !== "string")
    throw new TypeError("Path must be a string. Received " + JSON.stringify(path));
}
function normalizeStringPosix(path, allowAboveRoot) {
  var res = "", lastSegmentLength = 0, lastSlash = -1, dots = 0, code;
  for (var i = 0;i <= path.length; ++i) {
    if (i < path.length)
      code = path.charCodeAt(i);
    else if (code === 47)
      break;
    else
      code = 47;
    if (code === 47) {
      if (lastSlash === i - 1 || dots === 1)
        ;
      else if (lastSlash !== i - 1 && dots === 2) {
        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
          if (res.length > 2) {
            var lastSlashIndex = res.lastIndexOf("/");
            if (lastSlashIndex !== res.length - 1) {
              if (lastSlashIndex === -1)
                res = "", lastSegmentLength = 0;
              else
                res = res.slice(0, lastSlashIndex), lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
              lastSlash = i, dots = 0;
              continue;
            }
          } else if (res.length === 2 || res.length === 1) {
            res = "", lastSegmentLength = 0, lastSlash = i, dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          if (res.length > 0)
            res += "/..";
          else
            res = "..";
          lastSegmentLength = 2;
        }
      } else {
        if (res.length > 0)
          res += "/" + path.slice(lastSlash + 1, i);
        else
          res = path.slice(lastSlash + 1, i);
        lastSegmentLength = i - lastSlash - 1;
      }
      lastSlash = i, dots = 0;
    } else if (code === 46 && dots !== -1)
      ++dots;
    else
      dots = -1;
  }
  return res;
}
function _format(sep, pathObject) {
  var dir = pathObject.dir || pathObject.root, base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
  if (!dir)
    return base;
  if (dir === pathObject.root)
    return dir + base;
  return dir + sep + base;
}
function resolve() {
  var resolvedPath = "", resolvedAbsolute = false, cwd;
  for (var i = arguments.length - 1;i >= -1 && !resolvedAbsolute; i--) {
    var path;
    if (i >= 0)
      path = arguments[i];
    else {
      if (cwd === undefined)
        cwd = process.cwd();
      path = cwd;
    }
    if (assertPath(path), path.length === 0)
      continue;
    resolvedPath = path + "/" + resolvedPath, resolvedAbsolute = path.charCodeAt(0) === 47;
  }
  if (resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute), resolvedAbsolute)
    if (resolvedPath.length > 0)
      return "/" + resolvedPath;
    else
      return "/";
  else if (resolvedPath.length > 0)
    return resolvedPath;
  else
    return ".";
}
function normalize(path) {
  if (assertPath(path), path.length === 0)
    return ".";
  var isAbsolute = path.charCodeAt(0) === 47, trailingSeparator = path.charCodeAt(path.length - 1) === 47;
  if (path = normalizeStringPosix(path, !isAbsolute), path.length === 0 && !isAbsolute)
    path = ".";
  if (path.length > 0 && trailingSeparator)
    path += "/";
  if (isAbsolute)
    return "/" + path;
  return path;
}
function isAbsolute(path) {
  return assertPath(path), path.length > 0 && path.charCodeAt(0) === 47;
}
function join() {
  if (arguments.length === 0)
    return ".";
  var joined;
  for (var i = 0;i < arguments.length; ++i) {
    var arg = arguments[i];
    if (assertPath(arg), arg.length > 0)
      if (joined === undefined)
        joined = arg;
      else
        joined += "/" + arg;
  }
  if (joined === undefined)
    return ".";
  return normalize(joined);
}
function relative(from, to) {
  if (assertPath(from), assertPath(to), from === to)
    return "";
  if (from = resolve(from), to = resolve(to), from === to)
    return "";
  var fromStart = 1;
  for (;fromStart < from.length; ++fromStart)
    if (from.charCodeAt(fromStart) !== 47)
      break;
  var fromEnd = from.length, fromLen = fromEnd - fromStart, toStart = 1;
  for (;toStart < to.length; ++toStart)
    if (to.charCodeAt(toStart) !== 47)
      break;
  var toEnd = to.length, toLen = toEnd - toStart, length = fromLen < toLen ? fromLen : toLen, lastCommonSep = -1, i = 0;
  for (;i <= length; ++i) {
    if (i === length) {
      if (toLen > length) {
        if (to.charCodeAt(toStart + i) === 47)
          return to.slice(toStart + i + 1);
        else if (i === 0)
          return to.slice(toStart + i);
      } else if (fromLen > length) {
        if (from.charCodeAt(fromStart + i) === 47)
          lastCommonSep = i;
        else if (i === 0)
          lastCommonSep = 0;
      }
      break;
    }
    var fromCode = from.charCodeAt(fromStart + i), toCode = to.charCodeAt(toStart + i);
    if (fromCode !== toCode)
      break;
    else if (fromCode === 47)
      lastCommonSep = i;
  }
  var out = "";
  for (i = fromStart + lastCommonSep + 1;i <= fromEnd; ++i)
    if (i === fromEnd || from.charCodeAt(i) === 47)
      if (out.length === 0)
        out += "..";
      else
        out += "/..";
  if (out.length > 0)
    return out + to.slice(toStart + lastCommonSep);
  else {
    if (toStart += lastCommonSep, to.charCodeAt(toStart) === 47)
      ++toStart;
    return to.slice(toStart);
  }
}
function _makeLong(path) {
  return path;
}
function dirname(path) {
  if (assertPath(path), path.length === 0)
    return ".";
  var code = path.charCodeAt(0), hasRoot = code === 47, end = -1, matchedSlash = true;
  for (var i = path.length - 1;i >= 1; --i)
    if (code = path.charCodeAt(i), code === 47) {
      if (!matchedSlash) {
        end = i;
        break;
      }
    } else
      matchedSlash = false;
  if (end === -1)
    return hasRoot ? "/" : ".";
  if (hasRoot && end === 1)
    return "//";
  return path.slice(0, end);
}
function basename(path, ext) {
  if (ext !== undefined && typeof ext !== "string")
    throw new TypeError('"ext" argument must be a string');
  assertPath(path);
  var start = 0, end = -1, matchedSlash = true, i;
  if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
    if (ext.length === path.length && ext === path)
      return "";
    var extIdx = ext.length - 1, firstNonSlashEnd = -1;
    for (i = path.length - 1;i >= 0; --i) {
      var code = path.charCodeAt(i);
      if (code === 47) {
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else {
        if (firstNonSlashEnd === -1)
          matchedSlash = false, firstNonSlashEnd = i + 1;
        if (extIdx >= 0)
          if (code === ext.charCodeAt(extIdx)) {
            if (--extIdx === -1)
              end = i;
          } else
            extIdx = -1, end = firstNonSlashEnd;
      }
    }
    if (start === end)
      end = firstNonSlashEnd;
    else if (end === -1)
      end = path.length;
    return path.slice(start, end);
  } else {
    for (i = path.length - 1;i >= 0; --i)
      if (path.charCodeAt(i) === 47) {
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else if (end === -1)
        matchedSlash = false, end = i + 1;
    if (end === -1)
      return "";
    return path.slice(start, end);
  }
}
function extname(path) {
  assertPath(path);
  var startDot = -1, startPart = 0, end = -1, matchedSlash = true, preDotState = 0;
  for (var i = path.length - 1;i >= 0; --i) {
    var code = path.charCodeAt(i);
    if (code === 47) {
      if (!matchedSlash) {
        startPart = i + 1;
        break;
      }
      continue;
    }
    if (end === -1)
      matchedSlash = false, end = i + 1;
    if (code === 46) {
      if (startDot === -1)
        startDot = i;
      else if (preDotState !== 1)
        preDotState = 1;
    } else if (startDot !== -1)
      preDotState = -1;
  }
  if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1)
    return "";
  return path.slice(startDot, end);
}
function format(pathObject) {
  if (pathObject === null || typeof pathObject !== "object")
    throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
  return _format("/", pathObject);
}
function parse(path) {
  assertPath(path);
  var ret = { root: "", dir: "", base: "", ext: "", name: "" };
  if (path.length === 0)
    return ret;
  var code = path.charCodeAt(0), isAbsolute2 = code === 47, start;
  if (isAbsolute2)
    ret.root = "/", start = 1;
  else
    start = 0;
  var startDot = -1, startPart = 0, end = -1, matchedSlash = true, i = path.length - 1, preDotState = 0;
  for (;i >= start; --i) {
    if (code = path.charCodeAt(i), code === 47) {
      if (!matchedSlash) {
        startPart = i + 1;
        break;
      }
      continue;
    }
    if (end === -1)
      matchedSlash = false, end = i + 1;
    if (code === 46) {
      if (startDot === -1)
        startDot = i;
      else if (preDotState !== 1)
        preDotState = 1;
    } else if (startDot !== -1)
      preDotState = -1;
  }
  if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    if (end !== -1)
      if (startPart === 0 && isAbsolute2)
        ret.base = ret.name = path.slice(1, end);
      else
        ret.base = ret.name = path.slice(startPart, end);
  } else {
    if (startPart === 0 && isAbsolute2)
      ret.name = path.slice(1, startDot), ret.base = path.slice(1, end);
    else
      ret.name = path.slice(startPart, startDot), ret.base = path.slice(startPart, end);
    ret.ext = path.slice(startDot, end);
  }
  if (startPart > 0)
    ret.dir = path.slice(0, startPart - 1);
  else if (isAbsolute2)
    ret.dir = "/";
  return ret;
}
var sep = "/", delimiter = ":", posix, path_default;
var init_path = __esm(() => {
  posix = ((p) => (p.posix = p, p))({ resolve, normalize, isAbsolute, join, relative, _makeLong, dirname, basename, extname, format, parse, sep, delimiter, win32: null, posix: null });
  path_default = posix;
});

// src/index.ts
import {
  ModelType as ModelType4
} from "@elizaos/core";

// src/init.ts
import { logger } from "@elizaos/core";
import { fetch as fetch2 } from "undici";

// src/utils/config.ts
function getSetting(runtime, key, defaultValue) {
  return runtime.getSetting(key) ?? process.env[key] ?? defaultValue;
}
function getBaseURL(runtime) {
  const browserURL = getSetting(runtime, "OPENROUTER_BROWSER_BASE_URL");
  if (typeof globalThis !== "undefined" && globalThis.document && browserURL) {
    return browserURL;
  }
  return getSetting(runtime, "OPENROUTER_BASE_URL", "https://openrouter.ai/api/v1") || "https://openrouter.ai/api/v1";
}
function getApiKey(runtime) {
  return getSetting(runtime, "OPENROUTER_API_KEY");
}
function getSmallModel(runtime) {
  return getSetting(runtime, "OPENROUTER_SMALL_MODEL") ?? getSetting(runtime, "SMALL_MODEL", "google/gemini-2.0-flash-001") ?? "google/gemini-2.0-flash-001";
}
function getLargeModel(runtime) {
  return getSetting(runtime, "OPENROUTER_LARGE_MODEL") ?? getSetting(runtime, "LARGE_MODEL", "google/gemini-2.5-flash") ?? "google/gemini-2.5-flash";
}
function getImageModel(runtime) {
  return getSetting(runtime, "OPENROUTER_IMAGE_MODEL") ?? getSetting(runtime, "IMAGE_MODEL", "x-ai/grok-2-vision-1212") ?? "x-ai/grok-2-vision-1212";
}
function getImageGenerationModel(runtime) {
  return getSetting(runtime, "OPENROUTER_IMAGE_GENERATION_MODEL") ?? getSetting(runtime, "IMAGE_GENERATION_MODEL", "google/gemini-2.5-flash-image-preview") ?? "google/gemini-2.5-flash-image-preview";
}
function getEmbeddingModel(runtime) {
  return getSetting(runtime, "OPENROUTER_EMBEDDING_MODEL") ?? getSetting(runtime, "EMBEDDING_MODEL", "openai/text-embedding-3-small") ?? "openai/text-embedding-3-small";
}
function shouldAutoCleanupImages(runtime) {
  const setting = getSetting(runtime, "OPENROUTER_AUTO_CLEANUP_IMAGES", "false");
  return setting?.toLowerCase() === "true";
}
function getToolExecutionMaxSteps(runtime) {
  const setting = getSetting(runtime, "OPENROUTER_TOOL_EXECUTION_MAX_STEPS", "15");
  const value = parseInt(setting || "15", 10);
  if (Number.isNaN(value) || value < 1)
    return 15;
  if (value > 100)
    return 100;
  return value;
}

// src/init.ts
function initializeOpenRouter(_config, runtime) {
  (async () => {
    try {
      const isBrowser = typeof globalThis !== "undefined" && globalThis.document;
      if (isBrowser) {
        return;
      }
      if (!getApiKey(runtime)) {
        logger.warn("OPENROUTER_API_KEY is not set in environment - OpenRouter functionality will be limited");
        return;
      }
      try {
        const baseURL = getBaseURL(runtime);
        const response = await fetch2(`${baseURL}/models`, {
          headers: { Authorization: `Bearer ${getApiKey(runtime)}` }
        });
        if (!response.ok) {
          logger.warn(`OpenRouter API key validation failed: ${response.statusText}`);
          logger.warn("OpenRouter functionality will be limited until a valid API key is provided");
        } else {
          logger.log("OpenRouter API key validated successfully");
        }
      } catch (fetchError) {
        const message = fetchError instanceof Error ? fetchError.message : String(fetchError);
        logger.warn(`Error validating OpenRouter API key: ${message}`);
        logger.warn("OpenRouter functionality will be limited until a valid API key is provided");
      }
    } catch (error) {
      const message = error?.errors?.map((e) => e.message).join(", ") || (error instanceof Error ? error.message : String(error));
      logger.warn(`OpenRouter plugin configuration issue: ${message} - You need to configure the OPENROUTER_API_KEY in your environment variables`);
    }
  })();
  return;
}

// src/models/text.ts
import { logger as logger3, ModelType } from "@elizaos/core";
import { generateText, stepCountIs } from "ai";

// src/providers/openrouter.ts
import { createOpenRouter } from "@openrouter/ai-sdk-provider";
function createOpenRouterProvider(runtime) {
  const apiKey = getApiKey(runtime);
  const isBrowser = typeof globalThis !== "undefined" && globalThis.document;
  const baseURL = getBaseURL(runtime);
  return createOpenRouter({
    apiKey: isBrowser ? undefined : apiKey,
    baseURL
  });
}
// src/utils/events.ts
import {
  EventType
} from "@elizaos/core";
function emitModelUsageEvent(runtime, type, prompt, usage) {
  const truncatedPrompt = typeof prompt === "string" ? prompt.length > 200 ? `${prompt.slice(0, 200)}â€¦` : prompt : "";
  const inputTokens = Number(usage.inputTokens || 0);
  const outputTokens = Number(usage.outputTokens || 0);
  const totalTokens = Number(usage.totalTokens != null ? usage.totalTokens : inputTokens + outputTokens);
  runtime.emitEvent(EventType.MODEL_USED, {
    provider: "openrouter",
    type,
    prompt: truncatedPrompt,
    tokens: {
      prompt: inputTokens,
      completion: outputTokens,
      total: totalTokens
    }
  });
}

// src/utils/helpers.ts
import { logger as logger2 } from "@elizaos/core";
import { JSONParseError } from "ai";
function getJsonRepairFunction() {
  return async ({ text, error }) => {
    try {
      if (error instanceof JSONParseError) {
        const cleanedText = text.replace(/```json\n|\n```|```/g, "");
        JSON.parse(cleanedText);
        return cleanedText;
      }
      return null;
    } catch (jsonError) {
      const message = jsonError instanceof Error ? jsonError.message : String(jsonError);
      logger2.warn(`Failed to repair JSON text: ${message}`);
      return null;
    }
  };
}
function handleEmptyToolResponse(modelType) {
  logger2.warn(`[${modelType}] No text generated after tool execution`);
  const fallbackText = "I executed the requested action. The tool completed successfully.";
  logger2.warn(`[${modelType}] Using fallback response text`);
  return fallbackText;
}
function parseImageDescriptionResponse(responseText) {
  try {
    const jsonResponse = JSON.parse(responseText);
    if (jsonResponse.title && jsonResponse.description) {
      return jsonResponse;
    }
  } catch (e) {
    logger2.debug(`Parsing as JSON failed, processing as text: ${e}`);
  }
  const titleMatch = responseText.match(/title[:\s]+(.+?)(?:\n|$)/i);
  const title = titleMatch?.[1]?.trim() || "Image Analysis";
  const description = responseText.replace(/title[:\s]+(.+?)(?:\n|$)/i, "").trim();
  return { title, description };
}
async function handleObjectGenerationError(error) {
  if (error instanceof JSONParseError) {
    logger2.error(`[generateObject] Failed to parse JSON: ${error.message}`);
    const repairFunction = getJsonRepairFunction();
    const repairedJsonString = await repairFunction({
      text: error.text,
      error
    });
    if (repairedJsonString) {
      try {
        const repairedObject = JSON.parse(repairedJsonString);
        logger2.log("[generateObject] Successfully repaired JSON.");
        return repairedObject;
      } catch (repairParseError) {
        const message = repairParseError instanceof Error ? repairParseError.message : String(repairParseError);
        logger2.error(`[generateObject] Failed to parse repaired JSON: ${message}`);
        if (repairParseError instanceof Error)
          throw repairParseError;
        throw Object.assign(new Error(message), { cause: repairParseError });
      }
    } else {
      logger2.error("[generateObject] JSON repair failed.");
      throw error;
    }
  } else {
    const message = error instanceof Error ? error.message : String(error);
    logger2.error(`[generateObject] Unknown error: ${message}`);
    if (error instanceof Error)
      throw error;
    throw Object.assign(new Error(message), { cause: error });
  }
}
function isLikelyBase64(key, value) {
  const base64KeyPattern = /^(data|content|body|payload|encoded|b64|base64|document)$/i;
  if (!base64KeyPattern.test(key))
    return false;
  if (value.length < 20 || value.length > 1024 * 1024)
    return false;
  if (value.length % 4 !== 0)
    return false;
  if (!/^[A-Za-z0-9+/]*={0,2}$/.test(value))
    return false;
  return true;
}
function decodeBase64Fields(obj, depth = 0) {
  if (depth > 5)
    return obj;
  if (!obj || typeof obj !== "object")
    return obj;
  if (Array.isArray(obj))
    return obj.map((item) => decodeBase64Fields(item, depth + 1));
  const decoded = {};
  for (const [key, value] of Object.entries(obj)) {
    if (typeof value === "string" && isLikelyBase64(key, value)) {
      try {
        decoded[key] = Buffer.from(value, "base64").toString("utf8");
        logger2.debug(`[decodeBase64] Decoded field '${key}' (${value.length} chars)`);
      } catch (error) {
        logger2.warn(`[decodeBase64] Failed to decode field '${key}': ${error}`);
        decoded[key] = value;
      }
    } else if (value && typeof value === "object") {
      decoded[key] = decodeBase64Fields(value, depth + 1);
    } else {
      decoded[key] = value;
    }
  }
  return decoded;
}

// src/models/text.ts
async function generateTextWithModel(runtime, modelType, params) {
  const { prompt, stopSequences = [], tools, toolChoice } = params;
  const temperature = params.temperature ?? 0.7;
  const frequencyPenalty = params.frequencyPenalty ?? 0.7;
  const presencePenalty = params.presencePenalty ?? 0.7;
  const resolvedMaxOutput = params.maxOutputTokens ?? params.maxTokens ?? 8192;
  const openrouter = createOpenRouterProvider(runtime);
  const modelName = modelType === ModelType.TEXT_SMALL ? getSmallModel(runtime) : getLargeModel(runtime);
  const modelLabel = modelType === ModelType.TEXT_SMALL ? "TEXT_SMALL" : "TEXT_LARGE";
  logger3.debug(`[OpenRouter] Generating text with ${modelLabel} model: ${modelName}`);
  const generateParams = {
    model: openrouter.chat(modelName),
    prompt,
    system: runtime.character.system ?? undefined,
    temperature,
    frequencyPenalty,
    presencePenalty,
    stopSequences
  };
  generateParams.maxOutputTokens = resolvedMaxOutput;
  if (tools) {
    generateParams.tools = tools;
    const maxSteps = getToolExecutionMaxSteps(runtime);
    generateParams.stopWhen = stepCountIs(maxSteps);
    logger3.debug(`[OpenRouter] Using maxSteps: ${maxSteps} for tool execution`);
  }
  if (toolChoice) {
    generateParams.toolChoice = toolChoice;
  }
  let capturedToolResults = [];
  let capturedToolCalls = [];
  if (tools) {
    generateParams.onStepFinish = async (stepResult) => {
      if (stepResult.toolCalls && stepResult.toolCalls.length > 0) {
        capturedToolCalls = [
          ...capturedToolCalls,
          ...stepResult.toolCalls
        ];
      }
      if (stepResult.content && Array.isArray(stepResult.content)) {
        const toolResultsFromContent = stepResult.content.filter((content) => content.type === "tool-result" && content.output).map((content) => ({
          toolCallId: content.toolCallId,
          result: decodeBase64Fields(content.output)
        }));
        if (toolResultsFromContent.length > 0) {
          capturedToolResults = [...capturedToolResults, ...toolResultsFromContent];
        }
      }
    };
  }
  const response = await generateText(generateParams);
  let responseText;
  if (tools && (!response.text || response.text.trim() === "" || response.text === "Tools executed successfully.")) {
    responseText = handleEmptyToolResponse(modelLabel);
  } else {
    responseText = response.text;
  }
  if (response.usage) {
    emitModelUsageEvent(runtime, modelType, prompt, response.usage);
  }
  if (tools && response.steps && response.steps.length > 0) {
    return {
      text: responseText,
      toolCalls: capturedToolCalls,
      toolResults: capturedToolResults,
      steps: response.steps,
      usage: response.usage,
      finishReason: response.finishReason
    };
  }
  return responseText;
}
async function handleTextSmall(runtime, params) {
  return generateTextWithModel(runtime, ModelType.TEXT_SMALL, params);
}
async function handleTextLarge(runtime, params) {
  return generateTextWithModel(runtime, ModelType.TEXT_LARGE, params);
}

// src/models/object.ts
import {
  ModelType as ModelType2,
  logger as logger4
} from "@elizaos/core";
import { generateObject } from "ai";
async function generateObjectWithModel(runtime, modelType, params) {
  const openrouter = createOpenRouterProvider(runtime);
  const modelName = modelType === ModelType2.OBJECT_SMALL ? getSmallModel(runtime) : getLargeModel(runtime);
  const modelLabel = modelType === ModelType2.OBJECT_SMALL ? "OBJECT_SMALL" : "OBJECT_LARGE";
  logger4.log(`[OpenRouter] Using ${modelLabel} model: ${modelName}`);
  const temperature = params.temperature ?? 0.7;
  try {
    const { object, usage } = await generateObject({
      model: openrouter.chat(modelName),
      ...params.schema && { schema: params.schema },
      output: params.schema ? "object" : "no-schema",
      prompt: params.prompt,
      temperature,
      experimental_repairText: getJsonRepairFunction()
    });
    if (usage) {
      emitModelUsageEvent(runtime, modelType, params.prompt, usage);
    }
    return object;
  } catch (error) {
    return handleObjectGenerationError(error);
  }
}
async function handleObjectSmall(runtime, params) {
  return generateObjectWithModel(runtime, ModelType2.OBJECT_SMALL, params);
}
async function handleObjectLarge(runtime, params) {
  return generateObjectWithModel(runtime, ModelType2.OBJECT_LARGE, params);
}

// src/models/image.ts
import {
  logger as logger6
} from "@elizaos/core";
import { generateText as generateText2 } from "ai";

// src/utils/image-storage.ts
import { logger as logger5, getGeneratedDir } from "@elizaos/core";
function isBrowser() {
  return typeof globalThis !== "undefined" && globalThis.document;
}
function sanitizeId(id) {
  const src = (id ?? "").toString();
  const normalized = src.normalize("NFKC");
  let safe = normalized.replace(/[^a-zA-Z0-9_-]/g, "_");
  safe = safe.replace(/_+/g, "_");
  safe = safe.slice(0, 64);
  safe = safe.replace(/^_+|_+$/g, "");
  return safe || "agent";
}
function base64ToBytes(base64) {
  const cleaned = base64.replace(/\s+/g, "");
  const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  const lookup = new Array(256).fill(-1);
  for (let i = 0;i < chars.length; i++)
    lookup[chars.charCodeAt(i)] = i;
  const len = cleaned.length;
  let pad = 0;
  if (len >= 2 && cleaned[len - 1] === "=")
    pad++;
  if (len >= 2 && cleaned[len - 2] === "=")
    pad++;
  const outLen = (len * 3 >> 2) - pad;
  const out = new Uint8Array(outLen);
  let o = 0;
  for (let i = 0;i < len; i += 4) {
    const c0 = lookup[cleaned.charCodeAt(i)];
    const c1 = lookup[cleaned.charCodeAt(i + 1)];
    const c2 = lookup[cleaned.charCodeAt(i + 2)];
    const c3 = lookup[cleaned.charCodeAt(i + 3)];
    const n = c0 << 18 | c1 << 12 | (c2 & 63) << 6 | c3 & 63;
    if (o < outLen)
      out[o++] = n >> 16 & 255;
    if (o < outLen)
      out[o++] = n >> 8 & 255;
    if (o < outLen)
      out[o++] = n & 255;
  }
  return out;
}
async function saveBase64Image(base64Url, agentId, index = 0) {
  if (isBrowser()) {
    return null;
  }
  const m = base64Url.match(/^data:(image\/[a-zA-Z0-9.+-]+);base64,([A-Za-z0-9+/=]+)$/);
  if (!m)
    return null;
  const mime = m[1];
  const base64Data = m[2];
  const extMap = {
    "image/png": "png",
    "image/jpeg": "jpg",
    "image/jpg": "jpg",
    "image/webp": "webp",
    "image/gif": "gif",
    "image/bmp": "bmp",
    "image/tiff": "tiff"
  };
  const extension = extMap[mime];
  if (!extension)
    return null;
  const { join: join2 } = await Promise.resolve().then(() => (init_path(), exports_path));
  const safeAgentId = sanitizeId(agentId);
  const baseDir = join2(getGeneratedDir(), safeAgentId);
  const { existsSync } = await import("node:fs");
  if (!existsSync(baseDir)) {
    const { mkdir } = await import("node:fs/promises");
    await mkdir(baseDir, { recursive: true });
  }
  const timestamp = Date.now();
  const filename = `image_${timestamp}_${index}.${extension}`;
  const filepath = join2(baseDir, filename);
  const buffer = base64ToBytes(base64Data);
  const { writeFile } = await import("node:fs/promises");
  await writeFile(filepath, buffer);
  logger5.info(`[OpenRouter] Saved generated image to ${filepath}`);
  return filepath;
}
function deleteImage(filepath) {
  if (isBrowser()) {
    return;
  }
  try {
    (async () => {
      const { existsSync, unlinkSync } = await import("node:fs");
      if (existsSync(filepath)) {
        unlinkSync(filepath);
        logger5.debug(`[OpenRouter] Deleted image: ${filepath}`);
      }
    })().catch((error) => {
      logger5.warn(`[OpenRouter] Failed to delete image ${filepath}:`, String(error));
    });
  } catch (error) {
    logger5.warn(`[OpenRouter] Failed to delete image ${filepath}:`, String(error));
  }
}

// src/models/image.ts
async function handleImageDescription(runtime, params) {
  let imageUrl;
  let promptText;
  const modelName = getImageModel(runtime);
  logger6.log(`[OpenRouter] Using IMAGE_DESCRIPTION model: ${modelName}`);
  const maxOutputTokens = 300;
  if (typeof params === "string") {
    imageUrl = params;
    promptText = "Please analyze this image and provide a title and detailed description.";
  } else {
    imageUrl = params.imageUrl;
    promptText = params.prompt || "Please analyze this image and provide a title and detailed description.";
  }
  const openrouter = createOpenRouterProvider(runtime);
  const messages = [
    {
      role: "user",
      content: [
        { type: "text", text: promptText },
        { type: "image", image: imageUrl }
      ]
    }
  ];
  try {
    const model = openrouter.chat(modelName);
    const { text: responseText } = await generateText2({
      model,
      messages,
      maxOutputTokens
    });
    return parseImageDescriptionResponse(responseText);
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    logger6.error(`Error analyzing image: ${message}`);
    return {
      title: "Failed to analyze image",
      description: `Error: ${message}`
    };
  }
}
async function handleImageGeneration(runtime, params) {
  const modelName = getImageGenerationModel(runtime);
  logger6.log(`[OpenRouter] Using IMAGE_GENERATION model: ${modelName}`);
  const apiKey = getApiKey(runtime);
  try {
    const baseUrl = getBaseURL(runtime);
    const isBrowser2 = typeof globalThis !== "undefined" && globalThis.document;
    const response = await fetch(`${baseUrl}/chat/completions`, {
      method: "POST",
      headers: {
        ...isBrowser2 ? {} : { Authorization: `Bearer ${apiKey}` },
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        model: modelName,
        messages: [
          {
            role: "user",
            content: params.prompt
          }
        ],
        modalities: ["image", "text"]
      }),
      signal: AbortSignal.timeout ? AbortSignal.timeout(60000) : undefined
    });
    if (!response.ok) {
      const errorText = await response.text().catch(() => "");
      throw new Error(`HTTP ${response.status} ${response.statusText} ${errorText}`);
    }
    const result = await response.json();
    const images = [];
    const savedPaths = [];
    if (result.choices?.[0]?.message?.images) {
      for (const [index, image] of result.choices[0].message.images.entries()) {
        const base64Url = image.image_url.url;
        const filepath = await saveBase64Image(base64Url, runtime.agentId, index);
        if (filepath) {
          logger6.log(`[OpenRouter] Returning image with filepath: ${filepath}`);
          images.push({
            url: filepath
          });
          savedPaths.push(filepath);
        } else if (!base64Url.startsWith("data:")) {
          images.push({ url: base64Url });
        } else {
          logger6.warn(`[OpenRouter] Failed to save image ${index + 1}, skipping`);
        }
      }
    }
    if (savedPaths.length > 0 && shouldAutoCleanupImages(runtime)) {
      setTimeout(() => {
        savedPaths.forEach((path) => {
          deleteImage(path);
        });
      }, 30000);
    }
    if (images.length === 0) {
      throw new Error("No images generated in response");
    }
    logger6.log(`[OpenRouter] Generated ${images.length} image(s)`);
    return images;
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    logger6.error(`[OpenRouter] Error generating image: ${message}`);
    return [];
  }
}

// src/models/embedding.ts
import { logger as logger7, ModelType as ModelType3, VECTOR_DIMS } from "@elizaos/core";
async function handleTextEmbedding(runtime, params) {
  const embeddingModelName = getEmbeddingModel(runtime);
  const embeddingDimension = Number.parseInt(getSetting(runtime, "OPENROUTER_EMBEDDING_DIMENSIONS") ?? getSetting(runtime, "EMBEDDING_DIMENSIONS") ?? "1536", 10);
  if (!Object.values(VECTOR_DIMS).includes(embeddingDimension)) {
    const errorMsg = `Invalid embedding dimension: ${embeddingDimension}. Must be one of: ${Object.values(VECTOR_DIMS).join(", ")}`;
    logger7.error(errorMsg);
    throw new Error(errorMsg);
  }
  if (params === null) {
    logger7.debug("Creating test embedding for initialization");
    const testVector = Array(embeddingDimension).fill(0);
    testVector[0] = 0.1;
    return testVector;
  }
  let text;
  if (typeof params === "string") {
    text = params;
  } else if (typeof params === "object" && params.text) {
    text = params.text;
  } else {
    const errorMsg = "Invalid input format for embedding";
    logger7.warn(errorMsg);
    const fallbackVector = Array(embeddingDimension).fill(0);
    fallbackVector[0] = 0.2;
    return fallbackVector;
  }
  if (!text.trim()) {
    const errorMsg = "Empty text for embedding";
    logger7.warn(errorMsg);
    const fallbackVector = Array(embeddingDimension).fill(0);
    fallbackVector[0] = 0.3;
    return fallbackVector;
  }
  const apiKey = getApiKey(runtime);
  if (!apiKey) {
    const errorMsg = "OPENROUTER_API_KEY is not set";
    logger7.error(errorMsg);
    throw new Error(errorMsg);
  }
  const baseURL = getBaseURL(runtime);
  try {
    const response = await fetch(`${baseURL}/embeddings`, {
      method: "POST",
      headers: {
        Authorization: `Bearer ${apiKey}`,
        "Content-Type": "application/json",
        "HTTP-Referer": getSetting(runtime, "OPENROUTER_HTTP_REFERER") || "",
        "X-Title": getSetting(runtime, "OPENROUTER_X_TITLE") || "ElizaOS"
      },
      body: JSON.stringify({
        model: embeddingModelName,
        input: text
      })
    });
    if (!response.ok) {
      logger7.error(`OpenRouter API error: ${response.status} - ${response.statusText}`);
      throw new Error(`OpenRouter API error: ${response.status} - ${response.statusText}`);
    }
    const data = await response.json();
    if (!data?.data?.[0]?.embedding) {
      logger7.error("API returned invalid structure");
      throw new Error("API returned invalid structure");
    }
    const embedding = data.data[0].embedding;
    if (!Array.isArray(embedding) || embedding.length !== embeddingDimension) {
      const errorMsg = `Embedding length ${embedding?.length ?? 0} does not match configured dimension ${embeddingDimension}`;
      logger7.error(errorMsg);
      const fallbackVector = Array(embeddingDimension).fill(0);
      fallbackVector[0] = 0.4;
      return fallbackVector;
    }
    if (data.usage) {
      const usage = {
        inputTokens: data.usage.prompt_tokens,
        outputTokens: 0,
        totalTokens: data.usage.total_tokens
      };
      emitModelUsageEvent(runtime, ModelType3.TEXT_EMBEDDING, text, usage);
    }
    logger7.log(`Got valid embedding with length ${embedding.length}`);
    return embedding;
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    logger7.error(`Error generating embedding: ${message}`);
    throw error instanceof Error ? error : new Error(message);
  }
}

// src/index.ts
var openrouterPlugin = {
  name: "openrouter",
  description: "OpenRouter plugin",
  config: {
    OPENROUTER_API_KEY: process.env.OPENROUTER_API_KEY,
    OPENROUTER_BASE_URL: process.env.OPENROUTER_BASE_URL,
    OPENROUTER_SMALL_MODEL: process.env.OPENROUTER_SMALL_MODEL,
    OPENROUTER_LARGE_MODEL: process.env.OPENROUTER_LARGE_MODEL,
    OPENROUTER_IMAGE_MODEL: process.env.OPENROUTER_IMAGE_MODEL,
    OPENROUTER_IMAGE_GENERATION_MODEL: process.env.OPENROUTER_IMAGE_GENERATION_MODEL,
    OPENROUTER_EMBEDDING_MODEL: process.env.OPENROUTER_EMBEDDING_MODEL,
    OPENROUTER_EMBEDDING_DIMENSIONS: process.env.OPENROUTER_EMBEDDING_DIMENSIONS,
    OPENROUTER_AUTO_CLEANUP_IMAGES: process.env.OPENROUTER_AUTO_CLEANUP_IMAGES,
    SMALL_MODEL: process.env.SMALL_MODEL,
    LARGE_MODEL: process.env.LARGE_MODEL,
    IMAGE_MODEL: process.env.IMAGE_MODEL,
    IMAGE_GENERATION_MODEL: process.env.IMAGE_GENERATION_MODEL,
    EMBEDDING_MODEL: process.env.EMBEDDING_MODEL,
    EMBEDDING_DIMENSIONS: process.env.EMBEDDING_DIMENSIONS
  },
  async init(config, runtime) {
    initializeOpenRouter(config, runtime);
  },
  models: {
    [ModelType4.TEXT_SMALL]: async (runtime, params) => {
      return handleTextSmall(runtime, params);
    },
    [ModelType4.TEXT_LARGE]: async (runtime, params) => {
      return handleTextLarge(runtime, params);
    },
    [ModelType4.OBJECT_SMALL]: async (runtime, params) => {
      return handleObjectSmall(runtime, params);
    },
    [ModelType4.OBJECT_LARGE]: async (runtime, params) => {
      return handleObjectLarge(runtime, params);
    },
    [ModelType4.IMAGE_DESCRIPTION]: async (runtime, params) => {
      return handleImageDescription(runtime, params);
    },
    [ModelType4.IMAGE]: async (runtime, params) => {
      return handleImageGeneration(runtime, params);
    },
    [ModelType4.TEXT_EMBEDDING]: async (runtime, params) => {
      return handleTextEmbedding(runtime, params);
    }
  }
};
var src_default = openrouterPlugin;
export {
  openrouterPlugin,
  src_default as default
};

//# debugId=A21BECF40882BC4264756E2164756E21
