var __create = Object.create;
var __getProtoOf = Object.getPrototypeOf;
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __moduleCache = /* @__PURE__ */ new WeakMap;
var __toCommonJS = (from) => {
  var entry = __moduleCache.get(from), desc;
  if (entry)
    return entry;
  entry = __defProp({}, "__esModule", { value: true });
  if (from && typeof from === "object" || typeof from === "function")
    __getOwnPropNames(from).map((key) => !__hasOwnProp.call(entry, key) && __defProp(entry, key, {
      get: () => from[key],
      enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
    }));
  __moduleCache.set(from, entry);
  return entry;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};

// src/index.node.ts
var exports_index_node = {};
__export(exports_index_node, {
  openrouterPlugin: () => openrouterPlugin,
  default: () => src_default
});
module.exports = __toCommonJS(exports_index_node);

// src/index.ts
var import_core9 = require("@elizaos/core");

// src/init.ts
var import_core = require("@elizaos/core");
var import_undici = require("undici");

// src/utils/config.ts
function getSetting(runtime, key, defaultValue) {
  return runtime.getSetting(key) ?? process.env[key] ?? defaultValue;
}
function getBaseURL(runtime) {
  const browserURL = getSetting(runtime, "OPENROUTER_BROWSER_BASE_URL");
  if (typeof globalThis !== "undefined" && globalThis.document && browserURL) {
    return browserURL;
  }
  return getSetting(runtime, "OPENROUTER_BASE_URL", "https://openrouter.ai/api/v1") || "https://openrouter.ai/api/v1";
}
function getApiKey(runtime) {
  return getSetting(runtime, "OPENROUTER_API_KEY");
}
function getSmallModel(runtime) {
  return getSetting(runtime, "OPENROUTER_SMALL_MODEL") ?? getSetting(runtime, "SMALL_MODEL", "google/gemini-2.0-flash-001") ?? "google/gemini-2.0-flash-001";
}
function getLargeModel(runtime) {
  return getSetting(runtime, "OPENROUTER_LARGE_MODEL") ?? getSetting(runtime, "LARGE_MODEL", "google/gemini-2.5-flash") ?? "google/gemini-2.5-flash";
}
function getImageModel(runtime) {
  return getSetting(runtime, "OPENROUTER_IMAGE_MODEL") ?? getSetting(runtime, "IMAGE_MODEL", "x-ai/grok-2-vision-1212") ?? "x-ai/grok-2-vision-1212";
}
function getImageGenerationModel(runtime) {
  return getSetting(runtime, "OPENROUTER_IMAGE_GENERATION_MODEL") ?? getSetting(runtime, "IMAGE_GENERATION_MODEL", "google/gemini-2.5-flash-image-preview") ?? "google/gemini-2.5-flash-image-preview";
}
function getEmbeddingModel(runtime) {
  return getSetting(runtime, "OPENROUTER_EMBEDDING_MODEL") ?? getSetting(runtime, "EMBEDDING_MODEL", "openai/text-embedding-3-small") ?? "openai/text-embedding-3-small";
}
function shouldAutoCleanupImages(runtime) {
  const setting = getSetting(runtime, "OPENROUTER_AUTO_CLEANUP_IMAGES", "false");
  return setting?.toLowerCase() === "true";
}
function getToolExecutionMaxSteps(runtime) {
  const setting = getSetting(runtime, "OPENROUTER_TOOL_EXECUTION_MAX_STEPS", "15");
  const value = parseInt(setting || "15", 10);
  if (Number.isNaN(value) || value < 1)
    return 15;
  if (value > 100)
    return 100;
  return value;
}

// src/init.ts
function initializeOpenRouter(_config, runtime) {
  (async () => {
    try {
      const isBrowser = typeof globalThis !== "undefined" && globalThis.document;
      if (isBrowser) {
        return;
      }
      if (!getApiKey(runtime)) {
        import_core.logger.warn("OPENROUTER_API_KEY is not set in environment - OpenRouter functionality will be limited");
        return;
      }
      try {
        const baseURL = getBaseURL(runtime);
        const response = await import_undici.fetch(`${baseURL}/models`, {
          headers: { Authorization: `Bearer ${getApiKey(runtime)}` }
        });
        if (!response.ok) {
          import_core.logger.warn(`OpenRouter API key validation failed: ${response.statusText}`);
          import_core.logger.warn("OpenRouter functionality will be limited until a valid API key is provided");
        } else {
          import_core.logger.log("OpenRouter API key validated successfully");
        }
      } catch (fetchError) {
        const message = fetchError instanceof Error ? fetchError.message : String(fetchError);
        import_core.logger.warn(`Error validating OpenRouter API key: ${message}`);
        import_core.logger.warn("OpenRouter functionality will be limited until a valid API key is provided");
      }
    } catch (error) {
      const message = error?.errors?.map((e) => e.message).join(", ") || (error instanceof Error ? error.message : String(error));
      import_core.logger.warn(`OpenRouter plugin configuration issue: ${message} - You need to configure the OPENROUTER_API_KEY in your environment variables`);
    }
  })();
  return;
}

// src/models/text.ts
var import_core4 = require("@elizaos/core");
var import_ai2 = require("ai");

// src/providers/openrouter.ts
var import_ai_sdk_provider = require("@openrouter/ai-sdk-provider");
function createOpenRouterProvider(runtime) {
  const apiKey = getApiKey(runtime);
  const isBrowser = typeof globalThis !== "undefined" && globalThis.document;
  const baseURL = getBaseURL(runtime);
  return import_ai_sdk_provider.createOpenRouter({
    apiKey: isBrowser ? undefined : apiKey,
    baseURL
  });
}
// src/utils/events.ts
var import_core2 = require("@elizaos/core");
function emitModelUsageEvent(runtime, type, prompt, usage) {
  const truncatedPrompt = typeof prompt === "string" ? prompt.length > 200 ? `${prompt.slice(0, 200)}â€¦` : prompt : "";
  const inputTokens = Number(usage.inputTokens || 0);
  const outputTokens = Number(usage.outputTokens || 0);
  const totalTokens = Number(usage.totalTokens != null ? usage.totalTokens : inputTokens + outputTokens);
  runtime.emitEvent(import_core2.EventType.MODEL_USED, {
    provider: "openrouter",
    type,
    prompt: truncatedPrompt,
    tokens: {
      prompt: inputTokens,
      completion: outputTokens,
      total: totalTokens
    }
  });
}

// src/utils/helpers.ts
var import_core3 = require("@elizaos/core");
var import_ai = require("ai");
function getJsonRepairFunction() {
  return async ({ text, error }) => {
    try {
      if (error instanceof import_ai.JSONParseError) {
        const cleanedText = text.replace(/```json\n|\n```|```/g, "");
        JSON.parse(cleanedText);
        return cleanedText;
      }
      return null;
    } catch (jsonError) {
      const message = jsonError instanceof Error ? jsonError.message : String(jsonError);
      import_core3.logger.warn(`Failed to repair JSON text: ${message}`);
      return null;
    }
  };
}
function handleEmptyToolResponse(modelType) {
  import_core3.logger.warn(`[${modelType}] No text generated after tool execution`);
  const fallbackText = "I executed the requested action. The tool completed successfully.";
  import_core3.logger.warn(`[${modelType}] Using fallback response text`);
  return fallbackText;
}
function parseImageDescriptionResponse(responseText) {
  try {
    const jsonResponse = JSON.parse(responseText);
    if (jsonResponse.title && jsonResponse.description) {
      return jsonResponse;
    }
  } catch (e) {
    import_core3.logger.debug(`Parsing as JSON failed, processing as text: ${e}`);
  }
  const titleMatch = responseText.match(/title[:\s]+(.+?)(?:\n|$)/i);
  const title = titleMatch?.[1]?.trim() || "Image Analysis";
  const description = responseText.replace(/title[:\s]+(.+?)(?:\n|$)/i, "").trim();
  return { title, description };
}
async function handleObjectGenerationError(error) {
  if (error instanceof import_ai.JSONParseError) {
    import_core3.logger.error(`[generateObject] Failed to parse JSON: ${error.message}`);
    const repairFunction = getJsonRepairFunction();
    const repairedJsonString = await repairFunction({
      text: error.text,
      error
    });
    if (repairedJsonString) {
      try {
        const repairedObject = JSON.parse(repairedJsonString);
        import_core3.logger.log("[generateObject] Successfully repaired JSON.");
        return repairedObject;
      } catch (repairParseError) {
        const message = repairParseError instanceof Error ? repairParseError.message : String(repairParseError);
        import_core3.logger.error(`[generateObject] Failed to parse repaired JSON: ${message}`);
        if (repairParseError instanceof Error)
          throw repairParseError;
        throw Object.assign(new Error(message), { cause: repairParseError });
      }
    } else {
      import_core3.logger.error("[generateObject] JSON repair failed.");
      throw error;
    }
  } else {
    const message = error instanceof Error ? error.message : String(error);
    import_core3.logger.error(`[generateObject] Unknown error: ${message}`);
    if (error instanceof Error)
      throw error;
    throw Object.assign(new Error(message), { cause: error });
  }
}
function isLikelyBase64(key, value) {
  const base64KeyPattern = /^(data|content|body|payload|encoded|b64|base64|document)$/i;
  if (!base64KeyPattern.test(key))
    return false;
  if (value.length < 20 || value.length > 1024 * 1024)
    return false;
  if (value.length % 4 !== 0)
    return false;
  if (!/^[A-Za-z0-9+/]*={0,2}$/.test(value))
    return false;
  return true;
}
function decodeBase64Fields(obj, depth = 0) {
  if (depth > 5)
    return obj;
  if (!obj || typeof obj !== "object")
    return obj;
  if (Array.isArray(obj))
    return obj.map((item) => decodeBase64Fields(item, depth + 1));
  const decoded = {};
  for (const [key, value] of Object.entries(obj)) {
    if (typeof value === "string" && isLikelyBase64(key, value)) {
      try {
        decoded[key] = Buffer.from(value, "base64").toString("utf8");
        import_core3.logger.debug(`[decodeBase64] Decoded field '${key}' (${value.length} chars)`);
      } catch (error) {
        import_core3.logger.warn(`[decodeBase64] Failed to decode field '${key}': ${error}`);
        decoded[key] = value;
      }
    } else if (value && typeof value === "object") {
      decoded[key] = decodeBase64Fields(value, depth + 1);
    } else {
      decoded[key] = value;
    }
  }
  return decoded;
}

// src/models/text.ts
async function generateTextWithModel(runtime, modelType, params) {
  const { prompt, stopSequences = [], tools, toolChoice } = params;
  const temperature = params.temperature ?? 0.7;
  const frequencyPenalty = params.frequencyPenalty ?? 0.7;
  const presencePenalty = params.presencePenalty ?? 0.7;
  const resolvedMaxOutput = params.maxOutputTokens ?? params.maxTokens ?? 8192;
  const openrouter = createOpenRouterProvider(runtime);
  const modelName = modelType === import_core4.ModelType.TEXT_SMALL ? getSmallModel(runtime) : getLargeModel(runtime);
  const modelLabel = modelType === import_core4.ModelType.TEXT_SMALL ? "TEXT_SMALL" : "TEXT_LARGE";
  import_core4.logger.debug(`[OpenRouter] Generating text with ${modelLabel} model: ${modelName}`);
  const generateParams = {
    model: openrouter.chat(modelName),
    prompt,
    system: runtime.character.system ?? undefined,
    temperature,
    frequencyPenalty,
    presencePenalty,
    stopSequences
  };
  generateParams.maxOutputTokens = resolvedMaxOutput;
  if (tools) {
    generateParams.tools = tools;
    const maxSteps = getToolExecutionMaxSteps(runtime);
    generateParams.stopWhen = import_ai2.stepCountIs(maxSteps);
    import_core4.logger.debug(`[OpenRouter] Using maxSteps: ${maxSteps} for tool execution`);
  }
  if (toolChoice) {
    generateParams.toolChoice = toolChoice;
  }
  let capturedToolResults = [];
  let capturedToolCalls = [];
  if (tools) {
    generateParams.onStepFinish = async (stepResult) => {
      if (stepResult.toolCalls && stepResult.toolCalls.length > 0) {
        capturedToolCalls = [
          ...capturedToolCalls,
          ...stepResult.toolCalls
        ];
      }
      if (stepResult.content && Array.isArray(stepResult.content)) {
        const toolResultsFromContent = stepResult.content.filter((content) => content.type === "tool-result" && content.output).map((content) => ({
          toolCallId: content.toolCallId,
          result: decodeBase64Fields(content.output)
        }));
        if (toolResultsFromContent.length > 0) {
          capturedToolResults = [...capturedToolResults, ...toolResultsFromContent];
        }
      }
    };
  }
  const response = await import_ai2.generateText(generateParams);
  let responseText;
  if (tools && (!response.text || response.text.trim() === "" || response.text === "Tools executed successfully.")) {
    responseText = handleEmptyToolResponse(modelLabel);
  } else {
    responseText = response.text;
  }
  if (response.usage) {
    emitModelUsageEvent(runtime, modelType, prompt, response.usage);
  }
  if (tools && response.steps && response.steps.length > 0) {
    return {
      text: responseText,
      toolCalls: capturedToolCalls,
      toolResults: capturedToolResults,
      steps: response.steps,
      usage: response.usage,
      finishReason: response.finishReason
    };
  }
  return responseText;
}
async function handleTextSmall(runtime, params) {
  return generateTextWithModel(runtime, import_core4.ModelType.TEXT_SMALL, params);
}
async function handleTextLarge(runtime, params) {
  return generateTextWithModel(runtime, import_core4.ModelType.TEXT_LARGE, params);
}

// src/models/object.ts
var import_core5 = require("@elizaos/core");
var import_ai3 = require("ai");
async function generateObjectWithModel(runtime, modelType, params) {
  const openrouter = createOpenRouterProvider(runtime);
  const modelName = modelType === import_core5.ModelType.OBJECT_SMALL ? getSmallModel(runtime) : getLargeModel(runtime);
  const modelLabel = modelType === import_core5.ModelType.OBJECT_SMALL ? "OBJECT_SMALL" : "OBJECT_LARGE";
  import_core5.logger.log(`[OpenRouter] Using ${modelLabel} model: ${modelName}`);
  const temperature = params.temperature ?? 0.7;
  try {
    const { object, usage } = await import_ai3.generateObject({
      model: openrouter.chat(modelName),
      ...params.schema && { schema: params.schema },
      output: params.schema ? "object" : "no-schema",
      prompt: params.prompt,
      temperature,
      experimental_repairText: getJsonRepairFunction()
    });
    if (usage) {
      emitModelUsageEvent(runtime, modelType, params.prompt, usage);
    }
    return object;
  } catch (error) {
    return handleObjectGenerationError(error);
  }
}
async function handleObjectSmall(runtime, params) {
  return generateObjectWithModel(runtime, import_core5.ModelType.OBJECT_SMALL, params);
}
async function handleObjectLarge(runtime, params) {
  return generateObjectWithModel(runtime, import_core5.ModelType.OBJECT_LARGE, params);
}

// src/models/image.ts
var import_core7 = require("@elizaos/core");
var import_ai4 = require("ai");

// src/utils/image-storage.ts
var import_core6 = require("@elizaos/core");
function isBrowser() {
  return typeof globalThis !== "undefined" && globalThis.document;
}
function sanitizeId(id) {
  const src = (id ?? "").toString();
  const normalized = src.normalize("NFKC");
  let safe = normalized.replace(/[^a-zA-Z0-9_-]/g, "_");
  safe = safe.replace(/_+/g, "_");
  safe = safe.slice(0, 64);
  safe = safe.replace(/^_+|_+$/g, "");
  return safe || "agent";
}
function base64ToBytes(base64) {
  const cleaned = base64.replace(/\s+/g, "");
  const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  const lookup = new Array(256).fill(-1);
  for (let i = 0;i < chars.length; i++)
    lookup[chars.charCodeAt(i)] = i;
  const len = cleaned.length;
  let pad = 0;
  if (len >= 2 && cleaned[len - 1] === "=")
    pad++;
  if (len >= 2 && cleaned[len - 2] === "=")
    pad++;
  const outLen = (len * 3 >> 2) - pad;
  const out = new Uint8Array(outLen);
  let o = 0;
  for (let i = 0;i < len; i += 4) {
    const c0 = lookup[cleaned.charCodeAt(i)];
    const c1 = lookup[cleaned.charCodeAt(i + 1)];
    const c2 = lookup[cleaned.charCodeAt(i + 2)];
    const c3 = lookup[cleaned.charCodeAt(i + 3)];
    const n = c0 << 18 | c1 << 12 | (c2 & 63) << 6 | c3 & 63;
    if (o < outLen)
      out[o++] = n >> 16 & 255;
    if (o < outLen)
      out[o++] = n >> 8 & 255;
    if (o < outLen)
      out[o++] = n & 255;
  }
  return out;
}
async function saveBase64Image(base64Url, agentId, index = 0) {
  if (isBrowser()) {
    return null;
  }
  const m = base64Url.match(/^data:(image\/[a-zA-Z0-9.+-]+);base64,([A-Za-z0-9+/=]+)$/);
  if (!m)
    return null;
  const mime = m[1];
  const base64Data = m[2];
  const extMap = {
    "image/png": "png",
    "image/jpeg": "jpg",
    "image/jpg": "jpg",
    "image/webp": "webp",
    "image/gif": "gif",
    "image/bmp": "bmp",
    "image/tiff": "tiff"
  };
  const extension = extMap[mime];
  if (!extension)
    return null;
  const { join } = await import("node:path");
  const safeAgentId = sanitizeId(agentId);
  const baseDir = join(import_core6.getGeneratedDir(), safeAgentId);
  const { existsSync } = await import("node:fs");
  if (!existsSync(baseDir)) {
    const { mkdir } = await import("node:fs/promises");
    await mkdir(baseDir, { recursive: true });
  }
  const timestamp = Date.now();
  const filename = `image_${timestamp}_${index}.${extension}`;
  const filepath = join(baseDir, filename);
  const buffer = base64ToBytes(base64Data);
  const { writeFile } = await import("node:fs/promises");
  await writeFile(filepath, buffer);
  import_core6.logger.info(`[OpenRouter] Saved generated image to ${filepath}`);
  return filepath;
}
function deleteImage(filepath) {
  if (isBrowser()) {
    return;
  }
  try {
    (async () => {
      const { existsSync, unlinkSync } = await import("node:fs");
      if (existsSync(filepath)) {
        unlinkSync(filepath);
        import_core6.logger.debug(`[OpenRouter] Deleted image: ${filepath}`);
      }
    })().catch((error) => {
      import_core6.logger.warn(`[OpenRouter] Failed to delete image ${filepath}:`, String(error));
    });
  } catch (error) {
    import_core6.logger.warn(`[OpenRouter] Failed to delete image ${filepath}:`, String(error));
  }
}

// src/models/image.ts
async function handleImageDescription(runtime, params) {
  let imageUrl;
  let promptText;
  const modelName = getImageModel(runtime);
  import_core7.logger.log(`[OpenRouter] Using IMAGE_DESCRIPTION model: ${modelName}`);
  const maxOutputTokens = 300;
  if (typeof params === "string") {
    imageUrl = params;
    promptText = "Please analyze this image and provide a title and detailed description.";
  } else {
    imageUrl = params.imageUrl;
    promptText = params.prompt || "Please analyze this image and provide a title and detailed description.";
  }
  const openrouter = createOpenRouterProvider(runtime);
  const messages = [
    {
      role: "user",
      content: [
        { type: "text", text: promptText },
        { type: "image", image: imageUrl }
      ]
    }
  ];
  try {
    const model = openrouter.chat(modelName);
    const { text: responseText } = await import_ai4.generateText({
      model,
      messages,
      maxOutputTokens
    });
    return parseImageDescriptionResponse(responseText);
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    import_core7.logger.error(`Error analyzing image: ${message}`);
    return {
      title: "Failed to analyze image",
      description: `Error: ${message}`
    };
  }
}
async function handleImageGeneration(runtime, params) {
  const modelName = getImageGenerationModel(runtime);
  import_core7.logger.log(`[OpenRouter] Using IMAGE_GENERATION model: ${modelName}`);
  const apiKey = getApiKey(runtime);
  try {
    const baseUrl = getBaseURL(runtime);
    const isBrowser2 = typeof globalThis !== "undefined" && globalThis.document;
    const response = await fetch(`${baseUrl}/chat/completions`, {
      method: "POST",
      headers: {
        ...isBrowser2 ? {} : { Authorization: `Bearer ${apiKey}` },
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        model: modelName,
        messages: [
          {
            role: "user",
            content: params.prompt
          }
        ],
        modalities: ["image", "text"]
      }),
      signal: AbortSignal.timeout ? AbortSignal.timeout(60000) : undefined
    });
    if (!response.ok) {
      const errorText = await response.text().catch(() => "");
      throw new Error(`HTTP ${response.status} ${response.statusText} ${errorText}`);
    }
    const result = await response.json();
    const images = [];
    const savedPaths = [];
    if (result.choices?.[0]?.message?.images) {
      for (const [index, image] of result.choices[0].message.images.entries()) {
        const base64Url = image.image_url.url;
        const filepath = await saveBase64Image(base64Url, runtime.agentId, index);
        if (filepath) {
          import_core7.logger.log(`[OpenRouter] Returning image with filepath: ${filepath}`);
          images.push({
            url: filepath
          });
          savedPaths.push(filepath);
        } else if (!base64Url.startsWith("data:")) {
          images.push({ url: base64Url });
        } else {
          import_core7.logger.warn(`[OpenRouter] Failed to save image ${index + 1}, skipping`);
        }
      }
    }
    if (savedPaths.length > 0 && shouldAutoCleanupImages(runtime)) {
      setTimeout(() => {
        savedPaths.forEach((path) => {
          deleteImage(path);
        });
      }, 30000);
    }
    if (images.length === 0) {
      throw new Error("No images generated in response");
    }
    import_core7.logger.log(`[OpenRouter] Generated ${images.length} image(s)`);
    return images;
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    import_core7.logger.error(`[OpenRouter] Error generating image: ${message}`);
    return [];
  }
}

// src/models/embedding.ts
var import_core8 = require("@elizaos/core");
async function handleTextEmbedding(runtime, params) {
  const embeddingModelName = getEmbeddingModel(runtime);
  const embeddingDimension = Number.parseInt(getSetting(runtime, "OPENROUTER_EMBEDDING_DIMENSIONS") ?? getSetting(runtime, "EMBEDDING_DIMENSIONS") ?? "1536", 10);
  if (!Object.values(import_core8.VECTOR_DIMS).includes(embeddingDimension)) {
    const errorMsg = `Invalid embedding dimension: ${embeddingDimension}. Must be one of: ${Object.values(import_core8.VECTOR_DIMS).join(", ")}`;
    import_core8.logger.error(errorMsg);
    throw new Error(errorMsg);
  }
  if (params === null) {
    import_core8.logger.debug("Creating test embedding for initialization");
    const testVector = Array(embeddingDimension).fill(0);
    testVector[0] = 0.1;
    return testVector;
  }
  let text;
  if (typeof params === "string") {
    text = params;
  } else if (typeof params === "object" && params.text) {
    text = params.text;
  } else {
    const errorMsg = "Invalid input format for embedding";
    import_core8.logger.warn(errorMsg);
    const fallbackVector = Array(embeddingDimension).fill(0);
    fallbackVector[0] = 0.2;
    return fallbackVector;
  }
  if (!text.trim()) {
    const errorMsg = "Empty text for embedding";
    import_core8.logger.warn(errorMsg);
    const fallbackVector = Array(embeddingDimension).fill(0);
    fallbackVector[0] = 0.3;
    return fallbackVector;
  }
  const apiKey = getApiKey(runtime);
  if (!apiKey) {
    const errorMsg = "OPENROUTER_API_KEY is not set";
    import_core8.logger.error(errorMsg);
    throw new Error(errorMsg);
  }
  const baseURL = getBaseURL(runtime);
  try {
    const response = await fetch(`${baseURL}/embeddings`, {
      method: "POST",
      headers: {
        Authorization: `Bearer ${apiKey}`,
        "Content-Type": "application/json",
        "HTTP-Referer": getSetting(runtime, "OPENROUTER_HTTP_REFERER") || "",
        "X-Title": getSetting(runtime, "OPENROUTER_X_TITLE") || "ElizaOS"
      },
      body: JSON.stringify({
        model: embeddingModelName,
        input: text
      })
    });
    if (!response.ok) {
      import_core8.logger.error(`OpenRouter API error: ${response.status} - ${response.statusText}`);
      throw new Error(`OpenRouter API error: ${response.status} - ${response.statusText}`);
    }
    const data = await response.json();
    if (!data?.data?.[0]?.embedding) {
      import_core8.logger.error("API returned invalid structure");
      throw new Error("API returned invalid structure");
    }
    const embedding = data.data[0].embedding;
    if (!Array.isArray(embedding) || embedding.length !== embeddingDimension) {
      const errorMsg = `Embedding length ${embedding?.length ?? 0} does not match configured dimension ${embeddingDimension}`;
      import_core8.logger.error(errorMsg);
      const fallbackVector = Array(embeddingDimension).fill(0);
      fallbackVector[0] = 0.4;
      return fallbackVector;
    }
    if (data.usage) {
      const usage = {
        inputTokens: data.usage.prompt_tokens,
        outputTokens: 0,
        totalTokens: data.usage.total_tokens
      };
      emitModelUsageEvent(runtime, import_core8.ModelType.TEXT_EMBEDDING, text, usage);
    }
    import_core8.logger.log(`Got valid embedding with length ${embedding.length}`);
    return embedding;
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    import_core8.logger.error(`Error generating embedding: ${message}`);
    throw error instanceof Error ? error : new Error(message);
  }
}

// src/index.ts
var openrouterPlugin = {
  name: "openrouter",
  description: "OpenRouter plugin",
  config: {
    OPENROUTER_API_KEY: process.env.OPENROUTER_API_KEY,
    OPENROUTER_BASE_URL: process.env.OPENROUTER_BASE_URL,
    OPENROUTER_SMALL_MODEL: process.env.OPENROUTER_SMALL_MODEL,
    OPENROUTER_LARGE_MODEL: process.env.OPENROUTER_LARGE_MODEL,
    OPENROUTER_IMAGE_MODEL: process.env.OPENROUTER_IMAGE_MODEL,
    OPENROUTER_IMAGE_GENERATION_MODEL: process.env.OPENROUTER_IMAGE_GENERATION_MODEL,
    OPENROUTER_EMBEDDING_MODEL: process.env.OPENROUTER_EMBEDDING_MODEL,
    OPENROUTER_EMBEDDING_DIMENSIONS: process.env.OPENROUTER_EMBEDDING_DIMENSIONS,
    OPENROUTER_AUTO_CLEANUP_IMAGES: process.env.OPENROUTER_AUTO_CLEANUP_IMAGES,
    SMALL_MODEL: process.env.SMALL_MODEL,
    LARGE_MODEL: process.env.LARGE_MODEL,
    IMAGE_MODEL: process.env.IMAGE_MODEL,
    IMAGE_GENERATION_MODEL: process.env.IMAGE_GENERATION_MODEL,
    EMBEDDING_MODEL: process.env.EMBEDDING_MODEL,
    EMBEDDING_DIMENSIONS: process.env.EMBEDDING_DIMENSIONS
  },
  async init(config, runtime) {
    initializeOpenRouter(config, runtime);
  },
  models: {
    [import_core9.ModelType.TEXT_SMALL]: async (runtime, params) => {
      return handleTextSmall(runtime, params);
    },
    [import_core9.ModelType.TEXT_LARGE]: async (runtime, params) => {
      return handleTextLarge(runtime, params);
    },
    [import_core9.ModelType.OBJECT_SMALL]: async (runtime, params) => {
      return handleObjectSmall(runtime, params);
    },
    [import_core9.ModelType.OBJECT_LARGE]: async (runtime, params) => {
      return handleObjectLarge(runtime, params);
    },
    [import_core9.ModelType.IMAGE_DESCRIPTION]: async (runtime, params) => {
      return handleImageDescription(runtime, params);
    },
    [import_core9.ModelType.IMAGE]: async (runtime, params) => {
      return handleImageGeneration(runtime, params);
    },
    [import_core9.ModelType.TEXT_EMBEDDING]: async (runtime, params) => {
      return handleTextEmbedding(runtime, params);
    }
  }
};
var src_default = openrouterPlugin;

//# debugId=58E9583DC191044464756E2164756E21
