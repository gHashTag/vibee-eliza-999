// src/index.ts
import { createOpenAI } from "@ai-sdk/openai";
import {
  ModelType,
  logger
} from "@elizaos/core";
import { generateObject, generateText } from "ai";
import { encodingForModel } from "js-tiktoken";
function getBaseURL(runtime) {
  return runtime.getSetting("REDPILL_BASE_URL") || "https://api.redpill.ai/v1";
}
async function tokenizeText(model, prompt) {
  const modelName = model === ModelType.TEXT_SMALL ? process.env.REDPILL_SMALL_MODEL ?? process.env.SMALL_MODEL ?? "gpt-4o-mini" : process.env.REDPILL_LARGE_MODEL ?? process.env.LARGE_MODEL ?? "gpt-4o";
  const encoding = encodingForModel(modelName);
  const tokens = encoding.encode(prompt);
  return tokens;
}
async function detokenizeText(model, tokens) {
  const modelName = model === ModelType.TEXT_SMALL ? process.env.REDPILL_SMALL_MODEL ?? process.env.SMALL_MODEL ?? "gpt-4o-mini" : process.env.REDPILL_LARGE_MODEL ?? process.env.LARGE_MODEL ?? "gpt-4o";
  const encoding = encodingForModel(modelName);
  return encoding.decode(tokens);
}
var redpillPlugin = {
  name: "redpill",
  description: "RedPill plugin",
  config: {
    REDPILL_API_KEY: process.env.REDPILL_API_KEY,
    REDPILL_BASE_URL: process.env.REDPILL_BASE_URL,
    REDPILL_SMALL_MODEL: process.env.REDPILL_SMALL_MODEL,
    REDPILL_LARGE_MODEL: process.env.REDPILL_LARGE_MODEL,
    SMALL_MODEL: process.env.SMALL_MODEL,
    LARGE_MODEL: process.env.LARGE_MODEL
  },
  async init(_, runtime) {
    try {
      if (!process.env.REDPILL_API_KEY) {
        logger.warn(
          "REDPILL_API_KEY is not set in environment - RedPill functionality will be limited"
        );
        return;
      }
      try {
        const response = await fetch(`${getBaseURL(runtime)}/models`, {
          headers: { Authorization: `Bearer ${runtime.getSetting("REDPILL_API_KEY")}` }
        });
        if (!response.ok) {
          logger.warn(`RedPill API key validation failed: ${response.statusText}`);
          logger.warn("RedPill functionality will be limited until a valid API key is provided");
        } else {
          logger.success("RedPill API key validated successfully");
        }
      } catch (fetchError) {
        logger.warn(`Error validating RedPill API key: ${fetchError}`);
        logger.warn("RedPill functionality will be limited until a valid API key is provided");
      }
    } catch (error) {
      logger.warn(
        `RedPill plugin configuration issue: ${error.errors.map((e) => e.message).join(", ")} - You need to configure the REDPILL_API_KEY in your environment variables`
      );
    }
  },
  models: {
    [ModelType.TEXT_EMBEDDING]: async (_runtime, params) => {
      const model = "text-embedding-3-small";
      logger.log(`[Redpill] Using TEXT_EMBEDDING model: ${model}`);
      if (params === null) {
        logger.debug("Creating test embedding for initialization");
        const testVector = Array(1536).fill(0);
        testVector[0] = 0.1;
        return testVector;
      }
      let text;
      if (typeof params === "string") {
        text = params;
      } else if (typeof params === "object" && params.text) {
        text = params.text;
      } else {
        logger.warn("Invalid input format for embedding");
        const fallbackVector = Array(1536).fill(0);
        fallbackVector[0] = 0.2;
        return fallbackVector;
      }
      if (!text.trim()) {
        logger.warn("Empty text for embedding");
        const emptyVector = Array(1536).fill(0);
        emptyVector[0] = 0.3;
        return emptyVector;
      }
      try {
        const baseURL = getBaseURL(_runtime);
        const response = await fetch(`${baseURL}/embeddings`, {
          method: "POST",
          headers: {
            Authorization: `Bearer ${process.env.REDPILL_API_KEY}`,
            "Content-Type": "application/json"
          },
          body: JSON.stringify({
            model: "text-embedding-3-small",
            input: text
          })
        });
        if (!response.ok) {
          logger.error(`RedPill API error: ${response.status} - ${response.statusText}`);
          const errorVector = Array(1536).fill(0);
          errorVector[0] = 0.4;
          return errorVector;
        }
        const data = await response.json();
        if (!data?.data?.[0]?.embedding) {
          logger.error("API returned invalid structure");
          const errorVector = Array(1536).fill(0);
          errorVector[0] = 0.5;
          return errorVector;
        }
        const embedding = data.data[0].embedding;
        logger.log(`Got valid embedding with length ${embedding.length}`);
        return embedding;
      } catch (error) {
        logger.error("Error generating embedding:", error);
        const errorVector = Array(1536).fill(0);
        errorVector[0] = 0.6;
        return errorVector;
      }
    },
    [ModelType.TEXT_TOKENIZER_ENCODE]: async (_runtime, { prompt, modelType = ModelType.TEXT_LARGE }) => {
      const modelName = modelType === ModelType.TEXT_SMALL ? process.env.REDPILL_SMALL_MODEL ?? process.env.SMALL_MODEL ?? "gpt-4o-mini" : process.env.REDPILL_LARGE_MODEL ?? process.env.LARGE_MODEL ?? "gpt-4o";
      logger.log(`[Redpill] Using TEXT_TOKENIZER_ENCODE model: ${modelName}`);
      return await tokenizeText(modelType ?? ModelType.TEXT_LARGE, prompt);
    },
    [ModelType.TEXT_TOKENIZER_DECODE]: async (_runtime, { tokens, modelType = ModelType.TEXT_LARGE }) => {
      const modelName = modelType === ModelType.TEXT_SMALL ? process.env.REDPILL_SMALL_MODEL ?? process.env.SMALL_MODEL ?? "gpt-4o-mini" : process.env.REDPILL_LARGE_MODEL ?? process.env.LARGE_MODEL ?? "gpt-4o";
      logger.log(`[Redpill] Using TEXT_TOKENIZER_DECODE model: ${modelName}`);
      return await detokenizeText(modelType ?? ModelType.TEXT_LARGE, tokens);
    },
    [ModelType.TEXT_SMALL]: async (runtime, { prompt, stopSequences = [] }) => {
      const temperature = 0.7;
      const frequency_penalty = 0.7;
      const presence_penalty = 0.7;
      const max_response_length = 8192;
      const baseURL = getBaseURL(runtime);
      const redpill = createOpenAI({
        apiKey: runtime.getSetting("REDPILL_API_KEY"),
        baseURL
      });
      const model = runtime.getSetting("REDPILL_SMALL_MODEL") ?? runtime.getSetting("SMALL_MODEL") ?? "gpt-4o-mini";
      logger.log(`[Redpill] Using TEXT_SMALL model: ${model}`);
      logger.log("generating text");
      logger.log(prompt);
      const { text: redpillResponse } = await generateText({
        model: redpill.languageModel(model),
        prompt,
        system: runtime.character.system ?? void 0,
        temperature,
        maxTokens: max_response_length,
        frequencyPenalty: frequency_penalty,
        presencePenalty: presence_penalty,
        stopSequences
      });
      return redpillResponse;
    },
    [ModelType.TEXT_LARGE]: async (runtime, {
      prompt,
      stopSequences = [],
      maxTokens = 8192,
      temperature = 0.7,
      frequencyPenalty = 0.7,
      presencePenalty = 0.7
    }) => {
      const baseURL = getBaseURL(runtime);
      const redpill = createOpenAI({
        apiKey: runtime.getSetting("REDPILL_API_KEY"),
        baseURL
      });
      const model = runtime.getSetting("REDPILL_LARGE_MODEL") ?? runtime.getSetting("LARGE_MODEL") ?? "gpt-4o";
      logger.log(`[Redpill] Using TEXT_LARGE model: ${model}`);
      const { text: redpillResponse } = await generateText({
        model: redpill.languageModel(model),
        prompt,
        system: runtime.character.system ?? void 0,
        temperature,
        maxTokens,
        frequencyPenalty,
        presencePenalty,
        stopSequences
      });
      return redpillResponse;
    },
    [ModelType.IMAGE_DESCRIPTION]: async (runtime, params) => {
      let imageUrl;
      let prompt;
      if (typeof params === "string") {
        imageUrl = params;
        prompt = void 0;
      } else {
        imageUrl = params.imageUrl;
        prompt = params.prompt;
      }
      const model = "gpt-4-vision-preview";
      logger.log(`[Redpill] Using IMAGE_DESCRIPTION model: ${model}`);
      try {
        const baseURL = getBaseURL(runtime);
        const apiKey = process.env.REDPILL_API_KEY;
        if (!apiKey) {
          logger.error("RedPill API key not set");
          return {
            title: "Failed to analyze image",
            description: "API key not configured"
          };
        }
        const response = await fetch(`${baseURL}/chat/completions`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${apiKey}`
          },
          body: JSON.stringify({
            model: "gpt-4-vision-preview",
            messages: [
              {
                role: "user",
                content: [
                  {
                    type: "text",
                    text: prompt || "Please analyze this image and provide a title and detailed description."
                  },
                  {
                    type: "image_url",
                    image_url: { url: imageUrl }
                  }
                ]
              }
            ],
            max_tokens: 300
          })
        });
        if (!response.ok) {
          throw new Error(`RedPill API error: ${response.status}`);
        }
        const result = await response.json();
        const content = result.choices?.[0]?.message?.content;
        if (!content) {
          return {
            title: "Failed to analyze image",
            description: "No response from API"
          };
        }
        const titleMatch = content.match(/title[:\s]+(.+?)(?:\n|$)/i);
        const title = titleMatch?.[1] || "Image Analysis";
        const description = content.replace(/title[:\s]+(.+?)(?:\n|$)/i, "").trim();
        return { title, description };
      } catch (error) {
        logger.error("Error analyzing image:", error);
        return {
          title: "Failed to analyze image",
          description: `Error: ${error instanceof Error ? error.message : String(error)}`
        };
      }
    },
    [ModelType.OBJECT_SMALL]: async (runtime, params) => {
      const baseURL = getBaseURL(runtime);
      const redpill = createOpenAI({
        apiKey: runtime.getSetting("REDPILL_API_KEY"),
        baseURL
      });
      const model = runtime.getSetting("REDPILL_SMALL_MODEL") ?? runtime.getSetting("SMALL_MODEL") ?? "gpt-4o-mini";
      logger.log(`[Redpill] Using OBJECT_SMALL model: ${model}`);
      try {
        if (params.schema) {
          logger.info("Using OBJECT_SMALL without schema validation");
          const { object: object2 } = await generateObject({
            model: redpill.languageModel(model),
            output: "no-schema",
            prompt: params.prompt,
            temperature: params.temperature
          });
          return object2;
        }
        const { object } = await generateObject({
          model: redpill.languageModel(model),
          output: "no-schema",
          prompt: params.prompt,
          temperature: params.temperature
        });
        return object;
      } catch (error) {
        logger.error("Error generating object:", error);
        throw error;
      }
    },
    [ModelType.OBJECT_LARGE]: async (runtime, params) => {
      const baseURL = getBaseURL(runtime);
      const redpill = createOpenAI({
        apiKey: runtime.getSetting("REDPILL_API_KEY"),
        baseURL
      });
      const model = runtime.getSetting("REDPILL_LARGE_MODEL") ?? runtime.getSetting("LARGE_MODEL") ?? "gpt-4o";
      logger.log(`[Redpill] Using OBJECT_LARGE model: ${model}`);
      try {
        if (params.schema) {
          logger.info("Using OBJECT_LARGE without schema validation");
          const { object: object2 } = await generateObject({
            model: redpill.languageModel(model),
            output: "no-schema",
            prompt: params.prompt,
            temperature: params.temperature
          });
          return object2;
        }
        const { object } = await generateObject({
          model: redpill.languageModel(model),
          output: "no-schema",
          prompt: params.prompt,
          temperature: params.temperature
        });
        return object;
      } catch (error) {
        logger.error("Error generating object:", error);
        throw error;
      }
    }
  },
  tests: [
    {
      name: "redpill_plugin_tests",
      tests: [
        {
          name: "redpill_test_url_and_api_key_validation",
          fn: async (runtime) => {
            const baseURL = getBaseURL(runtime);
            const response = await fetch(`${baseURL}/models`, {
              headers: {
                Authorization: `Bearer ${runtime.getSetting("REDPILL_API_KEY")}`
              }
            });
            const data = await response.json();
            logger.log("Models Available:", data?.data.length);
            if (!response.ok) {
              throw new Error(`Failed to validate RedPill API key: ${response.statusText}`);
            }
          }
        },
        {
          name: "redpill_test_text_embedding",
          fn: async (runtime) => {
            try {
              const embedding = await runtime.useModel(ModelType.TEXT_EMBEDDING, {
                text: "Hello, world!"
              });
              logger.log("embedding", embedding);
            } catch (error) {
              logger.error("Error in test_text_embedding:", error);
              throw error;
            }
          }
        },
        {
          name: "redpill_test_text_large",
          fn: async (runtime) => {
            try {
              const text = await runtime.useModel(ModelType.TEXT_LARGE, {
                prompt: "What is the nature of reality in 10 words?"
              });
              if (text.length === 0) {
                throw new Error("Failed to generate text");
              }
              logger.log("generated with test_text_large:", text);
            } catch (error) {
              logger.error("Error in test_text_large:", error);
              throw error;
            }
          }
        },
        {
          name: "redpill_test_text_small",
          fn: async (runtime) => {
            try {
              const text = await runtime.useModel(ModelType.TEXT_SMALL, {
                prompt: "What is the nature of reality in 10 words?"
              });
              if (text.length === 0) {
                throw new Error("Failed to generate text");
              }
              logger.log("generated with test_text_small:", text);
            } catch (error) {
              logger.error("Error in test_text_small:", error);
              throw error;
            }
          }
        },
        {
          name: "image-description",
          fn: async (runtime) => {
            try {
              logger.log("redpill_test_image_description");
              try {
                const result = await runtime.useModel(
                  ModelType.IMAGE_DESCRIPTION,
                  "https://upload.wikimedia.org/wikipedia/commons/thumb/1/1c/Vitalik_Buterin_TechCrunch_London_2015_%28cropped%29.jpg/537px-Vitalik_Buterin_TechCrunch_London_2015_%28cropped%29.jpg"
                );
                if (result && typeof result === "object" && "title" in result && "description" in result) {
                  logger.log("Image description:", result);
                } else {
                  logger.error("Invalid image description result format:", result);
                }
              } catch (e) {
                logger.error("Error in image description test:", e);
              }
            } catch (e) {
              logger.error("Error in redpill_test_image_description:", e);
            }
          }
        },
        {
          name: "redpill_test_text_tokenizer_encode",
          fn: async (runtime) => {
            const prompt = "Hello tokenizer encode!";
            const tokens = await runtime.useModel(ModelType.TEXT_TOKENIZER_ENCODE, { prompt });
            if (!Array.isArray(tokens) || tokens.length === 0) {
              throw new Error("Failed to tokenize text: expected non-empty array of tokens");
            }
            logger.log("Tokenized output:", tokens);
          }
        },
        {
          name: "redpill_test_text_tokenizer_decode",
          fn: async (runtime) => {
            const prompt = "Hello tokenizer decode!";
            const tokens = await runtime.useModel(ModelType.TEXT_TOKENIZER_ENCODE, { prompt });
            const decodedText = await runtime.useModel(ModelType.TEXT_TOKENIZER_DECODE, { tokens });
            if (decodedText !== prompt) {
              throw new Error(
                `Decoded text does not match original. Expected "${prompt}", got "${decodedText}"`
              );
            }
            logger.log("Decoded text:", decodedText);
          }
        }
      ]
    }
  ]
};
var index_default = redpillPlugin;
export {
  index_default as default,
  redpillPlugin
};
//# sourceMappingURL=index.js.map