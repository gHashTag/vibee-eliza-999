"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Vector = void 0;
const TLObject_js_1 = require("../TLObject.js");
const BytesIO_js_1 = require("../BytesIO.js");
const Int_js_1 = require("./Int.js");
const platform_node_js_1 = require("../../../platform.node.js");
class Vector extends TLObject_js_1.TLObject {
    static ID = 0x1cb5c415;
    static write(value, tl) {
        const bytes = new BytesIO_js_1.BytesIO();
        bytes.write(Int_js_1.Int.write(Vector.ID, false));
        bytes.write(Int_js_1.Int.write(value.length));
        for (const i of value) {
            if (tl) {
                bytes.write(tl.write(i));
            }
            else {
                bytes.write(i.write());
            }
        }
        return platform_node_js_1.Buffer.from(bytes.buffer);
    }
    static async readBare(data, size) {
        if (size === 4) {
            return await Int_js_1.Int.read(data);
        }
        if (size === 8) {
            return await Int_js_1.Long.read(data);
        }
        return await TLObject_js_1.TLObject.read(data);
    }
    static async read(data, tl) {
        const results = [];
        const count = await Int_js_1.Int.read(data);
        const left = platform_node_js_1.Buffer.byteLength(data.read());
        const size = count ? left / count : 0;
        data.seek(-left, 1);
        for (let i = 0; i < count; i++) {
            if (tl) {
                results.push(await tl.read(data));
            }
            else {
                results.push(await Vector.readBare(data, size));
            }
        }
        return results;
    }
}
exports.Vector = Vector;
