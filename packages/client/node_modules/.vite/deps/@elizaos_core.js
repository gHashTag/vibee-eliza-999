import {
  __name,
  __privateAdd,
  __privateGet,
  __privateSet,
  __publicField,
  __require
} from "./chunk-JFQZGO67.js";

// ../core/dist/browser/index.browser.js
var rM = Object.create;
var { getPrototypeOf: oM, defineProperty: qP, getOwnPropertyNames: dJ, getOwnPropertyDescriptor: nM } = Object;
var lJ = Object.prototype.hasOwnProperty;
var K8 = /* @__PURE__ */ __name(($, q, K) => {
  K = $ != null ? rM(oM($)) : {};
  let P = q || !$ || !$.__esModule ? qP(K, "default", { value: $, enumerable: true }) : K;
  for (let _ of dJ($)) if (!lJ.call(P, _)) qP(P, _, { get: /* @__PURE__ */ __name(() => $[_], "get"), enumerable: true });
  return P;
}, "K8");
var mJ = /* @__PURE__ */ new WeakMap();
var J6 = /* @__PURE__ */ __name(($) => {
  var q = mJ.get($), K;
  if (q) return q;
  if (q = qP({}, "__esModule", { value: true }), $ && typeof $ === "object" || typeof $ === "function") dJ($).map((P) => !lJ.call(q, P) && qP(q, P, { get: /* @__PURE__ */ __name(() => $[P], "get"), enumerable: !(K = nM($, P)) || K.enumerable }));
  return mJ.set($, q), q;
}, "J6");
var x$ = /* @__PURE__ */ __name(($, q) => () => (q || $((q = { exports: {} }).exports, q), q.exports), "x$");
var rq = /* @__PURE__ */ __name(($, q) => {
  for (var K in q) qP($, K, { get: q[K], enumerable: true, configurable: true, set: /* @__PURE__ */ __name((P) => q[K] = () => P, "set") });
}, "rq");
var m_ = /* @__PURE__ */ __name(($, q) => () => ($ && (q = $($ = 0)), q), "m_");
var c8 = (($) => typeof __require < "u" ? __require : typeof Proxy < "u" ? new Proxy($, { get: /* @__PURE__ */ __name((q, K) => (typeof __require < "u" ? __require : q)[K], "get") }) : $)(function($) {
  if (typeof __require < "u") return __require.apply(this, arguments);
  throw Error('Dynamic require of "' + $ + '" is not supported');
});
var oJ = x$((OB, rJ) => {
  rJ.exports = function($, q) {
    if (typeof $ !== "string") throw TypeError("Expected a string");
    return q = typeof q > "u" ? "_" : q, $.replace(/([a-z\d])([A-Z])/g, "$1" + q + "$2").replace(/([A-Z]+)([A-Z][a-z\d]+)/g, "$1" + q + "$2").toLowerCase();
  };
});
var aJ = x$((YB, bO) => {
  var sM = /[\p{Lu}]/u, $N = /[\p{Ll}]/u, nJ = /^[\p{Lu}](?![\p{Lu}])/gu, BJ = /([\p{Alpha}\p{N}_]|$)/u, UJ = /[_.\- ]+/, qN = new RegExp("^" + UJ.source), iJ = new RegExp(UJ.source + BJ.source, "gu"), tJ = new RegExp("\\d+" + BJ.source, "gu"), KN = /* @__PURE__ */ __name(($, q, K) => {
    let P = false, _ = false, Y = false;
    for (let O = 0; O < $.length; O++) {
      let z = $[O];
      if (P && sM.test(z)) $ = $.slice(0, O) + "-" + $.slice(O), P = false, Y = _, _ = true, O++;
      else if (_ && Y && $N.test(z)) $ = $.slice(0, O - 1) + "-" + $.slice(O - 1), Y = _, _ = false, P = true;
      else P = q(z) === z && K(z) !== z, Y = _, _ = K(z) === z && q(z) !== z;
    }
    return $;
  }, "KN"), _N = /* @__PURE__ */ __name(($, q) => {
    return nJ.lastIndex = 0, $.replace(nJ, (K) => q(K));
  }, "_N"), PN = /* @__PURE__ */ __name(($, q) => {
    return iJ.lastIndex = 0, tJ.lastIndex = 0, $.replace(iJ, (K, P) => q(P)).replace(tJ, (K) => q(K));
  }, "PN"), FJ = /* @__PURE__ */ __name(($, q) => {
    if (!(typeof $ === "string" || Array.isArray($))) throw TypeError("Expected the input to be `string | string[]`");
    if (q = { pascalCase: false, preserveConsecutiveUppercase: false, ...q }, Array.isArray($)) $ = $.map((Y) => Y.trim()).filter((Y) => Y.length).join("-");
    else $ = $.trim();
    if ($.length === 0) return "";
    let K = q.locale === false ? (Y) => Y.toLowerCase() : (Y) => Y.toLocaleLowerCase(q.locale), P = q.locale === false ? (Y) => Y.toUpperCase() : (Y) => Y.toLocaleUpperCase(q.locale);
    if ($.length === 1) return q.pascalCase ? P($) : K($);
    if ($ !== K($)) $ = KN($, K, P);
    if ($ = $.replace(qN, ""), q.preserveConsecutiveUppercase) $ = _N($, K);
    else $ = K($);
    if (q.pascalCase) $ = P($.charAt(0)) + $.slice(1);
    return PN($, P);
  }, "FJ");
  bO.exports = FJ;
  bO.exports.default = FJ;
});
var gw = x$((tF, Lw) => {
  function H8($, q) {
    if (typeof q === "boolean") q = { forever: q };
    if (this._originalTimeouts = JSON.parse(JSON.stringify($)), this._timeouts = $, this._options = q || {}, this._maxRetryTime = q && q.maxRetryTime || 1 / 0, this._fn = null, this._errors = [], this._attempts = 1, this._operationTimeout = null, this._operationTimeoutCb = null, this._timeout = null, this._operationStart = null, this._timer = null, this._options.forever) this._cachedTimeouts = this._timeouts.slice(0);
  }
  __name(H8, "H8");
  Lw.exports = H8;
  H8.prototype.reset = function() {
    this._attempts = 1, this._timeouts = this._originalTimeouts.slice(0);
  };
  H8.prototype.stop = function() {
    if (this._timeout) clearTimeout(this._timeout);
    if (this._timer) clearTimeout(this._timer);
    this._timeouts = [], this._cachedTimeouts = null;
  };
  H8.prototype.retry = function($) {
    if (this._timeout) clearTimeout(this._timeout);
    if (!$) return false;
    var q = (/* @__PURE__ */ new Date()).getTime();
    if ($ && q - this._operationStart >= this._maxRetryTime) return this._errors.push($), this._errors.unshift(Error("RetryOperation timeout occurred")), false;
    this._errors.push($);
    var K = this._timeouts.shift();
    if (K === void 0) if (this._cachedTimeouts) this._errors.splice(0, this._errors.length - 1), K = this._cachedTimeouts.slice(-1);
    else return false;
    var P = this;
    if (this._timer = setTimeout(function() {
      if (P._attempts++, P._operationTimeoutCb) {
        if (P._timeout = setTimeout(function() {
          P._operationTimeoutCb(P._attempts);
        }, P._operationTimeout), P._options.unref) P._timeout.unref();
      }
      P._fn(P._attempts);
    }, K), this._options.unref) this._timer.unref();
    return true;
  };
  H8.prototype.attempt = function($, q) {
    if (this._fn = $, q) {
      if (q.timeout) this._operationTimeout = q.timeout;
      if (q.cb) this._operationTimeoutCb = q.cb;
    }
    var K = this;
    if (this._operationTimeoutCb) this._timeout = setTimeout(function() {
      K._operationTimeoutCb();
    }, K._operationTimeout);
    this._operationStart = (/* @__PURE__ */ new Date()).getTime(), this._fn(this._attempts);
  };
  H8.prototype.try = function($) {
    console.log("Using RetryOperation.try() is deprecated"), this.attempt($);
  };
  H8.prototype.start = function($) {
    console.log("Using RetryOperation.start() is deprecated"), this.attempt($);
  };
  H8.prototype.start = H8.prototype.try;
  H8.prototype.errors = function() {
    return this._errors;
  };
  H8.prototype.attempts = function() {
    return this._attempts;
  };
  H8.prototype.mainError = function() {
    if (this._errors.length === 0) return null;
    var $ = {}, q = null, K = 0;
    for (var P = 0; P < this._errors.length; P++) {
      var _ = this._errors[P], Y = _.message, O = ($[Y] || 0) + 1;
      if ($[Y] = O, O >= K) q = _, K = O;
    }
    return q;
  };
});
var yw = x$((qC) => {
  var $C = gw();
  qC.operation = function($) {
    var q = qC.timeouts($);
    return new $C(q, { forever: $ && ($.forever || $.retries === 1 / 0), unref: $ && $.unref, maxRetryTime: $ && $.maxRetryTime });
  };
  qC.timeouts = function($) {
    if ($ instanceof Array) return [].concat($);
    var q = { retries: 10, factor: 2, minTimeout: 1e3, maxTimeout: 1 / 0, randomize: false };
    for (var K in $) q[K] = $[K];
    if (q.minTimeout > q.maxTimeout) throw Error("minTimeout is greater than maxTimeout");
    var P = [];
    for (var _ = 0; _ < q.retries; _++) P.push(this.createTimeout(_, q));
    if ($ && $.forever && !P.length) P.push(this.createTimeout(_, q));
    return P.sort(function(Y, O) {
      return Y - O;
    }), P;
  };
  qC.createTimeout = function($, q) {
    var K = q.randomize ? Math.random() + 1 : 1, P = Math.round(K * Math.max(q.minTimeout, 1) * Math.pow(q.factor, $));
    return P = Math.min(P, q.maxTimeout), P;
  };
  qC.wrap = function($, q, K) {
    if (q instanceof Array) K = q, q = null;
    if (!K) {
      K = [];
      for (var P in $) if (typeof $[P] === "function") K.push(P);
    }
    for (var _ = 0; _ < K.length; _++) {
      var Y = K[_], O = $[Y];
      $[Y] = (function(J) {
        var T = qC.operation(q), X = Array.prototype.slice.call(arguments, 1), f = X.pop();
        X.push(function(V) {
          if (T.retry(V)) return;
          if (V) arguments[0] = T.mainError();
          f.apply(this, arguments);
        }), T.attempt(function() {
          J.apply($, X);
        });
      }).bind($, O), $[Y].options = q;
    }
  };
});
var h1 = x$((UF, C1) => {
  var OC = yw(), YC = ["Failed to fetch", "NetworkError when attempting to fetch resource.", "The Internet connection appears to be offline.", "Network request failed"];
  const _O2 = class _O2 extends Error {
    constructor($) {
      super();
      if ($ instanceof Error) this.originalError = $, { message: $ } = $;
      else this.originalError = Error($), this.originalError.stack = this.stack;
      this.name = "AbortError", this.message = $;
    }
  };
  __name(_O2, "O2");
  let O2 = _O2;
  var jC = /* @__PURE__ */ __name(($, q, K) => {
    let P = K.retries - (q - 1);
    return $.attemptNumber = q, $.retriesLeft = P, $;
  }, "jC"), vC = /* @__PURE__ */ __name(($) => YC.includes($), "vC"), uw = /* @__PURE__ */ __name(($, q) => new Promise((K, P) => {
    q = { onFailedAttempt: /* @__PURE__ */ __name(() => {
    }, "onFailedAttempt"), retries: 10, ...q };
    let _ = OC.operation(q);
    _.attempt(async (Y) => {
      try {
        K(await $(Y));
      } catch (O) {
        if (!(O instanceof Error)) {
          P(TypeError(`Non-error was thrown: "${O}". You should only throw errors.`));
          return;
        }
        if (O instanceof O2) _.stop(), P(O.originalError);
        else if (O instanceof TypeError && !vC(O.message)) _.stop(), P(O);
        else {
          jC(O, Y, q);
          try {
            await q.onFailedAttempt(O);
          } catch (z) {
            P(z);
            return;
          }
          if (!_.retry(O)) P(_.mainError());
        }
      }
    });
  }), "uw");
  C1.exports = uw;
  C1.exports.default = uw;
  C1.exports.AbortError = O2;
});
var pw = x$((FF, Y2) => {
  var zC = Object.prototype.hasOwnProperty, Lq = "~";
  function HP() {
  }
  __name(HP, "HP");
  if (Object.create) {
    if (HP.prototype = /* @__PURE__ */ Object.create(null), !new HP().__proto__) Lq = false;
  }
  function WC($, q, K) {
    this.fn = $, this.context = q, this.once = K || false;
  }
  __name(WC, "WC");
  function xw($, q, K, P, _) {
    if (typeof K !== "function") throw TypeError("The listener must be a function");
    var Y = new WC(K, P || $, _), O = Lq ? Lq + q : q;
    if (!$._events[O]) $._events[O] = Y, $._eventsCount++;
    else if (!$._events[O].fn) $._events[O].push(Y);
    else $._events[O] = [$._events[O], Y];
    return $;
  }
  __name(xw, "xw");
  function E1($, q) {
    if (--$._eventsCount === 0) $._events = new HP();
    else delete $._events[q];
  }
  __name(E1, "E1");
  function Cq() {
    this._events = new HP(), this._eventsCount = 0;
  }
  __name(Cq, "Cq");
  Cq.prototype.eventNames = function() {
    var q = [], K, P;
    if (this._eventsCount === 0) return q;
    for (P in K = this._events) if (zC.call(K, P)) q.push(Lq ? P.slice(1) : P);
    if (Object.getOwnPropertySymbols) return q.concat(Object.getOwnPropertySymbols(K));
    return q;
  };
  Cq.prototype.listeners = function(q) {
    var K = Lq ? Lq + q : q, P = this._events[K];
    if (!P) return [];
    if (P.fn) return [P.fn];
    for (var _ = 0, Y = P.length, O = Array(Y); _ < Y; _++) O[_] = P[_].fn;
    return O;
  };
  Cq.prototype.listenerCount = function(q) {
    var K = Lq ? Lq + q : q, P = this._events[K];
    if (!P) return 0;
    if (P.fn) return 1;
    return P.length;
  };
  Cq.prototype.emit = function(q, K, P, _, Y, O) {
    var z = Lq ? Lq + q : q;
    if (!this._events[z]) return false;
    var J = this._events[z], T = arguments.length, X, f;
    if (J.fn) {
      if (J.once) this.removeListener(q, J.fn, void 0, true);
      switch (T) {
        case 1:
          return J.fn.call(J.context), true;
        case 2:
          return J.fn.call(J.context, K), true;
        case 3:
          return J.fn.call(J.context, K, P), true;
        case 4:
          return J.fn.call(J.context, K, P, _), true;
        case 5:
          return J.fn.call(J.context, K, P, _, Y), true;
        case 6:
          return J.fn.call(J.context, K, P, _, Y, O), true;
      }
      for (f = 1, X = Array(T - 1); f < T; f++) X[f - 1] = arguments[f];
      J.fn.apply(J.context, X);
    } else {
      var V = J.length, M;
      for (f = 0; f < V; f++) {
        if (J[f].once) this.removeListener(q, J[f].fn, void 0, true);
        switch (T) {
          case 1:
            J[f].fn.call(J[f].context);
            break;
          case 2:
            J[f].fn.call(J[f].context, K);
            break;
          case 3:
            J[f].fn.call(J[f].context, K, P);
            break;
          case 4:
            J[f].fn.call(J[f].context, K, P, _);
            break;
          default:
            if (!X) for (M = 1, X = Array(T - 1); M < T; M++) X[M - 1] = arguments[M];
            J[f].fn.apply(J[f].context, X);
        }
      }
    }
    return true;
  };
  Cq.prototype.on = function(q, K, P) {
    return xw(this, q, K, P, false);
  };
  Cq.prototype.once = function(q, K, P) {
    return xw(this, q, K, P, true);
  };
  Cq.prototype.removeListener = function(q, K, P, _) {
    var Y = Lq ? Lq + q : q;
    if (!this._events[Y]) return this;
    if (!K) return E1(this, Y), this;
    var O = this._events[Y];
    if (O.fn) {
      if (O.fn === K && (!_ || O.once) && (!P || O.context === P)) E1(this, Y);
    } else {
      for (var z = 0, J = [], T = O.length; z < T; z++) if (O[z].fn !== K || _ && !O[z].once || P && O[z].context !== P) J.push(O[z]);
      if (J.length) this._events[Y] = J.length === 1 ? J[0] : J;
      else E1(this, Y);
    }
    return this;
  };
  Cq.prototype.removeAllListeners = function(q) {
    var K;
    if (q) {
      if (K = Lq ? Lq + q : q, this._events[K]) E1(this, K);
    } else this._events = new HP(), this._eventsCount = 0;
    return this;
  };
  Cq.prototype.off = Cq.prototype.removeListener;
  Cq.prototype.addListener = Cq.prototype.on;
  Cq.prefixed = Lq;
  Cq.EventEmitter = Cq;
  if (typeof Y2 < "u") Y2.exports = Cq;
});
var mw = x$((aF, cw) => {
  cw.exports = ($, q) => {
    return q = q || (() => {
    }), $.then((K) => new Promise((P) => {
      P(q());
    }).then(() => K), (K) => new Promise((P) => {
      P(q());
    }).then(() => {
      throw K;
    }));
  };
});
var lw = x$((QF, R1) => {
  var HC = mw();
  const _j2 = class _j2 extends Error {
    constructor($) {
      super($);
      this.name = "TimeoutError";
    }
  };
  __name(_j2, "j2");
  let j2 = _j2;
  var dw = /* @__PURE__ */ __name(($, q, K) => new Promise((P, _) => {
    if (typeof q !== "number" || q < 0) throw TypeError("Expected `milliseconds` to be a positive number");
    if (q === 1 / 0) {
      P($);
      return;
    }
    let Y = setTimeout(() => {
      if (typeof K === "function") {
        try {
          P(K());
        } catch (J) {
          _(J);
        }
        return;
      }
      let O = typeof K === "string" ? K : `Promise timed out after ${q} milliseconds`, z = K instanceof Error ? K : new j2(O);
      if (typeof $.cancel === "function") $.cancel();
      _(z);
    }, q);
    HC($.then(P, _), () => {
      clearTimeout(Y);
    });
  }), "dw");
  R1.exports = dw;
  R1.exports.default = dw;
  R1.exports.TimeoutError = j2;
});
var ow = x$((rw) => {
  Object.defineProperty(rw, "__esModule", { value: true });
  function JC($, q, K) {
    let P = 0, _ = $.length;
    while (_ > 0) {
      let Y = _ / 2 | 0, O = P + Y;
      if (K($[O], q) <= 0) P = ++O, _ -= Y + 1;
      else _ = Y;
    }
    return P;
  }
  __name(JC, "JC");
  rw.default = JC;
});
var tw = x$((iw) => {
  Object.defineProperty(iw, "__esModule", { value: true });
  var wC = ow();
  const _nw = class _nw {
    constructor() {
      this._queue = [];
    }
    enqueue($, q) {
      q = Object.assign({ priority: 0 }, q);
      let K = { priority: q.priority, run: $ };
      if (this.size && this._queue[this.size - 1].priority >= q.priority) {
        this._queue.push(K);
        return;
      }
      let P = wC.default(this._queue, K, (_, Y) => Y.priority - _.priority);
      this._queue.splice(P, 0, K);
    }
    dequeue() {
      let $ = this._queue.shift();
      return $ === null || $ === void 0 ? void 0 : $.run;
    }
    filter($) {
      return this._queue.filter((q) => q.priority === $.priority).map((q) => q.run);
    }
    get size() {
      return this._queue.length;
    }
  };
  __name(_nw, "nw");
  let nw = _nw;
  iw.default = nw;
});
var D1 = x$((Fw) => {
  Object.defineProperty(Fw, "__esModule", { value: true });
  var ZC = pw(), Bw = lw(), XC = tw(), I1 = /* @__PURE__ */ __name(() => {
  }, "I1"), AC = new Bw.TimeoutError();
  const _Uw = class _Uw extends ZC {
    constructor($) {
      var q, K, P, _;
      super();
      if (this._intervalCount = 0, this._intervalEnd = 0, this._pendingCount = 0, this._resolveEmpty = I1, this._resolveIdle = I1, $ = Object.assign({ carryoverConcurrencyCount: false, intervalCap: 1 / 0, interval: 0, concurrency: 1 / 0, autoStart: true, queueClass: XC.default }, $), !(typeof $.intervalCap === "number" && $.intervalCap >= 1)) throw TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${(K = (q = $.intervalCap) === null || q === void 0 ? void 0 : q.toString()) !== null && K !== void 0 ? K : ""}\` (${typeof $.intervalCap})`);
      if ($.interval === void 0 || !(Number.isFinite($.interval) && $.interval >= 0)) throw TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${(_ = (P = $.interval) === null || P === void 0 ? void 0 : P.toString()) !== null && _ !== void 0 ? _ : ""}\` (${typeof $.interval})`);
      this._carryoverConcurrencyCount = $.carryoverConcurrencyCount, this._isIntervalIgnored = $.intervalCap === 1 / 0 || $.interval === 0, this._intervalCap = $.intervalCap, this._interval = $.interval, this._queue = new $.queueClass(), this._queueClass = $.queueClass, this.concurrency = $.concurrency, this._timeout = $.timeout, this._throwOnTimeout = $.throwOnTimeout === true, this._isPaused = $.autoStart === false;
    }
    get _doesIntervalAllowAnother() {
      return this._isIntervalIgnored || this._intervalCount < this._intervalCap;
    }
    get _doesConcurrentAllowAnother() {
      return this._pendingCount < this._concurrency;
    }
    _next() {
      this._pendingCount--, this._tryToStartAnother(), this.emit("next");
    }
    _resolvePromises() {
      if (this._resolveEmpty(), this._resolveEmpty = I1, this._pendingCount === 0) this._resolveIdle(), this._resolveIdle = I1, this.emit("idle");
    }
    _onResumeInterval() {
      this._onInterval(), this._initializeIntervalIfNeeded(), this._timeoutId = void 0;
    }
    _isIntervalPaused() {
      let $ = Date.now();
      if (this._intervalId === void 0) {
        let q = this._intervalEnd - $;
        if (q < 0) this._intervalCount = this._carryoverConcurrencyCount ? this._pendingCount : 0;
        else {
          if (this._timeoutId === void 0) this._timeoutId = setTimeout(() => {
            this._onResumeInterval();
          }, q);
          return true;
        }
      }
      return false;
    }
    _tryToStartAnother() {
      if (this._queue.size === 0) {
        if (this._intervalId) clearInterval(this._intervalId);
        return this._intervalId = void 0, this._resolvePromises(), false;
      }
      if (!this._isPaused) {
        let $ = !this._isIntervalPaused();
        if (this._doesIntervalAllowAnother && this._doesConcurrentAllowAnother) {
          let q = this._queue.dequeue();
          if (!q) return false;
          if (this.emit("active"), q(), $) this._initializeIntervalIfNeeded();
          return true;
        }
      }
      return false;
    }
    _initializeIntervalIfNeeded() {
      if (this._isIntervalIgnored || this._intervalId !== void 0) return;
      this._intervalId = setInterval(() => {
        this._onInterval();
      }, this._interval), this._intervalEnd = Date.now() + this._interval;
    }
    _onInterval() {
      if (this._intervalCount === 0 && this._pendingCount === 0 && this._intervalId) clearInterval(this._intervalId), this._intervalId = void 0;
      this._intervalCount = this._carryoverConcurrencyCount ? this._pendingCount : 0, this._processQueue();
    }
    _processQueue() {
      while (this._tryToStartAnother()) ;
    }
    get concurrency() {
      return this._concurrency;
    }
    set concurrency($) {
      if (!(typeof $ === "number" && $ >= 1)) throw TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${$}\` (${typeof $})`);
      this._concurrency = $, this._processQueue();
    }
    async add($, q = {}) {
      return new Promise((K, P) => {
        let _ = /* @__PURE__ */ __name(async () => {
          this._pendingCount++, this._intervalCount++;
          try {
            let Y = this._timeout === void 0 && q.timeout === void 0 ? $() : Bw.default(Promise.resolve($()), q.timeout === void 0 ? this._timeout : q.timeout, () => {
              if (q.throwOnTimeout === void 0 ? this._throwOnTimeout : q.throwOnTimeout) P(AC);
              return;
            });
            K(await Y);
          } catch (Y) {
            P(Y);
          }
          this._next();
        }, "_");
        this._queue.enqueue(_, q), this._tryToStartAnother(), this.emit("add");
      });
    }
    async addAll($, q) {
      return Promise.all($.map(async (K) => this.add(K, q)));
    }
    start() {
      if (!this._isPaused) return this;
      return this._isPaused = false, this._processQueue(), this;
    }
    pause() {
      this._isPaused = true;
    }
    clear() {
      this._queue = new this._queueClass();
    }
    async onEmpty() {
      if (this._queue.size === 0) return;
      return new Promise(($) => {
        let q = this._resolveEmpty;
        this._resolveEmpty = () => {
          q(), $();
        };
      });
    }
    async onIdle() {
      if (this._pendingCount === 0 && this._queue.size === 0) return;
      return new Promise(($) => {
        let q = this._resolveIdle;
        this._resolveIdle = () => {
          q(), $();
        };
      });
    }
    get size() {
      return this._queue.size;
    }
    sizeBy($) {
      return this._queue.filter($).length;
    }
    get pending() {
      return this._pendingCount;
    }
    get isPaused() {
      return this._isPaused;
    }
    get timeout() {
      return this._timeout;
    }
    set timeout($) {
      this._timeout = $;
    }
  };
  __name(_Uw, "Uw");
  let Uw = _Uw;
  Fw.default = Uw;
});
var JP = x$((_a52, Qw) => {
  var VC = Number.MAX_SAFE_INTEGER || 9007199254740991, SC = ["major", "premajor", "minor", "preminor", "patch", "prepatch", "prerelease"];
  Qw.exports = { MAX_LENGTH: 256, MAX_SAFE_COMPONENT_LENGTH: 16, MAX_SAFE_BUILD_LENGTH: 250, MAX_SAFE_INTEGER: VC, RELEASE_TYPES: SC, SEMVER_SPEC_VERSION: "2.0.0", FLAG_INCLUDE_PRERELEASE: 1, FLAG_LOOSE: 2 };
});
var TP = x$((Pa, ew) => {
  var MC = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...$) => console.error("SEMVER", ...$) : () => {
  };
  ew.exports = MC;
});
var r_ = x$((d8, sw) => {
  var { MAX_SAFE_COMPONENT_LENGTH: W2, MAX_SAFE_BUILD_LENGTH: NC, MAX_LENGTH: CC } = JP(), hC = TP();
  d8 = sw.exports = {};
  var EC = d8.re = [], RC = d8.safeRe = [], F$ = d8.src = [], IC = d8.safeSrc = [], a$ = d8.t = {}, DC = 0, H2 = "[a-zA-Z0-9-]", LC = [["\\s", 1], ["\\d", CC], [H2, NC]], gC = /* @__PURE__ */ __name(($) => {
    for (let [q, K] of LC) $ = $.split(`${q}*`).join(`${q}{0,${K}}`).split(`${q}+`).join(`${q}{1,${K}}`);
    return $;
  }, "gC"), Y6 = /* @__PURE__ */ __name(($, q, K) => {
    let P = gC(q), _ = DC++;
    hC($, _, q), a$[$] = _, F$[_] = q, IC[_] = P, EC[_] = new RegExp(q, K ? "g" : void 0), RC[_] = new RegExp(P, K ? "g" : void 0);
  }, "Y6");
  Y6("NUMERICIDENTIFIER", "0|[1-9]\\d*");
  Y6("NUMERICIDENTIFIERLOOSE", "\\d+");
  Y6("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${H2}*`);
  Y6("MAINVERSION", `(${F$[a$.NUMERICIDENTIFIER]})\\.(${F$[a$.NUMERICIDENTIFIER]})\\.(${F$[a$.NUMERICIDENTIFIER]})`);
  Y6("MAINVERSIONLOOSE", `(${F$[a$.NUMERICIDENTIFIERLOOSE]})\\.(${F$[a$.NUMERICIDENTIFIERLOOSE]})\\.(${F$[a$.NUMERICIDENTIFIERLOOSE]})`);
  Y6("PRERELEASEIDENTIFIER", `(?:${F$[a$.NONNUMERICIDENTIFIER]}|${F$[a$.NUMERICIDENTIFIER]})`);
  Y6("PRERELEASEIDENTIFIERLOOSE", `(?:${F$[a$.NONNUMERICIDENTIFIER]}|${F$[a$.NUMERICIDENTIFIERLOOSE]})`);
  Y6("PRERELEASE", `(?:-(${F$[a$.PRERELEASEIDENTIFIER]}(?:\\.${F$[a$.PRERELEASEIDENTIFIER]})*))`);
  Y6("PRERELEASELOOSE", `(?:-?(${F$[a$.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${F$[a$.PRERELEASEIDENTIFIERLOOSE]})*))`);
  Y6("BUILDIDENTIFIER", `${H2}+`);
  Y6("BUILD", `(?:\\+(${F$[a$.BUILDIDENTIFIER]}(?:\\.${F$[a$.BUILDIDENTIFIER]})*))`);
  Y6("FULLPLAIN", `v?${F$[a$.MAINVERSION]}${F$[a$.PRERELEASE]}?${F$[a$.BUILD]}?`);
  Y6("FULL", `^${F$[a$.FULLPLAIN]}$`);
  Y6("LOOSEPLAIN", `[v=\\s]*${F$[a$.MAINVERSIONLOOSE]}${F$[a$.PRERELEASELOOSE]}?${F$[a$.BUILD]}?`);
  Y6("LOOSE", `^${F$[a$.LOOSEPLAIN]}$`);
  Y6("GTLT", "((?:<|>)?=?)");
  Y6("XRANGEIDENTIFIERLOOSE", `${F$[a$.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
  Y6("XRANGEIDENTIFIER", `${F$[a$.NUMERICIDENTIFIER]}|x|X|\\*`);
  Y6("XRANGEPLAIN", `[v=\\s]*(${F$[a$.XRANGEIDENTIFIER]})(?:\\.(${F$[a$.XRANGEIDENTIFIER]})(?:\\.(${F$[a$.XRANGEIDENTIFIER]})(?:${F$[a$.PRERELEASE]})?${F$[a$.BUILD]}?)?)?`);
  Y6("XRANGEPLAINLOOSE", `[v=\\s]*(${F$[a$.XRANGEIDENTIFIERLOOSE]})(?:\\.(${F$[a$.XRANGEIDENTIFIERLOOSE]})(?:\\.(${F$[a$.XRANGEIDENTIFIERLOOSE]})(?:${F$[a$.PRERELEASELOOSE]})?${F$[a$.BUILD]}?)?)?`);
  Y6("XRANGE", `^${F$[a$.GTLT]}\\s*${F$[a$.XRANGEPLAIN]}$`);
  Y6("XRANGELOOSE", `^${F$[a$.GTLT]}\\s*${F$[a$.XRANGEPLAINLOOSE]}$`);
  Y6("COERCEPLAIN", `(^|[^\\d])(\\d{1,${W2}})(?:\\.(\\d{1,${W2}}))?(?:\\.(\\d{1,${W2}}))?`);
  Y6("COERCE", `${F$[a$.COERCEPLAIN]}(?:$|[^\\d])`);
  Y6("COERCEFULL", F$[a$.COERCEPLAIN] + `(?:${F$[a$.PRERELEASE]})?(?:${F$[a$.BUILD]})?(?:$|[^\\d])`);
  Y6("COERCERTL", F$[a$.COERCE], true);
  Y6("COERCERTLFULL", F$[a$.COERCEFULL], true);
  Y6("LONETILDE", "(?:~>?)");
  Y6("TILDETRIM", `(\\s*)${F$[a$.LONETILDE]}\\s+`, true);
  d8.tildeTrimReplace = "$1~";
  Y6("TILDE", `^${F$[a$.LONETILDE]}${F$[a$.XRANGEPLAIN]}$`);
  Y6("TILDELOOSE", `^${F$[a$.LONETILDE]}${F$[a$.XRANGEPLAINLOOSE]}$`);
  Y6("LONECARET", "(?:\\^)");
  Y6("CARETTRIM", `(\\s*)${F$[a$.LONECARET]}\\s+`, true);
  d8.caretTrimReplace = "$1^";
  Y6("CARET", `^${F$[a$.LONECARET]}${F$[a$.XRANGEPLAIN]}$`);
  Y6("CARETLOOSE", `^${F$[a$.LONECARET]}${F$[a$.XRANGEPLAINLOOSE]}$`);
  Y6("COMPARATORLOOSE", `^${F$[a$.GTLT]}\\s*(${F$[a$.LOOSEPLAIN]})$|^$`);
  Y6("COMPARATOR", `^${F$[a$.GTLT]}\\s*(${F$[a$.FULLPLAIN]})$|^$`);
  Y6("COMPARATORTRIM", `(\\s*)${F$[a$.GTLT]}\\s*(${F$[a$.LOOSEPLAIN]}|${F$[a$.XRANGEPLAIN]})`, true);
  d8.comparatorTrimReplace = "$1$2$3";
  Y6("HYPHENRANGE", `^\\s*(${F$[a$.XRANGEPLAIN]})\\s+-\\s+(${F$[a$.XRANGEPLAIN]})\\s*$`);
  Y6("HYPHENRANGELOOSE", `^\\s*(${F$[a$.XRANGEPLAINLOOSE]})\\s+-\\s+(${F$[a$.XRANGEPLAINLOOSE]})\\s*$`);
  Y6("STAR", "(<|>)?=?\\s*\\*");
  Y6("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
  Y6("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
});
var b1 = x$((Oa, $f) => {
  var bC = Object.freeze({ loose: true }), yC = Object.freeze({}), uC = /* @__PURE__ */ __name(($) => {
    if (!$) return yC;
    if (typeof $ !== "object") return bC;
    return $;
  }, "uC");
  $f.exports = uC;
});
var J2 = x$((Ya, _f) => {
  var qf = /^[0-9]+$/, Kf = /* @__PURE__ */ __name(($, q) => {
    if (typeof $ === "number" && typeof q === "number") return $ === q ? 0 : $ < q ? -1 : 1;
    let K = qf.test($), P = qf.test(q);
    if (K && P) $ = +$, q = +q;
    return $ === q ? 0 : K && !P ? -1 : P && !K ? 1 : $ < q ? -1 : 1;
  }, "Kf"), xC = /* @__PURE__ */ __name(($, q) => Kf(q, $), "xC");
  _f.exports = { compareIdentifiers: Kf, rcompareIdentifiers: xC };
});
var hq = x$((ja, Of) => {
  var y1 = TP(), { MAX_LENGTH: Pf, MAX_SAFE_INTEGER: u1 } = JP(), { safeRe: x1, t: p1 } = r_(), pC = b1(), { compareIdentifiers: T2 } = J2();
  const _h8 = class _h8 {
    constructor($, q) {
      if (q = pC(q), $ instanceof _h8) if ($.loose === !!q.loose && $.includePrerelease === !!q.includePrerelease) return $;
      else $ = $.version;
      else if (typeof $ !== "string") throw TypeError(`Invalid version. Must be a string. Got type "${typeof $}".`);
      if ($.length > Pf) throw TypeError(`version is longer than ${Pf} characters`);
      y1("SemVer", $, q), this.options = q, this.loose = !!q.loose, this.includePrerelease = !!q.includePrerelease;
      let K = $.trim().match(q.loose ? x1[p1.LOOSE] : x1[p1.FULL]);
      if (!K) throw TypeError(`Invalid Version: ${$}`);
      if (this.raw = $, this.major = +K[1], this.minor = +K[2], this.patch = +K[3], this.major > u1 || this.major < 0) throw TypeError("Invalid major version");
      if (this.minor > u1 || this.minor < 0) throw TypeError("Invalid minor version");
      if (this.patch > u1 || this.patch < 0) throw TypeError("Invalid patch version");
      if (!K[4]) this.prerelease = [];
      else this.prerelease = K[4].split(".").map((P) => {
        if (/^[0-9]+$/.test(P)) {
          let _ = +P;
          if (_ >= 0 && _ < u1) return _;
        }
        return P;
      });
      this.build = K[5] ? K[5].split(".") : [], this.format();
    }
    format() {
      if (this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length) this.version += `-${this.prerelease.join(".")}`;
      return this.version;
    }
    toString() {
      return this.version;
    }
    compare($) {
      if (y1("SemVer.compare", this.version, this.options, $), !($ instanceof _h8)) {
        if (typeof $ === "string" && $ === this.version) return 0;
        $ = new _h8($, this.options);
      }
      if ($.version === this.version) return 0;
      return this.compareMain($) || this.comparePre($);
    }
    compareMain($) {
      if (!($ instanceof _h8)) $ = new _h8($, this.options);
      if (this.major < $.major) return -1;
      if (this.major > $.major) return 1;
      if (this.minor < $.minor) return -1;
      if (this.minor > $.minor) return 1;
      if (this.patch < $.patch) return -1;
      if (this.patch > $.patch) return 1;
      return 0;
    }
    comparePre($) {
      if (!($ instanceof _h8)) $ = new _h8($, this.options);
      if (this.prerelease.length && !$.prerelease.length) return -1;
      else if (!this.prerelease.length && $.prerelease.length) return 1;
      else if (!this.prerelease.length && !$.prerelease.length) return 0;
      let q = 0;
      do {
        let K = this.prerelease[q], P = $.prerelease[q];
        if (y1("prerelease compare", q, K, P), K === void 0 && P === void 0) return 0;
        else if (P === void 0) return 1;
        else if (K === void 0) return -1;
        else if (K === P) continue;
        else return T2(K, P);
      } while (++q);
    }
    compareBuild($) {
      if (!($ instanceof _h8)) $ = new _h8($, this.options);
      let q = 0;
      do {
        let K = this.build[q], P = $.build[q];
        if (y1("build compare", q, K, P), K === void 0 && P === void 0) return 0;
        else if (P === void 0) return 1;
        else if (K === void 0) return -1;
        else if (K === P) continue;
        else return T2(K, P);
      } while (++q);
    }
    inc($, q, K) {
      if ($.startsWith("pre")) {
        if (!q && K === false) throw Error("invalid increment argument: identifier is empty");
        if (q) {
          let P = `-${q}`.match(this.options.loose ? x1[p1.PRERELEASELOOSE] : x1[p1.PRERELEASE]);
          if (!P || P[1] !== q) throw Error(`invalid identifier: ${q}`);
        }
      }
      switch ($) {
        case "premajor":
          this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", q, K);
          break;
        case "preminor":
          this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", q, K);
          break;
        case "prepatch":
          this.prerelease.length = 0, this.inc("patch", q, K), this.inc("pre", q, K);
          break;
        case "prerelease":
          if (this.prerelease.length === 0) this.inc("patch", q, K);
          this.inc("pre", q, K);
          break;
        case "release":
          if (this.prerelease.length === 0) throw Error(`version ${this.raw} is not a prerelease`);
          this.prerelease.length = 0;
          break;
        case "major":
          if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) this.major++;
          this.minor = 0, this.patch = 0, this.prerelease = [];
          break;
        case "minor":
          if (this.patch !== 0 || this.prerelease.length === 0) this.minor++;
          this.patch = 0, this.prerelease = [];
          break;
        case "patch":
          if (this.prerelease.length === 0) this.patch++;
          this.prerelease = [];
          break;
        case "pre": {
          let P = Number(K) ? 1 : 0;
          if (this.prerelease.length === 0) this.prerelease = [P];
          else {
            let _ = this.prerelease.length;
            while (--_ >= 0) if (typeof this.prerelease[_] === "number") this.prerelease[_]++, _ = -2;
            if (_ === -1) {
              if (q === this.prerelease.join(".") && K === false) throw Error("invalid increment argument: identifier already exists");
              this.prerelease.push(P);
            }
          }
          if (q) {
            let _ = [q, P];
            if (K === false) _ = [q];
            if (T2(this.prerelease[0], q) === 0) {
              if (isNaN(this.prerelease[1])) this.prerelease = _;
            } else this.prerelease = _;
          }
          break;
        }
        default:
          throw Error(`invalid increment argument: ${$}`);
      }
      if (this.raw = this.format(), this.build.length) this.raw += `+${this.build.join(".")}`;
      return this;
    }
  };
  __name(_h8, "h8");
  let h8 = _h8;
  Of.exports = h8;
});
var z_ = x$((va, jf) => {
  var Yf = hq(), cC = /* @__PURE__ */ __name(($, q, K = false) => {
    if ($ instanceof Yf) return $;
    try {
      return new Yf($, q);
    } catch (P) {
      if (!K) return null;
      throw P;
    }
  }, "cC");
  jf.exports = cC;
});
var zf = x$((za, vf) => {
  var mC = z_(), dC = /* @__PURE__ */ __name(($, q) => {
    let K = mC($, q);
    return K ? K.version : null;
  }, "dC");
  vf.exports = dC;
});
var Hf = x$((Wa, Wf) => {
  var lC = z_(), rC = /* @__PURE__ */ __name(($, q) => {
    let K = lC($.trim().replace(/^[=v]+/, ""), q);
    return K ? K.version : null;
  }, "rC");
  Wf.exports = rC;
});
var wf = x$((Ha, Tf) => {
  var Jf = hq(), oC = /* @__PURE__ */ __name(($, q, K, P, _) => {
    if (typeof K === "string") _ = P, P = K, K = void 0;
    try {
      return new Jf($ instanceof Jf ? $.version : $, K).inc(q, P, _).version;
    } catch (Y) {
      return null;
    }
  }, "oC");
  Tf.exports = oC;
});
var Xf = x$((Ja, Zf) => {
  var ff = z_(), nC = /* @__PURE__ */ __name(($, q) => {
    let K = ff($, null, true), P = ff(q, null, true), _ = K.compare(P);
    if (_ === 0) return null;
    let Y = _ > 0, O = Y ? K : P, z = Y ? P : K, J = !!O.prerelease.length;
    if (!!z.prerelease.length && !J) {
      if (!z.patch && !z.minor) return "major";
      if (z.compareMain(O) === 0) {
        if (z.minor && !z.patch) return "minor";
        return "patch";
      }
    }
    let X = J ? "pre" : "";
    if (K.major !== P.major) return X + "major";
    if (K.minor !== P.minor) return X + "minor";
    if (K.patch !== P.patch) return X + "patch";
    return "prerelease";
  }, "nC");
  Zf.exports = nC;
});
var kf = x$((Ta, Af) => {
  var iC = hq(), tC = /* @__PURE__ */ __name(($, q) => new iC($, q).major, "tC");
  Af.exports = tC;
});
var Vf = x$((wa, Gf) => {
  var BC = hq(), UC = /* @__PURE__ */ __name(($, q) => new BC($, q).minor, "UC");
  Gf.exports = UC;
});
var Mf = x$((fa, Sf) => {
  var FC = hq(), aC = /* @__PURE__ */ __name(($, q) => new FC($, q).patch, "aC");
  Sf.exports = aC;
});
var Cf = x$((Za, Nf) => {
  var QC = z_(), eC = /* @__PURE__ */ __name(($, q) => {
    let K = QC($, q);
    return K && K.prerelease.length ? K.prerelease : null;
  }, "eC");
  Nf.exports = eC;
});
var J8 = x$((Xa, Ef) => {
  var hf = hq(), sC = /* @__PURE__ */ __name(($, q, K) => new hf($, K).compare(new hf(q, K)), "sC");
  Ef.exports = sC;
});
var If = x$((Aa, Rf) => {
  var $h = J8(), qh = /* @__PURE__ */ __name(($, q, K) => $h(q, $, K), "qh");
  Rf.exports = qh;
});
var Lf = x$((ka, Df) => {
  var Kh = J8(), _h = /* @__PURE__ */ __name(($, q) => Kh($, q, true), "_h");
  Df.exports = _h;
});
var c1 = x$((Ga, bf) => {
  var gf = hq(), Ph = /* @__PURE__ */ __name(($, q, K) => {
    let P = new gf($, K), _ = new gf(q, K);
    return P.compare(_) || P.compareBuild(_);
  }, "Ph");
  bf.exports = Ph;
});
var uf = x$((Va, yf) => {
  var Oh = c1(), Yh = /* @__PURE__ */ __name(($, q) => $.sort((K, P) => Oh(K, P, q)), "Yh");
  yf.exports = Yh;
});
var pf = x$((Sa, xf) => {
  var jh = c1(), vh = /* @__PURE__ */ __name(($, q) => $.sort((K, P) => jh(P, K, q)), "vh");
  xf.exports = vh;
});
var wP = x$((Ma, cf) => {
  var zh = J8(), Wh = /* @__PURE__ */ __name(($, q, K) => zh($, q, K) > 0, "Wh");
  cf.exports = Wh;
});
var m1 = x$((Na, mf) => {
  var Hh = J8(), Jh = /* @__PURE__ */ __name(($, q, K) => Hh($, q, K) < 0, "Jh");
  mf.exports = Jh;
});
var w2 = x$((Ca, df) => {
  var Th = J8(), wh = /* @__PURE__ */ __name(($, q, K) => Th($, q, K) === 0, "wh");
  df.exports = wh;
});
var f2 = x$((ha, lf) => {
  var fh = J8(), Zh = /* @__PURE__ */ __name(($, q, K) => fh($, q, K) !== 0, "Zh");
  lf.exports = Zh;
});
var d1 = x$((Ea, rf) => {
  var Xh = J8(), Ah = /* @__PURE__ */ __name(($, q, K) => Xh($, q, K) >= 0, "Ah");
  rf.exports = Ah;
});
var l1 = x$((Ra, of) => {
  var kh = J8(), Gh = /* @__PURE__ */ __name(($, q, K) => kh($, q, K) <= 0, "Gh");
  of.exports = Gh;
});
var Z2 = x$((Ia, nf) => {
  var Vh = w2(), Sh = f2(), Mh = wP(), Nh = d1(), Ch = m1(), hh = l1(), Eh = /* @__PURE__ */ __name(($, q, K, P) => {
    switch (q) {
      case "===":
        if (typeof $ === "object") $ = $.version;
        if (typeof K === "object") K = K.version;
        return $ === K;
      case "!==":
        if (typeof $ === "object") $ = $.version;
        if (typeof K === "object") K = K.version;
        return $ !== K;
      case "":
      case "=":
      case "==":
        return Vh($, K, P);
      case "!=":
        return Sh($, K, P);
      case ">":
        return Mh($, K, P);
      case ">=":
        return Nh($, K, P);
      case "<":
        return Ch($, K, P);
      case "<=":
        return hh($, K, P);
      default:
        throw TypeError(`Invalid operator: ${q}`);
    }
  }, "Eh");
  nf.exports = Eh;
});
var Bf = x$((Da, tf) => {
  var Rh = hq(), Ih = z_(), { safeRe: r1, t: o1 } = r_(), Dh = /* @__PURE__ */ __name(($, q) => {
    if ($ instanceof Rh) return $;
    if (typeof $ === "number") $ = String($);
    if (typeof $ !== "string") return null;
    q = q || {};
    let K = null;
    if (!q.rtl) K = $.match(q.includePrerelease ? r1[o1.COERCEFULL] : r1[o1.COERCE]);
    else {
      let J = q.includePrerelease ? r1[o1.COERCERTLFULL] : r1[o1.COERCERTL], T;
      while ((T = J.exec($)) && (!K || K.index + K[0].length !== $.length)) {
        if (!K || T.index + T[0].length !== K.index + K[0].length) K = T;
        J.lastIndex = T.index + T[1].length + T[2].length;
      }
      J.lastIndex = -1;
    }
    if (K === null) return null;
    let P = K[2], _ = K[3] || "0", Y = K[4] || "0", O = q.includePrerelease && K[5] ? `-${K[5]}` : "", z = q.includePrerelease && K[6] ? `+${K[6]}` : "";
    return Ih(`${P}.${_}.${Y}${O}${z}`, q);
  }, "Dh");
  tf.exports = Dh;
});
var af = x$((La, Ff) => {
  const _Uf = class _Uf {
    constructor() {
      this.max = 1e3, this.map = /* @__PURE__ */ new Map();
    }
    get($) {
      let q = this.map.get($);
      if (q === void 0) return;
      else return this.map.delete($), this.map.set($, q), q;
    }
    delete($) {
      return this.map.delete($);
    }
    set($, q) {
      if (!this.delete($) && q !== void 0) {
        if (this.map.size >= this.max) {
          let P = this.map.keys().next().value;
          this.delete(P);
        }
        this.map.set($, q);
      }
      return this;
    }
  };
  __name(_Uf, "Uf");
  let Uf = _Uf;
  Ff.exports = Uf;
});
var T8 = x$((ga, $Z) => {
  var Lh = /\s+/g;
  const _fP = class _fP {
    constructor($, q) {
      if (q = bh(q), $ instanceof _fP) if ($.loose === !!q.loose && $.includePrerelease === !!q.includePrerelease) return $;
      else return new _fP($.raw, q);
      if ($ instanceof X2) return this.raw = $.value, this.set = [[$]], this.formatted = void 0, this;
      if (this.options = q, this.loose = !!q.loose, this.includePrerelease = !!q.includePrerelease, this.raw = $.trim().replace(Lh, " "), this.set = this.raw.split("||").map((K) => this.parseRange(K.trim())).filter((K) => K.length), !this.set.length) throw TypeError(`Invalid SemVer Range: ${this.raw}`);
      if (this.set.length > 1) {
        let K = this.set[0];
        if (this.set = this.set.filter((P) => !ef(P[0])), this.set.length === 0) this.set = [K];
        else if (this.set.length > 1) {
          for (let P of this.set) if (P.length === 1 && dh(P[0])) {
            this.set = [P];
            break;
          }
        }
      }
      this.formatted = void 0;
    }
    get range() {
      if (this.formatted === void 0) {
        this.formatted = "";
        for (let $ = 0; $ < this.set.length; $++) {
          if ($ > 0) this.formatted += "||";
          let q = this.set[$];
          for (let K = 0; K < q.length; K++) {
            if (K > 0) this.formatted += " ";
            this.formatted += q[K].toString().trim();
          }
        }
      }
      return this.formatted;
    }
    format() {
      return this.range;
    }
    toString() {
      return this.range;
    }
    parseRange($) {
      let K = ((this.options.includePrerelease && ch) | (this.options.loose && mh)) + ":" + $, P = Qf.get(K);
      if (P) return P;
      let _ = this.options.loose, Y = _ ? gq[Eq.HYPHENRANGELOOSE] : gq[Eq.HYPHENRANGE];
      $ = $.replace(Y, ah(this.options.includePrerelease)), R6("hyphen replace", $), $ = $.replace(gq[Eq.COMPARATORTRIM], uh), R6("comparator trim", $), $ = $.replace(gq[Eq.TILDETRIM], xh), R6("tilde trim", $), $ = $.replace(gq[Eq.CARETTRIM], ph), R6("caret trim", $);
      let O = $.split(" ").map((X) => lh(X, this.options)).join(" ").split(/\s+/).map((X) => Fh(X, this.options));
      if (_) O = O.filter((X) => {
        return R6("loose invalid filter", X, this.options), !!X.match(gq[Eq.COMPARATORLOOSE]);
      });
      R6("range list", O);
      let z = /* @__PURE__ */ new Map(), J = O.map((X) => new X2(X, this.options));
      for (let X of J) {
        if (ef(X)) return [X];
        z.set(X.value, X);
      }
      if (z.size > 1 && z.has("")) z.delete("");
      let T = [...z.values()];
      return Qf.set(K, T), T;
    }
    intersects($, q) {
      if (!($ instanceof _fP)) throw TypeError("a Range is required");
      return this.set.some((K) => {
        return sf(K, q) && $.set.some((P) => {
          return sf(P, q) && K.every((_) => {
            return P.every((Y) => {
              return _.intersects(Y, q);
            });
          });
        });
      });
    }
    test($) {
      if (!$) return false;
      if (typeof $ === "string") try {
        $ = new yh($, this.options);
      } catch (q) {
        return false;
      }
      for (let q = 0; q < this.set.length; q++) if (Qh(this.set[q], $, this.options)) return true;
      return false;
    }
  };
  __name(_fP, "fP");
  let fP = _fP;
  $Z.exports = fP;
  var gh = af(), Qf = new gh(), bh = b1(), X2 = ZP(), R6 = TP(), yh = hq(), { safeRe: gq, t: Eq, comparatorTrimReplace: uh, tildeTrimReplace: xh, caretTrimReplace: ph } = r_(), { FLAG_INCLUDE_PRERELEASE: ch, FLAG_LOOSE: mh } = JP(), ef = /* @__PURE__ */ __name(($) => $.value === "<0.0.0-0", "ef"), dh = /* @__PURE__ */ __name(($) => $.value === "", "dh"), sf = /* @__PURE__ */ __name(($, q) => {
    let K = true, P = $.slice(), _ = P.pop();
    while (K && P.length) K = P.every((Y) => {
      return _.intersects(Y, q);
    }), _ = P.pop();
    return K;
  }, "sf"), lh = /* @__PURE__ */ __name(($, q) => {
    return $ = $.replace(gq[Eq.BUILD], ""), R6("comp", $, q), $ = nh($, q), R6("caret", $), $ = rh($, q), R6("tildes", $), $ = th($, q), R6("xrange", $), $ = Uh($, q), R6("stars", $), $;
  }, "lh"), bq = /* @__PURE__ */ __name(($) => !$ || $.toLowerCase() === "x" || $ === "*", "bq"), rh = /* @__PURE__ */ __name(($, q) => {
    return $.trim().split(/\s+/).map((K) => oh(K, q)).join(" ");
  }, "rh"), oh = /* @__PURE__ */ __name(($, q) => {
    let K = q.loose ? gq[Eq.TILDELOOSE] : gq[Eq.TILDE];
    return $.replace(K, (P, _, Y, O, z) => {
      R6("tilde", $, P, _, Y, O, z);
      let J;
      if (bq(_)) J = "";
      else if (bq(Y)) J = `>=${_}.0.0 <${+_ + 1}.0.0-0`;
      else if (bq(O)) J = `>=${_}.${Y}.0 <${_}.${+Y + 1}.0-0`;
      else if (z) R6("replaceTilde pr", z), J = `>=${_}.${Y}.${O}-${z} <${_}.${+Y + 1}.0-0`;
      else J = `>=${_}.${Y}.${O} <${_}.${+Y + 1}.0-0`;
      return R6("tilde return", J), J;
    });
  }, "oh"), nh = /* @__PURE__ */ __name(($, q) => {
    return $.trim().split(/\s+/).map((K) => ih(K, q)).join(" ");
  }, "nh"), ih = /* @__PURE__ */ __name(($, q) => {
    R6("caret", $, q);
    let K = q.loose ? gq[Eq.CARETLOOSE] : gq[Eq.CARET], P = q.includePrerelease ? "-0" : "";
    return $.replace(K, (_, Y, O, z, J) => {
      R6("caret", $, _, Y, O, z, J);
      let T;
      if (bq(Y)) T = "";
      else if (bq(O)) T = `>=${Y}.0.0${P} <${+Y + 1}.0.0-0`;
      else if (bq(z)) if (Y === "0") T = `>=${Y}.${O}.0${P} <${Y}.${+O + 1}.0-0`;
      else T = `>=${Y}.${O}.0${P} <${+Y + 1}.0.0-0`;
      else if (J) if (R6("replaceCaret pr", J), Y === "0") if (O === "0") T = `>=${Y}.${O}.${z}-${J} <${Y}.${O}.${+z + 1}-0`;
      else T = `>=${Y}.${O}.${z}-${J} <${Y}.${+O + 1}.0-0`;
      else T = `>=${Y}.${O}.${z}-${J} <${+Y + 1}.0.0-0`;
      else if (R6("no pr"), Y === "0") if (O === "0") T = `>=${Y}.${O}.${z}${P} <${Y}.${O}.${+z + 1}-0`;
      else T = `>=${Y}.${O}.${z}${P} <${Y}.${+O + 1}.0-0`;
      else T = `>=${Y}.${O}.${z} <${+Y + 1}.0.0-0`;
      return R6("caret return", T), T;
    });
  }, "ih"), th = /* @__PURE__ */ __name(($, q) => {
    return R6("replaceXRanges", $, q), $.split(/\s+/).map((K) => Bh(K, q)).join(" ");
  }, "th"), Bh = /* @__PURE__ */ __name(($, q) => {
    $ = $.trim();
    let K = q.loose ? gq[Eq.XRANGELOOSE] : gq[Eq.XRANGE];
    return $.replace(K, (P, _, Y, O, z, J) => {
      R6("xRange", $, P, _, Y, O, z, J);
      let T = bq(Y), X = T || bq(O), f = X || bq(z), V = f;
      if (_ === "=" && V) _ = "";
      if (J = q.includePrerelease ? "-0" : "", T) if (_ === ">" || _ === "<") P = "<0.0.0-0";
      else P = "*";
      else if (_ && V) {
        if (X) O = 0;
        if (z = 0, _ === ">") if (_ = ">=", X) Y = +Y + 1, O = 0, z = 0;
        else O = +O + 1, z = 0;
        else if (_ === "<=") if (_ = "<", X) Y = +Y + 1;
        else O = +O + 1;
        if (_ === "<") J = "-0";
        P = `${_ + Y}.${O}.${z}${J}`;
      } else if (X) P = `>=${Y}.0.0${J} <${+Y + 1}.0.0-0`;
      else if (f) P = `>=${Y}.${O}.0${J} <${Y}.${+O + 1}.0-0`;
      return R6("xRange return", P), P;
    });
  }, "Bh"), Uh = /* @__PURE__ */ __name(($, q) => {
    return R6("replaceStars", $, q), $.trim().replace(gq[Eq.STAR], "");
  }, "Uh"), Fh = /* @__PURE__ */ __name(($, q) => {
    return R6("replaceGTE0", $, q), $.trim().replace(gq[q.includePrerelease ? Eq.GTE0PRE : Eq.GTE0], "");
  }, "Fh"), ah = /* @__PURE__ */ __name(($) => (q, K, P, _, Y, O, z, J, T, X, f, V) => {
    if (bq(P)) K = "";
    else if (bq(_)) K = `>=${P}.0.0${$ ? "-0" : ""}`;
    else if (bq(Y)) K = `>=${P}.${_}.0${$ ? "-0" : ""}`;
    else if (O) K = `>=${K}`;
    else K = `>=${K}${$ ? "-0" : ""}`;
    if (bq(T)) J = "";
    else if (bq(X)) J = `<${+T + 1}.0.0-0`;
    else if (bq(f)) J = `<${T}.${+X + 1}.0-0`;
    else if (V) J = `<=${T}.${X}.${f}-${V}`;
    else if ($) J = `<${T}.${X}.${+f + 1}-0`;
    else J = `<=${J}`;
    return `${K} ${J}`.trim();
  }, "ah"), Qh = /* @__PURE__ */ __name(($, q, K) => {
    for (let P = 0; P < $.length; P++) if (!$[P].test(q)) return false;
    if (q.prerelease.length && !K.includePrerelease) {
      for (let P = 0; P < $.length; P++) {
        if (R6($[P].semver), $[P].semver === X2.ANY) continue;
        if ($[P].semver.prerelease.length > 0) {
          let _ = $[P].semver;
          if (_.major === q.major && _.minor === q.minor && _.patch === q.patch) return true;
        }
      }
      return false;
    }
    return true;
  }, "Qh");
});
var ZP = x$((ba, YZ) => {
  var XP = Symbol("SemVer ANY");
  const _n1 = class _n1 {
    static get ANY() {
      return XP;
    }
    constructor($, q) {
      if (q = qZ(q), $ instanceof _n1) if ($.loose === !!q.loose) return $;
      else $ = $.value;
      if ($ = $.trim().split(/\s+/).join(" "), k2("comparator", $, q), this.options = q, this.loose = !!q.loose, this.parse($), this.semver === XP) this.value = "";
      else this.value = this.operator + this.semver.version;
      k2("comp", this);
    }
    parse($) {
      let q = this.options.loose ? KZ[_Z.COMPARATORLOOSE] : KZ[_Z.COMPARATOR], K = $.match(q);
      if (!K) throw TypeError(`Invalid comparator: ${$}`);
      if (this.operator = K[1] !== void 0 ? K[1] : "", this.operator === "=") this.operator = "";
      if (!K[2]) this.semver = XP;
      else this.semver = new PZ(K[2], this.options.loose);
    }
    toString() {
      return this.value;
    }
    test($) {
      if (k2("Comparator.test", $, this.options.loose), this.semver === XP || $ === XP) return true;
      if (typeof $ === "string") try {
        $ = new PZ($, this.options);
      } catch (q) {
        return false;
      }
      return A2($, this.operator, this.semver, this.options);
    }
    intersects($, q) {
      if (!($ instanceof _n1)) throw TypeError("a Comparator is required");
      if (this.operator === "") {
        if (this.value === "") return true;
        return new OZ($.value, q).test(this.value);
      } else if ($.operator === "") {
        if ($.value === "") return true;
        return new OZ(this.value, q).test($.semver);
      }
      if (q = qZ(q), q.includePrerelease && (this.value === "<0.0.0-0" || $.value === "<0.0.0-0")) return false;
      if (!q.includePrerelease && (this.value.startsWith("<0.0.0") || $.value.startsWith("<0.0.0"))) return false;
      if (this.operator.startsWith(">") && $.operator.startsWith(">")) return true;
      if (this.operator.startsWith("<") && $.operator.startsWith("<")) return true;
      if (this.semver.version === $.semver.version && this.operator.includes("=") && $.operator.includes("=")) return true;
      if (A2(this.semver, "<", $.semver, q) && this.operator.startsWith(">") && $.operator.startsWith("<")) return true;
      if (A2(this.semver, ">", $.semver, q) && this.operator.startsWith("<") && $.operator.startsWith(">")) return true;
      return false;
    }
  };
  __name(_n1, "n1");
  let n1 = _n1;
  YZ.exports = n1;
  var qZ = b1(), { safeRe: KZ, t: _Z } = r_(), A2 = Z2(), k2 = TP(), PZ = hq(), OZ = T8();
});
var AP = x$((ya, jZ) => {
  var eh = T8(), sh = /* @__PURE__ */ __name(($, q, K) => {
    try {
      q = new eh(q, K);
    } catch (P) {
      return false;
    }
    return q.test($);
  }, "sh");
  jZ.exports = sh;
});
var zZ = x$((ua, vZ) => {
  var $E = T8(), qE = /* @__PURE__ */ __name(($, q) => new $E($, q).set.map((K) => K.map((P) => P.value).join(" ").trim().split(" ")), "qE");
  vZ.exports = qE;
});
var HZ = x$((xa, WZ) => {
  var KE = hq(), _E = T8(), PE = /* @__PURE__ */ __name(($, q, K) => {
    let P = null, _ = null, Y = null;
    try {
      Y = new _E(q, K);
    } catch (O) {
      return null;
    }
    return $.forEach((O) => {
      if (Y.test(O)) {
        if (!P || _.compare(O) === -1) P = O, _ = new KE(P, K);
      }
    }), P;
  }, "PE");
  WZ.exports = PE;
});
var TZ = x$((pa, JZ) => {
  var OE = hq(), YE = T8(), jE = /* @__PURE__ */ __name(($, q, K) => {
    let P = null, _ = null, Y = null;
    try {
      Y = new YE(q, K);
    } catch (O) {
      return null;
    }
    return $.forEach((O) => {
      if (Y.test(O)) {
        if (!P || _.compare(O) === 1) P = O, _ = new OE(P, K);
      }
    }), P;
  }, "jE");
  JZ.exports = jE;
});
var ZZ = x$((ca, fZ) => {
  var G2 = hq(), vE = T8(), wZ = wP(), zE = /* @__PURE__ */ __name(($, q) => {
    $ = new vE($, q);
    let K = new G2("0.0.0");
    if ($.test(K)) return K;
    if (K = new G2("0.0.0-0"), $.test(K)) return K;
    K = null;
    for (let P = 0; P < $.set.length; ++P) {
      let _ = $.set[P], Y = null;
      if (_.forEach((O) => {
        let z = new G2(O.semver.version);
        switch (O.operator) {
          case ">":
            if (z.prerelease.length === 0) z.patch++;
            else z.prerelease.push(0);
            z.raw = z.format();
          case "":
          case ">=":
            if (!Y || wZ(z, Y)) Y = z;
            break;
          case "<":
          case "<=":
            break;
          default:
            throw Error(`Unexpected operation: ${O.operator}`);
        }
      }), Y && (!K || wZ(K, Y))) K = Y;
    }
    if (K && $.test(K)) return K;
    return null;
  }, "zE");
  fZ.exports = zE;
});
var AZ = x$((ma, XZ) => {
  var WE = T8(), HE = /* @__PURE__ */ __name(($, q) => {
    try {
      return new WE($, q).range || "*";
    } catch (K) {
      return null;
    }
  }, "HE");
  XZ.exports = HE;
});
var i1 = x$((da, SZ) => {
  var JE = hq(), VZ = ZP(), { ANY: TE } = VZ, wE = T8(), fE = AP(), kZ = wP(), GZ = m1(), ZE = l1(), XE = d1(), AE = /* @__PURE__ */ __name(($, q, K, P) => {
    $ = new JE($, P), q = new wE(q, P);
    let _, Y, O, z, J;
    switch (K) {
      case ">":
        _ = kZ, Y = ZE, O = GZ, z = ">", J = ">=";
        break;
      case "<":
        _ = GZ, Y = XE, O = kZ, z = "<", J = "<=";
        break;
      default:
        throw TypeError('Must provide a hilo val of "<" or ">"');
    }
    if (fE($, q, P)) return false;
    for (let T = 0; T < q.set.length; ++T) {
      let X = q.set[T], f = null, V = null;
      if (X.forEach((M) => {
        if (M.semver === TE) M = new VZ(">=0.0.0");
        if (f = f || M, V = V || M, _(M.semver, f.semver, P)) f = M;
        else if (O(M.semver, V.semver, P)) V = M;
      }), f.operator === z || f.operator === J) return false;
      if ((!V.operator || V.operator === z) && Y($, V.semver)) return false;
      else if (V.operator === J && O($, V.semver)) return false;
    }
    return true;
  }, "AE");
  SZ.exports = AE;
});
var NZ = x$((la, MZ) => {
  var kE = i1(), GE = /* @__PURE__ */ __name(($, q, K) => kE($, q, ">", K), "GE");
  MZ.exports = GE;
});
var hZ = x$((ra, CZ) => {
  var VE = i1(), SE = /* @__PURE__ */ __name(($, q, K) => VE($, q, "<", K), "SE");
  CZ.exports = SE;
});
var IZ = x$((oa, RZ) => {
  var EZ = T8(), ME = /* @__PURE__ */ __name(($, q, K) => {
    return $ = new EZ($, K), q = new EZ(q, K), $.intersects(q, K);
  }, "ME");
  RZ.exports = ME;
});
var LZ = x$((na, DZ) => {
  var NE = AP(), CE = J8();
  DZ.exports = ($, q, K) => {
    let P = [], _ = null, Y = null, O = $.sort((X, f) => CE(X, f, K));
    for (let X of O) if (NE(X, q, K)) {
      if (Y = X, !_) _ = X;
    } else {
      if (Y) P.push([_, Y]);
      Y = null, _ = null;
    }
    if (_) P.push([_, null]);
    let z = [];
    for (let [X, f] of P) if (X === f) z.push(X);
    else if (!f && X === O[0]) z.push("*");
    else if (!f) z.push(`>=${X}`);
    else if (X === O[0]) z.push(`<=${f}`);
    else z.push(`${X} - ${f}`);
    let J = z.join(" || "), T = typeof q.raw === "string" ? q.raw : String(q);
    return J.length < T.length ? J : q;
  };
});
var pZ = x$((ia, xZ) => {
  var gZ = T8(), S2 = ZP(), { ANY: V2 } = S2, kP = AP(), M2 = J8(), hE = /* @__PURE__ */ __name(($, q, K = {}) => {
    if ($ === q) return true;
    $ = new gZ($, K), q = new gZ(q, K);
    let P = false;
    $: for (let _ of $.set) {
      for (let Y of q.set) {
        let O = RE(_, Y, K);
        if (P = P || O !== null, O) continue $;
      }
      if (P) return false;
    }
    return true;
  }, "hE"), EE = [new S2(">=0.0.0-0")], bZ = [new S2(">=0.0.0")], RE = /* @__PURE__ */ __name(($, q, K) => {
    if ($ === q) return true;
    if ($.length === 1 && $[0].semver === V2) if (q.length === 1 && q[0].semver === V2) return true;
    else if (K.includePrerelease) $ = EE;
    else $ = bZ;
    if (q.length === 1 && q[0].semver === V2) if (K.includePrerelease) return true;
    else q = bZ;
    let P = /* @__PURE__ */ new Set(), _, Y;
    for (let M of $) if (M.operator === ">" || M.operator === ">=") _ = yZ(_, M, K);
    else if (M.operator === "<" || M.operator === "<=") Y = uZ(Y, M, K);
    else P.add(M.semver);
    if (P.size > 1) return null;
    let O;
    if (_ && Y) {
      if (O = M2(_.semver, Y.semver, K), O > 0) return null;
      else if (O === 0 && (_.operator !== ">=" || Y.operator !== "<=")) return null;
    }
    for (let M of P) {
      if (_ && !kP(M, String(_), K)) return null;
      if (Y && !kP(M, String(Y), K)) return null;
      for (let N of q) if (!kP(M, String(N), K)) return false;
      return true;
    }
    let z, J, T, X, f = Y && !K.includePrerelease && Y.semver.prerelease.length ? Y.semver : false, V = _ && !K.includePrerelease && _.semver.prerelease.length ? _.semver : false;
    if (f && f.prerelease.length === 1 && Y.operator === "<" && f.prerelease[0] === 0) f = false;
    for (let M of q) {
      if (X = X || M.operator === ">" || M.operator === ">=", T = T || M.operator === "<" || M.operator === "<=", _) {
        if (V) {
          if (M.semver.prerelease && M.semver.prerelease.length && M.semver.major === V.major && M.semver.minor === V.minor && M.semver.patch === V.patch) V = false;
        }
        if (M.operator === ">" || M.operator === ">=") {
          if (z = yZ(_, M, K), z === M && z !== _) return false;
        } else if (_.operator === ">=" && !kP(_.semver, String(M), K)) return false;
      }
      if (Y) {
        if (f) {
          if (M.semver.prerelease && M.semver.prerelease.length && M.semver.major === f.major && M.semver.minor === f.minor && M.semver.patch === f.patch) f = false;
        }
        if (M.operator === "<" || M.operator === "<=") {
          if (J = uZ(Y, M, K), J === M && J !== Y) return false;
        } else if (Y.operator === "<=" && !kP(Y.semver, String(M), K)) return false;
      }
      if (!M.operator && (Y || _) && O !== 0) return false;
    }
    if (_ && T && !Y && O !== 0) return false;
    if (Y && X && !_ && O !== 0) return false;
    if (V || f) return false;
    return true;
  }, "RE"), yZ = /* @__PURE__ */ __name(($, q, K) => {
    if (!$) return q;
    let P = M2($.semver, q.semver, K);
    return P > 0 ? $ : P < 0 ? q : q.operator === ">" && $.operator === ">=" ? q : $;
  }, "yZ"), uZ = /* @__PURE__ */ __name(($, q, K) => {
    if (!$) return q;
    let P = M2($.semver, q.semver, K);
    return P < 0 ? $ : P > 0 ? q : q.operator === "<" && $.operator === "<=" ? q : $;
  }, "uZ");
  xZ.exports = hE;
});
var lZ = x$((ta, dZ) => {
  var N2 = r_(), cZ = JP(), IE = hq(), mZ = J2(), DE = z_(), LE = zf(), gE = Hf(), bE = wf(), yE = Xf(), uE = kf(), xE = Vf(), pE = Mf(), cE = Cf(), mE = J8(), dE = If(), lE = Lf(), rE = c1(), oE = uf(), nE = pf(), iE = wP(), tE = m1(), BE = w2(), UE = f2(), FE = d1(), aE = l1(), QE = Z2(), eE = Bf(), sE = ZP(), $R = T8(), qR = AP(), KR = zZ(), _R = HZ(), PR = TZ(), OR = ZZ(), YR = AZ(), jR = i1(), vR = NZ(), zR = hZ(), WR = IZ(), HR = LZ(), JR = pZ();
  dZ.exports = { parse: DE, valid: LE, clean: gE, inc: bE, diff: yE, major: uE, minor: xE, patch: pE, prerelease: cE, compare: mE, rcompare: dE, compareLoose: lE, compareBuild: rE, sort: oE, rsort: nE, gt: iE, lt: tE, eq: BE, neq: UE, gte: FE, lte: aE, cmp: QE, coerce: eE, Comparator: sE, Range: $R, satisfies: qR, toComparators: KR, maxSatisfying: _R, minSatisfying: PR, minVersion: OR, validRange: YR, outside: jR, gtr: vR, ltr: zR, intersects: WR, simplifyRange: HR, subset: JR, SemVer: IE, re: N2.re, src: N2.src, tokens: N2.t, SEMVER_SPEC_VERSION: cZ.SEMVER_SPEC_VERSION, RELEASE_TYPES: cZ.RELEASE_TYPES, compareIdentifiers: mZ.compareIdentifiers, rcompareIdentifiers: mZ.rcompareIdentifiers };
});
var jX = x$((LQ, YX) => {
  var PX = /* @__PURE__ */ __name(($ = 0) => (q) => `\x1B[${38 + $};5;${q}m`, "PX"), OX = /* @__PURE__ */ __name(($ = 0) => (q, K, P) => `\x1B[${38 + $};2;${q};${K};${P}m`, "OX");
  function yR() {
    let $ = /* @__PURE__ */ new Map(), q = { modifier: { reset: [0, 0], bold: [1, 22], dim: [2, 22], italic: [3, 23], underline: [4, 24], overline: [53, 55], inverse: [7, 27], hidden: [8, 28], strikethrough: [9, 29] }, color: { black: [30, 39], red: [31, 39], green: [32, 39], yellow: [33, 39], blue: [34, 39], magenta: [35, 39], cyan: [36, 39], white: [37, 39], blackBright: [90, 39], redBright: [91, 39], greenBright: [92, 39], yellowBright: [93, 39], blueBright: [94, 39], magentaBright: [95, 39], cyanBright: [96, 39], whiteBright: [97, 39] }, bgColor: { bgBlack: [40, 49], bgRed: [41, 49], bgGreen: [42, 49], bgYellow: [43, 49], bgBlue: [44, 49], bgMagenta: [45, 49], bgCyan: [46, 49], bgWhite: [47, 49], bgBlackBright: [100, 49], bgRedBright: [101, 49], bgGreenBright: [102, 49], bgYellowBright: [103, 49], bgBlueBright: [104, 49], bgMagentaBright: [105, 49], bgCyanBright: [106, 49], bgWhiteBright: [107, 49] } };
    q.color.gray = q.color.blackBright, q.bgColor.bgGray = q.bgColor.bgBlackBright, q.color.grey = q.color.blackBright, q.bgColor.bgGrey = q.bgColor.bgBlackBright;
    for (let [K, P] of Object.entries(q)) {
      for (let [_, Y] of Object.entries(P)) q[_] = { open: `\x1B[${Y[0]}m`, close: `\x1B[${Y[1]}m` }, P[_] = q[_], $.set(Y[0], Y[1]);
      Object.defineProperty(q, K, { value: P, enumerable: false });
    }
    return Object.defineProperty(q, "codes", { value: $, enumerable: false }), q.color.close = "\x1B[39m", q.bgColor.close = "\x1B[49m", q.color.ansi256 = PX(), q.color.ansi16m = OX(), q.bgColor.ansi256 = PX(10), q.bgColor.ansi16m = OX(10), Object.defineProperties(q, { rgbToAnsi256: { value: /* @__PURE__ */ __name((K, P, _) => {
      if (K === P && P === _) {
        if (K < 8) return 16;
        if (K > 248) return 231;
        return Math.round((K - 8) / 247 * 24) + 232;
      }
      return 16 + 36 * Math.round(K / 255 * 5) + 6 * Math.round(P / 255 * 5) + Math.round(_ / 255 * 5);
    }, "value"), enumerable: false }, hexToRgb: { value: /* @__PURE__ */ __name((K) => {
      let P = /(?<colorString>[a-f\d]{6}|[a-f\d]{3})/i.exec(K.toString(16));
      if (!P) return [0, 0, 0];
      let { colorString: _ } = P.groups;
      if (_.length === 3) _ = _.split("").map((O) => O + O).join("");
      let Y = Number.parseInt(_, 16);
      return [Y >> 16 & 255, Y >> 8 & 255, Y & 255];
    }, "value"), enumerable: false }, hexToAnsi256: { value: /* @__PURE__ */ __name((K) => q.rgbToAnsi256(...q.hexToRgb(K)), "value"), enumerable: false } }), q;
  }
  __name(yR, "yR");
  Object.defineProperty(YX, "exports", { enumerable: true, get: yR });
});
var lA = x$((tb) => {
  tb.byteLength = db;
  tb.toByteArray = rb;
  tb.fromByteArray = ib;
  var a8 = [], k8 = [], mb = typeof Uint8Array < "u" ? Uint8Array : Array, Mz = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (QK = 0, Nz = Mz.length; QK < Nz; ++QK) a8[QK] = Mz[QK], k8[Mz.charCodeAt(QK)] = QK;
  var QK, Nz;
  k8[45] = 62;
  k8[95] = 63;
  function dA($) {
    var q = $.length;
    if (q % 4 > 0) throw Error("Invalid string. Length must be a multiple of 4");
    var K = $.indexOf("=");
    if (K === -1) K = q;
    var P = K === q ? 0 : 4 - K % 4;
    return [K, P];
  }
  __name(dA, "dA");
  function db($) {
    var q = dA($), K = q[0], P = q[1];
    return (K + P) * 3 / 4 - P;
  }
  __name(db, "db");
  function lb($, q, K) {
    return (q + K) * 3 / 4 - K;
  }
  __name(lb, "lb");
  function rb($) {
    var q, K = dA($), P = K[0], _ = K[1], Y = new mb(lb($, P, _)), O = 0, z = _ > 0 ? P - 4 : P, J;
    for (J = 0; J < z; J += 4) q = k8[$.charCodeAt(J)] << 18 | k8[$.charCodeAt(J + 1)] << 12 | k8[$.charCodeAt(J + 2)] << 6 | k8[$.charCodeAt(J + 3)], Y[O++] = q >> 16 & 255, Y[O++] = q >> 8 & 255, Y[O++] = q & 255;
    if (_ === 2) q = k8[$.charCodeAt(J)] << 2 | k8[$.charCodeAt(J + 1)] >> 4, Y[O++] = q & 255;
    if (_ === 1) q = k8[$.charCodeAt(J)] << 10 | k8[$.charCodeAt(J + 1)] << 4 | k8[$.charCodeAt(J + 2)] >> 2, Y[O++] = q >> 8 & 255, Y[O++] = q & 255;
    return Y;
  }
  __name(rb, "rb");
  function ob($) {
    return a8[$ >> 18 & 63] + a8[$ >> 12 & 63] + a8[$ >> 6 & 63] + a8[$ & 63];
  }
  __name(ob, "ob");
  function nb($, q, K) {
    var P, _ = [];
    for (var Y = q; Y < K; Y += 3) P = ($[Y] << 16 & 16711680) + ($[Y + 1] << 8 & 65280) + ($[Y + 2] & 255), _.push(ob(P));
    return _.join("");
  }
  __name(nb, "nb");
  function ib($) {
    var q, K = $.length, P = K % 3, _ = [], Y = 16383;
    for (var O = 0, z = K - P; O < z; O += Y) _.push(nb($, O, O + Y > z ? z : O + Y));
    if (P === 1) q = $[K - 1], _.push(a8[q >> 2] + a8[q << 4 & 63] + "==");
    else if (P === 2) q = ($[K - 2] << 8) + $[K - 1], _.push(a8[q >> 10] + a8[q >> 4 & 63] + a8[q << 2 & 63] + "=");
    return _.join("");
  }
  __name(ib, "ib");
});
var cq = x$((fy) => {
  fy.__esModule = true;
  fy.extend = nA;
  fy.indexOf = zy;
  fy.escapeExpression = Wy;
  fy.isEmpty = Hy;
  fy.createFrame = Jy;
  fy.blockParams = Ty;
  fy.appendContextPath = wy;
  var Oy = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#x27;", "`": "&#x60;", "=": "&#x3D;" }, Yy = /[&<>"'`=]/g, jy = /[&<>"'`=]/;
  function vy($) {
    return Oy[$];
  }
  __name(vy, "vy");
  function nA($) {
    for (var q = 1; q < arguments.length; q++) for (var K in arguments[q]) if (Object.prototype.hasOwnProperty.call(arguments[q], K)) $[K] = arguments[q][K];
    return $;
  }
  __name(nA, "nA");
  var Dz = Object.prototype.toString;
  fy.toString = Dz;
  var Iz = /* @__PURE__ */ __name(function(q) {
    return typeof q === "function";
  }, "Iz");
  if (Iz(/x/)) fy.isFunction = Iz = /* @__PURE__ */ __name(function($) {
    return typeof $ === "function" && Dz.call($) === "[object Function]";
  }, "Iz");
  fy.isFunction = Iz;
  var iA = Array.isArray || function($) {
    return $ && typeof $ === "object" ? Dz.call($) === "[object Array]" : false;
  };
  fy.isArray = iA;
  function zy($, q) {
    for (var K = 0, P = $.length; K < P; K++) if ($[K] === q) return K;
    return -1;
  }
  __name(zy, "zy");
  function Wy($) {
    if (typeof $ !== "string") {
      if ($ && $.toHTML) return $.toHTML();
      else if ($ == null) return "";
      else if (!$) return $ + "";
      $ = "" + $;
    }
    if (!jy.test($)) return $;
    return $.replace(Yy, vy);
  }
  __name(Wy, "Wy");
  function Hy($) {
    if (!$ && $ !== 0) return true;
    else if (iA($) && $.length === 0) return true;
    else return false;
  }
  __name(Hy, "Hy");
  function Jy($) {
    var q = nA({}, $);
    return q._parent = $, q;
  }
  __name(Jy, "Jy");
  function Ty($, q) {
    return $.path = q, $;
  }
  __name(Ty, "Ty");
  function wy($, q) {
    return ($ ? $ + "." : "") + q;
  }
  __name(wy, "wy");
});
var G8 = x$((tA, BA) => {
  tA.__esModule = true;
  var Lz = ["description", "fileName", "lineNumber", "endLineNumber", "message", "name", "number", "stack"];
  function gz($, q) {
    var K = q && q.loc, P = void 0, _ = void 0, Y = void 0, O = void 0;
    if (K) P = K.start.line, _ = K.end.line, Y = K.start.column, O = K.end.column, $ += " - " + P + ":" + Y;
    var z = Error.prototype.constructor.call(this, $);
    for (var J = 0; J < Lz.length; J++) this[Lz[J]] = z[Lz[J]];
    if (Error.captureStackTrace) Error.captureStackTrace(this, gz);
    try {
      if (K) if (this.lineNumber = P, this.endLineNumber = _, Object.defineProperty) Object.defineProperty(this, "column", { value: Y, enumerable: true }), Object.defineProperty(this, "endColumn", { value: O, enumerable: true });
      else this.column = Y, this.endColumn = O;
    } catch (T) {
    }
  }
  __name(gz, "gz");
  gz.prototype = Error();
  tA.default = gz;
  BA.exports = tA.default;
});
var aA = x$((UA, FA) => {
  UA.__esModule = true;
  var bz = cq();
  UA.default = function($) {
    $.registerHelper("blockHelperMissing", function(q, K) {
      var { inverse: P, fn: _ } = K;
      if (q === true) return _(this);
      else if (q === false || q == null) return P(this);
      else if (bz.isArray(q)) if (q.length > 0) {
        if (K.ids) K.ids = [K.name];
        return $.helpers.each(q, K);
      } else return P(this);
      else {
        if (K.data && K.ids) {
          var Y = bz.createFrame(K.data);
          Y.contextPath = bz.appendContextPath(K.data.contextPath, K.name), K = { data: Y };
        }
        return _(q, K);
      }
    });
  };
  FA.exports = UA.default;
});
var sA = x$((QA, eA) => {
  QA.__esModule = true;
  function Ly($) {
    return $ && $.__esModule ? $ : { default: $ };
  }
  __name(Ly, "Ly");
  var N7 = cq(), gy = G8(), by = Ly(gy);
  QA.default = function($) {
    $.registerHelper("each", function(q, K) {
      if (!K) throw new by.default("Must pass iterator to #each");
      var { fn: P, inverse: _ } = K, Y = 0, O = "", z = void 0, J = void 0;
      if (K.data && K.ids) J = N7.appendContextPath(K.data.contextPath, K.ids[0]) + ".";
      if (N7.isFunction(q)) q = q.call(this);
      if (K.data) z = N7.createFrame(K.data);
      function T(N, E, h) {
        if (z) {
          if (z.key = N, z.index = E, z.first = E === 0, z.last = !!h, J) z.contextPath = J + N;
        }
        O = O + P(q[N], { data: z, blockParams: N7.blockParams([q[N], N], [J + N, null]) });
      }
      __name(T, "T");
      if (q && typeof q === "object") if (N7.isArray(q)) {
        for (var X = q.length; Y < X; Y++) if (Y in q) T(Y, Y, Y === q.length - 1);
      } else if (typeof Symbol === "function" && q[Symbol.iterator]) {
        var f = [], V = q[Symbol.iterator]();
        for (var M = V.next(); !M.done; M = V.next()) f.push(M.value);
        q = f;
        for (var X = q.length; Y < X; Y++) T(Y, Y, Y === q.length - 1);
      } else (function() {
        var N = void 0;
        if (Object.keys(q).forEach(function(E) {
          if (N !== void 0) T(N, Y - 1);
          N = E, Y++;
        }), N !== void 0) T(N, Y - 1, true);
      })();
      if (Y === 0) O = _(this);
      return O;
    });
  };
  eA.exports = QA.default;
});
var Kk = x$(($k, qk) => {
  $k.__esModule = true;
  function xy($) {
    return $ && $.__esModule ? $ : { default: $ };
  }
  __name(xy, "xy");
  var py = G8(), cy = xy(py);
  $k.default = function($) {
    $.registerHelper("helperMissing", function() {
      if (arguments.length === 1) return;
      else throw new cy.default('Missing helper: "' + arguments[arguments.length - 1].name + '"');
    });
  };
  qk.exports = $k.default;
});
var jk = x$((Ok, Yk) => {
  Ok.__esModule = true;
  function ly($) {
    return $ && $.__esModule ? $ : { default: $ };
  }
  __name(ly, "ly");
  var _k = cq(), ry = G8(), Pk = ly(ry);
  Ok.default = function($) {
    $.registerHelper("if", function(q, K) {
      if (arguments.length != 2) throw new Pk.default("#if requires exactly one argument");
      if (_k.isFunction(q)) q = q.call(this);
      if (!K.hash.includeZero && !q || _k.isEmpty(q)) return K.inverse(this);
      else return K.fn(this);
    }), $.registerHelper("unless", function(q, K) {
      if (arguments.length != 2) throw new Pk.default("#unless requires exactly one argument");
      return $.helpers.if.call(this, q, { fn: K.inverse, inverse: K.fn, hash: K.hash });
    });
  };
  Yk.exports = Ok.default;
});
var Wk = x$((vk, zk) => {
  vk.__esModule = true;
  vk.default = function($) {
    $.registerHelper("log", function() {
      var q = [void 0], K = arguments[arguments.length - 1];
      for (var P = 0; P < arguments.length - 1; P++) q.push(arguments[P]);
      var _ = 1;
      if (K.hash.level != null) _ = K.hash.level;
      else if (K.data && K.data.level != null) _ = K.data.level;
      q[0] = _, $.log.apply($, q);
    });
  };
  zk.exports = vk.default;
});
var Tk = x$((Hk, Jk) => {
  Hk.__esModule = true;
  Hk.default = function($) {
    $.registerHelper("lookup", function(q, K, P) {
      if (!q) return q;
      return P.lookupProperty(q, K);
    });
  };
  Jk.exports = Hk.default;
});
var Zk = x$((wk, fk) => {
  wk.__esModule = true;
  function Fy($) {
    return $ && $.__esModule ? $ : { default: $ };
  }
  __name(Fy, "Fy");
  var C7 = cq(), ay = G8(), Qy = Fy(ay);
  wk.default = function($) {
    $.registerHelper("with", function(q, K) {
      if (arguments.length != 2) throw new Qy.default("#with requires exactly one argument");
      if (C7.isFunction(q)) q = q.call(this);
      var P = K.fn;
      if (!C7.isEmpty(q)) {
        var _ = K.data;
        if (K.data && K.ids) _ = C7.createFrame(K.data), _.contextPath = C7.appendContextPath(K.data.contextPath, K.ids[0]);
        return P(q, { data: _, blockParams: C7.blockParams([q], [_ && _.contextPath]) });
      } else return K.inverse(this);
    });
  };
  fk.exports = wk.default;
});
var yz = x$((Zu) => {
  Zu.__esModule = true;
  Zu.registerDefaultHelpers = wu;
  Zu.moveHelperToHooks = fu;
  function h_($) {
    return $ && $.__esModule ? $ : { default: $ };
  }
  __name(h_, "h_");
  var $u = aA(), qu = h_($u), Ku = sA(), _u = h_(Ku), Pu = Kk(), Ou = h_(Pu), Yu = jk(), ju = h_(Yu), vu = Wk(), zu = h_(vu), Wu = Tk(), Hu = h_(Wu), Ju = Zk(), Tu = h_(Ju);
  function wu($) {
    qu.default($), _u.default($), Ou.default($), ju.default($), zu.default($), Hu.default($), Tu.default($);
  }
  __name(wu, "wu");
  function fu($, q, K) {
    if ($.helpers[q]) {
      if ($.hooks[q] = $.helpers[q], !K) delete $.helpers[q];
    }
  }
  __name(fu, "fu");
});
var kk = x$((Xk, Ak) => {
  Xk.__esModule = true;
  var Gu = cq();
  Xk.default = function($) {
    $.registerDecorator("inline", function(q, K, P, _) {
      var Y = q;
      if (!K.partials) K.partials = {}, Y = /* @__PURE__ */ __name(function(O, z) {
        var J = P.partials;
        P.partials = Gu.extend({}, J, K.partials);
        var T = q(O, z);
        return P.partials = J, T;
      }, "Y");
      return K.partials[_.args[0]] = _.fn, Y;
    });
  };
  Ak.exports = Xk.default;
});
var Gk = x$((Eu) => {
  Eu.__esModule = true;
  Eu.registerDefaultDecorators = hu;
  function Mu($) {
    return $ && $.__esModule ? $ : { default: $ };
  }
  __name(Mu, "Mu");
  var Nu = kk(), Cu = Mu(Nu);
  function hu($) {
    Cu.default($);
  }
  __name(hu, "hu");
});
var uz = x$((Vk, Sk) => {
  Vk.__esModule = true;
  var Du = cq(), C4 = { methodMap: ["debug", "info", "warn", "error"], level: "info", lookupLevel: /* @__PURE__ */ __name(function(q) {
    if (typeof q === "string") {
      var K = Du.indexOf(C4.methodMap, q.toLowerCase());
      if (K >= 0) q = K;
      else q = parseInt(q, 10);
    }
    return q;
  }, "lookupLevel"), log: /* @__PURE__ */ __name(function(q) {
    if (q = C4.lookupLevel(q), typeof console < "u" && C4.lookupLevel(C4.level) <= q) {
      var K = C4.methodMap[q];
      if (!console[K]) K = "log";
      for (var P = arguments.length, _ = Array(P > 1 ? P - 1 : 0), Y = 1; Y < P; Y++) _[Y - 1] = arguments[Y];
      console[K].apply(console, _);
    }
  }, "log") };
  Vk.default = C4;
  Sk.exports = Vk.default;
});
var Mk = x$((uu) => {
  uu.__esModule = true;
  uu.createNewLookupObject = yu;
  var bu = cq();
  function yu() {
    for (var $ = arguments.length, q = Array($), K = 0; K < $; K++) q[K] = arguments[K];
    return bu.extend.apply(void 0, [/* @__PURE__ */ Object.create(null)].concat(q));
  }
  __name(yu, "yu");
});
var xz = x$((iu) => {
  iu.__esModule = true;
  iu.createProtoAccessControl = lu;
  iu.resultIsAllowed = ru;
  iu.resetLoggedProperties = nu;
  function cu($) {
    return $ && $.__esModule ? $ : { default: $ };
  }
  __name(cu, "cu");
  var Nk = Mk(), mu = uz(), du = cu(mu), G5 = /* @__PURE__ */ Object.create(null);
  function lu($) {
    var q = /* @__PURE__ */ Object.create(null);
    q.constructor = false, q.__defineGetter__ = false, q.__defineSetter__ = false, q.__lookupGetter__ = false;
    var K = /* @__PURE__ */ Object.create(null);
    return K.__proto__ = false, { properties: { whitelist: Nk.createNewLookupObject(K, $.allowedProtoProperties), defaultValue: $.allowProtoPropertiesByDefault }, methods: { whitelist: Nk.createNewLookupObject(q, $.allowedProtoMethods), defaultValue: $.allowProtoMethodsByDefault } };
  }
  __name(lu, "lu");
  function ru($, q, K) {
    if (typeof $ === "function") return Ck(q.methods, K);
    else return Ck(q.properties, K);
  }
  __name(ru, "ru");
  function Ck($, q) {
    if ($.whitelist[q] !== void 0) return $.whitelist[q] === true;
    if ($.defaultValue !== void 0) return $.defaultValue;
    return ou(q), false;
  }
  __name(Ck, "Ck");
  function ou($) {
    if (G5[$] !== true) G5[$] = true, du.default.log("error", 'Handlebars: Access has been denied to resolve the property "' + $ + `" because it is not an "own property" of its parent.
You can add a runtime option to disable the check or this warning:
See https://handlebarsjs.com/api-reference/runtime-options.html#options-to-control-prototype-access for details`);
  }
  __name(ou, "ou");
  function nu() {
    Object.keys(G5).forEach(function($) {
      delete G5[$];
    });
  }
  __name(nu, "nu");
});
var S5 = x$((Yx) => {
  Yx.__esModule = true;
  Yx.HandlebarsEnvironment = mz;
  function hk($) {
    return $ && $.__esModule ? $ : { default: $ };
  }
  __name(hk, "hk");
  var E_ = cq(), au = G8(), pz = hk(au), Qu = yz(), eu = Gk(), su = uz(), V5 = hk(su), $x = xz(), qx = "4.7.8";
  Yx.VERSION = qx;
  var Kx = 8;
  Yx.COMPILER_REVISION = Kx;
  var _x = 7;
  Yx.LAST_COMPATIBLE_COMPILER_REVISION = _x;
  var Px = { 1: "<= 1.0.rc.2", 2: "== 1.0.0-rc.3", 3: "== 1.0.0-rc.4", 4: "== 1.x.x", 5: "== 2.0.0-alpha.x", 6: ">= 2.0.0-beta.1", 7: ">= 4.0.0 <4.3.0", 8: ">= 4.3.0" };
  Yx.REVISION_CHANGES = Px;
  var cz = "[object Object]";
  function mz($, q, K) {
    this.helpers = $ || {}, this.partials = q || {}, this.decorators = K || {}, Qu.registerDefaultHelpers(this), eu.registerDefaultDecorators(this);
  }
  __name(mz, "mz");
  mz.prototype = { constructor: mz, logger: V5.default, log: V5.default.log, registerHelper: /* @__PURE__ */ __name(function(q, K) {
    if (E_.toString.call(q) === cz) {
      if (K) throw new pz.default("Arg not supported with multiple helpers");
      E_.extend(this.helpers, q);
    } else this.helpers[q] = K;
  }, "registerHelper"), unregisterHelper: /* @__PURE__ */ __name(function(q) {
    delete this.helpers[q];
  }, "unregisterHelper"), registerPartial: /* @__PURE__ */ __name(function(q, K) {
    if (E_.toString.call(q) === cz) E_.extend(this.partials, q);
    else {
      if (typeof K > "u") throw new pz.default('Attempting to register a partial called "' + q + '" as undefined');
      this.partials[q] = K;
    }
  }, "registerPartial"), unregisterPartial: /* @__PURE__ */ __name(function(q) {
    delete this.partials[q];
  }, "unregisterPartial"), registerDecorator: /* @__PURE__ */ __name(function(q, K) {
    if (E_.toString.call(q) === cz) {
      if (K) throw new pz.default("Arg not supported with multiple decorators");
      E_.extend(this.decorators, q);
    } else this.decorators[q] = K;
  }, "registerDecorator"), unregisterDecorator: /* @__PURE__ */ __name(function(q) {
    delete this.decorators[q];
  }, "unregisterDecorator"), resetLoggedPropertyAccesses: /* @__PURE__ */ __name(function() {
    $x.resetLoggedProperties();
  }, "resetLoggedPropertyAccesses") };
  var Ox = V5.default.log;
  Yx.log = Ox;
  Yx.createFrame = E_.createFrame;
  Yx.logger = V5.default;
});
var Ik = x$((Ek, Rk) => {
  Ek.__esModule = true;
  function dz($) {
    this.string = $;
  }
  __name(dz, "dz");
  dz.prototype.toString = dz.prototype.toHTML = function() {
    return "" + this.string;
  };
  Ek.default = dz;
  Rk.exports = Ek.default;
});
var Dk = x$((kx) => {
  kx.__esModule = true;
  kx.wrapHelper = Ax;
  function Ax($, q) {
    if (typeof $ !== "function") return $;
    var K = /* @__PURE__ */ __name(function() {
      var _ = arguments[arguments.length - 1];
      return arguments[arguments.length - 1] = q(_), $.apply(this, arguments);
    }, "K");
    return K;
  }
  __name(Ax, "Ax");
});
var uk = x$((yx) => {
  yx.__esModule = true;
  yx.checkRevision = Ex;
  yx.template = Rx;
  yx.wrapProgram = M5;
  yx.resolvePartial = Ix;
  yx.invokePartial = Dx;
  yx.noop = bk;
  function Sx($) {
    return $ && $.__esModule ? $ : { default: $ };
  }
  __name(Sx, "Sx");
  function Mx($) {
    if ($ && $.__esModule) return $;
    else {
      var q = {};
      if ($ != null) {
        for (var K in $) if (Object.prototype.hasOwnProperty.call($, K)) q[K] = $[K];
      }
      return q.default = $, q;
    }
  }
  __name(Mx, "Mx");
  var Nx = cq(), XK = Mx(Nx), Cx = G8(), AK = Sx(Cx), kK = S5(), Lk = yz(), hx = Dk(), gk = xz();
  function Ex($) {
    var q = $ && $[0] || 1, K = kK.COMPILER_REVISION;
    if (q >= kK.LAST_COMPATIBLE_COMPILER_REVISION && q <= kK.COMPILER_REVISION) return;
    if (q < kK.LAST_COMPATIBLE_COMPILER_REVISION) {
      var P = kK.REVISION_CHANGES[K], _ = kK.REVISION_CHANGES[q];
      throw new AK.default("Template was precompiled with an older version of Handlebars than the current runtime. Please update your precompiler to a newer version (" + P + ") or downgrade your runtime to an older version (" + _ + ").");
    } else throw new AK.default("Template was precompiled with a newer version of Handlebars than the current runtime. Please update your runtime to a newer version (" + $[1] + ").");
  }
  __name(Ex, "Ex");
  function Rx($, q) {
    if (!q) throw new AK.default("No environment passed to template");
    if (!$ || !$.main) throw new AK.default("Unknown template object: " + typeof $);
    $.main.decorator = $.main_d, q.VM.checkRevision($.compiler);
    var K = $.compiler && $.compiler[0] === 7;
    function P(O, z, J) {
      if (J.hash) {
        if (z = XK.extend({}, z, J.hash), J.ids) J.ids[0] = true;
      }
      O = q.VM.resolvePartial.call(this, O, z, J);
      var T = XK.extend({}, J, { hooks: this.hooks, protoAccessControl: this.protoAccessControl }), X = q.VM.invokePartial.call(this, O, z, T);
      if (X == null && q.compile) J.partials[J.name] = q.compile(O, $.compilerOptions, q), X = J.partials[J.name](z, T);
      if (X != null) {
        if (J.indent) {
          var f = X.split(`
`);
          for (var V = 0, M = f.length; V < M; V++) {
            if (!f[V] && V + 1 === M) break;
            f[V] = J.indent + f[V];
          }
          X = f.join(`
`);
        }
        return X;
      } else throw new AK.default("The partial " + J.name + " could not be compiled when running in runtime-only mode");
    }
    __name(P, "P");
    var _ = { strict: /* @__PURE__ */ __name(function(z, J, T) {
      if (!z || !(J in z)) throw new AK.default('"' + J + '" not defined in ' + z, { loc: T });
      return _.lookupProperty(z, J);
    }, "strict"), lookupProperty: /* @__PURE__ */ __name(function(z, J) {
      var T = z[J];
      if (T == null) return T;
      if (Object.prototype.hasOwnProperty.call(z, J)) return T;
      if (gk.resultIsAllowed(T, _.protoAccessControl, J)) return T;
      return;
    }, "lookupProperty"), lookup: /* @__PURE__ */ __name(function(z, J) {
      var T = z.length;
      for (var X = 0; X < T; X++) {
        var f = z[X] && _.lookupProperty(z[X], J);
        if (f != null) return z[X][J];
      }
    }, "lookup"), lambda: /* @__PURE__ */ __name(function(z, J) {
      return typeof z === "function" ? z.call(J) : z;
    }, "lambda"), escapeExpression: XK.escapeExpression, invokePartial: P, fn: /* @__PURE__ */ __name(function(z) {
      var J = $[z];
      return J.decorator = $[z + "_d"], J;
    }, "fn"), programs: [], program: /* @__PURE__ */ __name(function(z, J, T, X, f) {
      var V = this.programs[z], M = this.fn(z);
      if (J || f || X || T) V = M5(this, z, M, J, T, X, f);
      else if (!V) V = this.programs[z] = M5(this, z, M);
      return V;
    }, "program"), data: /* @__PURE__ */ __name(function(z, J) {
      while (z && J--) z = z._parent;
      return z;
    }, "data"), mergeIfNeeded: /* @__PURE__ */ __name(function(z, J) {
      var T = z || J;
      if (z && J && z !== J) T = XK.extend({}, J, z);
      return T;
    }, "mergeIfNeeded"), nullContext: Object.seal({}), noop: q.VM.noop, compilerInfo: $.compiler };
    function Y(O) {
      var z = arguments.length <= 1 || arguments[1] === void 0 ? {} : arguments[1], J = z.data;
      if (Y._setup(z), !z.partial && $.useData) J = Lx(O, J);
      var T = void 0, X = $.useBlockParams ? [] : void 0;
      if ($.useDepths) if (z.depths) T = O != z.depths[0] ? [O].concat(z.depths) : z.depths;
      else T = [O];
      function f(V) {
        return "" + $.main(_, V, _.helpers, _.partials, J, X, T);
      }
      __name(f, "f");
      return f = yk($.main, f, _, z.depths || [], J, X), f(O, z);
    }
    __name(Y, "Y");
    return Y.isTop = true, Y._setup = function(O) {
      if (!O.partial) {
        var z = XK.extend({}, q.helpers, O.helpers);
        if (gx(z, _), _.helpers = z, $.usePartial) _.partials = _.mergeIfNeeded(O.partials, q.partials);
        if ($.usePartial || $.useDecorators) _.decorators = XK.extend({}, q.decorators, O.decorators);
        _.hooks = {}, _.protoAccessControl = gk.createProtoAccessControl(O);
        var J = O.allowCallsToHelperMissing || K;
        Lk.moveHelperToHooks(_, "helperMissing", J), Lk.moveHelperToHooks(_, "blockHelperMissing", J);
      } else _.protoAccessControl = O.protoAccessControl, _.helpers = O.helpers, _.partials = O.partials, _.decorators = O.decorators, _.hooks = O.hooks;
    }, Y._child = function(O, z, J, T) {
      if ($.useBlockParams && !J) throw new AK.default("must pass block params");
      if ($.useDepths && !T) throw new AK.default("must pass parent depths");
      return M5(_, O, $[O], z, 0, J, T);
    }, Y;
  }
  __name(Rx, "Rx");
  function M5($, q, K, P, _, Y, O) {
    function z(J) {
      var T = arguments.length <= 1 || arguments[1] === void 0 ? {} : arguments[1], X = O;
      if (O && J != O[0] && !(J === $.nullContext && O[0] === null)) X = [J].concat(O);
      return K($, J, $.helpers, $.partials, T.data || P, Y && [T.blockParams].concat(Y), X);
    }
    __name(z, "z");
    return z = yk(K, z, $, O, P, Y), z.program = q, z.depth = O ? O.length : 0, z.blockParams = _ || 0, z;
  }
  __name(M5, "M5");
  function Ix($, q, K) {
    if (!$) if (K.name === "@partial-block") $ = K.data["partial-block"];
    else $ = K.partials[K.name];
    else if (!$.call && !K.name) K.name = $, $ = K.partials[$];
    return $;
  }
  __name(Ix, "Ix");
  function Dx($, q, K) {
    var P = K.data && K.data["partial-block"];
    if (K.partial = true, K.ids) K.data.contextPath = K.ids[0] || K.data.contextPath;
    var _ = void 0;
    if (K.fn && K.fn !== bk) (function() {
      K.data = kK.createFrame(K.data);
      var Y = K.fn;
      if (_ = K.data["partial-block"] = function(z) {
        var J = arguments.length <= 1 || arguments[1] === void 0 ? {} : arguments[1];
        return J.data = kK.createFrame(J.data), J.data["partial-block"] = P, Y(z, J);
      }, Y.partials) K.partials = XK.extend({}, K.partials, Y.partials);
    })();
    if ($ === void 0 && _) $ = _;
    if ($ === void 0) throw new AK.default("The partial " + K.name + " could not be found");
    else if ($ instanceof Function) return $(q, K);
  }
  __name(Dx, "Dx");
  function bk() {
    return "";
  }
  __name(bk, "bk");
  function Lx($, q) {
    if (!q || !("root" in q)) q = q ? kK.createFrame(q) : {}, q.root = $;
    return q;
  }
  __name(Lx, "Lx");
  function yk($, q, K, P, _, Y) {
    if ($.decorator) {
      var O = {};
      q = $.decorator(q, O, K, P && P[0], _, Y, P), XK.extend(q, O);
    }
    return q;
  }
  __name(yk, "yk");
  function gx($, q) {
    Object.keys($).forEach(function(K) {
      var P = $[K];
      $[K] = bx(P, q);
    });
  }
  __name(gx, "gx");
  function bx($, q) {
    var K = q.lookupProperty;
    return hx.wrapHelper($, function(P) {
      return XK.extend({ lookupProperty: K }, P);
    });
  }
  __name(bx, "bx");
});
var lz = x$((xk, pk) => {
  xk.__esModule = true;
  xk.default = function($) {
    (function() {
      if (typeof globalThis === "object") return;
      Object.prototype.__defineGetter__("__magic__", function() {
        return this;
      }), __magic__.globalThis = __magic__, delete Object.prototype.__magic__;
    })();
    var q = globalThis.Handlebars;
    $.noConflict = function() {
      if (globalThis.Handlebars === $) globalThis.Handlebars = q;
      return $;
    };
  };
  pk.exports = xk.default;
});
var ok = x$((lk, rk) => {
  lk.__esModule = true;
  function oz($) {
    return $ && $.__esModule ? $ : { default: $ };
  }
  __name(oz, "oz");
  function nz($) {
    if ($ && $.__esModule) return $;
    else {
      var q = {};
      if ($ != null) {
        for (var K in $) if (Object.prototype.hasOwnProperty.call($, K)) q[K] = $[K];
      }
      return q.default = $, q;
    }
  }
  __name(nz, "nz");
  var nx = S5(), ck = nz(nx), ix = Ik(), tx = oz(ix), Bx = G8(), Ux = oz(Bx), Fx = cq(), rz = nz(Fx), ax = uk(), mk = nz(ax), Qx = lz(), ex = oz(Qx);
  function dk() {
    var $ = new ck.HandlebarsEnvironment();
    return rz.extend($, ck), $.SafeString = tx.default, $.Exception = Ux.default, $.Utils = rz, $.escapeExpression = rz.escapeExpression, $.VM = mk, $.template = function(q) {
      return mk.template(q, $);
    }, $;
  }
  __name(dk, "dk");
  var h7 = dk();
  h7.create = dk;
  ex.default(h7);
  h7.default = h7;
  lk.default = h7;
  rk.exports = lk.default;
});
var iz = x$((ik, tk) => {
  ik.__esModule = true;
  var nk = { helpers: { helperExpression: /* @__PURE__ */ __name(function(q) {
    return q.type === "SubExpression" || (q.type === "MustacheStatement" || q.type === "BlockStatement") && !!(q.params && q.params.length || q.hash);
  }, "helperExpression"), scopedId: /* @__PURE__ */ __name(function(q) {
    return /^\.|this\b/.test(q.original);
  }, "scopedId"), simpleId: /* @__PURE__ */ __name(function(q) {
    return q.parts.length === 1 && !nk.helpers.scopedId(q) && !q.depth;
  }, "simpleId") } };
  ik.default = nk;
  tk.exports = ik.default;
});
var Fk = x$((Bk, Uk) => {
  Bk.__esModule = true;
  var _p = (function() {
    var $ = { trace: /* @__PURE__ */ __name(function() {
    }, "trace"), yy: {}, symbols_: { error: 2, root: 3, program: 4, EOF: 5, program_repetition0: 6, statement: 7, mustache: 8, block: 9, rawBlock: 10, partial: 11, partialBlock: 12, content: 13, COMMENT: 14, CONTENT: 15, openRawBlock: 16, rawBlock_repetition0: 17, END_RAW_BLOCK: 18, OPEN_RAW_BLOCK: 19, helperName: 20, openRawBlock_repetition0: 21, openRawBlock_option0: 22, CLOSE_RAW_BLOCK: 23, openBlock: 24, block_option0: 25, closeBlock: 26, openInverse: 27, block_option1: 28, OPEN_BLOCK: 29, openBlock_repetition0: 30, openBlock_option0: 31, openBlock_option1: 32, CLOSE: 33, OPEN_INVERSE: 34, openInverse_repetition0: 35, openInverse_option0: 36, openInverse_option1: 37, openInverseChain: 38, OPEN_INVERSE_CHAIN: 39, openInverseChain_repetition0: 40, openInverseChain_option0: 41, openInverseChain_option1: 42, inverseAndProgram: 43, INVERSE: 44, inverseChain: 45, inverseChain_option0: 46, OPEN_ENDBLOCK: 47, OPEN: 48, mustache_repetition0: 49, mustache_option0: 50, OPEN_UNESCAPED: 51, mustache_repetition1: 52, mustache_option1: 53, CLOSE_UNESCAPED: 54, OPEN_PARTIAL: 55, partialName: 56, partial_repetition0: 57, partial_option0: 58, openPartialBlock: 59, OPEN_PARTIAL_BLOCK: 60, openPartialBlock_repetition0: 61, openPartialBlock_option0: 62, param: 63, sexpr: 64, OPEN_SEXPR: 65, sexpr_repetition0: 66, sexpr_option0: 67, CLOSE_SEXPR: 68, hash: 69, hash_repetition_plus0: 70, hashSegment: 71, ID: 72, EQUALS: 73, blockParams: 74, OPEN_BLOCK_PARAMS: 75, blockParams_repetition_plus0: 76, CLOSE_BLOCK_PARAMS: 77, path: 78, dataName: 79, STRING: 80, NUMBER: 81, BOOLEAN: 82, UNDEFINED: 83, NULL: 84, DATA: 85, pathSegments: 86, SEP: 87, $accept: 0, $end: 1 }, terminals_: { 2: "error", 5: "EOF", 14: "COMMENT", 15: "CONTENT", 18: "END_RAW_BLOCK", 19: "OPEN_RAW_BLOCK", 23: "CLOSE_RAW_BLOCK", 29: "OPEN_BLOCK", 33: "CLOSE", 34: "OPEN_INVERSE", 39: "OPEN_INVERSE_CHAIN", 44: "INVERSE", 47: "OPEN_ENDBLOCK", 48: "OPEN", 51: "OPEN_UNESCAPED", 54: "CLOSE_UNESCAPED", 55: "OPEN_PARTIAL", 60: "OPEN_PARTIAL_BLOCK", 65: "OPEN_SEXPR", 68: "CLOSE_SEXPR", 72: "ID", 73: "EQUALS", 75: "OPEN_BLOCK_PARAMS", 77: "CLOSE_BLOCK_PARAMS", 80: "STRING", 81: "NUMBER", 82: "BOOLEAN", 83: "UNDEFINED", 84: "NULL", 85: "DATA", 87: "SEP" }, productions_: [0, [3, 2], [4, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [13, 1], [10, 3], [16, 5], [9, 4], [9, 4], [24, 6], [27, 6], [38, 6], [43, 2], [45, 3], [45, 1], [26, 3], [8, 5], [8, 5], [11, 5], [12, 3], [59, 5], [63, 1], [63, 1], [64, 5], [69, 1], [71, 3], [74, 3], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [56, 1], [56, 1], [79, 2], [78, 1], [86, 3], [86, 1], [6, 0], [6, 2], [17, 0], [17, 2], [21, 0], [21, 2], [22, 0], [22, 1], [25, 0], [25, 1], [28, 0], [28, 1], [30, 0], [30, 2], [31, 0], [31, 1], [32, 0], [32, 1], [35, 0], [35, 2], [36, 0], [36, 1], [37, 0], [37, 1], [40, 0], [40, 2], [41, 0], [41, 1], [42, 0], [42, 1], [46, 0], [46, 1], [49, 0], [49, 2], [50, 0], [50, 1], [52, 0], [52, 2], [53, 0], [53, 1], [57, 0], [57, 2], [58, 0], [58, 1], [61, 0], [61, 2], [62, 0], [62, 1], [66, 0], [66, 2], [67, 0], [67, 1], [70, 1], [70, 2], [76, 1], [76, 2]], performAction: /* @__PURE__ */ __name(function(_, Y, O, z, J, T, X) {
      var f = T.length - 1;
      switch (J) {
        case 1:
          return T[f - 1];
        case 2:
          this.$ = z.prepareProgram(T[f]);
          break;
        case 3:
          this.$ = T[f];
          break;
        case 4:
          this.$ = T[f];
          break;
        case 5:
          this.$ = T[f];
          break;
        case 6:
          this.$ = T[f];
          break;
        case 7:
          this.$ = T[f];
          break;
        case 8:
          this.$ = T[f];
          break;
        case 9:
          this.$ = { type: "CommentStatement", value: z.stripComment(T[f]), strip: z.stripFlags(T[f], T[f]), loc: z.locInfo(this._$) };
          break;
        case 10:
          this.$ = { type: "ContentStatement", original: T[f], value: T[f], loc: z.locInfo(this._$) };
          break;
        case 11:
          this.$ = z.prepareRawBlock(T[f - 2], T[f - 1], T[f], this._$);
          break;
        case 12:
          this.$ = { path: T[f - 3], params: T[f - 2], hash: T[f - 1] };
          break;
        case 13:
          this.$ = z.prepareBlock(T[f - 3], T[f - 2], T[f - 1], T[f], false, this._$);
          break;
        case 14:
          this.$ = z.prepareBlock(T[f - 3], T[f - 2], T[f - 1], T[f], true, this._$);
          break;
        case 15:
          this.$ = { open: T[f - 5], path: T[f - 4], params: T[f - 3], hash: T[f - 2], blockParams: T[f - 1], strip: z.stripFlags(T[f - 5], T[f]) };
          break;
        case 16:
          this.$ = { path: T[f - 4], params: T[f - 3], hash: T[f - 2], blockParams: T[f - 1], strip: z.stripFlags(T[f - 5], T[f]) };
          break;
        case 17:
          this.$ = { path: T[f - 4], params: T[f - 3], hash: T[f - 2], blockParams: T[f - 1], strip: z.stripFlags(T[f - 5], T[f]) };
          break;
        case 18:
          this.$ = { strip: z.stripFlags(T[f - 1], T[f - 1]), program: T[f] };
          break;
        case 19:
          var V = z.prepareBlock(T[f - 2], T[f - 1], T[f], T[f], false, this._$), M = z.prepareProgram([V], T[f - 1].loc);
          M.chained = true, this.$ = { strip: T[f - 2].strip, program: M, chain: true };
          break;
        case 20:
          this.$ = T[f];
          break;
        case 21:
          this.$ = { path: T[f - 1], strip: z.stripFlags(T[f - 2], T[f]) };
          break;
        case 22:
          this.$ = z.prepareMustache(T[f - 3], T[f - 2], T[f - 1], T[f - 4], z.stripFlags(T[f - 4], T[f]), this._$);
          break;
        case 23:
          this.$ = z.prepareMustache(T[f - 3], T[f - 2], T[f - 1], T[f - 4], z.stripFlags(T[f - 4], T[f]), this._$);
          break;
        case 24:
          this.$ = { type: "PartialStatement", name: T[f - 3], params: T[f - 2], hash: T[f - 1], indent: "", strip: z.stripFlags(T[f - 4], T[f]), loc: z.locInfo(this._$) };
          break;
        case 25:
          this.$ = z.preparePartialBlock(T[f - 2], T[f - 1], T[f], this._$);
          break;
        case 26:
          this.$ = { path: T[f - 3], params: T[f - 2], hash: T[f - 1], strip: z.stripFlags(T[f - 4], T[f]) };
          break;
        case 27:
          this.$ = T[f];
          break;
        case 28:
          this.$ = T[f];
          break;
        case 29:
          this.$ = { type: "SubExpression", path: T[f - 3], params: T[f - 2], hash: T[f - 1], loc: z.locInfo(this._$) };
          break;
        case 30:
          this.$ = { type: "Hash", pairs: T[f], loc: z.locInfo(this._$) };
          break;
        case 31:
          this.$ = { type: "HashPair", key: z.id(T[f - 2]), value: T[f], loc: z.locInfo(this._$) };
          break;
        case 32:
          this.$ = z.id(T[f - 1]);
          break;
        case 33:
          this.$ = T[f];
          break;
        case 34:
          this.$ = T[f];
          break;
        case 35:
          this.$ = { type: "StringLiteral", value: T[f], original: T[f], loc: z.locInfo(this._$) };
          break;
        case 36:
          this.$ = { type: "NumberLiteral", value: Number(T[f]), original: Number(T[f]), loc: z.locInfo(this._$) };
          break;
        case 37:
          this.$ = { type: "BooleanLiteral", value: T[f] === "true", original: T[f] === "true", loc: z.locInfo(this._$) };
          break;
        case 38:
          this.$ = { type: "UndefinedLiteral", original: void 0, value: void 0, loc: z.locInfo(this._$) };
          break;
        case 39:
          this.$ = { type: "NullLiteral", original: null, value: null, loc: z.locInfo(this._$) };
          break;
        case 40:
          this.$ = T[f];
          break;
        case 41:
          this.$ = T[f];
          break;
        case 42:
          this.$ = z.preparePath(true, T[f], this._$);
          break;
        case 43:
          this.$ = z.preparePath(false, T[f], this._$);
          break;
        case 44:
          T[f - 2].push({ part: z.id(T[f]), original: T[f], separator: T[f - 1] }), this.$ = T[f - 2];
          break;
        case 45:
          this.$ = [{ part: z.id(T[f]), original: T[f] }];
          break;
        case 46:
          this.$ = [];
          break;
        case 47:
          T[f - 1].push(T[f]);
          break;
        case 48:
          this.$ = [];
          break;
        case 49:
          T[f - 1].push(T[f]);
          break;
        case 50:
          this.$ = [];
          break;
        case 51:
          T[f - 1].push(T[f]);
          break;
        case 58:
          this.$ = [];
          break;
        case 59:
          T[f - 1].push(T[f]);
          break;
        case 64:
          this.$ = [];
          break;
        case 65:
          T[f - 1].push(T[f]);
          break;
        case 70:
          this.$ = [];
          break;
        case 71:
          T[f - 1].push(T[f]);
          break;
        case 78:
          this.$ = [];
          break;
        case 79:
          T[f - 1].push(T[f]);
          break;
        case 82:
          this.$ = [];
          break;
        case 83:
          T[f - 1].push(T[f]);
          break;
        case 86:
          this.$ = [];
          break;
        case 87:
          T[f - 1].push(T[f]);
          break;
        case 90:
          this.$ = [];
          break;
        case 91:
          T[f - 1].push(T[f]);
          break;
        case 94:
          this.$ = [];
          break;
        case 95:
          T[f - 1].push(T[f]);
          break;
        case 98:
          this.$ = [T[f]];
          break;
        case 99:
          T[f - 1].push(T[f]);
          break;
        case 100:
          this.$ = [T[f]];
          break;
        case 101:
          T[f - 1].push(T[f]);
          break;
      }
    }, "performAction"), table: [{ 3: 1, 4: 2, 5: [2, 46], 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 1: [3] }, { 5: [1, 4] }, { 5: [2, 2], 7: 5, 8: 6, 9: 7, 10: 8, 11: 9, 12: 10, 13: 11, 14: [1, 12], 15: [1, 20], 16: 17, 19: [1, 23], 24: 15, 27: 16, 29: [1, 21], 34: [1, 22], 39: [2, 2], 44: [2, 2], 47: [2, 2], 48: [1, 13], 51: [1, 14], 55: [1, 18], 59: 19, 60: [1, 24] }, { 1: [2, 1] }, { 5: [2, 47], 14: [2, 47], 15: [2, 47], 19: [2, 47], 29: [2, 47], 34: [2, 47], 39: [2, 47], 44: [2, 47], 47: [2, 47], 48: [2, 47], 51: [2, 47], 55: [2, 47], 60: [2, 47] }, { 5: [2, 3], 14: [2, 3], 15: [2, 3], 19: [2, 3], 29: [2, 3], 34: [2, 3], 39: [2, 3], 44: [2, 3], 47: [2, 3], 48: [2, 3], 51: [2, 3], 55: [2, 3], 60: [2, 3] }, { 5: [2, 4], 14: [2, 4], 15: [2, 4], 19: [2, 4], 29: [2, 4], 34: [2, 4], 39: [2, 4], 44: [2, 4], 47: [2, 4], 48: [2, 4], 51: [2, 4], 55: [2, 4], 60: [2, 4] }, { 5: [2, 5], 14: [2, 5], 15: [2, 5], 19: [2, 5], 29: [2, 5], 34: [2, 5], 39: [2, 5], 44: [2, 5], 47: [2, 5], 48: [2, 5], 51: [2, 5], 55: [2, 5], 60: [2, 5] }, { 5: [2, 6], 14: [2, 6], 15: [2, 6], 19: [2, 6], 29: [2, 6], 34: [2, 6], 39: [2, 6], 44: [2, 6], 47: [2, 6], 48: [2, 6], 51: [2, 6], 55: [2, 6], 60: [2, 6] }, { 5: [2, 7], 14: [2, 7], 15: [2, 7], 19: [2, 7], 29: [2, 7], 34: [2, 7], 39: [2, 7], 44: [2, 7], 47: [2, 7], 48: [2, 7], 51: [2, 7], 55: [2, 7], 60: [2, 7] }, { 5: [2, 8], 14: [2, 8], 15: [2, 8], 19: [2, 8], 29: [2, 8], 34: [2, 8], 39: [2, 8], 44: [2, 8], 47: [2, 8], 48: [2, 8], 51: [2, 8], 55: [2, 8], 60: [2, 8] }, { 5: [2, 9], 14: [2, 9], 15: [2, 9], 19: [2, 9], 29: [2, 9], 34: [2, 9], 39: [2, 9], 44: [2, 9], 47: [2, 9], 48: [2, 9], 51: [2, 9], 55: [2, 9], 60: [2, 9] }, { 20: 25, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 36, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 4: 37, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 39: [2, 46], 44: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 4: 38, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 44: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 15: [2, 48], 17: 39, 18: [2, 48] }, { 20: 41, 56: 40, 64: 42, 65: [1, 43], 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 4: 44, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 5: [2, 10], 14: [2, 10], 15: [2, 10], 18: [2, 10], 19: [2, 10], 29: [2, 10], 34: [2, 10], 39: [2, 10], 44: [2, 10], 47: [2, 10], 48: [2, 10], 51: [2, 10], 55: [2, 10], 60: [2, 10] }, { 20: 45, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 46, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 47, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 41, 56: 48, 64: 42, 65: [1, 43], 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 33: [2, 78], 49: 49, 65: [2, 78], 72: [2, 78], 80: [2, 78], 81: [2, 78], 82: [2, 78], 83: [2, 78], 84: [2, 78], 85: [2, 78] }, { 23: [2, 33], 33: [2, 33], 54: [2, 33], 65: [2, 33], 68: [2, 33], 72: [2, 33], 75: [2, 33], 80: [2, 33], 81: [2, 33], 82: [2, 33], 83: [2, 33], 84: [2, 33], 85: [2, 33] }, { 23: [2, 34], 33: [2, 34], 54: [2, 34], 65: [2, 34], 68: [2, 34], 72: [2, 34], 75: [2, 34], 80: [2, 34], 81: [2, 34], 82: [2, 34], 83: [2, 34], 84: [2, 34], 85: [2, 34] }, { 23: [2, 35], 33: [2, 35], 54: [2, 35], 65: [2, 35], 68: [2, 35], 72: [2, 35], 75: [2, 35], 80: [2, 35], 81: [2, 35], 82: [2, 35], 83: [2, 35], 84: [2, 35], 85: [2, 35] }, { 23: [2, 36], 33: [2, 36], 54: [2, 36], 65: [2, 36], 68: [2, 36], 72: [2, 36], 75: [2, 36], 80: [2, 36], 81: [2, 36], 82: [2, 36], 83: [2, 36], 84: [2, 36], 85: [2, 36] }, { 23: [2, 37], 33: [2, 37], 54: [2, 37], 65: [2, 37], 68: [2, 37], 72: [2, 37], 75: [2, 37], 80: [2, 37], 81: [2, 37], 82: [2, 37], 83: [2, 37], 84: [2, 37], 85: [2, 37] }, { 23: [2, 38], 33: [2, 38], 54: [2, 38], 65: [2, 38], 68: [2, 38], 72: [2, 38], 75: [2, 38], 80: [2, 38], 81: [2, 38], 82: [2, 38], 83: [2, 38], 84: [2, 38], 85: [2, 38] }, { 23: [2, 39], 33: [2, 39], 54: [2, 39], 65: [2, 39], 68: [2, 39], 72: [2, 39], 75: [2, 39], 80: [2, 39], 81: [2, 39], 82: [2, 39], 83: [2, 39], 84: [2, 39], 85: [2, 39] }, { 23: [2, 43], 33: [2, 43], 54: [2, 43], 65: [2, 43], 68: [2, 43], 72: [2, 43], 75: [2, 43], 80: [2, 43], 81: [2, 43], 82: [2, 43], 83: [2, 43], 84: [2, 43], 85: [2, 43], 87: [1, 50] }, { 72: [1, 35], 86: 51 }, { 23: [2, 45], 33: [2, 45], 54: [2, 45], 65: [2, 45], 68: [2, 45], 72: [2, 45], 75: [2, 45], 80: [2, 45], 81: [2, 45], 82: [2, 45], 83: [2, 45], 84: [2, 45], 85: [2, 45], 87: [2, 45] }, { 52: 52, 54: [2, 82], 65: [2, 82], 72: [2, 82], 80: [2, 82], 81: [2, 82], 82: [2, 82], 83: [2, 82], 84: [2, 82], 85: [2, 82] }, { 25: 53, 38: 55, 39: [1, 57], 43: 56, 44: [1, 58], 45: 54, 47: [2, 54] }, { 28: 59, 43: 60, 44: [1, 58], 47: [2, 56] }, { 13: 62, 15: [1, 20], 18: [1, 61] }, { 33: [2, 86], 57: 63, 65: [2, 86], 72: [2, 86], 80: [2, 86], 81: [2, 86], 82: [2, 86], 83: [2, 86], 84: [2, 86], 85: [2, 86] }, { 33: [2, 40], 65: [2, 40], 72: [2, 40], 80: [2, 40], 81: [2, 40], 82: [2, 40], 83: [2, 40], 84: [2, 40], 85: [2, 40] }, { 33: [2, 41], 65: [2, 41], 72: [2, 41], 80: [2, 41], 81: [2, 41], 82: [2, 41], 83: [2, 41], 84: [2, 41], 85: [2, 41] }, { 20: 64, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 26: 65, 47: [1, 66] }, { 30: 67, 33: [2, 58], 65: [2, 58], 72: [2, 58], 75: [2, 58], 80: [2, 58], 81: [2, 58], 82: [2, 58], 83: [2, 58], 84: [2, 58], 85: [2, 58] }, { 33: [2, 64], 35: 68, 65: [2, 64], 72: [2, 64], 75: [2, 64], 80: [2, 64], 81: [2, 64], 82: [2, 64], 83: [2, 64], 84: [2, 64], 85: [2, 64] }, { 21: 69, 23: [2, 50], 65: [2, 50], 72: [2, 50], 80: [2, 50], 81: [2, 50], 82: [2, 50], 83: [2, 50], 84: [2, 50], 85: [2, 50] }, { 33: [2, 90], 61: 70, 65: [2, 90], 72: [2, 90], 80: [2, 90], 81: [2, 90], 82: [2, 90], 83: [2, 90], 84: [2, 90], 85: [2, 90] }, { 20: 74, 33: [2, 80], 50: 71, 63: 72, 64: 75, 65: [1, 43], 69: 73, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 72: [1, 79] }, { 23: [2, 42], 33: [2, 42], 54: [2, 42], 65: [2, 42], 68: [2, 42], 72: [2, 42], 75: [2, 42], 80: [2, 42], 81: [2, 42], 82: [2, 42], 83: [2, 42], 84: [2, 42], 85: [2, 42], 87: [1, 50] }, { 20: 74, 53: 80, 54: [2, 84], 63: 81, 64: 75, 65: [1, 43], 69: 82, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 26: 83, 47: [1, 66] }, { 47: [2, 55] }, { 4: 84, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 39: [2, 46], 44: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 47: [2, 20] }, { 20: 85, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 4: 86, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 26: 87, 47: [1, 66] }, { 47: [2, 57] }, { 5: [2, 11], 14: [2, 11], 15: [2, 11], 19: [2, 11], 29: [2, 11], 34: [2, 11], 39: [2, 11], 44: [2, 11], 47: [2, 11], 48: [2, 11], 51: [2, 11], 55: [2, 11], 60: [2, 11] }, { 15: [2, 49], 18: [2, 49] }, { 20: 74, 33: [2, 88], 58: 88, 63: 89, 64: 75, 65: [1, 43], 69: 90, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 65: [2, 94], 66: 91, 68: [2, 94], 72: [2, 94], 80: [2, 94], 81: [2, 94], 82: [2, 94], 83: [2, 94], 84: [2, 94], 85: [2, 94] }, { 5: [2, 25], 14: [2, 25], 15: [2, 25], 19: [2, 25], 29: [2, 25], 34: [2, 25], 39: [2, 25], 44: [2, 25], 47: [2, 25], 48: [2, 25], 51: [2, 25], 55: [2, 25], 60: [2, 25] }, { 20: 92, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 74, 31: 93, 33: [2, 60], 63: 94, 64: 75, 65: [1, 43], 69: 95, 70: 76, 71: 77, 72: [1, 78], 75: [2, 60], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 74, 33: [2, 66], 36: 96, 63: 97, 64: 75, 65: [1, 43], 69: 98, 70: 76, 71: 77, 72: [1, 78], 75: [2, 66], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 74, 22: 99, 23: [2, 52], 63: 100, 64: 75, 65: [1, 43], 69: 101, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 74, 33: [2, 92], 62: 102, 63: 103, 64: 75, 65: [1, 43], 69: 104, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 33: [1, 105] }, { 33: [2, 79], 65: [2, 79], 72: [2, 79], 80: [2, 79], 81: [2, 79], 82: [2, 79], 83: [2, 79], 84: [2, 79], 85: [2, 79] }, { 33: [2, 81] }, { 23: [2, 27], 33: [2, 27], 54: [2, 27], 65: [2, 27], 68: [2, 27], 72: [2, 27], 75: [2, 27], 80: [2, 27], 81: [2, 27], 82: [2, 27], 83: [2, 27], 84: [2, 27], 85: [2, 27] }, { 23: [2, 28], 33: [2, 28], 54: [2, 28], 65: [2, 28], 68: [2, 28], 72: [2, 28], 75: [2, 28], 80: [2, 28], 81: [2, 28], 82: [2, 28], 83: [2, 28], 84: [2, 28], 85: [2, 28] }, { 23: [2, 30], 33: [2, 30], 54: [2, 30], 68: [2, 30], 71: 106, 72: [1, 107], 75: [2, 30] }, { 23: [2, 98], 33: [2, 98], 54: [2, 98], 68: [2, 98], 72: [2, 98], 75: [2, 98] }, { 23: [2, 45], 33: [2, 45], 54: [2, 45], 65: [2, 45], 68: [2, 45], 72: [2, 45], 73: [1, 108], 75: [2, 45], 80: [2, 45], 81: [2, 45], 82: [2, 45], 83: [2, 45], 84: [2, 45], 85: [2, 45], 87: [2, 45] }, { 23: [2, 44], 33: [2, 44], 54: [2, 44], 65: [2, 44], 68: [2, 44], 72: [2, 44], 75: [2, 44], 80: [2, 44], 81: [2, 44], 82: [2, 44], 83: [2, 44], 84: [2, 44], 85: [2, 44], 87: [2, 44] }, { 54: [1, 109] }, { 54: [2, 83], 65: [2, 83], 72: [2, 83], 80: [2, 83], 81: [2, 83], 82: [2, 83], 83: [2, 83], 84: [2, 83], 85: [2, 83] }, { 54: [2, 85] }, { 5: [2, 13], 14: [2, 13], 15: [2, 13], 19: [2, 13], 29: [2, 13], 34: [2, 13], 39: [2, 13], 44: [2, 13], 47: [2, 13], 48: [2, 13], 51: [2, 13], 55: [2, 13], 60: [2, 13] }, { 38: 55, 39: [1, 57], 43: 56, 44: [1, 58], 45: 111, 46: 110, 47: [2, 76] }, { 33: [2, 70], 40: 112, 65: [2, 70], 72: [2, 70], 75: [2, 70], 80: [2, 70], 81: [2, 70], 82: [2, 70], 83: [2, 70], 84: [2, 70], 85: [2, 70] }, { 47: [2, 18] }, { 5: [2, 14], 14: [2, 14], 15: [2, 14], 19: [2, 14], 29: [2, 14], 34: [2, 14], 39: [2, 14], 44: [2, 14], 47: [2, 14], 48: [2, 14], 51: [2, 14], 55: [2, 14], 60: [2, 14] }, { 33: [1, 113] }, { 33: [2, 87], 65: [2, 87], 72: [2, 87], 80: [2, 87], 81: [2, 87], 82: [2, 87], 83: [2, 87], 84: [2, 87], 85: [2, 87] }, { 33: [2, 89] }, { 20: 74, 63: 115, 64: 75, 65: [1, 43], 67: 114, 68: [2, 96], 69: 116, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 33: [1, 117] }, { 32: 118, 33: [2, 62], 74: 119, 75: [1, 120] }, { 33: [2, 59], 65: [2, 59], 72: [2, 59], 75: [2, 59], 80: [2, 59], 81: [2, 59], 82: [2, 59], 83: [2, 59], 84: [2, 59], 85: [2, 59] }, { 33: [2, 61], 75: [2, 61] }, { 33: [2, 68], 37: 121, 74: 122, 75: [1, 120] }, { 33: [2, 65], 65: [2, 65], 72: [2, 65], 75: [2, 65], 80: [2, 65], 81: [2, 65], 82: [2, 65], 83: [2, 65], 84: [2, 65], 85: [2, 65] }, { 33: [2, 67], 75: [2, 67] }, { 23: [1, 123] }, { 23: [2, 51], 65: [2, 51], 72: [2, 51], 80: [2, 51], 81: [2, 51], 82: [2, 51], 83: [2, 51], 84: [2, 51], 85: [2, 51] }, { 23: [2, 53] }, { 33: [1, 124] }, { 33: [2, 91], 65: [2, 91], 72: [2, 91], 80: [2, 91], 81: [2, 91], 82: [2, 91], 83: [2, 91], 84: [2, 91], 85: [2, 91] }, { 33: [2, 93] }, { 5: [2, 22], 14: [2, 22], 15: [2, 22], 19: [2, 22], 29: [2, 22], 34: [2, 22], 39: [2, 22], 44: [2, 22], 47: [2, 22], 48: [2, 22], 51: [2, 22], 55: [2, 22], 60: [2, 22] }, { 23: [2, 99], 33: [2, 99], 54: [2, 99], 68: [2, 99], 72: [2, 99], 75: [2, 99] }, { 73: [1, 108] }, { 20: 74, 63: 125, 64: 75, 65: [1, 43], 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 5: [2, 23], 14: [2, 23], 15: [2, 23], 19: [2, 23], 29: [2, 23], 34: [2, 23], 39: [2, 23], 44: [2, 23], 47: [2, 23], 48: [2, 23], 51: [2, 23], 55: [2, 23], 60: [2, 23] }, { 47: [2, 19] }, { 47: [2, 77] }, { 20: 74, 33: [2, 72], 41: 126, 63: 127, 64: 75, 65: [1, 43], 69: 128, 70: 76, 71: 77, 72: [1, 78], 75: [2, 72], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 5: [2, 24], 14: [2, 24], 15: [2, 24], 19: [2, 24], 29: [2, 24], 34: [2, 24], 39: [2, 24], 44: [2, 24], 47: [2, 24], 48: [2, 24], 51: [2, 24], 55: [2, 24], 60: [2, 24] }, { 68: [1, 129] }, { 65: [2, 95], 68: [2, 95], 72: [2, 95], 80: [2, 95], 81: [2, 95], 82: [2, 95], 83: [2, 95], 84: [2, 95], 85: [2, 95] }, { 68: [2, 97] }, { 5: [2, 21], 14: [2, 21], 15: [2, 21], 19: [2, 21], 29: [2, 21], 34: [2, 21], 39: [2, 21], 44: [2, 21], 47: [2, 21], 48: [2, 21], 51: [2, 21], 55: [2, 21], 60: [2, 21] }, { 33: [1, 130] }, { 33: [2, 63] }, { 72: [1, 132], 76: 131 }, { 33: [1, 133] }, { 33: [2, 69] }, { 15: [2, 12], 18: [2, 12] }, { 14: [2, 26], 15: [2, 26], 19: [2, 26], 29: [2, 26], 34: [2, 26], 47: [2, 26], 48: [2, 26], 51: [2, 26], 55: [2, 26], 60: [2, 26] }, { 23: [2, 31], 33: [2, 31], 54: [2, 31], 68: [2, 31], 72: [2, 31], 75: [2, 31] }, { 33: [2, 74], 42: 134, 74: 135, 75: [1, 120] }, { 33: [2, 71], 65: [2, 71], 72: [2, 71], 75: [2, 71], 80: [2, 71], 81: [2, 71], 82: [2, 71], 83: [2, 71], 84: [2, 71], 85: [2, 71] }, { 33: [2, 73], 75: [2, 73] }, { 23: [2, 29], 33: [2, 29], 54: [2, 29], 65: [2, 29], 68: [2, 29], 72: [2, 29], 75: [2, 29], 80: [2, 29], 81: [2, 29], 82: [2, 29], 83: [2, 29], 84: [2, 29], 85: [2, 29] }, { 14: [2, 15], 15: [2, 15], 19: [2, 15], 29: [2, 15], 34: [2, 15], 39: [2, 15], 44: [2, 15], 47: [2, 15], 48: [2, 15], 51: [2, 15], 55: [2, 15], 60: [2, 15] }, { 72: [1, 137], 77: [1, 136] }, { 72: [2, 100], 77: [2, 100] }, { 14: [2, 16], 15: [2, 16], 19: [2, 16], 29: [2, 16], 34: [2, 16], 44: [2, 16], 47: [2, 16], 48: [2, 16], 51: [2, 16], 55: [2, 16], 60: [2, 16] }, { 33: [1, 138] }, { 33: [2, 75] }, { 33: [2, 32] }, { 72: [2, 101], 77: [2, 101] }, { 14: [2, 17], 15: [2, 17], 19: [2, 17], 29: [2, 17], 34: [2, 17], 39: [2, 17], 44: [2, 17], 47: [2, 17], 48: [2, 17], 51: [2, 17], 55: [2, 17], 60: [2, 17] }], defaultActions: { 4: [2, 1], 54: [2, 55], 56: [2, 20], 60: [2, 57], 73: [2, 81], 82: [2, 85], 86: [2, 18], 90: [2, 89], 101: [2, 53], 104: [2, 93], 110: [2, 19], 111: [2, 77], 116: [2, 97], 119: [2, 63], 122: [2, 69], 135: [2, 75], 136: [2, 32] }, parseError: /* @__PURE__ */ __name(function(_, Y) {
      throw Error(_);
    }, "parseError"), parse: /* @__PURE__ */ __name(function(_) {
      var Y = this, O = [0], z = [null], J = [], T = this.table, X = "", f = 0, V = 0, M = 0, N = 2, E = 1;
      if (this.lexer.setInput(_), this.lexer.yy = this.yy, this.yy.lexer = this.lexer, this.yy.parser = this, typeof this.lexer.yylloc > "u") this.lexer.yylloc = {};
      var h = this.lexer.yylloc;
      J.push(h);
      var I = this.lexer.options && this.lexer.options.ranges;
      if (typeof this.yy.parseError === "function") this.parseError = this.yy.parseError;
      function D(w) {
        O.length = O.length - 2 * w, z.length = z.length - w, J.length = J.length - w;
      }
      __name(D, "D");
      function g() {
        var w = Y.lexer.lex() || 1;
        if (typeof w !== "number") w = Y.symbols_[w] || w;
        return w;
      }
      __name(g, "g");
      var b, y, p, n, s, q$, c = {}, U, j, H, Z;
      while (true) {
        if (p = O[O.length - 1], this.defaultActions[p]) n = this.defaultActions[p];
        else {
          if (b === null || typeof b > "u") b = g();
          n = T[p] && T[p][b];
        }
        if (typeof n > "u" || !n.length || !n[0]) {
          var W = "";
          if (!M) {
            Z = [];
            for (U in T[p]) if (this.terminals_[U] && U > 2) Z.push("'" + this.terminals_[U] + "'");
            if (this.lexer.showPosition) W = "Parse error on line " + (f + 1) + `:
` + this.lexer.showPosition() + `
Expecting ` + Z.join(", ") + ", got '" + (this.terminals_[b] || b) + "'";
            else W = "Parse error on line " + (f + 1) + ": Unexpected " + (b == 1 ? "end of input" : "'" + (this.terminals_[b] || b) + "'");
            this.parseError(W, { text: this.lexer.match, token: this.terminals_[b] || b, line: this.lexer.yylineno, loc: h, expected: Z });
          }
        }
        if (n[0] instanceof Array && n.length > 1) throw Error("Parse Error: multiple actions possible at state: " + p + ", token: " + b);
        switch (n[0]) {
          case 1:
            if (O.push(b), z.push(this.lexer.yytext), J.push(this.lexer.yylloc), O.push(n[1]), b = null, !y) {
              if (V = this.lexer.yyleng, X = this.lexer.yytext, f = this.lexer.yylineno, h = this.lexer.yylloc, M > 0) M--;
            } else b = y, y = null;
            break;
          case 2:
            if (j = this.productions_[n[1]][1], c.$ = z[z.length - j], c._$ = { first_line: J[J.length - (j || 1)].first_line, last_line: J[J.length - 1].last_line, first_column: J[J.length - (j || 1)].first_column, last_column: J[J.length - 1].last_column }, I) c._$.range = [J[J.length - (j || 1)].range[0], J[J.length - 1].range[1]];
            if (q$ = this.performAction.call(c, X, V, f, this.yy, n[1], z, J), typeof q$ < "u") return q$;
            if (j) O = O.slice(0, -1 * j * 2), z = z.slice(0, -1 * j), J = J.slice(0, -1 * j);
            O.push(this.productions_[n[1]][0]), z.push(c.$), J.push(c._$), H = T[O[O.length - 2]][O[O.length - 1]], O.push(H);
            break;
          case 3:
            return true;
        }
      }
      return true;
    }, "parse") }, q = (function() {
      var P = { EOF: 1, parseError: /* @__PURE__ */ __name(function(Y, O) {
        if (this.yy.parser) this.yy.parser.parseError(Y, O);
        else throw Error(Y);
      }, "parseError"), setInput: /* @__PURE__ */ __name(function(Y) {
        if (this._input = Y, this._more = this._less = this.done = false, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = { first_line: 1, first_column: 0, last_line: 1, last_column: 0 }, this.options.ranges) this.yylloc.range = [0, 0];
        return this.offset = 0, this;
      }, "setInput"), input: /* @__PURE__ */ __name(function() {
        var Y = this._input[0];
        this.yytext += Y, this.yyleng++, this.offset++, this.match += Y, this.matched += Y;
        var O = Y.match(/(?:\r\n?|\n).*/g);
        if (O) this.yylineno++, this.yylloc.last_line++;
        else this.yylloc.last_column++;
        if (this.options.ranges) this.yylloc.range[1]++;
        return this._input = this._input.slice(1), Y;
      }, "input"), unput: /* @__PURE__ */ __name(function(Y) {
        var O = Y.length, z = Y.split(/(?:\r\n?|\n)/g);
        this._input = Y + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - O - 1), this.offset -= O;
        var J = this.match.split(/(?:\r\n?|\n)/g);
        if (this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), z.length - 1) this.yylineno -= z.length - 1;
        var T = this.yylloc.range;
        if (this.yylloc = { first_line: this.yylloc.first_line, last_line: this.yylineno + 1, first_column: this.yylloc.first_column, last_column: z ? (z.length === J.length ? this.yylloc.first_column : 0) + J[J.length - z.length].length - z[0].length : this.yylloc.first_column - O }, this.options.ranges) this.yylloc.range = [T[0], T[0] + this.yyleng - O];
        return this;
      }, "unput"), more: /* @__PURE__ */ __name(function() {
        return this._more = true, this;
      }, "more"), less: /* @__PURE__ */ __name(function(Y) {
        this.unput(this.match.slice(Y));
      }, "less"), pastInput: /* @__PURE__ */ __name(function() {
        var Y = this.matched.substr(0, this.matched.length - this.match.length);
        return (Y.length > 20 ? "..." : "") + Y.substr(-20).replace(/\n/g, "");
      }, "pastInput"), upcomingInput: /* @__PURE__ */ __name(function() {
        var Y = this.match;
        if (Y.length < 20) Y += this._input.substr(0, 20 - Y.length);
        return (Y.substr(0, 20) + (Y.length > 20 ? "..." : "")).replace(/\n/g, "");
      }, "upcomingInput"), showPosition: /* @__PURE__ */ __name(function() {
        var Y = this.pastInput(), O = Array(Y.length + 1).join("-");
        return Y + this.upcomingInput() + `
` + O + "^";
      }, "showPosition"), next: /* @__PURE__ */ __name(function() {
        if (this.done) return this.EOF;
        if (!this._input) this.done = true;
        var Y, O, z, J, T, X;
        if (!this._more) this.yytext = "", this.match = "";
        var f = this._currentRules();
        for (var V = 0; V < f.length; V++) if (z = this._input.match(this.rules[f[V]]), z && (!O || z[0].length > O[0].length)) {
          if (O = z, J = V, !this.options.flex) break;
        }
        if (O) {
          if (X = O[0].match(/(?:\r\n?|\n).*/g), X) this.yylineno += X.length;
          if (this.yylloc = { first_line: this.yylloc.last_line, last_line: this.yylineno + 1, first_column: this.yylloc.last_column, last_column: X ? X[X.length - 1].length - X[X.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + O[0].length }, this.yytext += O[0], this.match += O[0], this.matches = O, this.yyleng = this.yytext.length, this.options.ranges) this.yylloc.range = [this.offset, this.offset += this.yyleng];
          if (this._more = false, this._input = this._input.slice(O[0].length), this.matched += O[0], Y = this.performAction.call(this, this.yy, this, f[J], this.conditionStack[this.conditionStack.length - 1]), this.done && this._input) this.done = false;
          if (Y) return Y;
          else return;
        }
        if (this._input === "") return this.EOF;
        else return this.parseError("Lexical error on line " + (this.yylineno + 1) + `. Unrecognized text.
` + this.showPosition(), { text: "", token: null, line: this.yylineno });
      }, "next"), lex: /* @__PURE__ */ __name(function() {
        var Y = this.next();
        if (typeof Y < "u") return Y;
        else return this.lex();
      }, "lex"), begin: /* @__PURE__ */ __name(function(Y) {
        this.conditionStack.push(Y);
      }, "begin"), popState: /* @__PURE__ */ __name(function() {
        return this.conditionStack.pop();
      }, "popState"), _currentRules: /* @__PURE__ */ __name(function() {
        return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
      }, "_currentRules"), topState: /* @__PURE__ */ __name(function() {
        return this.conditionStack[this.conditionStack.length - 2];
      }, "topState"), pushState: /* @__PURE__ */ __name(function(Y) {
        this.begin(Y);
      }, "pushState") };
      return P.options = {}, P.performAction = function(Y, O, z, J) {
        function T(f, V) {
          return O.yytext = O.yytext.substring(f, O.yyleng - V + f);
        }
        __name(T, "T");
        var X = J;
        switch (z) {
          case 0:
            if (O.yytext.slice(-2) === "\\\\") T(0, 1), this.begin("mu");
            else if (O.yytext.slice(-1) === "\\") T(0, 1), this.begin("emu");
            else this.begin("mu");
            if (O.yytext) return 15;
            break;
          case 1:
            return 15;
          case 2:
            return this.popState(), 15;
            break;
          case 3:
            return this.begin("raw"), 15;
            break;
          case 4:
            if (this.popState(), this.conditionStack[this.conditionStack.length - 1] === "raw") return 15;
            else return T(5, 9), "END_RAW_BLOCK";
            break;
          case 5:
            return 15;
          case 6:
            return this.popState(), 14;
            break;
          case 7:
            return 65;
          case 8:
            return 68;
          case 9:
            return 19;
          case 10:
            return this.popState(), this.begin("raw"), 23;
            break;
          case 11:
            return 55;
          case 12:
            return 60;
          case 13:
            return 29;
          case 14:
            return 47;
          case 15:
            return this.popState(), 44;
            break;
          case 16:
            return this.popState(), 44;
            break;
          case 17:
            return 34;
          case 18:
            return 39;
          case 19:
            return 51;
          case 20:
            return 48;
          case 21:
            this.unput(O.yytext), this.popState(), this.begin("com");
            break;
          case 22:
            return this.popState(), 14;
            break;
          case 23:
            return 48;
          case 24:
            return 73;
          case 25:
            return 72;
          case 26:
            return 72;
          case 27:
            return 87;
          case 28:
            break;
          case 29:
            return this.popState(), 54;
            break;
          case 30:
            return this.popState(), 33;
            break;
          case 31:
            return O.yytext = T(1, 2).replace(/\\"/g, '"'), 80;
            break;
          case 32:
            return O.yytext = T(1, 2).replace(/\\'/g, "'"), 80;
            break;
          case 33:
            return 85;
          case 34:
            return 82;
          case 35:
            return 82;
          case 36:
            return 83;
          case 37:
            return 84;
          case 38:
            return 81;
          case 39:
            return 75;
          case 40:
            return 77;
          case 41:
            return 72;
          case 42:
            return O.yytext = O.yytext.replace(/\\([\\\]])/g, "$1"), 72;
            break;
          case 43:
            return "INVALID";
          case 44:
            return 5;
        }
      }, P.rules = [/^(?:[^\x00]*?(?=(\{\{)))/, /^(?:[^\x00]+)/, /^(?:[^\x00]{2,}?(?=(\{\{|\\\{\{|\\\\\{\{|$)))/, /^(?:\{\{\{\{(?=[^/]))/, /^(?:\{\{\{\{\/[^\s!"#%-,\.\/;->@\[-\^`\{-~]+(?=[=}\s\/.])\}\}\}\})/, /^(?:[^\x00]+?(?=(\{\{\{\{)))/, /^(?:[\s\S]*?--(~)?\}\})/, /^(?:\()/, /^(?:\))/, /^(?:\{\{\{\{)/, /^(?:\}\}\}\})/, /^(?:\{\{(~)?>)/, /^(?:\{\{(~)?#>)/, /^(?:\{\{(~)?#\*?)/, /^(?:\{\{(~)?\/)/, /^(?:\{\{(~)?\^\s*(~)?\}\})/, /^(?:\{\{(~)?\s*else\s*(~)?\}\})/, /^(?:\{\{(~)?\^)/, /^(?:\{\{(~)?\s*else\b)/, /^(?:\{\{(~)?\{)/, /^(?:\{\{(~)?&)/, /^(?:\{\{(~)?!--)/, /^(?:\{\{(~)?![\s\S]*?\}\})/, /^(?:\{\{(~)?\*?)/, /^(?:=)/, /^(?:\.\.)/, /^(?:\.(?=([=~}\s\/.)|])))/, /^(?:[\/.])/, /^(?:\s+)/, /^(?:\}(~)?\}\})/, /^(?:(~)?\}\})/, /^(?:"(\\["]|[^"])*")/, /^(?:'(\\[']|[^'])*')/, /^(?:@)/, /^(?:true(?=([~}\s)])))/, /^(?:false(?=([~}\s)])))/, /^(?:undefined(?=([~}\s)])))/, /^(?:null(?=([~}\s)])))/, /^(?:-?[0-9]+(?:\.[0-9]+)?(?=([~}\s)])))/, /^(?:as\s+\|)/, /^(?:\|)/, /^(?:([^\s!"#%-,\.\/;->@\[-\^`\{-~]+(?=([=~}\s\/.)|]))))/, /^(?:\[(\\\]|[^\]])*\])/, /^(?:.)/, /^(?:$)/], P.conditions = { mu: { rules: [7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44], inclusive: false }, emu: { rules: [2], inclusive: false }, com: { rules: [6], inclusive: false }, raw: { rules: [3, 4, 5], inclusive: false }, INITIAL: { rules: [0, 1, 44], inclusive: true } }, P;
    })();
    $.lexer = q;
    function K() {
      this.yy = {};
    }
    __name(K, "K");
    return K.prototype = $, $.Parser = K, new K();
  })();
  Bk.default = _p;
  Uk.exports = Bk.default;
});
var h5 = x$((ek, sk) => {
  ek.__esModule = true;
  function Yp($) {
    return $ && $.__esModule ? $ : { default: $ };
  }
  __name(Yp, "Yp");
  var jp = G8(), tz = Yp(jp);
  function N5() {
    this.parents = [];
  }
  __name(N5, "N5");
  N5.prototype = { constructor: N5, mutating: false, acceptKey: /* @__PURE__ */ __name(function(q, K) {
    var P = this.accept(q[K]);
    if (this.mutating) {
      if (P && !N5.prototype[P.type]) throw new tz.default('Unexpected node type "' + P.type + '" found when accepting ' + K + " on " + q.type);
      q[K] = P;
    }
  }, "acceptKey"), acceptRequired: /* @__PURE__ */ __name(function(q, K) {
    if (this.acceptKey(q, K), !q[K]) throw new tz.default(q.type + " requires " + K);
  }, "acceptRequired"), acceptArray: /* @__PURE__ */ __name(function(q) {
    for (var K = 0, P = q.length; K < P; K++) if (this.acceptKey(q, K), !q[K]) q.splice(K, 1), K--, P--;
  }, "acceptArray"), accept: /* @__PURE__ */ __name(function(q) {
    if (!q) return;
    if (!this[q.type]) throw new tz.default("Unknown type: " + q.type, q);
    if (this.current) this.parents.unshift(this.current);
    this.current = q;
    var K = this[q.type](q);
    if (this.current = this.parents.shift(), !this.mutating || K) return K;
    else if (K !== false) return q;
  }, "accept"), Program: /* @__PURE__ */ __name(function(q) {
    this.acceptArray(q.body);
  }, "Program"), MustacheStatement: C5, Decorator: C5, BlockStatement: ak, DecoratorBlock: ak, PartialStatement: Qk, PartialBlockStatement: /* @__PURE__ */ __name(function(q) {
    Qk.call(this, q), this.acceptKey(q, "program");
  }, "PartialBlockStatement"), ContentStatement: /* @__PURE__ */ __name(function() {
  }, "ContentStatement"), CommentStatement: /* @__PURE__ */ __name(function() {
  }, "CommentStatement"), SubExpression: C5, PathExpression: /* @__PURE__ */ __name(function() {
  }, "PathExpression"), StringLiteral: /* @__PURE__ */ __name(function() {
  }, "StringLiteral"), NumberLiteral: /* @__PURE__ */ __name(function() {
  }, "NumberLiteral"), BooleanLiteral: /* @__PURE__ */ __name(function() {
  }, "BooleanLiteral"), UndefinedLiteral: /* @__PURE__ */ __name(function() {
  }, "UndefinedLiteral"), NullLiteral: /* @__PURE__ */ __name(function() {
  }, "NullLiteral"), Hash: /* @__PURE__ */ __name(function(q) {
    this.acceptArray(q.pairs);
  }, "Hash"), HashPair: /* @__PURE__ */ __name(function(q) {
    this.acceptRequired(q, "value");
  }, "HashPair") };
  function C5($) {
    this.acceptRequired($, "path"), this.acceptArray($.params), this.acceptKey($, "hash");
  }
  __name(C5, "C5");
  function ak($) {
    C5.call(this, $), this.acceptKey($, "program"), this.acceptKey($, "inverse");
  }
  __name(ak, "ak");
  function Qk($) {
    this.acceptRequired($, "name"), this.acceptArray($.params), this.acceptKey($, "hash");
  }
  __name(Qk, "Qk");
  ek.default = N5;
  sk.exports = ek.default;
});
var KG = x$(($G, qG) => {
  $G.__esModule = true;
  function Wp($) {
    return $ && $.__esModule ? $ : { default: $ };
  }
  __name(Wp, "Wp");
  var Hp = h5(), Jp = Wp(Hp);
  function Q8() {
    var $ = arguments.length <= 0 || arguments[0] === void 0 ? {} : arguments[0];
    this.options = $;
  }
  __name(Q8, "Q8");
  Q8.prototype = new Jp.default();
  Q8.prototype.Program = function($) {
    var q = !this.options.ignoreStandalone, K = !this.isRootSeen;
    this.isRootSeen = true;
    var P = $.body;
    for (var _ = 0, Y = P.length; _ < Y; _++) {
      var O = P[_], z = this.accept(O);
      if (!z) continue;
      var J = Bz(P, _, K), T = Uz(P, _, K), X = z.openStandalone && J, f = z.closeStandalone && T, V = z.inlineStandalone && J && T;
      if (z.close) R_(P, _, true);
      if (z.open) eK(P, _, true);
      if (q && V) {
        if (R_(P, _), eK(P, _)) {
          if (O.type === "PartialStatement") O.indent = /([ \t]+$)/.exec(P[_ - 1].original)[1];
        }
      }
      if (q && X) R_((O.program || O.inverse).body), eK(P, _);
      if (q && f) R_(P, _), eK((O.inverse || O.program).body);
    }
    return $;
  };
  Q8.prototype.BlockStatement = Q8.prototype.DecoratorBlock = Q8.prototype.PartialBlockStatement = function($) {
    this.accept($.program), this.accept($.inverse);
    var q = $.program || $.inverse, K = $.program && $.inverse, P = K, _ = K;
    if (K && K.chained) {
      P = K.body[0].program;
      while (_.chained) _ = _.body[_.body.length - 1].program;
    }
    var Y = { open: $.openStrip.open, close: $.closeStrip.close, openStandalone: Uz(q.body), closeStandalone: Bz((P || q).body) };
    if ($.openStrip.close) R_(q.body, null, true);
    if (K) {
      var O = $.inverseStrip;
      if (O.open) eK(q.body, null, true);
      if (O.close) R_(P.body, null, true);
      if ($.closeStrip.open) eK(_.body, null, true);
      if (!this.options.ignoreStandalone && Bz(q.body) && Uz(P.body)) eK(q.body), R_(P.body);
    } else if ($.closeStrip.open) eK(q.body, null, true);
    return Y;
  };
  Q8.prototype.Decorator = Q8.prototype.MustacheStatement = function($) {
    return $.strip;
  };
  Q8.prototype.PartialStatement = Q8.prototype.CommentStatement = function($) {
    var q = $.strip || {};
    return { inlineStandalone: true, open: q.open, close: q.close };
  };
  function Bz($, q, K) {
    if (q === void 0) q = $.length;
    var P = $[q - 1], _ = $[q - 2];
    if (!P) return K;
    if (P.type === "ContentStatement") return (_ || !K ? /\r?\n\s*?$/ : /(^|\r?\n)\s*?$/).test(P.original);
  }
  __name(Bz, "Bz");
  function Uz($, q, K) {
    if (q === void 0) q = -1;
    var P = $[q + 1], _ = $[q + 2];
    if (!P) return K;
    if (P.type === "ContentStatement") return (_ || !K ? /^\s*?\r?\n/ : /^\s*?(\r?\n|$)/).test(P.original);
  }
  __name(Uz, "Uz");
  function R_($, q, K) {
    var P = $[q == null ? 0 : q + 1];
    if (!P || P.type !== "ContentStatement" || !K && P.rightStripped) return;
    var _ = P.value;
    P.value = P.value.replace(K ? /^\s+/ : /^[ \t]*\r?\n?/, ""), P.rightStripped = P.value !== _;
  }
  __name(R_, "R_");
  function eK($, q, K) {
    var P = $[q == null ? $.length - 1 : q - 1];
    if (!P || P.type !== "ContentStatement" || !K && P.leftStripped) return;
    var _ = P.value;
    return P.value = P.value.replace(K ? /\s+$/ : /[ \t]+$/, ""), P.leftStripped = P.value !== _, P.leftStripped;
  }
  __name(eK, "eK");
  $G.default = Q8;
  qG.exports = $G.default;
});
var _G = x$((Ep) => {
  Ep.__esModule = true;
  Ep.SourceLocation = Xp;
  Ep.id = Ap;
  Ep.stripFlags = kp;
  Ep.stripComment = Gp;
  Ep.preparePath = Vp;
  Ep.prepareMustache = Sp;
  Ep.prepareRawBlock = Mp;
  Ep.prepareBlock = Np;
  Ep.prepareProgram = Cp;
  Ep.preparePartialBlock = hp;
  function fp($) {
    return $ && $.__esModule ? $ : { default: $ };
  }
  __name(fp, "fp");
  var Zp = G8(), Fz = fp(Zp);
  function az($, q) {
    if (q = q.path ? q.path.original : q, $.path.original !== q) {
      var K = { loc: $.path.loc };
      throw new Fz.default($.path.original + " doesn't match " + q, K);
    }
  }
  __name(az, "az");
  function Xp($, q) {
    this.source = $, this.start = { line: q.first_line, column: q.first_column }, this.end = { line: q.last_line, column: q.last_column };
  }
  __name(Xp, "Xp");
  function Ap($) {
    if (/^\[.*\]$/.test($)) return $.substring(1, $.length - 1);
    else return $;
  }
  __name(Ap, "Ap");
  function kp($, q) {
    return { open: $.charAt(2) === "~", close: q.charAt(q.length - 3) === "~" };
  }
  __name(kp, "kp");
  function Gp($) {
    return $.replace(/^\{\{~?!-?-?/, "").replace(/-?-?~?\}\}$/, "");
  }
  __name(Gp, "Gp");
  function Vp($, q, K) {
    K = this.locInfo(K);
    var P = $ ? "@" : "", _ = [], Y = 0;
    for (var O = 0, z = q.length; O < z; O++) {
      var J = q[O].part, T = q[O].original !== J;
      if (P += (q[O].separator || "") + J, !T && (J === ".." || J === "." || J === "this")) {
        if (_.length > 0) throw new Fz.default("Invalid path: " + P, { loc: K });
        else if (J === "..") Y++;
      } else _.push(J);
    }
    return { type: "PathExpression", data: $, depth: Y, parts: _, original: P, loc: K };
  }
  __name(Vp, "Vp");
  function Sp($, q, K, P, _, Y) {
    var O = P.charAt(3) || P.charAt(2), z = O !== "{" && O !== "&", J = /\*/.test(P);
    return { type: J ? "Decorator" : "MustacheStatement", path: $, params: q, hash: K, escaped: z, strip: _, loc: this.locInfo(Y) };
  }
  __name(Sp, "Sp");
  function Mp($, q, K, P) {
    az($, K), P = this.locInfo(P);
    var _ = { type: "Program", body: q, strip: {}, loc: P };
    return { type: "BlockStatement", path: $.path, params: $.params, hash: $.hash, program: _, openStrip: {}, inverseStrip: {}, closeStrip: {}, loc: P };
  }
  __name(Mp, "Mp");
  function Np($, q, K, P, _, Y) {
    if (P && P.path) az($, P);
    var O = /\*/.test($.open);
    q.blockParams = $.blockParams;
    var z = void 0, J = void 0;
    if (K) {
      if (O) throw new Fz.default("Unexpected inverse block on decorator", K);
      if (K.chain) K.program.body[0].closeStrip = P.strip;
      J = K.strip, z = K.program;
    }
    if (_) _ = z, z = q, q = _;
    return { type: O ? "DecoratorBlock" : "BlockStatement", path: $.path, params: $.params, hash: $.hash, program: q, inverse: z, openStrip: $.strip, inverseStrip: J, closeStrip: P && P.strip, loc: this.locInfo(Y) };
  }
  __name(Np, "Np");
  function Cp($, q) {
    if (!q && $.length) {
      var K = $[0].loc, P = $[$.length - 1].loc;
      if (K && P) q = { source: K.source, start: { line: K.start.line, column: K.start.column }, end: { line: P.end.line, column: P.end.column } };
    }
    return { type: "Program", body: $, strip: {}, loc: q };
  }
  __name(Cp, "Cp");
  function hp($, q, K, P) {
    return az($, K), { type: "PartialBlockStatement", name: $.path, params: $.params, hash: $.hash, program: q, openStrip: $.strip, closeStrip: K && K.strip, loc: this.locInfo(P) };
  }
  __name(hp, "hp");
});
var YG = x$((Bp) => {
  Bp.__esModule = true;
  Bp.parseWithoutProcessing = OG;
  Bp.parse = tp;
  function mp($) {
    if ($ && $.__esModule) return $;
    else {
      var q = {};
      if ($ != null) {
        for (var K in $) if (Object.prototype.hasOwnProperty.call($, K)) q[K] = $[K];
      }
      return q.default = $, q;
    }
  }
  __name(mp, "mp");
  function PG($) {
    return $ && $.__esModule ? $ : { default: $ };
  }
  __name(PG, "PG");
  var dp = Fk(), Qz = PG(dp), lp = KG(), rp = PG(lp), op = _G(), np = mp(op), ip = cq();
  Bp.parser = Qz.default;
  var E5 = {};
  ip.extend(E5, np);
  function OG($, q) {
    if ($.type === "Program") return $;
    Qz.default.yy = E5, E5.locInfo = function(P) {
      return new E5.SourceLocation(q && q.srcName, P);
    };
    var K = Qz.default.parse($);
    return K;
  }
  __name(OG, "OG");
  function tp($, q) {
    var K = OG($, q), P = new rp.default(q);
    return P.accept(K);
  }
  __name(tp, "tp");
});
var WG = x$((_c) => {
  _c.__esModule = true;
  _c.Compiler = ez;
  _c.precompile = qc;
  _c.compile = Kc;
  function vG($) {
    return $ && $.__esModule ? $ : { default: $ };
  }
  __name(vG, "vG");
  var ep = G8(), R7 = vG(ep), I7 = cq(), sp = iz(), E7 = vG(sp), $c = [].slice;
  function ez() {
  }
  __name(ez, "ez");
  ez.prototype = { compiler: ez, equals: /* @__PURE__ */ __name(function(q) {
    var K = this.opcodes.length;
    if (q.opcodes.length !== K) return false;
    for (var P = 0; P < K; P++) {
      var _ = this.opcodes[P], Y = q.opcodes[P];
      if (_.opcode !== Y.opcode || !zG(_.args, Y.args)) return false;
    }
    K = this.children.length;
    for (var P = 0; P < K; P++) if (!this.children[P].equals(q.children[P])) return false;
    return true;
  }, "equals"), guid: 0, compile: /* @__PURE__ */ __name(function(q, K) {
    return this.sourceNode = [], this.opcodes = [], this.children = [], this.options = K, this.stringParams = K.stringParams, this.trackIds = K.trackIds, K.blockParams = K.blockParams || [], K.knownHelpers = I7.extend(/* @__PURE__ */ Object.create(null), { helperMissing: true, blockHelperMissing: true, each: true, if: true, unless: true, with: true, log: true, lookup: true }, K.knownHelpers), this.accept(q);
  }, "compile"), compileProgram: /* @__PURE__ */ __name(function(q) {
    var K = new this.compiler(), P = K.compile(q, this.options), _ = this.guid++;
    return this.usePartial = this.usePartial || P.usePartial, this.children[_] = P, this.useDepths = this.useDepths || P.useDepths, _;
  }, "compileProgram"), accept: /* @__PURE__ */ __name(function(q) {
    if (!this[q.type]) throw new R7.default("Unknown type: " + q.type, q);
    this.sourceNode.unshift(q);
    var K = this[q.type](q);
    return this.sourceNode.shift(), K;
  }, "accept"), Program: /* @__PURE__ */ __name(function(q) {
    this.options.blockParams.unshift(q.blockParams);
    var K = q.body, P = K.length;
    for (var _ = 0; _ < P; _++) this.accept(K[_]);
    return this.options.blockParams.shift(), this.isSimple = P === 1, this.blockParams = q.blockParams ? q.blockParams.length : 0, this;
  }, "Program"), BlockStatement: /* @__PURE__ */ __name(function(q) {
    jG(q);
    var { program: K, inverse: P } = q;
    K = K && this.compileProgram(K), P = P && this.compileProgram(P);
    var _ = this.classifySexpr(q);
    if (_ === "helper") this.helperSexpr(q, K, P);
    else if (_ === "simple") this.simpleSexpr(q), this.opcode("pushProgram", K), this.opcode("pushProgram", P), this.opcode("emptyHash"), this.opcode("blockValue", q.path.original);
    else this.ambiguousSexpr(q, K, P), this.opcode("pushProgram", K), this.opcode("pushProgram", P), this.opcode("emptyHash"), this.opcode("ambiguousBlockValue");
    this.opcode("append");
  }, "BlockStatement"), DecoratorBlock: /* @__PURE__ */ __name(function(q) {
    var K = q.program && this.compileProgram(q.program), P = this.setupFullMustacheParams(q, K, void 0), _ = q.path;
    this.useDecorators = true, this.opcode("registerDecorator", P.length, _.original);
  }, "DecoratorBlock"), PartialStatement: /* @__PURE__ */ __name(function(q) {
    this.usePartial = true;
    var K = q.program;
    if (K) K = this.compileProgram(q.program);
    var P = q.params;
    if (P.length > 1) throw new R7.default("Unsupported number of partial arguments: " + P.length, q);
    else if (!P.length) if (this.options.explicitPartialContext) this.opcode("pushLiteral", "undefined");
    else P.push({ type: "PathExpression", parts: [], depth: 0 });
    var _ = q.name.original, Y = q.name.type === "SubExpression";
    if (Y) this.accept(q.name);
    this.setupFullMustacheParams(q, K, void 0, true);
    var O = q.indent || "";
    if (this.options.preventIndent && O) this.opcode("appendContent", O), O = "";
    this.opcode("invokePartial", Y, _, O), this.opcode("append");
  }, "PartialStatement"), PartialBlockStatement: /* @__PURE__ */ __name(function(q) {
    this.PartialStatement(q);
  }, "PartialBlockStatement"), MustacheStatement: /* @__PURE__ */ __name(function(q) {
    if (this.SubExpression(q), q.escaped && !this.options.noEscape) this.opcode("appendEscaped");
    else this.opcode("append");
  }, "MustacheStatement"), Decorator: /* @__PURE__ */ __name(function(q) {
    this.DecoratorBlock(q);
  }, "Decorator"), ContentStatement: /* @__PURE__ */ __name(function(q) {
    if (q.value) this.opcode("appendContent", q.value);
  }, "ContentStatement"), CommentStatement: /* @__PURE__ */ __name(function() {
  }, "CommentStatement"), SubExpression: /* @__PURE__ */ __name(function(q) {
    jG(q);
    var K = this.classifySexpr(q);
    if (K === "simple") this.simpleSexpr(q);
    else if (K === "helper") this.helperSexpr(q);
    else this.ambiguousSexpr(q);
  }, "SubExpression"), ambiguousSexpr: /* @__PURE__ */ __name(function(q, K, P) {
    var _ = q.path, Y = _.parts[0], O = K != null || P != null;
    this.opcode("getContext", _.depth), this.opcode("pushProgram", K), this.opcode("pushProgram", P), _.strict = true, this.accept(_), this.opcode("invokeAmbiguous", Y, O);
  }, "ambiguousSexpr"), simpleSexpr: /* @__PURE__ */ __name(function(q) {
    var K = q.path;
    K.strict = true, this.accept(K), this.opcode("resolvePossibleLambda");
  }, "simpleSexpr"), helperSexpr: /* @__PURE__ */ __name(function(q, K, P) {
    var _ = this.setupFullMustacheParams(q, K, P), Y = q.path, O = Y.parts[0];
    if (this.options.knownHelpers[O]) this.opcode("invokeKnownHelper", _.length, O);
    else if (this.options.knownHelpersOnly) throw new R7.default("You specified knownHelpersOnly, but used the unknown helper " + O, q);
    else Y.strict = true, Y.falsy = true, this.accept(Y), this.opcode("invokeHelper", _.length, Y.original, E7.default.helpers.simpleId(Y));
  }, "helperSexpr"), PathExpression: /* @__PURE__ */ __name(function(q) {
    this.addDepth(q.depth), this.opcode("getContext", q.depth);
    var K = q.parts[0], P = E7.default.helpers.scopedId(q), _ = !q.depth && !P && this.blockParamIndex(K);
    if (_) this.opcode("lookupBlockParam", _, q.parts);
    else if (!K) this.opcode("pushContext");
    else if (q.data) this.options.data = true, this.opcode("lookupData", q.depth, q.parts, q.strict);
    else this.opcode("lookupOnContext", q.parts, q.falsy, q.strict, P);
  }, "PathExpression"), StringLiteral: /* @__PURE__ */ __name(function(q) {
    this.opcode("pushString", q.value);
  }, "StringLiteral"), NumberLiteral: /* @__PURE__ */ __name(function(q) {
    this.opcode("pushLiteral", q.value);
  }, "NumberLiteral"), BooleanLiteral: /* @__PURE__ */ __name(function(q) {
    this.opcode("pushLiteral", q.value);
  }, "BooleanLiteral"), UndefinedLiteral: /* @__PURE__ */ __name(function() {
    this.opcode("pushLiteral", "undefined");
  }, "UndefinedLiteral"), NullLiteral: /* @__PURE__ */ __name(function() {
    this.opcode("pushLiteral", "null");
  }, "NullLiteral"), Hash: /* @__PURE__ */ __name(function(q) {
    var K = q.pairs, P = 0, _ = K.length;
    this.opcode("pushHash");
    for (; P < _; P++) this.pushParam(K[P].value);
    while (P--) this.opcode("assignToHash", K[P].key);
    this.opcode("popHash");
  }, "Hash"), opcode: /* @__PURE__ */ __name(function(q) {
    this.opcodes.push({ opcode: q, args: $c.call(arguments, 1), loc: this.sourceNode[0].loc });
  }, "opcode"), addDepth: /* @__PURE__ */ __name(function(q) {
    if (!q) return;
    this.useDepths = true;
  }, "addDepth"), classifySexpr: /* @__PURE__ */ __name(function(q) {
    var K = E7.default.helpers.simpleId(q.path), P = K && !!this.blockParamIndex(q.path.parts[0]), _ = !P && E7.default.helpers.helperExpression(q), Y = !P && (_ || K);
    if (Y && !_) {
      var O = q.path.parts[0], z = this.options;
      if (z.knownHelpers[O]) _ = true;
      else if (z.knownHelpersOnly) Y = false;
    }
    if (_) return "helper";
    else if (Y) return "ambiguous";
    else return "simple";
  }, "classifySexpr"), pushParams: /* @__PURE__ */ __name(function(q) {
    for (var K = 0, P = q.length; K < P; K++) this.pushParam(q[K]);
  }, "pushParams"), pushParam: /* @__PURE__ */ __name(function(q) {
    var K = q.value != null ? q.value : q.original || "";
    if (this.stringParams) {
      if (K.replace) K = K.replace(/^(\.?\.\/)*/g, "").replace(/\//g, ".");
      if (q.depth) this.addDepth(q.depth);
      if (this.opcode("getContext", q.depth || 0), this.opcode("pushStringParam", K, q.type), q.type === "SubExpression") this.accept(q);
    } else {
      if (this.trackIds) {
        var P = void 0;
        if (q.parts && !E7.default.helpers.scopedId(q) && !q.depth) P = this.blockParamIndex(q.parts[0]);
        if (P) {
          var _ = q.parts.slice(1).join(".");
          this.opcode("pushId", "BlockParam", P, _);
        } else {
          if (K = q.original || K, K.replace) K = K.replace(/^this(?:\.|$)/, "").replace(/^\.\//, "").replace(/^\.$/, "");
          this.opcode("pushId", q.type, K);
        }
      }
      this.accept(q);
    }
  }, "pushParam"), setupFullMustacheParams: /* @__PURE__ */ __name(function(q, K, P, _) {
    var Y = q.params;
    if (this.pushParams(Y), this.opcode("pushProgram", K), this.opcode("pushProgram", P), q.hash) this.accept(q.hash);
    else this.opcode("emptyHash", _);
    return Y;
  }, "setupFullMustacheParams"), blockParamIndex: /* @__PURE__ */ __name(function(q) {
    for (var K = 0, P = this.options.blockParams.length; K < P; K++) {
      var _ = this.options.blockParams[K], Y = _ && I7.indexOf(_, q);
      if (_ && Y >= 0) return [K, Y];
    }
  }, "blockParamIndex") };
  function qc($, q, K) {
    if ($ == null || typeof $ !== "string" && $.type !== "Program") throw new R7.default("You must pass a string or Handlebars AST to Handlebars.precompile. You passed " + $);
    if (q = q || {}, !("data" in q)) q.data = true;
    if (q.compat) q.useDepths = true;
    var P = K.parse($, q), _ = new K.Compiler().compile(P, q);
    return new K.JavaScriptCompiler().compile(_, q);
  }
  __name(qc, "qc");
  function Kc($, q, K) {
    if (q === void 0) q = {};
    if ($ == null || typeof $ !== "string" && $.type !== "Program") throw new R7.default("You must pass a string or Handlebars AST to Handlebars.compile. You passed " + $);
    if (q = I7.extend({}, q), !("data" in q)) q.data = true;
    if (q.compat) q.useDepths = true;
    var P = void 0;
    function _() {
      var O = K.parse($, q), z = new K.Compiler().compile(O, q), J = new K.JavaScriptCompiler().compile(z, q, void 0, true);
      return K.template(J);
    }
    __name(_, "_");
    function Y(O, z) {
      if (!P) P = _();
      return P.call(this, O, z);
    }
    __name(Y, "Y");
    return Y._setup = function(O) {
      if (!P) P = _();
      return P._setup(O);
    }, Y._child = function(O, z, J, T) {
      if (!P) P = _();
      return P._child(O, z, J, T);
    }, Y;
  }
  __name(Kc, "Kc");
  function zG($, q) {
    if ($ === q) return true;
    if (I7.isArray($) && I7.isArray(q) && $.length === q.length) {
      for (var K = 0; K < $.length; K++) if (!zG($[K], q[K])) return false;
      return true;
    }
  }
  __name(zG, "zG");
  function jG($) {
    if (!$.path.parts) {
      var q = $.path;
      $.path = { type: "PathExpression", data: false, depth: 0, parts: [q.original + ""], original: q.original + "", loc: q.loc };
    }
  }
  __name(jG, "jG");
});
var JG = x$((vc) => {
  var HG = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
  vc.encode = function($) {
    if (0 <= $ && $ < HG.length) return HG[$];
    throw TypeError("Must be between 0 and 63: " + $);
  };
  vc.decode = function($) {
    var q = 65, K = 90, P = 97, _ = 122, Y = 48, O = 57, z = 43, J = 47, T = 26, X = 52;
    if (q <= $ && $ <= K) return $ - q;
    if (P <= $ && $ <= _) return $ - P + T;
    if (Y <= $ && $ <= O) return $ - Y + X;
    if ($ == z) return 62;
    if ($ == J) return 63;
    return -1;
  };
});
var $W = x$((Tc) => {
  var TG = JG(), sz = 5, wG = 1 << sz, fG = wG - 1, ZG = wG;
  function Hc($) {
    return $ < 0 ? (-$ << 1) + 1 : ($ << 1) + 0;
  }
  __name(Hc, "Hc");
  function Jc($) {
    var q = ($ & 1) === 1, K = $ >> 1;
    return q ? -K : K;
  }
  __name(Jc, "Jc");
  Tc.encode = function(q) {
    var K = "", P, _ = Hc(q);
    do {
      if (P = _ & fG, _ >>>= sz, _ > 0) P |= ZG;
      K += TG.encode(P);
    } while (_ > 0);
    return K;
  };
  Tc.decode = function(q, K, P) {
    var _ = q.length, Y = 0, O = 0, z, J;
    do {
      if (K >= _) throw Error("Expected more digits in base 64 VLQ value.");
      if (J = TG.decode(q.charCodeAt(K++)), J === -1) throw Error("Invalid base64 digit: " + q.charAt(K - 1));
      z = !!(J & ZG), J &= fG, Y = Y + (J << O), O += sz;
    } while (z);
    P.value = Jc(Y), P.rest = K;
  };
});
var R4 = x$((hc) => {
  function Zc($, q, K) {
    if (q in $) return $[q];
    else if (arguments.length === 3) return K;
    else throw Error('"' + q + '" is a required argument.');
  }
  __name(Zc, "Zc");
  hc.getArg = Zc;
  var XG = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/, Xc = /^data:.+\,.+$/;
  function D7($) {
    var q = $.match(XG);
    if (!q) return null;
    return { scheme: q[1], auth: q[2], host: q[3], port: q[4], path: q[5] };
  }
  __name(D7, "D7");
  hc.urlParse = D7;
  function h4($) {
    var q = "";
    if ($.scheme) q += $.scheme + ":";
    if (q += "//", $.auth) q += $.auth + "@";
    if ($.host) q += $.host;
    if ($.port) q += ":" + $.port;
    if ($.path) q += $.path;
    return q;
  }
  __name(h4, "h4");
  hc.urlGenerate = h4;
  function qW($) {
    var q = $, K = D7($);
    if (K) {
      if (!K.path) return $;
      q = K.path;
    }
    var P = hc.isAbsolute(q), _ = q.split(/\/+/);
    for (var Y, O = 0, z = _.length - 1; z >= 0; z--) if (Y = _[z], Y === ".") _.splice(z, 1);
    else if (Y === "..") O++;
    else if (O > 0) if (Y === "") _.splice(z + 1, O), O = 0;
    else _.splice(z, 2), O--;
    if (q = _.join("/"), q === "") q = P ? "/" : ".";
    if (K) return K.path = q, h4(K);
    return q;
  }
  __name(qW, "qW");
  hc.normalize = qW;
  function AG($, q) {
    if ($ === "") $ = ".";
    if (q === "") q = ".";
    var K = D7(q), P = D7($);
    if (P) $ = P.path || "/";
    if (K && !K.scheme) {
      if (P) K.scheme = P.scheme;
      return h4(K);
    }
    if (K || q.match(Xc)) return q;
    if (P && !P.host && !P.path) return P.host = q, h4(P);
    var _ = q.charAt(0) === "/" ? q : qW($.replace(/\/+$/, "") + "/" + q);
    if (P) return P.path = _, h4(P);
    return _;
  }
  __name(AG, "AG");
  hc.join = AG;
  hc.isAbsolute = function($) {
    return $.charAt(0) === "/" || XG.test($);
  };
  function Ac($, q) {
    if ($ === "") $ = ".";
    $ = $.replace(/\/$/, "");
    var K = 0;
    while (q.indexOf($ + "/") !== 0) {
      var P = $.lastIndexOf("/");
      if (P < 0) return q;
      if ($ = $.slice(0, P), $.match(/^([^\/]+:\/)?\/*$/)) return q;
      ++K;
    }
    return Array(K + 1).join("../") + q.substr($.length + 1);
  }
  __name(Ac, "Ac");
  hc.relative = Ac;
  var kG = (function() {
    var $ = /* @__PURE__ */ Object.create(null);
    return !("__proto__" in $);
  })();
  function GG($) {
    return $;
  }
  __name(GG, "GG");
  function kc($) {
    if (VG($)) return "$" + $;
    return $;
  }
  __name(kc, "kc");
  hc.toSetString = kG ? GG : kc;
  function Gc($) {
    if (VG($)) return $.slice(1);
    return $;
  }
  __name(Gc, "Gc");
  hc.fromSetString = kG ? GG : Gc;
  function VG($) {
    if (!$) return false;
    var q = $.length;
    if (q < 9) return false;
    if ($.charCodeAt(q - 1) !== 95 || $.charCodeAt(q - 2) !== 95 || $.charCodeAt(q - 3) !== 111 || $.charCodeAt(q - 4) !== 116 || $.charCodeAt(q - 5) !== 111 || $.charCodeAt(q - 6) !== 114 || $.charCodeAt(q - 7) !== 112 || $.charCodeAt(q - 8) !== 95 || $.charCodeAt(q - 9) !== 95) return false;
    for (var K = q - 10; K >= 0; K--) if ($.charCodeAt(K) !== 36) return false;
    return true;
  }
  __name(VG, "VG");
  function Vc($, q, K) {
    var P = E4($.source, q.source);
    if (P !== 0) return P;
    if (P = $.originalLine - q.originalLine, P !== 0) return P;
    if (P = $.originalColumn - q.originalColumn, P !== 0 || K) return P;
    if (P = $.generatedColumn - q.generatedColumn, P !== 0) return P;
    if (P = $.generatedLine - q.generatedLine, P !== 0) return P;
    return E4($.name, q.name);
  }
  __name(Vc, "Vc");
  hc.compareByOriginalPositions = Vc;
  function Sc($, q, K) {
    var P = $.generatedLine - q.generatedLine;
    if (P !== 0) return P;
    if (P = $.generatedColumn - q.generatedColumn, P !== 0 || K) return P;
    if (P = E4($.source, q.source), P !== 0) return P;
    if (P = $.originalLine - q.originalLine, P !== 0) return P;
    if (P = $.originalColumn - q.originalColumn, P !== 0) return P;
    return E4($.name, q.name);
  }
  __name(Sc, "Sc");
  hc.compareByGeneratedPositionsDeflated = Sc;
  function E4($, q) {
    if ($ === q) return 0;
    if ($ === null) return 1;
    if (q === null) return -1;
    if ($ > q) return 1;
    return -1;
  }
  __name(E4, "E4");
  function Mc($, q) {
    var K = $.generatedLine - q.generatedLine;
    if (K !== 0) return K;
    if (K = $.generatedColumn - q.generatedColumn, K !== 0) return K;
    if (K = E4($.source, q.source), K !== 0) return K;
    if (K = $.originalLine - q.originalLine, K !== 0) return K;
    if (K = $.originalColumn - q.originalColumn, K !== 0) return K;
    return E4($.name, q.name);
  }
  __name(Mc, "Mc");
  hc.compareByGeneratedPositionsInflated = Mc;
  function Nc($) {
    return JSON.parse($.replace(/^\)]}'[^\n]*\n/, ""));
  }
  __name(Nc, "Nc");
  hc.parseSourceMapInput = Nc;
  function Cc($, q, K) {
    if (q = q || "", $) {
      if ($[$.length - 1] !== "/" && q[0] !== "/") $ += "/";
      q = $ + q;
    }
    if (K) {
      var P = D7(K);
      if (!P) throw Error("sourceMapURL could not be parsed");
      if (P.path) {
        var _ = P.path.lastIndexOf("/");
        if (_ >= 0) P.path = P.path.substring(0, _ + 1);
      }
      q = AG(h4(P), q);
    }
    return qW(q);
  }
  __name(Cc, "Cc");
  hc.computeSourceURL = Cc;
});
var PW = x$((lc) => {
  var KW = R4(), _W = Object.prototype.hasOwnProperty, I_ = typeof Map < "u";
  function GK() {
    this._array = [], this._set = I_ ? /* @__PURE__ */ new Map() : /* @__PURE__ */ Object.create(null);
  }
  __name(GK, "GK");
  GK.fromArray = function(q, K) {
    var P = new GK();
    for (var _ = 0, Y = q.length; _ < Y; _++) P.add(q[_], K);
    return P;
  };
  GK.prototype.size = function() {
    return I_ ? this._set.size : Object.getOwnPropertyNames(this._set).length;
  };
  GK.prototype.add = function(q, K) {
    var P = I_ ? q : KW.toSetString(q), _ = I_ ? this.has(q) : _W.call(this._set, P), Y = this._array.length;
    if (!_ || K) this._array.push(q);
    if (!_) if (I_) this._set.set(q, Y);
    else this._set[P] = Y;
  };
  GK.prototype.has = function(q) {
    if (I_) return this._set.has(q);
    else {
      var K = KW.toSetString(q);
      return _W.call(this._set, K);
    }
  };
  GK.prototype.indexOf = function(q) {
    if (I_) {
      var K = this._set.get(q);
      if (K >= 0) return K;
    } else {
      var P = KW.toSetString(q);
      if (_W.call(this._set, P)) return this._set[P];
    }
    throw Error('"' + q + '" is not in the set.');
  };
  GK.prototype.at = function(q) {
    if (q >= 0 && q < this._array.length) return this._array[q];
    throw Error("No element indexed by " + q);
  };
  GK.prototype.toArray = function() {
    return this._array.slice();
  };
  lc.ArraySet = GK;
});
var MG = x$((nc) => {
  var SG = R4();
  function oc($, q) {
    var K = $.generatedLine, P = q.generatedLine, _ = $.generatedColumn, Y = q.generatedColumn;
    return P > K || P == K && Y >= _ || SG.compareByGeneratedPositionsInflated($, q) <= 0;
  }
  __name(oc, "oc");
  function R5() {
    this._array = [], this._sorted = true, this._last = { generatedLine: -1, generatedColumn: 0 };
  }
  __name(R5, "R5");
  R5.prototype.unsortedForEach = function(q, K) {
    this._array.forEach(q, K);
  };
  R5.prototype.add = function(q) {
    if (oc(this._last, q)) this._last = q, this._array.push(q);
    else this._sorted = false, this._array.push(q);
  };
  R5.prototype.toArray = function() {
    if (!this._sorted) this._array.sort(SG.compareByGeneratedPositionsInflated), this._sorted = true;
    return this._array;
  };
  nc.MappingList = R5;
});
var OW = x$((Bc) => {
  var L7 = $W(), i6 = R4(), I5 = PW().ArraySet, tc = MG().MappingList;
  function V8($) {
    if (!$) $ = {};
    this._file = i6.getArg($, "file", null), this._sourceRoot = i6.getArg($, "sourceRoot", null), this._skipValidation = i6.getArg($, "skipValidation", false), this._sources = new I5(), this._names = new I5(), this._mappings = new tc(), this._sourcesContents = null;
  }
  __name(V8, "V8");
  V8.prototype._version = 3;
  V8.fromSourceMap = function(q) {
    var K = q.sourceRoot, P = new V8({ file: q.file, sourceRoot: K });
    return q.eachMapping(function(_) {
      var Y = { generated: { line: _.generatedLine, column: _.generatedColumn } };
      if (_.source != null) {
        if (Y.source = _.source, K != null) Y.source = i6.relative(K, Y.source);
        if (Y.original = { line: _.originalLine, column: _.originalColumn }, _.name != null) Y.name = _.name;
      }
      P.addMapping(Y);
    }), q.sources.forEach(function(_) {
      var Y = _;
      if (K !== null) Y = i6.relative(K, _);
      if (!P._sources.has(Y)) P._sources.add(Y);
      var O = q.sourceContentFor(_);
      if (O != null) P.setSourceContent(_, O);
    }), P;
  };
  V8.prototype.addMapping = function(q) {
    var K = i6.getArg(q, "generated"), P = i6.getArg(q, "original", null), _ = i6.getArg(q, "source", null), Y = i6.getArg(q, "name", null);
    if (!this._skipValidation) this._validateMapping(K, P, _, Y);
    if (_ != null) {
      if (_ = String(_), !this._sources.has(_)) this._sources.add(_);
    }
    if (Y != null) {
      if (Y = String(Y), !this._names.has(Y)) this._names.add(Y);
    }
    this._mappings.add({ generatedLine: K.line, generatedColumn: K.column, originalLine: P != null && P.line, originalColumn: P != null && P.column, source: _, name: Y });
  };
  V8.prototype.setSourceContent = function(q, K) {
    var P = q;
    if (this._sourceRoot != null) P = i6.relative(this._sourceRoot, P);
    if (K != null) {
      if (!this._sourcesContents) this._sourcesContents = /* @__PURE__ */ Object.create(null);
      this._sourcesContents[i6.toSetString(P)] = K;
    } else if (this._sourcesContents) {
      if (delete this._sourcesContents[i6.toSetString(P)], Object.keys(this._sourcesContents).length === 0) this._sourcesContents = null;
    }
  };
  V8.prototype.applySourceMap = function(q, K, P) {
    var _ = K;
    if (K == null) {
      if (q.file == null) throw Error(`SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's "file" property. Both were omitted.`);
      _ = q.file;
    }
    var Y = this._sourceRoot;
    if (Y != null) _ = i6.relative(Y, _);
    var O = new I5(), z = new I5();
    this._mappings.unsortedForEach(function(J) {
      if (J.source === _ && J.originalLine != null) {
        var T = q.originalPositionFor({ line: J.originalLine, column: J.originalColumn });
        if (T.source != null) {
          if (J.source = T.source, P != null) J.source = i6.join(P, J.source);
          if (Y != null) J.source = i6.relative(Y, J.source);
          if (J.originalLine = T.line, J.originalColumn = T.column, T.name != null) J.name = T.name;
        }
      }
      var X = J.source;
      if (X != null && !O.has(X)) O.add(X);
      var f = J.name;
      if (f != null && !z.has(f)) z.add(f);
    }, this), this._sources = O, this._names = z, q.sources.forEach(function(J) {
      var T = q.sourceContentFor(J);
      if (T != null) {
        if (P != null) J = i6.join(P, J);
        if (Y != null) J = i6.relative(Y, J);
        this.setSourceContent(J, T);
      }
    }, this);
  };
  V8.prototype._validateMapping = function(q, K, P, _) {
    if (K && typeof K.line !== "number" && typeof K.column !== "number") throw Error("original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values.");
    if (q && "line" in q && "column" in q && q.line > 0 && q.column >= 0 && !K && !P && !_) return;
    else if (q && "line" in q && "column" in q && K && "line" in K && "column" in K && q.line > 0 && q.column >= 0 && K.line > 0 && K.column >= 0 && P) return;
    else throw Error("Invalid mapping: " + JSON.stringify({ generated: q, source: P, original: K, name: _ }));
  };
  V8.prototype._serializeMappings = function() {
    var q = 0, K = 1, P = 0, _ = 0, Y = 0, O = 0, z = "", J, T, X, f, V = this._mappings.toArray();
    for (var M = 0, N = V.length; M < N; M++) {
      if (T = V[M], J = "", T.generatedLine !== K) {
        q = 0;
        while (T.generatedLine !== K) J += ";", K++;
      } else if (M > 0) {
        if (!i6.compareByGeneratedPositionsInflated(T, V[M - 1])) continue;
        J += ",";
      }
      if (J += L7.encode(T.generatedColumn - q), q = T.generatedColumn, T.source != null) {
        if (f = this._sources.indexOf(T.source), J += L7.encode(f - O), O = f, J += L7.encode(T.originalLine - 1 - _), _ = T.originalLine - 1, J += L7.encode(T.originalColumn - P), P = T.originalColumn, T.name != null) X = this._names.indexOf(T.name), J += L7.encode(X - Y), Y = X;
      }
      z += J;
    }
    return z;
  };
  V8.prototype._generateSourcesContent = function(q, K) {
    return q.map(function(P) {
      if (!this._sourcesContents) return null;
      if (K != null) P = i6.relative(K, P);
      var _ = i6.toSetString(P);
      return Object.prototype.hasOwnProperty.call(this._sourcesContents, _) ? this._sourcesContents[_] : null;
    }, this);
  };
  V8.prototype.toJSON = function() {
    var q = { version: this._version, sources: this._sources.toArray(), names: this._names.toArray(), mappings: this._serializeMappings() };
    if (this._file != null) q.file = this._file;
    if (this._sourceRoot != null) q.sourceRoot = this._sourceRoot;
    if (this._sourcesContents) q.sourcesContent = this._generateSourcesContent(q.sources, q.sourceRoot);
    return q;
  };
  V8.prototype.toString = function() {
    return JSON.stringify(this.toJSON());
  };
  Bc.SourceMapGenerator = V8;
});
var CG = x$((Fc) => {
  Fc.GREATEST_LOWER_BOUND = 1;
  Fc.LEAST_UPPER_BOUND = 2;
  function YW($, q, K, P, _, Y) {
    var O = Math.floor((q - $) / 2) + $, z = _(K, P[O], true);
    if (z === 0) return O;
    else if (z > 0) {
      if (q - O > 1) return YW(O, q, K, P, _, Y);
      if (Y == Fc.LEAST_UPPER_BOUND) return q < P.length ? q : -1;
      else return O;
    } else {
      if (O - $ > 1) return YW($, O, K, P, _, Y);
      if (Y == Fc.LEAST_UPPER_BOUND) return O;
      else return $ < 0 ? -1 : $;
    }
  }
  __name(YW, "YW");
  Fc.search = function(q, K, P, _) {
    if (K.length === 0) return -1;
    var Y = YW(-1, K.length, q, K, P, _ || Fc.GREATEST_LOWER_BOUND);
    if (Y < 0) return -1;
    while (Y - 1 >= 0) {
      if (P(K[Y], K[Y - 1], true) !== 0) break;
      --Y;
    }
    return Y;
  };
});
var hG = x$((ec) => {
  function vW($, q, K) {
    var P = $[q];
    $[q] = $[K], $[K] = P;
  }
  __name(vW, "vW");
  function Qc($, q) {
    return Math.round($ + Math.random() * (q - $));
  }
  __name(Qc, "Qc");
  function zW($, q, K, P) {
    if (K < P) {
      var _ = Qc(K, P), Y = K - 1;
      vW($, _, P);
      var O = $[P];
      for (var z = K; z < P; z++) if (q($[z], O) <= 0) Y += 1, vW($, Y, z);
      vW($, Y + 1, z);
      var J = Y + 1;
      zW($, q, K, J - 1), zW($, q, J + 1, P);
    }
  }
  __name(zW, "zW");
  ec.quickSort = function($, q) {
    zW($, q, 0, $.length - 1);
  };
});
var RG = x$((qm) => {
  var Q$ = R4(), WW = CG(), I4 = PW().ArraySet, $m = $W(), g7 = hG().quickSort;
  function L6($, q) {
    var K = $;
    if (typeof $ === "string") K = Q$.parseSourceMapInput($);
    return K.sections != null ? new x8(K, q) : new Vq(K, q);
  }
  __name(L6, "L6");
  L6.fromSourceMap = function($, q) {
    return Vq.fromSourceMap($, q);
  };
  L6.prototype._version = 3;
  L6.prototype.__generatedMappings = null;
  Object.defineProperty(L6.prototype, "_generatedMappings", { configurable: true, enumerable: true, get: /* @__PURE__ */ __name(function() {
    if (!this.__generatedMappings) this._parseMappings(this._mappings, this.sourceRoot);
    return this.__generatedMappings;
  }, "get") });
  L6.prototype.__originalMappings = null;
  Object.defineProperty(L6.prototype, "_originalMappings", { configurable: true, enumerable: true, get: /* @__PURE__ */ __name(function() {
    if (!this.__originalMappings) this._parseMappings(this._mappings, this.sourceRoot);
    return this.__originalMappings;
  }, "get") });
  L6.prototype._charIsMappingSeparator = function(q, K) {
    var P = q.charAt(K);
    return P === ";" || P === ",";
  };
  L6.prototype._parseMappings = function(q, K) {
    throw Error("Subclasses must implement _parseMappings");
  };
  L6.GENERATED_ORDER = 1;
  L6.ORIGINAL_ORDER = 2;
  L6.GREATEST_LOWER_BOUND = 1;
  L6.LEAST_UPPER_BOUND = 2;
  L6.prototype.eachMapping = function(q, K, P) {
    var _ = K || null, Y = P || L6.GENERATED_ORDER, O;
    switch (Y) {
      case L6.GENERATED_ORDER:
        O = this._generatedMappings;
        break;
      case L6.ORIGINAL_ORDER:
        O = this._originalMappings;
        break;
      default:
        throw Error("Unknown order of iteration.");
    }
    var z = this.sourceRoot;
    O.map(function(J) {
      var T = J.source === null ? null : this._sources.at(J.source);
      return T = Q$.computeSourceURL(z, T, this._sourceMapURL), { source: T, generatedLine: J.generatedLine, generatedColumn: J.generatedColumn, originalLine: J.originalLine, originalColumn: J.originalColumn, name: J.name === null ? null : this._names.at(J.name) };
    }, this).forEach(q, _);
  };
  L6.prototype.allGeneratedPositionsFor = function(q) {
    var K = Q$.getArg(q, "line"), P = { source: Q$.getArg(q, "source"), originalLine: K, originalColumn: Q$.getArg(q, "column", 0) };
    if (P.source = this._findSourceIndex(P.source), P.source < 0) return [];
    var _ = [], Y = this._findMapping(P, this._originalMappings, "originalLine", "originalColumn", Q$.compareByOriginalPositions, WW.LEAST_UPPER_BOUND);
    if (Y >= 0) {
      var O = this._originalMappings[Y];
      if (q.column === void 0) {
        var z = O.originalLine;
        while (O && O.originalLine === z) _.push({ line: Q$.getArg(O, "generatedLine", null), column: Q$.getArg(O, "generatedColumn", null), lastColumn: Q$.getArg(O, "lastGeneratedColumn", null) }), O = this._originalMappings[++Y];
      } else {
        var J = O.originalColumn;
        while (O && O.originalLine === K && O.originalColumn == J) _.push({ line: Q$.getArg(O, "generatedLine", null), column: Q$.getArg(O, "generatedColumn", null), lastColumn: Q$.getArg(O, "lastGeneratedColumn", null) }), O = this._originalMappings[++Y];
      }
    }
    return _;
  };
  qm.SourceMapConsumer = L6;
  function Vq($, q) {
    var K = $;
    if (typeof $ === "string") K = Q$.parseSourceMapInput($);
    var P = Q$.getArg(K, "version"), _ = Q$.getArg(K, "sources"), Y = Q$.getArg(K, "names", []), O = Q$.getArg(K, "sourceRoot", null), z = Q$.getArg(K, "sourcesContent", null), J = Q$.getArg(K, "mappings"), T = Q$.getArg(K, "file", null);
    if (P != this._version) throw Error("Unsupported version: " + P);
    if (O) O = Q$.normalize(O);
    _ = _.map(String).map(Q$.normalize).map(function(X) {
      return O && Q$.isAbsolute(O) && Q$.isAbsolute(X) ? Q$.relative(O, X) : X;
    }), this._names = I4.fromArray(Y.map(String), true), this._sources = I4.fromArray(_, true), this._absoluteSources = this._sources.toArray().map(function(X) {
      return Q$.computeSourceURL(O, X, q);
    }), this.sourceRoot = O, this.sourcesContent = z, this._mappings = J, this._sourceMapURL = q, this.file = T;
  }
  __name(Vq, "Vq");
  Vq.prototype = Object.create(L6.prototype);
  Vq.prototype.consumer = L6;
  Vq.prototype._findSourceIndex = function($) {
    var q = $;
    if (this.sourceRoot != null) q = Q$.relative(this.sourceRoot, q);
    if (this._sources.has(q)) return this._sources.indexOf(q);
    var K;
    for (K = 0; K < this._absoluteSources.length; ++K) if (this._absoluteSources[K] == $) return K;
    return -1;
  };
  Vq.fromSourceMap = function(q, K) {
    var P = Object.create(Vq.prototype), _ = P._names = I4.fromArray(q._names.toArray(), true), Y = P._sources = I4.fromArray(q._sources.toArray(), true);
    P.sourceRoot = q._sourceRoot, P.sourcesContent = q._generateSourcesContent(P._sources.toArray(), P.sourceRoot), P.file = q._file, P._sourceMapURL = K, P._absoluteSources = P._sources.toArray().map(function(M) {
      return Q$.computeSourceURL(P.sourceRoot, M, K);
    });
    var O = q._mappings.toArray().slice(), z = P.__generatedMappings = [], J = P.__originalMappings = [];
    for (var T = 0, X = O.length; T < X; T++) {
      var f = O[T], V = new EG();
      if (V.generatedLine = f.generatedLine, V.generatedColumn = f.generatedColumn, f.source) {
        if (V.source = Y.indexOf(f.source), V.originalLine = f.originalLine, V.originalColumn = f.originalColumn, f.name) V.name = _.indexOf(f.name);
        J.push(V);
      }
      z.push(V);
    }
    return g7(P.__originalMappings, Q$.compareByOriginalPositions), P;
  };
  Vq.prototype._version = 3;
  Object.defineProperty(Vq.prototype, "sources", { get: /* @__PURE__ */ __name(function() {
    return this._absoluteSources.slice();
  }, "get") });
  function EG() {
    this.generatedLine = 0, this.generatedColumn = 0, this.source = null, this.originalLine = null, this.originalColumn = null, this.name = null;
  }
  __name(EG, "EG");
  Vq.prototype._parseMappings = function(q, K) {
    var P = 1, _ = 0, Y = 0, O = 0, z = 0, J = 0, T = q.length, X = 0, f = {}, V = {}, M = [], N = [], E, h, I, D, g;
    while (X < T) if (q.charAt(X) === ";") P++, X++, _ = 0;
    else if (q.charAt(X) === ",") X++;
    else {
      E = new EG(), E.generatedLine = P;
      for (D = X; D < T; D++) if (this._charIsMappingSeparator(q, D)) break;
      if (h = q.slice(X, D), I = f[h], I) X += h.length;
      else {
        I = [];
        while (X < D) $m.decode(q, X, V), g = V.value, X = V.rest, I.push(g);
        if (I.length === 2) throw Error("Found a source, but no line and column");
        if (I.length === 3) throw Error("Found a source and line, but no column");
        f[h] = I;
      }
      if (E.generatedColumn = _ + I[0], _ = E.generatedColumn, I.length > 1) {
        if (E.source = z + I[1], z += I[1], E.originalLine = Y + I[2], Y = E.originalLine, E.originalLine += 1, E.originalColumn = O + I[3], O = E.originalColumn, I.length > 4) E.name = J + I[4], J += I[4];
      }
      if (N.push(E), typeof E.originalLine === "number") M.push(E);
    }
    g7(N, Q$.compareByGeneratedPositionsDeflated), this.__generatedMappings = N, g7(M, Q$.compareByOriginalPositions), this.__originalMappings = M;
  };
  Vq.prototype._findMapping = function(q, K, P, _, Y, O) {
    if (q[P] <= 0) throw TypeError("Line must be greater than or equal to 1, got " + q[P]);
    if (q[_] < 0) throw TypeError("Column must be greater than or equal to 0, got " + q[_]);
    return WW.search(q, K, Y, O);
  };
  Vq.prototype.computeColumnSpans = function() {
    for (var q = 0; q < this._generatedMappings.length; ++q) {
      var K = this._generatedMappings[q];
      if (q + 1 < this._generatedMappings.length) {
        var P = this._generatedMappings[q + 1];
        if (K.generatedLine === P.generatedLine) {
          K.lastGeneratedColumn = P.generatedColumn - 1;
          continue;
        }
      }
      K.lastGeneratedColumn = 1 / 0;
    }
  };
  Vq.prototype.originalPositionFor = function(q) {
    var K = { generatedLine: Q$.getArg(q, "line"), generatedColumn: Q$.getArg(q, "column") }, P = this._findMapping(K, this._generatedMappings, "generatedLine", "generatedColumn", Q$.compareByGeneratedPositionsDeflated, Q$.getArg(q, "bias", L6.GREATEST_LOWER_BOUND));
    if (P >= 0) {
      var _ = this._generatedMappings[P];
      if (_.generatedLine === K.generatedLine) {
        var Y = Q$.getArg(_, "source", null);
        if (Y !== null) Y = this._sources.at(Y), Y = Q$.computeSourceURL(this.sourceRoot, Y, this._sourceMapURL);
        var O = Q$.getArg(_, "name", null);
        if (O !== null) O = this._names.at(O);
        return { source: Y, line: Q$.getArg(_, "originalLine", null), column: Q$.getArg(_, "originalColumn", null), name: O };
      }
    }
    return { source: null, line: null, column: null, name: null };
  };
  Vq.prototype.hasContentsOfAllSources = function() {
    if (!this.sourcesContent) return false;
    return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(q) {
      return q == null;
    });
  };
  Vq.prototype.sourceContentFor = function(q, K) {
    if (!this.sourcesContent) return null;
    var P = this._findSourceIndex(q);
    if (P >= 0) return this.sourcesContent[P];
    var _ = q;
    if (this.sourceRoot != null) _ = Q$.relative(this.sourceRoot, _);
    var Y;
    if (this.sourceRoot != null && (Y = Q$.urlParse(this.sourceRoot))) {
      var O = _.replace(/^file:\/\//, "");
      if (Y.scheme == "file" && this._sources.has(O)) return this.sourcesContent[this._sources.indexOf(O)];
      if ((!Y.path || Y.path == "/") && this._sources.has("/" + _)) return this.sourcesContent[this._sources.indexOf("/" + _)];
    }
    if (K) return null;
    else throw Error('"' + _ + '" is not in the SourceMap.');
  };
  Vq.prototype.generatedPositionFor = function(q) {
    var K = Q$.getArg(q, "source");
    if (K = this._findSourceIndex(K), K < 0) return { line: null, column: null, lastColumn: null };
    var P = { source: K, originalLine: Q$.getArg(q, "line"), originalColumn: Q$.getArg(q, "column") }, _ = this._findMapping(P, this._originalMappings, "originalLine", "originalColumn", Q$.compareByOriginalPositions, Q$.getArg(q, "bias", L6.GREATEST_LOWER_BOUND));
    if (_ >= 0) {
      var Y = this._originalMappings[_];
      if (Y.source === P.source) return { line: Q$.getArg(Y, "generatedLine", null), column: Q$.getArg(Y, "generatedColumn", null), lastColumn: Q$.getArg(Y, "lastGeneratedColumn", null) };
    }
    return { line: null, column: null, lastColumn: null };
  };
  qm.BasicSourceMapConsumer = Vq;
  function x8($, q) {
    var K = $;
    if (typeof $ === "string") K = Q$.parseSourceMapInput($);
    var P = Q$.getArg(K, "version"), _ = Q$.getArg(K, "sections");
    if (P != this._version) throw Error("Unsupported version: " + P);
    this._sources = new I4(), this._names = new I4();
    var Y = { line: -1, column: 0 };
    this._sections = _.map(function(O) {
      if (O.url) throw Error("Support for url field in sections not implemented.");
      var z = Q$.getArg(O, "offset"), J = Q$.getArg(z, "line"), T = Q$.getArg(z, "column");
      if (J < Y.line || J === Y.line && T < Y.column) throw Error("Section offsets must be ordered and non-overlapping.");
      return Y = z, { generatedOffset: { generatedLine: J + 1, generatedColumn: T + 1 }, consumer: new L6(Q$.getArg(O, "map"), q) };
    });
  }
  __name(x8, "x8");
  x8.prototype = Object.create(L6.prototype);
  x8.prototype.constructor = L6;
  x8.prototype._version = 3;
  Object.defineProperty(x8.prototype, "sources", { get: /* @__PURE__ */ __name(function() {
    var $ = [];
    for (var q = 0; q < this._sections.length; q++) for (var K = 0; K < this._sections[q].consumer.sources.length; K++) $.push(this._sections[q].consumer.sources[K]);
    return $;
  }, "get") });
  x8.prototype.originalPositionFor = function(q) {
    var K = { generatedLine: Q$.getArg(q, "line"), generatedColumn: Q$.getArg(q, "column") }, P = WW.search(K, this._sections, function(Y, O) {
      var z = Y.generatedLine - O.generatedOffset.generatedLine;
      if (z) return z;
      return Y.generatedColumn - O.generatedOffset.generatedColumn;
    }), _ = this._sections[P];
    if (!_) return { source: null, line: null, column: null, name: null };
    return _.consumer.originalPositionFor({ line: K.generatedLine - (_.generatedOffset.generatedLine - 1), column: K.generatedColumn - (_.generatedOffset.generatedLine === K.generatedLine ? _.generatedOffset.generatedColumn - 1 : 0), bias: q.bias });
  };
  x8.prototype.hasContentsOfAllSources = function() {
    return this._sections.every(function(q) {
      return q.consumer.hasContentsOfAllSources();
    });
  };
  x8.prototype.sourceContentFor = function(q, K) {
    for (var P = 0; P < this._sections.length; P++) {
      var _ = this._sections[P], Y = _.consumer.sourceContentFor(q, true);
      if (Y) return Y;
    }
    if (K) return null;
    else throw Error('"' + q + '" is not in the SourceMap.');
  };
  x8.prototype.generatedPositionFor = function(q) {
    for (var K = 0; K < this._sections.length; K++) {
      var P = this._sections[K];
      if (P.consumer._findSourceIndex(Q$.getArg(q, "source")) === -1) continue;
      var _ = P.consumer.generatedPositionFor(q);
      if (_) {
        var Y = { line: _.line + (P.generatedOffset.generatedLine - 1), column: _.column + (P.generatedOffset.generatedLine === _.line ? P.generatedOffset.generatedColumn - 1 : 0) };
        return Y;
      }
    }
    return { line: null, column: null };
  };
  x8.prototype._parseMappings = function(q, K) {
    this.__generatedMappings = [], this.__originalMappings = [];
    for (var P = 0; P < this._sections.length; P++) {
      var _ = this._sections[P], Y = _.consumer._generatedMappings;
      for (var O = 0; O < Y.length; O++) {
        var z = Y[O], J = _.consumer._sources.at(z.source);
        J = Q$.computeSourceURL(_.consumer.sourceRoot, J, this._sourceMapURL), this._sources.add(J), J = this._sources.indexOf(J);
        var T = null;
        if (z.name) T = _.consumer._names.at(z.name), this._names.add(T), T = this._names.indexOf(T);
        var X = { source: J, generatedLine: z.generatedLine + (_.generatedOffset.generatedLine - 1), generatedColumn: z.generatedColumn + (_.generatedOffset.generatedLine === z.generatedLine ? _.generatedOffset.generatedColumn - 1 : 0), originalLine: z.originalLine, originalColumn: z.originalColumn, name: T };
        if (this.__generatedMappings.push(X), typeof X.originalLine === "number") this.__originalMappings.push(X);
      }
    }
    g7(this.__generatedMappings, Q$.compareByGeneratedPositionsDeflated), g7(this.__originalMappings, Q$.compareByOriginalPositions);
  };
  qm.IndexedSourceMapConsumer = x8;
});
var IG = x$((vm) => {
  var Om = OW().SourceMapGenerator, D5 = R4(), Ym = /(\r?\n)/, jm = 10, D4 = "$$$isSourceNode$$$";
  function v8($, q, K, P, _) {
    if (this.children = [], this.sourceContents = {}, this.line = $ == null ? null : $, this.column = q == null ? null : q, this.source = K == null ? null : K, this.name = _ == null ? null : _, this[D4] = true, P != null) this.add(P);
  }
  __name(v8, "v8");
  v8.fromStringWithSourceMap = function(q, K, P) {
    var _ = new v8(), Y = q.split(Ym), O = 0, z = /* @__PURE__ */ __name(function() {
      var V = N(), M = N() || "";
      return V + M;
      function N() {
        return O < Y.length ? Y[O++] : void 0;
      }
      __name(N, "N");
    }, "z"), J = 1, T = 0, X = null;
    if (K.eachMapping(function(V) {
      if (X !== null) if (J < V.generatedLine) f(X, z()), J++, T = 0;
      else {
        var M = Y[O] || "", N = M.substr(0, V.generatedColumn - T);
        Y[O] = M.substr(V.generatedColumn - T), T = V.generatedColumn, f(X, N), X = V;
        return;
      }
      while (J < V.generatedLine) _.add(z()), J++;
      if (T < V.generatedColumn) {
        var M = Y[O] || "";
        _.add(M.substr(0, V.generatedColumn)), Y[O] = M.substr(V.generatedColumn), T = V.generatedColumn;
      }
      X = V;
    }, this), O < Y.length) {
      if (X) f(X, z());
      _.add(Y.splice(O).join(""));
    }
    return K.sources.forEach(function(V) {
      var M = K.sourceContentFor(V);
      if (M != null) {
        if (P != null) V = D5.join(P, V);
        _.setSourceContent(V, M);
      }
    }), _;
    function f(V, M) {
      if (V === null || V.source === void 0) _.add(M);
      else {
        var N = P ? D5.join(P, V.source) : V.source;
        _.add(new v8(V.originalLine, V.originalColumn, N, M, V.name));
      }
    }
    __name(f, "f");
  };
  v8.prototype.add = function(q) {
    if (Array.isArray(q)) q.forEach(function(K) {
      this.add(K);
    }, this);
    else if (q[D4] || typeof q === "string") {
      if (q) this.children.push(q);
    } else throw TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + q);
    return this;
  };
  v8.prototype.prepend = function(q) {
    if (Array.isArray(q)) for (var K = q.length - 1; K >= 0; K--) this.prepend(q[K]);
    else if (q[D4] || typeof q === "string") this.children.unshift(q);
    else throw TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + q);
    return this;
  };
  v8.prototype.walk = function(q) {
    var K;
    for (var P = 0, _ = this.children.length; P < _; P++) if (K = this.children[P], K[D4]) K.walk(q);
    else if (K !== "") q(K, { source: this.source, line: this.line, column: this.column, name: this.name });
  };
  v8.prototype.join = function(q) {
    var K, P, _ = this.children.length;
    if (_ > 0) {
      K = [];
      for (P = 0; P < _ - 1; P++) K.push(this.children[P]), K.push(q);
      K.push(this.children[P]), this.children = K;
    }
    return this;
  };
  v8.prototype.replaceRight = function(q, K) {
    var P = this.children[this.children.length - 1];
    if (P[D4]) P.replaceRight(q, K);
    else if (typeof P === "string") this.children[this.children.length - 1] = P.replace(q, K);
    else this.children.push("".replace(q, K));
    return this;
  };
  v8.prototype.setSourceContent = function(q, K) {
    this.sourceContents[D5.toSetString(q)] = K;
  };
  v8.prototype.walkSourceContents = function(q) {
    for (var K = 0, P = this.children.length; K < P; K++) if (this.children[K][D4]) this.children[K].walkSourceContents(q);
    var _ = Object.keys(this.sourceContents);
    for (var K = 0, P = _.length; K < P; K++) q(D5.fromSetString(_[K]), this.sourceContents[_[K]]);
  };
  v8.prototype.toString = function() {
    var q = "";
    return this.walk(function(K) {
      q += K;
    }), q;
  };
  v8.prototype.toStringWithSourceMap = function(q) {
    var K = { code: "", line: 1, column: 0 }, P = new Om(q), _ = false, Y = null, O = null, z = null, J = null;
    return this.walk(function(T, X) {
      if (K.code += T, X.source !== null && X.line !== null && X.column !== null) {
        if (Y !== X.source || O !== X.line || z !== X.column || J !== X.name) P.addMapping({ source: X.source, original: { line: X.line, column: X.column }, generated: { line: K.line, column: K.column }, name: X.name });
        Y = X.source, O = X.line, z = X.column, J = X.name, _ = true;
      } else if (_) P.addMapping({ generated: { line: K.line, column: K.column } }), Y = null, _ = false;
      for (var f = 0, V = T.length; f < V; f++) if (T.charCodeAt(f) === jm) {
        if (K.line++, K.column = 0, f + 1 === V) Y = null, _ = false;
        else if (_) P.addMapping({ source: X.source, original: { line: X.line, column: X.column }, generated: { line: K.line, column: K.column }, name: X.name });
      } else K.column++;
    }), this.walkSourceContents(function(T, X) {
      P.setSourceContent(T, X);
    }), { code: K.code, map: P };
  };
  vm.SourceNode = v8;
});
var DG = x$((Wm) => {
  Wm.SourceMapGenerator = OW().SourceMapGenerator;
  Wm.SourceMapConsumer = RG().SourceMapConsumer;
  Wm.SourceNode = IG().SourceNode;
});
var yG = x$((gG, bG) => {
  gG.__esModule = true;
  var JW = cq(), D_ = void 0;
  try {
    if (typeof define !== "function" || !define.amd) TW = DG(), D_ = TW.SourceNode;
  } catch ($) {
  }
  var TW;
  if (!D_) D_ = /* @__PURE__ */ __name(function($, q, K, P) {
    if (this.src = "", P) this.add(P);
  }, "D_"), D_.prototype = { add: /* @__PURE__ */ __name(function(q) {
    if (JW.isArray(q)) q = q.join("");
    this.src += q;
  }, "add"), prepend: /* @__PURE__ */ __name(function(q) {
    if (JW.isArray(q)) q = q.join("");
    this.src = q + this.src;
  }, "prepend"), toStringWithSourceMap: /* @__PURE__ */ __name(function() {
    return { code: this.toString() };
  }, "toStringWithSourceMap"), toString: /* @__PURE__ */ __name(function() {
    return this.src;
  }, "toString") };
  function HW($, q, K) {
    if (JW.isArray($)) {
      var P = [];
      for (var _ = 0, Y = $.length; _ < Y; _++) P.push(q.wrap($[_], K));
      return P;
    } else if (typeof $ === "boolean" || typeof $ === "number") return $ + "";
    return $;
  }
  __name(HW, "HW");
  function LG($) {
    this.srcFile = $, this.source = [];
  }
  __name(LG, "LG");
  LG.prototype = { isEmpty: /* @__PURE__ */ __name(function() {
    return !this.source.length;
  }, "isEmpty"), prepend: /* @__PURE__ */ __name(function(q, K) {
    this.source.unshift(this.wrap(q, K));
  }, "prepend"), push: /* @__PURE__ */ __name(function(q, K) {
    this.source.push(this.wrap(q, K));
  }, "push"), merge: /* @__PURE__ */ __name(function() {
    var q = this.empty();
    return this.each(function(K) {
      q.add(["  ", K, `
`]);
    }), q;
  }, "merge"), each: /* @__PURE__ */ __name(function(q) {
    for (var K = 0, P = this.source.length; K < P; K++) q(this.source[K]);
  }, "each"), empty: /* @__PURE__ */ __name(function() {
    var q = this.currentLocation || { start: {} };
    return new D_(q.start.line, q.start.column, this.srcFile);
  }, "empty"), wrap: /* @__PURE__ */ __name(function(q) {
    var K = arguments.length <= 1 || arguments[1] === void 0 ? this.currentLocation || { start: {} } : arguments[1];
    if (q instanceof D_) return q;
    return q = HW(q, this, K), new D_(K.start.line, K.start.column, this.srcFile, q);
  }, "wrap"), functionCall: /* @__PURE__ */ __name(function(q, K, P) {
    return P = this.generateList(P), this.wrap([q, K ? "." + K + "(" : "(", P, ")"]);
  }, "functionCall"), quotedString: /* @__PURE__ */ __name(function(q) {
    return '"' + (q + "").replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029") + '"';
  }, "quotedString"), objectLiteral: /* @__PURE__ */ __name(function(q) {
    var K = this, P = [];
    Object.keys(q).forEach(function(Y) {
      var O = HW(q[Y], K);
      if (O !== "undefined") P.push([K.quotedString(Y), ":", O]);
    });
    var _ = this.generateList(P);
    return _.prepend("{"), _.add("}"), _;
  }, "objectLiteral"), generateList: /* @__PURE__ */ __name(function(q) {
    var K = this.empty();
    for (var P = 0, _ = q.length; P < _; P++) {
      if (P) K.add(",");
      K.add(HW(q[P], this));
    }
    return K;
  }, "generateList"), generateArray: /* @__PURE__ */ __name(function(q) {
    var K = this.generateList(q);
    return K.prepend("["), K.add("]"), K;
  }, "generateArray") };
  gG.default = LG;
  bG.exports = gG.default;
});
var dG = x$((cG, mG) => {
  cG.__esModule = true;
  function pG($) {
    return $ && $.__esModule ? $ : { default: $ };
  }
  __name(pG, "pG");
  var uG = S5(), Zm = G8(), wW = pG(Zm), Xm = cq(), Am = yG(), xG = pG(Am);
  function L4($) {
    this.value = $;
  }
  __name(L4, "L4");
  function g4() {
  }
  __name(g4, "g4");
  g4.prototype = { nameLookup: /* @__PURE__ */ __name(function(q, K) {
    return this.internalNameLookup(q, K);
  }, "nameLookup"), depthedLookup: /* @__PURE__ */ __name(function(q) {
    return [this.aliasable("container.lookup"), "(depths, ", JSON.stringify(q), ")"];
  }, "depthedLookup"), compilerInfo: /* @__PURE__ */ __name(function() {
    var q = uG.COMPILER_REVISION, K = uG.REVISION_CHANGES[q];
    return [q, K];
  }, "compilerInfo"), appendToBuffer: /* @__PURE__ */ __name(function(q, K, P) {
    if (!Xm.isArray(q)) q = [q];
    if (q = this.source.wrap(q, K), this.environment.isSimple) return ["return ", q, ";"];
    else if (P) return ["buffer += ", q, ";"];
    else return q.appendToBuffer = true, q;
  }, "appendToBuffer"), initializeBuffer: /* @__PURE__ */ __name(function() {
    return this.quotedString("");
  }, "initializeBuffer"), internalNameLookup: /* @__PURE__ */ __name(function(q, K) {
    return this.lookupPropertyFunctionIsUsed = true, ["lookupProperty(", q, ",", JSON.stringify(K), ")"];
  }, "internalNameLookup"), lookupPropertyFunctionIsUsed: false, compile: /* @__PURE__ */ __name(function(q, K, P, _) {
    this.environment = q, this.options = K, this.stringParams = this.options.stringParams, this.trackIds = this.options.trackIds, this.precompile = !_, this.name = this.environment.name, this.isChild = !!P, this.context = P || { decorators: [], programs: [], environments: [] }, this.preamble(), this.stackSlot = 0, this.stackVars = [], this.aliases = {}, this.registers = { list: [] }, this.hashes = [], this.compileStack = [], this.inlineStack = [], this.blockParams = [], this.compileChildren(q, K), this.useDepths = this.useDepths || q.useDepths || q.useDecorators || this.options.compat, this.useBlockParams = this.useBlockParams || q.useBlockParams;
    var Y = q.opcodes, O = void 0, z = void 0, J = void 0, T = void 0;
    for (J = 0, T = Y.length; J < T; J++) O = Y[J], this.source.currentLocation = O.loc, z = z || O.loc, this[O.opcode].apply(this, O.args);
    if (this.source.currentLocation = z, this.pushSource(""), this.stackSlot || this.inlineStack.length || this.compileStack.length) throw new wW.default("Compile completed with content left on stack");
    if (!this.decorators.isEmpty()) if (this.useDecorators = true, this.decorators.prepend(["var decorators = container.decorators, ", this.lookupPropertyFunctionVarDeclaration(), `;
`]), this.decorators.push("return fn;"), _) this.decorators = Function.apply(this, ["fn", "props", "container", "depth0", "data", "blockParams", "depths", this.decorators.merge()]);
    else this.decorators.prepend(`function(fn, props, container, depth0, data, blockParams, depths) {
`), this.decorators.push(`}
`), this.decorators = this.decorators.merge();
    else this.decorators = void 0;
    var X = this.createFunctionContext(_);
    if (!this.isChild) {
      var f = { compiler: this.compilerInfo(), main: X };
      if (this.decorators) f.main_d = this.decorators, f.useDecorators = true;
      var V = this.context, M = V.programs, N = V.decorators;
      for (J = 0, T = M.length; J < T; J++) if (M[J]) {
        if (f[J] = M[J], N[J]) f[J + "_d"] = N[J], f.useDecorators = true;
      }
      if (this.environment.usePartial) f.usePartial = true;
      if (this.options.data) f.useData = true;
      if (this.useDepths) f.useDepths = true;
      if (this.useBlockParams) f.useBlockParams = true;
      if (this.options.compat) f.compat = true;
      if (!_) if (f.compiler = JSON.stringify(f.compiler), this.source.currentLocation = { start: { line: 1, column: 0 } }, f = this.objectLiteral(f), K.srcName) f = f.toStringWithSourceMap({ file: K.destName }), f.map = f.map && f.map.toString();
      else f = f.toString();
      else f.compilerOptions = this.options;
      return f;
    } else return X;
  }, "compile"), preamble: /* @__PURE__ */ __name(function() {
    this.lastContext = 0, this.source = new xG.default(this.options.srcName), this.decorators = new xG.default(this.options.srcName);
  }, "preamble"), createFunctionContext: /* @__PURE__ */ __name(function(q) {
    var K = this, P = "", _ = this.stackVars.concat(this.registers.list);
    if (_.length > 0) P += ", " + _.join(", ");
    var Y = 0;
    if (Object.keys(this.aliases).forEach(function(J) {
      var T = K.aliases[J];
      if (T.children && T.referenceCount > 1) P += ", alias" + ++Y + "=" + J, T.children[0] = "alias" + Y;
    }), this.lookupPropertyFunctionIsUsed) P += ", " + this.lookupPropertyFunctionVarDeclaration();
    var O = ["container", "depth0", "helpers", "partials", "data"];
    if (this.useBlockParams || this.useDepths) O.push("blockParams");
    if (this.useDepths) O.push("depths");
    var z = this.mergeSource(P);
    if (q) return O.push(z), Function.apply(this, O);
    else return this.source.wrap(["function(", O.join(","), `) {
  `, z, "}"]);
  }, "createFunctionContext"), mergeSource: /* @__PURE__ */ __name(function(q) {
    var K = this.environment.isSimple, P = !this.forceBuffer, _ = void 0, Y = void 0, O = void 0, z = void 0;
    if (this.source.each(function(J) {
      if (J.appendToBuffer) {
        if (O) J.prepend("  + ");
        else O = J;
        z = J;
      } else {
        if (O) {
          if (!Y) _ = true;
          else O.prepend("buffer += ");
          z.add(";"), O = z = void 0;
        }
        if (Y = true, !K) P = false;
      }
    }), P) {
      if (O) O.prepend("return "), z.add(";");
      else if (!Y) this.source.push('return "";');
    } else if (q += ", buffer = " + (_ ? "" : this.initializeBuffer()), O) O.prepend("return buffer + "), z.add(";");
    else this.source.push("return buffer;");
    if (q) this.source.prepend("var " + q.substring(2) + (_ ? "" : `;
`));
    return this.source.merge();
  }, "mergeSource"), lookupPropertyFunctionVarDeclaration: /* @__PURE__ */ __name(function() {
    return `
      lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    }
    `.trim();
  }, "lookupPropertyFunctionVarDeclaration"), blockValue: /* @__PURE__ */ __name(function(q) {
    var K = this.aliasable("container.hooks.blockHelperMissing"), P = [this.contextName(0)];
    this.setupHelperArgs(q, 0, P);
    var _ = this.popStack();
    P.splice(1, 0, _), this.push(this.source.functionCall(K, "call", P));
  }, "blockValue"), ambiguousBlockValue: /* @__PURE__ */ __name(function() {
    var q = this.aliasable("container.hooks.blockHelperMissing"), K = [this.contextName(0)];
    this.setupHelperArgs("", 0, K, true), this.flushInline();
    var P = this.topStack();
    K.splice(1, 0, P), this.pushSource(["if (!", this.lastHelper, ") { ", P, " = ", this.source.functionCall(q, "call", K), "}"]);
  }, "ambiguousBlockValue"), appendContent: /* @__PURE__ */ __name(function(q) {
    if (this.pendingContent) q = this.pendingContent + q;
    else this.pendingLocation = this.source.currentLocation;
    this.pendingContent = q;
  }, "appendContent"), append: /* @__PURE__ */ __name(function() {
    if (this.isInline()) this.replaceStack(function(K) {
      return [" != null ? ", K, ' : ""'];
    }), this.pushSource(this.appendToBuffer(this.popStack()));
    else {
      var q = this.popStack();
      if (this.pushSource(["if (", q, " != null) { ", this.appendToBuffer(q, void 0, true), " }"]), this.environment.isSimple) this.pushSource(["else { ", this.appendToBuffer("''", void 0, true), " }"]);
    }
  }, "append"), appendEscaped: /* @__PURE__ */ __name(function() {
    this.pushSource(this.appendToBuffer([this.aliasable("container.escapeExpression"), "(", this.popStack(), ")"]));
  }, "appendEscaped"), getContext: /* @__PURE__ */ __name(function(q) {
    this.lastContext = q;
  }, "getContext"), pushContext: /* @__PURE__ */ __name(function() {
    this.pushStackLiteral(this.contextName(this.lastContext));
  }, "pushContext"), lookupOnContext: /* @__PURE__ */ __name(function(q, K, P, _) {
    var Y = 0;
    if (!_ && this.options.compat && !this.lastContext) this.push(this.depthedLookup(q[Y++]));
    else this.pushContext();
    this.resolvePath("context", q, Y, K, P);
  }, "lookupOnContext"), lookupBlockParam: /* @__PURE__ */ __name(function(q, K) {
    this.useBlockParams = true, this.push(["blockParams[", q[0], "][", q[1], "]"]), this.resolvePath("context", K, 1);
  }, "lookupBlockParam"), lookupData: /* @__PURE__ */ __name(function(q, K, P) {
    if (!q) this.pushStackLiteral("data");
    else this.pushStackLiteral("container.data(data, " + q + ")");
    this.resolvePath("data", K, 0, true, P);
  }, "lookupData"), resolvePath: /* @__PURE__ */ __name(function(q, K, P, _, Y) {
    var O = this;
    if (this.options.strict || this.options.assumeObjects) {
      this.push(km(this.options.strict && Y, this, K, P, q));
      return;
    }
    var z = K.length;
    for (; P < z; P++) this.replaceStack(function(J) {
      var T = O.nameLookup(J, K[P], q);
      if (!_) return [" != null ? ", T, " : ", J];
      else return [" && ", T];
    });
  }, "resolvePath"), resolvePossibleLambda: /* @__PURE__ */ __name(function() {
    this.push([this.aliasable("container.lambda"), "(", this.popStack(), ", ", this.contextName(0), ")"]);
  }, "resolvePossibleLambda"), pushStringParam: /* @__PURE__ */ __name(function(q, K) {
    if (this.pushContext(), this.pushString(K), K !== "SubExpression") if (typeof q === "string") this.pushString(q);
    else this.pushStackLiteral(q);
  }, "pushStringParam"), emptyHash: /* @__PURE__ */ __name(function(q) {
    if (this.trackIds) this.push("{}");
    if (this.stringParams) this.push("{}"), this.push("{}");
    this.pushStackLiteral(q ? "undefined" : "{}");
  }, "emptyHash"), pushHash: /* @__PURE__ */ __name(function() {
    if (this.hash) this.hashes.push(this.hash);
    this.hash = { values: {}, types: [], contexts: [], ids: [] };
  }, "pushHash"), popHash: /* @__PURE__ */ __name(function() {
    var q = this.hash;
    if (this.hash = this.hashes.pop(), this.trackIds) this.push(this.objectLiteral(q.ids));
    if (this.stringParams) this.push(this.objectLiteral(q.contexts)), this.push(this.objectLiteral(q.types));
    this.push(this.objectLiteral(q.values));
  }, "popHash"), pushString: /* @__PURE__ */ __name(function(q) {
    this.pushStackLiteral(this.quotedString(q));
  }, "pushString"), pushLiteral: /* @__PURE__ */ __name(function(q) {
    this.pushStackLiteral(q);
  }, "pushLiteral"), pushProgram: /* @__PURE__ */ __name(function(q) {
    if (q != null) this.pushStackLiteral(this.programExpression(q));
    else this.pushStackLiteral(null);
  }, "pushProgram"), registerDecorator: /* @__PURE__ */ __name(function(q, K) {
    var P = this.nameLookup("decorators", K, "decorator"), _ = this.setupHelperArgs(K, q);
    this.decorators.push(["fn = ", this.decorators.functionCall(P, "", ["fn", "props", "container", _]), " || fn;"]);
  }, "registerDecorator"), invokeHelper: /* @__PURE__ */ __name(function(q, K, P) {
    var _ = this.popStack(), Y = this.setupHelper(q, K), O = [];
    if (P) O.push(Y.name);
    if (O.push(_), !this.options.strict) O.push(this.aliasable("container.hooks.helperMissing"));
    var z = ["(", this.itemsSeparatedBy(O, "||"), ")"], J = this.source.functionCall(z, "call", Y.callParams);
    this.push(J);
  }, "invokeHelper"), itemsSeparatedBy: /* @__PURE__ */ __name(function(q, K) {
    var P = [];
    P.push(q[0]);
    for (var _ = 1; _ < q.length; _++) P.push(K, q[_]);
    return P;
  }, "itemsSeparatedBy"), invokeKnownHelper: /* @__PURE__ */ __name(function(q, K) {
    var P = this.setupHelper(q, K);
    this.push(this.source.functionCall(P.name, "call", P.callParams));
  }, "invokeKnownHelper"), invokeAmbiguous: /* @__PURE__ */ __name(function(q, K) {
    this.useRegister("helper");
    var P = this.popStack();
    this.emptyHash();
    var _ = this.setupHelper(0, q, K), Y = this.lastHelper = this.nameLookup("helpers", q, "helper"), O = ["(", "(helper = ", Y, " || ", P, ")"];
    if (!this.options.strict) O[0] = "(helper = ", O.push(" != null ? helper : ", this.aliasable("container.hooks.helperMissing"));
    this.push(["(", O, _.paramsInit ? ["),(", _.paramsInit] : [], "),", "(typeof helper === ", this.aliasable('"function"'), " ? ", this.source.functionCall("helper", "call", _.callParams), " : helper))"]);
  }, "invokeAmbiguous"), invokePartial: /* @__PURE__ */ __name(function(q, K, P) {
    var _ = [], Y = this.setupParams(K, 1, _);
    if (q) K = this.popStack(), delete Y.name;
    if (P) Y.indent = JSON.stringify(P);
    if (Y.helpers = "helpers", Y.partials = "partials", Y.decorators = "container.decorators", !q) _.unshift(this.nameLookup("partials", K, "partial"));
    else _.unshift(K);
    if (this.options.compat) Y.depths = "depths";
    Y = this.objectLiteral(Y), _.push(Y), this.push(this.source.functionCall("container.invokePartial", "", _));
  }, "invokePartial"), assignToHash: /* @__PURE__ */ __name(function(q) {
    var K = this.popStack(), P = void 0, _ = void 0, Y = void 0;
    if (this.trackIds) Y = this.popStack();
    if (this.stringParams) _ = this.popStack(), P = this.popStack();
    var O = this.hash;
    if (P) O.contexts[q] = P;
    if (_) O.types[q] = _;
    if (Y) O.ids[q] = Y;
    O.values[q] = K;
  }, "assignToHash"), pushId: /* @__PURE__ */ __name(function(q, K, P) {
    if (q === "BlockParam") this.pushStackLiteral("blockParams[" + K[0] + "].path[" + K[1] + "]" + (P ? " + " + JSON.stringify("." + P) : ""));
    else if (q === "PathExpression") this.pushString(K);
    else if (q === "SubExpression") this.pushStackLiteral("true");
    else this.pushStackLiteral("null");
  }, "pushId"), compiler: g4, compileChildren: /* @__PURE__ */ __name(function(q, K) {
    var P = q.children, _ = void 0, Y = void 0;
    for (var O = 0, z = P.length; O < z; O++) {
      _ = P[O], Y = new this.compiler();
      var J = this.matchExistingProgram(_);
      if (J == null) {
        this.context.programs.push("");
        var T = this.context.programs.length;
        _.index = T, _.name = "program" + T, this.context.programs[T] = Y.compile(_, K, this.context, !this.precompile), this.context.decorators[T] = Y.decorators, this.context.environments[T] = _, this.useDepths = this.useDepths || Y.useDepths, this.useBlockParams = this.useBlockParams || Y.useBlockParams, _.useDepths = this.useDepths, _.useBlockParams = this.useBlockParams;
      } else _.index = J.index, _.name = "program" + J.index, this.useDepths = this.useDepths || J.useDepths, this.useBlockParams = this.useBlockParams || J.useBlockParams;
    }
  }, "compileChildren"), matchExistingProgram: /* @__PURE__ */ __name(function(q) {
    for (var K = 0, P = this.context.environments.length; K < P; K++) {
      var _ = this.context.environments[K];
      if (_ && _.equals(q)) return _;
    }
  }, "matchExistingProgram"), programExpression: /* @__PURE__ */ __name(function(q) {
    var K = this.environment.children[q], P = [K.index, "data", K.blockParams];
    if (this.useBlockParams || this.useDepths) P.push("blockParams");
    if (this.useDepths) P.push("depths");
    return "container.program(" + P.join(", ") + ")";
  }, "programExpression"), useRegister: /* @__PURE__ */ __name(function(q) {
    if (!this.registers[q]) this.registers[q] = true, this.registers.list.push(q);
  }, "useRegister"), push: /* @__PURE__ */ __name(function(q) {
    if (!(q instanceof L4)) q = this.source.wrap(q);
    return this.inlineStack.push(q), q;
  }, "push"), pushStackLiteral: /* @__PURE__ */ __name(function(q) {
    this.push(new L4(q));
  }, "pushStackLiteral"), pushSource: /* @__PURE__ */ __name(function(q) {
    if (this.pendingContent) this.source.push(this.appendToBuffer(this.source.quotedString(this.pendingContent), this.pendingLocation)), this.pendingContent = void 0;
    if (q) this.source.push(q);
  }, "pushSource"), replaceStack: /* @__PURE__ */ __name(function(q) {
    var K = ["("], P = void 0, _ = void 0, Y = void 0;
    if (!this.isInline()) throw new wW.default("replaceStack on non-inline");
    var O = this.popStack(true);
    if (O instanceof L4) P = [O.value], K = ["(", P], Y = true;
    else {
      _ = true;
      var z = this.incrStack();
      K = ["((", this.push(z), " = ", O, ")"], P = this.topStack();
    }
    var J = q.call(this, P);
    if (!Y) this.popStack();
    if (_) this.stackSlot--;
    this.push(K.concat(J, ")"));
  }, "replaceStack"), incrStack: /* @__PURE__ */ __name(function() {
    if (this.stackSlot++, this.stackSlot > this.stackVars.length) this.stackVars.push("stack" + this.stackSlot);
    return this.topStackName();
  }, "incrStack"), topStackName: /* @__PURE__ */ __name(function() {
    return "stack" + this.stackSlot;
  }, "topStackName"), flushInline: /* @__PURE__ */ __name(function() {
    var q = this.inlineStack;
    this.inlineStack = [];
    for (var K = 0, P = q.length; K < P; K++) {
      var _ = q[K];
      if (_ instanceof L4) this.compileStack.push(_);
      else {
        var Y = this.incrStack();
        this.pushSource([Y, " = ", _, ";"]), this.compileStack.push(Y);
      }
    }
  }, "flushInline"), isInline: /* @__PURE__ */ __name(function() {
    return this.inlineStack.length;
  }, "isInline"), popStack: /* @__PURE__ */ __name(function(q) {
    var K = this.isInline(), P = (K ? this.inlineStack : this.compileStack).pop();
    if (!q && P instanceof L4) return P.value;
    else {
      if (!K) {
        if (!this.stackSlot) throw new wW.default("Invalid stack pop");
        this.stackSlot--;
      }
      return P;
    }
  }, "popStack"), topStack: /* @__PURE__ */ __name(function() {
    var q = this.isInline() ? this.inlineStack : this.compileStack, K = q[q.length - 1];
    if (K instanceof L4) return K.value;
    else return K;
  }, "topStack"), contextName: /* @__PURE__ */ __name(function(q) {
    if (this.useDepths && q) return "depths[" + q + "]";
    else return "depth" + q;
  }, "contextName"), quotedString: /* @__PURE__ */ __name(function(q) {
    return this.source.quotedString(q);
  }, "quotedString"), objectLiteral: /* @__PURE__ */ __name(function(q) {
    return this.source.objectLiteral(q);
  }, "objectLiteral"), aliasable: /* @__PURE__ */ __name(function(q) {
    var K = this.aliases[q];
    if (K) return K.referenceCount++, K;
    return K = this.aliases[q] = this.source.wrap(q), K.aliasable = true, K.referenceCount = 1, K;
  }, "aliasable"), setupHelper: /* @__PURE__ */ __name(function(q, K, P) {
    var _ = [], Y = this.setupHelperArgs(K, q, _, P), O = this.nameLookup("helpers", K, "helper"), z = this.aliasable(this.contextName(0) + " != null ? " + this.contextName(0) + " : (container.nullContext || {})");
    return { params: _, paramsInit: Y, name: O, callParams: [z].concat(_) };
  }, "setupHelper"), setupParams: /* @__PURE__ */ __name(function(q, K, P) {
    var _ = {}, Y = [], O = [], z = [], J = !P, T = void 0;
    if (J) P = [];
    if (_.name = this.quotedString(q), _.hash = this.popStack(), this.trackIds) _.hashIds = this.popStack();
    if (this.stringParams) _.hashTypes = this.popStack(), _.hashContexts = this.popStack();
    var X = this.popStack(), f = this.popStack();
    if (f || X) _.fn = f || "container.noop", _.inverse = X || "container.noop";
    var V = K;
    while (V--) {
      if (T = this.popStack(), P[V] = T, this.trackIds) z[V] = this.popStack();
      if (this.stringParams) O[V] = this.popStack(), Y[V] = this.popStack();
    }
    if (J) _.args = this.source.generateArray(P);
    if (this.trackIds) _.ids = this.source.generateArray(z);
    if (this.stringParams) _.types = this.source.generateArray(O), _.contexts = this.source.generateArray(Y);
    if (this.options.data) _.data = "data";
    if (this.useBlockParams) _.blockParams = "blockParams";
    return _;
  }, "setupParams"), setupHelperArgs: /* @__PURE__ */ __name(function(q, K, P, _) {
    var Y = this.setupParams(q, K, P);
    if (Y.loc = JSON.stringify(this.source.currentLocation), Y = this.objectLiteral(Y), _) return this.useRegister("options"), P.push("options"), ["options=", Y];
    else if (P) return P.push(Y), "";
    else return Y;
  }, "setupHelperArgs") };
  (function() {
    var $ = "break else new var case finally return void catch for switch while continue function this with default if throw delete in try do instanceof typeof abstract enum int short boolean export interface static byte extends long super char final native synchronized class float package throws const goto private transient debugger implements protected volatile double import public let yield await null true false".split(" "), q = g4.RESERVED_WORDS = {};
    for (var K = 0, P = $.length; K < P; K++) q[$[K]] = true;
  })();
  g4.isValidJavaScriptVariableName = function($) {
    return !g4.RESERVED_WORDS[$] && /^[a-zA-Z_$][0-9a-zA-Z_$]*$/.test($);
  };
  function km($, q, K, P, _) {
    var Y = q.popStack(), O = K.length;
    if ($) O--;
    for (; P < O; P++) Y = q.nameLookup(Y, K[P], _);
    if ($) return [q.aliasable("container.strict"), "(", Y, ", ", q.quotedString(K[P]), ", ", JSON.stringify(q.source.currentLocation), " )"];
    else return Y;
  }
  __name(km, "km");
  cG.default = g4;
  mG.exports = cG.default;
});
var nG = x$((rG, oG) => {
  rG.__esModule = true;
  function b7($) {
    return $ && $.__esModule ? $ : { default: $ };
  }
  __name(b7, "b7");
  var Sm = ok(), Mm = b7(Sm), Nm = iz(), Cm = b7(Nm), fW = YG(), ZW = WG(), hm = dG(), Em = b7(hm), Rm = h5(), Im = b7(Rm), Dm = lz(), Lm = b7(Dm), gm = Mm.default.create;
  function lG() {
    var $ = gm();
    return $.compile = function(q, K) {
      return ZW.compile(q, K, $);
    }, $.precompile = function(q, K) {
      return ZW.precompile(q, K, $);
    }, $.AST = Cm.default, $.Compiler = ZW.Compiler, $.JavaScriptCompiler = Em.default, $.Parser = fW.parser, $.parse = fW.parse, $.parseWithoutProcessing = fW.parseWithoutProcessing, $;
  }
  __name(lG, "lG");
  var b4 = lG();
  b4.create = lG;
  Lm.default(b4);
  b4.Visitor = Im.default;
  b4.default = b4;
  rG.default = b4;
  oG.exports = rG.default;
});
var iG = x$((mm) => {
  mm.__esModule = true;
  mm.print = cm;
  mm.PrintVisitor = d6;
  function um($) {
    return $ && $.__esModule ? $ : { default: $ };
  }
  __name(um, "um");
  var xm = h5(), pm = um(xm);
  function cm($) {
    return new d6().accept($);
  }
  __name(cm, "cm");
  function d6() {
    this.padding = 0;
  }
  __name(d6, "d6");
  d6.prototype = new pm.default();
  d6.prototype.pad = function($) {
    var q = "";
    for (var K = 0, P = this.padding; K < P; K++) q += "  ";
    return q += $ + `
`, q;
  };
  d6.prototype.Program = function($) {
    var q = "", K = $.body, P = void 0, _ = void 0;
    if ($.blockParams) {
      var Y = "BLOCK PARAMS: [";
      for (P = 0, _ = $.blockParams.length; P < _; P++) Y += " " + $.blockParams[P];
      Y += " ]", q += this.pad(Y);
    }
    for (P = 0, _ = K.length; P < _; P++) q += this.accept(K[P]);
    return this.padding--, q;
  };
  d6.prototype.MustacheStatement = function($) {
    return this.pad("{{ " + this.SubExpression($) + " }}");
  };
  d6.prototype.Decorator = function($) {
    return this.pad("{{ DIRECTIVE " + this.SubExpression($) + " }}");
  };
  d6.prototype.BlockStatement = d6.prototype.DecoratorBlock = function($) {
    var q = "";
    if (q += this.pad(($.type === "DecoratorBlock" ? "DIRECTIVE " : "") + "BLOCK:"), this.padding++, q += this.pad(this.SubExpression($)), $.program) q += this.pad("PROGRAM:"), this.padding++, q += this.accept($.program), this.padding--;
    if ($.inverse) {
      if ($.program) this.padding++;
      if (q += this.pad("{{^}}"), this.padding++, q += this.accept($.inverse), this.padding--, $.program) this.padding--;
    }
    return this.padding--, q;
  };
  d6.prototype.PartialStatement = function($) {
    var q = "PARTIAL:" + $.name.original;
    if ($.params[0]) q += " " + this.accept($.params[0]);
    if ($.hash) q += " " + this.accept($.hash);
    return this.pad("{{> " + q + " }}");
  };
  d6.prototype.PartialBlockStatement = function($) {
    var q = "PARTIAL BLOCK:" + $.name.original;
    if ($.params[0]) q += " " + this.accept($.params[0]);
    if ($.hash) q += " " + this.accept($.hash);
    return q += " " + this.pad("PROGRAM:"), this.padding++, q += this.accept($.program), this.padding--, this.pad("{{> " + q + " }}");
  };
  d6.prototype.ContentStatement = function($) {
    return this.pad("CONTENT[ '" + $.value + "' ]");
  };
  d6.prototype.CommentStatement = function($) {
    return this.pad("{{! '" + $.value + "' }}");
  };
  d6.prototype.SubExpression = function($) {
    var q = $.params, K = [], P = void 0;
    for (var _ = 0, Y = q.length; _ < Y; _++) K.push(this.accept(q[_]));
    return q = "[" + K.join(", ") + "]", P = $.hash ? " " + this.accept($.hash) : "", this.accept($.path) + " " + q + P;
  };
  d6.prototype.PathExpression = function($) {
    var q = $.parts.join("/");
    return ($.data ? "@" : "") + "PATH:" + q;
  };
  d6.prototype.StringLiteral = function($) {
    return '"' + $.value + '"';
  };
  d6.prototype.NumberLiteral = function($) {
    return "NUMBER{" + $.value + "}";
  };
  d6.prototype.BooleanLiteral = function($) {
    return "BOOLEAN{" + $.value + "}";
  };
  d6.prototype.UndefinedLiteral = function() {
    return "UNDEFINED";
  };
  d6.prototype.NullLiteral = function() {
    return "NULL";
  };
  d6.prototype.Hash = function($) {
    var q = $.pairs, K = [];
    for (var P = 0, _ = q.length; P < _; P++) K.push(this.accept(q[P]));
    return "HASH{" + K.join(", ") + "}";
  };
  d6.prototype.HashPair = function($) {
    return $.key + "=" + this.accept($.value);
  };
});
var FG = x$((zP$, UG) => {
  var L5 = nG().default, BG = iG();
  L5.PrintVisitor = BG.PrintVisitor;
  L5.print = BG.print;
  UG.exports = L5;
  function tG($, q) {
    var K = /* @__PURE__ */ __name((() => ({})), "K"), P = K.readFileSync(q, "utf8");
    $.exports = L5.compile(P);
  }
  __name(tG, "tG");
  if (c8.extensions) c8.extensions[".handlebars"] = tG, c8.extensions[".hbs"] = tG;
});
var JH = {};
rq(JH, { sep: /* @__PURE__ */ __name(() => eV, "sep"), resolve: /* @__PURE__ */ __name(() => U5, "resolve"), relative: /* @__PURE__ */ __name(() => iV, "relative"), posix: /* @__PURE__ */ __name(() => $S, "posix"), parse: /* @__PURE__ */ __name(() => QV, "parse"), normalize: /* @__PURE__ */ __name(() => HH, "normalize"), join: /* @__PURE__ */ __name(() => nV, "join"), isAbsolute: /* @__PURE__ */ __name(() => oV, "isAbsolute"), format: /* @__PURE__ */ __name(() => aV, "format"), extname: /* @__PURE__ */ __name(() => FV, "extname"), dirname: /* @__PURE__ */ __name(() => BV, "dirname"), delimiter: /* @__PURE__ */ __name(() => sV, "delimiter"), default: /* @__PURE__ */ __name(() => Wl, "default"), basename: /* @__PURE__ */ __name(() => UV, "basename"), _makeLong: /* @__PURE__ */ __name(() => tV, "_makeLong") });
function e8($) {
  if (typeof $ !== "string") throw TypeError("Path must be a string. Received " + JSON.stringify($));
}
__name(e8, "e8");
function rV($, q) {
  var K = "", P = 0, _ = -1, Y = 0, O;
  for (var z = 0; z <= $.length; ++z) {
    if (z < $.length) O = $.charCodeAt(z);
    else if (O === 47) break;
    else O = 47;
    if (O === 47) {
      if (_ === z - 1 || Y === 1) ;
      else if (_ !== z - 1 && Y === 2) {
        if (K.length < 2 || P !== 2 || K.charCodeAt(K.length - 1) !== 46 || K.charCodeAt(K.length - 2) !== 46) {
          if (K.length > 2) {
            var J = K.lastIndexOf("/");
            if (J !== K.length - 1) {
              if (J === -1) K = "", P = 0;
              else K = K.slice(0, J), P = K.length - 1 - K.lastIndexOf("/");
              _ = z, Y = 0;
              continue;
            }
          } else if (K.length === 2 || K.length === 1) {
            K = "", P = 0, _ = z, Y = 0;
            continue;
          }
        }
        if (q) {
          if (K.length > 0) K += "/..";
          else K = "..";
          P = 2;
        }
      } else {
        if (K.length > 0) K += "/" + $.slice(_ + 1, z);
        else K = $.slice(_ + 1, z);
        P = z - _ - 1;
      }
      _ = z, Y = 0;
    } else if (O === 46 && Y !== -1) ++Y;
    else Y = -1;
  }
  return K;
}
__name(rV, "rV");
function zl($, q) {
  var K = q.dir || q.root, P = q.base || (q.name || "") + (q.ext || "");
  if (!K) return P;
  if (K === q.root) return K + P;
  return K + $ + P;
}
__name(zl, "zl");
function U5() {
  var $ = "", q = false, K;
  for (var P = arguments.length - 1; P >= -1 && !q; P--) {
    var _;
    if (P >= 0) _ = arguments[P];
    else {
      if (K === void 0) K = process.cwd();
      _ = K;
    }
    if (e8(_), _.length === 0) continue;
    $ = _ + "/" + $, q = _.charCodeAt(0) === 47;
  }
  if ($ = rV($, !q), q) if ($.length > 0) return "/" + $;
  else return "/";
  else if ($.length > 0) return $;
  else return ".";
}
__name(U5, "U5");
function HH($) {
  if (e8($), $.length === 0) return ".";
  var q = $.charCodeAt(0) === 47, K = $.charCodeAt($.length - 1) === 47;
  if ($ = rV($, !q), $.length === 0 && !q) $ = ".";
  if ($.length > 0 && K) $ += "/";
  if (q) return "/" + $;
  return $;
}
__name(HH, "HH");
function oV($) {
  return e8($), $.length > 0 && $.charCodeAt(0) === 47;
}
__name(oV, "oV");
function nV() {
  if (arguments.length === 0) return ".";
  var $;
  for (var q = 0; q < arguments.length; ++q) {
    var K = arguments[q];
    if (e8(K), K.length > 0) if ($ === void 0) $ = K;
    else $ += "/" + K;
  }
  if ($ === void 0) return ".";
  return HH($);
}
__name(nV, "nV");
function iV($, q) {
  if (e8($), e8(q), $ === q) return "";
  if ($ = U5($), q = U5(q), $ === q) return "";
  var K = 1;
  for (; K < $.length; ++K) if ($.charCodeAt(K) !== 47) break;
  var P = $.length, _ = P - K, Y = 1;
  for (; Y < q.length; ++Y) if (q.charCodeAt(Y) !== 47) break;
  var O = q.length, z = O - Y, J = _ < z ? _ : z, T = -1, X = 0;
  for (; X <= J; ++X) {
    if (X === J) {
      if (z > J) {
        if (q.charCodeAt(Y + X) === 47) return q.slice(Y + X + 1);
        else if (X === 0) return q.slice(Y + X);
      } else if (_ > J) {
        if ($.charCodeAt(K + X) === 47) T = X;
        else if (X === 0) T = 0;
      }
      break;
    }
    var f = $.charCodeAt(K + X), V = q.charCodeAt(Y + X);
    if (f !== V) break;
    else if (f === 47) T = X;
  }
  var M = "";
  for (X = K + T + 1; X <= P; ++X) if (X === P || $.charCodeAt(X) === 47) if (M.length === 0) M += "..";
  else M += "/..";
  if (M.length > 0) return M + q.slice(Y + T);
  else {
    if (Y += T, q.charCodeAt(Y) === 47) ++Y;
    return q.slice(Y);
  }
}
__name(iV, "iV");
function tV($) {
  return $;
}
__name(tV, "tV");
function BV($) {
  if (e8($), $.length === 0) return ".";
  var q = $.charCodeAt(0), K = q === 47, P = -1, _ = true;
  for (var Y = $.length - 1; Y >= 1; --Y) if (q = $.charCodeAt(Y), q === 47) {
    if (!_) {
      P = Y;
      break;
    }
  } else _ = false;
  if (P === -1) return K ? "/" : ".";
  if (K && P === 1) return "//";
  return $.slice(0, P);
}
__name(BV, "BV");
function UV($, q) {
  if (q !== void 0 && typeof q !== "string") throw TypeError('"ext" argument must be a string');
  e8($);
  var K = 0, P = -1, _ = true, Y;
  if (q !== void 0 && q.length > 0 && q.length <= $.length) {
    if (q.length === $.length && q === $) return "";
    var O = q.length - 1, z = -1;
    for (Y = $.length - 1; Y >= 0; --Y) {
      var J = $.charCodeAt(Y);
      if (J === 47) {
        if (!_) {
          K = Y + 1;
          break;
        }
      } else {
        if (z === -1) _ = false, z = Y + 1;
        if (O >= 0) if (J === q.charCodeAt(O)) {
          if (--O === -1) P = Y;
        } else O = -1, P = z;
      }
    }
    if (K === P) P = z;
    else if (P === -1) P = $.length;
    return $.slice(K, P);
  } else {
    for (Y = $.length - 1; Y >= 0; --Y) if ($.charCodeAt(Y) === 47) {
      if (!_) {
        K = Y + 1;
        break;
      }
    } else if (P === -1) _ = false, P = Y + 1;
    if (P === -1) return "";
    return $.slice(K, P);
  }
}
__name(UV, "UV");
function FV($) {
  e8($);
  var q = -1, K = 0, P = -1, _ = true, Y = 0;
  for (var O = $.length - 1; O >= 0; --O) {
    var z = $.charCodeAt(O);
    if (z === 47) {
      if (!_) {
        K = O + 1;
        break;
      }
      continue;
    }
    if (P === -1) _ = false, P = O + 1;
    if (z === 46) {
      if (q === -1) q = O;
      else if (Y !== 1) Y = 1;
    } else if (q !== -1) Y = -1;
  }
  if (q === -1 || P === -1 || Y === 0 || Y === 1 && q === P - 1 && q === K + 1) return "";
  return $.slice(q, P);
}
__name(FV, "FV");
function aV($) {
  if ($ === null || typeof $ !== "object") throw TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof $);
  return zl("/", $);
}
__name(aV, "aV");
function QV($) {
  e8($);
  var q = { root: "", dir: "", base: "", ext: "", name: "" };
  if ($.length === 0) return q;
  var K = $.charCodeAt(0), P = K === 47, _;
  if (P) q.root = "/", _ = 1;
  else _ = 0;
  var Y = -1, O = 0, z = -1, J = true, T = $.length - 1, X = 0;
  for (; T >= _; --T) {
    if (K = $.charCodeAt(T), K === 47) {
      if (!J) {
        O = T + 1;
        break;
      }
      continue;
    }
    if (z === -1) J = false, z = T + 1;
    if (K === 46) {
      if (Y === -1) Y = T;
      else if (X !== 1) X = 1;
    } else if (Y !== -1) X = -1;
  }
  if (Y === -1 || z === -1 || X === 0 || X === 1 && Y === z - 1 && Y === O + 1) {
    if (z !== -1) if (O === 0 && P) q.base = q.name = $.slice(1, z);
    else q.base = q.name = $.slice(O, z);
  } else {
    if (O === 0 && P) q.name = $.slice(1, Y), q.base = $.slice(1, z);
    else q.name = $.slice(O, Y), q.base = $.slice(O, z);
    q.ext = $.slice(Y, z);
  }
  if (O > 0) q.dir = $.slice(0, O - 1);
  else if (P) q.dir = "/";
  return q;
}
__name(QV, "QV");
var eV = "/";
var sV = ":";
var $S;
var Wl;
var TH = m_(() => {
  $S = (($) => ($.posix = $, $))({ resolve: U5, normalize: HH, isAbsolute: oV, join: nV, relative: iV, _makeLong: tV, dirname: BV, basename: UV, extname: FV, format: aV, parse: QV, sep: eV, delimiter: sV, win32: null, posix: null }), Wl = $S;
});
var wH = {};
rq(wH, { uptime: /* @__PURE__ */ __name(() => wl, "uptime"), type: /* @__PURE__ */ __name(() => Al, "type"), totalmem: /* @__PURE__ */ __name(() => Zl, "totalmem"), tmpdir: /* @__PURE__ */ __name(() => KS, "tmpdir"), tmpDir: /* @__PURE__ */ __name(() => Ml, "tmpDir"), release: /* @__PURE__ */ __name(() => kl, "release"), platform: /* @__PURE__ */ __name(() => Sl, "platform"), networkInterfaces: /* @__PURE__ */ __name(() => Gl, "networkInterfaces"), loadavg: /* @__PURE__ */ __name(() => Tl, "loadavg"), hostname: /* @__PURE__ */ __name(() => Jl, "hostname"), homedir: /* @__PURE__ */ __name(() => Cl, "homedir"), getNetworkInterfaces: /* @__PURE__ */ __name(() => qS, "getNetworkInterfaces"), freemem: /* @__PURE__ */ __name(() => fl, "freemem"), endianness: /* @__PURE__ */ __name(() => Hl, "endianness"), cpus: /* @__PURE__ */ __name(() => Xl, "cpus"), arch: /* @__PURE__ */ __name(() => Vl, "arch"), EOL: /* @__PURE__ */ __name(() => Nl, "EOL") });
var Hl = /* @__PURE__ */ __name(function() {
  return "LE";
}, "Hl");
var Jl = /* @__PURE__ */ __name(function() {
  if (typeof location < "u") return location.hostname;
  else return "";
}, "Jl");
var Tl = /* @__PURE__ */ __name(function() {
  return [];
}, "Tl");
var wl = /* @__PURE__ */ __name(function() {
  return 0;
}, "wl");
var fl = /* @__PURE__ */ __name(function() {
  return Number.MAX_VALUE;
}, "fl");
var Zl = /* @__PURE__ */ __name(function() {
  return Number.MAX_VALUE;
}, "Zl");
var Xl = /* @__PURE__ */ __name(function() {
  return [];
}, "Xl");
var Al = /* @__PURE__ */ __name(function() {
  return "Browser";
}, "Al");
var kl = /* @__PURE__ */ __name(function() {
  if (typeof navigator < "u") return navigator.appVersion;
  return "";
}, "kl");
var qS = /* @__PURE__ */ __name(function() {
  return {};
}, "qS");
var Gl;
var Vl = /* @__PURE__ */ __name(function() {
  return "javascript";
}, "Vl");
var Sl = /* @__PURE__ */ __name(function() {
  return "browser";
}, "Sl");
var KS = /* @__PURE__ */ __name(function() {
  return "/tmp";
}, "KS");
var Ml;
var Nl = `
`;
var Cl = /* @__PURE__ */ __name(function() {
  return "/";
}, "Cl");
var fH = m_(() => {
  Gl = qS, Ml = KS;
});
var wq = {};
rq(wq, { transcode: /* @__PURE__ */ __name(() => Wr, "transcode"), resolveObjectURL: /* @__PURE__ */ __name(() => jr, "resolveObjectURL"), kStringMaxLength: /* @__PURE__ */ __name(() => HS, "kStringMaxLength"), kMaxLength: /* @__PURE__ */ __name(() => d7, "kMaxLength"), isUtf8: /* @__PURE__ */ __name(() => vr, "isUtf8"), isAscii: /* @__PURE__ */ __name(() => zr, "isAscii"), default: /* @__PURE__ */ __name(() => Hr, "default"), constants: /* @__PURE__ */ __name(() => ul, "constants"), btoa: /* @__PURE__ */ __name(() => Ll, "btoa"), atob: /* @__PURE__ */ __name(() => gl, "atob"), INSPECT_MAX_BYTES: /* @__PURE__ */ __name(() => WS, "INSPECT_MAX_BYTES"), File: /* @__PURE__ */ __name(() => bl, "File"), Buffer: /* @__PURE__ */ __name(() => w$, "Buffer"), Blob: /* @__PURE__ */ __name(() => yl, "Blob") });
function hl($) {
  var q = $.length;
  if (q % 4 > 0) throw Error("Invalid string. Length must be a multiple of 4");
  var K = $.indexOf("=");
  if (K === -1) K = q;
  var P = K === q ? 0 : 4 - K % 4;
  return [K, P];
}
__name(hl, "hl");
function El($, q) {
  return ($ + q) * 3 / 4 - q;
}
__name(El, "El");
function Rl($) {
  var q, K = hl($), P = K[0], _ = K[1], Y = new Uint8Array(El(P, _)), O = 0, z = _ > 0 ? P - 4 : P, J;
  for (J = 0; J < z; J += 4) q = S8[$.charCodeAt(J)] << 18 | S8[$.charCodeAt(J + 1)] << 12 | S8[$.charCodeAt(J + 2)] << 6 | S8[$.charCodeAt(J + 3)], Y[O++] = q >> 16 & 255, Y[O++] = q >> 8 & 255, Y[O++] = q & 255;
  if (_ === 2) q = S8[$.charCodeAt(J)] << 2 | S8[$.charCodeAt(J + 1)] >> 4, Y[O++] = q & 255;
  if (_ === 1) q = S8[$.charCodeAt(J)] << 10 | S8[$.charCodeAt(J + 1)] << 4 | S8[$.charCodeAt(J + 2)] >> 2, Y[O++] = q >> 8 & 255, Y[O++] = q & 255;
  return Y;
}
__name(Rl, "Rl");
function Il($) {
  return s8[$ >> 18 & 63] + s8[$ >> 12 & 63] + s8[$ >> 6 & 63] + s8[$ & 63];
}
__name(Il, "Il");
function Dl($, q, K) {
  var P, _ = [];
  for (var Y = q; Y < K; Y += 3) P = ($[Y] << 16 & 16711680) + ($[Y + 1] << 8 & 65280) + ($[Y + 2] & 255), _.push(Il(P));
  return _.join("");
}
__name(Dl, "Dl");
function PS($) {
  var q, K = $.length, P = K % 3, _ = [], Y = 16383;
  for (var O = 0, z = K - P; O < z; O += Y) _.push(Dl($, O, O + Y > z ? z : O + Y));
  if (P === 1) q = $[K - 1], _.push(s8[q >> 2] + s8[q << 4 & 63] + "==");
  else if (P === 2) q = ($[K - 2] << 8) + $[K - 1], _.push(s8[q >> 10] + s8[q >> 4 & 63] + s8[q << 2 & 63] + "=");
  return _.join("");
}
__name(PS, "PS");
function F5($, q, K, P, _) {
  var Y, O, z = _ * 8 - P - 1, J = (1 << z) - 1, T = J >> 1, X = -7, f = K ? _ - 1 : 0, V = K ? -1 : 1, M = $[q + f];
  f += V, Y = M & (1 << -X) - 1, M >>= -X, X += z;
  for (; X > 0; Y = Y * 256 + $[q + f], f += V, X -= 8) ;
  O = Y & (1 << -X) - 1, Y >>= -X, X += P;
  for (; X > 0; O = O * 256 + $[q + f], f += V, X -= 8) ;
  if (Y === 0) Y = 1 - T;
  else if (Y === J) return O ? NaN : (M ? -1 : 1) * (1 / 0);
  else O = O + Math.pow(2, P), Y = Y - T;
  return (M ? -1 : 1) * O * Math.pow(2, Y - P);
}
__name(F5, "F5");
function zS($, q, K, P, _, Y) {
  var O, z, J, T = Y * 8 - _ - 1, X = (1 << T) - 1, f = X >> 1, V = _ === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, M = P ? 0 : Y - 1, N = P ? 1 : -1, E = q < 0 || q === 0 && 1 / q < 0 ? 1 : 0;
  if (q = Math.abs(q), isNaN(q) || q === 1 / 0) z = isNaN(q) ? 1 : 0, O = X;
  else {
    if (O = Math.floor(Math.log(q) / Math.LN2), q * (J = Math.pow(2, -O)) < 1) O--, J *= 2;
    if (O + f >= 1) q += V / J;
    else q += V * Math.pow(2, 1 - f);
    if (q * J >= 2) O++, J /= 2;
    if (O + f >= X) z = 0, O = X;
    else if (O + f >= 1) z = (q * J - 1) * Math.pow(2, _), O = O + f;
    else z = q * Math.pow(2, f - 1) * Math.pow(2, _), O = 0;
  }
  for (; _ >= 8; $[K + M] = z & 255, M += N, z /= 256, _ -= 8) ;
  O = O << _ | z, T += _;
  for (; T > 0; $[K + M] = O & 255, M += N, O /= 256, T -= 8) ;
  $[K + M - N] |= E * 128;
}
__name(zS, "zS");
function SK($) {
  if ($ > d7) throw RangeError('The value "' + $ + '" is invalid for option "size"');
  let q = new Uint8Array($);
  return Object.setPrototypeOf(q, w$.prototype), q;
}
__name(SK, "SK");
function VH($, q, K) {
  return class extends K {
    constructor() {
      super();
      Object.defineProperty(this, "message", { value: q.apply(this, arguments), writable: true, configurable: true }), this.name = `${this.name} [${$}]`, this.stack, delete this.name;
    }
    get code() {
      return $;
    }
    set code(P) {
      Object.defineProperty(this, "code", { configurable: true, enumerable: true, value: P, writable: true });
    }
    toString() {
      return `${this.name} [${$}]: ${this.message}`;
    }
  };
}
__name(VH, "VH");
function w$($, q, K) {
  if (typeof $ === "number") {
    if (typeof q === "string") throw TypeError('The "string" argument must be of type string. Received type number');
    return SH($);
  }
  return JS($, q, K);
}
__name(w$, "w$");
function JS($, q, K) {
  if (typeof $ === "string") return ml($, q);
  if (ArrayBuffer.isView($)) return dl($);
  if ($ == null) throw TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof $);
  if ($K($, ArrayBuffer) || $ && $K($.buffer, ArrayBuffer)) return kH($, q, K);
  if (typeof SharedArrayBuffer < "u" && ($K($, SharedArrayBuffer) || $ && $K($.buffer, SharedArrayBuffer))) return kH($, q, K);
  if (typeof $ === "number") throw TypeError('The "value" argument must not be of type number. Received type number');
  let P = $.valueOf && $.valueOf();
  if (P != null && P !== $) return w$.from(P, q, K);
  let _ = ll($);
  if (_) return _;
  if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof $[Symbol.toPrimitive] === "function") return w$.from($[Symbol.toPrimitive]("string"), q, K);
  throw TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof $);
}
__name(JS, "JS");
function TS($) {
  if (typeof $ !== "number") throw TypeError('"size" argument must be of type number');
  else if ($ < 0) throw RangeError('The value "' + $ + '" is invalid for option "size"');
}
__name(TS, "TS");
function cl($, q, K) {
  if (TS($), $ <= 0) return SK($);
  if (q !== void 0) return typeof K === "string" ? SK($).fill(q, K) : SK($).fill(q);
  return SK($);
}
__name(cl, "cl");
function SH($) {
  return TS($), SK($ < 0 ? 0 : MH($) | 0);
}
__name(SH, "SH");
function ml($, q) {
  if (typeof q !== "string" || q === "") q = "utf8";
  if (!w$.isEncoding(q)) throw TypeError("Unknown encoding: " + q);
  let K = wS($, q) | 0, P = SK(K), _ = P.write($, q);
  if (_ !== K) P = P.slice(0, _);
  return P;
}
__name(ml, "ml");
function AH($) {
  let q = $.length < 0 ? 0 : MH($.length) | 0, K = SK(q);
  for (let P = 0; P < q; P += 1) K[P] = $[P] & 255;
  return K;
}
__name(AH, "AH");
function dl($) {
  if ($K($, Uint8Array)) {
    let q = new Uint8Array($);
    return kH(q.buffer, q.byteOffset, q.byteLength);
  }
  return AH($);
}
__name(dl, "dl");
function kH($, q, K) {
  if (q < 0 || $.byteLength < q) throw RangeError('"offset" is outside of buffer bounds');
  if ($.byteLength < q + (K || 0)) throw RangeError('"length" is outside of buffer bounds');
  let P;
  if (q === void 0 && K === void 0) P = new Uint8Array($);
  else if (K === void 0) P = new Uint8Array($, q);
  else P = new Uint8Array($, q, K);
  return Object.setPrototypeOf(P, w$.prototype), P;
}
__name(kH, "kH");
function ll($) {
  if (w$.isBuffer($)) {
    let q = MH($.length) | 0, K = SK(q);
    if (K.length === 0) return K;
    return $.copy(K, 0, 0, q), K;
  }
  if ($.length !== void 0) {
    if (typeof $.length !== "number" || Number.isNaN($.length)) return SK(0);
    return AH($);
  }
  if ($.type === "Buffer" && Array.isArray($.data)) return AH($.data);
}
__name(ll, "ll");
function MH($) {
  if ($ >= d7) throw RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + d7.toString(16) + " bytes");
  return $ | 0;
}
__name(MH, "MH");
function wS($, q) {
  if (w$.isBuffer($)) return $.length;
  if (ArrayBuffer.isView($) || $K($, ArrayBuffer)) return $.byteLength;
  if (typeof $ !== "string") throw TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof $);
  let K = $.length, P = arguments.length > 2 && arguments[2] === true;
  if (!P && K === 0) return 0;
  let _ = false;
  for (; ; ) switch (q) {
    case "ascii":
    case "latin1":
    case "binary":
      return K;
    case "utf8":
    case "utf-8":
      return GH($).length;
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
      return K * 2;
    case "hex":
      return K >>> 1;
    case "base64":
      return MS($).length;
    default:
      if (_) return P ? -1 : GH($).length;
      q = ("" + q).toLowerCase(), _ = true;
  }
}
__name(wS, "wS");
function rl($, q, K) {
  let P = false;
  if (q === void 0 || q < 0) q = 0;
  if (q > this.length) return "";
  if (K === void 0 || K > this.length) K = this.length;
  if (K <= 0) return "";
  if (K >>>= 0, q >>>= 0, K <= q) return "";
  if (!$) $ = "utf8";
  while (true) switch ($) {
    case "hex":
      return el(this, q, K);
    case "utf8":
    case "utf-8":
      return ZS(this, q, K);
    case "ascii":
      return al(this, q, K);
    case "latin1":
    case "binary":
      return Ql(this, q, K);
    case "base64":
      return Ul(this, q, K);
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
      return sl(this, q, K);
    default:
      if (P) throw TypeError("Unknown encoding: " + $);
      $ = ($ + "").toLowerCase(), P = true;
  }
}
__name(rl, "rl");
function g_($, q, K) {
  let P = $[q];
  $[q] = $[K], $[K] = P;
}
__name(g_, "g_");
function fS($, q, K, P, _) {
  if ($.length === 0) return -1;
  if (typeof K === "string") P = K, K = 0;
  else if (K > 2147483647) K = 2147483647;
  else if (K < -2147483648) K = -2147483648;
  if (K = +K, Number.isNaN(K)) K = _ ? 0 : $.length - 1;
  if (K < 0) K = $.length + K;
  if (K >= $.length) if (_) return -1;
  else K = $.length - 1;
  else if (K < 0) if (_) K = 0;
  else return -1;
  if (typeof q === "string") q = w$.from(q, P);
  if (w$.isBuffer(q)) {
    if (q.length === 0) return -1;
    return YS($, q, K, P, _);
  } else if (typeof q === "number") {
    if (q = q & 255, typeof Uint8Array.prototype.indexOf === "function") if (_) return Uint8Array.prototype.indexOf.call($, q, K);
    else return Uint8Array.prototype.lastIndexOf.call($, q, K);
    return YS($, [q], K, P, _);
  }
  throw TypeError("val must be string, number or Buffer");
}
__name(fS, "fS");
function YS($, q, K, P, _) {
  let Y = 1, O = $.length, z = q.length;
  if (P !== void 0) {
    if (P = String(P).toLowerCase(), P === "ucs2" || P === "ucs-2" || P === "utf16le" || P === "utf-16le") {
      if ($.length < 2 || q.length < 2) return -1;
      Y = 2, O /= 2, z /= 2, K /= 2;
    }
  }
  function J(X, f) {
    if (Y === 1) return X[f];
    else return X.readUInt16BE(f * Y);
  }
  __name(J, "J");
  let T;
  if (_) {
    let X = -1;
    for (T = K; T < O; T++) if (J($, T) === J(q, X === -1 ? 0 : T - X)) {
      if (X === -1) X = T;
      if (T - X + 1 === z) return X * Y;
    } else {
      if (X !== -1) T -= T - X;
      X = -1;
    }
  } else {
    if (K + z > O) K = O - z;
    for (T = K; T >= 0; T--) {
      let X = true;
      for (let f = 0; f < z; f++) if (J($, T + f) !== J(q, f)) {
        X = false;
        break;
      }
      if (X) return T;
    }
  }
  return -1;
}
__name(YS, "YS");
function ol($, q, K, P) {
  K = Number(K) || 0;
  let _ = $.length - K;
  if (!P) P = _;
  else if (P = Number(P), P > _) P = _;
  let Y = q.length;
  if (P > Y / 2) P = Y / 2;
  let O;
  for (O = 0; O < P; ++O) {
    let z = parseInt(q.substr(O * 2, 2), 16);
    if (Number.isNaN(z)) return O;
    $[K + O] = z;
  }
  return O;
}
__name(ol, "ol");
function nl($, q, K, P) {
  return a5(GH(q, $.length - K), $, K, P);
}
__name(nl, "nl");
function il($, q, K, P) {
  return a5(_r(q), $, K, P);
}
__name(il, "il");
function tl($, q, K, P) {
  return a5(MS(q), $, K, P);
}
__name(tl, "tl");
function Bl($, q, K, P) {
  return a5(Pr(q, $.length - K), $, K, P);
}
__name(Bl, "Bl");
function Ul($, q, K) {
  if (q === 0 && K === $.length) return PS($);
  else return PS($.slice(q, K));
}
__name(Ul, "Ul");
function ZS($, q, K) {
  K = Math.min($.length, K);
  let P = [], _ = q;
  while (_ < K) {
    let Y = $[_], O = null, z = Y > 239 ? 4 : Y > 223 ? 3 : Y > 191 ? 2 : 1;
    if (_ + z <= K) {
      let J, T, X, f;
      switch (z) {
        case 1:
          if (Y < 128) O = Y;
          break;
        case 2:
          if (J = $[_ + 1], (J & 192) === 128) {
            if (f = (Y & 31) << 6 | J & 63, f > 127) O = f;
          }
          break;
        case 3:
          if (J = $[_ + 1], T = $[_ + 2], (J & 192) === 128 && (T & 192) === 128) {
            if (f = (Y & 15) << 12 | (J & 63) << 6 | T & 63, f > 2047 && (f < 55296 || f > 57343)) O = f;
          }
          break;
        case 4:
          if (J = $[_ + 1], T = $[_ + 2], X = $[_ + 3], (J & 192) === 128 && (T & 192) === 128 && (X & 192) === 128) {
            if (f = (Y & 15) << 18 | (J & 63) << 12 | (T & 63) << 6 | X & 63, f > 65535 && f < 1114112) O = f;
          }
      }
    }
    if (O === null) O = 65533, z = 1;
    else if (O > 65535) O -= 65536, P.push(O >>> 10 & 1023 | 55296), O = 56320 | O & 1023;
    P.push(O), _ += z;
  }
  return Fl(P);
}
__name(ZS, "ZS");
function Fl($) {
  let q = $.length;
  if (q <= jS) return String.fromCharCode.apply(String, $);
  let K = "", P = 0;
  while (P < q) K += String.fromCharCode.apply(String, $.slice(P, P += jS));
  return K;
}
__name(Fl, "Fl");
function al($, q, K) {
  let P = "";
  K = Math.min($.length, K);
  for (let _ = q; _ < K; ++_) P += String.fromCharCode($[_] & 127);
  return P;
}
__name(al, "al");
function Ql($, q, K) {
  let P = "";
  K = Math.min($.length, K);
  for (let _ = q; _ < K; ++_) P += String.fromCharCode($[_]);
  return P;
}
__name(Ql, "Ql");
function el($, q, K) {
  let P = $.length;
  if (!q || q < 0) q = 0;
  if (!K || K < 0 || K > P) K = P;
  let _ = "";
  for (let Y = q; Y < K; ++Y) _ += Or[$[Y]];
  return _;
}
__name(el, "el");
function sl($, q, K) {
  let P = $.slice(q, K), _ = "";
  for (let Y = 0; Y < P.length - 1; Y += 2) _ += String.fromCharCode(P[Y] + P[Y + 1] * 256);
  return _;
}
__name(sl, "sl");
function Tq($, q, K) {
  if ($ % 1 !== 0 || $ < 0) throw RangeError("offset is not uint");
  if ($ + q > K) throw RangeError("Trying to access beyond buffer length");
}
__name(Tq, "Tq");
function sq($, q, K, P, _, Y) {
  if (!w$.isBuffer($)) throw TypeError('"buffer" argument must be a Buffer instance');
  if (q > _ || q < Y) throw RangeError('"value" argument is out of bounds');
  if (K + P > $.length) throw RangeError("Index out of range");
}
__name(sq, "sq");
function XS($, q, K, P, _) {
  SS(q, P, _, $, K, 7);
  let Y = Number(q & BigInt(4294967295));
  $[K++] = Y, Y = Y >> 8, $[K++] = Y, Y = Y >> 8, $[K++] = Y, Y = Y >> 8, $[K++] = Y;
  let O = Number(q >> BigInt(32) & BigInt(4294967295));
  return $[K++] = O, O = O >> 8, $[K++] = O, O = O >> 8, $[K++] = O, O = O >> 8, $[K++] = O, K;
}
__name(XS, "XS");
function AS($, q, K, P, _) {
  SS(q, P, _, $, K, 7);
  let Y = Number(q & BigInt(4294967295));
  $[K + 7] = Y, Y = Y >> 8, $[K + 6] = Y, Y = Y >> 8, $[K + 5] = Y, Y = Y >> 8, $[K + 4] = Y;
  let O = Number(q >> BigInt(32) & BigInt(4294967295));
  return $[K + 3] = O, O = O >> 8, $[K + 2] = O, O = O >> 8, $[K + 1] = O, O = O >> 8, $[K] = O, K + 8;
}
__name(AS, "AS");
function kS($, q, K, P, _, Y) {
  if (K + P > $.length) throw RangeError("Index out of range");
  if (K < 0) throw RangeError("Index out of range");
}
__name(kS, "kS");
function GS($, q, K, P, _) {
  if (q = +q, K = K >>> 0, !_) kS($, q, K, 4, 34028234663852886e22, -34028234663852886e22);
  return zS($, q, K, P, 23, 4), K + 4;
}
__name(GS, "GS");
function VS($, q, K, P, _) {
  if (q = +q, K = K >>> 0, !_) kS($, q, K, 8, 17976931348623157e292, -17976931348623157e292);
  return zS($, q, K, P, 52, 8), K + 8;
}
__name(VS, "VS");
function vS($) {
  let q = "", K = $.length, P = $[0] === "-" ? 1 : 0;
  for (; K >= P + 4; K -= 3) q = `_${$.slice(K - 3, K)}${q}`;
  return `${$.slice(0, K)}${q}`;
}
__name(vS, "vS");
function $r($, q, K) {
  if (x4(q, "offset"), $[q] === void 0 || $[q + K] === void 0) l7(q, $.length - (K + 1));
}
__name($r, "$r");
function SS($, q, K, P, _, Y) {
  if ($ > K || $ < q) {
    let O = typeof q === "bigint" ? "n" : "", z;
    if (Y > 3) if (q === 0 || q === BigInt(0)) z = `>= 0${O} and < 2${O} ** ${(Y + 1) * 8}${O}`;
    else z = `>= -(2${O} ** ${(Y + 1) * 8 - 1}${O}) and < 2 ** ${(Y + 1) * 8 - 1}${O}`;
    else z = `>= ${q}${O} and <= ${K}${O}`;
    throw new XH("value", z, $);
  }
  $r(P, _, Y);
}
__name(SS, "SS");
function x4($, q) {
  if (typeof $ !== "number") throw new pl(q, "number", $);
}
__name(x4, "x4");
function l7($, q, K) {
  if (Math.floor($) !== $) throw x4($, K), new XH(K || "offset", "an integer", $);
  if (q < 0) throw new xl();
  throw new XH(K || "offset", `>= ${K ? 1 : 0} and <= ${q}`, $);
}
__name(l7, "l7");
function Kr($) {
  if ($ = $.split("=")[0], $ = $.trim().replace(qr, ""), $.length < 2) return "";
  while ($.length % 4 !== 0) $ = $ + "=";
  return $;
}
__name(Kr, "Kr");
function GH($, q) {
  q = q || 1 / 0;
  let K, P = $.length, _ = null, Y = [];
  for (let O = 0; O < P; ++O) {
    if (K = $.charCodeAt(O), K > 55295 && K < 57344) {
      if (!_) {
        if (K > 56319) {
          if ((q -= 3) > -1) Y.push(239, 191, 189);
          continue;
        } else if (O + 1 === P) {
          if ((q -= 3) > -1) Y.push(239, 191, 189);
          continue;
        }
        _ = K;
        continue;
      }
      if (K < 56320) {
        if ((q -= 3) > -1) Y.push(239, 191, 189);
        _ = K;
        continue;
      }
      K = (_ - 55296 << 10 | K - 56320) + 65536;
    } else if (_) {
      if ((q -= 3) > -1) Y.push(239, 191, 189);
    }
    if (_ = null, K < 128) {
      if ((q -= 1) < 0) break;
      Y.push(K);
    } else if (K < 2048) {
      if ((q -= 2) < 0) break;
      Y.push(K >> 6 | 192, K & 63 | 128);
    } else if (K < 65536) {
      if ((q -= 3) < 0) break;
      Y.push(K >> 12 | 224, K >> 6 & 63 | 128, K & 63 | 128);
    } else if (K < 1114112) {
      if ((q -= 4) < 0) break;
      Y.push(K >> 18 | 240, K >> 12 & 63 | 128, K >> 6 & 63 | 128, K & 63 | 128);
    } else throw Error("Invalid code point");
  }
  return Y;
}
__name(GH, "GH");
function _r($) {
  let q = [];
  for (let K = 0; K < $.length; ++K) q.push($.charCodeAt(K) & 255);
  return q;
}
__name(_r, "_r");
function Pr($, q) {
  let K, P, _, Y = [];
  for (let O = 0; O < $.length; ++O) {
    if ((q -= 2) < 0) break;
    K = $.charCodeAt(O), P = K >> 8, _ = K % 256, Y.push(_), Y.push(P);
  }
  return Y;
}
__name(Pr, "Pr");
function MS($) {
  return Rl(Kr($));
}
__name(MS, "MS");
function a5($, q, K, P) {
  let _;
  for (_ = 0; _ < P; ++_) {
    if (_ + K >= q.length || _ >= $.length) break;
    q[_ + K] = $[_];
  }
  return _;
}
__name(a5, "a5");
function $K($, q) {
  return $ instanceof q || $ != null && $.constructor != null && $.constructor.name != null && $.constructor.name === q.name;
}
__name($K, "$K");
function sK($) {
  return typeof BigInt > "u" ? Yr : $;
}
__name(sK, "sK");
function Yr() {
  throw Error("BigInt not supported");
}
__name(Yr, "Yr");
function NH($) {
  return () => {
    throw Error($ + " is not implemented for node:buffer browser polyfill");
  };
}
__name(NH, "NH");
var s8;
var S8;
var ZH = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var L_;
var _S;
var OS;
var WS = 50;
var d7 = 2147483647;
var HS = 536870888;
var Ll;
var gl;
var bl;
var yl;
var ul;
var xl;
var pl;
var XH;
var jS = 4096;
var qr;
var Or;
var jr;
var vr;
var zr = /* @__PURE__ */ __name(($) => {
  for (let q of $) if (q.charCodeAt(0) > 127) return false;
  return true;
}, "zr");
var Wr;
var Hr;
var fq = m_(() => {
  s8 = [], S8 = [];
  for (L_ = 0, _S = ZH.length; L_ < _S; ++L_) s8[L_] = ZH[L_], S8[ZH.charCodeAt(L_)] = L_;
  S8[45] = 62;
  S8[95] = 63;
  OS = typeof Symbol === "function" && typeof Symbol.for === "function" ? Symbol.for("nodejs.util.inspect.custom") : null, Ll = globalThis.btoa, gl = globalThis.atob, bl = globalThis.File, yl = globalThis.Blob, ul = { MAX_LENGTH: d7, MAX_STRING_LENGTH: HS };
  xl = VH("ERR_BUFFER_OUT_OF_BOUNDS", function($) {
    if ($) return `${$} is outside of buffer bounds`;
    return "Attempt to access memory outside buffer bounds";
  }, RangeError), pl = VH("ERR_INVALID_ARG_TYPE", function($, q) {
    return `The "${$}" argument must be of type number. Received type ${typeof q}`;
  }, TypeError), XH = VH("ERR_OUT_OF_RANGE", function($, q, K) {
    let P = `The value of "${$}" is out of range.`, _ = K;
    if (Number.isInteger(K) && Math.abs(K) > 4294967296) _ = vS(String(K));
    else if (typeof K === "bigint") {
      if (_ = String(K), K > BigInt(2) ** BigInt(32) || K < -(BigInt(2) ** BigInt(32))) _ = vS(_);
      _ += "n";
    }
    return P += ` It must be ${q}. Received ${_}`, P;
  }, RangeError);
  Object.defineProperty(w$.prototype, "parent", { enumerable: true, get: /* @__PURE__ */ __name(function() {
    if (!w$.isBuffer(this)) return;
    return this.buffer;
  }, "get") });
  Object.defineProperty(w$.prototype, "offset", { enumerable: true, get: /* @__PURE__ */ __name(function() {
    if (!w$.isBuffer(this)) return;
    return this.byteOffset;
  }, "get") });
  w$.poolSize = 8192;
  w$.from = function($, q, K) {
    return JS($, q, K);
  };
  Object.setPrototypeOf(w$.prototype, Uint8Array.prototype);
  Object.setPrototypeOf(w$, Uint8Array);
  w$.alloc = function($, q, K) {
    return cl($, q, K);
  };
  w$.allocUnsafe = function($) {
    return SH($);
  };
  w$.allocUnsafeSlow = function($) {
    return SH($);
  };
  w$.isBuffer = function($) {
    return $ != null && $._isBuffer === true && $ !== w$.prototype;
  };
  w$.compare = function($, q) {
    if ($K($, Uint8Array)) $ = w$.from($, $.offset, $.byteLength);
    if ($K(q, Uint8Array)) q = w$.from(q, q.offset, q.byteLength);
    if (!w$.isBuffer($) || !w$.isBuffer(q)) throw TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    if ($ === q) return 0;
    let K = $.length, P = q.length;
    for (let _ = 0, Y = Math.min(K, P); _ < Y; ++_) if ($[_] !== q[_]) {
      K = $[_], P = q[_];
      break;
    }
    if (K < P) return -1;
    if (P < K) return 1;
    return 0;
  };
  w$.isEncoding = function($) {
    switch (String($).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  };
  w$.concat = function($, q) {
    if (!Array.isArray($)) throw TypeError('"list" argument must be an Array of Buffers');
    if ($.length === 0) return w$.alloc(0);
    let K;
    if (q === void 0) {
      q = 0;
      for (K = 0; K < $.length; ++K) q += $[K].length;
    }
    let P = w$.allocUnsafe(q), _ = 0;
    for (K = 0; K < $.length; ++K) {
      let Y = $[K];
      if ($K(Y, Uint8Array)) if (_ + Y.length > P.length) {
        if (!w$.isBuffer(Y)) Y = w$.from(Y);
        Y.copy(P, _);
      } else Uint8Array.prototype.set.call(P, Y, _);
      else if (!w$.isBuffer(Y)) throw TypeError('"list" argument must be an Array of Buffers');
      else Y.copy(P, _);
      _ += Y.length;
    }
    return P;
  };
  w$.byteLength = wS;
  w$.prototype._isBuffer = true;
  w$.prototype.swap16 = function() {
    let $ = this.length;
    if ($ % 2 !== 0) throw RangeError("Buffer size must be a multiple of 16-bits");
    for (let q = 0; q < $; q += 2) g_(this, q, q + 1);
    return this;
  };
  w$.prototype.swap32 = function() {
    let $ = this.length;
    if ($ % 4 !== 0) throw RangeError("Buffer size must be a multiple of 32-bits");
    for (let q = 0; q < $; q += 4) g_(this, q, q + 3), g_(this, q + 1, q + 2);
    return this;
  };
  w$.prototype.swap64 = function() {
    let $ = this.length;
    if ($ % 8 !== 0) throw RangeError("Buffer size must be a multiple of 64-bits");
    for (let q = 0; q < $; q += 8) g_(this, q, q + 7), g_(this, q + 1, q + 6), g_(this, q + 2, q + 5), g_(this, q + 3, q + 4);
    return this;
  };
  w$.prototype.toString = function() {
    let $ = this.length;
    if ($ === 0) return "";
    if (arguments.length === 0) return ZS(this, 0, $);
    return rl.apply(this, arguments);
  };
  w$.prototype.toLocaleString = w$.prototype.toString;
  w$.prototype.equals = function($) {
    if (!w$.isBuffer($)) throw TypeError("Argument must be a Buffer");
    if (this === $) return true;
    return w$.compare(this, $) === 0;
  };
  w$.prototype.inspect = function() {
    let $ = "", q = WS;
    if ($ = this.toString("hex", 0, q).replace(/(.{2})/g, "$1 ").trim(), this.length > q) $ += " ... ";
    return "<Buffer " + $ + ">";
  };
  if (OS) w$.prototype[OS] = w$.prototype.inspect;
  w$.prototype.compare = function($, q, K, P, _) {
    if ($K($, Uint8Array)) $ = w$.from($, $.offset, $.byteLength);
    if (!w$.isBuffer($)) throw TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof $);
    if (q === void 0) q = 0;
    if (K === void 0) K = $ ? $.length : 0;
    if (P === void 0) P = 0;
    if (_ === void 0) _ = this.length;
    if (q < 0 || K > $.length || P < 0 || _ > this.length) throw RangeError("out of range index");
    if (P >= _ && q >= K) return 0;
    if (P >= _) return -1;
    if (q >= K) return 1;
    if (q >>>= 0, K >>>= 0, P >>>= 0, _ >>>= 0, this === $) return 0;
    let Y = _ - P, O = K - q, z = Math.min(Y, O), J = this.slice(P, _), T = $.slice(q, K);
    for (let X = 0; X < z; ++X) if (J[X] !== T[X]) {
      Y = J[X], O = T[X];
      break;
    }
    if (Y < O) return -1;
    if (O < Y) return 1;
    return 0;
  };
  w$.prototype.includes = function($, q, K) {
    return this.indexOf($, q, K) !== -1;
  };
  w$.prototype.indexOf = function($, q, K) {
    return fS(this, $, q, K, true);
  };
  w$.prototype.lastIndexOf = function($, q, K) {
    return fS(this, $, q, K, false);
  };
  w$.prototype.write = function($, q, K, P) {
    if (q === void 0) P = "utf8", K = this.length, q = 0;
    else if (K === void 0 && typeof q === "string") P = q, K = this.length, q = 0;
    else if (isFinite(q)) if (q = q >>> 0, isFinite(K)) {
      if (K = K >>> 0, P === void 0) P = "utf8";
    } else P = K, K = void 0;
    else throw Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
    let _ = this.length - q;
    if (K === void 0 || K > _) K = _;
    if ($.length > 0 && (K < 0 || q < 0) || q > this.length) throw RangeError("Attempt to write outside buffer bounds");
    if (!P) P = "utf8";
    let Y = false;
    for (; ; ) switch (P) {
      case "hex":
        return ol(this, $, q, K);
      case "utf8":
      case "utf-8":
        return nl(this, $, q, K);
      case "ascii":
      case "latin1":
      case "binary":
        return il(this, $, q, K);
      case "base64":
        return tl(this, $, q, K);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return Bl(this, $, q, K);
      default:
        if (Y) throw TypeError("Unknown encoding: " + P);
        P = ("" + P).toLowerCase(), Y = true;
    }
  };
  w$.prototype.toJSON = function() {
    return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
  };
  w$.prototype.slice = function($, q) {
    let K = this.length;
    if ($ = ~~$, q = q === void 0 ? K : ~~q, $ < 0) {
      if ($ += K, $ < 0) $ = 0;
    } else if ($ > K) $ = K;
    if (q < 0) {
      if (q += K, q < 0) q = 0;
    } else if (q > K) q = K;
    if (q < $) q = $;
    let P = this.subarray($, q);
    return Object.setPrototypeOf(P, w$.prototype), P;
  };
  w$.prototype.readUintLE = w$.prototype.readUIntLE = function($, q, K) {
    if ($ = $ >>> 0, q = q >>> 0, !K) Tq($, q, this.length);
    let P = this[$], _ = 1, Y = 0;
    while (++Y < q && (_ *= 256)) P += this[$ + Y] * _;
    return P;
  };
  w$.prototype.readUintBE = w$.prototype.readUIntBE = function($, q, K) {
    if ($ = $ >>> 0, q = q >>> 0, !K) Tq($, q, this.length);
    let P = this[$ + --q], _ = 1;
    while (q > 0 && (_ *= 256)) P += this[$ + --q] * _;
    return P;
  };
  w$.prototype.readUint8 = w$.prototype.readUInt8 = function($, q) {
    if ($ = $ >>> 0, !q) Tq($, 1, this.length);
    return this[$];
  };
  w$.prototype.readUint16LE = w$.prototype.readUInt16LE = function($, q) {
    if ($ = $ >>> 0, !q) Tq($, 2, this.length);
    return this[$] | this[$ + 1] << 8;
  };
  w$.prototype.readUint16BE = w$.prototype.readUInt16BE = function($, q) {
    if ($ = $ >>> 0, !q) Tq($, 2, this.length);
    return this[$] << 8 | this[$ + 1];
  };
  w$.prototype.readUint32LE = w$.prototype.readUInt32LE = function($, q) {
    if ($ = $ >>> 0, !q) Tq($, 4, this.length);
    return (this[$] | this[$ + 1] << 8 | this[$ + 2] << 16) + this[$ + 3] * 16777216;
  };
  w$.prototype.readUint32BE = w$.prototype.readUInt32BE = function($, q) {
    if ($ = $ >>> 0, !q) Tq($, 4, this.length);
    return this[$] * 16777216 + (this[$ + 1] << 16 | this[$ + 2] << 8 | this[$ + 3]);
  };
  w$.prototype.readBigUInt64LE = sK(function($) {
    $ = $ >>> 0, x4($, "offset");
    let q = this[$], K = this[$ + 7];
    if (q === void 0 || K === void 0) l7($, this.length - 8);
    let P = q + this[++$] * 256 + this[++$] * 65536 + this[++$] * 16777216, _ = this[++$] + this[++$] * 256 + this[++$] * 65536 + K * 16777216;
    return BigInt(P) + (BigInt(_) << BigInt(32));
  });
  w$.prototype.readBigUInt64BE = sK(function($) {
    $ = $ >>> 0, x4($, "offset");
    let q = this[$], K = this[$ + 7];
    if (q === void 0 || K === void 0) l7($, this.length - 8);
    let P = q * 16777216 + this[++$] * 65536 + this[++$] * 256 + this[++$], _ = this[++$] * 16777216 + this[++$] * 65536 + this[++$] * 256 + K;
    return (BigInt(P) << BigInt(32)) + BigInt(_);
  });
  w$.prototype.readIntLE = function($, q, K) {
    if ($ = $ >>> 0, q = q >>> 0, !K) Tq($, q, this.length);
    let P = this[$], _ = 1, Y = 0;
    while (++Y < q && (_ *= 256)) P += this[$ + Y] * _;
    if (_ *= 128, P >= _) P -= Math.pow(2, 8 * q);
    return P;
  };
  w$.prototype.readIntBE = function($, q, K) {
    if ($ = $ >>> 0, q = q >>> 0, !K) Tq($, q, this.length);
    let P = q, _ = 1, Y = this[$ + --P];
    while (P > 0 && (_ *= 256)) Y += this[$ + --P] * _;
    if (_ *= 128, Y >= _) Y -= Math.pow(2, 8 * q);
    return Y;
  };
  w$.prototype.readInt8 = function($, q) {
    if ($ = $ >>> 0, !q) Tq($, 1, this.length);
    if (!(this[$] & 128)) return this[$];
    return (255 - this[$] + 1) * -1;
  };
  w$.prototype.readInt16LE = function($, q) {
    if ($ = $ >>> 0, !q) Tq($, 2, this.length);
    let K = this[$] | this[$ + 1] << 8;
    return K & 32768 ? K | 4294901760 : K;
  };
  w$.prototype.readInt16BE = function($, q) {
    if ($ = $ >>> 0, !q) Tq($, 2, this.length);
    let K = this[$ + 1] | this[$] << 8;
    return K & 32768 ? K | 4294901760 : K;
  };
  w$.prototype.readInt32LE = function($, q) {
    if ($ = $ >>> 0, !q) Tq($, 4, this.length);
    return this[$] | this[$ + 1] << 8 | this[$ + 2] << 16 | this[$ + 3] << 24;
  };
  w$.prototype.readInt32BE = function($, q) {
    if ($ = $ >>> 0, !q) Tq($, 4, this.length);
    return this[$] << 24 | this[$ + 1] << 16 | this[$ + 2] << 8 | this[$ + 3];
  };
  w$.prototype.readBigInt64LE = sK(function($) {
    $ = $ >>> 0, x4($, "offset");
    let q = this[$], K = this[$ + 7];
    if (q === void 0 || K === void 0) l7($, this.length - 8);
    let P = this[$ + 4] + this[$ + 5] * 256 + this[$ + 6] * 65536 + (K << 24);
    return (BigInt(P) << BigInt(32)) + BigInt(q + this[++$] * 256 + this[++$] * 65536 + this[++$] * 16777216);
  });
  w$.prototype.readBigInt64BE = sK(function($) {
    $ = $ >>> 0, x4($, "offset");
    let q = this[$], K = this[$ + 7];
    if (q === void 0 || K === void 0) l7($, this.length - 8);
    let P = (q << 24) + this[++$] * 65536 + this[++$] * 256 + this[++$];
    return (BigInt(P) << BigInt(32)) + BigInt(this[++$] * 16777216 + this[++$] * 65536 + this[++$] * 256 + K);
  });
  w$.prototype.readFloatLE = function($, q) {
    if ($ = $ >>> 0, !q) Tq($, 4, this.length);
    return F5(this, $, true, 23, 4);
  };
  w$.prototype.readFloatBE = function($, q) {
    if ($ = $ >>> 0, !q) Tq($, 4, this.length);
    return F5(this, $, false, 23, 4);
  };
  w$.prototype.readDoubleLE = function($, q) {
    if ($ = $ >>> 0, !q) Tq($, 8, this.length);
    return F5(this, $, true, 52, 8);
  };
  w$.prototype.readDoubleBE = function($, q) {
    if ($ = $ >>> 0, !q) Tq($, 8, this.length);
    return F5(this, $, false, 52, 8);
  };
  w$.prototype.writeUintLE = w$.prototype.writeUIntLE = function($, q, K, P) {
    if ($ = +$, q = q >>> 0, K = K >>> 0, !P) {
      let O = Math.pow(2, 8 * K) - 1;
      sq(this, $, q, K, O, 0);
    }
    let _ = 1, Y = 0;
    this[q] = $ & 255;
    while (++Y < K && (_ *= 256)) this[q + Y] = $ / _ & 255;
    return q + K;
  };
  w$.prototype.writeUintBE = w$.prototype.writeUIntBE = function($, q, K, P) {
    if ($ = +$, q = q >>> 0, K = K >>> 0, !P) {
      let O = Math.pow(2, 8 * K) - 1;
      sq(this, $, q, K, O, 0);
    }
    let _ = K - 1, Y = 1;
    this[q + _] = $ & 255;
    while (--_ >= 0 && (Y *= 256)) this[q + _] = $ / Y & 255;
    return q + K;
  };
  w$.prototype.writeUint8 = w$.prototype.writeUInt8 = function($, q, K) {
    if ($ = +$, q = q >>> 0, !K) sq(this, $, q, 1, 255, 0);
    return this[q] = $ & 255, q + 1;
  };
  w$.prototype.writeUint16LE = w$.prototype.writeUInt16LE = function($, q, K) {
    if ($ = +$, q = q >>> 0, !K) sq(this, $, q, 2, 65535, 0);
    return this[q] = $ & 255, this[q + 1] = $ >>> 8, q + 2;
  };
  w$.prototype.writeUint16BE = w$.prototype.writeUInt16BE = function($, q, K) {
    if ($ = +$, q = q >>> 0, !K) sq(this, $, q, 2, 65535, 0);
    return this[q] = $ >>> 8, this[q + 1] = $ & 255, q + 2;
  };
  w$.prototype.writeUint32LE = w$.prototype.writeUInt32LE = function($, q, K) {
    if ($ = +$, q = q >>> 0, !K) sq(this, $, q, 4, 4294967295, 0);
    return this[q + 3] = $ >>> 24, this[q + 2] = $ >>> 16, this[q + 1] = $ >>> 8, this[q] = $ & 255, q + 4;
  };
  w$.prototype.writeUint32BE = w$.prototype.writeUInt32BE = function($, q, K) {
    if ($ = +$, q = q >>> 0, !K) sq(this, $, q, 4, 4294967295, 0);
    return this[q] = $ >>> 24, this[q + 1] = $ >>> 16, this[q + 2] = $ >>> 8, this[q + 3] = $ & 255, q + 4;
  };
  w$.prototype.writeBigUInt64LE = sK(function($, q = 0) {
    return XS(this, $, q, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  w$.prototype.writeBigUInt64BE = sK(function($, q = 0) {
    return AS(this, $, q, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  w$.prototype.writeIntLE = function($, q, K, P) {
    if ($ = +$, q = q >>> 0, !P) {
      let z = Math.pow(2, 8 * K - 1);
      sq(this, $, q, K, z - 1, -z);
    }
    let _ = 0, Y = 1, O = 0;
    this[q] = $ & 255;
    while (++_ < K && (Y *= 256)) {
      if ($ < 0 && O === 0 && this[q + _ - 1] !== 0) O = 1;
      this[q + _] = ($ / Y >> 0) - O & 255;
    }
    return q + K;
  };
  w$.prototype.writeIntBE = function($, q, K, P) {
    if ($ = +$, q = q >>> 0, !P) {
      let z = Math.pow(2, 8 * K - 1);
      sq(this, $, q, K, z - 1, -z);
    }
    let _ = K - 1, Y = 1, O = 0;
    this[q + _] = $ & 255;
    while (--_ >= 0 && (Y *= 256)) {
      if ($ < 0 && O === 0 && this[q + _ + 1] !== 0) O = 1;
      this[q + _] = ($ / Y >> 0) - O & 255;
    }
    return q + K;
  };
  w$.prototype.writeInt8 = function($, q, K) {
    if ($ = +$, q = q >>> 0, !K) sq(this, $, q, 1, 127, -128);
    if ($ < 0) $ = 255 + $ + 1;
    return this[q] = $ & 255, q + 1;
  };
  w$.prototype.writeInt16LE = function($, q, K) {
    if ($ = +$, q = q >>> 0, !K) sq(this, $, q, 2, 32767, -32768);
    return this[q] = $ & 255, this[q + 1] = $ >>> 8, q + 2;
  };
  w$.prototype.writeInt16BE = function($, q, K) {
    if ($ = +$, q = q >>> 0, !K) sq(this, $, q, 2, 32767, -32768);
    return this[q] = $ >>> 8, this[q + 1] = $ & 255, q + 2;
  };
  w$.prototype.writeInt32LE = function($, q, K) {
    if ($ = +$, q = q >>> 0, !K) sq(this, $, q, 4, 2147483647, -2147483648);
    return this[q] = $ & 255, this[q + 1] = $ >>> 8, this[q + 2] = $ >>> 16, this[q + 3] = $ >>> 24, q + 4;
  };
  w$.prototype.writeInt32BE = function($, q, K) {
    if ($ = +$, q = q >>> 0, !K) sq(this, $, q, 4, 2147483647, -2147483648);
    if ($ < 0) $ = 4294967295 + $ + 1;
    return this[q] = $ >>> 24, this[q + 1] = $ >>> 16, this[q + 2] = $ >>> 8, this[q + 3] = $ & 255, q + 4;
  };
  w$.prototype.writeBigInt64LE = sK(function($, q = 0) {
    return XS(this, $, q, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  w$.prototype.writeBigInt64BE = sK(function($, q = 0) {
    return AS(this, $, q, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  w$.prototype.writeFloatLE = function($, q, K) {
    return GS(this, $, q, true, K);
  };
  w$.prototype.writeFloatBE = function($, q, K) {
    return GS(this, $, q, false, K);
  };
  w$.prototype.writeDoubleLE = function($, q, K) {
    return VS(this, $, q, true, K);
  };
  w$.prototype.writeDoubleBE = function($, q, K) {
    return VS(this, $, q, false, K);
  };
  w$.prototype.copy = function($, q, K, P) {
    if (!w$.isBuffer($)) throw TypeError("argument should be a Buffer");
    if (!K) K = 0;
    if (!P && P !== 0) P = this.length;
    if (q >= $.length) q = $.length;
    if (!q) q = 0;
    if (P > 0 && P < K) P = K;
    if (P === K) return 0;
    if ($.length === 0 || this.length === 0) return 0;
    if (q < 0) throw RangeError("targetStart out of bounds");
    if (K < 0 || K >= this.length) throw RangeError("Index out of range");
    if (P < 0) throw RangeError("sourceEnd out of bounds");
    if (P > this.length) P = this.length;
    if ($.length - q < P - K) P = $.length - q + K;
    let _ = P - K;
    if (this === $ && typeof Uint8Array.prototype.copyWithin === "function") this.copyWithin(q, K, P);
    else Uint8Array.prototype.set.call($, this.subarray(K, P), q);
    return _;
  };
  w$.prototype.fill = function($, q, K, P) {
    if (typeof $ === "string") {
      if (typeof q === "string") P = q, q = 0, K = this.length;
      else if (typeof K === "string") P = K, K = this.length;
      if (P !== void 0 && typeof P !== "string") throw TypeError("encoding must be a string");
      if (typeof P === "string" && !w$.isEncoding(P)) throw TypeError("Unknown encoding: " + P);
      if ($.length === 1) {
        let Y = $.charCodeAt(0);
        if (P === "utf8" && Y < 128 || P === "latin1") $ = Y;
      }
    } else if (typeof $ === "number") $ = $ & 255;
    else if (typeof $ === "boolean") $ = Number($);
    if (q < 0 || this.length < q || this.length < K) throw RangeError("Out of range index");
    if (K <= q) return this;
    if (q = q >>> 0, K = K === void 0 ? this.length : K >>> 0, !$) $ = 0;
    let _;
    if (typeof $ === "number") for (_ = q; _ < K; ++_) this[_] = $;
    else {
      let Y = w$.isBuffer($) ? $ : w$.from($, P), O = Y.length;
      if (O === 0) throw TypeError('The value "' + $ + '" is invalid for argument "value"');
      for (_ = 0; _ < K - q; ++_) this[_ + q] = Y[_ % O];
    }
    return this;
  };
  qr = /[^+/0-9A-Za-z-_]/g;
  Or = (function() {
    let $ = Array(256);
    for (let q = 0; q < 16; ++q) {
      let K = q * 16;
      for (let P = 0; P < 16; ++P) $[K + P] = "0123456789abcdef"[q] + "0123456789abcdef"[P];
    }
    return $;
  })();
  jr = NH("resolveObjectURL"), vr = NH("isUtf8"), Wr = NH("transcode"), Hr = w$;
});
var bS = {};
rq(bS, { types: /* @__PURE__ */ __name(() => Vr, "types"), promisify: /* @__PURE__ */ __name(() => IS, "promisify"), log: /* @__PURE__ */ __name(() => hS, "log"), isUndefined: /* @__PURE__ */ __name(() => p4, "isUndefined"), isSymbol: /* @__PURE__ */ __name(() => Mr, "isSymbol"), isString: /* @__PURE__ */ __name(() => KO, "isString"), isRegExp: /* @__PURE__ */ __name(() => Q5, "isRegExp"), isPrimitive: /* @__PURE__ */ __name(() => Nr, "isPrimitive"), isObject: /* @__PURE__ */ __name(() => c4, "isObject"), isNumber: /* @__PURE__ */ __name(() => CS, "isNumber"), isNullOrUndefined: /* @__PURE__ */ __name(() => Sr, "isNullOrUndefined"), isNull: /* @__PURE__ */ __name(() => qO, "isNull"), isFunction: /* @__PURE__ */ __name(() => s5, "isFunction"), isError: /* @__PURE__ */ __name(() => e5, "isError"), isDate: /* @__PURE__ */ __name(() => RH, "isDate"), isBuffer: /* @__PURE__ */ __name(() => Cr, "isBuffer"), isBoolean: /* @__PURE__ */ __name(() => DH, "isBoolean"), isArray: /* @__PURE__ */ __name(() => NS, "isArray"), inspect: /* @__PURE__ */ __name(() => b_, "inspect"), inherits: /* @__PURE__ */ __name(() => ES, "inherits"), format: /* @__PURE__ */ __name(() => IH, "format"), deprecate: /* @__PURE__ */ __name(() => Tr, "deprecate"), default: /* @__PURE__ */ __name(() => Rr, "default"), debuglog: /* @__PURE__ */ __name(() => wr, "debuglog"), callbackifyOnRejected: /* @__PURE__ */ __name(() => bH, "callbackifyOnRejected"), callbackify: /* @__PURE__ */ __name(() => DS, "callbackify"), _extend: /* @__PURE__ */ __name(() => gH, "_extend"), TextEncoder: /* @__PURE__ */ __name(() => LS, "TextEncoder"), TextDecoder: /* @__PURE__ */ __name(() => gS, "TextDecoder") });
function IH($, ...q) {
  if (!KO($)) {
    var K = [$];
    for (var P = 0; P < q.length; P++) K.push(b_(q[P]));
    return K.join(" ");
  }
  var P = 0, _ = q.length, Y = String($).replace(Jr, function(z) {
    if (z === "%%") return "%";
    if (P >= _) return z;
    switch (z) {
      case "%s":
        return String(q[P++]);
      case "%d":
        return Number(q[P++]);
      case "%j":
        try {
          return JSON.stringify(q[P++]);
        } catch (J) {
          return "[Circular]";
        }
      default:
        return z;
    }
  });
  for (var O = q[P]; P < _; O = q[++P]) if (qO(O) || !c4(O)) Y += " " + O;
  else Y += " " + b_(O);
  return Y;
}
__name(IH, "IH");
function Tr($, q) {
  if (typeof process > "u" || process?.noDeprecation === true) return $;
  var K = false;
  function P(..._) {
    if (!K) {
      if (process.throwDeprecation) throw Error(q);
      else if (process.traceDeprecation) console.trace(q);
      else console.error(q);
      K = true;
    }
    return $.apply(this, ..._);
  }
  __name(P, "P");
  return P;
}
__name(Tr, "Tr");
function fr($, q) {
  var K = b_.styles[q];
  if (K) return "\x1B[" + b_.colors[K][0] + "m" + $ + "\x1B[" + b_.colors[K][1] + "m";
  else return $;
}
__name(fr, "fr");
function Zr($, q) {
  return $;
}
__name(Zr, "Zr");
function Xr($) {
  var q = {};
  return $.forEach(function(K, P) {
    q[K] = true;
  }), q;
}
__name(Xr, "Xr");
function $O($, q, K) {
  if ($.customInspect && q && s5(q.inspect) && q.inspect !== b_ && !(q.constructor && q.constructor.prototype === q)) {
    var P = q.inspect(K, $);
    if (!KO(P)) P = $O($, P, K);
    return P;
  }
  var _ = Ar($, q);
  if (_) return _;
  var Y = Object.keys(q), O = Xr(Y);
  if ($.showHidden) Y = Object.getOwnPropertyNames(q);
  if (e5(q) && (Y.indexOf("message") >= 0 || Y.indexOf("description") >= 0)) return CH(q);
  if (Y.length === 0) {
    if (s5(q)) {
      var z = q.name ? ": " + q.name : "";
      return $.stylize("[Function" + z + "]", "special");
    }
    if (Q5(q)) return $.stylize(RegExp.prototype.toString.call(q), "regexp");
    if (RH(q)) return $.stylize(Date.prototype.toString.call(q), "date");
    if (e5(q)) return CH(q);
  }
  var J = "", T = false, X = ["{", "}"];
  if (NS(q)) T = true, X = ["[", "]"];
  if (s5(q)) {
    var f = q.name ? ": " + q.name : "";
    J = " [Function" + f + "]";
  }
  if (Q5(q)) J = " " + RegExp.prototype.toString.call(q);
  if (RH(q)) J = " " + Date.prototype.toUTCString.call(q);
  if (e5(q)) J = " " + CH(q);
  if (Y.length === 0 && (!T || q.length == 0)) return X[0] + J + X[1];
  if (K < 0) if (Q5(q)) return $.stylize(RegExp.prototype.toString.call(q), "regexp");
  else return $.stylize("[Object]", "special");
  $.seen.push(q);
  var V;
  if (T) V = kr($, q, K, O, Y);
  else V = Y.map(function(M) {
    return EH($, q, K, O, M, T);
  });
  return $.seen.pop(), Gr(V, J, X);
}
__name($O, "$O");
function Ar($, q) {
  if (p4(q)) return $.stylize("undefined", "undefined");
  if (KO(q)) {
    var K = "'" + JSON.stringify(q).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
    return $.stylize(K, "string");
  }
  if (CS(q)) return $.stylize("" + q, "number");
  if (DH(q)) return $.stylize("" + q, "boolean");
  if (qO(q)) return $.stylize("null", "null");
}
__name(Ar, "Ar");
function CH($) {
  return "[" + Error.prototype.toString.call($) + "]";
}
__name(CH, "CH");
function kr($, q, K, P, _) {
  var Y = [];
  for (var O = 0, z = q.length; O < z; ++O) if (RS(q, String(O))) Y.push(EH($, q, K, P, String(O), true));
  else Y.push("");
  return _.forEach(function(J) {
    if (!J.match(/^\d+$/)) Y.push(EH($, q, K, P, J, true));
  }), Y;
}
__name(kr, "kr");
function EH($, q, K, P, _, Y) {
  var O, z, J;
  if (J = Object.getOwnPropertyDescriptor(q, _) || { value: q[_] }, J.get) if (J.set) z = $.stylize("[Getter/Setter]", "special");
  else z = $.stylize("[Getter]", "special");
  else if (J.set) z = $.stylize("[Setter]", "special");
  if (!RS(P, _)) O = "[" + _ + "]";
  if (!z) if ($.seen.indexOf(J.value) < 0) {
    if (qO(K)) z = $O($, J.value, null);
    else z = $O($, J.value, K - 1);
    if (z.indexOf(`
`) > -1) if (Y) z = z.split(`
`).map(function(T) {
      return "  " + T;
    }).join(`
`).slice(2);
    else z = `
` + z.split(`
`).map(function(T) {
      return "   " + T;
    }).join(`
`);
  } else z = $.stylize("[Circular]", "special");
  if (p4(O)) {
    if (Y && _.match(/^\d+$/)) return z;
    if (O = JSON.stringify("" + _), O.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) O = O.slice(1, -1), O = $.stylize(O, "name");
    else O = O.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), O = $.stylize(O, "string");
  }
  return O + ": " + z;
}
__name(EH, "EH");
function Gr($, q, K) {
  var P = 0, _ = $.reduce(function(Y, O) {
    if (P++, O.indexOf(`
`) >= 0) P++;
    return Y + O.replace(/\u001b\[\d\d?m/g, "").length + 1;
  }, 0);
  if (_ > 60) return K[0] + (q === "" ? "" : q + `
 `) + " " + $.join(`,
  `) + " " + K[1];
  return K[0] + q + " " + $.join(", ") + " " + K[1];
}
__name(Gr, "Gr");
function NS($) {
  return Array.isArray($);
}
__name(NS, "NS");
function DH($) {
  return typeof $ === "boolean";
}
__name(DH, "DH");
function qO($) {
  return $ === null;
}
__name(qO, "qO");
function Sr($) {
  return $ == null;
}
__name(Sr, "Sr");
function CS($) {
  return typeof $ === "number";
}
__name(CS, "CS");
function KO($) {
  return typeof $ === "string";
}
__name(KO, "KO");
function Mr($) {
  return typeof $ === "symbol";
}
__name(Mr, "Mr");
function p4($) {
  return $ === void 0;
}
__name(p4, "p4");
function Q5($) {
  return c4($) && LH($) === "[object RegExp]";
}
__name(Q5, "Q5");
function c4($) {
  return typeof $ === "object" && $ !== null;
}
__name(c4, "c4");
function RH($) {
  return c4($) && LH($) === "[object Date]";
}
__name(RH, "RH");
function e5($) {
  return c4($) && (LH($) === "[object Error]" || $ instanceof Error);
}
__name(e5, "e5");
function s5($) {
  return typeof $ === "function";
}
__name(s5, "s5");
function Nr($) {
  return $ === null || typeof $ === "boolean" || typeof $ === "number" || typeof $ === "string" || typeof $ === "symbol" || typeof $ > "u";
}
__name(Nr, "Nr");
function Cr($) {
  return $ instanceof Buffer;
}
__name(Cr, "Cr");
function LH($) {
  return Object.prototype.toString.call($);
}
__name(LH, "LH");
function hH($) {
  return $ < 10 ? "0" + $.toString(10) : $.toString(10);
}
__name(hH, "hH");
function Er() {
  var $ = /* @__PURE__ */ new Date(), q = [hH($.getHours()), hH($.getMinutes()), hH($.getSeconds())].join(":");
  return [$.getDate(), hr[$.getMonth()], q].join(" ");
}
__name(Er, "Er");
function hS(...$) {
  console.log("%s - %s", Er(), IH.apply(null, $));
}
__name(hS, "hS");
function ES($, q) {
  if (q) $.super_ = q, $.prototype = Object.create(q.prototype, { constructor: { value: $, enumerable: false, writable: true, configurable: true } });
}
__name(ES, "ES");
function gH($, q) {
  if (!q || !c4(q)) return $;
  var K = Object.keys(q), P = K.length;
  while (P--) $[K[P]] = q[K[P]];
  return $;
}
__name(gH, "gH");
function RS($, q) {
  return Object.prototype.hasOwnProperty.call($, q);
}
__name(RS, "RS");
function bH($, q) {
  if (!$) {
    var K = Error("Promise was rejected with a falsy value");
    K.reason = $, $ = K;
  }
  return q($);
}
__name(bH, "bH");
function DS($) {
  if (typeof $ !== "function") throw TypeError('The "original" argument must be of type Function');
  function q(...K) {
    var P = K.pop();
    if (typeof P !== "function") throw TypeError("The last argument must be of type Function");
    var _ = this, Y = /* @__PURE__ */ __name(function(...O) {
      return P.apply(_, ...O);
    }, "Y");
    $.apply(this, K).then(function(O) {
      process.nextTick(Y.bind(null, null, O));
    }, function(O) {
      process.nextTick(bH.bind(null, O, Y));
    });
  }
  __name(q, "q");
  return Object.setPrototypeOf(q, Object.getPrototypeOf($)), Object.defineProperties(q, Object.getOwnPropertyDescriptors($)), q;
}
__name(DS, "DS");
var Jr;
var wr;
var b_;
var Vr = /* @__PURE__ */ __name(() => {
}, "Vr");
var hr;
var IS;
var LS;
var gS;
var Rr;
var yS = m_(() => {
  Jr = /%[sdj%]/g;
  wr = (($ = {}, q = {}, K) => ((K = typeof process < "u" && false) && (K = K.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase()), q = new RegExp("^" + K + "$", "i"), (P) => {
    if (P = P.toUpperCase(), !$[P]) if (q.test(P)) $[P] = function(..._) {
      console.error("%s: %s", P, pid, IH.apply(null, ..._));
    };
    else $[P] = function() {
    };
    return $[P];
  }))(), b_ = (($) => ($.colors = { bold: [1, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], white: [37, 39], grey: [90, 39], black: [30, 39], blue: [34, 39], cyan: [36, 39], green: [32, 39], magenta: [35, 39], red: [31, 39], yellow: [33, 39] }, $.styles = { special: "cyan", number: "yellow", boolean: "yellow", undefined: "grey", null: "bold", string: "green", date: "magenta", regexp: "red" }, $.custom = Symbol.for("nodejs.util.inspect.custom"), $))(function($, q, ...K) {
    var P = { seen: [], stylize: Zr };
    if (K.length >= 1) P.depth = K[0];
    if (K.length >= 2) P.colors = K[1];
    if (DH(q)) P.showHidden = q;
    else if (q) gH(P, q);
    if (p4(P.showHidden)) P.showHidden = false;
    if (p4(P.depth)) P.depth = 2;
    if (p4(P.colors)) P.colors = false;
    if (P.colors) P.stylize = fr;
    return $O(P, $, P.depth);
  });
  hr = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
  IS = (($) => ($.custom = Symbol.for("nodejs.util.promisify.custom"), $))(function($) {
    if (typeof $ !== "function") throw TypeError('The "original" argument must be of type Function');
    if (kCustomPromisifiedSymbol && $[kCustomPromisifiedSymbol]) {
      var q = $[kCustomPromisifiedSymbol];
      if (typeof q !== "function") throw TypeError('The "nodejs.util.promisify.custom" argument must be of type Function');
      return Object.defineProperty(q, kCustomPromisifiedSymbol, { value: q, enumerable: false, writable: false, configurable: true }), q;
    }
    function q(...K) {
      var P, _, Y = new Promise(function(O, z) {
        P = O, _ = z;
      });
      K.push(function(O, z) {
        if (O) _(O);
        else P(z);
      });
      try {
        $.apply(this, K);
      } catch (O) {
        _(O);
      }
      return Y;
    }
    __name(q, "q");
    if (Object.setPrototypeOf(q, Object.getPrototypeOf($)), kCustomPromisifiedSymbol) Object.defineProperty(q, kCustomPromisifiedSymbol, { value: q, enumerable: false, writable: false, configurable: true });
    return Object.defineProperties(q, Object.getOwnPropertyDescriptors($));
  });
  ({ TextEncoder: LS, TextDecoder: gS } = globalThis), Rr = { TextEncoder: LS, TextDecoder: gS, promisify: IS, log: hS, inherits: ES, _extend: gH, callbackifyOnRejected: bH, callbackify: DS };
});
var o7 = {};
rq(o7, { setMaxListeners: /* @__PURE__ */ __name(() => iS, "setMaxListeners"), once: /* @__PURE__ */ __name(() => oS, "once"), listenerCount: /* @__PURE__ */ __name(() => tS, "listenerCount"), init: /* @__PURE__ */ __name(() => $_, "init"), getMaxListeners: /* @__PURE__ */ __name(() => US, "getMaxListeners"), getEventListeners: /* @__PURE__ */ __name(() => nS, "getEventListeners"), default: /* @__PURE__ */ __name(() => pr, "default"), captureRejectionSymbol: /* @__PURE__ */ __name(() => mS, "captureRejectionSymbol"), addAbortListener: /* @__PURE__ */ __name(() => FS, "addAbortListener"), EventEmitter: /* @__PURE__ */ __name(() => $_, "EventEmitter") });
function dS($, q) {
  var { _events: K } = $;
  if (q[0] ??= Error("Unhandled error."), !K) throw q[0];
  var P = K[cS];
  if (P) for (var _ of xS.call(P)) _.apply($, q);
  var Y = K.error;
  if (!Y) throw q[0];
  for (var _ of xS.call(Y)) _.apply($, q);
  return true;
}
__name(dS, "dS");
function Lr($, q, K, P) {
  q.then(void 0, function(_) {
    queueMicrotask(() => gr($, _, K, P));
  });
}
__name(Lr, "Lr");
function gr($, q, K, P) {
  if (typeof $[uS] === "function") $[uS](q, K, ...P);
  else try {
    $[y_] = false, $.emit("error", q);
  } finally {
    $[y_] = true;
  }
}
__name(gr, "gr");
function lS($, q, K) {
  K.warned = true;
  let P = Error(`Possible EventEmitter memory leak detected. ${K.length} ${String(q)} listeners added to [${$.constructor.name}]. Use emitter.setMaxListeners() to increase limit`);
  P.name = "MaxListenersExceededWarning", P.emitter = $, P.type = q, P.count = K.length, console.warn(P);
}
__name(lS, "lS");
function rS($, q, ...K) {
  this.removeListener($, q), q.apply(this, K);
}
__name(rS, "rS");
function oS($, q, K) {
  var P = K?.signal;
  if (BS(P, "options.signal"), P?.aborted) throw new yH(void 0, { cause: P?.reason });
  let { resolve: _, reject: Y, promise: O } = $newPromiseCapability(Promise), z = /* @__PURE__ */ __name((X) => {
    if ($.removeListener(q, J), P != null) _O(P, "abort", T);
    Y(X);
  }, "z"), J = /* @__PURE__ */ __name((...X) => {
    if (typeof $.removeListener === "function") $.removeListener("error", z);
    if (P != null) _O(P, "abort", T);
    _(X);
  }, "J");
  if (pS($, q, J, { once: true }), q !== "error" && typeof $.once === "function") $.once("error", z);
  function T() {
    _O($, q, J), _O($, "error", z), Y(new yH(void 0, { cause: P?.reason }));
  }
  __name(T, "T");
  if (P != null) pS(P, "abort", T, { once: true });
  return O;
}
__name(oS, "oS");
function nS($, q) {
  return $.listeners(q);
}
__name(nS, "nS");
function iS($, ...q) {
  xH($, "setMaxListeners", 0);
  var K;
  if (q && (K = q.length)) for (let P = 0; P < K; P++) q[P].setMaxListeners($);
  else u_ = $;
}
__name(iS, "iS");
function tS($, q) {
  return $.listenerCount(q);
}
__name(tS, "tS");
function _O($, q, K, P) {
  if (typeof $.removeListener === "function") $.removeListener(q, K);
  else $.removeEventListener(q, K, P);
}
__name(_O, "_O");
function pS($, q, K, P) {
  if (typeof $.on === "function") if (P.once) $.once(q, K);
  else $.on(q, K);
  else $.addEventListener(q, K, P);
}
__name(pS, "pS");
function m4($, q, K) {
  let P = TypeError(`The "${$}" argument must be of type ${q}. Received ${K}`);
  return P.code = "ERR_INVALID_ARG_TYPE", P;
}
__name(m4, "m4");
function ur($, q, K) {
  let P = RangeError(`The "${$}" argument is out of range. It must be ${q}. Received ${K}`);
  return P.code = "ERR_OUT_OF_RANGE", P;
}
__name(ur, "ur");
function BS($, q) {
  if ($ !== void 0 && ($ === null || typeof $ !== "object" || !("aborted" in $))) throw m4(q, "AbortSignal", $);
}
__name(BS, "BS");
function xH($, q, K, P) {
  if (typeof $ !== "number") throw m4(q, "number", $);
  if (K != null && $ < K || P != null && $ > P || (K != null || P != null) && Number.isNaN($)) throw ur(q, `${K != null ? `>= ${K}` : ""}${K != null && P != null ? " && " : ""}${P != null ? `<= ${P}` : ""}`, $);
}
__name(xH, "xH");
function r7($) {
  if (typeof $ !== "function") throw TypeError("The listener must be a function");
}
__name(r7, "r7");
function xr($, q) {
  if (typeof $ !== "boolean") throw m4(q, "boolean", $);
}
__name(xr, "xr");
function US($) {
  return $?._maxListeners ?? u_;
}
__name(US, "US");
function FS($, q) {
  if ($ === void 0) throw m4("signal", "AbortSignal", $);
  if (BS($, "signal"), typeof q !== "function") throw m4("listener", "function", q);
  let K;
  if ($.aborted) queueMicrotask(() => q());
  else $.addEventListener("abort", q, { __proto__: null, once: true }), K = /* @__PURE__ */ __name(() => {
    $.removeEventListener("abort", q);
  }, "K");
  return { __proto__: null, [Symbol.dispose]() {
    K?.();
  } };
}
__name(FS, "FS");
var uH;
var y_;
var cS;
var Ir;
var Dr;
var uS;
var mS;
var xS;
var u_ = 10;
var $_ = /* @__PURE__ */ __name(function($) {
  if (this._events === void 0 || this._events === this.__proto__._events) this._events = { __proto__: null }, this._eventsCount = 0;
  if (this._maxListeners ??= void 0, this[y_] = $?.captureRejections ? Boolean($?.captureRejections) : g6[y_]) this.emit = yr;
}, "$_");
var g6;
var br = /* @__PURE__ */ __name(function($, ...q) {
  if ($ === "error") return dS(this, q);
  var { _events: K } = this;
  if (K === void 0) return false;
  var P = K[$];
  if (P === void 0) return false;
  let _ = P.length > 1 ? P.slice() : P;
  for (let Y = 0, { length: O } = _; Y < O; Y++) {
    let z = _[Y];
    switch (q.length) {
      case 0:
        z.call(this);
        break;
      case 1:
        z.call(this, q[0]);
        break;
      case 2:
        z.call(this, q[0], q[1]);
        break;
      case 3:
        z.call(this, q[0], q[1], q[2]);
        break;
      default:
        z.apply(this, q);
        break;
    }
  }
  return true;
}, "br");
var yr = /* @__PURE__ */ __name(function($, ...q) {
  if ($ === "error") return dS(this, q);
  var { _events: K } = this;
  if (K === void 0) return false;
  var P = K[$];
  if (P === void 0) return false;
  let _ = P.length > 1 ? P.slice() : P;
  for (let Y = 0, { length: O } = _; Y < O; Y++) {
    let z = _[Y], J;
    switch (q.length) {
      case 0:
        J = z.call(this);
        break;
      case 1:
        J = z.call(this, q[0]);
        break;
      case 2:
        J = z.call(this, q[0], q[1]);
        break;
      case 3:
        J = z.call(this, q[0], q[1], q[2]);
        break;
      default:
        J = z.apply(this, q);
        break;
    }
    if (J !== void 0 && typeof J?.then === "function" && J.then === Promise.prototype.then) Lr(this, J, $, q);
  }
  return true;
}, "yr");
var yH;
var pr;
var n7 = m_(() => {
  var _a52;
  uH = Symbol.for, y_ = Symbol("kCapture"), cS = uH("events.errorMonitor"), Ir = Symbol("events.maxEventTargetListeners"), Dr = Symbol("events.maxEventTargetListenersWarned"), uS = uH("nodejs.rejection"), mS = uH("nodejs.rejection"), xS = Array.prototype.slice, g6 = $_.prototype = {};
  g6._events = void 0;
  g6._eventsCount = 0;
  g6._maxListeners = void 0;
  g6.setMaxListeners = function($) {
    return xH($, "setMaxListeners", 0), this._maxListeners = $, this;
  };
  g6.constructor = $_;
  g6.getMaxListeners = function() {
    return this?._maxListeners ?? u_;
  };
  g6.emit = br;
  g6.addListener = function($, q) {
    r7(q);
    var K = this._events;
    if (!K) K = this._events = { __proto__: null }, this._eventsCount = 0;
    else if (K.newListener) this.emit("newListener", $, q.listener ?? q);
    var P = K[$];
    if (!P) K[$] = [q], this._eventsCount++;
    else {
      P.push(q);
      var _ = this._maxListeners ?? u_;
      if (_ > 0 && P.length > _ && !P.warned) lS(this, $, P);
    }
    return this;
  };
  g6.on = g6.addListener;
  g6.prependListener = function($, q) {
    r7(q);
    var K = this._events;
    if (!K) K = this._events = { __proto__: null }, this._eventsCount = 0;
    else if (K.newListener) this.emit("newListener", $, q.listener ?? q);
    var P = K[$];
    if (!P) K[$] = [q], this._eventsCount++;
    else {
      P.unshift(q);
      var _ = this._maxListeners ?? u_;
      if (_ > 0 && P.length > _ && !P.warned) lS(this, $, P);
    }
    return this;
  };
  g6.once = function($, q) {
    r7(q);
    let K = rS.bind(this, $, q);
    return K.listener = q, this.addListener($, K), this;
  };
  g6.prependOnceListener = function($, q) {
    r7(q);
    let K = rS.bind(this, $, q);
    return K.listener = q, this.prependListener($, K), this;
  };
  g6.removeListener = function($, q) {
    r7(q);
    var { _events: K } = this;
    if (!K) return this;
    var P = K[$];
    if (!P) return this;
    var _ = P.length;
    let Y = -1;
    for (let O = _ - 1; O >= 0; O--) if (P[O] === q || P[O].listener === q) {
      Y = O;
      break;
    }
    if (Y < 0) return this;
    if (Y === 0) P.shift();
    else P.splice(Y, 1);
    if (P.length === 0) delete K[$], this._eventsCount--;
    return this;
  };
  g6.off = g6.removeListener;
  g6.removeAllListeners = function($) {
    var { _events: q } = this;
    if ($ && q) {
      if (q[$]) delete q[$], this._eventsCount--;
    } else this._events = { __proto__: null };
    return this;
  };
  g6.listeners = function($) {
    var { _events: q } = this;
    if (!q) return [];
    var K = q[$];
    if (!K) return [];
    return K.map((P) => P.listener ?? P);
  };
  g6.rawListeners = function($) {
    var { _events: q } = this;
    if (!q) return [];
    var K = q[$];
    if (!K) return [];
    return K.slice();
  };
  g6.listenerCount = function($) {
    var { _events: q } = this;
    if (!q) return 0;
    return q[$]?.length ?? 0;
  };
  g6.eventNames = function() {
    return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
  };
  g6[y_] = false;
  yH = (_a52 = class extends Error {
    constructor($ = "The operation was aborted", q = void 0) {
      if (q !== void 0 && typeof q !== "object") throw m4("options", "Object", q);
      super($, q);
      this.code = "ABORT_ERR", this.name = "AbortError";
    }
  }, __name(_a52, "yH"), _a52);
  Object.defineProperties($_, { captureRejections: { get() {
    return g6[y_];
  }, set($) {
    xr($, "EventEmitter.captureRejections"), g6[y_] = $;
  }, enumerable: true }, defaultMaxListeners: { enumerable: true, get: /* @__PURE__ */ __name(() => {
    return u_;
  }, "get"), set: /* @__PURE__ */ __name(($) => {
    xH($, "defaultMaxListeners", 0), u_ = $;
  }, "set") }, kMaxEventTargetListeners: { value: Ir, enumerable: false, configurable: false, writable: false }, kMaxEventTargetListenersWarned: { value: Dr, enumerable: false, configurable: false, writable: false } });
  Object.assign($_, { once: oS, getEventListeners: nS, getMaxListeners: US, setMaxListeners: iS, EventEmitter: $_, usingDomains: false, captureRejectionSymbol: mS, errorMonitor: cS, addAbortListener: FS, init: $_, listenerCount: tS });
  pr = $_;
});
var dH = x$((DP$, _0) => {
  var V6 = /* @__PURE__ */ __name(($, q) => () => (q || $((q = { exports: {} }).exports, q), q.exports), "V6"), u6 = V6(($, q) => {
    const _K2 = class _K2 extends Error {
      constructor(P) {
        if (!Array.isArray(P)) throw TypeError(`Expected input to be an Array, got ${typeof P}`);
        let _ = "";
        for (let Y = 0; Y < P.length; Y++) _ += `    ${P[Y].stack}
`;
        super(_);
        this.name = "AggregateError", this.errors = P;
      }
    };
    __name(_K2, "K");
    let K = _K2;
    q.exports = { AggregateError: K, ArrayIsArray(P) {
      return Array.isArray(P);
    }, ArrayPrototypeIncludes(P, _) {
      return P.includes(_);
    }, ArrayPrototypeIndexOf(P, _) {
      return P.indexOf(_);
    }, ArrayPrototypeJoin(P, _) {
      return P.join(_);
    }, ArrayPrototypeMap(P, _) {
      return P.map(_);
    }, ArrayPrototypePop(P, _) {
      return P.pop(_);
    }, ArrayPrototypePush(P, _) {
      return P.push(_);
    }, ArrayPrototypeSlice(P, _, Y) {
      return P.slice(_, Y);
    }, Error, FunctionPrototypeCall(P, _, ...Y) {
      return P.call(_, ...Y);
    }, FunctionPrototypeSymbolHasInstance(P, _) {
      return Function.prototype[Symbol.hasInstance].call(P, _);
    }, MathFloor: Math.floor, Number, NumberIsInteger: Number.isInteger, NumberIsNaN: Number.isNaN, NumberMAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER, NumberMIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER, NumberParseInt: Number.parseInt, ObjectDefineProperties(P, _) {
      return Object.defineProperties(P, _);
    }, ObjectDefineProperty(P, _, Y) {
      return Object.defineProperty(P, _, Y);
    }, ObjectGetOwnPropertyDescriptor(P, _) {
      return Object.getOwnPropertyDescriptor(P, _);
    }, ObjectKeys(P) {
      return Object.keys(P);
    }, ObjectSetPrototypeOf(P, _) {
      return Object.setPrototypeOf(P, _);
    }, Promise, PromisePrototypeCatch(P, _) {
      return P.catch(_);
    }, PromisePrototypeThen(P, _, Y) {
      return P.then(_, Y);
    }, PromiseReject(P) {
      return Promise.reject(P);
    }, PromiseResolve(P) {
      return Promise.resolve(P);
    }, ReflectApply: Reflect.apply, RegExpPrototypeTest(P, _) {
      return P.test(_);
    }, SafeSet: Set, String, StringPrototypeSlice(P, _, Y) {
      return P.slice(_, Y);
    }, StringPrototypeToLowerCase(P) {
      return P.toLowerCase();
    }, StringPrototypeToUpperCase(P) {
      return P.toUpperCase();
    }, StringPrototypeTrim(P) {
      return P.trim();
    }, Symbol, SymbolFor: Symbol.for, SymbolAsyncIterator: Symbol.asyncIterator, SymbolHasInstance: Symbol.hasInstance, SymbolIterator: Symbol.iterator, SymbolDispose: Symbol.dispose || Symbol("Symbol.dispose"), SymbolAsyncDispose: Symbol.asyncDispose || Symbol("Symbol.asyncDispose"), TypedArrayPrototypeSet(P, _, Y) {
      return P.set(_, Y);
    }, Boolean, Uint8Array };
  }), aS = V6(($, q) => {
    q.exports = { format(K, ...P) {
      return K.replace(/%([sdifj])/g, function(...[_, Y]) {
        let O = P.shift();
        if (Y === "f") return O.toFixed(6);
        else if (Y === "j") return JSON.stringify(O);
        else if (Y === "s" && typeof O === "object") return `${O.constructor !== Object ? O.constructor.name : ""} {}`.trim();
        else return O.toString();
      });
    }, inspect(K) {
      switch (typeof K) {
        case "string":
          if (K.includes("'")) {
            if (!K.includes('"')) return `"${K}"`;
            else if (!K.includes("`") && !K.includes("${")) return `\`${K}\``;
          }
          return `'${K}'`;
        case "number":
          if (isNaN(K)) return "NaN";
          else if (Object.is(K, -0)) return String(K);
          return K;
        case "bigint":
          return `${String(K)}n`;
        case "boolean":
        case "undefined":
          return String(K);
        case "object":
          return "{}";
      }
    } };
  }), mq = V6(($, q) => {
    var { format: K, inspect: P } = aS(), { AggregateError: _ } = u6(), Y = globalThis.AggregateError || _, O = Symbol("kIsNodeError"), z = ["string", "function", "number", "object", "Function", "Object", "boolean", "bigint", "symbol"], J = /^([A-Z][a-z0-9]*)+$/, T = {};
    function X(I, D) {
      if (!I) throw new T.ERR_INTERNAL_ASSERTION(D);
    }
    __name(X, "X");
    function f(I) {
      let D = "", g = I.length, b = I[0] === "-" ? 1 : 0;
      for (; g >= b + 4; g -= 3) D = `_${I.slice(g - 3, g)}${D}`;
      return `${I.slice(0, g)}${D}`;
    }
    __name(f, "f");
    function V(I, D, g) {
      if (typeof D === "function") return X(D.length <= g.length, `Code: ${I}; The provided arguments length (${g.length}) does not match the required ones (${D.length}).`), D(...g);
      let b = (D.match(/%[dfijoOs]/g) || []).length;
      if (X(b === g.length, `Code: ${I}; The provided arguments length (${g.length}) does not match the required ones (${b}).`), g.length === 0) return D;
      return K(D, ...g);
    }
    __name(V, "V");
    function M(I, D, g) {
      if (!g) g = Error;
      const _b2 = class _b2 extends g {
        constructor(...y) {
          super(V(I, D, y));
        }
        toString() {
          return `${this.name} [${I}]: ${this.message}`;
        }
      };
      __name(_b2, "b");
      let b = _b2;
      Object.defineProperties(b.prototype, { name: { value: g.name, writable: true, enumerable: false, configurable: true }, toString: { value() {
        return `${this.name} [${I}]: ${this.message}`;
      }, writable: true, enumerable: false, configurable: true } }), b.prototype.code = I, b.prototype[O] = true, T[I] = b;
    }
    __name(M, "M");
    function N(I) {
      let D = "__node_internal_" + I.name;
      return Object.defineProperty(I, "name", { value: D }), I;
    }
    __name(N, "N");
    function E(I, D) {
      if (I && D && I !== D) {
        if (Array.isArray(D.errors)) return D.errors.push(I), D;
        let g = new Y([D, I], D.message);
        return g.code = D.code, g;
      }
      return I || D;
    }
    __name(E, "E");
    const _h = class _h extends Error {
      constructor(I = "The operation was aborted", D = void 0) {
        if (D !== void 0 && typeof D !== "object") throw new T.ERR_INVALID_ARG_TYPE("options", "Object", D);
        super(I, D);
        this.code = "ABORT_ERR", this.name = "AbortError";
      }
    };
    __name(_h, "h");
    let h = _h;
    M("ERR_ASSERTION", "%s", Error), M("ERR_INVALID_ARG_TYPE", (I, D, g) => {
      if (X(typeof I === "string", "'name' must be a string"), !Array.isArray(D)) D = [D];
      let b = "The ";
      if (I.endsWith(" argument")) b += `${I} `;
      else b += `"${I}" ${I.includes(".") ? "property" : "argument"} `;
      b += "must be ";
      let y = [], p = [], n = [];
      for (let q$ of D) if (X(typeof q$ === "string", "All expected entries have to be of type string"), z.includes(q$)) y.push(q$.toLowerCase());
      else if (J.test(q$)) p.push(q$);
      else X(q$ !== "object", 'The value "object" should be written as "Object"'), n.push(q$);
      if (p.length > 0) {
        let q$ = y.indexOf("object");
        if (q$ !== -1) y.splice(y, q$, 1), p.push("Object");
      }
      if (y.length > 0) {
        switch (y.length) {
          case 1:
            b += `of type ${y[0]}`;
            break;
          case 2:
            b += `one of type ${y[0]} or ${y[1]}`;
            break;
          default: {
            let q$ = y.pop();
            b += `one of type ${y.join(", ")}, or ${q$}`;
          }
        }
        if (p.length > 0 || n.length > 0) b += " or ";
      }
      if (p.length > 0) {
        switch (p.length) {
          case 1:
            b += `an instance of ${p[0]}`;
            break;
          case 2:
            b += `an instance of ${p[0]} or ${p[1]}`;
            break;
          default: {
            let q$ = p.pop();
            b += `an instance of ${p.join(", ")}, or ${q$}`;
          }
        }
        if (n.length > 0) b += " or ";
      }
      switch (n.length) {
        case 0:
          break;
        case 1:
          if (n[0].toLowerCase() !== n[0]) b += "an ";
          b += `${n[0]}`;
          break;
        case 2:
          b += `one of ${n[0]} or ${n[1]}`;
          break;
        default: {
          let q$ = n.pop();
          b += `one of ${n.join(", ")}, or ${q$}`;
        }
      }
      if (g == null) b += `. Received ${g}`;
      else if (typeof g === "function" && g.name) b += `. Received function ${g.name}`;
      else if (typeof g === "object") {
        var s;
        if ((s = g.constructor) !== null && s !== void 0 && s.name) b += `. Received an instance of ${g.constructor.name}`;
        else {
          let q$ = P(g, { depth: -1 });
          b += `. Received ${q$}`;
        }
      } else {
        let q$ = P(g, { colors: false });
        if (q$.length > 25) q$ = `${q$.slice(0, 25)}...`;
        b += `. Received type ${typeof g} (${q$})`;
      }
      return b;
    }, TypeError), M("ERR_INVALID_ARG_VALUE", (I, D, g = "is invalid") => {
      let b = P(D);
      if (b.length > 128) b = b.slice(0, 128) + "...";
      return `The ${I.includes(".") ? "property" : "argument"} '${I}' ${g}. Received ${b}`;
    }, TypeError), M("ERR_INVALID_RETURN_VALUE", (I, D, g) => {
      var b;
      let y = g !== null && g !== void 0 && (b = g.constructor) !== null && b !== void 0 && b.name ? `instance of ${g.constructor.name}` : `type ${typeof g}`;
      return `Expected ${I} to be returned from the "${D}" function but got ${y}.`;
    }, TypeError), M("ERR_MISSING_ARGS", (...I) => {
      X(I.length > 0, "At least one arg needs to be specified");
      let D, g = I.length;
      switch (I = (Array.isArray(I) ? I : [I]).map((b) => `"${b}"`).join(" or "), g) {
        case 1:
          D += `The ${I[0]} argument`;
          break;
        case 2:
          D += `The ${I[0]} and ${I[1]} arguments`;
          break;
        default:
          {
            let b = I.pop();
            D += `The ${I.join(", ")}, and ${b} arguments`;
          }
          break;
      }
      return `${D} must be specified`;
    }, TypeError), M("ERR_OUT_OF_RANGE", (I, D, g) => {
      X(D, 'Missing "range" argument');
      let b;
      if (Number.isInteger(g) && Math.abs(g) > 4294967296) b = f(String(g));
      else if (typeof g === "bigint") {
        b = String(g);
        let y = BigInt(2) ** BigInt(32);
        if (g > y || g < -y) b = f(b);
        b += "n";
      } else b = P(g);
      return `The value of "${I}" is out of range. It must be ${D}. Received ${b}`;
    }, RangeError), M("ERR_MULTIPLE_CALLBACK", "Callback called multiple times", Error), M("ERR_METHOD_NOT_IMPLEMENTED", "The %s method is not implemented", Error), M("ERR_STREAM_ALREADY_FINISHED", "Cannot call %s after a stream was finished", Error), M("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable", Error), M("ERR_STREAM_DESTROYED", "Cannot call %s after a stream was destroyed", Error), M("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError), M("ERR_STREAM_PREMATURE_CLOSE", "Premature close", Error), M("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF", Error), M("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event", Error), M("ERR_STREAM_WRITE_AFTER_END", "write after end", Error), M("ERR_UNKNOWN_ENCODING", "Unknown encoding: %s", TypeError), q.exports = { AbortError: h, aggregateTwoErrors: N(E), hideStackFrames: N, codes: T };
  }), cr = V6(($, q) => {
    Object.defineProperty($, "__esModule", { value: true });
    var K = /* @__PURE__ */ new WeakMap(), P = /* @__PURE__ */ new WeakMap();
    function _(c) {
      let U = K.get(c);
      return console.assert(U != null, "'this' is expected an Event object, but got", c), U;
    }
    __name(_, "_");
    function Y(c) {
      if (c.passiveListener != null) {
        if (typeof console < "u" && typeof console.error === "function") console.error("Unable to preventDefault inside passive event listener invocation.", c.passiveListener);
        return;
      }
      if (!c.event.cancelable) return;
      if (c.canceled = true, typeof c.event.preventDefault === "function") c.event.preventDefault();
    }
    __name(Y, "Y");
    function O(c, U) {
      K.set(this, { eventTarget: c, event: U, eventPhase: 2, currentTarget: c, canceled: false, stopped: false, immediateStopped: false, passiveListener: null, timeStamp: U.timeStamp || Date.now() }), Object.defineProperty(this, "isTrusted", { value: false, enumerable: true });
      let j = Object.keys(U);
      for (let H = 0; H < j.length; ++H) {
        let Z = j[H];
        if (!(Z in this)) Object.defineProperty(this, Z, z(Z));
      }
    }
    __name(O, "O");
    if (O.prototype = { get type() {
      return _(this).event.type;
    }, get target() {
      return _(this).eventTarget;
    }, get currentTarget() {
      return _(this).currentTarget;
    }, composedPath() {
      let c = _(this).currentTarget;
      if (c == null) return [];
      return [c];
    }, get NONE() {
      return 0;
    }, get CAPTURING_PHASE() {
      return 1;
    }, get AT_TARGET() {
      return 2;
    }, get BUBBLING_PHASE() {
      return 3;
    }, get eventPhase() {
      return _(this).eventPhase;
    }, stopPropagation() {
      let c = _(this);
      if (c.stopped = true, typeof c.event.stopPropagation === "function") c.event.stopPropagation();
    }, stopImmediatePropagation() {
      let c = _(this);
      if (c.stopped = true, c.immediateStopped = true, typeof c.event.stopImmediatePropagation === "function") c.event.stopImmediatePropagation();
    }, get bubbles() {
      return Boolean(_(this).event.bubbles);
    }, get cancelable() {
      return Boolean(_(this).event.cancelable);
    }, preventDefault() {
      Y(_(this));
    }, get defaultPrevented() {
      return _(this).canceled;
    }, get composed() {
      return Boolean(_(this).event.composed);
    }, get timeStamp() {
      return _(this).timeStamp;
    }, get srcElement() {
      return _(this).eventTarget;
    }, get cancelBubble() {
      return _(this).stopped;
    }, set cancelBubble(c) {
      if (!c) return;
      let U = _(this);
      if (U.stopped = true, typeof U.event.cancelBubble === "boolean") U.event.cancelBubble = true;
    }, get returnValue() {
      return !_(this).canceled;
    }, set returnValue(c) {
      if (!c) Y(_(this));
    }, initEvent() {
    } }, Object.defineProperty(O.prototype, "constructor", { value: O, configurable: true, writable: true }), typeof window < "u" && typeof window.Event < "u") Object.setPrototypeOf(O.prototype, window.Event.prototype), P.set(window.Event.prototype, O);
    function z(c) {
      return { get() {
        return _(this).event[c];
      }, set(U) {
        _(this).event[c] = U;
      }, configurable: true, enumerable: true };
    }
    __name(z, "z");
    function J(c) {
      return { value() {
        let U = _(this).event;
        return U[c].apply(U, arguments);
      }, configurable: true, enumerable: true };
    }
    __name(J, "J");
    function T(c, U) {
      let j = Object.keys(U);
      if (j.length === 0) return c;
      function H(Z, W) {
        c.call(this, Z, W);
      }
      __name(H, "H");
      H.prototype = Object.create(c.prototype, { constructor: { value: H, configurable: true, writable: true } });
      for (let Z = 0; Z < j.length; ++Z) {
        let W = j[Z];
        if (!(W in c.prototype)) {
          let w = typeof Object.getOwnPropertyDescriptor(U, W).value === "function";
          Object.defineProperty(H.prototype, W, w ? J(W) : z(W));
        }
      }
      return H;
    }
    __name(T, "T");
    function X(c) {
      if (c == null || c === Object.prototype) return O;
      let U = P.get(c);
      if (U == null) U = T(X(Object.getPrototypeOf(c)), c), P.set(c, U);
      return U;
    }
    __name(X, "X");
    function f(c, U) {
      return new (X(Object.getPrototypeOf(U)))(c, U);
    }
    __name(f, "f");
    function V(c) {
      return _(c).immediateStopped;
    }
    __name(V, "V");
    function M(c, U) {
      _(c).eventPhase = U;
    }
    __name(M, "M");
    function N(c, U) {
      _(c).currentTarget = U;
    }
    __name(N, "N");
    function E(c, U) {
      _(c).passiveListener = U;
    }
    __name(E, "E");
    var h = /* @__PURE__ */ new WeakMap(), I = 1, D = 2, g = 3;
    function b(c) {
      return c !== null && typeof c === "object";
    }
    __name(b, "b");
    function y(c) {
      let U = h.get(c);
      if (U == null) throw TypeError("'this' is expected an EventTarget object, but got another value.");
      return U;
    }
    __name(y, "y");
    function p(c) {
      return { get() {
        let U = y(this).get(c);
        while (U != null) {
          if (U.listenerType === g) return U.listener;
          U = U.next;
        }
        return null;
      }, set(U) {
        if (typeof U !== "function" && !b(U)) U = null;
        let j = y(this), H = null, Z = j.get(c);
        while (Z != null) {
          if (Z.listenerType === g) if (H !== null) H.next = Z.next;
          else if (Z.next !== null) j.set(c, Z.next);
          else j.delete(c);
          else H = Z;
          Z = Z.next;
        }
        if (U !== null) {
          let W = { listener: U, listenerType: g, passive: false, once: false, next: null };
          if (H === null) j.set(c, W);
          else H.next = W;
        }
      }, configurable: true, enumerable: true };
    }
    __name(p, "p");
    function n(c, U) {
      Object.defineProperty(c, `on${U}`, p(U));
    }
    __name(n, "n");
    function s(c) {
      function U() {
        q$.call(this);
      }
      __name(U, "U");
      U.prototype = Object.create(q$.prototype, { constructor: { value: U, configurable: true, writable: true } });
      for (let j = 0; j < c.length; ++j) n(U.prototype, c[j]);
      return U;
    }
    __name(s, "s");
    function q$() {
      if (this instanceof q$) {
        h.set(this, /* @__PURE__ */ new Map());
        return;
      }
      if (arguments.length === 1 && Array.isArray(arguments[0])) return s(arguments[0]);
      if (arguments.length > 0) {
        let c = Array(arguments.length);
        for (let U = 0; U < arguments.length; ++U) c[U] = arguments[U];
        return s(c);
      }
      throw TypeError("Cannot call a class as a function");
    }
    __name(q$, "q$");
    if (q$.prototype = { addEventListener(c, U, j) {
      if (U == null) return;
      if (typeof U !== "function" && !b(U)) throw TypeError("'listener' should be a function or an object.");
      let H = y(this), Z = b(j), W = (Z ? Boolean(j.capture) : Boolean(j)) ? I : D, w = { listener: U, listenerType: W, passive: Z && Boolean(j.passive), once: Z && Boolean(j.once), next: null }, G = H.get(c);
      if (G === void 0) {
        H.set(c, w);
        return;
      }
      let S = null;
      while (G != null) {
        if (G.listener === U && G.listenerType === W) return;
        S = G, G = G.next;
      }
      S.next = w;
    }, removeEventListener(c, U, j) {
      if (U == null) return;
      let H = y(this), Z = (b(j) ? Boolean(j.capture) : Boolean(j)) ? I : D, W = null, w = H.get(c);
      while (w != null) {
        if (w.listener === U && w.listenerType === Z) {
          if (W !== null) W.next = w.next;
          else if (w.next !== null) H.set(c, w.next);
          else H.delete(c);
          return;
        }
        W = w, w = w.next;
      }
    }, dispatchEvent(c) {
      if (c == null || typeof c.type !== "string") throw TypeError('"event.type" should be a string.');
      let U = y(this), j = c.type, H = U.get(j);
      if (H == null) return true;
      let Z = f(this, c), W = null;
      while (H != null) {
        if (H.once) if (W !== null) W.next = H.next;
        else if (H.next !== null) U.set(j, H.next);
        else U.delete(j);
        else W = H;
        if (E(Z, H.passive ? H.listener : null), typeof H.listener === "function") try {
          H.listener.call(this, Z);
        } catch (w) {
          if (typeof console < "u" && typeof console.error === "function") console.error(w);
        }
        else if (H.listenerType !== g && typeof H.listener.handleEvent === "function") H.listener.handleEvent(Z);
        if (V(Z)) break;
        H = H.next;
      }
      return E(Z, null), M(Z, 0), N(Z, null), !Z.defaultPrevented;
    } }, Object.defineProperty(q$.prototype, "constructor", { value: q$, configurable: true, writable: true }), typeof window < "u" && typeof window.EventTarget < "u") Object.setPrototypeOf(q$.prototype, window.EventTarget.prototype);
    $.defineEventAttribute = n, $.EventTarget = q$, $.default = q$, q.exports = q$, q.exports.EventTarget = q.exports.default = q$, q.exports.defineEventAttribute = n;
  }), i7 = V6(($, q) => {
    Object.defineProperty($, "__esModule", { value: true });
    var K = cr();
    const _P3 = class _P3 extends K.EventTarget {
      constructor() {
        super();
        throw TypeError("AbortSignal cannot be constructed directly");
      }
      get aborted() {
        let X = O.get(this);
        if (typeof X !== "boolean") throw TypeError(`Expected 'this' to be an 'AbortSignal' object, but got ${this === null ? "null" : typeof this}`);
        return X;
      }
    };
    __name(_P3, "P");
    let P = _P3;
    K.defineEventAttribute(P.prototype, "abort");
    function _() {
      let X = Object.create(P.prototype);
      return K.EventTarget.call(X), O.set(X, false), X;
    }
    __name(_, "_");
    function Y(X) {
      if (O.get(X) !== false) return;
      O.set(X, true), X.dispatchEvent({ type: "abort" });
    }
    __name(Y, "Y");
    var O = /* @__PURE__ */ new WeakMap();
    if (Object.defineProperties(P.prototype, { aborted: { enumerable: true } }), typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol") Object.defineProperty(P.prototype, Symbol.toStringTag, { configurable: true, value: "AbortSignal" });
    const _z2 = class _z2 {
      constructor() {
        J.set(this, _());
      }
      get signal() {
        return T(this);
      }
      abort() {
        Y(T(this));
      }
    };
    __name(_z2, "z");
    let z = _z2;
    var J = /* @__PURE__ */ new WeakMap();
    function T(X) {
      let f = J.get(X);
      if (f == null) throw TypeError(`Expected 'this' to be an 'AbortController' object, but got ${X === null ? "null" : typeof X}`);
      return f;
    }
    __name(T, "T");
    if (Object.defineProperties(z.prototype, { signal: { enumerable: true }, abort: { enumerable: true } }), typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol") Object.defineProperty(z.prototype, Symbol.toStringTag, { configurable: true, value: "AbortController" });
    $.AbortController = z, $.AbortSignal = P, $.default = z, q.exports = z, q.exports.AbortController = q.exports.default = z, q.exports.AbortSignal = P;
  }), $8 = V6(($, q) => {
    var K = (fq(), J6(wq)), { format: P, inspect: _ } = aS(), { codes: { ERR_INVALID_ARG_TYPE: Y } } = mq(), { kResistStopPropagation: O, AggregateError: z, SymbolDispose: J } = u6(), T = globalThis.AbortSignal || i7().AbortSignal, X = globalThis.AbortController || i7().AbortController, f = Object.getPrototypeOf(async function() {
    }).constructor, V = globalThis.Blob || K.Blob, M = typeof V < "u" ? function(h) {
      return h instanceof V;
    } : function(h) {
      return false;
    }, N = /* @__PURE__ */ __name((h, I) => {
      if (h !== void 0 && (h === null || typeof h !== "object" || !("aborted" in h))) throw new Y(I, "AbortSignal", h);
    }, "N"), E = /* @__PURE__ */ __name((h, I) => {
      if (typeof h !== "function") throw new Y(I, "Function", h);
    }, "E");
    q.exports = { AggregateError: z, kEmptyObject: Object.freeze({}), once(h) {
      let I = false;
      return function(...D) {
        if (I) return;
        I = true, h.apply(this, D);
      };
    }, createDeferredPromise: /* @__PURE__ */ __name(function() {
      let h, I;
      return { promise: new Promise((D, g) => {
        h = D, I = g;
      }), resolve: h, reject: I };
    }, "createDeferredPromise"), promisify(h) {
      return new Promise((I, D) => {
        h((g, ...b) => {
          if (g) return D(g);
          return I(...b);
        });
      });
    }, debuglog() {
      return function() {
      };
    }, format: P, inspect: _, types: { isAsyncFunction(h) {
      return h instanceof f;
    }, isArrayBufferView(h) {
      return ArrayBuffer.isView(h);
    } }, isBlob: M, deprecate(h, I) {
      return h;
    }, addAbortListener: (n7(), J6(o7)).addAbortListener || function(h, I) {
      if (h === void 0) throw new Y("signal", "AbortSignal", h);
      N(h, "signal"), E(I, "listener");
      let D;
      if (h.aborted) queueMicrotask(() => I());
      else h.addEventListener("abort", I, { __proto__: null, once: true, [O]: true }), D = /* @__PURE__ */ __name(() => {
        h.removeEventListener("abort", I);
      }, "D");
      return { __proto__: null, [J]() {
        var g;
        (g = D) === null || g === void 0 || g();
      } };
    }, AbortSignalAny: T.any || function(h) {
      if (h.length === 1) return h[0];
      let I = new X(), D = /* @__PURE__ */ __name(() => I.abort(), "D");
      return h.forEach((g) => {
        N(g, "signals"), g.addEventListener("abort", D, { once: true });
      }), I.signal.addEventListener("abort", () => {
        h.forEach((g) => g.removeEventListener("abort", D));
      }, { once: true }), I.signal;
    } }, q.exports.promisify.custom = Symbol.for("nodejs.util.promisify.custom");
  }), t7 = V6(($, q) => {
    var { ArrayIsArray: K, ArrayPrototypeIncludes: P, ArrayPrototypeJoin: _, ArrayPrototypeMap: Y, NumberIsInteger: O, NumberIsNaN: z, NumberMAX_SAFE_INTEGER: J, NumberMIN_SAFE_INTEGER: T, NumberParseInt: X, ObjectPrototypeHasOwnProperty: f, RegExpPrototypeExec: V, String: M, StringPrototypeToUpperCase: N, StringPrototypeTrim: E } = u6(), { hideStackFrames: h, codes: { ERR_SOCKET_BAD_PORT: I, ERR_INVALID_ARG_TYPE: D, ERR_INVALID_ARG_VALUE: g, ERR_OUT_OF_RANGE: b, ERR_UNKNOWN_SIGNAL: y } } = mq(), { normalizeEncoding: p } = $8(), { isAsyncFunction: n, isArrayBufferView: s } = $8().types, q$ = {};
    function c(d) {
      return d === (d | 0);
    }
    __name(c, "c");
    function U(d) {
      return d === d >>> 0;
    }
    __name(U, "U");
    var j = /^[0-7]+$/, H = "must be a 32-bit unsigned integer or an octal string";
    function Z(d, o, W$) {
      if (typeof d > "u") d = W$;
      if (typeof d === "string") {
        if (V(j, d) === null) throw new g(o, d, H);
        d = X(d, 8);
      }
      return G(d, o), d;
    }
    __name(Z, "Z");
    var W = h((d, o, W$ = T, B = J) => {
      if (typeof d !== "number") throw new D(o, "number", d);
      if (!O(d)) throw new b(o, "an integer", d);
      if (d < W$ || d > B) throw new b(o, `>= ${W$} && <= ${B}`, d);
    }), w = h((d, o, W$ = -2147483648, B = 2147483647) => {
      if (typeof d !== "number") throw new D(o, "number", d);
      if (!O(d)) throw new b(o, "an integer", d);
      if (d < W$ || d > B) throw new b(o, `>= ${W$} && <= ${B}`, d);
    }), G = h((d, o, W$ = false) => {
      if (typeof d !== "number") throw new D(o, "number", d);
      if (!O(d)) throw new b(o, "an integer", d);
      let B = W$ ? 1 : 0, F = 4294967295;
      if (d < B || d > F) throw new b(o, `>= ${B} && <= ${F}`, d);
    });
    function S(d, o) {
      if (typeof d !== "string") throw new D(o, "string", d);
    }
    __name(S, "S");
    function A(d, o, W$ = void 0, B) {
      if (typeof d !== "number") throw new D(o, "number", d);
      if (W$ != null && d < W$ || B != null && d > B || (W$ != null || B != null) && z(d)) throw new b(o, `${W$ != null ? `>= ${W$}` : ""}${W$ != null && B != null ? " && " : ""}${B != null ? `<= ${B}` : ""}`, d);
    }
    __name(A, "A");
    var v = h((d, o, W$) => {
      if (!P(W$, d)) {
        let B = "must be one of: " + _(Y(W$, (F) => typeof F === "string" ? `'${F}'` : M(F)), ", ");
        throw new g(o, d, B);
      }
    });
    function k(d, o) {
      if (typeof d !== "boolean") throw new D(o, "boolean", d);
    }
    __name(k, "k");
    function R(d, o, W$) {
      return d == null || !f(d, o) ? W$ : d[o];
    }
    __name(R, "R");
    var C = h((d, o, W$ = null) => {
      let B = R(W$, "allowArray", false), F = R(W$, "allowFunction", false);
      if (!R(W$, "nullable", false) && d === null || !B && K(d) || typeof d !== "object" && (!F || typeof d !== "function")) throw new D(o, "Object", d);
    }), L = h((d, o) => {
      if (d != null && typeof d !== "object" && typeof d !== "function") throw new D(o, "a dictionary", d);
    }), x = h((d, o, W$ = 0) => {
      if (!K(d)) throw new D(o, "Array", d);
      if (d.length < W$) {
        let B = `must be longer than ${W$}`;
        throw new g(o, d, B);
      }
    });
    function l(d, o) {
      x(d, o);
      for (let W$ = 0; W$ < d.length; W$++) S(d[W$], `${o}[${W$}]`);
    }
    __name(l, "l");
    function a(d, o) {
      x(d, o);
      for (let W$ = 0; W$ < d.length; W$++) k(d[W$], `${o}[${W$}]`);
    }
    __name(a, "a");
    function f$(d, o) {
      x(d, o);
      for (let W$ = 0; W$ < d.length; W$++) {
        let B = d[W$], F = `${o}[${W$}]`;
        if (B == null) throw new D(F, "AbortSignal", B);
        v$(B, F);
      }
    }
    __name(f$, "f$");
    function $$(d, o = "signal") {
      if (S(d, o), q$[d] === void 0) {
        if (q$[N(d)] !== void 0) throw new y(d + " (signals must use all capital letters)");
        throw new y(d);
      }
    }
    __name($$, "$$");
    var t = h((d, o = "buffer") => {
      if (!s(d)) throw new D(o, ["Buffer", "TypedArray", "DataView"], d);
    });
    function H$(d, o) {
      let W$ = p(o), B = d.length;
      if (W$ === "hex" && B % 2 !== 0) throw new g("encoding", o, `is invalid for data of length ${B}`);
    }
    __name(H$, "H$");
    function Q(d, o = "Port", W$ = true) {
      if (typeof d !== "number" && typeof d !== "string" || typeof d === "string" && E(d).length === 0 || +d !== +d >>> 0 || d > 65535 || d === 0 && !W$) throw new I(o, d, W$);
      return d | 0;
    }
    __name(Q, "Q");
    var v$ = h((d, o) => {
      if (d !== void 0 && (d === null || typeof d !== "object" || !("aborted" in d))) throw new D(o, "AbortSignal", d);
    }), B$ = h((d, o) => {
      if (typeof d !== "function") throw new D(o, "Function", d);
    }), m = h((d, o) => {
      if (typeof d !== "function" || n(d)) throw new D(o, "Function", d);
    }), r = h((d, o) => {
      if (d !== void 0) throw new D(o, "undefined", d);
    });
    function J$(d, o, W$) {
      if (!P(W$, d)) throw new D(o, `('${_(W$, "|")}')`, d);
    }
    __name(J$, "J$");
    var e = /^(?:<[^>]*>)(?:\s*;\s*[^;"\s]+(?:=(")?[^;"\s]*\1)?)*$/;
    function _$2(d, o) {
      if (typeof d > "u" || !V(e, d)) throw new g(o, d, 'must be an array or string of format "</styles.css>; rel=preload; as=style"');
    }
    __name(_$2, "_$");
    function Y$(d) {
      if (typeof d === "string") return _$2(d, "hints"), d;
      else if (K(d)) {
        let o = d.length, W$ = "";
        if (o === 0) return W$;
        for (let B = 0; B < o; B++) {
          let F = d[B];
          if (_$2(F, "hints"), W$ += F, B !== o - 1) W$ += ", ";
        }
        return W$;
      }
      throw new g("hints", d, 'must be an array or string of format "</styles.css>; rel=preload; as=style"');
    }
    __name(Y$, "Y$");
    q.exports = { isInt32: c, isUint32: U, parseFileMode: Z, validateArray: x, validateStringArray: l, validateBooleanArray: a, validateAbortSignalArray: f$, validateBoolean: k, validateBuffer: t, validateDictionary: L, validateEncoding: H$, validateFunction: B$, validateInt32: w, validateInteger: W, validateNumber: A, validateObject: C, validateOneOf: v, validatePlainFunction: m, validatePort: Q, validateSignalName: $$, validateString: S, validateUint32: G, validateUndefined: r, validateUnion: J$, validateAbortSignal: v$, validateLinkHeaderValue: Y$ };
  }), x_ = V6(($, q) => {
    q.exports = globalThis.process;
  }), NK = V6(($, q) => {
    var { SymbolAsyncIterator: K, SymbolIterator: P, SymbolFor: _ } = u6(), Y = _("nodejs.stream.destroyed"), O = _("nodejs.stream.errored"), z = _("nodejs.stream.readable"), J = _("nodejs.stream.writable"), T = _("nodejs.stream.disturbed"), X = _("nodejs.webstream.isClosedPromise"), f = _("nodejs.webstream.controllerErrorFunction");
    function V(R, C = false) {
      var L;
      return !!(R && typeof R.pipe === "function" && typeof R.on === "function" && (!C || typeof R.pause === "function" && typeof R.resume === "function") && (!R._writableState || ((L = R._readableState) === null || L === void 0 ? void 0 : L.readable) !== false) && (!R._writableState || R._readableState));
    }
    __name(V, "V");
    function M(R) {
      var C;
      return !!(R && typeof R.write === "function" && typeof R.on === "function" && (!R._readableState || ((C = R._writableState) === null || C === void 0 ? void 0 : C.writable) !== false));
    }
    __name(M, "M");
    function N(R) {
      return !!(R && typeof R.pipe === "function" && R._readableState && typeof R.on === "function" && typeof R.write === "function");
    }
    __name(N, "N");
    function E(R) {
      return R && (R._readableState || R._writableState || typeof R.write === "function" && typeof R.on === "function" || typeof R.pipe === "function" && typeof R.on === "function");
    }
    __name(E, "E");
    function h(R) {
      return !!(R && !E(R) && typeof R.pipeThrough === "function" && typeof R.getReader === "function" && typeof R.cancel === "function");
    }
    __name(h, "h");
    function I(R) {
      return !!(R && !E(R) && typeof R.getWriter === "function" && typeof R.abort === "function");
    }
    __name(I, "I");
    function D(R) {
      return !!(R && !E(R) && typeof R.readable === "object" && typeof R.writable === "object");
    }
    __name(D, "D");
    function g(R) {
      return h(R) || I(R) || D(R);
    }
    __name(g, "g");
    function b(R, C) {
      if (R == null) return false;
      if (C === true) return typeof R[K] === "function";
      if (C === false) return typeof R[P] === "function";
      return typeof R[K] === "function" || typeof R[P] === "function";
    }
    __name(b, "b");
    function y(R) {
      if (!E(R)) return null;
      let { _writableState: C, _readableState: L } = R, x = C || L;
      return !!(R.destroyed || R[Y] || x !== null && x !== void 0 && x.destroyed);
    }
    __name(y, "y");
    function p(R) {
      if (!M(R)) return null;
      if (R.writableEnded === true) return true;
      let C = R._writableState;
      if (C !== null && C !== void 0 && C.errored) return false;
      if (typeof (C === null || C === void 0 ? void 0 : C.ended) !== "boolean") return null;
      return C.ended;
    }
    __name(p, "p");
    function n(R, C) {
      if (!M(R)) return null;
      if (R.writableFinished === true) return true;
      let L = R._writableState;
      if (L !== null && L !== void 0 && L.errored) return false;
      if (typeof (L === null || L === void 0 ? void 0 : L.finished) !== "boolean") return null;
      return !!(L.finished || C === false && L.ended === true && L.length === 0);
    }
    __name(n, "n");
    function s(R) {
      if (!V(R)) return null;
      if (R.readableEnded === true) return true;
      let C = R._readableState;
      if (!C || C.errored) return false;
      if (typeof (C === null || C === void 0 ? void 0 : C.ended) !== "boolean") return null;
      return C.ended;
    }
    __name(s, "s");
    function q$(R, C) {
      if (!V(R)) return null;
      let L = R._readableState;
      if (L !== null && L !== void 0 && L.errored) return false;
      if (typeof (L === null || L === void 0 ? void 0 : L.endEmitted) !== "boolean") return null;
      return !!(L.endEmitted || C === false && L.ended === true && L.length === 0);
    }
    __name(q$, "q$");
    function c(R) {
      if (R && R[z] != null) return R[z];
      if (typeof (R === null || R === void 0 ? void 0 : R.readable) !== "boolean") return null;
      if (y(R)) return false;
      return V(R) && R.readable && !q$(R);
    }
    __name(c, "c");
    function U(R) {
      if (R && R[J] != null) return R[J];
      if (typeof (R === null || R === void 0 ? void 0 : R.writable) !== "boolean") return null;
      if (y(R)) return false;
      return M(R) && R.writable && !p(R);
    }
    __name(U, "U");
    function j(R, C) {
      if (!E(R)) return null;
      if (y(R)) return true;
      if ((C === null || C === void 0 ? void 0 : C.readable) !== false && c(R)) return false;
      if ((C === null || C === void 0 ? void 0 : C.writable) !== false && U(R)) return false;
      return true;
    }
    __name(j, "j");
    function H(R) {
      var C, L;
      if (!E(R)) return null;
      if (R.writableErrored) return R.writableErrored;
      return (C = (L = R._writableState) === null || L === void 0 ? void 0 : L.errored) !== null && C !== void 0 ? C : null;
    }
    __name(H, "H");
    function Z(R) {
      var C, L;
      if (!E(R)) return null;
      if (R.readableErrored) return R.readableErrored;
      return (C = (L = R._readableState) === null || L === void 0 ? void 0 : L.errored) !== null && C !== void 0 ? C : null;
    }
    __name(Z, "Z");
    function W(R) {
      if (!E(R)) return null;
      if (typeof R.closed === "boolean") return R.closed;
      let { _writableState: C, _readableState: L } = R;
      if (typeof (C === null || C === void 0 ? void 0 : C.closed) === "boolean" || typeof (L === null || L === void 0 ? void 0 : L.closed) === "boolean") return (C === null || C === void 0 ? void 0 : C.closed) || (L === null || L === void 0 ? void 0 : L.closed);
      if (typeof R._closed === "boolean" && w(R)) return R._closed;
      return null;
    }
    __name(W, "W");
    function w(R) {
      return typeof R._closed === "boolean" && typeof R._defaultKeepAlive === "boolean" && typeof R._removedConnection === "boolean" && typeof R._removedContLen === "boolean";
    }
    __name(w, "w");
    function G(R) {
      return typeof R._sent100 === "boolean" && w(R);
    }
    __name(G, "G");
    function S(R) {
      var C;
      return typeof R._consuming === "boolean" && typeof R._dumped === "boolean" && ((C = R.req) === null || C === void 0 ? void 0 : C.upgradeOrConnect) === void 0;
    }
    __name(S, "S");
    function A(R) {
      if (!E(R)) return null;
      let { _writableState: C, _readableState: L } = R, x = C || L;
      return !x && G(R) || !!(x && x.autoDestroy && x.emitClose && x.closed === false);
    }
    __name(A, "A");
    function v(R) {
      var C;
      return !!(R && ((C = R[T]) !== null && C !== void 0 ? C : R.readableDidRead || R.readableAborted));
    }
    __name(v, "v");
    function k(R) {
      var C, L, x, l, a, f$, $$, t, H$, Q;
      return !!(R && ((C = (L = (x = (l = (a = (f$ = R[O]) !== null && f$ !== void 0 ? f$ : R.readableErrored) !== null && a !== void 0 ? a : R.writableErrored) !== null && l !== void 0 ? l : ($$ = R._readableState) === null || $$ === void 0 ? void 0 : $$.errorEmitted) !== null && x !== void 0 ? x : (t = R._writableState) === null || t === void 0 ? void 0 : t.errorEmitted) !== null && L !== void 0 ? L : (H$ = R._readableState) === null || H$ === void 0 ? void 0 : H$.errored) !== null && C !== void 0 ? C : (Q = R._writableState) === null || Q === void 0 ? void 0 : Q.errored));
    }
    __name(k, "k");
    q.exports = { isDestroyed: y, kIsDestroyed: Y, isDisturbed: v, kIsDisturbed: T, isErrored: k, kIsErrored: O, isReadable: c, kIsReadable: z, kIsClosedPromise: X, kControllerErrorFunction: f, kIsWritable: J, isClosed: W, isDuplexNodeStream: N, isFinished: j, isIterable: b, isReadableNodeStream: V, isReadableStream: h, isReadableEnded: s, isReadableFinished: q$, isReadableErrored: Z, isNodeStream: E, isWebStream: g, isWritable: U, isWritableNodeStream: M, isWritableStream: I, isWritableEnded: p, isWritableFinished: n, isWritableErrored: H, isServerRequest: S, isServerResponse: G, willEmitClose: A, isTransformStream: D };
  }), q_ = V6(($, q) => {
    var K = x_(), { AbortError: P, codes: _ } = mq(), { ERR_INVALID_ARG_TYPE: Y, ERR_STREAM_PREMATURE_CLOSE: O } = _, { kEmptyObject: z, once: J } = $8(), { validateAbortSignal: T, validateFunction: X, validateObject: f, validateBoolean: V } = t7(), { Promise: M, PromisePrototypeThen: N, SymbolDispose: E } = u6(), { isClosed: h, isReadable: I, isReadableNodeStream: D, isReadableStream: g, isReadableFinished: b, isReadableErrored: y, isWritable: p, isWritableNodeStream: n, isWritableStream: s, isWritableFinished: q$, isWritableErrored: c, isNodeStream: U, willEmitClose: j, kIsClosedPromise: H } = NK(), Z;
    function W(v) {
      return v.setHeader && typeof v.abort === "function";
    }
    __name(W, "W");
    var w = /* @__PURE__ */ __name(() => {
    }, "w");
    function G(v, k, R) {
      var C, L;
      if (arguments.length === 2) R = k, k = z;
      else if (k == null) k = z;
      else f(k, "options");
      if (X(R, "callback"), T(k.signal, "options.signal"), R = J(R), g(v) || s(v)) return S(v, k, R);
      if (!U(v)) throw new Y("stream", ["ReadableStream", "WritableStream", "Stream"], v);
      let x = (C = k.readable) !== null && C !== void 0 ? C : D(v), l = (L = k.writable) !== null && L !== void 0 ? L : n(v), a = v._writableState, f$ = v._readableState, $$ = /* @__PURE__ */ __name(() => {
        if (!v.writable) Q();
      }, "$$"), t = j(v) && D(v) === x && n(v) === l, H$ = q$(v, false), Q = /* @__PURE__ */ __name(() => {
        if (H$ = true, v.destroyed) t = false;
        if (t && (!v.readable || x)) return;
        if (!x || v$) R.call(v);
      }, "Q"), v$ = b(v, false), B$ = /* @__PURE__ */ __name(() => {
        if (v$ = true, v.destroyed) t = false;
        if (t && (!v.writable || l)) return;
        if (!l || H$) R.call(v);
      }, "B$"), m = /* @__PURE__ */ __name((d) => {
        R.call(v, d);
      }, "m"), r = h(v), J$ = /* @__PURE__ */ __name(() => {
        r = true;
        let d = c(v) || y(v);
        if (d && typeof d !== "boolean") return R.call(v, d);
        if (x && !v$ && D(v, true)) {
          if (!b(v, false)) return R.call(v, new O());
        }
        if (l && !H$) {
          if (!q$(v, false)) return R.call(v, new O());
        }
        R.call(v);
      }, "J$"), e = /* @__PURE__ */ __name(() => {
        r = true;
        let d = c(v) || y(v);
        if (d && typeof d !== "boolean") return R.call(v, d);
        R.call(v);
      }, "e"), _$2 = /* @__PURE__ */ __name(() => {
        v.req.on("finish", Q);
      }, "_$");
      if (W(v)) {
        if (v.on("complete", Q), !t) v.on("abort", J$);
        if (v.req) _$2();
        else v.on("request", _$2);
      } else if (l && !a) v.on("end", $$), v.on("close", $$);
      if (!t && typeof v.aborted === "boolean") v.on("aborted", J$);
      if (v.on("end", B$), v.on("finish", Q), k.error !== false) v.on("error", m);
      if (v.on("close", J$), r) K.nextTick(J$);
      else if (a !== null && a !== void 0 && a.errorEmitted || f$ !== null && f$ !== void 0 && f$.errorEmitted) {
        if (!t) K.nextTick(e);
      } else if (!x && (!t || I(v)) && (H$ || p(v) === false)) K.nextTick(e);
      else if (!l && (!t || p(v)) && (v$ || I(v) === false)) K.nextTick(e);
      else if (f$ && v.req && v.aborted) K.nextTick(e);
      let Y$ = /* @__PURE__ */ __name(() => {
        if (R = w, v.removeListener("aborted", J$), v.removeListener("complete", Q), v.removeListener("abort", J$), v.removeListener("request", _$2), v.req) v.req.removeListener("finish", Q);
        v.removeListener("end", $$), v.removeListener("close", $$), v.removeListener("finish", Q), v.removeListener("end", B$), v.removeListener("error", m), v.removeListener("close", J$);
      }, "Y$");
      if (k.signal && !r) {
        let d = /* @__PURE__ */ __name(() => {
          let o = R;
          Y$(), o.call(v, new P(void 0, { cause: k.signal.reason }));
        }, "d");
        if (k.signal.aborted) K.nextTick(d);
        else {
          Z = Z || $8().addAbortListener;
          let o = Z(k.signal, d), W$ = R;
          R = J((...B) => {
            o[E](), W$.apply(v, B);
          });
        }
      }
      return Y$;
    }
    __name(G, "G");
    function S(v, k, R) {
      let C = false, L = w;
      if (k.signal) if (L = /* @__PURE__ */ __name(() => {
        C = true, R.call(v, new P(void 0, { cause: k.signal.reason }));
      }, "L"), k.signal.aborted) K.nextTick(L);
      else {
        Z = Z || $8().addAbortListener;
        let l = Z(k.signal, L), a = R;
        R = J((...f$) => {
          l[E](), a.apply(v, f$);
        });
      }
      let x = /* @__PURE__ */ __name((...l) => {
        if (!C) K.nextTick(() => R.apply(v, l));
      }, "x");
      return N(v[H].promise, x, x), w;
    }
    __name(S, "S");
    function A(v, k) {
      var R;
      let C = false;
      if (k === null) k = z;
      if ((R = k) !== null && R !== void 0 && R.cleanup) V(k.cleanup, "cleanup"), C = k.cleanup;
      return new M((L, x) => {
        let l = G(v, k, (a) => {
          if (C) l();
          if (a) x(a);
          else L();
        });
      });
    }
    __name(A, "A");
    q.exports = G, q.exports.finished = A;
  }), d4 = V6(($, q) => {
    var K = x_(), { aggregateTwoErrors: P, codes: { ERR_MULTIPLE_CALLBACK: _ }, AbortError: Y } = mq(), { Symbol: O } = u6(), { kIsDestroyed: z, isDestroyed: J, isFinished: T, isServerRequest: X } = NK(), f = O("kDestroy"), V = O("kConstruct");
    function M(j, H, Z) {
      if (j) {
        if (j.stack, H && !H.errored) H.errored = j;
        if (Z && !Z.errored) Z.errored = j;
      }
    }
    __name(M, "M");
    function N(j, H) {
      let Z = this._readableState, W = this._writableState, w = W || Z;
      if (W !== null && W !== void 0 && W.destroyed || Z !== null && Z !== void 0 && Z.destroyed) {
        if (typeof H === "function") H();
        return this;
      }
      if (M(j, W, Z), W) W.destroyed = true;
      if (Z) Z.destroyed = true;
      if (!w.constructed) this.once(f, function(G) {
        E(this, P(G, j), H);
      });
      else E(this, j, H);
      return this;
    }
    __name(N, "N");
    function E(j, H, Z) {
      let W = false;
      function w(G) {
        if (W) return;
        W = true;
        let { _readableState: S, _writableState: A } = j;
        if (M(G, A, S), A) A.closed = true;
        if (S) S.closed = true;
        if (typeof Z === "function") Z(G);
        if (G) K.nextTick(h, j, G);
        else K.nextTick(I, j);
      }
      __name(w, "w");
      try {
        j._destroy(H || null, w);
      } catch (G) {
        w(G);
      }
    }
    __name(E, "E");
    function h(j, H) {
      D(j, H), I(j);
    }
    __name(h, "h");
    function I(j) {
      let { _readableState: H, _writableState: Z } = j;
      if (Z) Z.closeEmitted = true;
      if (H) H.closeEmitted = true;
      if (Z !== null && Z !== void 0 && Z.emitClose || H !== null && H !== void 0 && H.emitClose) j.emit("close");
    }
    __name(I, "I");
    function D(j, H) {
      let { _readableState: Z, _writableState: W } = j;
      if (W !== null && W !== void 0 && W.errorEmitted || Z !== null && Z !== void 0 && Z.errorEmitted) return;
      if (W) W.errorEmitted = true;
      if (Z) Z.errorEmitted = true;
      j.emit("error", H);
    }
    __name(D, "D");
    function g() {
      let j = this._readableState, H = this._writableState;
      if (j) j.constructed = true, j.closed = false, j.closeEmitted = false, j.destroyed = false, j.errored = null, j.errorEmitted = false, j.reading = false, j.ended = j.readable === false, j.endEmitted = j.readable === false;
      if (H) H.constructed = true, H.destroyed = false, H.closed = false, H.closeEmitted = false, H.errored = null, H.errorEmitted = false, H.finalCalled = false, H.prefinished = false, H.ended = H.writable === false, H.ending = H.writable === false, H.finished = H.writable === false;
    }
    __name(g, "g");
    function b(j, H, Z) {
      let { _readableState: W, _writableState: w } = j;
      if (w !== null && w !== void 0 && w.destroyed || W !== null && W !== void 0 && W.destroyed) return this;
      if (W !== null && W !== void 0 && W.autoDestroy || w !== null && w !== void 0 && w.autoDestroy) j.destroy(H);
      else if (H) {
        if (H.stack, w && !w.errored) w.errored = H;
        if (W && !W.errored) W.errored = H;
        if (Z) K.nextTick(D, j, H);
        else D(j, H);
      }
    }
    __name(b, "b");
    function y(j, H) {
      if (typeof j._construct !== "function") return;
      let { _readableState: Z, _writableState: W } = j;
      if (Z) Z.constructed = false;
      if (W) W.constructed = false;
      if (j.once(V, H), j.listenerCount(V) > 1) return;
      K.nextTick(p, j);
    }
    __name(y, "y");
    function p(j) {
      let H = false;
      function Z(W) {
        if (H) {
          b(j, W !== null && W !== void 0 ? W : new _());
          return;
        }
        H = true;
        let { _readableState: w, _writableState: G } = j, S = G || w;
        if (w) w.constructed = true;
        if (G) G.constructed = true;
        if (S.destroyed) j.emit(f, W);
        else if (W) b(j, W, true);
        else K.nextTick(n, j);
      }
      __name(Z, "Z");
      try {
        j._construct((W) => {
          K.nextTick(Z, W);
        });
      } catch (W) {
        K.nextTick(Z, W);
      }
    }
    __name(p, "p");
    function n(j) {
      j.emit(V);
    }
    __name(n, "n");
    function s(j) {
      return (j === null || j === void 0 ? void 0 : j.setHeader) && typeof j.abort === "function";
    }
    __name(s, "s");
    function q$(j) {
      j.emit("close");
    }
    __name(q$, "q$");
    function c(j, H) {
      j.emit("error", H), K.nextTick(q$, j);
    }
    __name(c, "c");
    function U(j, H) {
      if (!j || J(j)) return;
      if (!H && !T(j)) H = new Y();
      if (X(j)) j.socket = null, j.destroy(H);
      else if (s(j)) j.abort();
      else if (s(j.req)) j.req.abort();
      else if (typeof j.destroy === "function") j.destroy(H);
      else if (typeof j.close === "function") j.close();
      else if (H) K.nextTick(c, j, H);
      else K.nextTick(q$, j);
      if (!j.destroyed) j[z] = true;
    }
    __name(U, "U");
    q.exports = { construct: y, destroyer: U, destroy: N, undestroy: g, errorOrDestroy: b };
  }), pH = V6(($, q) => {
    var { ArrayIsArray: K, ObjectSetPrototypeOf: P } = u6(), { EventEmitter: _ } = (n7(), J6(o7));
    function Y(z) {
      _.call(this, z);
    }
    __name(Y, "Y");
    P(Y.prototype, _.prototype), P(Y, _), Y.prototype.pipe = function(z, J) {
      let T = this;
      function X(I) {
        if (z.writable && z.write(I) === false && T.pause) T.pause();
      }
      __name(X, "X");
      T.on("data", X);
      function f() {
        if (T.readable && T.resume) T.resume();
      }
      __name(f, "f");
      if (z.on("drain", f), !z._isStdio && (!J || J.end !== false)) T.on("end", M), T.on("close", N);
      let V = false;
      function M() {
        if (V) return;
        V = true, z.end();
      }
      __name(M, "M");
      function N() {
        if (V) return;
        if (V = true, typeof z.destroy === "function") z.destroy();
      }
      __name(N, "N");
      function E(I) {
        if (h(), _.listenerCount(this, "error") === 0) this.emit("error", I);
      }
      __name(E, "E");
      O(T, "error", E), O(z, "error", E);
      function h() {
        T.removeListener("data", X), z.removeListener("drain", f), T.removeListener("end", M), T.removeListener("close", N), T.removeListener("error", E), z.removeListener("error", E), T.removeListener("end", h), T.removeListener("close", h), z.removeListener("close", h);
      }
      __name(h, "h");
      return T.on("end", h), T.on("close", h), z.on("close", h), z.emit("pipe", T), z;
    };
    function O(z, J, T) {
      if (typeof z.prependListener === "function") return z.prependListener(J, T);
      if (!z._events || !z._events[J]) z.on(J, T);
      else if (K(z._events[J])) z._events[J].unshift(T);
      else z._events[J] = [T, z._events[J]];
    }
    __name(O, "O");
    q.exports = { Stream: Y, prependListener: O };
  }), PO = V6(($, q) => {
    var { SymbolDispose: K } = u6(), { AbortError: P, codes: _ } = mq(), { isNodeStream: Y, isWebStream: O, kControllerErrorFunction: z } = NK(), J = q_(), { ERR_INVALID_ARG_TYPE: T } = _, X, f = /* @__PURE__ */ __name((V, M) => {
      if (typeof V !== "object" || !("aborted" in V)) throw new T(M, "AbortSignal", V);
    }, "f");
    q.exports.addAbortSignal = function(V, M) {
      if (f(V, "signal"), !Y(M) && !O(M)) throw new T("stream", ["ReadableStream", "WritableStream", "Stream"], M);
      return q.exports.addAbortSignalNoValidate(V, M);
    }, q.exports.addAbortSignalNoValidate = function(V, M) {
      if (typeof V !== "object" || !("aborted" in V)) return M;
      let N = Y(M) ? () => {
        M.destroy(new P(void 0, { cause: V.reason }));
      } : () => {
        M[z](new P(void 0, { cause: V.reason }));
      };
      if (V.aborted) N();
      else {
        X = X || $8().addAbortListener;
        let E = X(V, N);
        J(M, E[K]);
      }
      return M;
    };
  }), mr = V6(($, q) => {
    var { StringPrototypeSlice: K, SymbolIterator: P, TypedArrayPrototypeSet: _, Uint8Array: Y } = u6(), { Buffer: O } = (fq(), J6(wq)), { inspect: z } = $8();
    q.exports = class {
      constructor() {
        this.head = null, this.tail = null, this.length = 0;
      }
      push(J) {
        let T = { data: J, next: null };
        if (this.length > 0) this.tail.next = T;
        else this.head = T;
        this.tail = T, ++this.length;
      }
      unshift(J) {
        let T = { data: J, next: this.head };
        if (this.length === 0) this.tail = T;
        this.head = T, ++this.length;
      }
      shift() {
        if (this.length === 0) return;
        let J = this.head.data;
        if (this.length === 1) this.head = this.tail = null;
        else this.head = this.head.next;
        return --this.length, J;
      }
      clear() {
        this.head = this.tail = null, this.length = 0;
      }
      join(J) {
        if (this.length === 0) return "";
        let T = this.head, X = "" + T.data;
        while ((T = T.next) !== null) X += J + T.data;
        return X;
      }
      concat(J) {
        if (this.length === 0) return O.alloc(0);
        let T = O.allocUnsafe(J >>> 0), X = this.head, f = 0;
        while (X) _(T, X.data, f), f += X.data.length, X = X.next;
        return T;
      }
      consume(J, T) {
        let X = this.head.data;
        if (J < X.length) {
          let f = X.slice(0, J);
          return this.head.data = X.slice(J), f;
        }
        if (J === X.length) return this.shift();
        return T ? this._getString(J) : this._getBuffer(J);
      }
      first() {
        return this.head.data;
      }
      *[P]() {
        for (let J = this.head; J; J = J.next) yield J.data;
      }
      _getString(J) {
        let T = "", X = this.head, f = 0;
        do {
          let V = X.data;
          if (J > V.length) T += V, J -= V.length;
          else {
            if (J === V.length) if (T += V, ++f, X.next) this.head = X.next;
            else this.head = this.tail = null;
            else T += K(V, 0, J), this.head = X, X.data = K(V, J);
            break;
          }
          ++f;
        } while ((X = X.next) !== null);
        return this.length -= f, T;
      }
      _getBuffer(J) {
        let T = O.allocUnsafe(J), X = J, f = this.head, V = 0;
        do {
          let M = f.data;
          if (J > M.length) _(T, M, X - J), J -= M.length;
          else {
            if (J === M.length) if (_(T, M, X - J), ++V, f.next) this.head = f.next;
            else this.head = this.tail = null;
            else _(T, new Y(M.buffer, M.byteOffset, J), X - J), this.head = f, f.data = M.slice(J);
            break;
          }
          ++V;
        } while ((f = f.next) !== null);
        return this.length -= V, T;
      }
      [Symbol.for("nodejs.util.inspect.custom")](J, T) {
        return z(this, { ...T, depth: 0, customInspect: false });
      }
    };
  }), OO = V6(($, q) => {
    var { MathFloor: K, NumberIsInteger: P } = u6(), { validateInteger: _ } = t7(), { ERR_INVALID_ARG_VALUE: Y } = mq().codes, O = 16384, z = 16;
    function J(V, M, N) {
      return V.highWaterMark != null ? V.highWaterMark : M ? V[N] : null;
    }
    __name(J, "J");
    function T(V) {
      return V ? z : O;
    }
    __name(T, "T");
    function X(V, M) {
      if (_(M, "value", 0), V) z = M;
      else O = M;
    }
    __name(X, "X");
    function f(V, M, N, E) {
      let h = J(M, E, N);
      if (h != null) {
        if (!P(h) || h < 0) {
          let I = E ? `options.${N}` : "options.highWaterMark";
          throw new Y(I, h);
        }
        return K(h);
      }
      return T(V.objectMode);
    }
    __name(f, "f");
    q.exports = { getHighWaterMark: f, getDefaultHighWaterMark: T, setDefaultHighWaterMark: X };
  }), dr = V6(($, q) => {
    var K = (fq(), J6(wq)), P = K.Buffer;
    function _(O, z) {
      for (var J in O) z[J] = O[J];
    }
    __name(_, "_");
    if (P.from && P.alloc && P.allocUnsafe && P.allocUnsafeSlow) q.exports = K;
    else _(K, $), $.Buffer = Y;
    function Y(O, z, J) {
      return P(O, z, J);
    }
    __name(Y, "Y");
    Y.prototype = Object.create(P.prototype), _(P, Y), Y.from = function(O, z, J) {
      if (typeof O === "number") throw TypeError("Argument must not be a number");
      return P(O, z, J);
    }, Y.alloc = function(O, z, J) {
      if (typeof O !== "number") throw TypeError("Argument must be a number");
      var T = P(O);
      if (z !== void 0) if (typeof J === "string") T.fill(z, J);
      else T.fill(z);
      else T.fill(0);
      return T;
    }, Y.allocUnsafe = function(O) {
      if (typeof O !== "number") throw TypeError("Argument must be a number");
      return P(O);
    }, Y.allocUnsafeSlow = function(O) {
      if (typeof O !== "number") throw TypeError("Argument must be a number");
      return K.SlowBuffer(O);
    };
  }), lr = V6(($) => {
    var q = dr().Buffer, K = q.isEncoding || function(D) {
      switch (D = "" + D, D && D.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function P(D) {
      if (!D) return "utf8";
      var g;
      while (true) switch (D) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return D;
        default:
          if (g) return;
          D = ("" + D).toLowerCase(), g = true;
      }
    }
    __name(P, "P");
    function _(D) {
      var g = P(D);
      if (typeof g !== "string" && (q.isEncoding === K || !K(D))) throw Error("Unknown encoding: " + D);
      return g || D;
    }
    __name(_, "_");
    $.StringDecoder = Y;
    function Y(D) {
      this.encoding = _(D);
      var g;
      switch (this.encoding) {
        case "utf16le":
          this.text = V, this.end = M, g = 4;
          break;
        case "utf8":
          this.fillLast = T, g = 4;
          break;
        case "base64":
          this.text = N, this.end = E, g = 3;
          break;
        default:
          this.write = h, this.end = I;
          return;
      }
      this.lastNeed = 0, this.lastTotal = 0, this.lastChar = q.allocUnsafe(g);
    }
    __name(Y, "Y");
    Y.prototype.write = function(D) {
      if (D.length === 0) return "";
      var g, b;
      if (this.lastNeed) {
        if (g = this.fillLast(D), g === void 0) return "";
        b = this.lastNeed, this.lastNeed = 0;
      } else b = 0;
      if (b < D.length) return g ? g + this.text(D, b) : this.text(D, b);
      return g || "";
    }, Y.prototype.end = f, Y.prototype.text = X, Y.prototype.fillLast = function(D) {
      if (this.lastNeed <= D.length) return D.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
      D.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, D.length), this.lastNeed -= D.length;
    };
    function O(D) {
      if (D <= 127) return 0;
      else if (D >> 5 === 6) return 2;
      else if (D >> 4 === 14) return 3;
      else if (D >> 3 === 30) return 4;
      return D >> 6 === 2 ? -1 : -2;
    }
    __name(O, "O");
    function z(D, g, b) {
      var y = g.length - 1;
      if (y < b) return 0;
      var p = O(g[y]);
      if (p >= 0) {
        if (p > 0) D.lastNeed = p - 1;
        return p;
      }
      if (--y < b || p === -2) return 0;
      if (p = O(g[y]), p >= 0) {
        if (p > 0) D.lastNeed = p - 2;
        return p;
      }
      if (--y < b || p === -2) return 0;
      if (p = O(g[y]), p >= 0) {
        if (p > 0) if (p === 2) p = 0;
        else D.lastNeed = p - 3;
        return p;
      }
      return 0;
    }
    __name(z, "z");
    function J(D, g, b) {
      if ((g[0] & 192) !== 128) return D.lastNeed = 0, "";
      if (D.lastNeed > 1 && g.length > 1) {
        if ((g[1] & 192) !== 128) return D.lastNeed = 1, "";
        if (D.lastNeed > 2 && g.length > 2) {
          if ((g[2] & 192) !== 128) return D.lastNeed = 2, "";
        }
      }
    }
    __name(J, "J");
    function T(D) {
      var g = this.lastTotal - this.lastNeed, b = J(this, D, g);
      if (b !== void 0) return b;
      if (this.lastNeed <= D.length) return D.copy(this.lastChar, g, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
      D.copy(this.lastChar, g, 0, D.length), this.lastNeed -= D.length;
    }
    __name(T, "T");
    function X(D, g) {
      var b = z(this, D, g);
      if (!this.lastNeed) return D.toString("utf8", g);
      this.lastTotal = b;
      var y = D.length - (b - this.lastNeed);
      return D.copy(this.lastChar, 0, y), D.toString("utf8", g, y);
    }
    __name(X, "X");
    function f(D) {
      var g = D && D.length ? this.write(D) : "";
      if (this.lastNeed) return g + "";
      return g;
    }
    __name(f, "f");
    function V(D, g) {
      if ((D.length - g) % 2 === 0) {
        var b = D.toString("utf16le", g);
        if (b) {
          var y = b.charCodeAt(b.length - 1);
          if (y >= 55296 && y <= 56319) return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = D[D.length - 2], this.lastChar[1] = D[D.length - 1], b.slice(0, -1);
        }
        return b;
      }
      return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = D[D.length - 1], D.toString("utf16le", g, D.length - 1);
    }
    __name(V, "V");
    function M(D) {
      var g = D && D.length ? this.write(D) : "";
      if (this.lastNeed) {
        var b = this.lastTotal - this.lastNeed;
        return g + this.lastChar.toString("utf16le", 0, b);
      }
      return g;
    }
    __name(M, "M");
    function N(D, g) {
      var b = (D.length - g) % 3;
      if (b === 0) return D.toString("base64", g);
      if (this.lastNeed = 3 - b, this.lastTotal = 3, b === 1) this.lastChar[0] = D[D.length - 1];
      else this.lastChar[0] = D[D.length - 2], this.lastChar[1] = D[D.length - 1];
      return D.toString("base64", g, D.length - b);
    }
    __name(N, "N");
    function E(D) {
      var g = D && D.length ? this.write(D) : "";
      if (this.lastNeed) return g + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
      return g;
    }
    __name(E, "E");
    function h(D) {
      return D.toString(this.encoding);
    }
    __name(h, "h");
    function I(D) {
      return D && D.length ? this.write(D) : "";
    }
    __name(I, "I");
  }), QS = V6(($, q) => {
    var K = x_(), { PromisePrototypeThen: P, SymbolAsyncIterator: _, SymbolIterator: Y } = u6(), { Buffer: O } = (fq(), J6(wq)), { ERR_INVALID_ARG_TYPE: z, ERR_STREAM_NULL_VALUES: J } = mq().codes;
    function T(X, f, V) {
      let M;
      if (typeof f === "string" || f instanceof O) return new X({ objectMode: true, ...V, read() {
        this.push(f), this.push(null);
      } });
      let N;
      if (f && f[_]) N = true, M = f[_]();
      else if (f && f[Y]) N = false, M = f[Y]();
      else throw new z("iterable", ["Iterable"], f);
      let E = new X({ objectMode: true, highWaterMark: 1, ...V }), h = false;
      E._read = function() {
        if (!h) h = true, D();
      }, E._destroy = function(g, b) {
        P(I(g), () => K.nextTick(b, g), (y) => K.nextTick(b, y || g));
      };
      async function I(g) {
        let b = g !== void 0 && g !== null, y = typeof M.throw === "function";
        if (b && y) {
          let { value: p, done: n } = await M.throw(g);
          if (await p, n) return;
        }
        if (typeof M.return === "function") {
          let { value: p } = await M.return();
          await p;
        }
      }
      __name(I, "I");
      async function D() {
        for (; ; ) {
          try {
            let { value: g, done: b } = N ? await M.next() : M.next();
            if (b) E.push(null);
            else {
              let y = g && typeof g.then === "function" ? await g : g;
              if (y === null) throw h = false, new J();
              else if (E.push(y)) continue;
              else h = false;
            }
          } catch (g) {
            E.destroy(g);
          }
          break;
        }
      }
      __name(D, "D");
      return E;
    }
    __name(T, "T");
    q.exports = T;
  }), YO = V6(($, q) => {
    var K = x_(), { ArrayPrototypeIndexOf: P, NumberIsInteger: _, NumberIsNaN: Y, NumberParseInt: O, ObjectDefineProperties: z, ObjectKeys: J, ObjectSetPrototypeOf: T, Promise: X, SafeSet: f, SymbolAsyncDispose: V, SymbolAsyncIterator: M, Symbol: N } = u6();
    q.exports = B, B.ReadableState = W$;
    var { EventEmitter: E } = (n7(), J6(o7)), { Stream: h, prependListener: I } = pH(), { Buffer: D } = (fq(), J6(wq)), { addAbortSignal: g } = PO(), b = q_(), y = $8().debuglog("stream", (u) => {
      y = u;
    }), p = mr(), n = d4(), { getHighWaterMark: s, getDefaultHighWaterMark: q$ } = OO(), { aggregateTwoErrors: c, codes: { ERR_INVALID_ARG_TYPE: U, ERR_METHOD_NOT_IMPLEMENTED: j, ERR_OUT_OF_RANGE: H, ERR_STREAM_PUSH_AFTER_EOF: Z, ERR_STREAM_UNSHIFT_AFTER_END_EVENT: W }, AbortError: w } = mq(), { validateObject: G } = t7(), S = N("kPaused"), { StringDecoder: A } = lr(), v = QS();
    T(B.prototype, h.prototype), T(B, h);
    var k = /* @__PURE__ */ __name(() => {
    }, "k"), { errorOrDestroy: R } = n, C = 1, L = 2, x = 4, l = 8, a = 16, f$ = 32, $$ = 64, t = 128, H$ = 256, Q = 512, v$ = 1024, B$ = 2048, m = 4096, r = 8192, J$ = 16384, e = 32768, _$2 = 65536, Y$ = 131072, d = 262144;
    function o(u) {
      return { enumerable: false, get() {
        return (this.state & u) !== 0;
      }, set(i) {
        if (i) this.state |= u;
        else this.state &= ~u;
      } };
    }
    __name(o, "o");
    z(W$.prototype, { objectMode: o(C), ended: o(L), endEmitted: o(x), reading: o(l), constructed: o(a), sync: o(f$), needReadable: o($$), emittedReadable: o(t), readableListening: o(H$), resumeScheduled: o(Q), errorEmitted: o(v$), emitClose: o(B$), autoDestroy: o(m), destroyed: o(r), closed: o(J$), closeEmitted: o(e), multiAwaitDrain: o(_$2), readingMore: o(Y$), dataEmitted: o(d) });
    function W$(u, i, K$) {
      if (typeof K$ !== "boolean") K$ = i instanceof MK();
      if (this.state = B$ | m | a | f$, u && u.objectMode) this.state |= C;
      if (K$ && u && u.readableObjectMode) this.state |= C;
      if (this.highWaterMark = u ? s(this, u, "readableHighWaterMark", K$) : q$(false), this.buffer = new p(), this.length = 0, this.pipes = [], this.flowing = null, this[S] = null, u && u.emitClose === false) this.state &= ~B$;
      if (u && u.autoDestroy === false) this.state &= ~m;
      if (this.errored = null, this.defaultEncoding = u && u.defaultEncoding || "utf8", this.awaitDrainWriters = null, this.decoder = null, this.encoding = null, u && u.encoding) this.decoder = new A(u.encoding), this.encoding = u.encoding;
    }
    __name(W$, "W$");
    function B(u) {
      if (!(this instanceof B)) return new B(u);
      let i = this instanceof MK();
      if (this._readableState = new W$(u, this, i), u) {
        if (typeof u.read === "function") this._read = u.read;
        if (typeof u.destroy === "function") this._destroy = u.destroy;
        if (typeof u.construct === "function") this._construct = u.construct;
        if (u.signal && !i) g(u.signal, this);
      }
      h.call(this, u), n.construct(this, () => {
        if (this._readableState.needReadable) S$(this, this._readableState);
      });
    }
    __name(B, "B");
    B.prototype.destroy = n.destroy, B.prototype._undestroy = n.undestroy, B.prototype._destroy = function(u, i) {
      i(u);
    }, B.prototype[E.captureRejectionSymbol] = function(u) {
      this.destroy(u);
    }, B.prototype[V] = function() {
      let u;
      if (!this.destroyed) u = this.readableEnded ? null : new w(), this.destroy(u);
      return new X((i, K$) => b(this, (P$) => P$ && P$ !== u ? K$(P$) : i(null)));
    }, B.prototype.push = function(u, i) {
      return F(this, u, i, false);
    }, B.prototype.unshift = function(u, i) {
      return F(this, u, i, true);
    };
    function F(u, i, K$, P$) {
      y("readableAddChunk", i);
      let i$ = u._readableState, k$;
      if ((i$.state & C) === 0) {
        if (typeof i === "string") {
          if (K$ = K$ || i$.defaultEncoding, i$.encoding !== K$) if (P$ && i$.encoding) i = D.from(i, K$).toString(i$.encoding);
          else i = D.from(i, K$), K$ = "";
        } else if (i instanceof D) K$ = "";
        else if (h._isUint8Array(i)) i = h._uint8ArrayToBuffer(i), K$ = "";
        else if (i != null) k$ = new U("chunk", ["string", "Buffer", "Uint8Array"], i);
      }
      if (k$) R(u, k$);
      else if (i === null) i$.state &= ~l, Z$(u, i$);
      else if ((i$.state & C) !== 0 || i && i.length > 0) if (P$) if ((i$.state & x) !== 0) R(u, new W());
      else if (i$.destroyed || i$.errored) return false;
      else X$(u, i$, i, true);
      else if (i$.ended) R(u, new Z());
      else if (i$.destroyed || i$.errored) return false;
      else if (i$.state &= ~l, i$.decoder && !K$) if (i = i$.decoder.write(i), i$.objectMode || i.length !== 0) X$(u, i$, i, false);
      else S$(u, i$);
      else X$(u, i$, i, false);
      else if (!P$) i$.state &= ~l, S$(u, i$);
      return !i$.ended && (i$.length < i$.highWaterMark || i$.length === 0);
    }
    __name(F, "F");
    function X$(u, i, K$, P$) {
      if (i.flowing && i.length === 0 && !i.sync && u.listenerCount("data") > 0) {
        if ((i.state & _$2) !== 0) i.awaitDrainWriters.clear();
        else i.awaitDrainWriters = null;
        i.dataEmitted = true, u.emit("data", K$);
      } else {
        if (i.length += i.objectMode ? 1 : K$.length, P$) i.buffer.unshift(K$);
        else i.buffer.push(K$);
        if ((i.state & $$) !== 0) A$(u);
      }
      S$(u, i);
    }
    __name(X$, "X$");
    B.prototype.isPaused = function() {
      let u = this._readableState;
      return u[S] === true || u.flowing === false;
    }, B.prototype.setEncoding = function(u) {
      let i = new A(u);
      this._readableState.decoder = i, this._readableState.encoding = this._readableState.decoder.encoding;
      let K$ = this._readableState.buffer, P$ = "";
      for (let i$ of K$) P$ += i.write(i$);
      if (K$.clear(), P$ !== "") K$.push(P$);
      return this._readableState.length = P$.length, this;
    };
    var z$ = 1073741824;
    function j$(u) {
      if (u > z$) throw new H("size", "<= 1GiB", u);
      else u--, u |= u >>> 1, u |= u >>> 2, u |= u >>> 4, u |= u >>> 8, u |= u >>> 16, u++;
      return u;
    }
    __name(j$, "j$");
    function X6(u, i) {
      if (u <= 0 || i.length === 0 && i.ended) return 0;
      if ((i.state & C) !== 0) return 1;
      if (Y(u)) {
        if (i.flowing && i.length) return i.buffer.first().length;
        return i.length;
      }
      if (u <= i.length) return u;
      return i.ended ? i.length : 0;
    }
    __name(X6, "X6");
    B.prototype.read = function(u) {
      if (y("read", u), u === void 0) u = NaN;
      else if (!_(u)) u = O(u, 10);
      let i = this._readableState, K$ = u;
      if (u > i.highWaterMark) i.highWaterMark = j$(u);
      if (u !== 0) i.state &= ~t;
      if (u === 0 && i.needReadable && ((i.highWaterMark !== 0 ? i.length >= i.highWaterMark : i.length > 0) || i.ended)) {
        if (y("read: emitReadable", i.length, i.ended), i.length === 0 && i.ended) zq(this);
        else A$(this);
        return null;
      }
      if (u = X6(u, i), u === 0 && i.ended) {
        if (i.length === 0) zq(this);
        return null;
      }
      let P$ = (i.state & $$) !== 0;
      if (y("need readable", P$), i.length === 0 || i.length - u < i.highWaterMark) P$ = true, y("length less than watermark", P$);
      if (i.ended || i.reading || i.destroyed || i.errored || !i.constructed) P$ = false, y("reading, ended or constructing", P$);
      else if (P$) {
        if (y("do read"), i.state |= l | f$, i.length === 0) i.state |= $$;
        try {
          this._read(i.highWaterMark);
        } catch (k$) {
          R(this, k$);
        }
        if (i.state &= ~f$, !i.reading) u = X6(K$, i);
      }
      let i$;
      if (u > 0) i$ = h$(u, i);
      else i$ = null;
      if (i$ === null) i.needReadable = i.length <= i.highWaterMark, u = 0;
      else if (i.length -= u, i.multiAwaitDrain) i.awaitDrainWriters.clear();
      else i.awaitDrainWriters = null;
      if (i.length === 0) {
        if (!i.ended) i.needReadable = true;
        if (K$ !== u && i.ended) zq(this);
      }
      if (i$ !== null && !i.errorEmitted && !i.closeEmitted) i.dataEmitted = true, this.emit("data", i$);
      return i$;
    };
    function Z$(u, i) {
      if (y("onEofChunk"), i.ended) return;
      if (i.decoder) {
        let K$ = i.decoder.end();
        if (K$ && K$.length) i.buffer.push(K$), i.length += i.objectMode ? 1 : K$.length;
      }
      if (i.ended = true, i.sync) A$(u);
      else i.needReadable = false, i.emittedReadable = true, l6(u);
    }
    __name(Z$, "Z$");
    function A$(u) {
      let i = u._readableState;
      if (y("emitReadable", i.needReadable, i.emittedReadable), i.needReadable = false, !i.emittedReadable) y("emitReadable", i.flowing), i.emittedReadable = true, K.nextTick(l6, u);
    }
    __name(A$, "A$");
    function l6(u) {
      let i = u._readableState;
      if (y("emitReadable_", i.destroyed, i.length, i.ended), !i.destroyed && !i.errored && (i.length || i.ended)) u.emit("readable"), i.emittedReadable = false;
      i.needReadable = !i.flowing && !i.ended && i.length <= i.highWaterMark, C$(u);
    }
    __name(l6, "l6");
    function S$(u, i) {
      if (!i.readingMore && i.constructed) i.readingMore = true, K.nextTick(V$, u, i);
    }
    __name(S$, "S$");
    function V$(u, i) {
      while (!i.reading && !i.ended && (i.length < i.highWaterMark || i.flowing && i.length === 0)) {
        let K$ = i.length;
        if (y("maybeReadMore read 0"), u.read(0), K$ === i.length) break;
      }
      i.readingMore = false;
    }
    __name(V$, "V$");
    B.prototype._read = function(u) {
      throw new j("_read()");
    }, B.prototype.pipe = function(u, i) {
      let K$ = this, P$ = this._readableState;
      if (P$.pipes.length === 1) {
        if (!P$.multiAwaitDrain) P$.multiAwaitDrain = true, P$.awaitDrainWriters = new f(P$.awaitDrainWriters ? [P$.awaitDrainWriters] : []);
      }
      P$.pipes.push(u), y("pipe count=%d opts=%j", P$.pipes.length, i);
      let i$ = (!i || i.end !== false) && u !== K.stdout && u !== K.stderr ? G$ : v6;
      if (P$.endEmitted) K.nextTick(i$);
      else K$.once("end", i$);
      u.on("unpipe", k$);
      function k$(C6, S6) {
        if (y("onunpipe"), C6 === K$) {
          if (S6 && S6.hasUnpiped === false) S6.hasUnpiped = true, u$();
        }
      }
      __name(k$, "k$");
      function G$() {
        y("onend"), u.end();
      }
      __name(G$, "G$");
      let x6, R$ = false;
      function u$() {
        if (y("cleanup"), u.removeListener("close", p6), u.removeListener("finish", H6), x6) u.removeListener("drain", x6);
        if (u.removeListener("error", M$), u.removeListener("unpipe", k$), K$.removeListener("end", G$), K$.removeListener("end", v6), K$.removeListener("data", I$), R$ = true, x6 && P$.awaitDrainWriters && (!u._writableState || u._writableState.needDrain)) x6();
      }
      __name(u$, "u$");
      function Xq() {
        if (!R$) {
          if (P$.pipes.length === 1 && P$.pipes[0] === u) y("false write response, pause", 0), P$.awaitDrainWriters = u, P$.multiAwaitDrain = false;
          else if (P$.pipes.length > 1 && P$.pipes.includes(u)) y("false write response, pause", P$.awaitDrainWriters.size), P$.awaitDrainWriters.add(u);
          K$.pause();
        }
        if (!x6) x6 = Mq(K$, u), u.on("drain", x6);
      }
      __name(Xq, "Xq");
      K$.on("data", I$);
      function I$(C6) {
        y("ondata");
        let S6 = u.write(C6);
        if (y("dest.write", S6), S6 === false) Xq();
      }
      __name(I$, "I$");
      function M$(C6) {
        if (y("onerror", C6), v6(), u.removeListener("error", M$), u.listenerCount("error") === 0) {
          let S6 = u._writableState || u._readableState;
          if (S6 && !S6.errorEmitted) R(u, C6);
          else u.emit("error", C6);
        }
      }
      __name(M$, "M$");
      I(u, "error", M$);
      function p6() {
        u.removeListener("finish", H6), v6();
      }
      __name(p6, "p6");
      u.once("close", p6);
      function H6() {
        y("onfinish"), u.removeListener("close", p6), v6();
      }
      __name(H6, "H6");
      u.once("finish", H6);
      function v6() {
        y("unpipe"), K$.unpipe(u);
      }
      __name(v6, "v6");
      if (u.emit("pipe", K$), u.writableNeedDrain === true) Xq();
      else if (!P$.flowing) y("pipe resume"), K$.resume();
      return u;
    };
    function Mq(u, i) {
      return function() {
        let K$ = u._readableState;
        if (K$.awaitDrainWriters === i) y("pipeOnDrain", 1), K$.awaitDrainWriters = null;
        else if (K$.multiAwaitDrain) y("pipeOnDrain", K$.awaitDrainWriters.size), K$.awaitDrainWriters.delete(i);
        if ((!K$.awaitDrainWriters || K$.awaitDrainWriters.size === 0) && u.listenerCount("data")) u.resume();
      };
    }
    __name(Mq, "Mq");
    B.prototype.unpipe = function(u) {
      let i = this._readableState, K$ = { hasUnpiped: false };
      if (i.pipes.length === 0) return this;
      if (!u) {
        let i$ = i.pipes;
        i.pipes = [], this.pause();
        for (let k$ = 0; k$ < i$.length; k$++) i$[k$].emit("unpipe", this, { hasUnpiped: false });
        return this;
      }
      let P$ = P(i.pipes, u);
      if (P$ === -1) return this;
      if (i.pipes.splice(P$, 1), i.pipes.length === 0) this.pause();
      return u.emit("unpipe", this, K$), this;
    }, B.prototype.on = function(u, i) {
      let K$ = h.prototype.on.call(this, u, i), P$ = this._readableState;
      if (u === "data") {
        if (P$.readableListening = this.listenerCount("readable") > 0, P$.flowing !== false) this.resume();
      } else if (u === "readable") {
        if (!P$.endEmitted && !P$.readableListening) {
          if (P$.readableListening = P$.needReadable = true, P$.flowing = false, P$.emittedReadable = false, y("on readable", P$.length, P$.reading), P$.length) A$(this);
          else if (!P$.reading) K.nextTick(D$, this);
        }
      }
      return K$;
    }, B.prototype.addListener = B.prototype.on, B.prototype.removeListener = function(u, i) {
      let K$ = h.prototype.removeListener.call(this, u, i);
      if (u === "readable") K.nextTick(N$, this);
      return K$;
    }, B.prototype.off = B.prototype.removeListener, B.prototype.removeAllListeners = function(u) {
      let i = h.prototype.removeAllListeners.apply(this, arguments);
      if (u === "readable" || u === void 0) K.nextTick(N$, this);
      return i;
    };
    function N$(u) {
      let i = u._readableState;
      if (i.readableListening = u.listenerCount("readable") > 0, i.resumeScheduled && i[S] === false) i.flowing = true;
      else if (u.listenerCount("data") > 0) u.resume();
      else if (!i.readableListening) i.flowing = null;
    }
    __name(N$, "N$");
    function D$(u) {
      y("readable nexttick read 0"), u.read(0);
    }
    __name(D$, "D$");
    B.prototype.resume = function() {
      let u = this._readableState;
      if (!u.flowing) y("resume"), u.flowing = !u.readableListening, Nq(this, u);
      return u[S] = false, this;
    };
    function Nq(u, i) {
      if (!i.resumeScheduled) i.resumeScheduled = true, K.nextTick(L$, u, i);
    }
    __name(Nq, "Nq");
    function L$(u, i) {
      if (y("resume", i.reading), !i.reading) u.read(0);
      if (i.resumeScheduled = false, u.emit("resume"), C$(u), i.flowing && !i.reading) u.read(0);
    }
    __name(L$, "L$");
    B.prototype.pause = function() {
      if (y("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== false) y("pause"), this._readableState.flowing = false, this.emit("pause");
      return this._readableState[S] = true, this;
    };
    function C$(u) {
      let i = u._readableState;
      y("flow", i.flowing);
      while (i.flowing && u.read() !== null) ;
    }
    __name(C$, "C$");
    B.prototype.wrap = function(u) {
      let i = false;
      u.on("data", (P$) => {
        if (!this.push(P$) && u.pause) i = true, u.pause();
      }), u.on("end", () => {
        this.push(null);
      }), u.on("error", (P$) => {
        R(this, P$);
      }), u.on("close", () => {
        this.destroy();
      }), u.on("destroy", () => {
        this.destroy();
      }), this._read = () => {
        if (i && u.resume) i = false, u.resume();
      };
      let K$ = J(u);
      for (let P$ = 1; P$ < K$.length; P$++) {
        let i$ = K$[P$];
        if (this[i$] === void 0 && typeof u[i$] === "function") this[i$] = u[i$].bind(u);
      }
      return this;
    }, B.prototype[M] = function() {
      return Zq(this);
    }, B.prototype.iterator = function(u) {
      if (u !== void 0) G(u, "options");
      return Zq(this, u);
    };
    function Zq(u, i) {
      if (typeof u.read !== "function") u = B.wrap(u, { objectMode: true });
      let K$ = g$(u, i);
      return K$.stream = u, K$;
    }
    __name(Zq, "Zq");
    async function* g$(u, i) {
      let K$ = k;
      function P$(G$) {
        if (this === u) K$(), K$ = k;
        else K$ = G$;
      }
      __name(P$, "P$");
      u.on("readable", P$);
      let i$, k$ = b(u, { writable: false }, (G$) => {
        i$ = G$ ? c(i$, G$) : null, K$(), K$ = k;
      });
      try {
        while (true) {
          let G$ = u.destroyed ? null : u.read();
          if (G$ !== null) yield G$;
          else if (i$) throw i$;
          else if (i$ === null) return;
          else await new X(P$);
        }
      } catch (G$) {
        throw i$ = c(i$, G$), i$;
      } finally {
        if ((i$ || (i === null || i === void 0 ? void 0 : i.destroyOnReturn) !== false) && (i$ === void 0 || u._readableState.autoDestroy)) n.destroyer(u, null);
        else u.off("readable", P$), k$();
      }
    }
    __name(g$, "g$");
    z(B.prototype, { readable: { __proto__: null, get() {
      let u = this._readableState;
      return !!u && u.readable !== false && !u.destroyed && !u.errorEmitted && !u.endEmitted;
    }, set(u) {
      if (this._readableState) this._readableState.readable = !!u;
    } }, readableDidRead: { __proto__: null, enumerable: false, get: /* @__PURE__ */ __name(function() {
      return this._readableState.dataEmitted;
    }, "get") }, readableAborted: { __proto__: null, enumerable: false, get: /* @__PURE__ */ __name(function() {
      return !!(this._readableState.readable !== false && (this._readableState.destroyed || this._readableState.errored) && !this._readableState.endEmitted);
    }, "get") }, readableHighWaterMark: { __proto__: null, enumerable: false, get: /* @__PURE__ */ __name(function() {
      return this._readableState.highWaterMark;
    }, "get") }, readableBuffer: { __proto__: null, enumerable: false, get: /* @__PURE__ */ __name(function() {
      return this._readableState && this._readableState.buffer;
    }, "get") }, readableFlowing: { __proto__: null, enumerable: false, get: /* @__PURE__ */ __name(function() {
      return this._readableState.flowing;
    }, "get"), set: /* @__PURE__ */ __name(function(u) {
      if (this._readableState) this._readableState.flowing = u;
    }, "set") }, readableLength: { __proto__: null, enumerable: false, get() {
      return this._readableState.length;
    } }, readableObjectMode: { __proto__: null, enumerable: false, get() {
      return this._readableState ? this._readableState.objectMode : false;
    } }, readableEncoding: { __proto__: null, enumerable: false, get() {
      return this._readableState ? this._readableState.encoding : null;
    } }, errored: { __proto__: null, enumerable: false, get() {
      return this._readableState ? this._readableState.errored : null;
    } }, closed: { __proto__: null, get() {
      return this._readableState ? this._readableState.closed : false;
    } }, destroyed: { __proto__: null, enumerable: false, get() {
      return this._readableState ? this._readableState.destroyed : false;
    }, set(u) {
      if (!this._readableState) return;
      this._readableState.destroyed = u;
    } }, readableEnded: { __proto__: null, enumerable: false, get() {
      return this._readableState ? this._readableState.endEmitted : false;
    } } }), z(W$.prototype, { pipesCount: { __proto__: null, get() {
      return this.pipes.length;
    } }, paused: { __proto__: null, get() {
      return this[S] !== false;
    }, set(u) {
      this[S] = !!u;
    } } }), B._fromList = h$;
    function h$(u, i) {
      if (i.length === 0) return null;
      let K$;
      if (i.objectMode) K$ = i.buffer.shift();
      else if (!u || u >= i.length) {
        if (i.decoder) K$ = i.buffer.join("");
        else if (i.buffer.length === 1) K$ = i.buffer.first();
        else K$ = i.buffer.concat(i.length);
        i.buffer.clear();
      } else K$ = i.buffer.consume(u, i.decoder);
      return K$;
    }
    __name(h$, "h$");
    function zq(u) {
      let i = u._readableState;
      if (y("endReadable", i.endEmitted), !i.endEmitted) i.ended = true, K.nextTick(b$, i, u);
    }
    __name(zq, "zq");
    function b$(u, i) {
      if (y("endReadableNT", u.endEmitted, u.length), !u.errored && !u.closeEmitted && !u.endEmitted && u.length === 0) {
        if (u.endEmitted = true, i.emit("end"), i.writable && i.allowHalfOpen === false) K.nextTick(y$, i);
        else if (u.autoDestroy) {
          let K$ = i._writableState;
          if (!K$ || K$.autoDestroy && (K$.finished || K$.writable === false)) i.destroy();
        }
      }
    }
    __name(b$, "b$");
    function y$(u) {
      if (u.writable && !u.writableEnded && !u.destroyed) u.end();
    }
    __name(y$, "y$");
    B.from = function(u, i) {
      return v(B, u, i);
    };
    var Wq;
    function E$() {
      if (Wq === void 0) Wq = {};
      return Wq;
    }
    __name(E$, "E$");
    B.fromWeb = function(u, i) {
      return E$().newStreamReadableFromReadableStream(u, i);
    }, B.toWeb = function(u, i) {
      return E$().newReadableStreamFromStreamReadable(u, i);
    }, B.wrap = function(u, i) {
      var K$, P$;
      return new B({ objectMode: (K$ = (P$ = u.readableObjectMode) !== null && P$ !== void 0 ? P$ : u.objectMode) !== null && K$ !== void 0 ? K$ : true, ...i, destroy(i$, k$) {
        n.destroyer(u, i$), k$(i$);
      } }).wrap(u);
    };
  }), cH = V6(($, q) => {
    var K = x_(), { ArrayPrototypeSlice: P, Error: _, FunctionPrototypeSymbolHasInstance: Y, ObjectDefineProperty: O, ObjectDefineProperties: z, ObjectSetPrototypeOf: J, StringPrototypeToLowerCase: T, Symbol: X, SymbolHasInstance: f } = u6();
    q.exports = G, G.WritableState = W;
    var { EventEmitter: V } = (n7(), J6(o7)), M = pH().Stream, { Buffer: N } = (fq(), J6(wq)), E = d4(), { addAbortSignal: h } = PO(), { getHighWaterMark: I, getDefaultHighWaterMark: D } = OO(), { ERR_INVALID_ARG_TYPE: g, ERR_METHOD_NOT_IMPLEMENTED: b, ERR_MULTIPLE_CALLBACK: y, ERR_STREAM_CANNOT_PIPE: p, ERR_STREAM_DESTROYED: n, ERR_STREAM_ALREADY_FINISHED: s, ERR_STREAM_NULL_VALUES: q$, ERR_STREAM_WRITE_AFTER_END: c, ERR_UNKNOWN_ENCODING: U } = mq().codes, { errorOrDestroy: j } = E;
    J(G.prototype, M.prototype), J(G, M);
    function H() {
    }
    __name(H, "H");
    var Z = X("kOnFinished");
    function W(m, r, J$) {
      if (typeof J$ !== "boolean") J$ = r instanceof MK();
      if (this.objectMode = !!(m && m.objectMode), J$) this.objectMode = this.objectMode || !!(m && m.writableObjectMode);
      this.highWaterMark = m ? I(this, m, "writableHighWaterMark", J$) : D(false), this.finalCalled = false, this.needDrain = false, this.ending = false, this.ended = false, this.finished = false, this.destroyed = false;
      let e = !!(m && m.decodeStrings === false);
      this.decodeStrings = !e, this.defaultEncoding = m && m.defaultEncoding || "utf8", this.length = 0, this.writing = false, this.corked = 0, this.sync = true, this.bufferProcessing = false, this.onwrite = R.bind(void 0, r), this.writecb = null, this.writelen = 0, this.afterWriteTickInfo = null, w(this), this.pendingcb = 0, this.constructed = true, this.prefinished = false, this.errorEmitted = false, this.emitClose = !m || m.emitClose !== false, this.autoDestroy = !m || m.autoDestroy !== false, this.errored = null, this.closed = false, this.closeEmitted = false, this[Z] = [];
    }
    __name(W, "W");
    function w(m) {
      m.buffered = [], m.bufferedIndex = 0, m.allBuffers = true, m.allNoop = true;
    }
    __name(w, "w");
    W.prototype.getBuffer = function() {
      return P(this.buffered, this.bufferedIndex);
    }, O(W.prototype, "bufferedRequestCount", { __proto__: null, get() {
      return this.buffered.length - this.bufferedIndex;
    } });
    function G(m) {
      let r = this instanceof MK();
      if (!r && !Y(G, this)) return new G(m);
      if (this._writableState = new W(m, this, r), m) {
        if (typeof m.write === "function") this._write = m.write;
        if (typeof m.writev === "function") this._writev = m.writev;
        if (typeof m.destroy === "function") this._destroy = m.destroy;
        if (typeof m.final === "function") this._final = m.final;
        if (typeof m.construct === "function") this._construct = m.construct;
        if (m.signal) h(m.signal, this);
      }
      M.call(this, m), E.construct(this, () => {
        let J$ = this._writableState;
        if (!J$.writing) l(this, J$);
        t(this, J$);
      });
    }
    __name(G, "G");
    O(G, f, { __proto__: null, value: /* @__PURE__ */ __name(function(m) {
      if (Y(this, m)) return true;
      if (this !== G) return false;
      return m && m._writableState instanceof W;
    }, "value") }), G.prototype.pipe = function() {
      j(this, new p());
    };
    function S(m, r, J$, e) {
      let _$2 = m._writableState;
      if (typeof J$ === "function") e = J$, J$ = _$2.defaultEncoding;
      else {
        if (!J$) J$ = _$2.defaultEncoding;
        else if (J$ !== "buffer" && !N.isEncoding(J$)) throw new U(J$);
        if (typeof e !== "function") e = H;
      }
      if (r === null) throw new q$();
      else if (!_$2.objectMode) if (typeof r === "string") {
        if (_$2.decodeStrings !== false) r = N.from(r, J$), J$ = "buffer";
      } else if (r instanceof N) J$ = "buffer";
      else if (M._isUint8Array(r)) r = M._uint8ArrayToBuffer(r), J$ = "buffer";
      else throw new g("chunk", ["string", "Buffer", "Uint8Array"], r);
      let Y$;
      if (_$2.ending) Y$ = new c();
      else if (_$2.destroyed) Y$ = new n("write");
      if (Y$) return K.nextTick(e, Y$), j(m, Y$, true), Y$;
      return _$2.pendingcb++, A(m, _$2, r, J$, e);
    }
    __name(S, "S");
    G.prototype.write = function(m, r, J$) {
      return S(this, m, r, J$) === true;
    }, G.prototype.cork = function() {
      this._writableState.corked++;
    }, G.prototype.uncork = function() {
      let m = this._writableState;
      if (m.corked) {
        if (m.corked--, !m.writing) l(this, m);
      }
    }, G.prototype.setDefaultEncoding = function(m) {
      if (typeof m === "string") m = T(m);
      if (!N.isEncoding(m)) throw new U(m);
      return this._writableState.defaultEncoding = m, this;
    };
    function A(m, r, J$, e, _$2) {
      let Y$ = r.objectMode ? 1 : J$.length;
      r.length += Y$;
      let d = r.length < r.highWaterMark;
      if (!d) r.needDrain = true;
      if (r.writing || r.corked || r.errored || !r.constructed) {
        if (r.buffered.push({ chunk: J$, encoding: e, callback: _$2 }), r.allBuffers && e !== "buffer") r.allBuffers = false;
        if (r.allNoop && _$2 !== H) r.allNoop = false;
      } else r.writelen = Y$, r.writecb = _$2, r.writing = true, r.sync = true, m._write(J$, e, r.onwrite), r.sync = false;
      return d && !r.errored && !r.destroyed;
    }
    __name(A, "A");
    function v(m, r, J$, e, _$2, Y$, d) {
      if (r.writelen = e, r.writecb = d, r.writing = true, r.sync = true, r.destroyed) r.onwrite(new n("write"));
      else if (J$) m._writev(_$2, r.onwrite);
      else m._write(_$2, Y$, r.onwrite);
      r.sync = false;
    }
    __name(v, "v");
    function k(m, r, J$, e) {
      --r.pendingcb, e(J$), x(r), j(m, J$);
    }
    __name(k, "k");
    function R(m, r) {
      let J$ = m._writableState, e = J$.sync, _$2 = J$.writecb;
      if (typeof _$2 !== "function") {
        j(m, new y());
        return;
      }
      if (J$.writing = false, J$.writecb = null, J$.length -= J$.writelen, J$.writelen = 0, r) {
        if (r.stack, !J$.errored) J$.errored = r;
        if (m._readableState && !m._readableState.errored) m._readableState.errored = r;
        if (e) K.nextTick(k, m, J$, r, _$2);
        else k(m, J$, r, _$2);
      } else {
        if (J$.buffered.length > J$.bufferedIndex) l(m, J$);
        if (e) if (J$.afterWriteTickInfo !== null && J$.afterWriteTickInfo.cb === _$2) J$.afterWriteTickInfo.count++;
        else J$.afterWriteTickInfo = { count: 1, cb: _$2, stream: m, state: J$ }, K.nextTick(C, J$.afterWriteTickInfo);
        else L(m, J$, 1, _$2);
      }
    }
    __name(R, "R");
    function C({ stream: m, state: r, count: J$, cb: e }) {
      return r.afterWriteTickInfo = null, L(m, r, J$, e);
    }
    __name(C, "C");
    function L(m, r, J$, e) {
      if (!r.ending && !m.destroyed && r.length === 0 && r.needDrain) r.needDrain = false, m.emit("drain");
      while (J$-- > 0) r.pendingcb--, e();
      if (r.destroyed) x(r);
      t(m, r);
    }
    __name(L, "L");
    function x(m) {
      if (m.writing) return;
      for (let _$2 = m.bufferedIndex; _$2 < m.buffered.length; ++_$2) {
        var r;
        let { chunk: Y$, callback: d } = m.buffered[_$2], o = m.objectMode ? 1 : Y$.length;
        m.length -= o, d((r = m.errored) !== null && r !== void 0 ? r : new n("write"));
      }
      let J$ = m[Z].splice(0);
      for (let _$2 = 0; _$2 < J$.length; _$2++) {
        var e;
        J$[_$2]((e = m.errored) !== null && e !== void 0 ? e : new n("end"));
      }
      w(m);
    }
    __name(x, "x");
    function l(m, r) {
      if (r.corked || r.bufferProcessing || r.destroyed || !r.constructed) return;
      let { buffered: J$, bufferedIndex: e, objectMode: _$2 } = r, Y$ = J$.length - e;
      if (!Y$) return;
      let d = e;
      if (r.bufferProcessing = true, Y$ > 1 && m._writev) {
        r.pendingcb -= Y$ - 1;
        let o = r.allNoop ? H : (B) => {
          for (let F = d; F < J$.length; ++F) J$[F].callback(B);
        }, W$ = r.allNoop && d === 0 ? J$ : P(J$, d);
        W$.allBuffers = r.allBuffers, v(m, r, true, r.length, W$, "", o), w(r);
      } else {
        do {
          let { chunk: o, encoding: W$, callback: B } = J$[d];
          J$[d++] = null;
          let F = _$2 ? 1 : o.length;
          v(m, r, false, F, o, W$, B);
        } while (d < J$.length && !r.writing);
        if (d === J$.length) w(r);
        else if (d > 256) J$.splice(0, d), r.bufferedIndex = 0;
        else r.bufferedIndex = d;
      }
      r.bufferProcessing = false;
    }
    __name(l, "l");
    G.prototype._write = function(m, r, J$) {
      if (this._writev) this._writev([{ chunk: m, encoding: r }], J$);
      else throw new b("_write()");
    }, G.prototype._writev = null, G.prototype.end = function(m, r, J$) {
      let e = this._writableState;
      if (typeof m === "function") J$ = m, m = null, r = null;
      else if (typeof r === "function") J$ = r, r = null;
      let _$2;
      if (m !== null && m !== void 0) {
        let Y$ = S(this, m, r);
        if (Y$ instanceof _) _$2 = Y$;
      }
      if (e.corked) e.corked = 1, this.uncork();
      if (_$2) ;
      else if (!e.errored && !e.ending) e.ending = true, t(this, e, true), e.ended = true;
      else if (e.finished) _$2 = new s("end");
      else if (e.destroyed) _$2 = new n("end");
      if (typeof J$ === "function") if (_$2 || e.finished) K.nextTick(J$, _$2);
      else e[Z].push(J$);
      return this;
    };
    function a(m) {
      return m.ending && !m.destroyed && m.constructed && m.length === 0 && !m.errored && m.buffered.length === 0 && !m.finished && !m.writing && !m.errorEmitted && !m.closeEmitted;
    }
    __name(a, "a");
    function f$(m, r) {
      let J$ = false;
      function e(_$2) {
        if (J$) {
          j(m, _$2 !== null && _$2 !== void 0 ? _$2 : y());
          return;
        }
        if (J$ = true, r.pendingcb--, _$2) {
          let Y$ = r[Z].splice(0);
          for (let d = 0; d < Y$.length; d++) Y$[d](_$2);
          j(m, _$2, r.sync);
        } else if (a(r)) r.prefinished = true, m.emit("prefinish"), r.pendingcb++, K.nextTick(H$, m, r);
      }
      __name(e, "e");
      r.sync = true, r.pendingcb++;
      try {
        m._final(e);
      } catch (_$2) {
        e(_$2);
      }
      r.sync = false;
    }
    __name(f$, "f$");
    function $$(m, r) {
      if (!r.prefinished && !r.finalCalled) if (typeof m._final === "function" && !r.destroyed) r.finalCalled = true, f$(m, r);
      else r.prefinished = true, m.emit("prefinish");
    }
    __name($$, "$$");
    function t(m, r, J$) {
      if (a(r)) {
        if ($$(m, r), r.pendingcb === 0) {
          if (J$) r.pendingcb++, K.nextTick((e, _$2) => {
            if (a(_$2)) H$(e, _$2);
            else _$2.pendingcb--;
          }, m, r);
          else if (a(r)) r.pendingcb++, H$(m, r);
        }
      }
    }
    __name(t, "t");
    function H$(m, r) {
      r.pendingcb--, r.finished = true;
      let J$ = r[Z].splice(0);
      for (let e = 0; e < J$.length; e++) J$[e]();
      if (m.emit("finish"), r.autoDestroy) {
        let e = m._readableState;
        if (!e || e.autoDestroy && (e.endEmitted || e.readable === false)) m.destroy();
      }
    }
    __name(H$, "H$");
    z(G.prototype, { closed: { __proto__: null, get() {
      return this._writableState ? this._writableState.closed : false;
    } }, destroyed: { __proto__: null, get() {
      return this._writableState ? this._writableState.destroyed : false;
    }, set(m) {
      if (this._writableState) this._writableState.destroyed = m;
    } }, writable: { __proto__: null, get() {
      let m = this._writableState;
      return !!m && m.writable !== false && !m.destroyed && !m.errored && !m.ending && !m.ended;
    }, set(m) {
      if (this._writableState) this._writableState.writable = !!m;
    } }, writableFinished: { __proto__: null, get() {
      return this._writableState ? this._writableState.finished : false;
    } }, writableObjectMode: { __proto__: null, get() {
      return this._writableState ? this._writableState.objectMode : false;
    } }, writableBuffer: { __proto__: null, get() {
      return this._writableState && this._writableState.getBuffer();
    } }, writableEnded: { __proto__: null, get() {
      return this._writableState ? this._writableState.ending : false;
    } }, writableNeedDrain: { __proto__: null, get() {
      let m = this._writableState;
      if (!m) return false;
      return !m.destroyed && !m.ending && m.needDrain;
    } }, writableHighWaterMark: { __proto__: null, get() {
      return this._writableState && this._writableState.highWaterMark;
    } }, writableCorked: { __proto__: null, get() {
      return this._writableState ? this._writableState.corked : 0;
    } }, writableLength: { __proto__: null, get() {
      return this._writableState && this._writableState.length;
    } }, errored: { __proto__: null, enumerable: false, get() {
      return this._writableState ? this._writableState.errored : null;
    } }, writableAborted: { __proto__: null, enumerable: false, get: /* @__PURE__ */ __name(function() {
      return !!(this._writableState.writable !== false && (this._writableState.destroyed || this._writableState.errored) && !this._writableState.finished);
    }, "get") } });
    var Q = E.destroy;
    G.prototype.destroy = function(m, r) {
      let J$ = this._writableState;
      if (!J$.destroyed && (J$.bufferedIndex < J$.buffered.length || J$[Z].length)) K.nextTick(x, J$);
      return Q.call(this, m, r), this;
    }, G.prototype._undestroy = E.undestroy, G.prototype._destroy = function(m, r) {
      r(m);
    }, G.prototype[V.captureRejectionSymbol] = function(m) {
      this.destroy(m);
    };
    var v$;
    function B$() {
      if (v$ === void 0) v$ = {};
      return v$;
    }
    __name(B$, "B$");
    G.fromWeb = function(m, r) {
      return B$().newStreamWritableFromWritableStream(m, r);
    }, G.toWeb = function(m) {
      return B$().newWritableStreamFromStreamWritable(m);
    };
  }), rr = V6(($, q) => {
    var K = x_(), P = (fq(), J6(wq)), { isReadable: _, isWritable: Y, isIterable: O, isNodeStream: z, isReadableNodeStream: J, isWritableNodeStream: T, isDuplexNodeStream: X, isReadableStream: f, isWritableStream: V } = NK(), M = q_(), { AbortError: N, codes: { ERR_INVALID_ARG_TYPE: E, ERR_INVALID_RETURN_VALUE: h } } = mq(), { destroyer: I } = d4(), D = MK(), g = YO(), b = cH(), { createDeferredPromise: y } = $8(), p = QS(), n = globalThis.Blob || P.Blob, s = typeof n < "u" ? function(Z) {
      return Z instanceof n;
    } : function(Z) {
      return false;
    }, q$ = globalThis.AbortController || i7().AbortController, { FunctionPrototypeCall: c } = u6();
    const _U = class _U extends D {
      constructor(Z) {
        super(Z);
        if ((Z === null || Z === void 0 ? void 0 : Z.readable) === false) this._readableState.readable = false, this._readableState.ended = true, this._readableState.endEmitted = true;
        if ((Z === null || Z === void 0 ? void 0 : Z.writable) === false) this._writableState.writable = false, this._writableState.ending = true, this._writableState.ended = true, this._writableState.finished = true;
      }
    };
    __name(_U, "U");
    let U = _U;
    q.exports = /* @__PURE__ */ __name(function Z(W, w) {
      if (X(W)) return W;
      if (J(W)) return H({ readable: W });
      if (T(W)) return H({ writable: W });
      if (z(W)) return H({ writable: false, readable: false });
      if (f(W)) return H({ readable: g.fromWeb(W) });
      if (V(W)) return H({ writable: b.fromWeb(W) });
      if (typeof W === "function") {
        let { value: S, write: A, final: v, destroy: k } = j(W);
        if (O(S)) return p(U, S, { objectMode: true, write: A, final: v, destroy: k });
        let R = S === null || S === void 0 ? void 0 : S.then;
        if (typeof R === "function") {
          let C, L = c(R, S, (x) => {
            if (x != null) throw new h("nully", "body", x);
          }, (x) => {
            I(C, x);
          });
          return C = new U({ objectMode: true, readable: false, write: A, final(x) {
            v(async () => {
              try {
                await L, K.nextTick(x, null);
              } catch (l) {
                K.nextTick(x, l);
              }
            });
          }, destroy: k });
        }
        throw new h("Iterable, AsyncIterable or AsyncFunction", w, S);
      }
      if (s(W)) return Z(W.arrayBuffer());
      if (O(W)) return p(U, W, { objectMode: true, writable: false });
      if (f(W === null || W === void 0 ? void 0 : W.readable) && V(W === null || W === void 0 ? void 0 : W.writable)) return U.fromWeb(W);
      if (typeof (W === null || W === void 0 ? void 0 : W.writable) === "object" || typeof (W === null || W === void 0 ? void 0 : W.readable) === "object") {
        let S = W !== null && W !== void 0 && W.readable ? J(W === null || W === void 0 ? void 0 : W.readable) ? W === null || W === void 0 ? void 0 : W.readable : Z(W.readable) : void 0, A = W !== null && W !== void 0 && W.writable ? T(W === null || W === void 0 ? void 0 : W.writable) ? W === null || W === void 0 ? void 0 : W.writable : Z(W.writable) : void 0;
        return H({ readable: S, writable: A });
      }
      let G = W === null || W === void 0 ? void 0 : W.then;
      if (typeof G === "function") {
        let S;
        return c(G, W, (A) => {
          if (A != null) S.push(A);
          S.push(null);
        }, (A) => {
          I(S, A);
        }), S = new U({ objectMode: true, writable: false, read() {
        } });
      }
      throw new E(w, ["Blob", "ReadableStream", "WritableStream", "Stream", "Iterable", "AsyncIterable", "Function", "{ readable, writable } pair", "Promise"], W);
    }, "Z");
    function j(Z) {
      let { promise: W, resolve: w } = y(), G = new q$(), S = G.signal;
      return { value: Z((async function* () {
        while (true) {
          let A = W;
          W = null;
          let { chunk: v, done: k, cb: R } = await A;
          if (K.nextTick(R), k) return;
          if (S.aborted) throw new N(void 0, { cause: S.reason });
          ({ promise: W, resolve: w } = y()), yield v;
        }
      })(), { signal: S }), write(A, v, k) {
        let R = w;
        w = null, R({ chunk: A, done: false, cb: k });
      }, final(A) {
        let v = w;
        w = null, v({ done: true, cb: A });
      }, destroy(A, v) {
        G.abort(), v(A);
      } };
    }
    __name(j, "j");
    function H(Z) {
      let W = Z.readable && typeof Z.readable.read !== "function" ? g.wrap(Z.readable) : Z.readable, w = Z.writable, G = !!_(W), S = !!Y(w), A, v, k, R, C;
      function L(x) {
        let l = R;
        if (R = null, l) l(x);
        else if (x) C.destroy(x);
      }
      __name(L, "L");
      if (C = new U({ readableObjectMode: !!(W !== null && W !== void 0 && W.readableObjectMode), writableObjectMode: !!(w !== null && w !== void 0 && w.writableObjectMode), readable: G, writable: S }), S) M(w, (x) => {
        if (S = false, x) I(W, x);
        L(x);
      }), C._write = function(x, l, a) {
        if (w.write(x, l)) a();
        else A = a;
      }, C._final = function(x) {
        w.end(), v = x;
      }, w.on("drain", function() {
        if (A) {
          let x = A;
          A = null, x();
        }
      }), w.on("finish", function() {
        if (v) {
          let x = v;
          v = null, x();
        }
      });
      if (G) M(W, (x) => {
        if (G = false, x) I(W, x);
        L(x);
      }), W.on("readable", function() {
        if (k) {
          let x = k;
          k = null, x();
        }
      }), W.on("end", function() {
        C.push(null);
      }), C._read = function() {
        while (true) {
          let x = W.read();
          if (x === null) {
            k = C._read;
            return;
          }
          if (!C.push(x)) return;
        }
      };
      return C._destroy = function(x, l) {
        if (!x && R !== null) x = new N();
        if (k = null, A = null, v = null, R === null) l(x);
        else R = l, I(w, x), I(W, x);
      }, C;
    }
    __name(H, "H");
  }), MK = V6(($, q) => {
    var { ObjectDefineProperties: K, ObjectGetOwnPropertyDescriptor: P, ObjectKeys: _, ObjectSetPrototypeOf: Y } = u6();
    q.exports = J;
    var O = YO(), z = cH();
    Y(J.prototype, O.prototype), Y(J, O);
    {
      let V = _(z.prototype);
      for (let M = 0; M < V.length; M++) {
        let N = V[M];
        if (!J.prototype[N]) J.prototype[N] = z.prototype[N];
      }
    }
    function J(V) {
      if (!(this instanceof J)) return new J(V);
      if (O.call(this, V), z.call(this, V), V) {
        if (this.allowHalfOpen = V.allowHalfOpen !== false, V.readable === false) this._readableState.readable = false, this._readableState.ended = true, this._readableState.endEmitted = true;
        if (V.writable === false) this._writableState.writable = false, this._writableState.ending = true, this._writableState.ended = true, this._writableState.finished = true;
      } else this.allowHalfOpen = true;
    }
    __name(J, "J");
    K(J.prototype, { writable: { __proto__: null, ...P(z.prototype, "writable") }, writableHighWaterMark: { __proto__: null, ...P(z.prototype, "writableHighWaterMark") }, writableObjectMode: { __proto__: null, ...P(z.prototype, "writableObjectMode") }, writableBuffer: { __proto__: null, ...P(z.prototype, "writableBuffer") }, writableLength: { __proto__: null, ...P(z.prototype, "writableLength") }, writableFinished: { __proto__: null, ...P(z.prototype, "writableFinished") }, writableCorked: { __proto__: null, ...P(z.prototype, "writableCorked") }, writableEnded: { __proto__: null, ...P(z.prototype, "writableEnded") }, writableNeedDrain: { __proto__: null, ...P(z.prototype, "writableNeedDrain") }, destroyed: { __proto__: null, get() {
      if (this._readableState === void 0 || this._writableState === void 0) return false;
      return this._readableState.destroyed && this._writableState.destroyed;
    }, set(V) {
      if (this._readableState && this._writableState) this._readableState.destroyed = V, this._writableState.destroyed = V;
    } } });
    var T;
    function X() {
      if (T === void 0) T = {};
      return T;
    }
    __name(X, "X");
    J.fromWeb = function(V, M) {
      return X().newStreamDuplexFromReadableWritablePair(V, M);
    }, J.toWeb = function(V) {
      return X().newReadableWritablePairFromDuplex(V);
    };
    var f;
    J.from = function(V) {
      if (!f) f = rr();
      return f(V, "body");
    };
  }), eS = V6(($, q) => {
    var { ObjectSetPrototypeOf: K, Symbol: P } = u6();
    q.exports = J;
    var { ERR_METHOD_NOT_IMPLEMENTED: _ } = mq().codes, Y = MK(), { getHighWaterMark: O } = OO();
    K(J.prototype, Y.prototype), K(J, Y);
    var z = P("kCallback");
    function J(f) {
      if (!(this instanceof J)) return new J(f);
      let V = f ? O(this, f, "readableHighWaterMark", true) : null;
      if (V === 0) f = { ...f, highWaterMark: null, readableHighWaterMark: V, writableHighWaterMark: f.writableHighWaterMark || 0 };
      if (Y.call(this, f), this._readableState.sync = false, this[z] = null, f) {
        if (typeof f.transform === "function") this._transform = f.transform;
        if (typeof f.flush === "function") this._flush = f.flush;
      }
      this.on("prefinish", X);
    }
    __name(J, "J");
    function T(f) {
      if (typeof this._flush === "function" && !this.destroyed) this._flush((V, M) => {
        if (V) {
          if (f) f(V);
          else this.destroy(V);
          return;
        }
        if (M != null) this.push(M);
        if (this.push(null), f) f();
      });
      else if (this.push(null), f) f();
    }
    __name(T, "T");
    function X() {
      if (this._final !== T) T.call(this);
    }
    __name(X, "X");
    J.prototype._final = T, J.prototype._transform = function(f, V, M) {
      throw new _("_transform()");
    }, J.prototype._write = function(f, V, M) {
      let N = this._readableState, E = this._writableState, h = N.length;
      this._transform(f, V, (I, D) => {
        if (I) {
          M(I);
          return;
        }
        if (D != null) this.push(D);
        if (E.ended || h === N.length || N.length < N.highWaterMark) M();
        else this[z] = M;
      });
    }, J.prototype._read = function() {
      if (this[z]) {
        let f = this[z];
        this[z] = null, f();
      }
    };
  }), sS = V6(($, q) => {
    var { ObjectSetPrototypeOf: K } = u6();
    q.exports = _;
    var P = eS();
    K(_.prototype, P.prototype), K(_, P);
    function _(Y) {
      if (!(this instanceof _)) return new _(Y);
      P.call(this, Y);
    }
    __name(_, "_");
    _.prototype._transform = function(Y, O, z) {
      z(null, Y);
    };
  }), mH = V6(($, q) => {
    var K = x_(), { ArrayIsArray: P, Promise: _, SymbolAsyncIterator: Y, SymbolDispose: O } = u6(), z = q_(), { once: J } = $8(), T = d4(), X = MK(), { aggregateTwoErrors: f, codes: { ERR_INVALID_ARG_TYPE: V, ERR_INVALID_RETURN_VALUE: M, ERR_MISSING_ARGS: N, ERR_STREAM_DESTROYED: E, ERR_STREAM_PREMATURE_CLOSE: h }, AbortError: I } = mq(), { validateFunction: D, validateAbortSignal: g } = t7(), { isIterable: b, isReadable: y, isReadableNodeStream: p, isNodeStream: n, isTransformStream: s, isWebStream: q$, isReadableStream: c, isReadableFinished: U } = NK(), j = globalThis.AbortController || i7().AbortController, H, Z, W;
    function w(x, l, a) {
      let f$ = false;
      x.on("close", () => {
        f$ = true;
      });
      let $$ = z(x, { readable: l, writable: a }, (t) => {
        f$ = !t;
      });
      return { destroy: /* @__PURE__ */ __name((t) => {
        if (f$) return;
        f$ = true, T.destroyer(x, t || new E("pipe"));
      }, "destroy"), cleanup: $$ };
    }
    __name(w, "w");
    function G(x) {
      return D(x[x.length - 1], "streams[stream.length - 1]"), x.pop();
    }
    __name(G, "G");
    function S(x) {
      if (b(x)) return x;
      else if (p(x)) return A(x);
      throw new V("val", ["Readable", "Iterable", "AsyncIterable"], x);
    }
    __name(S, "S");
    async function* A(x) {
      if (!Z) Z = YO();
      yield* Z.prototype[Y].call(x);
    }
    __name(A, "A");
    async function v(x, l, a, { end: f$ }) {
      let $$, t = null, H$ = /* @__PURE__ */ __name((B$) => {
        if (B$) $$ = B$;
        if (t) {
          let m = t;
          t = null, m();
        }
      }, "H$"), Q = /* @__PURE__ */ __name(() => new _((B$, m) => {
        if ($$) m($$);
        else t = /* @__PURE__ */ __name(() => {
          if ($$) m($$);
          else B$();
        }, "t");
      }), "Q");
      l.on("drain", H$);
      let v$ = z(l, { readable: false }, H$);
      try {
        if (l.writableNeedDrain) await Q();
        for await (let B$ of x) if (!l.write(B$)) await Q();
        if (f$) l.end(), await Q();
        a();
      } catch (B$) {
        a($$ !== B$ ? f($$, B$) : B$);
      } finally {
        v$(), l.off("drain", H$);
      }
    }
    __name(v, "v");
    async function k(x, l, a, { end: f$ }) {
      if (s(l)) l = l.writable;
      let $$ = l.getWriter();
      try {
        for await (let t of x) await $$.ready, $$.write(t).catch(() => {
        });
        if (await $$.ready, f$) await $$.close();
        a();
      } catch (t) {
        try {
          await $$.abort(t), a(t);
        } catch (H$) {
          a(H$);
        }
      }
    }
    __name(k, "k");
    function R(...x) {
      return C(x, J(G(x)));
    }
    __name(R, "R");
    function C(x, l, a) {
      if (x.length === 1 && P(x[0])) x = x[0];
      if (x.length < 2) throw new N("streams");
      let f$ = new j(), $$ = f$.signal, t = a === null || a === void 0 ? void 0 : a.signal, H$ = [];
      g(t, "options.signal");
      function Q() {
        _$2(new I());
      }
      __name(Q, "Q");
      W = W || $8().addAbortListener;
      let v$;
      if (t) v$ = W(t, Q);
      let B$, m, r = [], J$ = 0;
      function e(B) {
        _$2(B, --J$ === 0);
      }
      __name(e, "e");
      function _$2(B, F) {
        var X$;
        if (B && (!B$ || B$.code === "ERR_STREAM_PREMATURE_CLOSE")) B$ = B;
        if (!B$ && !F) return;
        while (r.length) r.shift()(B$);
        if ((X$ = v$) === null || X$ === void 0 || X$[O](), f$.abort(), F) {
          if (!B$) H$.forEach((z$) => z$());
          K.nextTick(l, B$, m);
        }
      }
      __name(_$2, "_$");
      let Y$;
      for (let B = 0; B < x.length; B++) {
        let F = x[B], X$ = B < x.length - 1, z$ = B > 0, j$ = X$ || (a === null || a === void 0 ? void 0 : a.end) !== false, X6 = B === x.length - 1;
        if (n(F)) {
          let Z$ = /* @__PURE__ */ __name(function(A$) {
            if (A$ && A$.name !== "AbortError" && A$.code !== "ERR_STREAM_PREMATURE_CLOSE") e(A$);
          }, "Z$");
          var d = Z$;
          if (j$) {
            let { destroy: A$, cleanup: l6 } = w(F, X$, z$);
            if (r.push(A$), y(F) && X6) H$.push(l6);
          }
          if (F.on("error", Z$), y(F) && X6) H$.push(() => {
            F.removeListener("error", Z$);
          });
        }
        if (B === 0) if (typeof F === "function") {
          if (Y$ = F({ signal: $$ }), !b(Y$)) throw new M("Iterable, AsyncIterable or Stream", "source", Y$);
        } else if (b(F) || p(F) || s(F)) Y$ = F;
        else Y$ = X.from(F);
        else if (typeof F === "function") {
          if (s(Y$)) {
            var o;
            Y$ = S((o = Y$) === null || o === void 0 ? void 0 : o.readable);
          } else Y$ = S(Y$);
          if (Y$ = F(Y$, { signal: $$ }), X$) {
            if (!b(Y$, true)) throw new M("AsyncIterable", `transform[${B - 1}]`, Y$);
          } else {
            var W$;
            if (!H) H = sS();
            let Z$ = new H({ objectMode: true }), A$ = (W$ = Y$) === null || W$ === void 0 ? void 0 : W$.then;
            if (typeof A$ === "function") J$++, A$.call(Y$, (V$) => {
              if (m = V$, V$ != null) Z$.write(V$);
              if (j$) Z$.end();
              K.nextTick(e);
            }, (V$) => {
              Z$.destroy(V$), K.nextTick(e, V$);
            });
            else if (b(Y$, true)) J$++, v(Y$, Z$, e, { end: j$ });
            else if (c(Y$) || s(Y$)) {
              let V$ = Y$.readable || Y$;
              J$++, v(V$, Z$, e, { end: j$ });
            } else throw new M("AsyncIterable or Promise", "destination", Y$);
            Y$ = Z$;
            let { destroy: l6, cleanup: S$ } = w(Y$, false, true);
            if (r.push(l6), X6) H$.push(S$);
          }
        } else if (n(F)) {
          if (p(Y$)) {
            J$ += 2;
            let Z$ = L(Y$, F, e, { end: j$ });
            if (y(F) && X6) H$.push(Z$);
          } else if (s(Y$) || c(Y$)) {
            let Z$ = Y$.readable || Y$;
            J$++, v(Z$, F, e, { end: j$ });
          } else if (b(Y$)) J$++, v(Y$, F, e, { end: j$ });
          else throw new V("val", ["Readable", "Iterable", "AsyncIterable", "ReadableStream", "TransformStream"], Y$);
          Y$ = F;
        } else if (q$(F)) {
          if (p(Y$)) J$++, k(S(Y$), F, e, { end: j$ });
          else if (c(Y$) || b(Y$)) J$++, k(Y$, F, e, { end: j$ });
          else if (s(Y$)) J$++, k(Y$.readable, F, e, { end: j$ });
          else throw new V("val", ["Readable", "Iterable", "AsyncIterable", "ReadableStream", "TransformStream"], Y$);
          Y$ = F;
        } else Y$ = X.from(F);
      }
      if ($$ !== null && $$ !== void 0 && $$.aborted || t !== null && t !== void 0 && t.aborted) K.nextTick(Q);
      return Y$;
    }
    __name(C, "C");
    function L(x, l, a, { end: f$ }) {
      let $$ = false;
      if (l.on("close", () => {
        if (!$$) a(new h());
      }), x.pipe(l, { end: false }), f$) {
        let H$ = /* @__PURE__ */ __name(function() {
          $$ = true, l.end();
        }, "H$");
        var t = H$;
        if (U(x)) K.nextTick(H$);
        else x.once("end", H$);
      } else a();
      return z(x, { readable: true, writable: false }, (H$) => {
        let Q = x._readableState;
        if (H$ && H$.code === "ERR_STREAM_PREMATURE_CLOSE" && Q && Q.ended && !Q.errored && !Q.errorEmitted) x.once("end", a).once("error", a);
        else a(H$);
      }), z(l, { readable: false, writable: true }, a);
    }
    __name(L, "L");
    q.exports = { pipelineImpl: C, pipeline: R };
  }), $0 = V6(($, q) => {
    var { pipeline: K } = mH(), P = MK(), { destroyer: _ } = d4(), { isNodeStream: Y, isReadable: O, isWritable: z, isWebStream: J, isTransformStream: T, isWritableStream: X, isReadableStream: f } = NK(), { AbortError: V, codes: { ERR_INVALID_ARG_VALUE: M, ERR_MISSING_ARGS: N } } = mq(), E = q_();
    q.exports = function(...h) {
      if (h.length === 0) throw new N("streams");
      if (h.length === 1) return P.from(h[0]);
      let I = [...h];
      if (typeof h[0] === "function") h[0] = P.from(h[0]);
      if (typeof h[h.length - 1] === "function") {
        let j = h.length - 1;
        h[j] = P.from(h[j]);
      }
      for (let j = 0; j < h.length; ++j) {
        if (!Y(h[j]) && !J(h[j])) continue;
        if (j < h.length - 1 && !(O(h[j]) || f(h[j]) || T(h[j]))) throw new M(`streams[${j}]`, I[j], "must be readable");
        if (j > 0 && !(z(h[j]) || X(h[j]) || T(h[j]))) throw new M(`streams[${j}]`, I[j], "must be writable");
      }
      let D, g, b, y, p;
      function n(j) {
        let H = y;
        if (y = null, H) H(j);
        else if (j) p.destroy(j);
        else if (!U && !c) p.destroy();
      }
      __name(n, "n");
      let s = h[0], q$ = K(h, n), c = !!(z(s) || X(s) || T(s)), U = !!(O(q$) || f(q$) || T(q$));
      if (p = new P({ writableObjectMode: !!(s !== null && s !== void 0 && s.writableObjectMode), readableObjectMode: !!(q$ !== null && q$ !== void 0 && q$.readableObjectMode), writable: c, readable: U }), c) {
        if (Y(s)) p._write = function(H, Z, W) {
          if (s.write(H, Z)) W();
          else D = W;
        }, p._final = function(H) {
          s.end(), g = H;
        }, s.on("drain", function() {
          if (D) {
            let H = D;
            D = null, H();
          }
        });
        else if (J(s)) {
          let H = (T(s) ? s.writable : s).getWriter();
          p._write = async function(Z, W, w) {
            try {
              await H.ready, H.write(Z).catch(() => {
              }), w();
            } catch (G) {
              w(G);
            }
          }, p._final = async function(Z) {
            try {
              await H.ready, H.close().catch(() => {
              }), g = Z;
            } catch (W) {
              Z(W);
            }
          };
        }
        let j = T(q$) ? q$.readable : q$;
        E(j, () => {
          if (g) {
            let H = g;
            g = null, H();
          }
        });
      }
      if (U) {
        if (Y(q$)) q$.on("readable", function() {
          if (b) {
            let j = b;
            b = null, j();
          }
        }), q$.on("end", function() {
          p.push(null);
        }), p._read = function() {
          while (true) {
            let j = q$.read();
            if (j === null) {
              b = p._read;
              return;
            }
            if (!p.push(j)) return;
          }
        };
        else if (J(q$)) {
          let j = (T(q$) ? q$.readable : q$).getReader();
          p._read = async function() {
            while (true) try {
              let { value: H, done: Z } = await j.read();
              if (!p.push(H)) return;
              if (Z) {
                p.push(null);
                return;
              }
            } catch {
              return;
            }
          };
        }
      }
      return p._destroy = function(j, H) {
        if (!j && y !== null) j = new V();
        if (b = null, D = null, g = null, y === null) H(j);
        else if (y = H, Y(q$)) _(q$, j);
      }, p;
    };
  }), or = V6(($, q) => {
    var K = globalThis.AbortController || i7().AbortController, { codes: { ERR_INVALID_ARG_VALUE: P, ERR_INVALID_ARG_TYPE: _, ERR_MISSING_ARGS: Y, ERR_OUT_OF_RANGE: O }, AbortError: z } = mq(), { validateAbortSignal: J, validateInteger: T, validateObject: X } = t7(), f = u6().Symbol("kWeak"), V = u6().Symbol("kResistStopPropagation"), { finished: M } = q_(), N = $0(), { addAbortSignalNoValidate: E } = PO(), { isWritable: h, isNodeStream: I } = NK(), { deprecate: D } = $8(), { ArrayPrototypePush: g, Boolean: b, MathFloor: y, Number: p, NumberIsNaN: n, Promise: s, PromiseReject: q$, PromiseResolve: c, PromisePrototypeThen: U, Symbol: j } = u6(), H = j("kEmpty"), Z = j("kEof");
    function W(t, H$) {
      if (H$ != null) X(H$, "options");
      if ((H$ === null || H$ === void 0 ? void 0 : H$.signal) != null) J(H$.signal, "options.signal");
      if (I(t) && !h(t)) throw new P("stream", t, "must be writable");
      let Q = N(this, t);
      if (H$ !== null && H$ !== void 0 && H$.signal) E(H$.signal, Q);
      return Q;
    }
    __name(W, "W");
    function w(t, H$) {
      if (typeof t !== "function") throw new _("fn", ["Function", "AsyncFunction"], t);
      if (H$ != null) X(H$, "options");
      if ((H$ === null || H$ === void 0 ? void 0 : H$.signal) != null) J(H$.signal, "options.signal");
      let Q = 1;
      if ((H$ === null || H$ === void 0 ? void 0 : H$.concurrency) != null) Q = y(H$.concurrency);
      let v$ = Q - 1;
      if ((H$ === null || H$ === void 0 ? void 0 : H$.highWaterMark) != null) v$ = y(H$.highWaterMark);
      return T(Q, "options.concurrency", 1), T(v$, "options.highWaterMark", 0), v$ += Q, (async function* () {
        let B$ = $8().AbortSignalAny([H$ === null || H$ === void 0 ? void 0 : H$.signal].filter(b)), m = this, r = [], J$ = { signal: B$ }, e, _$2, Y$ = false, d = 0;
        function o() {
          Y$ = true, W$();
        }
        __name(o, "o");
        function W$() {
          d -= 1, B();
        }
        __name(W$, "W$");
        function B() {
          if (_$2 && !Y$ && d < Q && r.length < v$) _$2(), _$2 = null;
        }
        __name(B, "B");
        async function F() {
          try {
            for await (let X$ of m) {
              if (Y$) return;
              if (B$.aborted) throw new z();
              try {
                if (X$ = t(X$, J$), X$ === H) continue;
                X$ = c(X$);
              } catch (z$) {
                X$ = q$(z$);
              }
              if (d += 1, U(X$, W$, o), r.push(X$), e) e(), e = null;
              if (!Y$ && (r.length >= v$ || d >= Q)) await new s((z$) => {
                _$2 = z$;
              });
            }
            r.push(Z);
          } catch (X$) {
            let z$ = q$(X$);
            U(z$, W$, o), r.push(z$);
          } finally {
            if (Y$ = true, e) e(), e = null;
          }
        }
        __name(F, "F");
        F();
        try {
          while (true) {
            while (r.length > 0) {
              let X$ = await r[0];
              if (X$ === Z) return;
              if (B$.aborted) throw new z();
              if (X$ !== H) yield X$;
              r.shift(), B();
            }
            await new s((X$) => {
              e = X$;
            });
          }
        } finally {
          if (Y$ = true, _$2) _$2(), _$2 = null;
        }
      }).call(this);
    }
    __name(w, "w");
    function G(t = void 0) {
      if (t != null) X(t, "options");
      if ((t === null || t === void 0 ? void 0 : t.signal) != null) J(t.signal, "options.signal");
      return (async function* () {
        let H$ = 0;
        for await (let v$ of this) {
          var Q;
          if (t !== null && t !== void 0 && (Q = t.signal) !== null && Q !== void 0 && Q.aborted) throw new z({ cause: t.signal.reason });
          yield [H$++, v$];
        }
      }).call(this);
    }
    __name(G, "G");
    async function S(t, H$ = void 0) {
      for await (let Q of R.call(this, t, H$)) return true;
      return false;
    }
    __name(S, "S");
    async function A(t, H$ = void 0) {
      if (typeof t !== "function") throw new _("fn", ["Function", "AsyncFunction"], t);
      return !await S.call(this, async (...Q) => {
        return !await t(...Q);
      }, H$);
    }
    __name(A, "A");
    async function v(t, H$) {
      for await (let Q of R.call(this, t, H$)) return Q;
      return;
    }
    __name(v, "v");
    async function k(t, H$) {
      if (typeof t !== "function") throw new _("fn", ["Function", "AsyncFunction"], t);
      async function Q(v$, B$) {
        return await t(v$, B$), H;
      }
      __name(Q, "Q");
      for await (let v$ of w.call(this, Q, H$)) ;
    }
    __name(k, "k");
    function R(t, H$) {
      if (typeof t !== "function") throw new _("fn", ["Function", "AsyncFunction"], t);
      async function Q(v$, B$) {
        if (await t(v$, B$)) return v$;
        return H;
      }
      __name(Q, "Q");
      return w.call(this, Q, H$);
    }
    __name(R, "R");
    const _C = class _C extends Y {
      constructor() {
        super("reduce");
        this.message = "Reduce of an empty stream requires an initial value";
      }
    };
    __name(_C, "C");
    let C = _C;
    async function L(t, H$, Q) {
      var v$;
      if (typeof t !== "function") throw new _("reducer", ["Function", "AsyncFunction"], t);
      if (Q != null) X(Q, "options");
      if ((Q === null || Q === void 0 ? void 0 : Q.signal) != null) J(Q.signal, "options.signal");
      let B$ = arguments.length > 1;
      if (Q !== null && Q !== void 0 && (v$ = Q.signal) !== null && v$ !== void 0 && v$.aborted) {
        let _$2 = new z(void 0, { cause: Q.signal.reason });
        throw this.once("error", () => {
        }), await M(this.destroy(_$2)), _$2;
      }
      let m = new K(), r = m.signal;
      if (Q !== null && Q !== void 0 && Q.signal) {
        let _$2 = { once: true, [f]: this, [V]: true };
        Q.signal.addEventListener("abort", () => m.abort(), _$2);
      }
      let J$ = false;
      try {
        for await (let _$2 of this) {
          var e;
          if (J$ = true, Q !== null && Q !== void 0 && (e = Q.signal) !== null && e !== void 0 && e.aborted) throw new z();
          if (!B$) H$ = _$2, B$ = true;
          else H$ = await t(H$, _$2, { signal: r });
        }
        if (!J$ && !B$) throw new C();
      } finally {
        m.abort();
      }
      return H$;
    }
    __name(L, "L");
    async function x(t) {
      if (t != null) X(t, "options");
      if ((t === null || t === void 0 ? void 0 : t.signal) != null) J(t.signal, "options.signal");
      let H$ = [];
      for await (let v$ of this) {
        var Q;
        if (t !== null && t !== void 0 && (Q = t.signal) !== null && Q !== void 0 && Q.aborted) throw new z(void 0, { cause: t.signal.reason });
        g(H$, v$);
      }
      return H$;
    }
    __name(x, "x");
    function l(t, H$) {
      let Q = w.call(this, t, H$);
      return (async function* () {
        for await (let v$ of Q) yield* v$;
      }).call(this);
    }
    __name(l, "l");
    function a(t) {
      if (t = p(t), n(t)) return 0;
      if (t < 0) throw new O("number", ">= 0", t);
      return t;
    }
    __name(a, "a");
    function f$(t, H$ = void 0) {
      if (H$ != null) X(H$, "options");
      if ((H$ === null || H$ === void 0 ? void 0 : H$.signal) != null) J(H$.signal, "options.signal");
      return t = a(t), (async function* () {
        var Q;
        if (H$ !== null && H$ !== void 0 && (Q = H$.signal) !== null && Q !== void 0 && Q.aborted) throw new z();
        for await (let B$ of this) {
          var v$;
          if (H$ !== null && H$ !== void 0 && (v$ = H$.signal) !== null && v$ !== void 0 && v$.aborted) throw new z();
          if (t-- <= 0) yield B$;
        }
      }).call(this);
    }
    __name(f$, "f$");
    function $$(t, H$ = void 0) {
      if (H$ != null) X(H$, "options");
      if ((H$ === null || H$ === void 0 ? void 0 : H$.signal) != null) J(H$.signal, "options.signal");
      return t = a(t), (async function* () {
        var Q;
        if (H$ !== null && H$ !== void 0 && (Q = H$.signal) !== null && Q !== void 0 && Q.aborted) throw new z();
        for await (let B$ of this) {
          var v$;
          if (H$ !== null && H$ !== void 0 && (v$ = H$.signal) !== null && v$ !== void 0 && v$.aborted) throw new z();
          if (t-- > 0) yield B$;
          if (t <= 0) return;
        }
      }).call(this);
    }
    __name($$, "$$");
    q.exports.streamReturningOperators = { asIndexedPairs: D(G, "readable.asIndexedPairs will be removed in a future version."), drop: f$, filter: R, flatMap: l, map: w, take: $$, compose: W }, q.exports.promiseReturningOperators = { every: A, forEach: k, reduce: L, toArray: x, some: S, find: v };
  }), q0 = V6(($, q) => {
    var { ArrayPrototypePop: K, Promise: P } = u6(), { isIterable: _, isNodeStream: Y, isWebStream: O } = NK(), { pipelineImpl: z } = mH(), { finished: J } = q_();
    K0();
    function T(...X) {
      return new P((f, V) => {
        let M, N, E = X[X.length - 1];
        if (E && typeof E === "object" && !Y(E) && !_(E) && !O(E)) {
          let h = K(X);
          M = h.signal, N = h.end;
        }
        z(X, (h, I) => {
          if (h) V(h);
          else f(I);
        }, { signal: M, end: N });
      });
    }
    __name(T, "T");
    q.exports = { finished: J, pipeline: T };
  }), K0 = V6(($, q) => {
    var { Buffer: K } = (fq(), J6(wq)), { ObjectDefineProperty: P, ObjectKeys: _, ReflectApply: Y } = u6(), { promisify: { custom: O } } = $8(), { streamReturningOperators: z, promiseReturningOperators: J } = or(), { codes: { ERR_ILLEGAL_CONSTRUCTOR: T } } = mq(), X = $0(), { setDefaultHighWaterMark: f, getDefaultHighWaterMark: V } = OO(), { pipeline: M } = mH(), { destroyer: N } = d4(), E = q_(), h = q0(), I = NK(), D = q.exports = pH().Stream;
    D.isDestroyed = I.isDestroyed, D.isDisturbed = I.isDisturbed, D.isErrored = I.isErrored, D.isReadable = I.isReadable, D.isWritable = I.isWritable, D.Readable = YO();
    for (let b of _(z)) {
      let y = /* @__PURE__ */ __name(function(...n) {
        if (new.target) throw T();
        return D.Readable.from(Y(p, this, n));
      }, "y"), p = z[b];
      P(y, "name", { __proto__: null, value: p.name }), P(y, "length", { __proto__: null, value: p.length }), P(D.Readable.prototype, b, { __proto__: null, value: y, enumerable: false, configurable: true, writable: true });
    }
    for (let b of _(J)) {
      let y = /* @__PURE__ */ __name(function(...n) {
        if (new.target) throw T();
        return Y(p, this, n);
      }, "y"), p = J[b];
      P(y, "name", { __proto__: null, value: p.name }), P(y, "length", { __proto__: null, value: p.length }), P(D.Readable.prototype, b, { __proto__: null, value: y, enumerable: false, configurable: true, writable: true });
    }
    D.Writable = cH(), D.Duplex = MK(), D.Transform = eS(), D.PassThrough = sS(), D.pipeline = M;
    var { addAbortSignal: g } = PO();
    D.addAbortSignal = g, D.finished = E, D.destroy = N, D.compose = X, D.setDefaultHighWaterMark = f, D.getDefaultHighWaterMark = V, P(D, "promises", { __proto__: null, configurable: true, enumerable: true, get() {
      return h;
    } }), P(M, O, { __proto__: null, enumerable: true, get() {
      return h.pipeline;
    } }), P(E, O, { __proto__: null, enumerable: true, get() {
      return h.finished;
    } }), D.Stream = D, D._isUint8Array = function(b) {
      return b instanceof Uint8Array;
    }, D._uint8ArrayToBuffer = function(b) {
      return K.from(b.buffer, b.byteOffset, b.byteLength);
    };
  }), nr = V6(($, q) => {
    var K = dH();
    {
      let P = K0(), _ = q0(), Y = P.Readable.destroy;
      q.exports = P.Readable, q.exports._uint8ArrayToBuffer = P._uint8ArrayToBuffer, q.exports._isUint8Array = P._isUint8Array, q.exports.isDisturbed = P.isDisturbed, q.exports.isErrored = P.isErrored, q.exports.isReadable = P.isReadable, q.exports.Readable = P.Readable, q.exports.Writable = P.Writable, q.exports.Duplex = P.Duplex, q.exports.Transform = P.Transform, q.exports.PassThrough = P.PassThrough, q.exports.addAbortSignal = P.addAbortSignal, q.exports.finished = P.finished, q.exports.destroy = P.destroy, q.exports.destroy = Y, q.exports.pipeline = P.pipeline, q.exports.compose = P.compose, Object.defineProperty(P, "promises", { configurable: true, enumerable: true, get() {
        return _;
      } }), q.exports.Stream = P.Stream;
    }
    q.exports.default = q.exports;
  });
  _0.exports = nr();
});
var dq = {};
rq(dq, { webcrypto: /* @__PURE__ */ __name(() => cn, "webcrypto"), rng: /* @__PURE__ */ __name(() => ao, "rng"), randomUUID: /* @__PURE__ */ __name(() => un, "randomUUID"), randomFillSync: /* @__PURE__ */ __name(() => Dn, "randomFillSync"), randomFill: /* @__PURE__ */ __name(() => In, "randomFill"), randomBytes: /* @__PURE__ */ __name(() => Qo, "randomBytes"), publicEncrypt: /* @__PURE__ */ __name(() => Cn, "publicEncrypt"), publicDecrypt: /* @__PURE__ */ __name(() => En, "publicDecrypt"), pseudoRandomBytes: /* @__PURE__ */ __name(() => Fo, "pseudoRandomBytes"), prng: /* @__PURE__ */ __name(() => Uo, "prng"), privateEncrypt: /* @__PURE__ */ __name(() => hn, "privateEncrypt"), privateDecrypt: /* @__PURE__ */ __name(() => Rn, "privateDecrypt"), pbkdf2Sync: /* @__PURE__ */ __name(() => Pn, "pbkdf2Sync"), pbkdf2: /* @__PURE__ */ __name(() => _n, "pbkdf2"), listCiphers: /* @__PURE__ */ __name(() => wn, "listCiphers"), getRandomValues: /* @__PURE__ */ __name(() => yn, "getRandomValues"), getHashes: /* @__PURE__ */ __name(() => Kn, "getHashes"), getDiffieHellman: /* @__PURE__ */ __name(() => Xn, "getDiffieHellman"), getCurves: /* @__PURE__ */ __name(() => pn, "getCurves"), getCiphers: /* @__PURE__ */ __name(() => Tn, "getCiphers"), default: /* @__PURE__ */ __name(() => mn, "default"), createVerify: /* @__PURE__ */ __name(() => Sn, "createVerify"), createSign: /* @__PURE__ */ __name(() => Gn, "createSign"), createHmac: /* @__PURE__ */ __name(() => qn, "createHmac"), createHash: /* @__PURE__ */ __name(() => so, "createHash"), createECDH: /* @__PURE__ */ __name(() => Nn, "createECDH"), createDiffieHellmanGroup: /* @__PURE__ */ __name(() => Zn, "createDiffieHellmanGroup"), createDiffieHellman: /* @__PURE__ */ __name(() => An, "createDiffieHellman"), createDecipheriv: /* @__PURE__ */ __name(() => Jn, "createDecipheriv"), createDecipher: /* @__PURE__ */ __name(() => Wn, "createDecipher"), createCredentials: /* @__PURE__ */ __name(() => Ln, "createCredentials"), createCipheriv: /* @__PURE__ */ __name(() => vn, "createCipheriv"), createCipher: /* @__PURE__ */ __name(() => Yn, "createCipher"), constants: /* @__PURE__ */ __name(() => gn, "constants"), Verify: /* @__PURE__ */ __name(() => Mn, "Verify"), Sign: /* @__PURE__ */ __name(() => Vn, "Sign"), Hmac: /* @__PURE__ */ __name(() => $n, "Hmac"), Hash: /* @__PURE__ */ __name(() => eo, "Hash"), DiffieHellmanGroup: /* @__PURE__ */ __name(() => fn, "DiffieHellmanGroup"), DiffieHellman: /* @__PURE__ */ __name(() => kn, "DiffieHellman"), Decipheriv: /* @__PURE__ */ __name(() => Hn, "Decipheriv"), Decipher: /* @__PURE__ */ __name(() => zn, "Decipher"), DEFAULT_ENCODING: /* @__PURE__ */ __name(() => bn, "DEFAULT_ENCODING"), Cipheriv: /* @__PURE__ */ __name(() => jn, "Cipheriv"), Cipher: /* @__PURE__ */ __name(() => On, "Cipher") });
function pn() {
  return xn;
}
__name(pn, "pn");
var ir;
var tr;
var P0;
var Br;
var Ur;
var Fr = /* @__PURE__ */ __name(($, q, K) => {
  K = $ != null ? ir(tr($)) : {};
  let P = q || !$ || !$.__esModule ? P0(K, "default", { value: $, enumerable: true }) : K;
  for (let _ of Br($)) if (!Ur.call(P, _)) P0(P, _, { get: /* @__PURE__ */ __name(() => $[_], "get"), enumerable: true });
  return P;
}, "Fr");
var r$ = /* @__PURE__ */ __name(($, q) => () => (q || $((q = { exports: {} }).exports, q), q.exports), "r$");
var jO;
var vO;
var Y0;
var ar;
var rH;
var oH;
var q8;
var nH;
var j0;
var Qr;
var v0;
var er;
var sr;
var $o;
var qo;
var CK;
var K_;
var z0;
var M8;
var W0;
var zO;
var Ko;
var z8;
var _o;
var Po;
var Oo;
var H0;
var qK;
var U7;
var J0;
var Yo;
var T0;
var jo;
var w0;
var vo;
var zo;
var Wo;
var Ho;
var iH;
var Jo;
var tH;
var To;
var wo;
var fo;
var Zo;
var Xo;
var Ao;
var ko;
var Go;
var Vo;
var So;
var Mo;
var No;
var Co;
var ho;
var O0;
var Eo;
var B7;
var Ro;
var f0;
var Z0;
var Io;
var Do;
var X0;
var Lo;
var go;
var F7;
var bo;
var yo;
var uo;
var xo;
var po;
var co;
var A0;
var mo;
var k0;
var G0;
var V0;
var BH;
var S0;
var lo;
var M0;
var ro;
var oo;
var lH;
var no;
var io;
var to;
var Bo;
var f6;
var Uo;
var Fo;
var ao;
var Qo;
var eo;
var so;
var $n;
var qn;
var Kn;
var _n;
var Pn;
var On;
var Yn;
var jn;
var vn;
var zn;
var Wn;
var Hn;
var Jn;
var Tn;
var wn;
var fn;
var Zn;
var Xn;
var An;
var kn;
var Gn;
var Vn;
var Sn;
var Mn;
var Nn;
var Cn;
var hn;
var En;
var Rn;
var In;
var Dn;
var Ln;
var gn;
var bn = "buffer";
var yn = /* @__PURE__ */ __name(($) => {
  return crypto.getRandomValues($);
}, "yn");
var un = /* @__PURE__ */ __name(() => {
  return crypto.randomUUID();
}, "un");
var xn;
var cn;
var mn;
var lq = m_(() => {
  ir = Object.create, { getPrototypeOf: tr, defineProperty: P0, getOwnPropertyNames: Br } = Object, Ur = Object.prototype.hasOwnProperty, jO = r$(($, q) => {
    q.exports = (lq(), J6(dq)).randomBytes;
  }), vO = r$(($, q) => {
    q.exports = (lq(), J6(dq)).createHash;
  }), Y0 = r$(($, q) => {
    q.exports = (lq(), J6(dq)).createHmac;
  }), ar = r$(($, q) => {
    q.exports = { sha224WithRSAEncryption: { sign: "rsa", hash: "sha224", id: "302d300d06096086480165030402040500041c" }, "RSA-SHA224": { sign: "ecdsa/rsa", hash: "sha224", id: "302d300d06096086480165030402040500041c" }, sha256WithRSAEncryption: { sign: "rsa", hash: "sha256", id: "3031300d060960864801650304020105000420" }, "RSA-SHA256": { sign: "ecdsa/rsa", hash: "sha256", id: "3031300d060960864801650304020105000420" }, sha384WithRSAEncryption: { sign: "rsa", hash: "sha384", id: "3041300d060960864801650304020205000430" }, "RSA-SHA384": { sign: "ecdsa/rsa", hash: "sha384", id: "3041300d060960864801650304020205000430" }, sha512WithRSAEncryption: { sign: "rsa", hash: "sha512", id: "3051300d060960864801650304020305000440" }, "RSA-SHA512": { sign: "ecdsa/rsa", hash: "sha512", id: "3051300d060960864801650304020305000440" }, "RSA-SHA1": { sign: "rsa", hash: "sha1", id: "3021300906052b0e03021a05000414" }, "ecdsa-with-SHA1": { sign: "ecdsa", hash: "sha1", id: "" }, sha256: { sign: "ecdsa", hash: "sha256", id: "" }, sha224: { sign: "ecdsa", hash: "sha224", id: "" }, sha384: { sign: "ecdsa", hash: "sha384", id: "" }, sha512: { sign: "ecdsa", hash: "sha512", id: "" }, "DSA-SHA": { sign: "dsa", hash: "sha1", id: "" }, "DSA-SHA1": { sign: "dsa", hash: "sha1", id: "" }, DSA: { sign: "dsa", hash: "sha1", id: "" }, "DSA-WITH-SHA224": { sign: "dsa", hash: "sha224", id: "" }, "DSA-SHA224": { sign: "dsa", hash: "sha224", id: "" }, "DSA-WITH-SHA256": { sign: "dsa", hash: "sha256", id: "" }, "DSA-SHA256": { sign: "dsa", hash: "sha256", id: "" }, "DSA-WITH-SHA384": { sign: "dsa", hash: "sha384", id: "" }, "DSA-SHA384": { sign: "dsa", hash: "sha384", id: "" }, "DSA-WITH-SHA512": { sign: "dsa", hash: "sha512", id: "" }, "DSA-SHA512": { sign: "dsa", hash: "sha512", id: "" }, "DSA-RIPEMD160": { sign: "dsa", hash: "rmd160", id: "" }, ripemd160WithRSA: { sign: "rsa", hash: "rmd160", id: "3021300906052b2403020105000414" }, "RSA-RIPEMD160": { sign: "rsa", hash: "rmd160", id: "3021300906052b2403020105000414" }, md5WithRSAEncryption: { sign: "rsa", hash: "md5", id: "3020300c06082a864886f70d020505000410" }, "RSA-MD5": { sign: "rsa", hash: "md5", id: "3020300c06082a864886f70d020505000410" } };
  }), rH = r$(($, q) => {
    var K = Math.pow(2, 30) - 1;
    q.exports = function(P, _) {
      if (typeof P !== "number") throw TypeError("Iterations not a number");
      if (P < 0) throw TypeError("Bad iterations");
      if (typeof _ !== "number") throw TypeError("Key length not a number");
      if (_ < 0 || _ > K || _ !== _) throw TypeError("Bad key length");
    };
  }), oH = r$(($, q) => {
    var K;
    if (globalThis.process && globalThis.process.browser) K = "utf-8";
    else if (globalThis.process && globalThis.process.version) P = parseInt(process.version.split(".")[0].slice(1), 10), K = P >= 6 ? "utf-8" : "binary";
    else K = "utf-8";
    var P;
    q.exports = K;
  }), q8 = r$(($, q) => {
    var K = (fq(), J6(wq)), P = K.Buffer;
    function _(O, z) {
      for (var J in O) z[J] = O[J];
    }
    __name(_, "_");
    if (P.from && P.alloc && P.allocUnsafe && P.allocUnsafeSlow) q.exports = K;
    else _(K, $), $.Buffer = Y;
    function Y(O, z, J) {
      return P(O, z, J);
    }
    __name(Y, "Y");
    Y.prototype = Object.create(P.prototype), _(P, Y), Y.from = function(O, z, J) {
      if (typeof O === "number") throw TypeError("Argument must not be a number");
      return P(O, z, J);
    }, Y.alloc = function(O, z, J) {
      if (typeof O !== "number") throw TypeError("Argument must be a number");
      var T = P(O);
      if (z !== void 0) if (typeof J === "string") T.fill(z, J);
      else T.fill(z);
      else T.fill(0);
      return T;
    }, Y.allocUnsafe = function(O) {
      if (typeof O !== "number") throw TypeError("Argument must be a number");
      return P(O);
    }, Y.allocUnsafeSlow = function(O) {
      if (typeof O !== "number") throw TypeError("Argument must be a number");
      return K.SlowBuffer(O);
    };
  }), nH = r$(($, q) => {
    var K = q8().Buffer;
    q.exports = function(P, _, Y) {
      if (K.isBuffer(P)) return P;
      else if (typeof P === "string") return K.from(P, _);
      else if (ArrayBuffer.isView(P)) return K.from(P.buffer);
      else throw TypeError(Y + " must be a string, a Buffer, a typed array or a DataView");
    };
  }), j0 = r$(($, q) => {
    var K = { md5: 16, sha1: 20, sha224: 28, sha256: 32, sha384: 48, sha512: 64, rmd160: 20, ripemd160: 20 }, P = Y0(), _ = q8().Buffer, Y = rH(), O = oH(), z = nH();
    function J(T, X, f, V, M) {
      Y(f, V), T = z(T, O, "Password"), X = z(X, O, "Salt"), M = M || "sha1";
      var N = _.allocUnsafe(V), E = _.allocUnsafe(X.length + 4);
      X.copy(E, 0, 0, X.length);
      var h = 0, I = K[M], D = Math.ceil(V / I);
      for (var g = 1; g <= D; g++) {
        E.writeUInt32BE(g, X.length);
        var b = P(M, T).update(E).digest(), y = b;
        for (var p = 1; p < f; p++) {
          y = P(M, T).update(y).digest();
          for (var n = 0; n < I; n++) b[n] ^= y[n];
        }
        b.copy(N, h), h += I;
      }
      return N;
    }
    __name(J, "J");
    q.exports = J;
  }), Qr = r$(($, q) => {
    var K = q8().Buffer, P = rH(), _ = oH(), Y = j0(), O = nH(), z, J = globalThis.crypto && globalThis.crypto.subtle, T = { sha: "SHA-1", "sha-1": "SHA-1", sha1: "SHA-1", sha256: "SHA-256", "sha-256": "SHA-256", sha384: "SHA-384", "sha-384": "SHA-384", "sha-512": "SHA-512", sha512: "SHA-512" }, X = [];
    function f(h) {
      if (globalThis.process && !globalThis.process.browser) return Promise.resolve(false);
      if (!J || !J.importKey || !J.deriveBits) return Promise.resolve(false);
      if (X[h] !== void 0) return X[h];
      z = z || K.alloc(8);
      var I = N(z, z, 10, 128, h).then(function() {
        return true;
      }).catch(function() {
        return false;
      });
      return X[h] = I, I;
    }
    __name(f, "f");
    var V;
    function M() {
      if (V) return V;
      if (globalThis.process && globalThis.process.nextTick) V = globalThis.process.nextTick;
      else if (globalThis.queueMicrotask) V = globalThis.queueMicrotask;
      else if (globalThis.setImmediate) V = globalThis.setImmediate;
      else V = globalThis.setTimeout;
      return V;
    }
    __name(M, "M");
    function N(h, I, D, g, b) {
      return J.importKey("raw", h, { name: "PBKDF2" }, false, ["deriveBits"]).then(function(y) {
        return J.deriveBits({ name: "PBKDF2", salt: I, iterations: D, hash: { name: b } }, y, g << 3);
      }).then(function(y) {
        return K.from(y);
      });
    }
    __name(N, "N");
    function E(h, I) {
      h.then(function(D) {
        M()(function() {
          I(null, D);
        });
      }, function(D) {
        M()(function() {
          I(D);
        });
      });
    }
    __name(E, "E");
    q.exports = function(h, I, D, g, b, y) {
      if (typeof b === "function") y = b, b = void 0;
      b = b || "sha1";
      var p = T[b.toLowerCase()];
      if (!p || typeof globalThis.Promise !== "function") {
        M()(function() {
          var n;
          try {
            n = Y(h, I, D, g, b);
          } catch (s) {
            return y(s);
          }
          y(null, n);
        });
        return;
      }
      if (P(D, g), h = O(h, _, "Password"), I = O(I, _, "Salt"), typeof y !== "function") throw Error("No callback provided to pbkdf2");
      E(f(p).then(function(n) {
        if (n) return N(h, I, D, g, p);
        return Y(h, I, D, g, b);
      }), y);
    };
  }), v0 = r$(($) => {
    var q = (lq(), J6(dq)), K = rH(), P = oH(), _ = nH();
    function Y(z, J, T, X, f, V) {
      if (K(T, X), z = _(z, P, "Password"), J = _(J, P, "Salt"), typeof f === "function") V = f, f = "sha1";
      if (typeof V !== "function") throw Error("No callback provided to pbkdf2");
      return q.pbkdf2(z, J, T, X, f, V);
    }
    __name(Y, "Y");
    function O(z, J, T, X, f) {
      return K(T, X), z = _(z, P, "Password"), J = _(J, P, "Salt"), f = f || "sha1", q.pbkdf2Sync(z, J, T, X, f);
    }
    __name(O, "O");
    if (!q.pbkdf2Sync || q.pbkdf2Sync.toString().indexOf("keylen, digest") === -1) $.pbkdf2Sync = j0(), $.pbkdf2 = Qr();
    else $.pbkdf2Sync = O, $.pbkdf2 = Y;
  }), er = r$(($) => {
    var q = (lq(), J6(dq));
    $.createCipher = $.Cipher = q.createCipher, $.createCipheriv = $.Cipheriv = q.createCipheriv, $.createDecipher = $.Decipher = q.createDecipher, $.createDecipheriv = $.Decipheriv = q.createDecipheriv, $.listCiphers = $.getCiphers = q.getCiphers;
  }), sr = r$(($) => {
    var q = (lq(), J6(dq));
    $.DiffieHellmanGroup = q.DiffieHellmanGroup, $.createDiffieHellmanGroup = q.createDiffieHellmanGroup, $.getDiffieHellman = q.getDiffieHellman, $.createDiffieHellman = q.createDiffieHellman, $.DiffieHellman = q.DiffieHellman;
  }), $o = r$(($) => {
    var q = (lq(), J6(dq));
    $.createSign = q.createSign, $.Sign = q.Sign, $.createVerify = q.createVerify, $.Verify = q.Verify;
  }), qo = r$(($, q) => {
    q.exports = { name: "elliptic", version: "6.6.1", description: "EC cryptography", main: "lib/elliptic.js", files: ["lib"], scripts: { lint: "eslint lib test", "lint:fix": "npm run lint -- --fix", unit: "istanbul test _mocha --reporter=spec test/index.js", test: "npm run lint && npm run unit", version: "grunt dist && git add dist/" }, repository: { type: "git", url: "git@github.com:indutny/elliptic" }, keywords: ["EC", "Elliptic", "curve", "Cryptography"], author: "Fedor Indutny <fedor@indutny.com>", license: "MIT", bugs: { url: "https://github.com/indutny/elliptic/issues" }, homepage: "https://github.com/indutny/elliptic", devDependencies: { brfs: "^2.0.2", coveralls: "^3.1.0", eslint: "^7.6.0", grunt: "^1.2.1", "grunt-browserify": "^5.3.0", "grunt-cli": "^1.3.2", "grunt-contrib-connect": "^3.0.0", "grunt-contrib-copy": "^1.0.0", "grunt-contrib-uglify": "^5.0.0", "grunt-mocha-istanbul": "^5.0.2", "grunt-saucelabs": "^9.0.1", istanbul: "^0.4.5", mocha: "^8.0.1" }, dependencies: { "bn.js": "^4.11.9", brorand: "^1.1.0", "hash.js": "^1.0.0", "hmac-drbg": "^1.0.1", inherits: "^2.0.4", "minimalistic-assert": "^1.0.1", "minimalistic-crypto-utils": "^1.0.1" } };
  }), CK = r$(($, q) => {
    (function(K, P) {
      function _(j, H) {
        if (!j) throw Error(H || "Assertion failed");
      }
      __name(_, "_");
      function Y(j, H) {
        j.super_ = H;
        var Z = /* @__PURE__ */ __name(function() {
        }, "Z");
        Z.prototype = H.prototype, j.prototype = new Z(), j.prototype.constructor = j;
      }
      __name(Y, "Y");
      function O(j, H, Z) {
        if (O.isBN(j)) return j;
        if (this.negative = 0, this.words = null, this.length = 0, this.red = null, j !== null) {
          if (H === "le" || H === "be") Z = H, H = 10;
          this._init(j || 0, H || 10, Z || "be");
        }
      }
      __name(O, "O");
      if (typeof K === "object") K.exports = O;
      else P.BN = O;
      O.BN = O, O.wordSize = 26;
      var z;
      try {
        if (typeof window < "u" && typeof window.Buffer < "u") z = window.Buffer;
        else z = (fq(), J6(wq)).Buffer;
      } catch (j) {
      }
      O.isBN = function(j) {
        if (j instanceof O) return true;
        return j !== null && typeof j === "object" && j.constructor.wordSize === O.wordSize && Array.isArray(j.words);
      }, O.max = function(j, H) {
        if (j.cmp(H) > 0) return j;
        return H;
      }, O.min = function(j, H) {
        if (j.cmp(H) < 0) return j;
        return H;
      }, O.prototype._init = function(j, H, Z) {
        if (typeof j === "number") return this._initNumber(j, H, Z);
        if (typeof j === "object") return this._initArray(j, H, Z);
        if (H === "hex") H = 16;
        _(H === (H | 0) && H >= 2 && H <= 36), j = j.toString().replace(/\s+/g, "");
        var W = 0;
        if (j[0] === "-") W++, this.negative = 1;
        if (W < j.length) {
          if (H === 16) this._parseHex(j, W, Z);
          else if (this._parseBase(j, H, W), Z === "le") this._initArray(this.toArray(), H, Z);
        }
      }, O.prototype._initNumber = function(j, H, Z) {
        if (j < 0) this.negative = 1, j = -j;
        if (j < 67108864) this.words = [j & 67108863], this.length = 1;
        else if (j < 4503599627370496) this.words = [j & 67108863, j / 67108864 & 67108863], this.length = 2;
        else _(j < 9007199254740992), this.words = [j & 67108863, j / 67108864 & 67108863, 1], this.length = 3;
        if (Z !== "le") return;
        this._initArray(this.toArray(), H, Z);
      }, O.prototype._initArray = function(j, H, Z) {
        if (_(typeof j.length === "number"), j.length <= 0) return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(j.length / 3), this.words = Array(this.length);
        for (var W = 0; W < this.length; W++) this.words[W] = 0;
        var w, G, S = 0;
        if (Z === "be") {
          for (W = j.length - 1, w = 0; W >= 0; W -= 3) if (G = j[W] | j[W - 1] << 8 | j[W - 2] << 16, this.words[w] |= G << S & 67108863, this.words[w + 1] = G >>> 26 - S & 67108863, S += 24, S >= 26) S -= 26, w++;
        } else if (Z === "le") {
          for (W = 0, w = 0; W < j.length; W += 3) if (G = j[W] | j[W + 1] << 8 | j[W + 2] << 16, this.words[w] |= G << S & 67108863, this.words[w + 1] = G >>> 26 - S & 67108863, S += 24, S >= 26) S -= 26, w++;
        }
        return this.strip();
      };
      function J(j, H) {
        var Z = j.charCodeAt(H);
        if (Z >= 65 && Z <= 70) return Z - 55;
        else if (Z >= 97 && Z <= 102) return Z - 87;
        else return Z - 48 & 15;
      }
      __name(J, "J");
      function T(j, H, Z) {
        var W = J(j, Z);
        if (Z - 1 >= H) W |= J(j, Z - 1) << 4;
        return W;
      }
      __name(T, "T");
      O.prototype._parseHex = function(j, H, Z) {
        this.length = Math.ceil((j.length - H) / 6), this.words = Array(this.length);
        for (var W = 0; W < this.length; W++) this.words[W] = 0;
        var w = 0, G = 0, S;
        if (Z === "be") for (W = j.length - 1; W >= H; W -= 2) if (S = T(j, H, W) << w, this.words[G] |= S & 67108863, w >= 18) w -= 18, G += 1, this.words[G] |= S >>> 26;
        else w += 8;
        else {
          var A = j.length - H;
          for (W = A % 2 === 0 ? H + 1 : H; W < j.length; W += 2) if (S = T(j, H, W) << w, this.words[G] |= S & 67108863, w >= 18) w -= 18, G += 1, this.words[G] |= S >>> 26;
          else w += 8;
        }
        this.strip();
      };
      function X(j, H, Z, W) {
        var w = 0, G = Math.min(j.length, Z);
        for (var S = H; S < G; S++) {
          var A = j.charCodeAt(S) - 48;
          if (w *= W, A >= 49) w += A - 49 + 10;
          else if (A >= 17) w += A - 17 + 10;
          else w += A;
        }
        return w;
      }
      __name(X, "X");
      O.prototype._parseBase = function(j, H, Z) {
        this.words = [0], this.length = 1;
        for (var W = 0, w = 1; w <= 67108863; w *= H) W++;
        W--, w = w / H | 0;
        var G = j.length - Z, S = G % W, A = Math.min(G, G - S) + Z, v = 0;
        for (var k = Z; k < A; k += W) if (v = X(j, k, k + W, H), this.imuln(w), this.words[0] + v < 67108864) this.words[0] += v;
        else this._iaddn(v);
        if (S !== 0) {
          var R = 1;
          v = X(j, k, j.length, H);
          for (k = 0; k < S; k++) R *= H;
          if (this.imuln(R), this.words[0] + v < 67108864) this.words[0] += v;
          else this._iaddn(v);
        }
        this.strip();
      }, O.prototype.copy = function(j) {
        j.words = Array(this.length);
        for (var H = 0; H < this.length; H++) j.words[H] = this.words[H];
        j.length = this.length, j.negative = this.negative, j.red = this.red;
      }, O.prototype.clone = function() {
        var j = new O(null);
        return this.copy(j), j;
      }, O.prototype._expand = function(j) {
        while (this.length < j) this.words[this.length++] = 0;
        return this;
      }, O.prototype.strip = function() {
        while (this.length > 1 && this.words[this.length - 1] === 0) this.length--;
        return this._normSign();
      }, O.prototype._normSign = function() {
        if (this.length === 1 && this.words[0] === 0) this.negative = 0;
        return this;
      }, O.prototype.inspect = function() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var f = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], V = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], M = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
      if (O.prototype.toString = function(j, H) {
        j = j || 10, H = H | 0 || 1;
        var Z;
        if (j === 16 || j === "hex") {
          Z = "";
          var W = 0, w = 0;
          for (var G = 0; G < this.length; G++) {
            var S = this.words[G], A = ((S << W | w) & 16777215).toString(16);
            if (w = S >>> 24 - W & 16777215, W += 2, W >= 26) W -= 26, G--;
            if (w !== 0 || G !== this.length - 1) Z = f[6 - A.length] + A + Z;
            else Z = A + Z;
          }
          if (w !== 0) Z = w.toString(16) + Z;
          while (Z.length % H !== 0) Z = "0" + Z;
          if (this.negative !== 0) Z = "-" + Z;
          return Z;
        }
        if (j === (j | 0) && j >= 2 && j <= 36) {
          var v = V[j], k = M[j];
          Z = "";
          var R = this.clone();
          R.negative = 0;
          while (!R.isZero()) {
            var C = R.modn(k).toString(j);
            if (R = R.idivn(k), !R.isZero()) Z = f[v - C.length] + C + Z;
            else Z = C + Z;
          }
          if (this.isZero()) Z = "0" + Z;
          while (Z.length % H !== 0) Z = "0" + Z;
          if (this.negative !== 0) Z = "-" + Z;
          return Z;
        }
        _(false, "Base should be between 2 and 36");
      }, O.prototype.toNumber = function() {
        var j = this.words[0];
        if (this.length === 2) j += this.words[1] * 67108864;
        else if (this.length === 3 && this.words[2] === 1) j += 4503599627370496 + this.words[1] * 67108864;
        else if (this.length > 2) _(false, "Number can only safely store up to 53 bits");
        return this.negative !== 0 ? -j : j;
      }, O.prototype.toJSON = function() {
        return this.toString(16);
      }, O.prototype.toBuffer = function(j, H) {
        return _(typeof z < "u"), this.toArrayLike(z, j, H);
      }, O.prototype.toArray = function(j, H) {
        return this.toArrayLike(Array, j, H);
      }, O.prototype.toArrayLike = function(j, H, Z) {
        var W = this.byteLength(), w = Z || Math.max(1, W);
        _(W <= w, "byte array longer than desired length"), _(w > 0, "Requested array length <= 0"), this.strip();
        var G = H === "le", S = new j(w), A, v, k = this.clone();
        if (!G) {
          for (v = 0; v < w - W; v++) S[v] = 0;
          for (v = 0; !k.isZero(); v++) A = k.andln(255), k.iushrn(8), S[w - v - 1] = A;
        } else {
          for (v = 0; !k.isZero(); v++) A = k.andln(255), k.iushrn(8), S[v] = A;
          for (; v < w; v++) S[v] = 0;
        }
        return S;
      }, Math.clz32) O.prototype._countBits = function(j) {
        return 32 - Math.clz32(j);
      };
      else O.prototype._countBits = function(j) {
        var H = j, Z = 0;
        if (H >= 4096) Z += 13, H >>>= 13;
        if (H >= 64) Z += 7, H >>>= 7;
        if (H >= 8) Z += 4, H >>>= 4;
        if (H >= 2) Z += 2, H >>>= 2;
        return Z + H;
      };
      O.prototype._zeroBits = function(j) {
        if (j === 0) return 26;
        var H = j, Z = 0;
        if ((H & 8191) === 0) Z += 13, H >>>= 13;
        if ((H & 127) === 0) Z += 7, H >>>= 7;
        if ((H & 15) === 0) Z += 4, H >>>= 4;
        if ((H & 3) === 0) Z += 2, H >>>= 2;
        if ((H & 1) === 0) Z++;
        return Z;
      }, O.prototype.bitLength = function() {
        var j = this.words[this.length - 1], H = this._countBits(j);
        return (this.length - 1) * 26 + H;
      };
      function N(j) {
        var H = Array(j.bitLength());
        for (var Z = 0; Z < H.length; Z++) {
          var W = Z / 26 | 0, w = Z % 26;
          H[Z] = (j.words[W] & 1 << w) >>> w;
        }
        return H;
      }
      __name(N, "N");
      O.prototype.zeroBits = function() {
        if (this.isZero()) return 0;
        var j = 0;
        for (var H = 0; H < this.length; H++) {
          var Z = this._zeroBits(this.words[H]);
          if (j += Z, Z !== 26) break;
        }
        return j;
      }, O.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, O.prototype.toTwos = function(j) {
        if (this.negative !== 0) return this.abs().inotn(j).iaddn(1);
        return this.clone();
      }, O.prototype.fromTwos = function(j) {
        if (this.testn(j - 1)) return this.notn(j).iaddn(1).ineg();
        return this.clone();
      }, O.prototype.isNeg = function() {
        return this.negative !== 0;
      }, O.prototype.neg = function() {
        return this.clone().ineg();
      }, O.prototype.ineg = function() {
        if (!this.isZero()) this.negative ^= 1;
        return this;
      }, O.prototype.iuor = function(j) {
        while (this.length < j.length) this.words[this.length++] = 0;
        for (var H = 0; H < j.length; H++) this.words[H] = this.words[H] | j.words[H];
        return this.strip();
      }, O.prototype.ior = function(j) {
        return _((this.negative | j.negative) === 0), this.iuor(j);
      }, O.prototype.or = function(j) {
        if (this.length > j.length) return this.clone().ior(j);
        return j.clone().ior(this);
      }, O.prototype.uor = function(j) {
        if (this.length > j.length) return this.clone().iuor(j);
        return j.clone().iuor(this);
      }, O.prototype.iuand = function(j) {
        var H;
        if (this.length > j.length) H = j;
        else H = this;
        for (var Z = 0; Z < H.length; Z++) this.words[Z] = this.words[Z] & j.words[Z];
        return this.length = H.length, this.strip();
      }, O.prototype.iand = function(j) {
        return _((this.negative | j.negative) === 0), this.iuand(j);
      }, O.prototype.and = function(j) {
        if (this.length > j.length) return this.clone().iand(j);
        return j.clone().iand(this);
      }, O.prototype.uand = function(j) {
        if (this.length > j.length) return this.clone().iuand(j);
        return j.clone().iuand(this);
      }, O.prototype.iuxor = function(j) {
        var H, Z;
        if (this.length > j.length) H = this, Z = j;
        else H = j, Z = this;
        for (var W = 0; W < Z.length; W++) this.words[W] = H.words[W] ^ Z.words[W];
        if (this !== H) for (; W < H.length; W++) this.words[W] = H.words[W];
        return this.length = H.length, this.strip();
      }, O.prototype.ixor = function(j) {
        return _((this.negative | j.negative) === 0), this.iuxor(j);
      }, O.prototype.xor = function(j) {
        if (this.length > j.length) return this.clone().ixor(j);
        return j.clone().ixor(this);
      }, O.prototype.uxor = function(j) {
        if (this.length > j.length) return this.clone().iuxor(j);
        return j.clone().iuxor(this);
      }, O.prototype.inotn = function(j) {
        _(typeof j === "number" && j >= 0);
        var H = Math.ceil(j / 26) | 0, Z = j % 26;
        if (this._expand(H), Z > 0) H--;
        for (var W = 0; W < H; W++) this.words[W] = ~this.words[W] & 67108863;
        if (Z > 0) this.words[W] = ~this.words[W] & 67108863 >> 26 - Z;
        return this.strip();
      }, O.prototype.notn = function(j) {
        return this.clone().inotn(j);
      }, O.prototype.setn = function(j, H) {
        _(typeof j === "number" && j >= 0);
        var Z = j / 26 | 0, W = j % 26;
        if (this._expand(Z + 1), H) this.words[Z] = this.words[Z] | 1 << W;
        else this.words[Z] = this.words[Z] & ~(1 << W);
        return this.strip();
      }, O.prototype.iadd = function(j) {
        var H;
        if (this.negative !== 0 && j.negative === 0) return this.negative = 0, H = this.isub(j), this.negative ^= 1, this._normSign();
        else if (this.negative === 0 && j.negative !== 0) return j.negative = 0, H = this.isub(j), j.negative = 1, H._normSign();
        var Z, W;
        if (this.length > j.length) Z = this, W = j;
        else Z = j, W = this;
        var w = 0;
        for (var G = 0; G < W.length; G++) H = (Z.words[G] | 0) + (W.words[G] | 0) + w, this.words[G] = H & 67108863, w = H >>> 26;
        for (; w !== 0 && G < Z.length; G++) H = (Z.words[G] | 0) + w, this.words[G] = H & 67108863, w = H >>> 26;
        if (this.length = Z.length, w !== 0) this.words[this.length] = w, this.length++;
        else if (Z !== this) for (; G < Z.length; G++) this.words[G] = Z.words[G];
        return this;
      }, O.prototype.add = function(j) {
        var H;
        if (j.negative !== 0 && this.negative === 0) return j.negative = 0, H = this.sub(j), j.negative ^= 1, H;
        else if (j.negative === 0 && this.negative !== 0) return this.negative = 0, H = j.sub(this), this.negative = 1, H;
        if (this.length > j.length) return this.clone().iadd(j);
        return j.clone().iadd(this);
      }, O.prototype.isub = function(j) {
        if (j.negative !== 0) {
          j.negative = 0;
          var H = this.iadd(j);
          return j.negative = 1, H._normSign();
        } else if (this.negative !== 0) return this.negative = 0, this.iadd(j), this.negative = 1, this._normSign();
        var Z = this.cmp(j);
        if (Z === 0) return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var W, w;
        if (Z > 0) W = this, w = j;
        else W = j, w = this;
        var G = 0;
        for (var S = 0; S < w.length; S++) H = (W.words[S] | 0) - (w.words[S] | 0) + G, G = H >> 26, this.words[S] = H & 67108863;
        for (; G !== 0 && S < W.length; S++) H = (W.words[S] | 0) + G, G = H >> 26, this.words[S] = H & 67108863;
        if (G === 0 && S < W.length && W !== this) for (; S < W.length; S++) this.words[S] = W.words[S];
        if (this.length = Math.max(this.length, S), W !== this) this.negative = 1;
        return this.strip();
      }, O.prototype.sub = function(j) {
        return this.clone().isub(j);
      };
      function E(j, H, Z) {
        Z.negative = H.negative ^ j.negative;
        var W = j.length + H.length | 0;
        Z.length = W, W = W - 1 | 0;
        var w = j.words[0] | 0, G = H.words[0] | 0, S = w * G, A = S & 67108863, v = S / 67108864 | 0;
        Z.words[0] = A;
        for (var k = 1; k < W; k++) {
          var R = v >>> 26, C = v & 67108863, L = Math.min(k, H.length - 1);
          for (var x = Math.max(0, k - j.length + 1); x <= L; x++) {
            var l = k - x | 0;
            w = j.words[l] | 0, G = H.words[x] | 0, S = w * G + C, R += S / 67108864 | 0, C = S & 67108863;
          }
          Z.words[k] = C | 0, v = R | 0;
        }
        if (v !== 0) Z.words[k] = v | 0;
        else Z.length--;
        return Z.strip();
      }
      __name(E, "E");
      var h = /* @__PURE__ */ __name(function(j, H, Z) {
        var W = j.words, w = H.words, G = Z.words, S = 0, A, v, k, R = W[0] | 0, C = R & 8191, L = R >>> 13, x = W[1] | 0, l = x & 8191, a = x >>> 13, f$ = W[2] | 0, $$ = f$ & 8191, t = f$ >>> 13, H$ = W[3] | 0, Q = H$ & 8191, v$ = H$ >>> 13, B$ = W[4] | 0, m = B$ & 8191, r = B$ >>> 13, J$ = W[5] | 0, e = J$ & 8191, _$2 = J$ >>> 13, Y$ = W[6] | 0, d = Y$ & 8191, o = Y$ >>> 13, W$ = W[7] | 0, B = W$ & 8191, F = W$ >>> 13, X$ = W[8] | 0, z$ = X$ & 8191, j$ = X$ >>> 13, X6 = W[9] | 0, Z$ = X6 & 8191, A$ = X6 >>> 13, l6 = w[0] | 0, S$ = l6 & 8191, V$ = l6 >>> 13, Mq = w[1] | 0, N$ = Mq & 8191, D$ = Mq >>> 13, Nq = w[2] | 0, L$ = Nq & 8191, C$ = Nq >>> 13, Zq = w[3] | 0, g$ = Zq & 8191, h$ = Zq >>> 13, zq = w[4] | 0, b$ = zq & 8191, y$ = zq >>> 13, Wq = w[5] | 0, E$ = Wq & 8191, u = Wq >>> 13, i = w[6] | 0, K$ = i & 8191, P$ = i >>> 13, i$ = w[7] | 0, k$ = i$ & 8191, G$ = i$ >>> 13, x6 = w[8] | 0, R$ = x6 & 8191, u$ = x6 >>> 13, Xq = w[9] | 0, I$ = Xq & 8191, M$ = Xq >>> 13;
        Z.negative = j.negative ^ H.negative, Z.length = 19, A = Math.imul(C, S$), v = Math.imul(C, V$), v = v + Math.imul(L, S$) | 0, k = Math.imul(L, V$);
        var p6 = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (p6 >>> 26) | 0, p6 &= 67108863, A = Math.imul(l, S$), v = Math.imul(l, V$), v = v + Math.imul(a, S$) | 0, k = Math.imul(a, V$), A = A + Math.imul(C, N$) | 0, v = v + Math.imul(C, D$) | 0, v = v + Math.imul(L, N$) | 0, k = k + Math.imul(L, D$) | 0;
        var H6 = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (H6 >>> 26) | 0, H6 &= 67108863, A = Math.imul($$, S$), v = Math.imul($$, V$), v = v + Math.imul(t, S$) | 0, k = Math.imul(t, V$), A = A + Math.imul(l, N$) | 0, v = v + Math.imul(l, D$) | 0, v = v + Math.imul(a, N$) | 0, k = k + Math.imul(a, D$) | 0, A = A + Math.imul(C, L$) | 0, v = v + Math.imul(C, C$) | 0, v = v + Math.imul(L, L$) | 0, k = k + Math.imul(L, C$) | 0;
        var v6 = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (v6 >>> 26) | 0, v6 &= 67108863, A = Math.imul(Q, S$), v = Math.imul(Q, V$), v = v + Math.imul(v$, S$) | 0, k = Math.imul(v$, V$), A = A + Math.imul($$, N$) | 0, v = v + Math.imul($$, D$) | 0, v = v + Math.imul(t, N$) | 0, k = k + Math.imul(t, D$) | 0, A = A + Math.imul(l, L$) | 0, v = v + Math.imul(l, C$) | 0, v = v + Math.imul(a, L$) | 0, k = k + Math.imul(a, C$) | 0, A = A + Math.imul(C, g$) | 0, v = v + Math.imul(C, h$) | 0, v = v + Math.imul(L, g$) | 0, k = k + Math.imul(L, h$) | 0;
        var C6 = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (C6 >>> 26) | 0, C6 &= 67108863, A = Math.imul(m, S$), v = Math.imul(m, V$), v = v + Math.imul(r, S$) | 0, k = Math.imul(r, V$), A = A + Math.imul(Q, N$) | 0, v = v + Math.imul(Q, D$) | 0, v = v + Math.imul(v$, N$) | 0, k = k + Math.imul(v$, D$) | 0, A = A + Math.imul($$, L$) | 0, v = v + Math.imul($$, C$) | 0, v = v + Math.imul(t, L$) | 0, k = k + Math.imul(t, C$) | 0, A = A + Math.imul(l, g$) | 0, v = v + Math.imul(l, h$) | 0, v = v + Math.imul(a, g$) | 0, k = k + Math.imul(a, h$) | 0, A = A + Math.imul(C, b$) | 0, v = v + Math.imul(C, y$) | 0, v = v + Math.imul(L, b$) | 0, k = k + Math.imul(L, y$) | 0;
        var S6 = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (S6 >>> 26) | 0, S6 &= 67108863, A = Math.imul(e, S$), v = Math.imul(e, V$), v = v + Math.imul(_$2, S$) | 0, k = Math.imul(_$2, V$), A = A + Math.imul(m, N$) | 0, v = v + Math.imul(m, D$) | 0, v = v + Math.imul(r, N$) | 0, k = k + Math.imul(r, D$) | 0, A = A + Math.imul(Q, L$) | 0, v = v + Math.imul(Q, C$) | 0, v = v + Math.imul(v$, L$) | 0, k = k + Math.imul(v$, C$) | 0, A = A + Math.imul($$, g$) | 0, v = v + Math.imul($$, h$) | 0, v = v + Math.imul(t, g$) | 0, k = k + Math.imul(t, h$) | 0, A = A + Math.imul(l, b$) | 0, v = v + Math.imul(l, y$) | 0, v = v + Math.imul(a, b$) | 0, k = k + Math.imul(a, y$) | 0, A = A + Math.imul(C, E$) | 0, v = v + Math.imul(C, u) | 0, v = v + Math.imul(L, E$) | 0, k = k + Math.imul(L, u) | 0;
        var t6 = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (t6 >>> 26) | 0, t6 &= 67108863, A = Math.imul(d, S$), v = Math.imul(d, V$), v = v + Math.imul(o, S$) | 0, k = Math.imul(o, V$), A = A + Math.imul(e, N$) | 0, v = v + Math.imul(e, D$) | 0, v = v + Math.imul(_$2, N$) | 0, k = k + Math.imul(_$2, D$) | 0, A = A + Math.imul(m, L$) | 0, v = v + Math.imul(m, C$) | 0, v = v + Math.imul(r, L$) | 0, k = k + Math.imul(r, C$) | 0, A = A + Math.imul(Q, g$) | 0, v = v + Math.imul(Q, h$) | 0, v = v + Math.imul(v$, g$) | 0, k = k + Math.imul(v$, h$) | 0, A = A + Math.imul($$, b$) | 0, v = v + Math.imul($$, y$) | 0, v = v + Math.imul(t, b$) | 0, k = k + Math.imul(t, y$) | 0, A = A + Math.imul(l, E$) | 0, v = v + Math.imul(l, u) | 0, v = v + Math.imul(a, E$) | 0, k = k + Math.imul(a, u) | 0, A = A + Math.imul(C, K$) | 0, v = v + Math.imul(C, P$) | 0, v = v + Math.imul(L, K$) | 0, k = k + Math.imul(L, P$) | 0;
        var B6 = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (B6 >>> 26) | 0, B6 &= 67108863, A = Math.imul(B, S$), v = Math.imul(B, V$), v = v + Math.imul(F, S$) | 0, k = Math.imul(F, V$), A = A + Math.imul(d, N$) | 0, v = v + Math.imul(d, D$) | 0, v = v + Math.imul(o, N$) | 0, k = k + Math.imul(o, D$) | 0, A = A + Math.imul(e, L$) | 0, v = v + Math.imul(e, C$) | 0, v = v + Math.imul(_$2, L$) | 0, k = k + Math.imul(_$2, C$) | 0, A = A + Math.imul(m, g$) | 0, v = v + Math.imul(m, h$) | 0, v = v + Math.imul(r, g$) | 0, k = k + Math.imul(r, h$) | 0, A = A + Math.imul(Q, b$) | 0, v = v + Math.imul(Q, y$) | 0, v = v + Math.imul(v$, b$) | 0, k = k + Math.imul(v$, y$) | 0, A = A + Math.imul($$, E$) | 0, v = v + Math.imul($$, u) | 0, v = v + Math.imul(t, E$) | 0, k = k + Math.imul(t, u) | 0, A = A + Math.imul(l, K$) | 0, v = v + Math.imul(l, P$) | 0, v = v + Math.imul(a, K$) | 0, k = k + Math.imul(a, P$) | 0, A = A + Math.imul(C, k$) | 0, v = v + Math.imul(C, G$) | 0, v = v + Math.imul(L, k$) | 0, k = k + Math.imul(L, G$) | 0;
        var U6 = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (U6 >>> 26) | 0, U6 &= 67108863, A = Math.imul(z$, S$), v = Math.imul(z$, V$), v = v + Math.imul(j$, S$) | 0, k = Math.imul(j$, V$), A = A + Math.imul(B, N$) | 0, v = v + Math.imul(B, D$) | 0, v = v + Math.imul(F, N$) | 0, k = k + Math.imul(F, D$) | 0, A = A + Math.imul(d, L$) | 0, v = v + Math.imul(d, C$) | 0, v = v + Math.imul(o, L$) | 0, k = k + Math.imul(o, C$) | 0, A = A + Math.imul(e, g$) | 0, v = v + Math.imul(e, h$) | 0, v = v + Math.imul(_$2, g$) | 0, k = k + Math.imul(_$2, h$) | 0, A = A + Math.imul(m, b$) | 0, v = v + Math.imul(m, y$) | 0, v = v + Math.imul(r, b$) | 0, k = k + Math.imul(r, y$) | 0, A = A + Math.imul(Q, E$) | 0, v = v + Math.imul(Q, u) | 0, v = v + Math.imul(v$, E$) | 0, k = k + Math.imul(v$, u) | 0, A = A + Math.imul($$, K$) | 0, v = v + Math.imul($$, P$) | 0, v = v + Math.imul(t, K$) | 0, k = k + Math.imul(t, P$) | 0, A = A + Math.imul(l, k$) | 0, v = v + Math.imul(l, G$) | 0, v = v + Math.imul(a, k$) | 0, k = k + Math.imul(a, G$) | 0, A = A + Math.imul(C, R$) | 0, v = v + Math.imul(C, u$) | 0, v = v + Math.imul(L, R$) | 0, k = k + Math.imul(L, u$) | 0;
        var F6 = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (F6 >>> 26) | 0, F6 &= 67108863, A = Math.imul(Z$, S$), v = Math.imul(Z$, V$), v = v + Math.imul(A$, S$) | 0, k = Math.imul(A$, V$), A = A + Math.imul(z$, N$) | 0, v = v + Math.imul(z$, D$) | 0, v = v + Math.imul(j$, N$) | 0, k = k + Math.imul(j$, D$) | 0, A = A + Math.imul(B, L$) | 0, v = v + Math.imul(B, C$) | 0, v = v + Math.imul(F, L$) | 0, k = k + Math.imul(F, C$) | 0, A = A + Math.imul(d, g$) | 0, v = v + Math.imul(d, h$) | 0, v = v + Math.imul(o, g$) | 0, k = k + Math.imul(o, h$) | 0, A = A + Math.imul(e, b$) | 0, v = v + Math.imul(e, y$) | 0, v = v + Math.imul(_$2, b$) | 0, k = k + Math.imul(_$2, y$) | 0, A = A + Math.imul(m, E$) | 0, v = v + Math.imul(m, u) | 0, v = v + Math.imul(r, E$) | 0, k = k + Math.imul(r, u) | 0, A = A + Math.imul(Q, K$) | 0, v = v + Math.imul(Q, P$) | 0, v = v + Math.imul(v$, K$) | 0, k = k + Math.imul(v$, P$) | 0, A = A + Math.imul($$, k$) | 0, v = v + Math.imul($$, G$) | 0, v = v + Math.imul(t, k$) | 0, k = k + Math.imul(t, G$) | 0, A = A + Math.imul(l, R$) | 0, v = v + Math.imul(l, u$) | 0, v = v + Math.imul(a, R$) | 0, k = k + Math.imul(a, u$) | 0, A = A + Math.imul(C, I$) | 0, v = v + Math.imul(C, M$) | 0, v = v + Math.imul(L, I$) | 0, k = k + Math.imul(L, M$) | 0;
        var a6 = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (a6 >>> 26) | 0, a6 &= 67108863, A = Math.imul(Z$, N$), v = Math.imul(Z$, D$), v = v + Math.imul(A$, N$) | 0, k = Math.imul(A$, D$), A = A + Math.imul(z$, L$) | 0, v = v + Math.imul(z$, C$) | 0, v = v + Math.imul(j$, L$) | 0, k = k + Math.imul(j$, C$) | 0, A = A + Math.imul(B, g$) | 0, v = v + Math.imul(B, h$) | 0, v = v + Math.imul(F, g$) | 0, k = k + Math.imul(F, h$) | 0, A = A + Math.imul(d, b$) | 0, v = v + Math.imul(d, y$) | 0, v = v + Math.imul(o, b$) | 0, k = k + Math.imul(o, y$) | 0, A = A + Math.imul(e, E$) | 0, v = v + Math.imul(e, u) | 0, v = v + Math.imul(_$2, E$) | 0, k = k + Math.imul(_$2, u) | 0, A = A + Math.imul(m, K$) | 0, v = v + Math.imul(m, P$) | 0, v = v + Math.imul(r, K$) | 0, k = k + Math.imul(r, P$) | 0, A = A + Math.imul(Q, k$) | 0, v = v + Math.imul(Q, G$) | 0, v = v + Math.imul(v$, k$) | 0, k = k + Math.imul(v$, G$) | 0, A = A + Math.imul($$, R$) | 0, v = v + Math.imul($$, u$) | 0, v = v + Math.imul(t, R$) | 0, k = k + Math.imul(t, u$) | 0, A = A + Math.imul(l, I$) | 0, v = v + Math.imul(l, M$) | 0, v = v + Math.imul(a, I$) | 0, k = k + Math.imul(a, M$) | 0;
        var Q6 = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (Q6 >>> 26) | 0, Q6 &= 67108863, A = Math.imul(Z$, L$), v = Math.imul(Z$, C$), v = v + Math.imul(A$, L$) | 0, k = Math.imul(A$, C$), A = A + Math.imul(z$, g$) | 0, v = v + Math.imul(z$, h$) | 0, v = v + Math.imul(j$, g$) | 0, k = k + Math.imul(j$, h$) | 0, A = A + Math.imul(B, b$) | 0, v = v + Math.imul(B, y$) | 0, v = v + Math.imul(F, b$) | 0, k = k + Math.imul(F, y$) | 0, A = A + Math.imul(d, E$) | 0, v = v + Math.imul(d, u) | 0, v = v + Math.imul(o, E$) | 0, k = k + Math.imul(o, u) | 0, A = A + Math.imul(e, K$) | 0, v = v + Math.imul(e, P$) | 0, v = v + Math.imul(_$2, K$) | 0, k = k + Math.imul(_$2, P$) | 0, A = A + Math.imul(m, k$) | 0, v = v + Math.imul(m, G$) | 0, v = v + Math.imul(r, k$) | 0, k = k + Math.imul(r, G$) | 0, A = A + Math.imul(Q, R$) | 0, v = v + Math.imul(Q, u$) | 0, v = v + Math.imul(v$, R$) | 0, k = k + Math.imul(v$, u$) | 0, A = A + Math.imul($$, I$) | 0, v = v + Math.imul($$, M$) | 0, v = v + Math.imul(t, I$) | 0, k = k + Math.imul(t, M$) | 0;
        var e6 = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (e6 >>> 26) | 0, e6 &= 67108863, A = Math.imul(Z$, g$), v = Math.imul(Z$, h$), v = v + Math.imul(A$, g$) | 0, k = Math.imul(A$, h$), A = A + Math.imul(z$, b$) | 0, v = v + Math.imul(z$, y$) | 0, v = v + Math.imul(j$, b$) | 0, k = k + Math.imul(j$, y$) | 0, A = A + Math.imul(B, E$) | 0, v = v + Math.imul(B, u) | 0, v = v + Math.imul(F, E$) | 0, k = k + Math.imul(F, u) | 0, A = A + Math.imul(d, K$) | 0, v = v + Math.imul(d, P$) | 0, v = v + Math.imul(o, K$) | 0, k = k + Math.imul(o, P$) | 0, A = A + Math.imul(e, k$) | 0, v = v + Math.imul(e, G$) | 0, v = v + Math.imul(_$2, k$) | 0, k = k + Math.imul(_$2, G$) | 0, A = A + Math.imul(m, R$) | 0, v = v + Math.imul(m, u$) | 0, v = v + Math.imul(r, R$) | 0, k = k + Math.imul(r, u$) | 0, A = A + Math.imul(Q, I$) | 0, v = v + Math.imul(Q, M$) | 0, v = v + Math.imul(v$, I$) | 0, k = k + Math.imul(v$, M$) | 0;
        var s6 = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (s6 >>> 26) | 0, s6 &= 67108863, A = Math.imul(Z$, b$), v = Math.imul(Z$, y$), v = v + Math.imul(A$, b$) | 0, k = Math.imul(A$, y$), A = A + Math.imul(z$, E$) | 0, v = v + Math.imul(z$, u) | 0, v = v + Math.imul(j$, E$) | 0, k = k + Math.imul(j$, u) | 0, A = A + Math.imul(B, K$) | 0, v = v + Math.imul(B, P$) | 0, v = v + Math.imul(F, K$) | 0, k = k + Math.imul(F, P$) | 0, A = A + Math.imul(d, k$) | 0, v = v + Math.imul(d, G$) | 0, v = v + Math.imul(o, k$) | 0, k = k + Math.imul(o, G$) | 0, A = A + Math.imul(e, R$) | 0, v = v + Math.imul(e, u$) | 0, v = v + Math.imul(_$2, R$) | 0, k = k + Math.imul(_$2, u$) | 0, A = A + Math.imul(m, I$) | 0, v = v + Math.imul(m, M$) | 0, v = v + Math.imul(r, I$) | 0, k = k + Math.imul(r, M$) | 0;
        var $q = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + ($q >>> 26) | 0, $q &= 67108863, A = Math.imul(Z$, E$), v = Math.imul(Z$, u), v = v + Math.imul(A$, E$) | 0, k = Math.imul(A$, u), A = A + Math.imul(z$, K$) | 0, v = v + Math.imul(z$, P$) | 0, v = v + Math.imul(j$, K$) | 0, k = k + Math.imul(j$, P$) | 0, A = A + Math.imul(B, k$) | 0, v = v + Math.imul(B, G$) | 0, v = v + Math.imul(F, k$) | 0, k = k + Math.imul(F, G$) | 0, A = A + Math.imul(d, R$) | 0, v = v + Math.imul(d, u$) | 0, v = v + Math.imul(o, R$) | 0, k = k + Math.imul(o, u$) | 0, A = A + Math.imul(e, I$) | 0, v = v + Math.imul(e, M$) | 0, v = v + Math.imul(_$2, I$) | 0, k = k + Math.imul(_$2, M$) | 0;
        var qq = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (qq >>> 26) | 0, qq &= 67108863, A = Math.imul(Z$, K$), v = Math.imul(Z$, P$), v = v + Math.imul(A$, K$) | 0, k = Math.imul(A$, P$), A = A + Math.imul(z$, k$) | 0, v = v + Math.imul(z$, G$) | 0, v = v + Math.imul(j$, k$) | 0, k = k + Math.imul(j$, G$) | 0, A = A + Math.imul(B, R$) | 0, v = v + Math.imul(B, u$) | 0, v = v + Math.imul(F, R$) | 0, k = k + Math.imul(F, u$) | 0, A = A + Math.imul(d, I$) | 0, v = v + Math.imul(d, M$) | 0, v = v + Math.imul(o, I$) | 0, k = k + Math.imul(o, M$) | 0;
        var Kq = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (Kq >>> 26) | 0, Kq &= 67108863, A = Math.imul(Z$, k$), v = Math.imul(Z$, G$), v = v + Math.imul(A$, k$) | 0, k = Math.imul(A$, G$), A = A + Math.imul(z$, R$) | 0, v = v + Math.imul(z$, u$) | 0, v = v + Math.imul(j$, R$) | 0, k = k + Math.imul(j$, u$) | 0, A = A + Math.imul(B, I$) | 0, v = v + Math.imul(B, M$) | 0, v = v + Math.imul(F, I$) | 0, k = k + Math.imul(F, M$) | 0;
        var _q = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (_q >>> 26) | 0, _q &= 67108863, A = Math.imul(Z$, R$), v = Math.imul(Z$, u$), v = v + Math.imul(A$, R$) | 0, k = Math.imul(A$, u$), A = A + Math.imul(z$, I$) | 0, v = v + Math.imul(z$, M$) | 0, v = v + Math.imul(j$, I$) | 0, k = k + Math.imul(j$, M$) | 0;
        var Pq = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (Pq >>> 26) | 0, Pq &= 67108863, A = Math.imul(Z$, I$), v = Math.imul(Z$, M$), v = v + Math.imul(A$, I$) | 0, k = Math.imul(A$, M$);
        var Oq = (S + A | 0) + ((v & 8191) << 13) | 0;
        if (S = (k + (v >>> 13) | 0) + (Oq >>> 26) | 0, Oq &= 67108863, G[0] = p6, G[1] = H6, G[2] = v6, G[3] = C6, G[4] = S6, G[5] = t6, G[6] = B6, G[7] = U6, G[8] = F6, G[9] = a6, G[10] = Q6, G[11] = e6, G[12] = s6, G[13] = $q, G[14] = qq, G[15] = Kq, G[16] = _q, G[17] = Pq, G[18] = Oq, S !== 0) G[19] = S, Z.length++;
        return Z;
      }, "h");
      if (!Math.imul) h = E;
      function I(j, H, Z) {
        Z.negative = H.negative ^ j.negative, Z.length = j.length + H.length;
        var W = 0, w = 0;
        for (var G = 0; G < Z.length - 1; G++) {
          var S = w;
          w = 0;
          var A = W & 67108863, v = Math.min(G, H.length - 1);
          for (var k = Math.max(0, G - j.length + 1); k <= v; k++) {
            var R = G - k, C = j.words[R] | 0, L = H.words[k] | 0, x = C * L, l = x & 67108863;
            S = S + (x / 67108864 | 0) | 0, l = l + A | 0, A = l & 67108863, S = S + (l >>> 26) | 0, w += S >>> 26, S &= 67108863;
          }
          Z.words[G] = A, W = S, S = w;
        }
        if (W !== 0) Z.words[G] = W;
        else Z.length--;
        return Z.strip();
      }
      __name(I, "I");
      function D(j, H, Z) {
        var W = new g();
        return W.mulp(j, H, Z);
      }
      __name(D, "D");
      O.prototype.mulTo = function(j, H) {
        var Z, W = this.length + j.length;
        if (this.length === 10 && j.length === 10) Z = h(this, j, H);
        else if (W < 63) Z = E(this, j, H);
        else if (W < 1024) Z = I(this, j, H);
        else Z = D(this, j, H);
        return Z;
      };
      function g(j, H) {
        this.x = j, this.y = H;
      }
      __name(g, "g");
      g.prototype.makeRBT = function(j) {
        var H = Array(j), Z = O.prototype._countBits(j) - 1;
        for (var W = 0; W < j; W++) H[W] = this.revBin(W, Z, j);
        return H;
      }, g.prototype.revBin = function(j, H, Z) {
        if (j === 0 || j === Z - 1) return j;
        var W = 0;
        for (var w = 0; w < H; w++) W |= (j & 1) << H - w - 1, j >>= 1;
        return W;
      }, g.prototype.permute = function(j, H, Z, W, w, G) {
        for (var S = 0; S < G; S++) W[S] = H[j[S]], w[S] = Z[j[S]];
      }, g.prototype.transform = function(j, H, Z, W, w, G) {
        this.permute(G, j, H, Z, W, w);
        for (var S = 1; S < w; S <<= 1) {
          var A = S << 1, v = Math.cos(2 * Math.PI / A), k = Math.sin(2 * Math.PI / A);
          for (var R = 0; R < w; R += A) {
            var C = v, L = k;
            for (var x = 0; x < S; x++) {
              var l = Z[R + x], a = W[R + x], f$ = Z[R + x + S], $$ = W[R + x + S], t = C * f$ - L * $$;
              if ($$ = C * $$ + L * f$, f$ = t, Z[R + x] = l + f$, W[R + x] = a + $$, Z[R + x + S] = l - f$, W[R + x + S] = a - $$, x !== A) t = v * C - k * L, L = v * L + k * C, C = t;
            }
          }
        }
      }, g.prototype.guessLen13b = function(j, H) {
        var Z = Math.max(H, j) | 1, W = Z & 1, w = 0;
        for (Z = Z / 2 | 0; Z; Z = Z >>> 1) w++;
        return 1 << w + 1 + W;
      }, g.prototype.conjugate = function(j, H, Z) {
        if (Z <= 1) return;
        for (var W = 0; W < Z / 2; W++) {
          var w = j[W];
          j[W] = j[Z - W - 1], j[Z - W - 1] = w, w = H[W], H[W] = -H[Z - W - 1], H[Z - W - 1] = -w;
        }
      }, g.prototype.normalize13b = function(j, H) {
        var Z = 0;
        for (var W = 0; W < H / 2; W++) {
          var w = Math.round(j[2 * W + 1] / H) * 8192 + Math.round(j[2 * W] / H) + Z;
          if (j[W] = w & 67108863, w < 67108864) Z = 0;
          else Z = w / 67108864 | 0;
        }
        return j;
      }, g.prototype.convert13b = function(j, H, Z, W) {
        var w = 0;
        for (var G = 0; G < H; G++) w = w + (j[G] | 0), Z[2 * G] = w & 8191, w = w >>> 13, Z[2 * G + 1] = w & 8191, w = w >>> 13;
        for (G = 2 * H; G < W; ++G) Z[G] = 0;
        _(w === 0), _((w & -8192) === 0);
      }, g.prototype.stub = function(j) {
        var H = Array(j);
        for (var Z = 0; Z < j; Z++) H[Z] = 0;
        return H;
      }, g.prototype.mulp = function(j, H, Z) {
        var W = 2 * this.guessLen13b(j.length, H.length), w = this.makeRBT(W), G = this.stub(W), S = Array(W), A = Array(W), v = Array(W), k = Array(W), R = Array(W), C = Array(W), L = Z.words;
        L.length = W, this.convert13b(j.words, j.length, S, W), this.convert13b(H.words, H.length, k, W), this.transform(S, G, A, v, W, w), this.transform(k, G, R, C, W, w);
        for (var x = 0; x < W; x++) {
          var l = A[x] * R[x] - v[x] * C[x];
          v[x] = A[x] * C[x] + v[x] * R[x], A[x] = l;
        }
        return this.conjugate(A, v, W), this.transform(A, v, L, G, W, w), this.conjugate(L, G, W), this.normalize13b(L, W), Z.negative = j.negative ^ H.negative, Z.length = j.length + H.length, Z.strip();
      }, O.prototype.mul = function(j) {
        var H = new O(null);
        return H.words = Array(this.length + j.length), this.mulTo(j, H);
      }, O.prototype.mulf = function(j) {
        var H = new O(null);
        return H.words = Array(this.length + j.length), D(this, j, H);
      }, O.prototype.imul = function(j) {
        return this.clone().mulTo(j, this);
      }, O.prototype.imuln = function(j) {
        _(typeof j === "number"), _(j < 67108864);
        var H = 0;
        for (var Z = 0; Z < this.length; Z++) {
          var W = (this.words[Z] | 0) * j, w = (W & 67108863) + (H & 67108863);
          H >>= 26, H += W / 67108864 | 0, H += w >>> 26, this.words[Z] = w & 67108863;
        }
        if (H !== 0) this.words[Z] = H, this.length++;
        return this.length = j === 0 ? 1 : this.length, this;
      }, O.prototype.muln = function(j) {
        return this.clone().imuln(j);
      }, O.prototype.sqr = function() {
        return this.mul(this);
      }, O.prototype.isqr = function() {
        return this.imul(this.clone());
      }, O.prototype.pow = function(j) {
        var H = N(j);
        if (H.length === 0) return new O(1);
        var Z = this;
        for (var W = 0; W < H.length; W++, Z = Z.sqr()) if (H[W] !== 0) break;
        if (++W < H.length) for (var w = Z.sqr(); W < H.length; W++, w = w.sqr()) {
          if (H[W] === 0) continue;
          Z = Z.mul(w);
        }
        return Z;
      }, O.prototype.iushln = function(j) {
        _(typeof j === "number" && j >= 0);
        var H = j % 26, Z = (j - H) / 26, W = 67108863 >>> 26 - H << 26 - H, w;
        if (H !== 0) {
          var G = 0;
          for (w = 0; w < this.length; w++) {
            var S = this.words[w] & W, A = (this.words[w] | 0) - S << H;
            this.words[w] = A | G, G = S >>> 26 - H;
          }
          if (G) this.words[w] = G, this.length++;
        }
        if (Z !== 0) {
          for (w = this.length - 1; w >= 0; w--) this.words[w + Z] = this.words[w];
          for (w = 0; w < Z; w++) this.words[w] = 0;
          this.length += Z;
        }
        return this.strip();
      }, O.prototype.ishln = function(j) {
        return _(this.negative === 0), this.iushln(j);
      }, O.prototype.iushrn = function(j, H, Z) {
        _(typeof j === "number" && j >= 0);
        var W;
        if (H) W = (H - H % 26) / 26;
        else W = 0;
        var w = j % 26, G = Math.min((j - w) / 26, this.length), S = 67108863 ^ 67108863 >>> w << w, A = Z;
        if (W -= G, W = Math.max(0, W), A) {
          for (var v = 0; v < G; v++) A.words[v] = this.words[v];
          A.length = G;
        }
        if (G === 0) ;
        else if (this.length > G) {
          this.length -= G;
          for (v = 0; v < this.length; v++) this.words[v] = this.words[v + G];
        } else this.words[0] = 0, this.length = 1;
        var k = 0;
        for (v = this.length - 1; v >= 0 && (k !== 0 || v >= W); v--) {
          var R = this.words[v] | 0;
          this.words[v] = k << 26 - w | R >>> w, k = R & S;
        }
        if (A && k !== 0) A.words[A.length++] = k;
        if (this.length === 0) this.words[0] = 0, this.length = 1;
        return this.strip();
      }, O.prototype.ishrn = function(j, H, Z) {
        return _(this.negative === 0), this.iushrn(j, H, Z);
      }, O.prototype.shln = function(j) {
        return this.clone().ishln(j);
      }, O.prototype.ushln = function(j) {
        return this.clone().iushln(j);
      }, O.prototype.shrn = function(j) {
        return this.clone().ishrn(j);
      }, O.prototype.ushrn = function(j) {
        return this.clone().iushrn(j);
      }, O.prototype.testn = function(j) {
        _(typeof j === "number" && j >= 0);
        var H = j % 26, Z = (j - H) / 26, W = 1 << H;
        if (this.length <= Z) return false;
        var w = this.words[Z];
        return !!(w & W);
      }, O.prototype.imaskn = function(j) {
        _(typeof j === "number" && j >= 0);
        var H = j % 26, Z = (j - H) / 26;
        if (_(this.negative === 0, "imaskn works only with positive numbers"), this.length <= Z) return this;
        if (H !== 0) Z++;
        if (this.length = Math.min(Z, this.length), H !== 0) {
          var W = 67108863 ^ 67108863 >>> H << H;
          this.words[this.length - 1] &= W;
        }
        return this.strip();
      }, O.prototype.maskn = function(j) {
        return this.clone().imaskn(j);
      }, O.prototype.iaddn = function(j) {
        if (_(typeof j === "number"), _(j < 67108864), j < 0) return this.isubn(-j);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) < j) return this.words[0] = j - (this.words[0] | 0), this.negative = 0, this;
          return this.negative = 0, this.isubn(j), this.negative = 1, this;
        }
        return this._iaddn(j);
      }, O.prototype._iaddn = function(j) {
        this.words[0] += j;
        for (var H = 0; H < this.length && this.words[H] >= 67108864; H++) if (this.words[H] -= 67108864, H === this.length - 1) this.words[H + 1] = 1;
        else this.words[H + 1]++;
        return this.length = Math.max(this.length, H + 1), this;
      }, O.prototype.isubn = function(j) {
        if (_(typeof j === "number"), _(j < 67108864), j < 0) return this.iaddn(-j);
        if (this.negative !== 0) return this.negative = 0, this.iaddn(j), this.negative = 1, this;
        if (this.words[0] -= j, this.length === 1 && this.words[0] < 0) this.words[0] = -this.words[0], this.negative = 1;
        else for (var H = 0; H < this.length && this.words[H] < 0; H++) this.words[H] += 67108864, this.words[H + 1] -= 1;
        return this.strip();
      }, O.prototype.addn = function(j) {
        return this.clone().iaddn(j);
      }, O.prototype.subn = function(j) {
        return this.clone().isubn(j);
      }, O.prototype.iabs = function() {
        return this.negative = 0, this;
      }, O.prototype.abs = function() {
        return this.clone().iabs();
      }, O.prototype._ishlnsubmul = function(j, H, Z) {
        var W = j.length + Z, w;
        this._expand(W);
        var G, S = 0;
        for (w = 0; w < j.length; w++) {
          G = (this.words[w + Z] | 0) + S;
          var A = (j.words[w] | 0) * H;
          G -= A & 67108863, S = (G >> 26) - (A / 67108864 | 0), this.words[w + Z] = G & 67108863;
        }
        for (; w < this.length - Z; w++) G = (this.words[w + Z] | 0) + S, S = G >> 26, this.words[w + Z] = G & 67108863;
        if (S === 0) return this.strip();
        _(S === -1), S = 0;
        for (w = 0; w < this.length; w++) G = -(this.words[w] | 0) + S, S = G >> 26, this.words[w] = G & 67108863;
        return this.negative = 1, this.strip();
      }, O.prototype._wordDiv = function(j, H) {
        var Z = this.length - j.length, W = this.clone(), w = j, G = w.words[w.length - 1] | 0, S = this._countBits(G);
        if (Z = 26 - S, Z !== 0) w = w.ushln(Z), W.iushln(Z), G = w.words[w.length - 1] | 0;
        var A = W.length - w.length, v;
        if (H !== "mod") {
          v = new O(null), v.length = A + 1, v.words = Array(v.length);
          for (var k = 0; k < v.length; k++) v.words[k] = 0;
        }
        var R = W.clone()._ishlnsubmul(w, 1, A);
        if (R.negative === 0) {
          if (W = R, v) v.words[A] = 1;
        }
        for (var C = A - 1; C >= 0; C--) {
          var L = (W.words[w.length + C] | 0) * 67108864 + (W.words[w.length + C - 1] | 0);
          L = Math.min(L / G | 0, 67108863), W._ishlnsubmul(w, L, C);
          while (W.negative !== 0) if (L--, W.negative = 0, W._ishlnsubmul(w, 1, C), !W.isZero()) W.negative ^= 1;
          if (v) v.words[C] = L;
        }
        if (v) v.strip();
        if (W.strip(), H !== "div" && Z !== 0) W.iushrn(Z);
        return { div: v || null, mod: W };
      }, O.prototype.divmod = function(j, H, Z) {
        if (_(!j.isZero()), this.isZero()) return { div: new O(0), mod: new O(0) };
        var W, w, G;
        if (this.negative !== 0 && j.negative === 0) {
          if (G = this.neg().divmod(j, H), H !== "mod") W = G.div.neg();
          if (H !== "div") {
            if (w = G.mod.neg(), Z && w.negative !== 0) w.iadd(j);
          }
          return { div: W, mod: w };
        }
        if (this.negative === 0 && j.negative !== 0) {
          if (G = this.divmod(j.neg(), H), H !== "mod") W = G.div.neg();
          return { div: W, mod: G.mod };
        }
        if ((this.negative & j.negative) !== 0) {
          if (G = this.neg().divmod(j.neg(), H), H !== "div") {
            if (w = G.mod.neg(), Z && w.negative !== 0) w.isub(j);
          }
          return { div: G.div, mod: w };
        }
        if (j.length > this.length || this.cmp(j) < 0) return { div: new O(0), mod: this };
        if (j.length === 1) {
          if (H === "div") return { div: this.divn(j.words[0]), mod: null };
          if (H === "mod") return { div: null, mod: new O(this.modn(j.words[0])) };
          return { div: this.divn(j.words[0]), mod: new O(this.modn(j.words[0])) };
        }
        return this._wordDiv(j, H);
      }, O.prototype.div = function(j) {
        return this.divmod(j, "div", false).div;
      }, O.prototype.mod = function(j) {
        return this.divmod(j, "mod", false).mod;
      }, O.prototype.umod = function(j) {
        return this.divmod(j, "mod", true).mod;
      }, O.prototype.divRound = function(j) {
        var H = this.divmod(j);
        if (H.mod.isZero()) return H.div;
        var Z = H.div.negative !== 0 ? H.mod.isub(j) : H.mod, W = j.ushrn(1), w = j.andln(1), G = Z.cmp(W);
        if (G < 0 || w === 1 && G === 0) return H.div;
        return H.div.negative !== 0 ? H.div.isubn(1) : H.div.iaddn(1);
      }, O.prototype.modn = function(j) {
        _(j <= 67108863);
        var H = 67108864 % j, Z = 0;
        for (var W = this.length - 1; W >= 0; W--) Z = (H * Z + (this.words[W] | 0)) % j;
        return Z;
      }, O.prototype.idivn = function(j) {
        _(j <= 67108863);
        var H = 0;
        for (var Z = this.length - 1; Z >= 0; Z--) {
          var W = (this.words[Z] | 0) + H * 67108864;
          this.words[Z] = W / j | 0, H = W % j;
        }
        return this.strip();
      }, O.prototype.divn = function(j) {
        return this.clone().idivn(j);
      }, O.prototype.egcd = function(j) {
        _(j.negative === 0), _(!j.isZero());
        var H = this, Z = j.clone();
        if (H.negative !== 0) H = H.umod(j);
        else H = H.clone();
        var W = new O(1), w = new O(0), G = new O(0), S = new O(1), A = 0;
        while (H.isEven() && Z.isEven()) H.iushrn(1), Z.iushrn(1), ++A;
        var v = Z.clone(), k = H.clone();
        while (!H.isZero()) {
          for (var R = 0, C = 1; (H.words[0] & C) === 0 && R < 26; ++R, C <<= 1) ;
          if (R > 0) {
            H.iushrn(R);
            while (R-- > 0) {
              if (W.isOdd() || w.isOdd()) W.iadd(v), w.isub(k);
              W.iushrn(1), w.iushrn(1);
            }
          }
          for (var L = 0, x = 1; (Z.words[0] & x) === 0 && L < 26; ++L, x <<= 1) ;
          if (L > 0) {
            Z.iushrn(L);
            while (L-- > 0) {
              if (G.isOdd() || S.isOdd()) G.iadd(v), S.isub(k);
              G.iushrn(1), S.iushrn(1);
            }
          }
          if (H.cmp(Z) >= 0) H.isub(Z), W.isub(G), w.isub(S);
          else Z.isub(H), G.isub(W), S.isub(w);
        }
        return { a: G, b: S, gcd: Z.iushln(A) };
      }, O.prototype._invmp = function(j) {
        _(j.negative === 0), _(!j.isZero());
        var H = this, Z = j.clone();
        if (H.negative !== 0) H = H.umod(j);
        else H = H.clone();
        var W = new O(1), w = new O(0), G = Z.clone();
        while (H.cmpn(1) > 0 && Z.cmpn(1) > 0) {
          for (var S = 0, A = 1; (H.words[0] & A) === 0 && S < 26; ++S, A <<= 1) ;
          if (S > 0) {
            H.iushrn(S);
            while (S-- > 0) {
              if (W.isOdd()) W.iadd(G);
              W.iushrn(1);
            }
          }
          for (var v = 0, k = 1; (Z.words[0] & k) === 0 && v < 26; ++v, k <<= 1) ;
          if (v > 0) {
            Z.iushrn(v);
            while (v-- > 0) {
              if (w.isOdd()) w.iadd(G);
              w.iushrn(1);
            }
          }
          if (H.cmp(Z) >= 0) H.isub(Z), W.isub(w);
          else Z.isub(H), w.isub(W);
        }
        var R;
        if (H.cmpn(1) === 0) R = W;
        else R = w;
        if (R.cmpn(0) < 0) R.iadd(j);
        return R;
      }, O.prototype.gcd = function(j) {
        if (this.isZero()) return j.abs();
        if (j.isZero()) return this.abs();
        var H = this.clone(), Z = j.clone();
        H.negative = 0, Z.negative = 0;
        for (var W = 0; H.isEven() && Z.isEven(); W++) H.iushrn(1), Z.iushrn(1);
        do {
          while (H.isEven()) H.iushrn(1);
          while (Z.isEven()) Z.iushrn(1);
          var w = H.cmp(Z);
          if (w < 0) {
            var G = H;
            H = Z, Z = G;
          } else if (w === 0 || Z.cmpn(1) === 0) break;
          H.isub(Z);
        } while (true);
        return Z.iushln(W);
      }, O.prototype.invm = function(j) {
        return this.egcd(j).a.umod(j);
      }, O.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, O.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, O.prototype.andln = function(j) {
        return this.words[0] & j;
      }, O.prototype.bincn = function(j) {
        _(typeof j === "number");
        var H = j % 26, Z = (j - H) / 26, W = 1 << H;
        if (this.length <= Z) return this._expand(Z + 1), this.words[Z] |= W, this;
        var w = W;
        for (var G = Z; w !== 0 && G < this.length; G++) {
          var S = this.words[G] | 0;
          S += w, w = S >>> 26, S &= 67108863, this.words[G] = S;
        }
        if (w !== 0) this.words[G] = w, this.length++;
        return this;
      }, O.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, O.prototype.cmpn = function(j) {
        var H = j < 0;
        if (this.negative !== 0 && !H) return -1;
        if (this.negative === 0 && H) return 1;
        this.strip();
        var Z;
        if (this.length > 1) Z = 1;
        else {
          if (H) j = -j;
          _(j <= 67108863, "Number is too big");
          var W = this.words[0] | 0;
          Z = W === j ? 0 : W < j ? -1 : 1;
        }
        if (this.negative !== 0) return -Z | 0;
        return Z;
      }, O.prototype.cmp = function(j) {
        if (this.negative !== 0 && j.negative === 0) return -1;
        if (this.negative === 0 && j.negative !== 0) return 1;
        var H = this.ucmp(j);
        if (this.negative !== 0) return -H | 0;
        return H;
      }, O.prototype.ucmp = function(j) {
        if (this.length > j.length) return 1;
        if (this.length < j.length) return -1;
        var H = 0;
        for (var Z = this.length - 1; Z >= 0; Z--) {
          var W = this.words[Z] | 0, w = j.words[Z] | 0;
          if (W === w) continue;
          if (W < w) H = -1;
          else if (W > w) H = 1;
          break;
        }
        return H;
      }, O.prototype.gtn = function(j) {
        return this.cmpn(j) === 1;
      }, O.prototype.gt = function(j) {
        return this.cmp(j) === 1;
      }, O.prototype.gten = function(j) {
        return this.cmpn(j) >= 0;
      }, O.prototype.gte = function(j) {
        return this.cmp(j) >= 0;
      }, O.prototype.ltn = function(j) {
        return this.cmpn(j) === -1;
      }, O.prototype.lt = function(j) {
        return this.cmp(j) === -1;
      }, O.prototype.lten = function(j) {
        return this.cmpn(j) <= 0;
      }, O.prototype.lte = function(j) {
        return this.cmp(j) <= 0;
      }, O.prototype.eqn = function(j) {
        return this.cmpn(j) === 0;
      }, O.prototype.eq = function(j) {
        return this.cmp(j) === 0;
      }, O.red = function(j) {
        return new c(j);
      }, O.prototype.toRed = function(j) {
        return _(!this.red, "Already a number in reduction context"), _(this.negative === 0, "red works only with positives"), j.convertTo(this)._forceRed(j);
      }, O.prototype.fromRed = function() {
        return _(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, O.prototype._forceRed = function(j) {
        return this.red = j, this;
      }, O.prototype.forceRed = function(j) {
        return _(!this.red, "Already a number in reduction context"), this._forceRed(j);
      }, O.prototype.redAdd = function(j) {
        return _(this.red, "redAdd works only with red numbers"), this.red.add(this, j);
      }, O.prototype.redIAdd = function(j) {
        return _(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, j);
      }, O.prototype.redSub = function(j) {
        return _(this.red, "redSub works only with red numbers"), this.red.sub(this, j);
      }, O.prototype.redISub = function(j) {
        return _(this.red, "redISub works only with red numbers"), this.red.isub(this, j);
      }, O.prototype.redShl = function(j) {
        return _(this.red, "redShl works only with red numbers"), this.red.shl(this, j);
      }, O.prototype.redMul = function(j) {
        return _(this.red, "redMul works only with red numbers"), this.red._verify2(this, j), this.red.mul(this, j);
      }, O.prototype.redIMul = function(j) {
        return _(this.red, "redMul works only with red numbers"), this.red._verify2(this, j), this.red.imul(this, j);
      }, O.prototype.redSqr = function() {
        return _(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, O.prototype.redISqr = function() {
        return _(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, O.prototype.redSqrt = function() {
        return _(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, O.prototype.redInvm = function() {
        return _(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, O.prototype.redNeg = function() {
        return _(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, O.prototype.redPow = function(j) {
        return _(this.red && !j.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, j);
      };
      var b = { k256: null, p224: null, p192: null, p25519: null };
      function y(j, H) {
        this.name = j, this.p = new O(H, 16), this.n = this.p.bitLength(), this.k = new O(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      __name(y, "y");
      y.prototype._tmp = function() {
        var j = new O(null);
        return j.words = Array(Math.ceil(this.n / 13)), j;
      }, y.prototype.ireduce = function(j) {
        var H = j, Z;
        do
          this.split(H, this.tmp), H = this.imulK(H), H = H.iadd(this.tmp), Z = H.bitLength();
        while (Z > this.n);
        var W = Z < this.n ? -1 : H.ucmp(this.p);
        if (W === 0) H.words[0] = 0, H.length = 1;
        else if (W > 0) H.isub(this.p);
        else if (H.strip !== void 0) H.strip();
        else H._strip();
        return H;
      }, y.prototype.split = function(j, H) {
        j.iushrn(this.n, 0, H);
      }, y.prototype.imulK = function(j) {
        return j.imul(this.k);
      };
      function p() {
        y.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
      }
      __name(p, "p");
      Y(p, y), p.prototype.split = function(j, H) {
        var Z = 4194303, W = Math.min(j.length, 9);
        for (var w = 0; w < W; w++) H.words[w] = j.words[w];
        if (H.length = W, j.length <= 9) {
          j.words[0] = 0, j.length = 1;
          return;
        }
        var G = j.words[9];
        H.words[H.length++] = G & Z;
        for (w = 10; w < j.length; w++) {
          var S = j.words[w] | 0;
          j.words[w - 10] = (S & Z) << 4 | G >>> 22, G = S;
        }
        if (G >>>= 22, j.words[w - 10] = G, G === 0 && j.length > 10) j.length -= 10;
        else j.length -= 9;
      }, p.prototype.imulK = function(j) {
        j.words[j.length] = 0, j.words[j.length + 1] = 0, j.length += 2;
        var H = 0;
        for (var Z = 0; Z < j.length; Z++) {
          var W = j.words[Z] | 0;
          H += W * 977, j.words[Z] = H & 67108863, H = W * 64 + (H / 67108864 | 0);
        }
        if (j.words[j.length - 1] === 0) {
          if (j.length--, j.words[j.length - 1] === 0) j.length--;
        }
        return j;
      };
      function n() {
        y.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
      }
      __name(n, "n");
      Y(n, y);
      function s() {
        y.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
      }
      __name(s, "s");
      Y(s, y);
      function q$() {
        y.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
      }
      __name(q$, "q$");
      Y(q$, y), q$.prototype.imulK = function(j) {
        var H = 0;
        for (var Z = 0; Z < j.length; Z++) {
          var W = (j.words[Z] | 0) * 19 + H, w = W & 67108863;
          W >>>= 26, j.words[Z] = w, H = W;
        }
        if (H !== 0) j.words[j.length++] = H;
        return j;
      }, O._prime = function(j) {
        if (b[j]) return b[j];
        var H;
        if (j === "k256") H = new p();
        else if (j === "p224") H = new n();
        else if (j === "p192") H = new s();
        else if (j === "p25519") H = new q$();
        else throw Error("Unknown prime " + j);
        return b[j] = H, H;
      };
      function c(j) {
        if (typeof j === "string") {
          var H = O._prime(j);
          this.m = H.p, this.prime = H;
        } else _(j.gtn(1), "modulus must be greater than 1"), this.m = j, this.prime = null;
      }
      __name(c, "c");
      c.prototype._verify1 = function(j) {
        _(j.negative === 0, "red works only with positives"), _(j.red, "red works only with red numbers");
      }, c.prototype._verify2 = function(j, H) {
        _((j.negative | H.negative) === 0, "red works only with positives"), _(j.red && j.red === H.red, "red works only with red numbers");
      }, c.prototype.imod = function(j) {
        if (this.prime) return this.prime.ireduce(j)._forceRed(this);
        return j.umod(this.m)._forceRed(this);
      }, c.prototype.neg = function(j) {
        if (j.isZero()) return j.clone();
        return this.m.sub(j)._forceRed(this);
      }, c.prototype.add = function(j, H) {
        this._verify2(j, H);
        var Z = j.add(H);
        if (Z.cmp(this.m) >= 0) Z.isub(this.m);
        return Z._forceRed(this);
      }, c.prototype.iadd = function(j, H) {
        this._verify2(j, H);
        var Z = j.iadd(H);
        if (Z.cmp(this.m) >= 0) Z.isub(this.m);
        return Z;
      }, c.prototype.sub = function(j, H) {
        this._verify2(j, H);
        var Z = j.sub(H);
        if (Z.cmpn(0) < 0) Z.iadd(this.m);
        return Z._forceRed(this);
      }, c.prototype.isub = function(j, H) {
        this._verify2(j, H);
        var Z = j.isub(H);
        if (Z.cmpn(0) < 0) Z.iadd(this.m);
        return Z;
      }, c.prototype.shl = function(j, H) {
        return this._verify1(j), this.imod(j.ushln(H));
      }, c.prototype.imul = function(j, H) {
        return this._verify2(j, H), this.imod(j.imul(H));
      }, c.prototype.mul = function(j, H) {
        return this._verify2(j, H), this.imod(j.mul(H));
      }, c.prototype.isqr = function(j) {
        return this.imul(j, j.clone());
      }, c.prototype.sqr = function(j) {
        return this.mul(j, j);
      }, c.prototype.sqrt = function(j) {
        if (j.isZero()) return j.clone();
        var H = this.m.andln(3);
        if (_(H % 2 === 1), H === 3) {
          var Z = this.m.add(new O(1)).iushrn(2);
          return this.pow(j, Z);
        }
        var W = this.m.subn(1), w = 0;
        while (!W.isZero() && W.andln(1) === 0) w++, W.iushrn(1);
        _(!W.isZero());
        var G = new O(1).toRed(this), S = G.redNeg(), A = this.m.subn(1).iushrn(1), v = this.m.bitLength();
        v = new O(2 * v * v).toRed(this);
        while (this.pow(v, A).cmp(S) !== 0) v.redIAdd(S);
        var k = this.pow(v, W), R = this.pow(j, W.addn(1).iushrn(1)), C = this.pow(j, W), L = w;
        while (C.cmp(G) !== 0) {
          var x = C;
          for (var l = 0; x.cmp(G) !== 0; l++) x = x.redSqr();
          _(l < L);
          var a = this.pow(k, new O(1).iushln(L - l - 1));
          R = R.redMul(a), k = a.redSqr(), C = C.redMul(k), L = l;
        }
        return R;
      }, c.prototype.invm = function(j) {
        var H = j._invmp(this.m);
        if (H.negative !== 0) return H.negative = 0, this.imod(H).redNeg();
        else return this.imod(H);
      }, c.prototype.pow = function(j, H) {
        if (H.isZero()) return new O(1).toRed(this);
        if (H.cmpn(1) === 0) return j.clone();
        var Z = 4, W = Array(1 << Z);
        W[0] = new O(1).toRed(this), W[1] = j;
        for (var w = 2; w < W.length; w++) W[w] = this.mul(W[w - 1], j);
        var G = W[0], S = 0, A = 0, v = H.bitLength() % 26;
        if (v === 0) v = 26;
        for (w = H.length - 1; w >= 0; w--) {
          var k = H.words[w];
          for (var R = v - 1; R >= 0; R--) {
            var C = k >> R & 1;
            if (G !== W[0]) G = this.sqr(G);
            if (C === 0 && S === 0) {
              A = 0;
              continue;
            }
            if (S <<= 1, S |= C, A++, A !== Z && (w !== 0 || R !== 0)) continue;
            G = this.mul(G, W[S]), A = 0, S = 0;
          }
          v = 26;
        }
        return G;
      }, c.prototype.convertTo = function(j) {
        var H = j.umod(this.m);
        return H === j ? H.clone() : H;
      }, c.prototype.convertFrom = function(j) {
        var H = j.clone();
        return H.red = null, H;
      }, O.mont = function(j) {
        return new U(j);
      };
      function U(j) {
        if (c.call(this, j), this.shift = this.m.bitLength(), this.shift % 26 !== 0) this.shift += 26 - this.shift % 26;
        this.r = new O(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      __name(U, "U");
      Y(U, c), U.prototype.convertTo = function(j) {
        return this.imod(j.ushln(this.shift));
      }, U.prototype.convertFrom = function(j) {
        var H = this.imod(j.mul(this.rinv));
        return H.red = null, H;
      }, U.prototype.imul = function(j, H) {
        if (j.isZero() || H.isZero()) return j.words[0] = 0, j.length = 1, j;
        var Z = j.imul(H), W = Z.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), w = Z.isub(W).iushrn(this.shift), G = w;
        if (w.cmp(this.m) >= 0) G = w.isub(this.m);
        else if (w.cmpn(0) < 0) G = w.iadd(this.m);
        return G._forceRed(this);
      }, U.prototype.mul = function(j, H) {
        if (j.isZero() || H.isZero()) return new O(0)._forceRed(this);
        var Z = j.mul(H), W = Z.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), w = Z.isub(W).iushrn(this.shift), G = w;
        if (w.cmp(this.m) >= 0) G = w.isub(this.m);
        else if (w.cmpn(0) < 0) G = w.iadd(this.m);
        return G._forceRed(this);
      }, U.prototype.invm = function(j) {
        var H = this.imod(j._invmp(this.m).mul(this.r2));
        return H._forceRed(this);
      };
    })(typeof q > "u" || q, $);
  }), K_ = r$(($, q) => {
    q.exports = K;
    function K(P, _) {
      if (!P) throw Error(_ || "Assertion failed");
    }
    __name(K, "K");
    K.equal = function(P, _, Y) {
      if (P != _) throw Error(Y || "Assertion failed: " + P + " != " + _);
    };
  }), z0 = r$(($) => {
    var q = $;
    function K(Y, O) {
      if (Array.isArray(Y)) return Y.slice();
      if (!Y) return [];
      var z = [];
      if (typeof Y !== "string") {
        for (var J = 0; J < Y.length; J++) z[J] = Y[J] | 0;
        return z;
      }
      if (O === "hex") {
        if (Y = Y.replace(/[^a-z0-9]+/ig, ""), Y.length % 2 !== 0) Y = "0" + Y;
        for (var J = 0; J < Y.length; J += 2) z.push(parseInt(Y[J] + Y[J + 1], 16));
      } else for (var J = 0; J < Y.length; J++) {
        var T = Y.charCodeAt(J), X = T >> 8, f = T & 255;
        if (X) z.push(X, f);
        else z.push(f);
      }
      return z;
    }
    __name(K, "K");
    q.toArray = K;
    function P(Y) {
      if (Y.length === 1) return "0" + Y;
      else return Y;
    }
    __name(P, "P");
    q.zero2 = P;
    function _(Y) {
      var O = "";
      for (var z = 0; z < Y.length; z++) O += P(Y[z].toString(16));
      return O;
    }
    __name(_, "_");
    q.toHex = _, q.encode = function(Y, O) {
      if (O === "hex") return _(Y);
      else return Y;
    };
  }), M8 = r$(($) => {
    var q = $, K = CK(), P = K_(), _ = z0();
    q.assert = P, q.toArray = _.toArray, q.zero2 = _.zero2, q.toHex = _.toHex, q.encode = _.encode;
    function Y(X, f, V) {
      var M = Array(Math.max(X.bitLength(), V) + 1), N;
      for (N = 0; N < M.length; N += 1) M[N] = 0;
      var E = 1 << f + 1, h = X.clone();
      for (N = 0; N < M.length; N++) {
        var I, D = h.andln(E - 1);
        if (h.isOdd()) {
          if (D > (E >> 1) - 1) I = (E >> 1) - D;
          else I = D;
          h.isubn(I);
        } else I = 0;
        M[N] = I, h.iushrn(1);
      }
      return M;
    }
    __name(Y, "Y");
    q.getNAF = Y;
    function O(X, f) {
      var V = [[], []];
      X = X.clone(), f = f.clone();
      var M = 0, N = 0, E;
      while (X.cmpn(-M) > 0 || f.cmpn(-N) > 0) {
        var h = X.andln(3) + M & 3, I = f.andln(3) + N & 3;
        if (h === 3) h = -1;
        if (I === 3) I = -1;
        var D;
        if ((h & 1) === 0) D = 0;
        else if (E = X.andln(7) + M & 7, (E === 3 || E === 5) && I === 2) D = -h;
        else D = h;
        V[0].push(D);
        var g;
        if ((I & 1) === 0) g = 0;
        else if (E = f.andln(7) + N & 7, (E === 3 || E === 5) && h === 2) g = -I;
        else g = I;
        if (V[1].push(g), 2 * M === D + 1) M = 1 - M;
        if (2 * N === g + 1) N = 1 - N;
        X.iushrn(1), f.iushrn(1);
      }
      return V;
    }
    __name(O, "O");
    q.getJSF = O;
    function z(X, f, V) {
      var M = "_" + f;
      X.prototype[f] = function() {
        return this[M] !== void 0 ? this[M] : this[M] = V.call(this);
      };
    }
    __name(z, "z");
    q.cachedProperty = z;
    function J(X) {
      return typeof X === "string" ? q.toArray(X, "hex") : X;
    }
    __name(J, "J");
    q.parseBytes = J;
    function T(X) {
      return new K(X, "hex", "le");
    }
    __name(T, "T");
    q.intFromLE = T;
  }), W0 = r$(($, q) => {
    var K;
    q.exports = function(Y) {
      if (!K) K = new P(null);
      return K.generate(Y);
    };
    function P(Y) {
      this.rand = Y;
    }
    __name(P, "P");
    if (q.exports.Rand = P, P.prototype.generate = function(Y) {
      return this._rand(Y);
    }, P.prototype._rand = function(Y) {
      if (this.rand.getBytes) return this.rand.getBytes(Y);
      var O = new Uint8Array(Y);
      for (var z = 0; z < O.length; z++) O[z] = this.rand.getByte();
      return O;
    }, typeof self === "object") {
      if (self.crypto && self.crypto.getRandomValues) P.prototype._rand = function(Y) {
        var O = new Uint8Array(Y);
        return self.crypto.getRandomValues(O), O;
      };
      else if (self.msCrypto && self.msCrypto.getRandomValues) P.prototype._rand = function(Y) {
        var O = new Uint8Array(Y);
        return self.msCrypto.getRandomValues(O), O;
      };
      else if (typeof window === "object") P.prototype._rand = function() {
        throw Error("Not implemented yet");
      };
    } else try {
      if (_ = (lq(), J6(dq)), typeof _.randomBytes !== "function") throw Error("Not supported");
      P.prototype._rand = function(Y) {
        return _.randomBytes(Y);
      };
    } catch (Y) {
    }
    var _;
  }), zO = r$(($, q) => {
    var K = CK(), P = M8(), _ = P.getNAF, Y = P.getJSF, O = P.assert;
    function z(T, X) {
      this.type = T, this.p = new K(X.p, 16), this.red = X.prime ? K.red(X.prime) : K.mont(this.p), this.zero = new K(0).toRed(this.red), this.one = new K(1).toRed(this.red), this.two = new K(2).toRed(this.red), this.n = X.n && new K(X.n, 16), this.g = X.g && this.pointFromJSON(X.g, X.gRed), this._wnafT1 = [, , , ,], this._wnafT2 = [, , , ,], this._wnafT3 = [, , , ,], this._wnafT4 = [, , , ,], this._bitLength = this.n ? this.n.bitLength() : 0;
      var f = this.n && this.p.div(this.n);
      if (!f || f.cmpn(100) > 0) this.redN = null;
      else this._maxwellTrick = true, this.redN = this.n.toRed(this.red);
    }
    __name(z, "z");
    q.exports = z, z.prototype.point = function() {
      throw Error("Not implemented");
    }, z.prototype.validate = function() {
      throw Error("Not implemented");
    }, z.prototype._fixedNafMul = function(T, X) {
      O(T.precomputed);
      var f = T._getDoubles(), V = _(X, 1, this._bitLength), M = (1 << f.step + 1) - (f.step % 2 === 0 ? 2 : 1);
      M /= 3;
      var N = [], E, h;
      for (E = 0; E < V.length; E += f.step) {
        h = 0;
        for (var I = E + f.step - 1; I >= E; I--) h = (h << 1) + V[I];
        N.push(h);
      }
      var D = this.jpoint(null, null, null), g = this.jpoint(null, null, null);
      for (var b = M; b > 0; b--) {
        for (E = 0; E < N.length; E++) if (h = N[E], h === b) g = g.mixedAdd(f.points[E]);
        else if (h === -b) g = g.mixedAdd(f.points[E].neg());
        D = D.add(g);
      }
      return D.toP();
    }, z.prototype._wnafMul = function(T, X) {
      var f = 4, V = T._getNAFPoints(f);
      f = V.wnd;
      var M = V.points, N = _(X, f, this._bitLength), E = this.jpoint(null, null, null);
      for (var h = N.length - 1; h >= 0; h--) {
        for (var I = 0; h >= 0 && N[h] === 0; h--) I++;
        if (h >= 0) I++;
        if (E = E.dblp(I), h < 0) break;
        var D = N[h];
        if (O(D !== 0), T.type === "affine") if (D > 0) E = E.mixedAdd(M[D - 1 >> 1]);
        else E = E.mixedAdd(M[-D - 1 >> 1].neg());
        else if (D > 0) E = E.add(M[D - 1 >> 1]);
        else E = E.add(M[-D - 1 >> 1].neg());
      }
      return T.type === "affine" ? E.toP() : E;
    }, z.prototype._wnafMulAdd = function(T, X, f, V, M) {
      var N = this._wnafT1, E = this._wnafT2, h = this._wnafT3, I = 0, D, g, b;
      for (D = 0; D < V; D++) {
        b = X[D];
        var y = b._getNAFPoints(T);
        N[D] = y.wnd, E[D] = y.points;
      }
      for (D = V - 1; D >= 1; D -= 2) {
        var p = D - 1, n = D;
        if (N[p] !== 1 || N[n] !== 1) {
          h[p] = _(f[p], N[p], this._bitLength), h[n] = _(f[n], N[n], this._bitLength), I = Math.max(h[p].length, I), I = Math.max(h[n].length, I);
          continue;
        }
        var s = [X[p], null, null, X[n]];
        if (X[p].y.cmp(X[n].y) === 0) s[1] = X[p].add(X[n]), s[2] = X[p].toJ().mixedAdd(X[n].neg());
        else if (X[p].y.cmp(X[n].y.redNeg()) === 0) s[1] = X[p].toJ().mixedAdd(X[n]), s[2] = X[p].add(X[n].neg());
        else s[1] = X[p].toJ().mixedAdd(X[n]), s[2] = X[p].toJ().mixedAdd(X[n].neg());
        var q$ = [-3, -1, -5, -7, 0, 7, 5, 1, 3], c = Y(f[p], f[n]);
        I = Math.max(c[0].length, I), h[p] = Array(I), h[n] = Array(I);
        for (g = 0; g < I; g++) {
          var U = c[0][g] | 0, j = c[1][g] | 0;
          h[p][g] = q$[(U + 1) * 3 + (j + 1)], h[n][g] = 0, E[p] = s;
        }
      }
      var H = this.jpoint(null, null, null), Z = this._wnafT4;
      for (D = I; D >= 0; D--) {
        var W = 0;
        while (D >= 0) {
          var w = true;
          for (g = 0; g < V; g++) if (Z[g] = h[g][D] | 0, Z[g] !== 0) w = false;
          if (!w) break;
          W++, D--;
        }
        if (D >= 0) W++;
        if (H = H.dblp(W), D < 0) break;
        for (g = 0; g < V; g++) {
          var G = Z[g];
          if (G === 0) continue;
          else if (G > 0) b = E[g][G - 1 >> 1];
          else if (G < 0) b = E[g][-G - 1 >> 1].neg();
          if (b.type === "affine") H = H.mixedAdd(b);
          else H = H.add(b);
        }
      }
      for (D = 0; D < V; D++) E[D] = null;
      if (M) return H;
      else return H.toP();
    };
    function J(T, X) {
      this.curve = T, this.type = X, this.precomputed = null;
    }
    __name(J, "J");
    z.BasePoint = J, J.prototype.eq = function() {
      throw Error("Not implemented");
    }, J.prototype.validate = function() {
      return this.curve.validate(this);
    }, z.prototype.decodePoint = function(T, X) {
      T = P.toArray(T, X);
      var f = this.p.byteLength();
      if ((T[0] === 4 || T[0] === 6 || T[0] === 7) && T.length - 1 === 2 * f) {
        if (T[0] === 6) O(T[T.length - 1] % 2 === 0);
        else if (T[0] === 7) O(T[T.length - 1] % 2 === 1);
        var V = this.point(T.slice(1, 1 + f), T.slice(1 + f, 1 + 2 * f));
        return V;
      } else if ((T[0] === 2 || T[0] === 3) && T.length - 1 === f) return this.pointFromX(T.slice(1, 1 + f), T[0] === 3);
      throw Error("Unknown point format");
    }, J.prototype.encodeCompressed = function(T) {
      return this.encode(T, true);
    }, J.prototype._encode = function(T) {
      var X = this.curve.p.byteLength(), f = this.getX().toArray("be", X);
      if (T) return [this.getY().isEven() ? 2 : 3].concat(f);
      return [4].concat(f, this.getY().toArray("be", X));
    }, J.prototype.encode = function(T, X) {
      return P.encode(this._encode(X), T);
    }, J.prototype.precompute = function(T) {
      if (this.precomputed) return this;
      var X = { doubles: null, naf: null, beta: null };
      return X.naf = this._getNAFPoints(8), X.doubles = this._getDoubles(4, T), X.beta = this._getBeta(), this.precomputed = X, this;
    }, J.prototype._hasDoubles = function(T) {
      if (!this.precomputed) return false;
      var X = this.precomputed.doubles;
      if (!X) return false;
      return X.points.length >= Math.ceil((T.bitLength() + 1) / X.step);
    }, J.prototype._getDoubles = function(T, X) {
      if (this.precomputed && this.precomputed.doubles) return this.precomputed.doubles;
      var f = [this], V = this;
      for (var M = 0; M < X; M += T) {
        for (var N = 0; N < T; N++) V = V.dbl();
        f.push(V);
      }
      return { step: T, points: f };
    }, J.prototype._getNAFPoints = function(T) {
      if (this.precomputed && this.precomputed.naf) return this.precomputed.naf;
      var X = [this], f = (1 << T) - 1, V = f === 1 ? null : this.dbl();
      for (var M = 1; M < f; M++) X[M] = X[M - 1].add(V);
      return { wnd: T, points: X };
    }, J.prototype._getBeta = function() {
      return null;
    }, J.prototype.dblp = function(T) {
      var X = this;
      for (var f = 0; f < T; f++) X = X.dbl();
      return X;
    };
  }), Ko = r$(($, q) => {
    if (typeof Object.create === "function") q.exports = function(K, P) {
      if (P) K.super_ = P, K.prototype = Object.create(P.prototype, { constructor: { value: K, enumerable: false, writable: true, configurable: true } });
    };
    else q.exports = function(K, P) {
      if (P) {
        K.super_ = P;
        var _ = /* @__PURE__ */ __name(function() {
        }, "_");
        _.prototype = P.prototype, K.prototype = new _(), K.prototype.constructor = K;
      }
    };
  }), z8 = r$(($, q) => {
    try {
      if (K = (yS(), J6(bS)), typeof K.inherits !== "function") throw "";
      q.exports = K.inherits;
    } catch (P) {
      q.exports = Ko();
    }
    var K;
  }), _o = r$(($, q) => {
    var K = M8(), P = CK(), _ = z8(), Y = zO(), O = K.assert;
    function z(X) {
      Y.call(this, "short", X), this.a = new P(X.a, 16).toRed(this.red), this.b = new P(X.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(X), this._endoWnafT1 = [, , , ,], this._endoWnafT2 = [, , , ,];
    }
    __name(z, "z");
    _(z, Y), q.exports = z, z.prototype._getEndomorphism = function(X) {
      if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1) return;
      var f, V;
      if (X.beta) f = new P(X.beta, 16).toRed(this.red);
      else {
        var M = this._getEndoRoots(this.p);
        f = M[0].cmp(M[1]) < 0 ? M[0] : M[1], f = f.toRed(this.red);
      }
      if (X.lambda) V = new P(X.lambda, 16);
      else {
        var N = this._getEndoRoots(this.n);
        if (this.g.mul(N[0]).x.cmp(this.g.x.redMul(f)) === 0) V = N[0];
        else V = N[1], O(this.g.mul(V).x.cmp(this.g.x.redMul(f)) === 0);
      }
      var E;
      if (X.basis) E = X.basis.map(function(h) {
        return { a: new P(h.a, 16), b: new P(h.b, 16) };
      });
      else E = this._getEndoBasis(V);
      return { beta: f, lambda: V, basis: E };
    }, z.prototype._getEndoRoots = function(X) {
      var f = X === this.p ? this.red : P.mont(X), V = new P(2).toRed(f).redInvm(), M = V.redNeg(), N = new P(3).toRed(f).redNeg().redSqrt().redMul(V), E = M.redAdd(N).fromRed(), h = M.redSub(N).fromRed();
      return [E, h];
    }, z.prototype._getEndoBasis = function(X) {
      var f = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), V = X, M = this.n.clone(), N = new P(1), E = new P(0), h = new P(0), I = new P(1), D, g, b, y, p, n, s, q$ = 0, c, U;
      while (V.cmpn(0) !== 0) {
        var j = M.div(V);
        c = M.sub(j.mul(V)), U = h.sub(j.mul(N));
        var H = I.sub(j.mul(E));
        if (!b && c.cmp(f) < 0) D = s.neg(), g = N, b = c.neg(), y = U;
        else if (b && ++q$ === 2) break;
        s = c, M = V, V = c, h = N, N = U, I = E, E = H;
      }
      p = c.neg(), n = U;
      var Z = b.sqr().add(y.sqr()), W = p.sqr().add(n.sqr());
      if (W.cmp(Z) >= 0) p = D, n = g;
      if (b.negative) b = b.neg(), y = y.neg();
      if (p.negative) p = p.neg(), n = n.neg();
      return [{ a: b, b: y }, { a: p, b: n }];
    }, z.prototype._endoSplit = function(X) {
      var f = this.endo.basis, V = f[0], M = f[1], N = M.b.mul(X).divRound(this.n), E = V.b.neg().mul(X).divRound(this.n), h = N.mul(V.a), I = E.mul(M.a), D = N.mul(V.b), g = E.mul(M.b), b = X.sub(h).sub(I), y = D.add(g).neg();
      return { k1: b, k2: y };
    }, z.prototype.pointFromX = function(X, f) {
      if (X = new P(X, 16), !X.red) X = X.toRed(this.red);
      var V = X.redSqr().redMul(X).redIAdd(X.redMul(this.a)).redIAdd(this.b), M = V.redSqrt();
      if (M.redSqr().redSub(V).cmp(this.zero) !== 0) throw Error("invalid point");
      var N = M.fromRed().isOdd();
      if (f && !N || !f && N) M = M.redNeg();
      return this.point(X, M);
    }, z.prototype.validate = function(X) {
      if (X.inf) return true;
      var { x: f, y: V } = X, M = this.a.redMul(f), N = f.redSqr().redMul(f).redIAdd(M).redIAdd(this.b);
      return V.redSqr().redISub(N).cmpn(0) === 0;
    }, z.prototype._endoWnafMulAdd = function(X, f, V) {
      var M = this._endoWnafT1, N = this._endoWnafT2;
      for (var E = 0; E < X.length; E++) {
        var h = this._endoSplit(f[E]), I = X[E], D = I._getBeta();
        if (h.k1.negative) h.k1.ineg(), I = I.neg(true);
        if (h.k2.negative) h.k2.ineg(), D = D.neg(true);
        M[E * 2] = I, M[E * 2 + 1] = D, N[E * 2] = h.k1, N[E * 2 + 1] = h.k2;
      }
      var g = this._wnafMulAdd(1, M, N, E * 2, V);
      for (var b = 0; b < E * 2; b++) M[b] = null, N[b] = null;
      return g;
    };
    function J(X, f, V, M) {
      if (Y.BasePoint.call(this, X, "affine"), f === null && V === null) this.x = null, this.y = null, this.inf = true;
      else {
        if (this.x = new P(f, 16), this.y = new P(V, 16), M) this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red);
        if (!this.x.red) this.x = this.x.toRed(this.curve.red);
        if (!this.y.red) this.y = this.y.toRed(this.curve.red);
        this.inf = false;
      }
    }
    __name(J, "J");
    _(J, Y.BasePoint), z.prototype.point = function(X, f, V) {
      return new J(this, X, f, V);
    }, z.prototype.pointFromJSON = function(X, f) {
      return J.fromJSON(this, X, f);
    }, J.prototype._getBeta = function() {
      if (!this.curve.endo) return;
      var X = this.precomputed;
      if (X && X.beta) return X.beta;
      var f = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
      if (X) {
        var V = this.curve, M = /* @__PURE__ */ __name(function(N) {
          return V.point(N.x.redMul(V.endo.beta), N.y);
        }, "M");
        X.beta = f, f.precomputed = { beta: null, naf: X.naf && { wnd: X.naf.wnd, points: X.naf.points.map(M) }, doubles: X.doubles && { step: X.doubles.step, points: X.doubles.points.map(M) } };
      }
      return f;
    }, J.prototype.toJSON = function() {
      if (!this.precomputed) return [this.x, this.y];
      return [this.x, this.y, this.precomputed && { doubles: this.precomputed.doubles && { step: this.precomputed.doubles.step, points: this.precomputed.doubles.points.slice(1) }, naf: this.precomputed.naf && { wnd: this.precomputed.naf.wnd, points: this.precomputed.naf.points.slice(1) } }];
    }, J.fromJSON = function(X, f, V) {
      if (typeof f === "string") f = JSON.parse(f);
      var M = X.point(f[0], f[1], V);
      if (!f[2]) return M;
      function N(h) {
        return X.point(h[0], h[1], V);
      }
      __name(N, "N");
      var E = f[2];
      return M.precomputed = { beta: null, doubles: E.doubles && { step: E.doubles.step, points: [M].concat(E.doubles.points.map(N)) }, naf: E.naf && { wnd: E.naf.wnd, points: [M].concat(E.naf.points.map(N)) } }, M;
    }, J.prototype.inspect = function() {
      if (this.isInfinity()) return "<EC Point Infinity>";
      return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
    }, J.prototype.isInfinity = function() {
      return this.inf;
    }, J.prototype.add = function(X) {
      if (this.inf) return X;
      if (X.inf) return this;
      if (this.eq(X)) return this.dbl();
      if (this.neg().eq(X)) return this.curve.point(null, null);
      if (this.x.cmp(X.x) === 0) return this.curve.point(null, null);
      var f = this.y.redSub(X.y);
      if (f.cmpn(0) !== 0) f = f.redMul(this.x.redSub(X.x).redInvm());
      var V = f.redSqr().redISub(this.x).redISub(X.x), M = f.redMul(this.x.redSub(V)).redISub(this.y);
      return this.curve.point(V, M);
    }, J.prototype.dbl = function() {
      if (this.inf) return this;
      var X = this.y.redAdd(this.y);
      if (X.cmpn(0) === 0) return this.curve.point(null, null);
      var f = this.curve.a, V = this.x.redSqr(), M = X.redInvm(), N = V.redAdd(V).redIAdd(V).redIAdd(f).redMul(M), E = N.redSqr().redISub(this.x.redAdd(this.x)), h = N.redMul(this.x.redSub(E)).redISub(this.y);
      return this.curve.point(E, h);
    }, J.prototype.getX = function() {
      return this.x.fromRed();
    }, J.prototype.getY = function() {
      return this.y.fromRed();
    }, J.prototype.mul = function(X) {
      if (X = new P(X, 16), this.isInfinity()) return this;
      else if (this._hasDoubles(X)) return this.curve._fixedNafMul(this, X);
      else if (this.curve.endo) return this.curve._endoWnafMulAdd([this], [X]);
      else return this.curve._wnafMul(this, X);
    }, J.prototype.mulAdd = function(X, f, V) {
      var M = [this, f], N = [X, V];
      if (this.curve.endo) return this.curve._endoWnafMulAdd(M, N);
      else return this.curve._wnafMulAdd(1, M, N, 2);
    }, J.prototype.jmulAdd = function(X, f, V) {
      var M = [this, f], N = [X, V];
      if (this.curve.endo) return this.curve._endoWnafMulAdd(M, N, true);
      else return this.curve._wnafMulAdd(1, M, N, 2, true);
    }, J.prototype.eq = function(X) {
      return this === X || this.inf === X.inf && (this.inf || this.x.cmp(X.x) === 0 && this.y.cmp(X.y) === 0);
    }, J.prototype.neg = function(X) {
      if (this.inf) return this;
      var f = this.curve.point(this.x, this.y.redNeg());
      if (X && this.precomputed) {
        var V = this.precomputed, M = /* @__PURE__ */ __name(function(N) {
          return N.neg();
        }, "M");
        f.precomputed = { naf: V.naf && { wnd: V.naf.wnd, points: V.naf.points.map(M) }, doubles: V.doubles && { step: V.doubles.step, points: V.doubles.points.map(M) } };
      }
      return f;
    }, J.prototype.toJ = function() {
      if (this.inf) return this.curve.jpoint(null, null, null);
      var X = this.curve.jpoint(this.x, this.y, this.curve.one);
      return X;
    };
    function T(X, f, V, M) {
      if (Y.BasePoint.call(this, X, "jacobian"), f === null && V === null && M === null) this.x = this.curve.one, this.y = this.curve.one, this.z = new P(0);
      else this.x = new P(f, 16), this.y = new P(V, 16), this.z = new P(M, 16);
      if (!this.x.red) this.x = this.x.toRed(this.curve.red);
      if (!this.y.red) this.y = this.y.toRed(this.curve.red);
      if (!this.z.red) this.z = this.z.toRed(this.curve.red);
      this.zOne = this.z === this.curve.one;
    }
    __name(T, "T");
    _(T, Y.BasePoint), z.prototype.jpoint = function(X, f, V) {
      return new T(this, X, f, V);
    }, T.prototype.toP = function() {
      if (this.isInfinity()) return this.curve.point(null, null);
      var X = this.z.redInvm(), f = X.redSqr(), V = this.x.redMul(f), M = this.y.redMul(f).redMul(X);
      return this.curve.point(V, M);
    }, T.prototype.neg = function() {
      return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
    }, T.prototype.add = function(X) {
      if (this.isInfinity()) return X;
      if (X.isInfinity()) return this;
      var f = X.z.redSqr(), V = this.z.redSqr(), M = this.x.redMul(f), N = X.x.redMul(V), E = this.y.redMul(f.redMul(X.z)), h = X.y.redMul(V.redMul(this.z)), I = M.redSub(N), D = E.redSub(h);
      if (I.cmpn(0) === 0) if (D.cmpn(0) !== 0) return this.curve.jpoint(null, null, null);
      else return this.dbl();
      var g = I.redSqr(), b = g.redMul(I), y = M.redMul(g), p = D.redSqr().redIAdd(b).redISub(y).redISub(y), n = D.redMul(y.redISub(p)).redISub(E.redMul(b)), s = this.z.redMul(X.z).redMul(I);
      return this.curve.jpoint(p, n, s);
    }, T.prototype.mixedAdd = function(X) {
      if (this.isInfinity()) return X.toJ();
      if (X.isInfinity()) return this;
      var f = this.z.redSqr(), V = this.x, M = X.x.redMul(f), N = this.y, E = X.y.redMul(f).redMul(this.z), h = V.redSub(M), I = N.redSub(E);
      if (h.cmpn(0) === 0) if (I.cmpn(0) !== 0) return this.curve.jpoint(null, null, null);
      else return this.dbl();
      var D = h.redSqr(), g = D.redMul(h), b = V.redMul(D), y = I.redSqr().redIAdd(g).redISub(b).redISub(b), p = I.redMul(b.redISub(y)).redISub(N.redMul(g)), n = this.z.redMul(h);
      return this.curve.jpoint(y, p, n);
    }, T.prototype.dblp = function(X) {
      if (X === 0) return this;
      if (this.isInfinity()) return this;
      if (!X) return this.dbl();
      var f;
      if (this.curve.zeroA || this.curve.threeA) {
        var V = this;
        for (f = 0; f < X; f++) V = V.dbl();
        return V;
      }
      var M = this.curve.a, N = this.curve.tinv, E = this.x, h = this.y, I = this.z, D = I.redSqr().redSqr(), g = h.redAdd(h);
      for (f = 0; f < X; f++) {
        var b = E.redSqr(), y = g.redSqr(), p = y.redSqr(), n = b.redAdd(b).redIAdd(b).redIAdd(M.redMul(D)), s = E.redMul(y), q$ = n.redSqr().redISub(s.redAdd(s)), c = s.redISub(q$), U = n.redMul(c);
        U = U.redIAdd(U).redISub(p);
        var j = g.redMul(I);
        if (f + 1 < X) D = D.redMul(p);
        E = q$, I = j, g = U;
      }
      return this.curve.jpoint(E, g.redMul(N), I);
    }, T.prototype.dbl = function() {
      if (this.isInfinity()) return this;
      if (this.curve.zeroA) return this._zeroDbl();
      else if (this.curve.threeA) return this._threeDbl();
      else return this._dbl();
    }, T.prototype._zeroDbl = function() {
      var X, f, V;
      if (this.zOne) {
        var M = this.x.redSqr(), N = this.y.redSqr(), E = N.redSqr(), h = this.x.redAdd(N).redSqr().redISub(M).redISub(E);
        h = h.redIAdd(h);
        var I = M.redAdd(M).redIAdd(M), D = I.redSqr().redISub(h).redISub(h), g = E.redIAdd(E);
        g = g.redIAdd(g), g = g.redIAdd(g), X = D, f = I.redMul(h.redISub(D)).redISub(g), V = this.y.redAdd(this.y);
      } else {
        var b = this.x.redSqr(), y = this.y.redSqr(), p = y.redSqr(), n = this.x.redAdd(y).redSqr().redISub(b).redISub(p);
        n = n.redIAdd(n);
        var s = b.redAdd(b).redIAdd(b), q$ = s.redSqr(), c = p.redIAdd(p);
        c = c.redIAdd(c), c = c.redIAdd(c), X = q$.redISub(n).redISub(n), f = s.redMul(n.redISub(X)).redISub(c), V = this.y.redMul(this.z), V = V.redIAdd(V);
      }
      return this.curve.jpoint(X, f, V);
    }, T.prototype._threeDbl = function() {
      var X, f, V;
      if (this.zOne) {
        var M = this.x.redSqr(), N = this.y.redSqr(), E = N.redSqr(), h = this.x.redAdd(N).redSqr().redISub(M).redISub(E);
        h = h.redIAdd(h);
        var I = M.redAdd(M).redIAdd(M).redIAdd(this.curve.a), D = I.redSqr().redISub(h).redISub(h);
        X = D;
        var g = E.redIAdd(E);
        g = g.redIAdd(g), g = g.redIAdd(g), f = I.redMul(h.redISub(D)).redISub(g), V = this.y.redAdd(this.y);
      } else {
        var b = this.z.redSqr(), y = this.y.redSqr(), p = this.x.redMul(y), n = this.x.redSub(b).redMul(this.x.redAdd(b));
        n = n.redAdd(n).redIAdd(n);
        var s = p.redIAdd(p);
        s = s.redIAdd(s);
        var q$ = s.redAdd(s);
        X = n.redSqr().redISub(q$), V = this.y.redAdd(this.z).redSqr().redISub(y).redISub(b);
        var c = y.redSqr();
        c = c.redIAdd(c), c = c.redIAdd(c), c = c.redIAdd(c), f = n.redMul(s.redISub(X)).redISub(c);
      }
      return this.curve.jpoint(X, f, V);
    }, T.prototype._dbl = function() {
      var X = this.curve.a, f = this.x, V = this.y, M = this.z, N = M.redSqr().redSqr(), E = f.redSqr(), h = V.redSqr(), I = E.redAdd(E).redIAdd(E).redIAdd(X.redMul(N)), D = f.redAdd(f);
      D = D.redIAdd(D);
      var g = D.redMul(h), b = I.redSqr().redISub(g.redAdd(g)), y = g.redISub(b), p = h.redSqr();
      p = p.redIAdd(p), p = p.redIAdd(p), p = p.redIAdd(p);
      var n = I.redMul(y).redISub(p), s = V.redAdd(V).redMul(M);
      return this.curve.jpoint(b, n, s);
    }, T.prototype.trpl = function() {
      if (!this.curve.zeroA) return this.dbl().add(this);
      var X = this.x.redSqr(), f = this.y.redSqr(), V = this.z.redSqr(), M = f.redSqr(), N = X.redAdd(X).redIAdd(X), E = N.redSqr(), h = this.x.redAdd(f).redSqr().redISub(X).redISub(M);
      h = h.redIAdd(h), h = h.redAdd(h).redIAdd(h), h = h.redISub(E);
      var I = h.redSqr(), D = M.redIAdd(M);
      D = D.redIAdd(D), D = D.redIAdd(D), D = D.redIAdd(D);
      var g = N.redIAdd(h).redSqr().redISub(E).redISub(I).redISub(D), b = f.redMul(g);
      b = b.redIAdd(b), b = b.redIAdd(b);
      var y = this.x.redMul(I).redISub(b);
      y = y.redIAdd(y), y = y.redIAdd(y);
      var p = this.y.redMul(g.redMul(D.redISub(g)).redISub(h.redMul(I)));
      p = p.redIAdd(p), p = p.redIAdd(p), p = p.redIAdd(p);
      var n = this.z.redAdd(h).redSqr().redISub(V).redISub(I);
      return this.curve.jpoint(y, p, n);
    }, T.prototype.mul = function(X, f) {
      return X = new P(X, f), this.curve._wnafMul(this, X);
    }, T.prototype.eq = function(X) {
      if (X.type === "affine") return this.eq(X.toJ());
      if (this === X) return true;
      var f = this.z.redSqr(), V = X.z.redSqr();
      if (this.x.redMul(V).redISub(X.x.redMul(f)).cmpn(0) !== 0) return false;
      var M = f.redMul(this.z), N = V.redMul(X.z);
      return this.y.redMul(N).redISub(X.y.redMul(M)).cmpn(0) === 0;
    }, T.prototype.eqXToP = function(X) {
      var f = this.z.redSqr(), V = X.toRed(this.curve.red).redMul(f);
      if (this.x.cmp(V) === 0) return true;
      var M = X.clone(), N = this.curve.redN.redMul(f);
      for (; ; ) {
        if (M.iadd(this.curve.n), M.cmp(this.curve.p) >= 0) return false;
        if (V.redIAdd(N), this.x.cmp(V) === 0) return true;
      }
    }, T.prototype.inspect = function() {
      if (this.isInfinity()) return "<EC JPoint Infinity>";
      return "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
    }, T.prototype.isInfinity = function() {
      return this.z.cmpn(0) === 0;
    };
  }), Po = r$(($, q) => {
    var K = CK(), P = z8(), _ = zO(), Y = M8();
    function O(J) {
      _.call(this, "mont", J), this.a = new K(J.a, 16).toRed(this.red), this.b = new K(J.b, 16).toRed(this.red), this.i4 = new K(4).toRed(this.red).redInvm(), this.two = new K(2).toRed(this.red), this.a24 = this.i4.redMul(this.a.redAdd(this.two));
    }
    __name(O, "O");
    P(O, _), q.exports = O, O.prototype.validate = function(J) {
      var T = J.normalize().x, X = T.redSqr(), f = X.redMul(T).redAdd(X.redMul(this.a)).redAdd(T), V = f.redSqrt();
      return V.redSqr().cmp(f) === 0;
    };
    function z(J, T, X) {
      if (_.BasePoint.call(this, J, "projective"), T === null && X === null) this.x = this.curve.one, this.z = this.curve.zero;
      else {
        if (this.x = new K(T, 16), this.z = new K(X, 16), !this.x.red) this.x = this.x.toRed(this.curve.red);
        if (!this.z.red) this.z = this.z.toRed(this.curve.red);
      }
    }
    __name(z, "z");
    P(z, _.BasePoint), O.prototype.decodePoint = function(J, T) {
      return this.point(Y.toArray(J, T), 1);
    }, O.prototype.point = function(J, T) {
      return new z(this, J, T);
    }, O.prototype.pointFromJSON = function(J) {
      return z.fromJSON(this, J);
    }, z.prototype.precompute = function() {
    }, z.prototype._encode = function() {
      return this.getX().toArray("be", this.curve.p.byteLength());
    }, z.fromJSON = function(J, T) {
      return new z(J, T[0], T[1] || J.one);
    }, z.prototype.inspect = function() {
      if (this.isInfinity()) return "<EC Point Infinity>";
      return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
    }, z.prototype.isInfinity = function() {
      return this.z.cmpn(0) === 0;
    }, z.prototype.dbl = function() {
      var J = this.x.redAdd(this.z), T = J.redSqr(), X = this.x.redSub(this.z), f = X.redSqr(), V = T.redSub(f), M = T.redMul(f), N = V.redMul(f.redAdd(this.curve.a24.redMul(V)));
      return this.curve.point(M, N);
    }, z.prototype.add = function() {
      throw Error("Not supported on Montgomery curve");
    }, z.prototype.diffAdd = function(J, T) {
      var X = this.x.redAdd(this.z), f = this.x.redSub(this.z), V = J.x.redAdd(J.z), M = J.x.redSub(J.z), N = M.redMul(X), E = V.redMul(f), h = T.z.redMul(N.redAdd(E).redSqr()), I = T.x.redMul(N.redISub(E).redSqr());
      return this.curve.point(h, I);
    }, z.prototype.mul = function(J) {
      var T = J.clone(), X = this, f = this.curve.point(null, null), V = this;
      for (var M = []; T.cmpn(0) !== 0; T.iushrn(1)) M.push(T.andln(1));
      for (var N = M.length - 1; N >= 0; N--) if (M[N] === 0) X = X.diffAdd(f, V), f = f.dbl();
      else f = X.diffAdd(f, V), X = X.dbl();
      return f;
    }, z.prototype.mulAdd = function() {
      throw Error("Not supported on Montgomery curve");
    }, z.prototype.jumlAdd = function() {
      throw Error("Not supported on Montgomery curve");
    }, z.prototype.eq = function(J) {
      return this.getX().cmp(J.getX()) === 0;
    }, z.prototype.normalize = function() {
      return this.x = this.x.redMul(this.z.redInvm()), this.z = this.curve.one, this;
    }, z.prototype.getX = function() {
      return this.normalize(), this.x.fromRed();
    };
  }), Oo = r$(($, q) => {
    var K = M8(), P = CK(), _ = z8(), Y = zO(), O = K.assert;
    function z(T) {
      this.twisted = (T.a | 0) !== 1, this.mOneA = this.twisted && (T.a | 0) === -1, this.extended = this.mOneA, Y.call(this, "edwards", T), this.a = new P(T.a, 16).umod(this.red.m), this.a = this.a.toRed(this.red), this.c = new P(T.c, 16).toRed(this.red), this.c2 = this.c.redSqr(), this.d = new P(T.d, 16).toRed(this.red), this.dd = this.d.redAdd(this.d), O(!this.twisted || this.c.fromRed().cmpn(1) === 0), this.oneC = (T.c | 0) === 1;
    }
    __name(z, "z");
    _(z, Y), q.exports = z, z.prototype._mulA = function(T) {
      if (this.mOneA) return T.redNeg();
      else return this.a.redMul(T);
    }, z.prototype._mulC = function(T) {
      if (this.oneC) return T;
      else return this.c.redMul(T);
    }, z.prototype.jpoint = function(T, X, f, V) {
      return this.point(T, X, f, V);
    }, z.prototype.pointFromX = function(T, X) {
      if (T = new P(T, 16), !T.red) T = T.toRed(this.red);
      var f = T.redSqr(), V = this.c2.redSub(this.a.redMul(f)), M = this.one.redSub(this.c2.redMul(this.d).redMul(f)), N = V.redMul(M.redInvm()), E = N.redSqrt();
      if (E.redSqr().redSub(N).cmp(this.zero) !== 0) throw Error("invalid point");
      var h = E.fromRed().isOdd();
      if (X && !h || !X && h) E = E.redNeg();
      return this.point(T, E);
    }, z.prototype.pointFromY = function(T, X) {
      if (T = new P(T, 16), !T.red) T = T.toRed(this.red);
      var f = T.redSqr(), V = f.redSub(this.c2), M = f.redMul(this.d).redMul(this.c2).redSub(this.a), N = V.redMul(M.redInvm());
      if (N.cmp(this.zero) === 0) if (X) throw Error("invalid point");
      else return this.point(this.zero, T);
      var E = N.redSqrt();
      if (E.redSqr().redSub(N).cmp(this.zero) !== 0) throw Error("invalid point");
      if (E.fromRed().isOdd() !== X) E = E.redNeg();
      return this.point(E, T);
    }, z.prototype.validate = function(T) {
      if (T.isInfinity()) return true;
      T.normalize();
      var X = T.x.redSqr(), f = T.y.redSqr(), V = X.redMul(this.a).redAdd(f), M = this.c2.redMul(this.one.redAdd(this.d.redMul(X).redMul(f)));
      return V.cmp(M) === 0;
    };
    function J(T, X, f, V, M) {
      if (Y.BasePoint.call(this, T, "projective"), X === null && f === null && V === null) this.x = this.curve.zero, this.y = this.curve.one, this.z = this.curve.one, this.t = this.curve.zero, this.zOne = true;
      else {
        if (this.x = new P(X, 16), this.y = new P(f, 16), this.z = V ? new P(V, 16) : this.curve.one, this.t = M && new P(M, 16), !this.x.red) this.x = this.x.toRed(this.curve.red);
        if (!this.y.red) this.y = this.y.toRed(this.curve.red);
        if (!this.z.red) this.z = this.z.toRed(this.curve.red);
        if (this.t && !this.t.red) this.t = this.t.toRed(this.curve.red);
        if (this.zOne = this.z === this.curve.one, this.curve.extended && !this.t) {
          if (this.t = this.x.redMul(this.y), !this.zOne) this.t = this.t.redMul(this.z.redInvm());
        }
      }
    }
    __name(J, "J");
    _(J, Y.BasePoint), z.prototype.pointFromJSON = function(T) {
      return J.fromJSON(this, T);
    }, z.prototype.point = function(T, X, f, V) {
      return new J(this, T, X, f, V);
    }, J.fromJSON = function(T, X) {
      return new J(T, X[0], X[1], X[2]);
    }, J.prototype.inspect = function() {
      if (this.isInfinity()) return "<EC Point Infinity>";
      return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
    }, J.prototype.isInfinity = function() {
      return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
    }, J.prototype._extDbl = function() {
      var T = this.x.redSqr(), X = this.y.redSqr(), f = this.z.redSqr();
      f = f.redIAdd(f);
      var V = this.curve._mulA(T), M = this.x.redAdd(this.y).redSqr().redISub(T).redISub(X), N = V.redAdd(X), E = N.redSub(f), h = V.redSub(X), I = M.redMul(E), D = N.redMul(h), g = M.redMul(h), b = E.redMul(N);
      return this.curve.point(I, D, b, g);
    }, J.prototype._projDbl = function() {
      var T = this.x.redAdd(this.y).redSqr(), X = this.x.redSqr(), f = this.y.redSqr(), V, M, N, E, h, I;
      if (this.curve.twisted) {
        E = this.curve._mulA(X);
        var D = E.redAdd(f);
        if (this.zOne) V = T.redSub(X).redSub(f).redMul(D.redSub(this.curve.two)), M = D.redMul(E.redSub(f)), N = D.redSqr().redSub(D).redSub(D);
        else h = this.z.redSqr(), I = D.redSub(h).redISub(h), V = T.redSub(X).redISub(f).redMul(I), M = D.redMul(E.redSub(f)), N = D.redMul(I);
      } else E = X.redAdd(f), h = this.curve._mulC(this.z).redSqr(), I = E.redSub(h).redSub(h), V = this.curve._mulC(T.redISub(E)).redMul(I), M = this.curve._mulC(E).redMul(X.redISub(f)), N = E.redMul(I);
      return this.curve.point(V, M, N);
    }, J.prototype.dbl = function() {
      if (this.isInfinity()) return this;
      if (this.curve.extended) return this._extDbl();
      else return this._projDbl();
    }, J.prototype._extAdd = function(T) {
      var X = this.y.redSub(this.x).redMul(T.y.redSub(T.x)), f = this.y.redAdd(this.x).redMul(T.y.redAdd(T.x)), V = this.t.redMul(this.curve.dd).redMul(T.t), M = this.z.redMul(T.z.redAdd(T.z)), N = f.redSub(X), E = M.redSub(V), h = M.redAdd(V), I = f.redAdd(X), D = N.redMul(E), g = h.redMul(I), b = N.redMul(I), y = E.redMul(h);
      return this.curve.point(D, g, y, b);
    }, J.prototype._projAdd = function(T) {
      var X = this.z.redMul(T.z), f = X.redSqr(), V = this.x.redMul(T.x), M = this.y.redMul(T.y), N = this.curve.d.redMul(V).redMul(M), E = f.redSub(N), h = f.redAdd(N), I = this.x.redAdd(this.y).redMul(T.x.redAdd(T.y)).redISub(V).redISub(M), D = X.redMul(E).redMul(I), g, b;
      if (this.curve.twisted) g = X.redMul(h).redMul(M.redSub(this.curve._mulA(V))), b = E.redMul(h);
      else g = X.redMul(h).redMul(M.redSub(V)), b = this.curve._mulC(E).redMul(h);
      return this.curve.point(D, g, b);
    }, J.prototype.add = function(T) {
      if (this.isInfinity()) return T;
      if (T.isInfinity()) return this;
      if (this.curve.extended) return this._extAdd(T);
      else return this._projAdd(T);
    }, J.prototype.mul = function(T) {
      if (this._hasDoubles(T)) return this.curve._fixedNafMul(this, T);
      else return this.curve._wnafMul(this, T);
    }, J.prototype.mulAdd = function(T, X, f) {
      return this.curve._wnafMulAdd(1, [this, X], [T, f], 2, false);
    }, J.prototype.jmulAdd = function(T, X, f) {
      return this.curve._wnafMulAdd(1, [this, X], [T, f], 2, true);
    }, J.prototype.normalize = function() {
      if (this.zOne) return this;
      var T = this.z.redInvm();
      if (this.x = this.x.redMul(T), this.y = this.y.redMul(T), this.t) this.t = this.t.redMul(T);
      return this.z = this.curve.one, this.zOne = true, this;
    }, J.prototype.neg = function() {
      return this.curve.point(this.x.redNeg(), this.y, this.z, this.t && this.t.redNeg());
    }, J.prototype.getX = function() {
      return this.normalize(), this.x.fromRed();
    }, J.prototype.getY = function() {
      return this.normalize(), this.y.fromRed();
    }, J.prototype.eq = function(T) {
      return this === T || this.getX().cmp(T.getX()) === 0 && this.getY().cmp(T.getY()) === 0;
    }, J.prototype.eqXToP = function(T) {
      var X = T.toRed(this.curve.red).redMul(this.z);
      if (this.x.cmp(X) === 0) return true;
      var f = T.clone(), V = this.curve.redN.redMul(this.z);
      for (; ; ) {
        if (f.iadd(this.curve.n), f.cmp(this.curve.p) >= 0) return false;
        if (X.redIAdd(V), this.x.cmp(X) === 0) return true;
      }
    }, J.prototype.toP = J.prototype.normalize, J.prototype.mixedAdd = J.prototype.add;
  }), H0 = r$(($) => {
    var q = $;
    q.base = zO(), q.short = _o(), q.mont = Po(), q.edwards = Oo();
  }), qK = r$(($) => {
    var q = K_(), K = z8();
    $.inherits = K;
    function P(H, Z) {
      if ((H.charCodeAt(Z) & 64512) !== 55296) return false;
      if (Z < 0 || Z + 1 >= H.length) return false;
      return (H.charCodeAt(Z + 1) & 64512) === 56320;
    }
    __name(P, "P");
    function _(H, Z) {
      if (Array.isArray(H)) return H.slice();
      if (!H) return [];
      var W = [];
      if (typeof H === "string") {
        if (!Z) {
          var w = 0;
          for (var G = 0; G < H.length; G++) {
            var S = H.charCodeAt(G);
            if (S < 128) W[w++] = S;
            else if (S < 2048) W[w++] = S >> 6 | 192, W[w++] = S & 63 | 128;
            else if (P(H, G)) S = 65536 + ((S & 1023) << 10) + (H.charCodeAt(++G) & 1023), W[w++] = S >> 18 | 240, W[w++] = S >> 12 & 63 | 128, W[w++] = S >> 6 & 63 | 128, W[w++] = S & 63 | 128;
            else W[w++] = S >> 12 | 224, W[w++] = S >> 6 & 63 | 128, W[w++] = S & 63 | 128;
          }
        } else if (Z === "hex") {
          if (H = H.replace(/[^a-z0-9]+/ig, ""), H.length % 2 !== 0) H = "0" + H;
          for (G = 0; G < H.length; G += 2) W.push(parseInt(H[G] + H[G + 1], 16));
        }
      } else for (G = 0; G < H.length; G++) W[G] = H[G] | 0;
      return W;
    }
    __name(_, "_");
    $.toArray = _;
    function Y(H) {
      var Z = "";
      for (var W = 0; W < H.length; W++) Z += J(H[W].toString(16));
      return Z;
    }
    __name(Y, "Y");
    $.toHex = Y;
    function O(H) {
      var Z = H >>> 24 | H >>> 8 & 65280 | H << 8 & 16711680 | (H & 255) << 24;
      return Z >>> 0;
    }
    __name(O, "O");
    $.htonl = O;
    function z(H, Z) {
      var W = "";
      for (var w = 0; w < H.length; w++) {
        var G = H[w];
        if (Z === "little") G = O(G);
        W += T(G.toString(16));
      }
      return W;
    }
    __name(z, "z");
    $.toHex32 = z;
    function J(H) {
      if (H.length === 1) return "0" + H;
      else return H;
    }
    __name(J, "J");
    $.zero2 = J;
    function T(H) {
      if (H.length === 7) return "0" + H;
      else if (H.length === 6) return "00" + H;
      else if (H.length === 5) return "000" + H;
      else if (H.length === 4) return "0000" + H;
      else if (H.length === 3) return "00000" + H;
      else if (H.length === 2) return "000000" + H;
      else if (H.length === 1) return "0000000" + H;
      else return H;
    }
    __name(T, "T");
    $.zero8 = T;
    function X(H, Z, W, w) {
      var G = W - Z;
      q(G % 4 === 0);
      var S = Array(G / 4);
      for (var A = 0, v = Z; A < S.length; A++, v += 4) {
        var k;
        if (w === "big") k = H[v] << 24 | H[v + 1] << 16 | H[v + 2] << 8 | H[v + 3];
        else k = H[v + 3] << 24 | H[v + 2] << 16 | H[v + 1] << 8 | H[v];
        S[A] = k >>> 0;
      }
      return S;
    }
    __name(X, "X");
    $.join32 = X;
    function f(H, Z) {
      var W = Array(H.length * 4);
      for (var w = 0, G = 0; w < H.length; w++, G += 4) {
        var S = H[w];
        if (Z === "big") W[G] = S >>> 24, W[G + 1] = S >>> 16 & 255, W[G + 2] = S >>> 8 & 255, W[G + 3] = S & 255;
        else W[G + 3] = S >>> 24, W[G + 2] = S >>> 16 & 255, W[G + 1] = S >>> 8 & 255, W[G] = S & 255;
      }
      return W;
    }
    __name(f, "f");
    $.split32 = f;
    function V(H, Z) {
      return H >>> Z | H << 32 - Z;
    }
    __name(V, "V");
    $.rotr32 = V;
    function M(H, Z) {
      return H << Z | H >>> 32 - Z;
    }
    __name(M, "M");
    $.rotl32 = M;
    function N(H, Z) {
      return H + Z >>> 0;
    }
    __name(N, "N");
    $.sum32 = N;
    function E(H, Z, W) {
      return H + Z + W >>> 0;
    }
    __name(E, "E");
    $.sum32_3 = E;
    function h(H, Z, W, w) {
      return H + Z + W + w >>> 0;
    }
    __name(h, "h");
    $.sum32_4 = h;
    function I(H, Z, W, w, G) {
      return H + Z + W + w + G >>> 0;
    }
    __name(I, "I");
    $.sum32_5 = I;
    function D(H, Z, W, w) {
      var G = H[Z], S = H[Z + 1], A = w + S >>> 0, v = (A < w ? 1 : 0) + W + G;
      H[Z] = v >>> 0, H[Z + 1] = A;
    }
    __name(D, "D");
    $.sum64 = D;
    function g(H, Z, W, w) {
      var G = Z + w >>> 0, S = (G < Z ? 1 : 0) + H + W;
      return S >>> 0;
    }
    __name(g, "g");
    $.sum64_hi = g;
    function b(H, Z, W, w) {
      var G = Z + w;
      return G >>> 0;
    }
    __name(b, "b");
    $.sum64_lo = b;
    function y(H, Z, W, w, G, S, A, v) {
      var k = 0, R = Z;
      R = R + w >>> 0, k += R < Z ? 1 : 0, R = R + S >>> 0, k += R < S ? 1 : 0, R = R + v >>> 0, k += R < v ? 1 : 0;
      var C = H + W + G + A + k;
      return C >>> 0;
    }
    __name(y, "y");
    $.sum64_4_hi = y;
    function p(H, Z, W, w, G, S, A, v) {
      var k = Z + w + S + v;
      return k >>> 0;
    }
    __name(p, "p");
    $.sum64_4_lo = p;
    function n(H, Z, W, w, G, S, A, v, k, R) {
      var C = 0, L = Z;
      L = L + w >>> 0, C += L < Z ? 1 : 0, L = L + S >>> 0, C += L < S ? 1 : 0, L = L + v >>> 0, C += L < v ? 1 : 0, L = L + R >>> 0, C += L < R ? 1 : 0;
      var x = H + W + G + A + k + C;
      return x >>> 0;
    }
    __name(n, "n");
    $.sum64_5_hi = n;
    function s(H, Z, W, w, G, S, A, v, k, R) {
      var C = Z + w + S + v + R;
      return C >>> 0;
    }
    __name(s, "s");
    $.sum64_5_lo = s;
    function q$(H, Z, W) {
      var w = Z << 32 - W | H >>> W;
      return w >>> 0;
    }
    __name(q$, "q$");
    $.rotr64_hi = q$;
    function c(H, Z, W) {
      var w = H << 32 - W | Z >>> W;
      return w >>> 0;
    }
    __name(c, "c");
    $.rotr64_lo = c;
    function U(H, Z, W) {
      return H >>> W;
    }
    __name(U, "U");
    $.shr64_hi = U;
    function j(H, Z, W) {
      var w = H << 32 - W | Z >>> W;
      return w >>> 0;
    }
    __name(j, "j");
    $.shr64_lo = j;
  }), U7 = r$(($) => {
    var q = qK(), K = K_();
    function P() {
      this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32;
    }
    __name(P, "P");
    $.BlockHash = P, P.prototype.update = function(_, Y) {
      if (_ = q.toArray(_, Y), !this.pending) this.pending = _;
      else this.pending = this.pending.concat(_);
      if (this.pendingTotal += _.length, this.pending.length >= this._delta8) {
        _ = this.pending;
        var O = _.length % this._delta8;
        if (this.pending = _.slice(_.length - O, _.length), this.pending.length === 0) this.pending = null;
        _ = q.join32(_, 0, _.length - O, this.endian);
        for (var z = 0; z < _.length; z += this._delta32) this._update(_, z, z + this._delta32);
      }
      return this;
    }, P.prototype.digest = function(_) {
      return this.update(this._pad()), K(this.pending === null), this._digest(_);
    }, P.prototype._pad = function() {
      var _ = this.pendingTotal, Y = this._delta8, O = Y - (_ + this.padLength) % Y, z = Array(O + this.padLength);
      z[0] = 128;
      for (var J = 1; J < O; J++) z[J] = 0;
      if (_ <<= 3, this.endian === "big") {
        for (var T = 8; T < this.padLength; T++) z[J++] = 0;
        z[J++] = 0, z[J++] = 0, z[J++] = 0, z[J++] = 0, z[J++] = _ >>> 24 & 255, z[J++] = _ >>> 16 & 255, z[J++] = _ >>> 8 & 255, z[J++] = _ & 255;
      } else {
        z[J++] = _ & 255, z[J++] = _ >>> 8 & 255, z[J++] = _ >>> 16 & 255, z[J++] = _ >>> 24 & 255, z[J++] = 0, z[J++] = 0, z[J++] = 0, z[J++] = 0;
        for (T = 8; T < this.padLength; T++) z[J++] = 0;
      }
      return z;
    };
  }), J0 = r$(($) => {
    var q = qK(), K = q.rotr32;
    function P(f, V, M, N) {
      if (f === 0) return _(V, M, N);
      if (f === 1 || f === 3) return O(V, M, N);
      if (f === 2) return Y(V, M, N);
    }
    __name(P, "P");
    $.ft_1 = P;
    function _(f, V, M) {
      return f & V ^ ~f & M;
    }
    __name(_, "_");
    $.ch32 = _;
    function Y(f, V, M) {
      return f & V ^ f & M ^ V & M;
    }
    __name(Y, "Y");
    $.maj32 = Y;
    function O(f, V, M) {
      return f ^ V ^ M;
    }
    __name(O, "O");
    $.p32 = O;
    function z(f) {
      return K(f, 2) ^ K(f, 13) ^ K(f, 22);
    }
    __name(z, "z");
    $.s0_256 = z;
    function J(f) {
      return K(f, 6) ^ K(f, 11) ^ K(f, 25);
    }
    __name(J, "J");
    $.s1_256 = J;
    function T(f) {
      return K(f, 7) ^ K(f, 18) ^ f >>> 3;
    }
    __name(T, "T");
    $.g0_256 = T;
    function X(f) {
      return K(f, 17) ^ K(f, 19) ^ f >>> 10;
    }
    __name(X, "X");
    $.g1_256 = X;
  }), Yo = r$(($, q) => {
    var K = qK(), P = U7(), _ = J0(), Y = K.rotl32, O = K.sum32, z = K.sum32_5, J = _.ft_1, T = P.BlockHash, X = [1518500249, 1859775393, 2400959708, 3395469782];
    function f() {
      if (!(this instanceof f)) return new f();
      T.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.W = Array(80);
    }
    __name(f, "f");
    K.inherits(f, T), q.exports = f, f.blockSize = 512, f.outSize = 160, f.hmacStrength = 80, f.padLength = 64, f.prototype._update = function(V, M) {
      var N = this.W;
      for (var E = 0; E < 16; E++) N[E] = V[M + E];
      for (; E < N.length; E++) N[E] = Y(N[E - 3] ^ N[E - 8] ^ N[E - 14] ^ N[E - 16], 1);
      var h = this.h[0], I = this.h[1], D = this.h[2], g = this.h[3], b = this.h[4];
      for (E = 0; E < N.length; E++) {
        var y = ~~(E / 20), p = z(Y(h, 5), J(y, I, D, g), b, N[E], X[y]);
        b = g, g = D, D = Y(I, 30), I = h, h = p;
      }
      this.h[0] = O(this.h[0], h), this.h[1] = O(this.h[1], I), this.h[2] = O(this.h[2], D), this.h[3] = O(this.h[3], g), this.h[4] = O(this.h[4], b);
    }, f.prototype._digest = function(V) {
      if (V === "hex") return K.toHex32(this.h, "big");
      else return K.split32(this.h, "big");
    };
  }), T0 = r$(($, q) => {
    var K = qK(), P = U7(), _ = J0(), Y = K_(), O = K.sum32, z = K.sum32_4, J = K.sum32_5, T = _.ch32, X = _.maj32, f = _.s0_256, V = _.s1_256, M = _.g0_256, N = _.g1_256, E = P.BlockHash, h = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298];
    function I() {
      if (!(this instanceof I)) return new I();
      E.call(this), this.h = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225], this.k = h, this.W = Array(64);
    }
    __name(I, "I");
    K.inherits(I, E), q.exports = I, I.blockSize = 512, I.outSize = 256, I.hmacStrength = 192, I.padLength = 64, I.prototype._update = function(D, g) {
      var b = this.W;
      for (var y = 0; y < 16; y++) b[y] = D[g + y];
      for (; y < b.length; y++) b[y] = z(N(b[y - 2]), b[y - 7], M(b[y - 15]), b[y - 16]);
      var p = this.h[0], n = this.h[1], s = this.h[2], q$ = this.h[3], c = this.h[4], U = this.h[5], j = this.h[6], H = this.h[7];
      Y(this.k.length === b.length);
      for (y = 0; y < b.length; y++) {
        var Z = J(H, V(c), T(c, U, j), this.k[y], b[y]), W = O(f(p), X(p, n, s));
        H = j, j = U, U = c, c = O(q$, Z), q$ = s, s = n, n = p, p = O(Z, W);
      }
      this.h[0] = O(this.h[0], p), this.h[1] = O(this.h[1], n), this.h[2] = O(this.h[2], s), this.h[3] = O(this.h[3], q$), this.h[4] = O(this.h[4], c), this.h[5] = O(this.h[5], U), this.h[6] = O(this.h[6], j), this.h[7] = O(this.h[7], H);
    }, I.prototype._digest = function(D) {
      if (D === "hex") return K.toHex32(this.h, "big");
      else return K.split32(this.h, "big");
    };
  }), jo = r$(($, q) => {
    var K = qK(), P = T0();
    function _() {
      if (!(this instanceof _)) return new _();
      P.call(this), this.h = [3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428];
    }
    __name(_, "_");
    K.inherits(_, P), q.exports = _, _.blockSize = 512, _.outSize = 224, _.hmacStrength = 192, _.padLength = 64, _.prototype._digest = function(Y) {
      if (Y === "hex") return K.toHex32(this.h.slice(0, 7), "big");
      else return K.split32(this.h.slice(0, 7), "big");
    };
  }), w0 = r$(($, q) => {
    var K = qK(), P = U7(), _ = K_(), Y = K.rotr64_hi, O = K.rotr64_lo, z = K.shr64_hi, J = K.shr64_lo, T = K.sum64, X = K.sum64_hi, f = K.sum64_lo, V = K.sum64_4_hi, M = K.sum64_4_lo, N = K.sum64_5_hi, E = K.sum64_5_lo, h = P.BlockHash, I = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591];
    function D() {
      if (!(this instanceof D)) return new D();
      h.call(this), this.h = [1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723, 2773480762, 1595750129, 1359893119, 2917565137, 2600822924, 725511199, 528734635, 4215389547, 1541459225, 327033209], this.k = I, this.W = Array(160);
    }
    __name(D, "D");
    K.inherits(D, h), q.exports = D, D.blockSize = 1024, D.outSize = 512, D.hmacStrength = 192, D.padLength = 128, D.prototype._prepareBlock = function(W, w) {
      var G = this.W;
      for (var S = 0; S < 32; S++) G[S] = W[w + S];
      for (; S < G.length; S += 2) {
        var A = H(G[S - 4], G[S - 3]), v = Z(G[S - 4], G[S - 3]), k = G[S - 14], R = G[S - 13], C = U(G[S - 30], G[S - 29]), L = j(G[S - 30], G[S - 29]), x = G[S - 32], l = G[S - 31];
        G[S] = V(A, v, k, R, C, L, x, l), G[S + 1] = M(A, v, k, R, C, L, x, l);
      }
    }, D.prototype._update = function(W, w) {
      this._prepareBlock(W, w);
      var G = this.W, S = this.h[0], A = this.h[1], v = this.h[2], k = this.h[3], R = this.h[4], C = this.h[5], L = this.h[6], x = this.h[7], l = this.h[8], a = this.h[9], f$ = this.h[10], $$ = this.h[11], t = this.h[12], H$ = this.h[13], Q = this.h[14], v$ = this.h[15];
      _(this.k.length === G.length);
      for (var B$ = 0; B$ < G.length; B$ += 2) {
        var m = Q, r = v$, J$ = q$(l, a), e = c(l, a), _$2 = g(l, a, f$, $$, t, H$), Y$ = b(l, a, f$, $$, t, H$), d = this.k[B$], o = this.k[B$ + 1], W$ = G[B$], B = G[B$ + 1], F = N(m, r, J$, e, _$2, Y$, d, o, W$, B), X$ = E(m, r, J$, e, _$2, Y$, d, o, W$, B);
        m = n(S, A), r = s(S, A), J$ = y(S, A, v, k, R, C), e = p(S, A, v, k, R, C);
        var z$ = X(m, r, J$, e), j$ = f(m, r, J$, e);
        Q = t, v$ = H$, t = f$, H$ = $$, f$ = l, $$ = a, l = X(L, x, F, X$), a = f(x, x, F, X$), L = R, x = C, R = v, C = k, v = S, k = A, S = X(F, X$, z$, j$), A = f(F, X$, z$, j$);
      }
      T(this.h, 0, S, A), T(this.h, 2, v, k), T(this.h, 4, R, C), T(this.h, 6, L, x), T(this.h, 8, l, a), T(this.h, 10, f$, $$), T(this.h, 12, t, H$), T(this.h, 14, Q, v$);
    }, D.prototype._digest = function(W) {
      if (W === "hex") return K.toHex32(this.h, "big");
      else return K.split32(this.h, "big");
    };
    function g(W, w, G, S, A) {
      var v = W & G ^ ~W & A;
      if (v < 0) v += 4294967296;
      return v;
    }
    __name(g, "g");
    function b(W, w, G, S, A, v) {
      var k = w & S ^ ~w & v;
      if (k < 0) k += 4294967296;
      return k;
    }
    __name(b, "b");
    function y(W, w, G, S, A) {
      var v = W & G ^ W & A ^ G & A;
      if (v < 0) v += 4294967296;
      return v;
    }
    __name(y, "y");
    function p(W, w, G, S, A, v) {
      var k = w & S ^ w & v ^ S & v;
      if (k < 0) k += 4294967296;
      return k;
    }
    __name(p, "p");
    function n(W, w) {
      var G = Y(W, w, 28), S = Y(w, W, 2), A = Y(w, W, 7), v = G ^ S ^ A;
      if (v < 0) v += 4294967296;
      return v;
    }
    __name(n, "n");
    function s(W, w) {
      var G = O(W, w, 28), S = O(w, W, 2), A = O(w, W, 7), v = G ^ S ^ A;
      if (v < 0) v += 4294967296;
      return v;
    }
    __name(s, "s");
    function q$(W, w) {
      var G = Y(W, w, 14), S = Y(W, w, 18), A = Y(w, W, 9), v = G ^ S ^ A;
      if (v < 0) v += 4294967296;
      return v;
    }
    __name(q$, "q$");
    function c(W, w) {
      var G = O(W, w, 14), S = O(W, w, 18), A = O(w, W, 9), v = G ^ S ^ A;
      if (v < 0) v += 4294967296;
      return v;
    }
    __name(c, "c");
    function U(W, w) {
      var G = Y(W, w, 1), S = Y(W, w, 8), A = z(W, w, 7), v = G ^ S ^ A;
      if (v < 0) v += 4294967296;
      return v;
    }
    __name(U, "U");
    function j(W, w) {
      var G = O(W, w, 1), S = O(W, w, 8), A = J(W, w, 7), v = G ^ S ^ A;
      if (v < 0) v += 4294967296;
      return v;
    }
    __name(j, "j");
    function H(W, w) {
      var G = Y(W, w, 19), S = Y(w, W, 29), A = z(W, w, 6), v = G ^ S ^ A;
      if (v < 0) v += 4294967296;
      return v;
    }
    __name(H, "H");
    function Z(W, w) {
      var G = O(W, w, 19), S = O(w, W, 29), A = J(W, w, 6), v = G ^ S ^ A;
      if (v < 0) v += 4294967296;
      return v;
    }
    __name(Z, "Z");
  }), vo = r$(($, q) => {
    var K = qK(), P = w0();
    function _() {
      if (!(this instanceof _)) return new _();
      P.call(this), this.h = [3418070365, 3238371032, 1654270250, 914150663, 2438529370, 812702999, 355462360, 4144912697, 1731405415, 4290775857, 2394180231, 1750603025, 3675008525, 1694076839, 1203062813, 3204075428];
    }
    __name(_, "_");
    K.inherits(_, P), q.exports = _, _.blockSize = 1024, _.outSize = 384, _.hmacStrength = 192, _.padLength = 128, _.prototype._digest = function(Y) {
      if (Y === "hex") return K.toHex32(this.h.slice(0, 12), "big");
      else return K.split32(this.h.slice(0, 12), "big");
    };
  }), zo = r$(($) => {
    $.sha1 = Yo(), $.sha224 = jo(), $.sha256 = T0(), $.sha384 = vo(), $.sha512 = w0();
  }), Wo = r$(($) => {
    var q = qK(), K = U7(), P = q.rotl32, _ = q.sum32, Y = q.sum32_3, O = q.sum32_4, z = K.BlockHash;
    function J() {
      if (!(this instanceof J)) return new J();
      z.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = "little";
    }
    __name(J, "J");
    q.inherits(J, z), $.ripemd160 = J, J.blockSize = 512, J.outSize = 160, J.hmacStrength = 192, J.padLength = 64, J.prototype._update = function(h, I) {
      var D = this.h[0], g = this.h[1], b = this.h[2], y = this.h[3], p = this.h[4], n = D, s = g, q$ = b, c = y, U = p;
      for (var j = 0; j < 80; j++) {
        var H = _(P(O(D, T(j, g, b, y), h[V[j] + I], X(j)), N[j]), p);
        D = p, p = y, y = P(b, 10), b = g, g = H, H = _(P(O(n, T(79 - j, s, q$, c), h[M[j] + I], f(j)), E[j]), U), n = U, U = c, c = P(q$, 10), q$ = s, s = H;
      }
      H = Y(this.h[1], b, c), this.h[1] = Y(this.h[2], y, U), this.h[2] = Y(this.h[3], p, n), this.h[3] = Y(this.h[4], D, s), this.h[4] = Y(this.h[0], g, q$), this.h[0] = H;
    }, J.prototype._digest = function(h) {
      if (h === "hex") return q.toHex32(this.h, "little");
      else return q.split32(this.h, "little");
    };
    function T(h, I, D, g) {
      if (h <= 15) return I ^ D ^ g;
      else if (h <= 31) return I & D | ~I & g;
      else if (h <= 47) return (I | ~D) ^ g;
      else if (h <= 63) return I & g | D & ~g;
      else return I ^ (D | ~g);
    }
    __name(T, "T");
    function X(h) {
      if (h <= 15) return 0;
      else if (h <= 31) return 1518500249;
      else if (h <= 47) return 1859775393;
      else if (h <= 63) return 2400959708;
      else return 2840853838;
    }
    __name(X, "X");
    function f(h) {
      if (h <= 15) return 1352829926;
      else if (h <= 31) return 1548603684;
      else if (h <= 47) return 1836072691;
      else if (h <= 63) return 2053994217;
      else return 0;
    }
    __name(f, "f");
    var V = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13], M = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11], N = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6], E = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11];
  }), Ho = r$(($, q) => {
    var K = qK(), P = K_();
    function _(Y, O, z) {
      if (!(this instanceof _)) return new _(Y, O, z);
      this.Hash = Y, this.blockSize = Y.blockSize / 8, this.outSize = Y.outSize / 8, this.inner = null, this.outer = null, this._init(K.toArray(O, z));
    }
    __name(_, "_");
    q.exports = _, _.prototype._init = function(Y) {
      if (Y.length > this.blockSize) Y = new this.Hash().update(Y).digest();
      P(Y.length <= this.blockSize);
      for (var O = Y.length; O < this.blockSize; O++) Y.push(0);
      for (O = 0; O < Y.length; O++) Y[O] ^= 54;
      this.inner = new this.Hash().update(Y);
      for (O = 0; O < Y.length; O++) Y[O] ^= 106;
      this.outer = new this.Hash().update(Y);
    }, _.prototype.update = function(Y, O) {
      return this.inner.update(Y, O), this;
    }, _.prototype.digest = function(Y) {
      return this.outer.update(this.inner.digest()), this.outer.digest(Y);
    };
  }), iH = r$(($) => {
    var q = $;
    q.utils = qK(), q.common = U7(), q.sha = zo(), q.ripemd = Wo(), q.hmac = Ho(), q.sha1 = q.sha.sha1, q.sha256 = q.sha.sha256, q.sha224 = q.sha.sha224, q.sha384 = q.sha.sha384, q.sha512 = q.sha.sha512, q.ripemd160 = q.ripemd.ripemd160;
  }), Jo = r$(($, q) => {
    q.exports = { doubles: { step: 4, points: [["e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a", "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"], ["8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508", "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"], ["175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739", "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"], ["363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640", "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"], ["8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c", "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"], ["723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda", "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"], ["eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa", "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"], ["100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0", "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"], ["e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d", "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"], ["feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d", "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"], ["da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1", "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"], ["53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0", "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"], ["8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047", "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"], ["385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862", "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"], ["6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7", "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"], ["3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd", "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"], ["85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83", "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"], ["948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a", "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"], ["6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8", "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"], ["e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d", "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"], ["e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725", "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"], ["213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754", "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"], ["4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c", "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"], ["fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6", "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"], ["76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39", "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"], ["c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891", "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"], ["d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b", "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"], ["b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03", "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"], ["e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d", "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"], ["a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070", "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"], ["90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4", "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"], ["8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da", "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"], ["e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11", "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"], ["8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e", "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"], ["e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41", "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"], ["b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef", "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"], ["d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8", "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"], ["324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d", "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"], ["4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96", "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"], ["9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd", "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"], ["6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5", "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"], ["a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266", "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"], ["7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71", "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"], ["928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac", "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"], ["85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751", "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"], ["ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e", "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"], ["827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241", "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"], ["eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3", "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"], ["e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f", "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"], ["1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19", "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"], ["146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be", "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"], ["fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9", "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"], ["da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2", "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"], ["a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13", "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"], ["174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c", "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"], ["959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba", "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"], ["d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151", "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"], ["64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073", "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"], ["8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458", "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"], ["13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b", "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"], ["bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366", "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"], ["8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa", "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"], ["8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0", "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"], ["dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787", "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"], ["f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e", "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"]] }, naf: { wnd: 7, points: [["f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9", "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"], ["2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4", "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"], ["5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc", "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"], ["acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe", "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"], ["774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb", "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"], ["f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8", "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"], ["d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e", "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"], ["defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34", "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"], ["2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c", "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"], ["352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5", "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"], ["2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f", "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"], ["9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714", "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"], ["daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729", "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"], ["c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db", "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"], ["6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4", "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"], ["1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5", "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"], ["605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479", "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"], ["62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d", "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"], ["80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f", "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"], ["7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb", "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"], ["d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9", "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"], ["49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963", "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"], ["77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74", "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"], ["f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530", "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"], ["463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b", "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"], ["f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247", "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"], ["caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1", "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"], ["2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120", "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"], ["7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435", "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"], ["754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18", "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"], ["e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8", "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"], ["186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb", "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"], ["df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f", "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"], ["5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143", "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"], ["290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba", "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"], ["af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45", "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"], ["766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a", "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"], ["59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e", "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"], ["f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8", "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"], ["7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c", "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"], ["948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519", "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"], ["7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab", "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"], ["3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca", "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"], ["d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf", "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"], ["1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610", "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"], ["733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4", "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"], ["15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c", "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"], ["a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940", "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"], ["e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980", "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"], ["311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3", "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"], ["34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf", "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"], ["f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63", "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"], ["d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448", "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"], ["32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf", "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"], ["7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5", "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"], ["ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6", "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"], ["16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5", "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"], ["eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99", "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"], ["78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51", "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"], ["494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5", "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"], ["a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5", "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"], ["c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997", "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"], ["841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881", "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"], ["5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5", "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"], ["36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66", "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"], ["336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726", "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"], ["8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede", "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"], ["1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94", "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"], ["85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31", "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"], ["29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51", "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"], ["a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252", "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"], ["4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5", "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"], ["d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b", "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"], ["ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4", "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"], ["af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f", "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"], ["e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889", "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"], ["591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246", "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"], ["11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984", "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"], ["3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a", "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"], ["cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030", "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"], ["c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197", "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"], ["c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593", "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"], ["a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef", "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"], ["347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38", "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"], ["da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a", "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"], ["c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111", "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"], ["4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502", "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"], ["3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea", "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"], ["cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26", "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"], ["b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986", "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"], ["d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e", "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"], ["48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4", "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"], ["dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda", "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"], ["6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859", "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"], ["e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f", "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"], ["eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c", "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"], ["13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942", "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"], ["ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a", "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"], ["b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80", "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"], ["ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d", "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"], ["8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1", "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"], ["52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63", "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"], ["e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352", "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"], ["7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193", "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"], ["5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00", "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"], ["32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58", "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"], ["e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7", "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"], ["8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8", "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"], ["4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e", "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"], ["3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d", "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"], ["674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b", "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"], ["d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f", "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"], ["30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6", "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"], ["be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297", "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"], ["93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a", "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"], ["b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c", "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"], ["d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52", "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"], ["d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb", "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"], ["463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065", "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"], ["7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917", "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"], ["74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9", "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"], ["30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3", "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"], ["9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57", "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"], ["176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66", "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"], ["75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8", "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"], ["809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721", "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"], ["1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180", "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"]] } };
  }), tH = r$(($) => {
    var q = $, K = iH(), P = H0(), _ = M8(), Y = _.assert;
    function O(T) {
      if (T.type === "short") this.curve = new P.short(T);
      else if (T.type === "edwards") this.curve = new P.edwards(T);
      else this.curve = new P.mont(T);
      this.g = this.curve.g, this.n = this.curve.n, this.hash = T.hash, Y(this.g.validate(), "Invalid curve"), Y(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
    }
    __name(O, "O");
    q.PresetCurve = O;
    function z(T, X) {
      Object.defineProperty(q, T, { configurable: true, enumerable: true, get: /* @__PURE__ */ __name(function() {
        var f = new O(X);
        return Object.defineProperty(q, T, { configurable: true, enumerable: true, value: f }), f;
      }, "get") });
    }
    __name(z, "z");
    z("p192", { type: "short", prime: "p192", p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff", a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc", b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1", n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831", hash: K.sha256, gRed: false, g: ["188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012", "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"] }), z("p224", { type: "short", prime: "p224", p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001", a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe", b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4", n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d", hash: K.sha256, gRed: false, g: ["b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21", "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"] }), z("p256", { type: "short", prime: null, p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff", a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc", b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b", n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551", hash: K.sha256, gRed: false, g: ["6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296", "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"] }), z("p384", { type: "short", prime: null, p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff", a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc", b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef", n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973", hash: K.sha384, gRed: false, g: ["aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7", "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"] }), z("p521", { type: "short", prime: null, p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff", a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc", b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00", n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409", hash: K.sha512, gRed: false, g: ["000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66", "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"] }), z("curve25519", { type: "mont", prime: "p25519", p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed", a: "76d06", b: "1", n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed", hash: K.sha256, gRed: false, g: ["9"] }), z("ed25519", { type: "edwards", prime: "p25519", p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed", a: "-1", c: "1", d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3", n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed", hash: K.sha256, gRed: false, g: ["216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a", "6666666666666666666666666666666666666666666666666666666666666658"] });
    var J;
    try {
      J = Jo();
    } catch (T) {
      J = void 0;
    }
    z("secp256k1", { type: "short", prime: "k256", p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f", a: "0", b: "7", n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141", h: "1", hash: K.sha256, beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee", lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72", basis: [{ a: "3086d221a7d46bcde86c90e49284eb15", b: "-e4437ed6010e88286f547fa90abfe4c3" }, { a: "114ca50f7a8e2f3f657c1108d9d44cfd8", b: "3086d221a7d46bcde86c90e49284eb15" }], gRed: false, g: ["79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798", "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8", J] });
  }), To = r$(($, q) => {
    var K = iH(), P = z0(), _ = K_();
    function Y(O) {
      if (!(this instanceof Y)) return new Y(O);
      this.hash = O.hash, this.predResist = !!O.predResist, this.outLen = this.hash.outSize, this.minEntropy = O.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
      var z = P.toArray(O.entropy, O.entropyEnc || "hex"), J = P.toArray(O.nonce, O.nonceEnc || "hex"), T = P.toArray(O.pers, O.persEnc || "hex");
      _(z.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._init(z, J, T);
    }
    __name(Y, "Y");
    q.exports = Y, Y.prototype._init = function(O, z, J) {
      var T = O.concat(z).concat(J);
      this.K = Array(this.outLen / 8), this.V = Array(this.outLen / 8);
      for (var X = 0; X < this.V.length; X++) this.K[X] = 0, this.V[X] = 1;
      this._update(T), this._reseed = 1, this.reseedInterval = 281474976710656;
    }, Y.prototype._hmac = function() {
      return new K.hmac(this.hash, this.K);
    }, Y.prototype._update = function(O) {
      var z = this._hmac().update(this.V).update([0]);
      if (O) z = z.update(O);
      if (this.K = z.digest(), this.V = this._hmac().update(this.V).digest(), !O) return;
      this.K = this._hmac().update(this.V).update([1]).update(O).digest(), this.V = this._hmac().update(this.V).digest();
    }, Y.prototype.reseed = function(O, z, J, T) {
      if (typeof z !== "string") T = J, J = z, z = null;
      O = P.toArray(O, z), J = P.toArray(J, T), _(O.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._update(O.concat(J || [])), this._reseed = 1;
    }, Y.prototype.generate = function(O, z, J, T) {
      if (this._reseed > this.reseedInterval) throw Error("Reseed is required");
      if (typeof z !== "string") T = J, J = z, z = null;
      if (J) J = P.toArray(J, T || "hex"), this._update(J);
      var X = [];
      while (X.length < O) this.V = this._hmac().update(this.V).digest(), X = X.concat(this.V);
      var f = X.slice(0, O);
      return this._update(J), this._reseed++, P.encode(f, z);
    };
  }), wo = r$(($, q) => {
    var K = CK(), P = M8(), _ = P.assert;
    function Y(O, z) {
      if (this.ec = O, this.priv = null, this.pub = null, z.priv) this._importPrivate(z.priv, z.privEnc);
      if (z.pub) this._importPublic(z.pub, z.pubEnc);
    }
    __name(Y, "Y");
    q.exports = Y, Y.fromPublic = function(O, z, J) {
      if (z instanceof Y) return z;
      return new Y(O, { pub: z, pubEnc: J });
    }, Y.fromPrivate = function(O, z, J) {
      if (z instanceof Y) return z;
      return new Y(O, { priv: z, privEnc: J });
    }, Y.prototype.validate = function() {
      var O = this.getPublic();
      if (O.isInfinity()) return { result: false, reason: "Invalid public key" };
      if (!O.validate()) return { result: false, reason: "Public key is not a point" };
      if (!O.mul(this.ec.curve.n).isInfinity()) return { result: false, reason: "Public key * N != O" };
      return { result: true, reason: null };
    }, Y.prototype.getPublic = function(O, z) {
      if (typeof O === "string") z = O, O = null;
      if (!this.pub) this.pub = this.ec.g.mul(this.priv);
      if (!z) return this.pub;
      return this.pub.encode(z, O);
    }, Y.prototype.getPrivate = function(O) {
      if (O === "hex") return this.priv.toString(16, 2);
      else return this.priv;
    }, Y.prototype._importPrivate = function(O, z) {
      this.priv = new K(O, z || 16), this.priv = this.priv.umod(this.ec.curve.n);
    }, Y.prototype._importPublic = function(O, z) {
      if (O.x || O.y) {
        if (this.ec.curve.type === "mont") _(O.x, "Need x coordinate");
        else if (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") _(O.x && O.y, "Need both x and y coordinate");
        this.pub = this.ec.curve.point(O.x, O.y);
        return;
      }
      this.pub = this.ec.curve.decodePoint(O, z);
    }, Y.prototype.derive = function(O) {
      if (!O.validate()) _(O.validate(), "public point not validated");
      return O.mul(this.priv).getX();
    }, Y.prototype.sign = function(O, z, J) {
      return this.ec.sign(O, this, z, J);
    }, Y.prototype.verify = function(O, z, J) {
      return this.ec.verify(O, z, this, void 0, J);
    }, Y.prototype.inspect = function() {
      return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
    };
  }), fo = r$(($, q) => {
    var K = CK(), P = M8(), _ = P.assert;
    function Y(X, f) {
      if (X instanceof Y) return X;
      if (this._importDER(X, f)) return;
      if (_(X.r && X.s, "Signature without r or s"), this.r = new K(X.r, 16), this.s = new K(X.s, 16), X.recoveryParam === void 0) this.recoveryParam = null;
      else this.recoveryParam = X.recoveryParam;
    }
    __name(Y, "Y");
    q.exports = Y;
    function O() {
      this.place = 0;
    }
    __name(O, "O");
    function z(X, f) {
      var V = X[f.place++];
      if (!(V & 128)) return V;
      var M = V & 15;
      if (M === 0 || M > 4) return false;
      if (X[f.place] === 0) return false;
      var N = 0;
      for (var E = 0, h = f.place; E < M; E++, h++) N <<= 8, N |= X[h], N >>>= 0;
      if (N <= 127) return false;
      return f.place = h, N;
    }
    __name(z, "z");
    function J(X) {
      var f = 0, V = X.length - 1;
      while (!X[f] && !(X[f + 1] & 128) && f < V) f++;
      if (f === 0) return X;
      return X.slice(f);
    }
    __name(J, "J");
    Y.prototype._importDER = function(X, f) {
      X = P.toArray(X, f);
      var V = new O();
      if (X[V.place++] !== 48) return false;
      var M = z(X, V);
      if (M === false) return false;
      if (M + V.place !== X.length) return false;
      if (X[V.place++] !== 2) return false;
      var N = z(X, V);
      if (N === false) return false;
      if ((X[V.place] & 128) !== 0) return false;
      var E = X.slice(V.place, N + V.place);
      if (V.place += N, X[V.place++] !== 2) return false;
      var h = z(X, V);
      if (h === false) return false;
      if (X.length !== h + V.place) return false;
      if ((X[V.place] & 128) !== 0) return false;
      var I = X.slice(V.place, h + V.place);
      if (E[0] === 0) if (E[1] & 128) E = E.slice(1);
      else return false;
      if (I[0] === 0) if (I[1] & 128) I = I.slice(1);
      else return false;
      return this.r = new K(E), this.s = new K(I), this.recoveryParam = null, true;
    };
    function T(X, f) {
      if (f < 128) {
        X.push(f);
        return;
      }
      var V = 1 + (Math.log(f) / Math.LN2 >>> 3);
      X.push(V | 128);
      while (--V) X.push(f >>> (V << 3) & 255);
      X.push(f);
    }
    __name(T, "T");
    Y.prototype.toDER = function(X) {
      var f = this.r.toArray(), V = this.s.toArray();
      if (f[0] & 128) f = [0].concat(f);
      if (V[0] & 128) V = [0].concat(V);
      f = J(f), V = J(V);
      while (!V[0] && !(V[1] & 128)) V = V.slice(1);
      var M = [2];
      T(M, f.length), M = M.concat(f), M.push(2), T(M, V.length);
      var N = M.concat(V), E = [48];
      return T(E, N.length), E = E.concat(N), P.encode(E, X);
    };
  }), Zo = r$(($, q) => {
    var K = CK(), P = To(), _ = M8(), Y = tH(), O = W0(), z = _.assert, J = wo(), T = fo();
    function X(f) {
      if (!(this instanceof X)) return new X(f);
      if (typeof f === "string") z(Object.prototype.hasOwnProperty.call(Y, f), "Unknown curve " + f), f = Y[f];
      if (f instanceof Y.PresetCurve) f = { curve: f };
      this.curve = f.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = f.curve.g, this.g.precompute(f.curve.n.bitLength() + 1), this.hash = f.hash || f.curve.hash;
    }
    __name(X, "X");
    q.exports = X, X.prototype.keyPair = function(f) {
      return new J(this, f);
    }, X.prototype.keyFromPrivate = function(f, V) {
      return J.fromPrivate(this, f, V);
    }, X.prototype.keyFromPublic = function(f, V) {
      return J.fromPublic(this, f, V);
    }, X.prototype.genKeyPair = function(f) {
      if (!f) f = {};
      var V = new P({ hash: this.hash, pers: f.pers, persEnc: f.persEnc || "utf8", entropy: f.entropy || O(this.hash.hmacStrength), entropyEnc: f.entropy && f.entropyEnc || "utf8", nonce: this.n.toArray() }), M = this.n.byteLength(), N = this.n.sub(new K(2));
      for (; ; ) {
        var E = new K(V.generate(M));
        if (E.cmp(N) > 0) continue;
        return E.iaddn(1), this.keyFromPrivate(E);
      }
    }, X.prototype._truncateToN = function(f, V, M) {
      var N;
      if (K.isBN(f) || typeof f === "number") f = new K(f, 16), N = f.byteLength();
      else if (typeof f === "object") N = f.length, f = new K(f, 16);
      else {
        var E = f.toString();
        N = E.length + 1 >>> 1, f = new K(E, 16);
      }
      if (typeof M !== "number") M = N * 8;
      var h = M - this.n.bitLength();
      if (h > 0) f = f.ushrn(h);
      if (!V && f.cmp(this.n) >= 0) return f.sub(this.n);
      else return f;
    }, X.prototype.sign = function(f, V, M, N) {
      if (typeof M === "object") N = M, M = null;
      if (!N) N = {};
      if (typeof f !== "string" && typeof f !== "number" && !K.isBN(f)) {
        z(typeof f === "object" && f && typeof f.length === "number", "Expected message to be an array-like, a hex string, or a BN instance"), z(f.length >>> 0 === f.length);
        for (var E = 0; E < f.length; E++) z((f[E] & 255) === f[E]);
      }
      V = this.keyFromPrivate(V, M), f = this._truncateToN(f, false, N.msgBitLength), z(!f.isNeg(), "Can not sign a negative message");
      var h = this.n.byteLength(), I = V.getPrivate().toArray("be", h), D = f.toArray("be", h);
      z(new K(D).eq(f), "Can not sign message");
      var g = new P({ hash: this.hash, entropy: I, nonce: D, pers: N.pers, persEnc: N.persEnc || "utf8" }), b = this.n.sub(new K(1));
      for (var y = 0; ; y++) {
        var p = N.k ? N.k(y) : new K(g.generate(this.n.byteLength()));
        if (p = this._truncateToN(p, true), p.cmpn(1) <= 0 || p.cmp(b) >= 0) continue;
        var n = this.g.mul(p);
        if (n.isInfinity()) continue;
        var s = n.getX(), q$ = s.umod(this.n);
        if (q$.cmpn(0) === 0) continue;
        var c = p.invm(this.n).mul(q$.mul(V.getPrivate()).iadd(f));
        if (c = c.umod(this.n), c.cmpn(0) === 0) continue;
        var U = (n.getY().isOdd() ? 1 : 0) | (s.cmp(q$) !== 0 ? 2 : 0);
        if (N.canonical && c.cmp(this.nh) > 0) c = this.n.sub(c), U ^= 1;
        return new T({ r: q$, s: c, recoveryParam: U });
      }
    }, X.prototype.verify = function(f, V, M, N, E) {
      if (!E) E = {};
      f = this._truncateToN(f, false, E.msgBitLength), M = this.keyFromPublic(M, N), V = new T(V, "hex");
      var { r: h, s: I } = V;
      if (h.cmpn(1) < 0 || h.cmp(this.n) >= 0) return false;
      if (I.cmpn(1) < 0 || I.cmp(this.n) >= 0) return false;
      var D = I.invm(this.n), g = D.mul(f).umod(this.n), b = D.mul(h).umod(this.n), y;
      if (!this.curve._maxwellTrick) {
        if (y = this.g.mulAdd(g, M.getPublic(), b), y.isInfinity()) return false;
        return y.getX().umod(this.n).cmp(h) === 0;
      }
      if (y = this.g.jmulAdd(g, M.getPublic(), b), y.isInfinity()) return false;
      return y.eqXToP(h);
    }, X.prototype.recoverPubKey = function(f, V, M, N) {
      z((3 & M) === M, "The recovery param is more than two bits"), V = new T(V, N);
      var E = this.n, h = new K(f), I = V.r, D = V.s, g = M & 1, b = M >> 1;
      if (I.cmp(this.curve.p.umod(this.curve.n)) >= 0 && b) throw Error("Unable to find sencond key candinate");
      if (b) I = this.curve.pointFromX(I.add(this.curve.n), g);
      else I = this.curve.pointFromX(I, g);
      var y = V.r.invm(E), p = E.sub(h).mul(y).umod(E), n = D.mul(y).umod(E);
      return this.g.mulAdd(p, I, n);
    }, X.prototype.getKeyRecoveryParam = function(f, V, M, N) {
      if (V = new T(V, N), V.recoveryParam !== null) return V.recoveryParam;
      for (var E = 0; E < 4; E++) {
        var h;
        try {
          h = this.recoverPubKey(f, V, E);
        } catch (I) {
          continue;
        }
        if (h.eq(M)) return E;
      }
      throw Error("Unable to find valid recovery factor");
    };
  }), Xo = r$(($, q) => {
    var K = M8(), P = K.assert, _ = K.parseBytes, Y = K.cachedProperty;
    function O(z, J) {
      if (this.eddsa = z, this._secret = _(J.secret), z.isPoint(J.pub)) this._pub = J.pub;
      else this._pubBytes = _(J.pub);
    }
    __name(O, "O");
    O.fromPublic = function(z, J) {
      if (J instanceof O) return J;
      return new O(z, { pub: J });
    }, O.fromSecret = function(z, J) {
      if (J instanceof O) return J;
      return new O(z, { secret: J });
    }, O.prototype.secret = function() {
      return this._secret;
    }, Y(O, "pubBytes", function() {
      return this.eddsa.encodePoint(this.pub());
    }), Y(O, "pub", function() {
      if (this._pubBytes) return this.eddsa.decodePoint(this._pubBytes);
      return this.eddsa.g.mul(this.priv());
    }), Y(O, "privBytes", function() {
      var z = this.eddsa, J = this.hash(), T = z.encodingLength - 1, X = J.slice(0, z.encodingLength);
      return X[0] &= 248, X[T] &= 127, X[T] |= 64, X;
    }), Y(O, "priv", function() {
      return this.eddsa.decodeInt(this.privBytes());
    }), Y(O, "hash", function() {
      return this.eddsa.hash().update(this.secret()).digest();
    }), Y(O, "messagePrefix", function() {
      return this.hash().slice(this.eddsa.encodingLength);
    }), O.prototype.sign = function(z) {
      return P(this._secret, "KeyPair can only verify"), this.eddsa.sign(z, this);
    }, O.prototype.verify = function(z, J) {
      return this.eddsa.verify(z, J, this);
    }, O.prototype.getSecret = function(z) {
      return P(this._secret, "KeyPair is public only"), K.encode(this.secret(), z);
    }, O.prototype.getPublic = function(z) {
      return K.encode(this.pubBytes(), z);
    }, q.exports = O;
  }), Ao = r$(($, q) => {
    var K = CK(), P = M8(), _ = P.assert, Y = P.cachedProperty, O = P.parseBytes;
    function z(J, T) {
      if (this.eddsa = J, typeof T !== "object") T = O(T);
      if (Array.isArray(T)) _(T.length === J.encodingLength * 2, "Signature has invalid size"), T = { R: T.slice(0, J.encodingLength), S: T.slice(J.encodingLength) };
      if (_(T.R && T.S, "Signature without R or S"), J.isPoint(T.R)) this._R = T.R;
      if (T.S instanceof K) this._S = T.S;
      this._Rencoded = Array.isArray(T.R) ? T.R : T.Rencoded, this._Sencoded = Array.isArray(T.S) ? T.S : T.Sencoded;
    }
    __name(z, "z");
    Y(z, "S", function() {
      return this.eddsa.decodeInt(this.Sencoded());
    }), Y(z, "R", function() {
      return this.eddsa.decodePoint(this.Rencoded());
    }), Y(z, "Rencoded", function() {
      return this.eddsa.encodePoint(this.R());
    }), Y(z, "Sencoded", function() {
      return this.eddsa.encodeInt(this.S());
    }), z.prototype.toBytes = function() {
      return this.Rencoded().concat(this.Sencoded());
    }, z.prototype.toHex = function() {
      return P.encode(this.toBytes(), "hex").toUpperCase();
    }, q.exports = z;
  }), ko = r$(($, q) => {
    var K = iH(), P = tH(), _ = M8(), Y = _.assert, O = _.parseBytes, z = Xo(), J = Ao();
    function T(X) {
      if (Y(X === "ed25519", "only tested with ed25519 so far"), !(this instanceof T)) return new T(X);
      X = P[X].curve, this.curve = X, this.g = X.g, this.g.precompute(X.n.bitLength() + 1), this.pointClass = X.point().constructor, this.encodingLength = Math.ceil(X.n.bitLength() / 8), this.hash = K.sha512;
    }
    __name(T, "T");
    q.exports = T, T.prototype.sign = function(X, f) {
      X = O(X);
      var V = this.keyFromSecret(f), M = this.hashInt(V.messagePrefix(), X), N = this.g.mul(M), E = this.encodePoint(N), h = this.hashInt(E, V.pubBytes(), X).mul(V.priv()), I = M.add(h).umod(this.curve.n);
      return this.makeSignature({ R: N, S: I, Rencoded: E });
    }, T.prototype.verify = function(X, f, V) {
      if (X = O(X), f = this.makeSignature(f), f.S().gte(f.eddsa.curve.n) || f.S().isNeg()) return false;
      var M = this.keyFromPublic(V), N = this.hashInt(f.Rencoded(), M.pubBytes(), X), E = this.g.mul(f.S()), h = f.R().add(M.pub().mul(N));
      return h.eq(E);
    }, T.prototype.hashInt = function() {
      var X = this.hash();
      for (var f = 0; f < arguments.length; f++) X.update(arguments[f]);
      return _.intFromLE(X.digest()).umod(this.curve.n);
    }, T.prototype.keyFromPublic = function(X) {
      return z.fromPublic(this, X);
    }, T.prototype.keyFromSecret = function(X) {
      return z.fromSecret(this, X);
    }, T.prototype.makeSignature = function(X) {
      if (X instanceof J) return X;
      return new J(this, X);
    }, T.prototype.encodePoint = function(X) {
      var f = X.getY().toArray("le", this.encodingLength);
      return f[this.encodingLength - 1] |= X.getX().isOdd() ? 128 : 0, f;
    }, T.prototype.decodePoint = function(X) {
      X = _.parseBytes(X);
      var f = X.length - 1, V = X.slice(0, f).concat(X[f] & -129), M = (X[f] & 128) !== 0, N = _.intFromLE(V);
      return this.curve.pointFromY(N, M);
    }, T.prototype.encodeInt = function(X) {
      return X.toArray("le", this.encodingLength);
    }, T.prototype.decodeInt = function(X) {
      return _.intFromLE(X);
    }, T.prototype.isPoint = function(X) {
      return X instanceof this.pointClass;
    };
  }), Go = r$(($) => {
    var q = $;
    q.version = qo().version, q.utils = M8(), q.rand = W0(), q.curve = H0(), q.curves = tH(), q.ec = Zo(), q.eddsa = ko();
  }), Vo = r$(($, q) => {
    (function(K, P) {
      function _(j, H) {
        if (!j) throw Error(H || "Assertion failed");
      }
      __name(_, "_");
      function Y(j, H) {
        j.super_ = H;
        var Z = /* @__PURE__ */ __name(function() {
        }, "Z");
        Z.prototype = H.prototype, j.prototype = new Z(), j.prototype.constructor = j;
      }
      __name(Y, "Y");
      function O(j, H, Z) {
        if (O.isBN(j)) return j;
        if (this.negative = 0, this.words = null, this.length = 0, this.red = null, j !== null) {
          if (H === "le" || H === "be") Z = H, H = 10;
          this._init(j || 0, H || 10, Z || "be");
        }
      }
      __name(O, "O");
      if (typeof K === "object") K.exports = O;
      else P.BN = O;
      O.BN = O, O.wordSize = 26;
      var z;
      try {
        if (typeof window < "u" && typeof window.Buffer < "u") z = window.Buffer;
        else z = (fq(), J6(wq)).Buffer;
      } catch (j) {
      }
      O.isBN = function(j) {
        if (j instanceof O) return true;
        return j !== null && typeof j === "object" && j.constructor.wordSize === O.wordSize && Array.isArray(j.words);
      }, O.max = function(j, H) {
        if (j.cmp(H) > 0) return j;
        return H;
      }, O.min = function(j, H) {
        if (j.cmp(H) < 0) return j;
        return H;
      }, O.prototype._init = function(j, H, Z) {
        if (typeof j === "number") return this._initNumber(j, H, Z);
        if (typeof j === "object") return this._initArray(j, H, Z);
        if (H === "hex") H = 16;
        _(H === (H | 0) && H >= 2 && H <= 36), j = j.toString().replace(/\s+/g, "");
        var W = 0;
        if (j[0] === "-") W++, this.negative = 1;
        if (W < j.length) {
          if (H === 16) this._parseHex(j, W, Z);
          else if (this._parseBase(j, H, W), Z === "le") this._initArray(this.toArray(), H, Z);
        }
      }, O.prototype._initNumber = function(j, H, Z) {
        if (j < 0) this.negative = 1, j = -j;
        if (j < 67108864) this.words = [j & 67108863], this.length = 1;
        else if (j < 4503599627370496) this.words = [j & 67108863, j / 67108864 & 67108863], this.length = 2;
        else _(j < 9007199254740992), this.words = [j & 67108863, j / 67108864 & 67108863, 1], this.length = 3;
        if (Z !== "le") return;
        this._initArray(this.toArray(), H, Z);
      }, O.prototype._initArray = function(j, H, Z) {
        if (_(typeof j.length === "number"), j.length <= 0) return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(j.length / 3), this.words = Array(this.length);
        for (var W = 0; W < this.length; W++) this.words[W] = 0;
        var w, G, S = 0;
        if (Z === "be") {
          for (W = j.length - 1, w = 0; W >= 0; W -= 3) if (G = j[W] | j[W - 1] << 8 | j[W - 2] << 16, this.words[w] |= G << S & 67108863, this.words[w + 1] = G >>> 26 - S & 67108863, S += 24, S >= 26) S -= 26, w++;
        } else if (Z === "le") {
          for (W = 0, w = 0; W < j.length; W += 3) if (G = j[W] | j[W + 1] << 8 | j[W + 2] << 16, this.words[w] |= G << S & 67108863, this.words[w + 1] = G >>> 26 - S & 67108863, S += 24, S >= 26) S -= 26, w++;
        }
        return this.strip();
      };
      function J(j, H) {
        var Z = j.charCodeAt(H);
        if (Z >= 65 && Z <= 70) return Z - 55;
        else if (Z >= 97 && Z <= 102) return Z - 87;
        else return Z - 48 & 15;
      }
      __name(J, "J");
      function T(j, H, Z) {
        var W = J(j, Z);
        if (Z - 1 >= H) W |= J(j, Z - 1) << 4;
        return W;
      }
      __name(T, "T");
      O.prototype._parseHex = function(j, H, Z) {
        this.length = Math.ceil((j.length - H) / 6), this.words = Array(this.length);
        for (var W = 0; W < this.length; W++) this.words[W] = 0;
        var w = 0, G = 0, S;
        if (Z === "be") for (W = j.length - 1; W >= H; W -= 2) if (S = T(j, H, W) << w, this.words[G] |= S & 67108863, w >= 18) w -= 18, G += 1, this.words[G] |= S >>> 26;
        else w += 8;
        else {
          var A = j.length - H;
          for (W = A % 2 === 0 ? H + 1 : H; W < j.length; W += 2) if (S = T(j, H, W) << w, this.words[G] |= S & 67108863, w >= 18) w -= 18, G += 1, this.words[G] |= S >>> 26;
          else w += 8;
        }
        this.strip();
      };
      function X(j, H, Z, W) {
        var w = 0, G = Math.min(j.length, Z);
        for (var S = H; S < G; S++) {
          var A = j.charCodeAt(S) - 48;
          if (w *= W, A >= 49) w += A - 49 + 10;
          else if (A >= 17) w += A - 17 + 10;
          else w += A;
        }
        return w;
      }
      __name(X, "X");
      O.prototype._parseBase = function(j, H, Z) {
        this.words = [0], this.length = 1;
        for (var W = 0, w = 1; w <= 67108863; w *= H) W++;
        W--, w = w / H | 0;
        var G = j.length - Z, S = G % W, A = Math.min(G, G - S) + Z, v = 0;
        for (var k = Z; k < A; k += W) if (v = X(j, k, k + W, H), this.imuln(w), this.words[0] + v < 67108864) this.words[0] += v;
        else this._iaddn(v);
        if (S !== 0) {
          var R = 1;
          v = X(j, k, j.length, H);
          for (k = 0; k < S; k++) R *= H;
          if (this.imuln(R), this.words[0] + v < 67108864) this.words[0] += v;
          else this._iaddn(v);
        }
        this.strip();
      }, O.prototype.copy = function(j) {
        j.words = Array(this.length);
        for (var H = 0; H < this.length; H++) j.words[H] = this.words[H];
        j.length = this.length, j.negative = this.negative, j.red = this.red;
      }, O.prototype.clone = function() {
        var j = new O(null);
        return this.copy(j), j;
      }, O.prototype._expand = function(j) {
        while (this.length < j) this.words[this.length++] = 0;
        return this;
      }, O.prototype.strip = function() {
        while (this.length > 1 && this.words[this.length - 1] === 0) this.length--;
        return this._normSign();
      }, O.prototype._normSign = function() {
        if (this.length === 1 && this.words[0] === 0) this.negative = 0;
        return this;
      }, O.prototype.inspect = function() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var f = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], V = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], M = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
      if (O.prototype.toString = function(j, H) {
        j = j || 10, H = H | 0 || 1;
        var Z;
        if (j === 16 || j === "hex") {
          Z = "";
          var W = 0, w = 0;
          for (var G = 0; G < this.length; G++) {
            var S = this.words[G], A = ((S << W | w) & 16777215).toString(16);
            if (w = S >>> 24 - W & 16777215, W += 2, W >= 26) W -= 26, G--;
            if (w !== 0 || G !== this.length - 1) Z = f[6 - A.length] + A + Z;
            else Z = A + Z;
          }
          if (w !== 0) Z = w.toString(16) + Z;
          while (Z.length % H !== 0) Z = "0" + Z;
          if (this.negative !== 0) Z = "-" + Z;
          return Z;
        }
        if (j === (j | 0) && j >= 2 && j <= 36) {
          var v = V[j], k = M[j];
          Z = "";
          var R = this.clone();
          R.negative = 0;
          while (!R.isZero()) {
            var C = R.modn(k).toString(j);
            if (R = R.idivn(k), !R.isZero()) Z = f[v - C.length] + C + Z;
            else Z = C + Z;
          }
          if (this.isZero()) Z = "0" + Z;
          while (Z.length % H !== 0) Z = "0" + Z;
          if (this.negative !== 0) Z = "-" + Z;
          return Z;
        }
        _(false, "Base should be between 2 and 36");
      }, O.prototype.toNumber = function() {
        var j = this.words[0];
        if (this.length === 2) j += this.words[1] * 67108864;
        else if (this.length === 3 && this.words[2] === 1) j += 4503599627370496 + this.words[1] * 67108864;
        else if (this.length > 2) _(false, "Number can only safely store up to 53 bits");
        return this.negative !== 0 ? -j : j;
      }, O.prototype.toJSON = function() {
        return this.toString(16);
      }, O.prototype.toBuffer = function(j, H) {
        return _(typeof z < "u"), this.toArrayLike(z, j, H);
      }, O.prototype.toArray = function(j, H) {
        return this.toArrayLike(Array, j, H);
      }, O.prototype.toArrayLike = function(j, H, Z) {
        var W = this.byteLength(), w = Z || Math.max(1, W);
        _(W <= w, "byte array longer than desired length"), _(w > 0, "Requested array length <= 0"), this.strip();
        var G = H === "le", S = new j(w), A, v, k = this.clone();
        if (!G) {
          for (v = 0; v < w - W; v++) S[v] = 0;
          for (v = 0; !k.isZero(); v++) A = k.andln(255), k.iushrn(8), S[w - v - 1] = A;
        } else {
          for (v = 0; !k.isZero(); v++) A = k.andln(255), k.iushrn(8), S[v] = A;
          for (; v < w; v++) S[v] = 0;
        }
        return S;
      }, Math.clz32) O.prototype._countBits = function(j) {
        return 32 - Math.clz32(j);
      };
      else O.prototype._countBits = function(j) {
        var H = j, Z = 0;
        if (H >= 4096) Z += 13, H >>>= 13;
        if (H >= 64) Z += 7, H >>>= 7;
        if (H >= 8) Z += 4, H >>>= 4;
        if (H >= 2) Z += 2, H >>>= 2;
        return Z + H;
      };
      O.prototype._zeroBits = function(j) {
        if (j === 0) return 26;
        var H = j, Z = 0;
        if ((H & 8191) === 0) Z += 13, H >>>= 13;
        if ((H & 127) === 0) Z += 7, H >>>= 7;
        if ((H & 15) === 0) Z += 4, H >>>= 4;
        if ((H & 3) === 0) Z += 2, H >>>= 2;
        if ((H & 1) === 0) Z++;
        return Z;
      }, O.prototype.bitLength = function() {
        var j = this.words[this.length - 1], H = this._countBits(j);
        return (this.length - 1) * 26 + H;
      };
      function N(j) {
        var H = Array(j.bitLength());
        for (var Z = 0; Z < H.length; Z++) {
          var W = Z / 26 | 0, w = Z % 26;
          H[Z] = (j.words[W] & 1 << w) >>> w;
        }
        return H;
      }
      __name(N, "N");
      O.prototype.zeroBits = function() {
        if (this.isZero()) return 0;
        var j = 0;
        for (var H = 0; H < this.length; H++) {
          var Z = this._zeroBits(this.words[H]);
          if (j += Z, Z !== 26) break;
        }
        return j;
      }, O.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, O.prototype.toTwos = function(j) {
        if (this.negative !== 0) return this.abs().inotn(j).iaddn(1);
        return this.clone();
      }, O.prototype.fromTwos = function(j) {
        if (this.testn(j - 1)) return this.notn(j).iaddn(1).ineg();
        return this.clone();
      }, O.prototype.isNeg = function() {
        return this.negative !== 0;
      }, O.prototype.neg = function() {
        return this.clone().ineg();
      }, O.prototype.ineg = function() {
        if (!this.isZero()) this.negative ^= 1;
        return this;
      }, O.prototype.iuor = function(j) {
        while (this.length < j.length) this.words[this.length++] = 0;
        for (var H = 0; H < j.length; H++) this.words[H] = this.words[H] | j.words[H];
        return this.strip();
      }, O.prototype.ior = function(j) {
        return _((this.negative | j.negative) === 0), this.iuor(j);
      }, O.prototype.or = function(j) {
        if (this.length > j.length) return this.clone().ior(j);
        return j.clone().ior(this);
      }, O.prototype.uor = function(j) {
        if (this.length > j.length) return this.clone().iuor(j);
        return j.clone().iuor(this);
      }, O.prototype.iuand = function(j) {
        var H;
        if (this.length > j.length) H = j;
        else H = this;
        for (var Z = 0; Z < H.length; Z++) this.words[Z] = this.words[Z] & j.words[Z];
        return this.length = H.length, this.strip();
      }, O.prototype.iand = function(j) {
        return _((this.negative | j.negative) === 0), this.iuand(j);
      }, O.prototype.and = function(j) {
        if (this.length > j.length) return this.clone().iand(j);
        return j.clone().iand(this);
      }, O.prototype.uand = function(j) {
        if (this.length > j.length) return this.clone().iuand(j);
        return j.clone().iuand(this);
      }, O.prototype.iuxor = function(j) {
        var H, Z;
        if (this.length > j.length) H = this, Z = j;
        else H = j, Z = this;
        for (var W = 0; W < Z.length; W++) this.words[W] = H.words[W] ^ Z.words[W];
        if (this !== H) for (; W < H.length; W++) this.words[W] = H.words[W];
        return this.length = H.length, this.strip();
      }, O.prototype.ixor = function(j) {
        return _((this.negative | j.negative) === 0), this.iuxor(j);
      }, O.prototype.xor = function(j) {
        if (this.length > j.length) return this.clone().ixor(j);
        return j.clone().ixor(this);
      }, O.prototype.uxor = function(j) {
        if (this.length > j.length) return this.clone().iuxor(j);
        return j.clone().iuxor(this);
      }, O.prototype.inotn = function(j) {
        _(typeof j === "number" && j >= 0);
        var H = Math.ceil(j / 26) | 0, Z = j % 26;
        if (this._expand(H), Z > 0) H--;
        for (var W = 0; W < H; W++) this.words[W] = ~this.words[W] & 67108863;
        if (Z > 0) this.words[W] = ~this.words[W] & 67108863 >> 26 - Z;
        return this.strip();
      }, O.prototype.notn = function(j) {
        return this.clone().inotn(j);
      }, O.prototype.setn = function(j, H) {
        _(typeof j === "number" && j >= 0);
        var Z = j / 26 | 0, W = j % 26;
        if (this._expand(Z + 1), H) this.words[Z] = this.words[Z] | 1 << W;
        else this.words[Z] = this.words[Z] & ~(1 << W);
        return this.strip();
      }, O.prototype.iadd = function(j) {
        var H;
        if (this.negative !== 0 && j.negative === 0) return this.negative = 0, H = this.isub(j), this.negative ^= 1, this._normSign();
        else if (this.negative === 0 && j.negative !== 0) return j.negative = 0, H = this.isub(j), j.negative = 1, H._normSign();
        var Z, W;
        if (this.length > j.length) Z = this, W = j;
        else Z = j, W = this;
        var w = 0;
        for (var G = 0; G < W.length; G++) H = (Z.words[G] | 0) + (W.words[G] | 0) + w, this.words[G] = H & 67108863, w = H >>> 26;
        for (; w !== 0 && G < Z.length; G++) H = (Z.words[G] | 0) + w, this.words[G] = H & 67108863, w = H >>> 26;
        if (this.length = Z.length, w !== 0) this.words[this.length] = w, this.length++;
        else if (Z !== this) for (; G < Z.length; G++) this.words[G] = Z.words[G];
        return this;
      }, O.prototype.add = function(j) {
        var H;
        if (j.negative !== 0 && this.negative === 0) return j.negative = 0, H = this.sub(j), j.negative ^= 1, H;
        else if (j.negative === 0 && this.negative !== 0) return this.negative = 0, H = j.sub(this), this.negative = 1, H;
        if (this.length > j.length) return this.clone().iadd(j);
        return j.clone().iadd(this);
      }, O.prototype.isub = function(j) {
        if (j.negative !== 0) {
          j.negative = 0;
          var H = this.iadd(j);
          return j.negative = 1, H._normSign();
        } else if (this.negative !== 0) return this.negative = 0, this.iadd(j), this.negative = 1, this._normSign();
        var Z = this.cmp(j);
        if (Z === 0) return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var W, w;
        if (Z > 0) W = this, w = j;
        else W = j, w = this;
        var G = 0;
        for (var S = 0; S < w.length; S++) H = (W.words[S] | 0) - (w.words[S] | 0) + G, G = H >> 26, this.words[S] = H & 67108863;
        for (; G !== 0 && S < W.length; S++) H = (W.words[S] | 0) + G, G = H >> 26, this.words[S] = H & 67108863;
        if (G === 0 && S < W.length && W !== this) for (; S < W.length; S++) this.words[S] = W.words[S];
        if (this.length = Math.max(this.length, S), W !== this) this.negative = 1;
        return this.strip();
      }, O.prototype.sub = function(j) {
        return this.clone().isub(j);
      };
      function E(j, H, Z) {
        Z.negative = H.negative ^ j.negative;
        var W = j.length + H.length | 0;
        Z.length = W, W = W - 1 | 0;
        var w = j.words[0] | 0, G = H.words[0] | 0, S = w * G, A = S & 67108863, v = S / 67108864 | 0;
        Z.words[0] = A;
        for (var k = 1; k < W; k++) {
          var R = v >>> 26, C = v & 67108863, L = Math.min(k, H.length - 1);
          for (var x = Math.max(0, k - j.length + 1); x <= L; x++) {
            var l = k - x | 0;
            w = j.words[l] | 0, G = H.words[x] | 0, S = w * G + C, R += S / 67108864 | 0, C = S & 67108863;
          }
          Z.words[k] = C | 0, v = R | 0;
        }
        if (v !== 0) Z.words[k] = v | 0;
        else Z.length--;
        return Z.strip();
      }
      __name(E, "E");
      var h = /* @__PURE__ */ __name(function(j, H, Z) {
        var W = j.words, w = H.words, G = Z.words, S = 0, A, v, k, R = W[0] | 0, C = R & 8191, L = R >>> 13, x = W[1] | 0, l = x & 8191, a = x >>> 13, f$ = W[2] | 0, $$ = f$ & 8191, t = f$ >>> 13, H$ = W[3] | 0, Q = H$ & 8191, v$ = H$ >>> 13, B$ = W[4] | 0, m = B$ & 8191, r = B$ >>> 13, J$ = W[5] | 0, e = J$ & 8191, _$2 = J$ >>> 13, Y$ = W[6] | 0, d = Y$ & 8191, o = Y$ >>> 13, W$ = W[7] | 0, B = W$ & 8191, F = W$ >>> 13, X$ = W[8] | 0, z$ = X$ & 8191, j$ = X$ >>> 13, X6 = W[9] | 0, Z$ = X6 & 8191, A$ = X6 >>> 13, l6 = w[0] | 0, S$ = l6 & 8191, V$ = l6 >>> 13, Mq = w[1] | 0, N$ = Mq & 8191, D$ = Mq >>> 13, Nq = w[2] | 0, L$ = Nq & 8191, C$ = Nq >>> 13, Zq = w[3] | 0, g$ = Zq & 8191, h$ = Zq >>> 13, zq = w[4] | 0, b$ = zq & 8191, y$ = zq >>> 13, Wq = w[5] | 0, E$ = Wq & 8191, u = Wq >>> 13, i = w[6] | 0, K$ = i & 8191, P$ = i >>> 13, i$ = w[7] | 0, k$ = i$ & 8191, G$ = i$ >>> 13, x6 = w[8] | 0, R$ = x6 & 8191, u$ = x6 >>> 13, Xq = w[9] | 0, I$ = Xq & 8191, M$ = Xq >>> 13;
        Z.negative = j.negative ^ H.negative, Z.length = 19, A = Math.imul(C, S$), v = Math.imul(C, V$), v = v + Math.imul(L, S$) | 0, k = Math.imul(L, V$);
        var p6 = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (p6 >>> 26) | 0, p6 &= 67108863, A = Math.imul(l, S$), v = Math.imul(l, V$), v = v + Math.imul(a, S$) | 0, k = Math.imul(a, V$), A = A + Math.imul(C, N$) | 0, v = v + Math.imul(C, D$) | 0, v = v + Math.imul(L, N$) | 0, k = k + Math.imul(L, D$) | 0;
        var H6 = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (H6 >>> 26) | 0, H6 &= 67108863, A = Math.imul($$, S$), v = Math.imul($$, V$), v = v + Math.imul(t, S$) | 0, k = Math.imul(t, V$), A = A + Math.imul(l, N$) | 0, v = v + Math.imul(l, D$) | 0, v = v + Math.imul(a, N$) | 0, k = k + Math.imul(a, D$) | 0, A = A + Math.imul(C, L$) | 0, v = v + Math.imul(C, C$) | 0, v = v + Math.imul(L, L$) | 0, k = k + Math.imul(L, C$) | 0;
        var v6 = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (v6 >>> 26) | 0, v6 &= 67108863, A = Math.imul(Q, S$), v = Math.imul(Q, V$), v = v + Math.imul(v$, S$) | 0, k = Math.imul(v$, V$), A = A + Math.imul($$, N$) | 0, v = v + Math.imul($$, D$) | 0, v = v + Math.imul(t, N$) | 0, k = k + Math.imul(t, D$) | 0, A = A + Math.imul(l, L$) | 0, v = v + Math.imul(l, C$) | 0, v = v + Math.imul(a, L$) | 0, k = k + Math.imul(a, C$) | 0, A = A + Math.imul(C, g$) | 0, v = v + Math.imul(C, h$) | 0, v = v + Math.imul(L, g$) | 0, k = k + Math.imul(L, h$) | 0;
        var C6 = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (C6 >>> 26) | 0, C6 &= 67108863, A = Math.imul(m, S$), v = Math.imul(m, V$), v = v + Math.imul(r, S$) | 0, k = Math.imul(r, V$), A = A + Math.imul(Q, N$) | 0, v = v + Math.imul(Q, D$) | 0, v = v + Math.imul(v$, N$) | 0, k = k + Math.imul(v$, D$) | 0, A = A + Math.imul($$, L$) | 0, v = v + Math.imul($$, C$) | 0, v = v + Math.imul(t, L$) | 0, k = k + Math.imul(t, C$) | 0, A = A + Math.imul(l, g$) | 0, v = v + Math.imul(l, h$) | 0, v = v + Math.imul(a, g$) | 0, k = k + Math.imul(a, h$) | 0, A = A + Math.imul(C, b$) | 0, v = v + Math.imul(C, y$) | 0, v = v + Math.imul(L, b$) | 0, k = k + Math.imul(L, y$) | 0;
        var S6 = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (S6 >>> 26) | 0, S6 &= 67108863, A = Math.imul(e, S$), v = Math.imul(e, V$), v = v + Math.imul(_$2, S$) | 0, k = Math.imul(_$2, V$), A = A + Math.imul(m, N$) | 0, v = v + Math.imul(m, D$) | 0, v = v + Math.imul(r, N$) | 0, k = k + Math.imul(r, D$) | 0, A = A + Math.imul(Q, L$) | 0, v = v + Math.imul(Q, C$) | 0, v = v + Math.imul(v$, L$) | 0, k = k + Math.imul(v$, C$) | 0, A = A + Math.imul($$, g$) | 0, v = v + Math.imul($$, h$) | 0, v = v + Math.imul(t, g$) | 0, k = k + Math.imul(t, h$) | 0, A = A + Math.imul(l, b$) | 0, v = v + Math.imul(l, y$) | 0, v = v + Math.imul(a, b$) | 0, k = k + Math.imul(a, y$) | 0, A = A + Math.imul(C, E$) | 0, v = v + Math.imul(C, u) | 0, v = v + Math.imul(L, E$) | 0, k = k + Math.imul(L, u) | 0;
        var t6 = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (t6 >>> 26) | 0, t6 &= 67108863, A = Math.imul(d, S$), v = Math.imul(d, V$), v = v + Math.imul(o, S$) | 0, k = Math.imul(o, V$), A = A + Math.imul(e, N$) | 0, v = v + Math.imul(e, D$) | 0, v = v + Math.imul(_$2, N$) | 0, k = k + Math.imul(_$2, D$) | 0, A = A + Math.imul(m, L$) | 0, v = v + Math.imul(m, C$) | 0, v = v + Math.imul(r, L$) | 0, k = k + Math.imul(r, C$) | 0, A = A + Math.imul(Q, g$) | 0, v = v + Math.imul(Q, h$) | 0, v = v + Math.imul(v$, g$) | 0, k = k + Math.imul(v$, h$) | 0, A = A + Math.imul($$, b$) | 0, v = v + Math.imul($$, y$) | 0, v = v + Math.imul(t, b$) | 0, k = k + Math.imul(t, y$) | 0, A = A + Math.imul(l, E$) | 0, v = v + Math.imul(l, u) | 0, v = v + Math.imul(a, E$) | 0, k = k + Math.imul(a, u) | 0, A = A + Math.imul(C, K$) | 0, v = v + Math.imul(C, P$) | 0, v = v + Math.imul(L, K$) | 0, k = k + Math.imul(L, P$) | 0;
        var B6 = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (B6 >>> 26) | 0, B6 &= 67108863, A = Math.imul(B, S$), v = Math.imul(B, V$), v = v + Math.imul(F, S$) | 0, k = Math.imul(F, V$), A = A + Math.imul(d, N$) | 0, v = v + Math.imul(d, D$) | 0, v = v + Math.imul(o, N$) | 0, k = k + Math.imul(o, D$) | 0, A = A + Math.imul(e, L$) | 0, v = v + Math.imul(e, C$) | 0, v = v + Math.imul(_$2, L$) | 0, k = k + Math.imul(_$2, C$) | 0, A = A + Math.imul(m, g$) | 0, v = v + Math.imul(m, h$) | 0, v = v + Math.imul(r, g$) | 0, k = k + Math.imul(r, h$) | 0, A = A + Math.imul(Q, b$) | 0, v = v + Math.imul(Q, y$) | 0, v = v + Math.imul(v$, b$) | 0, k = k + Math.imul(v$, y$) | 0, A = A + Math.imul($$, E$) | 0, v = v + Math.imul($$, u) | 0, v = v + Math.imul(t, E$) | 0, k = k + Math.imul(t, u) | 0, A = A + Math.imul(l, K$) | 0, v = v + Math.imul(l, P$) | 0, v = v + Math.imul(a, K$) | 0, k = k + Math.imul(a, P$) | 0, A = A + Math.imul(C, k$) | 0, v = v + Math.imul(C, G$) | 0, v = v + Math.imul(L, k$) | 0, k = k + Math.imul(L, G$) | 0;
        var U6 = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (U6 >>> 26) | 0, U6 &= 67108863, A = Math.imul(z$, S$), v = Math.imul(z$, V$), v = v + Math.imul(j$, S$) | 0, k = Math.imul(j$, V$), A = A + Math.imul(B, N$) | 0, v = v + Math.imul(B, D$) | 0, v = v + Math.imul(F, N$) | 0, k = k + Math.imul(F, D$) | 0, A = A + Math.imul(d, L$) | 0, v = v + Math.imul(d, C$) | 0, v = v + Math.imul(o, L$) | 0, k = k + Math.imul(o, C$) | 0, A = A + Math.imul(e, g$) | 0, v = v + Math.imul(e, h$) | 0, v = v + Math.imul(_$2, g$) | 0, k = k + Math.imul(_$2, h$) | 0, A = A + Math.imul(m, b$) | 0, v = v + Math.imul(m, y$) | 0, v = v + Math.imul(r, b$) | 0, k = k + Math.imul(r, y$) | 0, A = A + Math.imul(Q, E$) | 0, v = v + Math.imul(Q, u) | 0, v = v + Math.imul(v$, E$) | 0, k = k + Math.imul(v$, u) | 0, A = A + Math.imul($$, K$) | 0, v = v + Math.imul($$, P$) | 0, v = v + Math.imul(t, K$) | 0, k = k + Math.imul(t, P$) | 0, A = A + Math.imul(l, k$) | 0, v = v + Math.imul(l, G$) | 0, v = v + Math.imul(a, k$) | 0, k = k + Math.imul(a, G$) | 0, A = A + Math.imul(C, R$) | 0, v = v + Math.imul(C, u$) | 0, v = v + Math.imul(L, R$) | 0, k = k + Math.imul(L, u$) | 0;
        var F6 = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (F6 >>> 26) | 0, F6 &= 67108863, A = Math.imul(Z$, S$), v = Math.imul(Z$, V$), v = v + Math.imul(A$, S$) | 0, k = Math.imul(A$, V$), A = A + Math.imul(z$, N$) | 0, v = v + Math.imul(z$, D$) | 0, v = v + Math.imul(j$, N$) | 0, k = k + Math.imul(j$, D$) | 0, A = A + Math.imul(B, L$) | 0, v = v + Math.imul(B, C$) | 0, v = v + Math.imul(F, L$) | 0, k = k + Math.imul(F, C$) | 0, A = A + Math.imul(d, g$) | 0, v = v + Math.imul(d, h$) | 0, v = v + Math.imul(o, g$) | 0, k = k + Math.imul(o, h$) | 0, A = A + Math.imul(e, b$) | 0, v = v + Math.imul(e, y$) | 0, v = v + Math.imul(_$2, b$) | 0, k = k + Math.imul(_$2, y$) | 0, A = A + Math.imul(m, E$) | 0, v = v + Math.imul(m, u) | 0, v = v + Math.imul(r, E$) | 0, k = k + Math.imul(r, u) | 0, A = A + Math.imul(Q, K$) | 0, v = v + Math.imul(Q, P$) | 0, v = v + Math.imul(v$, K$) | 0, k = k + Math.imul(v$, P$) | 0, A = A + Math.imul($$, k$) | 0, v = v + Math.imul($$, G$) | 0, v = v + Math.imul(t, k$) | 0, k = k + Math.imul(t, G$) | 0, A = A + Math.imul(l, R$) | 0, v = v + Math.imul(l, u$) | 0, v = v + Math.imul(a, R$) | 0, k = k + Math.imul(a, u$) | 0, A = A + Math.imul(C, I$) | 0, v = v + Math.imul(C, M$) | 0, v = v + Math.imul(L, I$) | 0, k = k + Math.imul(L, M$) | 0;
        var a6 = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (a6 >>> 26) | 0, a6 &= 67108863, A = Math.imul(Z$, N$), v = Math.imul(Z$, D$), v = v + Math.imul(A$, N$) | 0, k = Math.imul(A$, D$), A = A + Math.imul(z$, L$) | 0, v = v + Math.imul(z$, C$) | 0, v = v + Math.imul(j$, L$) | 0, k = k + Math.imul(j$, C$) | 0, A = A + Math.imul(B, g$) | 0, v = v + Math.imul(B, h$) | 0, v = v + Math.imul(F, g$) | 0, k = k + Math.imul(F, h$) | 0, A = A + Math.imul(d, b$) | 0, v = v + Math.imul(d, y$) | 0, v = v + Math.imul(o, b$) | 0, k = k + Math.imul(o, y$) | 0, A = A + Math.imul(e, E$) | 0, v = v + Math.imul(e, u) | 0, v = v + Math.imul(_$2, E$) | 0, k = k + Math.imul(_$2, u) | 0, A = A + Math.imul(m, K$) | 0, v = v + Math.imul(m, P$) | 0, v = v + Math.imul(r, K$) | 0, k = k + Math.imul(r, P$) | 0, A = A + Math.imul(Q, k$) | 0, v = v + Math.imul(Q, G$) | 0, v = v + Math.imul(v$, k$) | 0, k = k + Math.imul(v$, G$) | 0, A = A + Math.imul($$, R$) | 0, v = v + Math.imul($$, u$) | 0, v = v + Math.imul(t, R$) | 0, k = k + Math.imul(t, u$) | 0, A = A + Math.imul(l, I$) | 0, v = v + Math.imul(l, M$) | 0, v = v + Math.imul(a, I$) | 0, k = k + Math.imul(a, M$) | 0;
        var Q6 = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (Q6 >>> 26) | 0, Q6 &= 67108863, A = Math.imul(Z$, L$), v = Math.imul(Z$, C$), v = v + Math.imul(A$, L$) | 0, k = Math.imul(A$, C$), A = A + Math.imul(z$, g$) | 0, v = v + Math.imul(z$, h$) | 0, v = v + Math.imul(j$, g$) | 0, k = k + Math.imul(j$, h$) | 0, A = A + Math.imul(B, b$) | 0, v = v + Math.imul(B, y$) | 0, v = v + Math.imul(F, b$) | 0, k = k + Math.imul(F, y$) | 0, A = A + Math.imul(d, E$) | 0, v = v + Math.imul(d, u) | 0, v = v + Math.imul(o, E$) | 0, k = k + Math.imul(o, u) | 0, A = A + Math.imul(e, K$) | 0, v = v + Math.imul(e, P$) | 0, v = v + Math.imul(_$2, K$) | 0, k = k + Math.imul(_$2, P$) | 0, A = A + Math.imul(m, k$) | 0, v = v + Math.imul(m, G$) | 0, v = v + Math.imul(r, k$) | 0, k = k + Math.imul(r, G$) | 0, A = A + Math.imul(Q, R$) | 0, v = v + Math.imul(Q, u$) | 0, v = v + Math.imul(v$, R$) | 0, k = k + Math.imul(v$, u$) | 0, A = A + Math.imul($$, I$) | 0, v = v + Math.imul($$, M$) | 0, v = v + Math.imul(t, I$) | 0, k = k + Math.imul(t, M$) | 0;
        var e6 = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (e6 >>> 26) | 0, e6 &= 67108863, A = Math.imul(Z$, g$), v = Math.imul(Z$, h$), v = v + Math.imul(A$, g$) | 0, k = Math.imul(A$, h$), A = A + Math.imul(z$, b$) | 0, v = v + Math.imul(z$, y$) | 0, v = v + Math.imul(j$, b$) | 0, k = k + Math.imul(j$, y$) | 0, A = A + Math.imul(B, E$) | 0, v = v + Math.imul(B, u) | 0, v = v + Math.imul(F, E$) | 0, k = k + Math.imul(F, u) | 0, A = A + Math.imul(d, K$) | 0, v = v + Math.imul(d, P$) | 0, v = v + Math.imul(o, K$) | 0, k = k + Math.imul(o, P$) | 0, A = A + Math.imul(e, k$) | 0, v = v + Math.imul(e, G$) | 0, v = v + Math.imul(_$2, k$) | 0, k = k + Math.imul(_$2, G$) | 0, A = A + Math.imul(m, R$) | 0, v = v + Math.imul(m, u$) | 0, v = v + Math.imul(r, R$) | 0, k = k + Math.imul(r, u$) | 0, A = A + Math.imul(Q, I$) | 0, v = v + Math.imul(Q, M$) | 0, v = v + Math.imul(v$, I$) | 0, k = k + Math.imul(v$, M$) | 0;
        var s6 = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (s6 >>> 26) | 0, s6 &= 67108863, A = Math.imul(Z$, b$), v = Math.imul(Z$, y$), v = v + Math.imul(A$, b$) | 0, k = Math.imul(A$, y$), A = A + Math.imul(z$, E$) | 0, v = v + Math.imul(z$, u) | 0, v = v + Math.imul(j$, E$) | 0, k = k + Math.imul(j$, u) | 0, A = A + Math.imul(B, K$) | 0, v = v + Math.imul(B, P$) | 0, v = v + Math.imul(F, K$) | 0, k = k + Math.imul(F, P$) | 0, A = A + Math.imul(d, k$) | 0, v = v + Math.imul(d, G$) | 0, v = v + Math.imul(o, k$) | 0, k = k + Math.imul(o, G$) | 0, A = A + Math.imul(e, R$) | 0, v = v + Math.imul(e, u$) | 0, v = v + Math.imul(_$2, R$) | 0, k = k + Math.imul(_$2, u$) | 0, A = A + Math.imul(m, I$) | 0, v = v + Math.imul(m, M$) | 0, v = v + Math.imul(r, I$) | 0, k = k + Math.imul(r, M$) | 0;
        var $q = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + ($q >>> 26) | 0, $q &= 67108863, A = Math.imul(Z$, E$), v = Math.imul(Z$, u), v = v + Math.imul(A$, E$) | 0, k = Math.imul(A$, u), A = A + Math.imul(z$, K$) | 0, v = v + Math.imul(z$, P$) | 0, v = v + Math.imul(j$, K$) | 0, k = k + Math.imul(j$, P$) | 0, A = A + Math.imul(B, k$) | 0, v = v + Math.imul(B, G$) | 0, v = v + Math.imul(F, k$) | 0, k = k + Math.imul(F, G$) | 0, A = A + Math.imul(d, R$) | 0, v = v + Math.imul(d, u$) | 0, v = v + Math.imul(o, R$) | 0, k = k + Math.imul(o, u$) | 0, A = A + Math.imul(e, I$) | 0, v = v + Math.imul(e, M$) | 0, v = v + Math.imul(_$2, I$) | 0, k = k + Math.imul(_$2, M$) | 0;
        var qq = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (qq >>> 26) | 0, qq &= 67108863, A = Math.imul(Z$, K$), v = Math.imul(Z$, P$), v = v + Math.imul(A$, K$) | 0, k = Math.imul(A$, P$), A = A + Math.imul(z$, k$) | 0, v = v + Math.imul(z$, G$) | 0, v = v + Math.imul(j$, k$) | 0, k = k + Math.imul(j$, G$) | 0, A = A + Math.imul(B, R$) | 0, v = v + Math.imul(B, u$) | 0, v = v + Math.imul(F, R$) | 0, k = k + Math.imul(F, u$) | 0, A = A + Math.imul(d, I$) | 0, v = v + Math.imul(d, M$) | 0, v = v + Math.imul(o, I$) | 0, k = k + Math.imul(o, M$) | 0;
        var Kq = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (Kq >>> 26) | 0, Kq &= 67108863, A = Math.imul(Z$, k$), v = Math.imul(Z$, G$), v = v + Math.imul(A$, k$) | 0, k = Math.imul(A$, G$), A = A + Math.imul(z$, R$) | 0, v = v + Math.imul(z$, u$) | 0, v = v + Math.imul(j$, R$) | 0, k = k + Math.imul(j$, u$) | 0, A = A + Math.imul(B, I$) | 0, v = v + Math.imul(B, M$) | 0, v = v + Math.imul(F, I$) | 0, k = k + Math.imul(F, M$) | 0;
        var _q = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (_q >>> 26) | 0, _q &= 67108863, A = Math.imul(Z$, R$), v = Math.imul(Z$, u$), v = v + Math.imul(A$, R$) | 0, k = Math.imul(A$, u$), A = A + Math.imul(z$, I$) | 0, v = v + Math.imul(z$, M$) | 0, v = v + Math.imul(j$, I$) | 0, k = k + Math.imul(j$, M$) | 0;
        var Pq = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (Pq >>> 26) | 0, Pq &= 67108863, A = Math.imul(Z$, I$), v = Math.imul(Z$, M$), v = v + Math.imul(A$, I$) | 0, k = Math.imul(A$, M$);
        var Oq = (S + A | 0) + ((v & 8191) << 13) | 0;
        if (S = (k + (v >>> 13) | 0) + (Oq >>> 26) | 0, Oq &= 67108863, G[0] = p6, G[1] = H6, G[2] = v6, G[3] = C6, G[4] = S6, G[5] = t6, G[6] = B6, G[7] = U6, G[8] = F6, G[9] = a6, G[10] = Q6, G[11] = e6, G[12] = s6, G[13] = $q, G[14] = qq, G[15] = Kq, G[16] = _q, G[17] = Pq, G[18] = Oq, S !== 0) G[19] = S, Z.length++;
        return Z;
      }, "h");
      if (!Math.imul) h = E;
      function I(j, H, Z) {
        Z.negative = H.negative ^ j.negative, Z.length = j.length + H.length;
        var W = 0, w = 0;
        for (var G = 0; G < Z.length - 1; G++) {
          var S = w;
          w = 0;
          var A = W & 67108863, v = Math.min(G, H.length - 1);
          for (var k = Math.max(0, G - j.length + 1); k <= v; k++) {
            var R = G - k, C = j.words[R] | 0, L = H.words[k] | 0, x = C * L, l = x & 67108863;
            S = S + (x / 67108864 | 0) | 0, l = l + A | 0, A = l & 67108863, S = S + (l >>> 26) | 0, w += S >>> 26, S &= 67108863;
          }
          Z.words[G] = A, W = S, S = w;
        }
        if (W !== 0) Z.words[G] = W;
        else Z.length--;
        return Z.strip();
      }
      __name(I, "I");
      function D(j, H, Z) {
        var W = new g();
        return W.mulp(j, H, Z);
      }
      __name(D, "D");
      O.prototype.mulTo = function(j, H) {
        var Z, W = this.length + j.length;
        if (this.length === 10 && j.length === 10) Z = h(this, j, H);
        else if (W < 63) Z = E(this, j, H);
        else if (W < 1024) Z = I(this, j, H);
        else Z = D(this, j, H);
        return Z;
      };
      function g(j, H) {
        this.x = j, this.y = H;
      }
      __name(g, "g");
      g.prototype.makeRBT = function(j) {
        var H = Array(j), Z = O.prototype._countBits(j) - 1;
        for (var W = 0; W < j; W++) H[W] = this.revBin(W, Z, j);
        return H;
      }, g.prototype.revBin = function(j, H, Z) {
        if (j === 0 || j === Z - 1) return j;
        var W = 0;
        for (var w = 0; w < H; w++) W |= (j & 1) << H - w - 1, j >>= 1;
        return W;
      }, g.prototype.permute = function(j, H, Z, W, w, G) {
        for (var S = 0; S < G; S++) W[S] = H[j[S]], w[S] = Z[j[S]];
      }, g.prototype.transform = function(j, H, Z, W, w, G) {
        this.permute(G, j, H, Z, W, w);
        for (var S = 1; S < w; S <<= 1) {
          var A = S << 1, v = Math.cos(2 * Math.PI / A), k = Math.sin(2 * Math.PI / A);
          for (var R = 0; R < w; R += A) {
            var C = v, L = k;
            for (var x = 0; x < S; x++) {
              var l = Z[R + x], a = W[R + x], f$ = Z[R + x + S], $$ = W[R + x + S], t = C * f$ - L * $$;
              if ($$ = C * $$ + L * f$, f$ = t, Z[R + x] = l + f$, W[R + x] = a + $$, Z[R + x + S] = l - f$, W[R + x + S] = a - $$, x !== A) t = v * C - k * L, L = v * L + k * C, C = t;
            }
          }
        }
      }, g.prototype.guessLen13b = function(j, H) {
        var Z = Math.max(H, j) | 1, W = Z & 1, w = 0;
        for (Z = Z / 2 | 0; Z; Z = Z >>> 1) w++;
        return 1 << w + 1 + W;
      }, g.prototype.conjugate = function(j, H, Z) {
        if (Z <= 1) return;
        for (var W = 0; W < Z / 2; W++) {
          var w = j[W];
          j[W] = j[Z - W - 1], j[Z - W - 1] = w, w = H[W], H[W] = -H[Z - W - 1], H[Z - W - 1] = -w;
        }
      }, g.prototype.normalize13b = function(j, H) {
        var Z = 0;
        for (var W = 0; W < H / 2; W++) {
          var w = Math.round(j[2 * W + 1] / H) * 8192 + Math.round(j[2 * W] / H) + Z;
          if (j[W] = w & 67108863, w < 67108864) Z = 0;
          else Z = w / 67108864 | 0;
        }
        return j;
      }, g.prototype.convert13b = function(j, H, Z, W) {
        var w = 0;
        for (var G = 0; G < H; G++) w = w + (j[G] | 0), Z[2 * G] = w & 8191, w = w >>> 13, Z[2 * G + 1] = w & 8191, w = w >>> 13;
        for (G = 2 * H; G < W; ++G) Z[G] = 0;
        _(w === 0), _((w & -8192) === 0);
      }, g.prototype.stub = function(j) {
        var H = Array(j);
        for (var Z = 0; Z < j; Z++) H[Z] = 0;
        return H;
      }, g.prototype.mulp = function(j, H, Z) {
        var W = 2 * this.guessLen13b(j.length, H.length), w = this.makeRBT(W), G = this.stub(W), S = Array(W), A = Array(W), v = Array(W), k = Array(W), R = Array(W), C = Array(W), L = Z.words;
        L.length = W, this.convert13b(j.words, j.length, S, W), this.convert13b(H.words, H.length, k, W), this.transform(S, G, A, v, W, w), this.transform(k, G, R, C, W, w);
        for (var x = 0; x < W; x++) {
          var l = A[x] * R[x] - v[x] * C[x];
          v[x] = A[x] * C[x] + v[x] * R[x], A[x] = l;
        }
        return this.conjugate(A, v, W), this.transform(A, v, L, G, W, w), this.conjugate(L, G, W), this.normalize13b(L, W), Z.negative = j.negative ^ H.negative, Z.length = j.length + H.length, Z.strip();
      }, O.prototype.mul = function(j) {
        var H = new O(null);
        return H.words = Array(this.length + j.length), this.mulTo(j, H);
      }, O.prototype.mulf = function(j) {
        var H = new O(null);
        return H.words = Array(this.length + j.length), D(this, j, H);
      }, O.prototype.imul = function(j) {
        return this.clone().mulTo(j, this);
      }, O.prototype.imuln = function(j) {
        _(typeof j === "number"), _(j < 67108864);
        var H = 0;
        for (var Z = 0; Z < this.length; Z++) {
          var W = (this.words[Z] | 0) * j, w = (W & 67108863) + (H & 67108863);
          H >>= 26, H += W / 67108864 | 0, H += w >>> 26, this.words[Z] = w & 67108863;
        }
        if (H !== 0) this.words[Z] = H, this.length++;
        return this.length = j === 0 ? 1 : this.length, this;
      }, O.prototype.muln = function(j) {
        return this.clone().imuln(j);
      }, O.prototype.sqr = function() {
        return this.mul(this);
      }, O.prototype.isqr = function() {
        return this.imul(this.clone());
      }, O.prototype.pow = function(j) {
        var H = N(j);
        if (H.length === 0) return new O(1);
        var Z = this;
        for (var W = 0; W < H.length; W++, Z = Z.sqr()) if (H[W] !== 0) break;
        if (++W < H.length) for (var w = Z.sqr(); W < H.length; W++, w = w.sqr()) {
          if (H[W] === 0) continue;
          Z = Z.mul(w);
        }
        return Z;
      }, O.prototype.iushln = function(j) {
        _(typeof j === "number" && j >= 0);
        var H = j % 26, Z = (j - H) / 26, W = 67108863 >>> 26 - H << 26 - H, w;
        if (H !== 0) {
          var G = 0;
          for (w = 0; w < this.length; w++) {
            var S = this.words[w] & W, A = (this.words[w] | 0) - S << H;
            this.words[w] = A | G, G = S >>> 26 - H;
          }
          if (G) this.words[w] = G, this.length++;
        }
        if (Z !== 0) {
          for (w = this.length - 1; w >= 0; w--) this.words[w + Z] = this.words[w];
          for (w = 0; w < Z; w++) this.words[w] = 0;
          this.length += Z;
        }
        return this.strip();
      }, O.prototype.ishln = function(j) {
        return _(this.negative === 0), this.iushln(j);
      }, O.prototype.iushrn = function(j, H, Z) {
        _(typeof j === "number" && j >= 0);
        var W;
        if (H) W = (H - H % 26) / 26;
        else W = 0;
        var w = j % 26, G = Math.min((j - w) / 26, this.length), S = 67108863 ^ 67108863 >>> w << w, A = Z;
        if (W -= G, W = Math.max(0, W), A) {
          for (var v = 0; v < G; v++) A.words[v] = this.words[v];
          A.length = G;
        }
        if (G === 0) ;
        else if (this.length > G) {
          this.length -= G;
          for (v = 0; v < this.length; v++) this.words[v] = this.words[v + G];
        } else this.words[0] = 0, this.length = 1;
        var k = 0;
        for (v = this.length - 1; v >= 0 && (k !== 0 || v >= W); v--) {
          var R = this.words[v] | 0;
          this.words[v] = k << 26 - w | R >>> w, k = R & S;
        }
        if (A && k !== 0) A.words[A.length++] = k;
        if (this.length === 0) this.words[0] = 0, this.length = 1;
        return this.strip();
      }, O.prototype.ishrn = function(j, H, Z) {
        return _(this.negative === 0), this.iushrn(j, H, Z);
      }, O.prototype.shln = function(j) {
        return this.clone().ishln(j);
      }, O.prototype.ushln = function(j) {
        return this.clone().iushln(j);
      }, O.prototype.shrn = function(j) {
        return this.clone().ishrn(j);
      }, O.prototype.ushrn = function(j) {
        return this.clone().iushrn(j);
      }, O.prototype.testn = function(j) {
        _(typeof j === "number" && j >= 0);
        var H = j % 26, Z = (j - H) / 26, W = 1 << H;
        if (this.length <= Z) return false;
        var w = this.words[Z];
        return !!(w & W);
      }, O.prototype.imaskn = function(j) {
        _(typeof j === "number" && j >= 0);
        var H = j % 26, Z = (j - H) / 26;
        if (_(this.negative === 0, "imaskn works only with positive numbers"), this.length <= Z) return this;
        if (H !== 0) Z++;
        if (this.length = Math.min(Z, this.length), H !== 0) {
          var W = 67108863 ^ 67108863 >>> H << H;
          this.words[this.length - 1] &= W;
        }
        return this.strip();
      }, O.prototype.maskn = function(j) {
        return this.clone().imaskn(j);
      }, O.prototype.iaddn = function(j) {
        if (_(typeof j === "number"), _(j < 67108864), j < 0) return this.isubn(-j);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) < j) return this.words[0] = j - (this.words[0] | 0), this.negative = 0, this;
          return this.negative = 0, this.isubn(j), this.negative = 1, this;
        }
        return this._iaddn(j);
      }, O.prototype._iaddn = function(j) {
        this.words[0] += j;
        for (var H = 0; H < this.length && this.words[H] >= 67108864; H++) if (this.words[H] -= 67108864, H === this.length - 1) this.words[H + 1] = 1;
        else this.words[H + 1]++;
        return this.length = Math.max(this.length, H + 1), this;
      }, O.prototype.isubn = function(j) {
        if (_(typeof j === "number"), _(j < 67108864), j < 0) return this.iaddn(-j);
        if (this.negative !== 0) return this.negative = 0, this.iaddn(j), this.negative = 1, this;
        if (this.words[0] -= j, this.length === 1 && this.words[0] < 0) this.words[0] = -this.words[0], this.negative = 1;
        else for (var H = 0; H < this.length && this.words[H] < 0; H++) this.words[H] += 67108864, this.words[H + 1] -= 1;
        return this.strip();
      }, O.prototype.addn = function(j) {
        return this.clone().iaddn(j);
      }, O.prototype.subn = function(j) {
        return this.clone().isubn(j);
      }, O.prototype.iabs = function() {
        return this.negative = 0, this;
      }, O.prototype.abs = function() {
        return this.clone().iabs();
      }, O.prototype._ishlnsubmul = function(j, H, Z) {
        var W = j.length + Z, w;
        this._expand(W);
        var G, S = 0;
        for (w = 0; w < j.length; w++) {
          G = (this.words[w + Z] | 0) + S;
          var A = (j.words[w] | 0) * H;
          G -= A & 67108863, S = (G >> 26) - (A / 67108864 | 0), this.words[w + Z] = G & 67108863;
        }
        for (; w < this.length - Z; w++) G = (this.words[w + Z] | 0) + S, S = G >> 26, this.words[w + Z] = G & 67108863;
        if (S === 0) return this.strip();
        _(S === -1), S = 0;
        for (w = 0; w < this.length; w++) G = -(this.words[w] | 0) + S, S = G >> 26, this.words[w] = G & 67108863;
        return this.negative = 1, this.strip();
      }, O.prototype._wordDiv = function(j, H) {
        var Z = this.length - j.length, W = this.clone(), w = j, G = w.words[w.length - 1] | 0, S = this._countBits(G);
        if (Z = 26 - S, Z !== 0) w = w.ushln(Z), W.iushln(Z), G = w.words[w.length - 1] | 0;
        var A = W.length - w.length, v;
        if (H !== "mod") {
          v = new O(null), v.length = A + 1, v.words = Array(v.length);
          for (var k = 0; k < v.length; k++) v.words[k] = 0;
        }
        var R = W.clone()._ishlnsubmul(w, 1, A);
        if (R.negative === 0) {
          if (W = R, v) v.words[A] = 1;
        }
        for (var C = A - 1; C >= 0; C--) {
          var L = (W.words[w.length + C] | 0) * 67108864 + (W.words[w.length + C - 1] | 0);
          L = Math.min(L / G | 0, 67108863), W._ishlnsubmul(w, L, C);
          while (W.negative !== 0) if (L--, W.negative = 0, W._ishlnsubmul(w, 1, C), !W.isZero()) W.negative ^= 1;
          if (v) v.words[C] = L;
        }
        if (v) v.strip();
        if (W.strip(), H !== "div" && Z !== 0) W.iushrn(Z);
        return { div: v || null, mod: W };
      }, O.prototype.divmod = function(j, H, Z) {
        if (_(!j.isZero()), this.isZero()) return { div: new O(0), mod: new O(0) };
        var W, w, G;
        if (this.negative !== 0 && j.negative === 0) {
          if (G = this.neg().divmod(j, H), H !== "mod") W = G.div.neg();
          if (H !== "div") {
            if (w = G.mod.neg(), Z && w.negative !== 0) w.iadd(j);
          }
          return { div: W, mod: w };
        }
        if (this.negative === 0 && j.negative !== 0) {
          if (G = this.divmod(j.neg(), H), H !== "mod") W = G.div.neg();
          return { div: W, mod: G.mod };
        }
        if ((this.negative & j.negative) !== 0) {
          if (G = this.neg().divmod(j.neg(), H), H !== "div") {
            if (w = G.mod.neg(), Z && w.negative !== 0) w.isub(j);
          }
          return { div: G.div, mod: w };
        }
        if (j.length > this.length || this.cmp(j) < 0) return { div: new O(0), mod: this };
        if (j.length === 1) {
          if (H === "div") return { div: this.divn(j.words[0]), mod: null };
          if (H === "mod") return { div: null, mod: new O(this.modn(j.words[0])) };
          return { div: this.divn(j.words[0]), mod: new O(this.modn(j.words[0])) };
        }
        return this._wordDiv(j, H);
      }, O.prototype.div = function(j) {
        return this.divmod(j, "div", false).div;
      }, O.prototype.mod = function(j) {
        return this.divmod(j, "mod", false).mod;
      }, O.prototype.umod = function(j) {
        return this.divmod(j, "mod", true).mod;
      }, O.prototype.divRound = function(j) {
        var H = this.divmod(j);
        if (H.mod.isZero()) return H.div;
        var Z = H.div.negative !== 0 ? H.mod.isub(j) : H.mod, W = j.ushrn(1), w = j.andln(1), G = Z.cmp(W);
        if (G < 0 || w === 1 && G === 0) return H.div;
        return H.div.negative !== 0 ? H.div.isubn(1) : H.div.iaddn(1);
      }, O.prototype.modn = function(j) {
        _(j <= 67108863);
        var H = 67108864 % j, Z = 0;
        for (var W = this.length - 1; W >= 0; W--) Z = (H * Z + (this.words[W] | 0)) % j;
        return Z;
      }, O.prototype.idivn = function(j) {
        _(j <= 67108863);
        var H = 0;
        for (var Z = this.length - 1; Z >= 0; Z--) {
          var W = (this.words[Z] | 0) + H * 67108864;
          this.words[Z] = W / j | 0, H = W % j;
        }
        return this.strip();
      }, O.prototype.divn = function(j) {
        return this.clone().idivn(j);
      }, O.prototype.egcd = function(j) {
        _(j.negative === 0), _(!j.isZero());
        var H = this, Z = j.clone();
        if (H.negative !== 0) H = H.umod(j);
        else H = H.clone();
        var W = new O(1), w = new O(0), G = new O(0), S = new O(1), A = 0;
        while (H.isEven() && Z.isEven()) H.iushrn(1), Z.iushrn(1), ++A;
        var v = Z.clone(), k = H.clone();
        while (!H.isZero()) {
          for (var R = 0, C = 1; (H.words[0] & C) === 0 && R < 26; ++R, C <<= 1) ;
          if (R > 0) {
            H.iushrn(R);
            while (R-- > 0) {
              if (W.isOdd() || w.isOdd()) W.iadd(v), w.isub(k);
              W.iushrn(1), w.iushrn(1);
            }
          }
          for (var L = 0, x = 1; (Z.words[0] & x) === 0 && L < 26; ++L, x <<= 1) ;
          if (L > 0) {
            Z.iushrn(L);
            while (L-- > 0) {
              if (G.isOdd() || S.isOdd()) G.iadd(v), S.isub(k);
              G.iushrn(1), S.iushrn(1);
            }
          }
          if (H.cmp(Z) >= 0) H.isub(Z), W.isub(G), w.isub(S);
          else Z.isub(H), G.isub(W), S.isub(w);
        }
        return { a: G, b: S, gcd: Z.iushln(A) };
      }, O.prototype._invmp = function(j) {
        _(j.negative === 0), _(!j.isZero());
        var H = this, Z = j.clone();
        if (H.negative !== 0) H = H.umod(j);
        else H = H.clone();
        var W = new O(1), w = new O(0), G = Z.clone();
        while (H.cmpn(1) > 0 && Z.cmpn(1) > 0) {
          for (var S = 0, A = 1; (H.words[0] & A) === 0 && S < 26; ++S, A <<= 1) ;
          if (S > 0) {
            H.iushrn(S);
            while (S-- > 0) {
              if (W.isOdd()) W.iadd(G);
              W.iushrn(1);
            }
          }
          for (var v = 0, k = 1; (Z.words[0] & k) === 0 && v < 26; ++v, k <<= 1) ;
          if (v > 0) {
            Z.iushrn(v);
            while (v-- > 0) {
              if (w.isOdd()) w.iadd(G);
              w.iushrn(1);
            }
          }
          if (H.cmp(Z) >= 0) H.isub(Z), W.isub(w);
          else Z.isub(H), w.isub(W);
        }
        var R;
        if (H.cmpn(1) === 0) R = W;
        else R = w;
        if (R.cmpn(0) < 0) R.iadd(j);
        return R;
      }, O.prototype.gcd = function(j) {
        if (this.isZero()) return j.abs();
        if (j.isZero()) return this.abs();
        var H = this.clone(), Z = j.clone();
        H.negative = 0, Z.negative = 0;
        for (var W = 0; H.isEven() && Z.isEven(); W++) H.iushrn(1), Z.iushrn(1);
        do {
          while (H.isEven()) H.iushrn(1);
          while (Z.isEven()) Z.iushrn(1);
          var w = H.cmp(Z);
          if (w < 0) {
            var G = H;
            H = Z, Z = G;
          } else if (w === 0 || Z.cmpn(1) === 0) break;
          H.isub(Z);
        } while (true);
        return Z.iushln(W);
      }, O.prototype.invm = function(j) {
        return this.egcd(j).a.umod(j);
      }, O.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, O.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, O.prototype.andln = function(j) {
        return this.words[0] & j;
      }, O.prototype.bincn = function(j) {
        _(typeof j === "number");
        var H = j % 26, Z = (j - H) / 26, W = 1 << H;
        if (this.length <= Z) return this._expand(Z + 1), this.words[Z] |= W, this;
        var w = W;
        for (var G = Z; w !== 0 && G < this.length; G++) {
          var S = this.words[G] | 0;
          S += w, w = S >>> 26, S &= 67108863, this.words[G] = S;
        }
        if (w !== 0) this.words[G] = w, this.length++;
        return this;
      }, O.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, O.prototype.cmpn = function(j) {
        var H = j < 0;
        if (this.negative !== 0 && !H) return -1;
        if (this.negative === 0 && H) return 1;
        this.strip();
        var Z;
        if (this.length > 1) Z = 1;
        else {
          if (H) j = -j;
          _(j <= 67108863, "Number is too big");
          var W = this.words[0] | 0;
          Z = W === j ? 0 : W < j ? -1 : 1;
        }
        if (this.negative !== 0) return -Z | 0;
        return Z;
      }, O.prototype.cmp = function(j) {
        if (this.negative !== 0 && j.negative === 0) return -1;
        if (this.negative === 0 && j.negative !== 0) return 1;
        var H = this.ucmp(j);
        if (this.negative !== 0) return -H | 0;
        return H;
      }, O.prototype.ucmp = function(j) {
        if (this.length > j.length) return 1;
        if (this.length < j.length) return -1;
        var H = 0;
        for (var Z = this.length - 1; Z >= 0; Z--) {
          var W = this.words[Z] | 0, w = j.words[Z] | 0;
          if (W === w) continue;
          if (W < w) H = -1;
          else if (W > w) H = 1;
          break;
        }
        return H;
      }, O.prototype.gtn = function(j) {
        return this.cmpn(j) === 1;
      }, O.prototype.gt = function(j) {
        return this.cmp(j) === 1;
      }, O.prototype.gten = function(j) {
        return this.cmpn(j) >= 0;
      }, O.prototype.gte = function(j) {
        return this.cmp(j) >= 0;
      }, O.prototype.ltn = function(j) {
        return this.cmpn(j) === -1;
      }, O.prototype.lt = function(j) {
        return this.cmp(j) === -1;
      }, O.prototype.lten = function(j) {
        return this.cmpn(j) <= 0;
      }, O.prototype.lte = function(j) {
        return this.cmp(j) <= 0;
      }, O.prototype.eqn = function(j) {
        return this.cmpn(j) === 0;
      }, O.prototype.eq = function(j) {
        return this.cmp(j) === 0;
      }, O.red = function(j) {
        return new c(j);
      }, O.prototype.toRed = function(j) {
        return _(!this.red, "Already a number in reduction context"), _(this.negative === 0, "red works only with positives"), j.convertTo(this)._forceRed(j);
      }, O.prototype.fromRed = function() {
        return _(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, O.prototype._forceRed = function(j) {
        return this.red = j, this;
      }, O.prototype.forceRed = function(j) {
        return _(!this.red, "Already a number in reduction context"), this._forceRed(j);
      }, O.prototype.redAdd = function(j) {
        return _(this.red, "redAdd works only with red numbers"), this.red.add(this, j);
      }, O.prototype.redIAdd = function(j) {
        return _(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, j);
      }, O.prototype.redSub = function(j) {
        return _(this.red, "redSub works only with red numbers"), this.red.sub(this, j);
      }, O.prototype.redISub = function(j) {
        return _(this.red, "redISub works only with red numbers"), this.red.isub(this, j);
      }, O.prototype.redShl = function(j) {
        return _(this.red, "redShl works only with red numbers"), this.red.shl(this, j);
      }, O.prototype.redMul = function(j) {
        return _(this.red, "redMul works only with red numbers"), this.red._verify2(this, j), this.red.mul(this, j);
      }, O.prototype.redIMul = function(j) {
        return _(this.red, "redMul works only with red numbers"), this.red._verify2(this, j), this.red.imul(this, j);
      }, O.prototype.redSqr = function() {
        return _(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, O.prototype.redISqr = function() {
        return _(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, O.prototype.redSqrt = function() {
        return _(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, O.prototype.redInvm = function() {
        return _(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, O.prototype.redNeg = function() {
        return _(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, O.prototype.redPow = function(j) {
        return _(this.red && !j.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, j);
      };
      var b = { k256: null, p224: null, p192: null, p25519: null };
      function y(j, H) {
        this.name = j, this.p = new O(H, 16), this.n = this.p.bitLength(), this.k = new O(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      __name(y, "y");
      y.prototype._tmp = function() {
        var j = new O(null);
        return j.words = Array(Math.ceil(this.n / 13)), j;
      }, y.prototype.ireduce = function(j) {
        var H = j, Z;
        do
          this.split(H, this.tmp), H = this.imulK(H), H = H.iadd(this.tmp), Z = H.bitLength();
        while (Z > this.n);
        var W = Z < this.n ? -1 : H.ucmp(this.p);
        if (W === 0) H.words[0] = 0, H.length = 1;
        else if (W > 0) H.isub(this.p);
        else if (H.strip !== void 0) H.strip();
        else H._strip();
        return H;
      }, y.prototype.split = function(j, H) {
        j.iushrn(this.n, 0, H);
      }, y.prototype.imulK = function(j) {
        return j.imul(this.k);
      };
      function p() {
        y.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
      }
      __name(p, "p");
      Y(p, y), p.prototype.split = function(j, H) {
        var Z = 4194303, W = Math.min(j.length, 9);
        for (var w = 0; w < W; w++) H.words[w] = j.words[w];
        if (H.length = W, j.length <= 9) {
          j.words[0] = 0, j.length = 1;
          return;
        }
        var G = j.words[9];
        H.words[H.length++] = G & Z;
        for (w = 10; w < j.length; w++) {
          var S = j.words[w] | 0;
          j.words[w - 10] = (S & Z) << 4 | G >>> 22, G = S;
        }
        if (G >>>= 22, j.words[w - 10] = G, G === 0 && j.length > 10) j.length -= 10;
        else j.length -= 9;
      }, p.prototype.imulK = function(j) {
        j.words[j.length] = 0, j.words[j.length + 1] = 0, j.length += 2;
        var H = 0;
        for (var Z = 0; Z < j.length; Z++) {
          var W = j.words[Z] | 0;
          H += W * 977, j.words[Z] = H & 67108863, H = W * 64 + (H / 67108864 | 0);
        }
        if (j.words[j.length - 1] === 0) {
          if (j.length--, j.words[j.length - 1] === 0) j.length--;
        }
        return j;
      };
      function n() {
        y.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
      }
      __name(n, "n");
      Y(n, y);
      function s() {
        y.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
      }
      __name(s, "s");
      Y(s, y);
      function q$() {
        y.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
      }
      __name(q$, "q$");
      Y(q$, y), q$.prototype.imulK = function(j) {
        var H = 0;
        for (var Z = 0; Z < j.length; Z++) {
          var W = (j.words[Z] | 0) * 19 + H, w = W & 67108863;
          W >>>= 26, j.words[Z] = w, H = W;
        }
        if (H !== 0) j.words[j.length++] = H;
        return j;
      }, O._prime = function(j) {
        if (b[j]) return b[j];
        var H;
        if (j === "k256") H = new p();
        else if (j === "p224") H = new n();
        else if (j === "p192") H = new s();
        else if (j === "p25519") H = new q$();
        else throw Error("Unknown prime " + j);
        return b[j] = H, H;
      };
      function c(j) {
        if (typeof j === "string") {
          var H = O._prime(j);
          this.m = H.p, this.prime = H;
        } else _(j.gtn(1), "modulus must be greater than 1"), this.m = j, this.prime = null;
      }
      __name(c, "c");
      c.prototype._verify1 = function(j) {
        _(j.negative === 0, "red works only with positives"), _(j.red, "red works only with red numbers");
      }, c.prototype._verify2 = function(j, H) {
        _((j.negative | H.negative) === 0, "red works only with positives"), _(j.red && j.red === H.red, "red works only with red numbers");
      }, c.prototype.imod = function(j) {
        if (this.prime) return this.prime.ireduce(j)._forceRed(this);
        return j.umod(this.m)._forceRed(this);
      }, c.prototype.neg = function(j) {
        if (j.isZero()) return j.clone();
        return this.m.sub(j)._forceRed(this);
      }, c.prototype.add = function(j, H) {
        this._verify2(j, H);
        var Z = j.add(H);
        if (Z.cmp(this.m) >= 0) Z.isub(this.m);
        return Z._forceRed(this);
      }, c.prototype.iadd = function(j, H) {
        this._verify2(j, H);
        var Z = j.iadd(H);
        if (Z.cmp(this.m) >= 0) Z.isub(this.m);
        return Z;
      }, c.prototype.sub = function(j, H) {
        this._verify2(j, H);
        var Z = j.sub(H);
        if (Z.cmpn(0) < 0) Z.iadd(this.m);
        return Z._forceRed(this);
      }, c.prototype.isub = function(j, H) {
        this._verify2(j, H);
        var Z = j.isub(H);
        if (Z.cmpn(0) < 0) Z.iadd(this.m);
        return Z;
      }, c.prototype.shl = function(j, H) {
        return this._verify1(j), this.imod(j.ushln(H));
      }, c.prototype.imul = function(j, H) {
        return this._verify2(j, H), this.imod(j.imul(H));
      }, c.prototype.mul = function(j, H) {
        return this._verify2(j, H), this.imod(j.mul(H));
      }, c.prototype.isqr = function(j) {
        return this.imul(j, j.clone());
      }, c.prototype.sqr = function(j) {
        return this.mul(j, j);
      }, c.prototype.sqrt = function(j) {
        if (j.isZero()) return j.clone();
        var H = this.m.andln(3);
        if (_(H % 2 === 1), H === 3) {
          var Z = this.m.add(new O(1)).iushrn(2);
          return this.pow(j, Z);
        }
        var W = this.m.subn(1), w = 0;
        while (!W.isZero() && W.andln(1) === 0) w++, W.iushrn(1);
        _(!W.isZero());
        var G = new O(1).toRed(this), S = G.redNeg(), A = this.m.subn(1).iushrn(1), v = this.m.bitLength();
        v = new O(2 * v * v).toRed(this);
        while (this.pow(v, A).cmp(S) !== 0) v.redIAdd(S);
        var k = this.pow(v, W), R = this.pow(j, W.addn(1).iushrn(1)), C = this.pow(j, W), L = w;
        while (C.cmp(G) !== 0) {
          var x = C;
          for (var l = 0; x.cmp(G) !== 0; l++) x = x.redSqr();
          _(l < L);
          var a = this.pow(k, new O(1).iushln(L - l - 1));
          R = R.redMul(a), k = a.redSqr(), C = C.redMul(k), L = l;
        }
        return R;
      }, c.prototype.invm = function(j) {
        var H = j._invmp(this.m);
        if (H.negative !== 0) return H.negative = 0, this.imod(H).redNeg();
        else return this.imod(H);
      }, c.prototype.pow = function(j, H) {
        if (H.isZero()) return new O(1).toRed(this);
        if (H.cmpn(1) === 0) return j.clone();
        var Z = 4, W = Array(1 << Z);
        W[0] = new O(1).toRed(this), W[1] = j;
        for (var w = 2; w < W.length; w++) W[w] = this.mul(W[w - 1], j);
        var G = W[0], S = 0, A = 0, v = H.bitLength() % 26;
        if (v === 0) v = 26;
        for (w = H.length - 1; w >= 0; w--) {
          var k = H.words[w];
          for (var R = v - 1; R >= 0; R--) {
            var C = k >> R & 1;
            if (G !== W[0]) G = this.sqr(G);
            if (C === 0 && S === 0) {
              A = 0;
              continue;
            }
            if (S <<= 1, S |= C, A++, A !== Z && (w !== 0 || R !== 0)) continue;
            G = this.mul(G, W[S]), A = 0, S = 0;
          }
          v = 26;
        }
        return G;
      }, c.prototype.convertTo = function(j) {
        var H = j.umod(this.m);
        return H === j ? H.clone() : H;
      }, c.prototype.convertFrom = function(j) {
        var H = j.clone();
        return H.red = null, H;
      }, O.mont = function(j) {
        return new U(j);
      };
      function U(j) {
        if (c.call(this, j), this.shift = this.m.bitLength(), this.shift % 26 !== 0) this.shift += 26 - this.shift % 26;
        this.r = new O(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      __name(U, "U");
      Y(U, c), U.prototype.convertTo = function(j) {
        return this.imod(j.ushln(this.shift));
      }, U.prototype.convertFrom = function(j) {
        var H = this.imod(j.mul(this.rinv));
        return H.red = null, H;
      }, U.prototype.imul = function(j, H) {
        if (j.isZero() || H.isZero()) return j.words[0] = 0, j.length = 1, j;
        var Z = j.imul(H), W = Z.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), w = Z.isub(W).iushrn(this.shift), G = w;
        if (w.cmp(this.m) >= 0) G = w.isub(this.m);
        else if (w.cmpn(0) < 0) G = w.iadd(this.m);
        return G._forceRed(this);
      }, U.prototype.mul = function(j, H) {
        if (j.isZero() || H.isZero()) return new O(0)._forceRed(this);
        var Z = j.mul(H), W = Z.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), w = Z.isub(W).iushrn(this.shift), G = w;
        if (w.cmp(this.m) >= 0) G = w.isub(this.m);
        else if (w.cmpn(0) < 0) G = w.iadd(this.m);
        return G._forceRed(this);
      }, U.prototype.invm = function(j) {
        var H = this.imod(j._invmp(this.m).mul(this.r2));
        return H._forceRed(this);
      };
    })(typeof q > "u" || q, $);
  }), So = r$(($, q) => {
    var K = Go(), P = Vo();
    q.exports = function(z) {
      return new Y(z);
    };
    var _ = { secp256k1: { name: "secp256k1", byteLength: 32 }, secp224r1: { name: "p224", byteLength: 28 }, prime256v1: { name: "p256", byteLength: 32 }, prime192v1: { name: "p192", byteLength: 24 }, ed25519: { name: "ed25519", byteLength: 32 }, secp384r1: { name: "p384", byteLength: 48 }, secp521r1: { name: "p521", byteLength: 66 } };
    _.p224 = _.secp224r1, _.p256 = _.secp256r1 = _.prime256v1, _.p192 = _.secp192r1 = _.prime192v1, _.p384 = _.secp384r1, _.p521 = _.secp521r1;
    function Y(z) {
      if (this.curveType = _[z], !this.curveType) this.curveType = { name: z };
      this.curve = new K.ec(this.curveType.name), this.keys = void 0;
    }
    __name(Y, "Y");
    Y.prototype.generateKeys = function(z, J) {
      return this.keys = this.curve.genKeyPair(), this.getPublicKey(z, J);
    }, Y.prototype.computeSecret = function(z, J, T) {
      if (J = J || "utf8", !Buffer.isBuffer(z)) z = new Buffer(z, J);
      var X = this.curve.keyFromPublic(z).getPublic(), f = X.mul(this.keys.getPrivate()).getX();
      return O(f, T, this.curveType.byteLength);
    }, Y.prototype.getPublicKey = function(z, J) {
      var T = this.keys.getPublic(J === "compressed", true);
      if (J === "hybrid") if (T[T.length - 1] % 2) T[0] = 7;
      else T[0] = 6;
      return O(T, z);
    }, Y.prototype.getPrivateKey = function(z) {
      return O(this.keys.getPrivate(), z);
    }, Y.prototype.setPublicKey = function(z, J) {
      if (J = J || "utf8", !Buffer.isBuffer(z)) z = new Buffer(z, J);
      return this.keys._importPublic(z), this;
    }, Y.prototype.setPrivateKey = function(z, J) {
      if (J = J || "utf8", !Buffer.isBuffer(z)) z = new Buffer(z, J);
      var T = new P(z);
      return T = T.toString(16), this.keys = this.curve.genKeyPair(), this.keys._importPrivate(T), this;
    };
    function O(z, J, T) {
      if (!Array.isArray(z)) z = z.toArray();
      var X = new Buffer(z);
      if (T && X.length < T) {
        var f = new Buffer(T - X.length);
        f.fill(0), X = Buffer.concat([f, X]);
      }
      if (!J) return X;
      else return X.toString(J);
    }
    __name(O, "O");
  }), Mo = r$(($, q) => {
    var K = (lq(), J6(dq)).createECDH;
    q.exports = K || So();
  }), No = r$(($, q) => {
    (function(K, P) {
      function _(j, H) {
        if (!j) throw Error(H || "Assertion failed");
      }
      __name(_, "_");
      function Y(j, H) {
        j.super_ = H;
        var Z = /* @__PURE__ */ __name(function() {
        }, "Z");
        Z.prototype = H.prototype, j.prototype = new Z(), j.prototype.constructor = j;
      }
      __name(Y, "Y");
      function O(j, H, Z) {
        if (O.isBN(j)) return j;
        if (this.negative = 0, this.words = null, this.length = 0, this.red = null, j !== null) {
          if (H === "le" || H === "be") Z = H, H = 10;
          this._init(j || 0, H || 10, Z || "be");
        }
      }
      __name(O, "O");
      if (typeof K === "object") K.exports = O;
      else P.BN = O;
      O.BN = O, O.wordSize = 26;
      var z;
      try {
        if (typeof window < "u" && typeof window.Buffer < "u") z = window.Buffer;
        else z = (fq(), J6(wq)).Buffer;
      } catch (j) {
      }
      O.isBN = function(j) {
        if (j instanceof O) return true;
        return j !== null && typeof j === "object" && j.constructor.wordSize === O.wordSize && Array.isArray(j.words);
      }, O.max = function(j, H) {
        if (j.cmp(H) > 0) return j;
        return H;
      }, O.min = function(j, H) {
        if (j.cmp(H) < 0) return j;
        return H;
      }, O.prototype._init = function(j, H, Z) {
        if (typeof j === "number") return this._initNumber(j, H, Z);
        if (typeof j === "object") return this._initArray(j, H, Z);
        if (H === "hex") H = 16;
        _(H === (H | 0) && H >= 2 && H <= 36), j = j.toString().replace(/\s+/g, "");
        var W = 0;
        if (j[0] === "-") W++, this.negative = 1;
        if (W < j.length) {
          if (H === 16) this._parseHex(j, W, Z);
          else if (this._parseBase(j, H, W), Z === "le") this._initArray(this.toArray(), H, Z);
        }
      }, O.prototype._initNumber = function(j, H, Z) {
        if (j < 0) this.negative = 1, j = -j;
        if (j < 67108864) this.words = [j & 67108863], this.length = 1;
        else if (j < 4503599627370496) this.words = [j & 67108863, j / 67108864 & 67108863], this.length = 2;
        else _(j < 9007199254740992), this.words = [j & 67108863, j / 67108864 & 67108863, 1], this.length = 3;
        if (Z !== "le") return;
        this._initArray(this.toArray(), H, Z);
      }, O.prototype._initArray = function(j, H, Z) {
        if (_(typeof j.length === "number"), j.length <= 0) return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(j.length / 3), this.words = Array(this.length);
        for (var W = 0; W < this.length; W++) this.words[W] = 0;
        var w, G, S = 0;
        if (Z === "be") {
          for (W = j.length - 1, w = 0; W >= 0; W -= 3) if (G = j[W] | j[W - 1] << 8 | j[W - 2] << 16, this.words[w] |= G << S & 67108863, this.words[w + 1] = G >>> 26 - S & 67108863, S += 24, S >= 26) S -= 26, w++;
        } else if (Z === "le") {
          for (W = 0, w = 0; W < j.length; W += 3) if (G = j[W] | j[W + 1] << 8 | j[W + 2] << 16, this.words[w] |= G << S & 67108863, this.words[w + 1] = G >>> 26 - S & 67108863, S += 24, S >= 26) S -= 26, w++;
        }
        return this.strip();
      };
      function J(j, H) {
        var Z = j.charCodeAt(H);
        if (Z >= 65 && Z <= 70) return Z - 55;
        else if (Z >= 97 && Z <= 102) return Z - 87;
        else return Z - 48 & 15;
      }
      __name(J, "J");
      function T(j, H, Z) {
        var W = J(j, Z);
        if (Z - 1 >= H) W |= J(j, Z - 1) << 4;
        return W;
      }
      __name(T, "T");
      O.prototype._parseHex = function(j, H, Z) {
        this.length = Math.ceil((j.length - H) / 6), this.words = Array(this.length);
        for (var W = 0; W < this.length; W++) this.words[W] = 0;
        var w = 0, G = 0, S;
        if (Z === "be") for (W = j.length - 1; W >= H; W -= 2) if (S = T(j, H, W) << w, this.words[G] |= S & 67108863, w >= 18) w -= 18, G += 1, this.words[G] |= S >>> 26;
        else w += 8;
        else {
          var A = j.length - H;
          for (W = A % 2 === 0 ? H + 1 : H; W < j.length; W += 2) if (S = T(j, H, W) << w, this.words[G] |= S & 67108863, w >= 18) w -= 18, G += 1, this.words[G] |= S >>> 26;
          else w += 8;
        }
        this.strip();
      };
      function X(j, H, Z, W) {
        var w = 0, G = Math.min(j.length, Z);
        for (var S = H; S < G; S++) {
          var A = j.charCodeAt(S) - 48;
          if (w *= W, A >= 49) w += A - 49 + 10;
          else if (A >= 17) w += A - 17 + 10;
          else w += A;
        }
        return w;
      }
      __name(X, "X");
      O.prototype._parseBase = function(j, H, Z) {
        this.words = [0], this.length = 1;
        for (var W = 0, w = 1; w <= 67108863; w *= H) W++;
        W--, w = w / H | 0;
        var G = j.length - Z, S = G % W, A = Math.min(G, G - S) + Z, v = 0;
        for (var k = Z; k < A; k += W) if (v = X(j, k, k + W, H), this.imuln(w), this.words[0] + v < 67108864) this.words[0] += v;
        else this._iaddn(v);
        if (S !== 0) {
          var R = 1;
          v = X(j, k, j.length, H);
          for (k = 0; k < S; k++) R *= H;
          if (this.imuln(R), this.words[0] + v < 67108864) this.words[0] += v;
          else this._iaddn(v);
        }
        this.strip();
      }, O.prototype.copy = function(j) {
        j.words = Array(this.length);
        for (var H = 0; H < this.length; H++) j.words[H] = this.words[H];
        j.length = this.length, j.negative = this.negative, j.red = this.red;
      }, O.prototype.clone = function() {
        var j = new O(null);
        return this.copy(j), j;
      }, O.prototype._expand = function(j) {
        while (this.length < j) this.words[this.length++] = 0;
        return this;
      }, O.prototype.strip = function() {
        while (this.length > 1 && this.words[this.length - 1] === 0) this.length--;
        return this._normSign();
      }, O.prototype._normSign = function() {
        if (this.length === 1 && this.words[0] === 0) this.negative = 0;
        return this;
      }, O.prototype.inspect = function() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var f = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], V = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], M = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
      if (O.prototype.toString = function(j, H) {
        j = j || 10, H = H | 0 || 1;
        var Z;
        if (j === 16 || j === "hex") {
          Z = "";
          var W = 0, w = 0;
          for (var G = 0; G < this.length; G++) {
            var S = this.words[G], A = ((S << W | w) & 16777215).toString(16);
            if (w = S >>> 24 - W & 16777215, W += 2, W >= 26) W -= 26, G--;
            if (w !== 0 || G !== this.length - 1) Z = f[6 - A.length] + A + Z;
            else Z = A + Z;
          }
          if (w !== 0) Z = w.toString(16) + Z;
          while (Z.length % H !== 0) Z = "0" + Z;
          if (this.negative !== 0) Z = "-" + Z;
          return Z;
        }
        if (j === (j | 0) && j >= 2 && j <= 36) {
          var v = V[j], k = M[j];
          Z = "";
          var R = this.clone();
          R.negative = 0;
          while (!R.isZero()) {
            var C = R.modn(k).toString(j);
            if (R = R.idivn(k), !R.isZero()) Z = f[v - C.length] + C + Z;
            else Z = C + Z;
          }
          if (this.isZero()) Z = "0" + Z;
          while (Z.length % H !== 0) Z = "0" + Z;
          if (this.negative !== 0) Z = "-" + Z;
          return Z;
        }
        _(false, "Base should be between 2 and 36");
      }, O.prototype.toNumber = function() {
        var j = this.words[0];
        if (this.length === 2) j += this.words[1] * 67108864;
        else if (this.length === 3 && this.words[2] === 1) j += 4503599627370496 + this.words[1] * 67108864;
        else if (this.length > 2) _(false, "Number can only safely store up to 53 bits");
        return this.negative !== 0 ? -j : j;
      }, O.prototype.toJSON = function() {
        return this.toString(16);
      }, O.prototype.toBuffer = function(j, H) {
        return _(typeof z < "u"), this.toArrayLike(z, j, H);
      }, O.prototype.toArray = function(j, H) {
        return this.toArrayLike(Array, j, H);
      }, O.prototype.toArrayLike = function(j, H, Z) {
        var W = this.byteLength(), w = Z || Math.max(1, W);
        _(W <= w, "byte array longer than desired length"), _(w > 0, "Requested array length <= 0"), this.strip();
        var G = H === "le", S = new j(w), A, v, k = this.clone();
        if (!G) {
          for (v = 0; v < w - W; v++) S[v] = 0;
          for (v = 0; !k.isZero(); v++) A = k.andln(255), k.iushrn(8), S[w - v - 1] = A;
        } else {
          for (v = 0; !k.isZero(); v++) A = k.andln(255), k.iushrn(8), S[v] = A;
          for (; v < w; v++) S[v] = 0;
        }
        return S;
      }, Math.clz32) O.prototype._countBits = function(j) {
        return 32 - Math.clz32(j);
      };
      else O.prototype._countBits = function(j) {
        var H = j, Z = 0;
        if (H >= 4096) Z += 13, H >>>= 13;
        if (H >= 64) Z += 7, H >>>= 7;
        if (H >= 8) Z += 4, H >>>= 4;
        if (H >= 2) Z += 2, H >>>= 2;
        return Z + H;
      };
      O.prototype._zeroBits = function(j) {
        if (j === 0) return 26;
        var H = j, Z = 0;
        if ((H & 8191) === 0) Z += 13, H >>>= 13;
        if ((H & 127) === 0) Z += 7, H >>>= 7;
        if ((H & 15) === 0) Z += 4, H >>>= 4;
        if ((H & 3) === 0) Z += 2, H >>>= 2;
        if ((H & 1) === 0) Z++;
        return Z;
      }, O.prototype.bitLength = function() {
        var j = this.words[this.length - 1], H = this._countBits(j);
        return (this.length - 1) * 26 + H;
      };
      function N(j) {
        var H = Array(j.bitLength());
        for (var Z = 0; Z < H.length; Z++) {
          var W = Z / 26 | 0, w = Z % 26;
          H[Z] = (j.words[W] & 1 << w) >>> w;
        }
        return H;
      }
      __name(N, "N");
      O.prototype.zeroBits = function() {
        if (this.isZero()) return 0;
        var j = 0;
        for (var H = 0; H < this.length; H++) {
          var Z = this._zeroBits(this.words[H]);
          if (j += Z, Z !== 26) break;
        }
        return j;
      }, O.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, O.prototype.toTwos = function(j) {
        if (this.negative !== 0) return this.abs().inotn(j).iaddn(1);
        return this.clone();
      }, O.prototype.fromTwos = function(j) {
        if (this.testn(j - 1)) return this.notn(j).iaddn(1).ineg();
        return this.clone();
      }, O.prototype.isNeg = function() {
        return this.negative !== 0;
      }, O.prototype.neg = function() {
        return this.clone().ineg();
      }, O.prototype.ineg = function() {
        if (!this.isZero()) this.negative ^= 1;
        return this;
      }, O.prototype.iuor = function(j) {
        while (this.length < j.length) this.words[this.length++] = 0;
        for (var H = 0; H < j.length; H++) this.words[H] = this.words[H] | j.words[H];
        return this.strip();
      }, O.prototype.ior = function(j) {
        return _((this.negative | j.negative) === 0), this.iuor(j);
      }, O.prototype.or = function(j) {
        if (this.length > j.length) return this.clone().ior(j);
        return j.clone().ior(this);
      }, O.prototype.uor = function(j) {
        if (this.length > j.length) return this.clone().iuor(j);
        return j.clone().iuor(this);
      }, O.prototype.iuand = function(j) {
        var H;
        if (this.length > j.length) H = j;
        else H = this;
        for (var Z = 0; Z < H.length; Z++) this.words[Z] = this.words[Z] & j.words[Z];
        return this.length = H.length, this.strip();
      }, O.prototype.iand = function(j) {
        return _((this.negative | j.negative) === 0), this.iuand(j);
      }, O.prototype.and = function(j) {
        if (this.length > j.length) return this.clone().iand(j);
        return j.clone().iand(this);
      }, O.prototype.uand = function(j) {
        if (this.length > j.length) return this.clone().iuand(j);
        return j.clone().iuand(this);
      }, O.prototype.iuxor = function(j) {
        var H, Z;
        if (this.length > j.length) H = this, Z = j;
        else H = j, Z = this;
        for (var W = 0; W < Z.length; W++) this.words[W] = H.words[W] ^ Z.words[W];
        if (this !== H) for (; W < H.length; W++) this.words[W] = H.words[W];
        return this.length = H.length, this.strip();
      }, O.prototype.ixor = function(j) {
        return _((this.negative | j.negative) === 0), this.iuxor(j);
      }, O.prototype.xor = function(j) {
        if (this.length > j.length) return this.clone().ixor(j);
        return j.clone().ixor(this);
      }, O.prototype.uxor = function(j) {
        if (this.length > j.length) return this.clone().iuxor(j);
        return j.clone().iuxor(this);
      }, O.prototype.inotn = function(j) {
        _(typeof j === "number" && j >= 0);
        var H = Math.ceil(j / 26) | 0, Z = j % 26;
        if (this._expand(H), Z > 0) H--;
        for (var W = 0; W < H; W++) this.words[W] = ~this.words[W] & 67108863;
        if (Z > 0) this.words[W] = ~this.words[W] & 67108863 >> 26 - Z;
        return this.strip();
      }, O.prototype.notn = function(j) {
        return this.clone().inotn(j);
      }, O.prototype.setn = function(j, H) {
        _(typeof j === "number" && j >= 0);
        var Z = j / 26 | 0, W = j % 26;
        if (this._expand(Z + 1), H) this.words[Z] = this.words[Z] | 1 << W;
        else this.words[Z] = this.words[Z] & ~(1 << W);
        return this.strip();
      }, O.prototype.iadd = function(j) {
        var H;
        if (this.negative !== 0 && j.negative === 0) return this.negative = 0, H = this.isub(j), this.negative ^= 1, this._normSign();
        else if (this.negative === 0 && j.negative !== 0) return j.negative = 0, H = this.isub(j), j.negative = 1, H._normSign();
        var Z, W;
        if (this.length > j.length) Z = this, W = j;
        else Z = j, W = this;
        var w = 0;
        for (var G = 0; G < W.length; G++) H = (Z.words[G] | 0) + (W.words[G] | 0) + w, this.words[G] = H & 67108863, w = H >>> 26;
        for (; w !== 0 && G < Z.length; G++) H = (Z.words[G] | 0) + w, this.words[G] = H & 67108863, w = H >>> 26;
        if (this.length = Z.length, w !== 0) this.words[this.length] = w, this.length++;
        else if (Z !== this) for (; G < Z.length; G++) this.words[G] = Z.words[G];
        return this;
      }, O.prototype.add = function(j) {
        var H;
        if (j.negative !== 0 && this.negative === 0) return j.negative = 0, H = this.sub(j), j.negative ^= 1, H;
        else if (j.negative === 0 && this.negative !== 0) return this.negative = 0, H = j.sub(this), this.negative = 1, H;
        if (this.length > j.length) return this.clone().iadd(j);
        return j.clone().iadd(this);
      }, O.prototype.isub = function(j) {
        if (j.negative !== 0) {
          j.negative = 0;
          var H = this.iadd(j);
          return j.negative = 1, H._normSign();
        } else if (this.negative !== 0) return this.negative = 0, this.iadd(j), this.negative = 1, this._normSign();
        var Z = this.cmp(j);
        if (Z === 0) return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var W, w;
        if (Z > 0) W = this, w = j;
        else W = j, w = this;
        var G = 0;
        for (var S = 0; S < w.length; S++) H = (W.words[S] | 0) - (w.words[S] | 0) + G, G = H >> 26, this.words[S] = H & 67108863;
        for (; G !== 0 && S < W.length; S++) H = (W.words[S] | 0) + G, G = H >> 26, this.words[S] = H & 67108863;
        if (G === 0 && S < W.length && W !== this) for (; S < W.length; S++) this.words[S] = W.words[S];
        if (this.length = Math.max(this.length, S), W !== this) this.negative = 1;
        return this.strip();
      }, O.prototype.sub = function(j) {
        return this.clone().isub(j);
      };
      function E(j, H, Z) {
        Z.negative = H.negative ^ j.negative;
        var W = j.length + H.length | 0;
        Z.length = W, W = W - 1 | 0;
        var w = j.words[0] | 0, G = H.words[0] | 0, S = w * G, A = S & 67108863, v = S / 67108864 | 0;
        Z.words[0] = A;
        for (var k = 1; k < W; k++) {
          var R = v >>> 26, C = v & 67108863, L = Math.min(k, H.length - 1);
          for (var x = Math.max(0, k - j.length + 1); x <= L; x++) {
            var l = k - x | 0;
            w = j.words[l] | 0, G = H.words[x] | 0, S = w * G + C, R += S / 67108864 | 0, C = S & 67108863;
          }
          Z.words[k] = C | 0, v = R | 0;
        }
        if (v !== 0) Z.words[k] = v | 0;
        else Z.length--;
        return Z.strip();
      }
      __name(E, "E");
      var h = /* @__PURE__ */ __name(function(j, H, Z) {
        var W = j.words, w = H.words, G = Z.words, S = 0, A, v, k, R = W[0] | 0, C = R & 8191, L = R >>> 13, x = W[1] | 0, l = x & 8191, a = x >>> 13, f$ = W[2] | 0, $$ = f$ & 8191, t = f$ >>> 13, H$ = W[3] | 0, Q = H$ & 8191, v$ = H$ >>> 13, B$ = W[4] | 0, m = B$ & 8191, r = B$ >>> 13, J$ = W[5] | 0, e = J$ & 8191, _$2 = J$ >>> 13, Y$ = W[6] | 0, d = Y$ & 8191, o = Y$ >>> 13, W$ = W[7] | 0, B = W$ & 8191, F = W$ >>> 13, X$ = W[8] | 0, z$ = X$ & 8191, j$ = X$ >>> 13, X6 = W[9] | 0, Z$ = X6 & 8191, A$ = X6 >>> 13, l6 = w[0] | 0, S$ = l6 & 8191, V$ = l6 >>> 13, Mq = w[1] | 0, N$ = Mq & 8191, D$ = Mq >>> 13, Nq = w[2] | 0, L$ = Nq & 8191, C$ = Nq >>> 13, Zq = w[3] | 0, g$ = Zq & 8191, h$ = Zq >>> 13, zq = w[4] | 0, b$ = zq & 8191, y$ = zq >>> 13, Wq = w[5] | 0, E$ = Wq & 8191, u = Wq >>> 13, i = w[6] | 0, K$ = i & 8191, P$ = i >>> 13, i$ = w[7] | 0, k$ = i$ & 8191, G$ = i$ >>> 13, x6 = w[8] | 0, R$ = x6 & 8191, u$ = x6 >>> 13, Xq = w[9] | 0, I$ = Xq & 8191, M$ = Xq >>> 13;
        Z.negative = j.negative ^ H.negative, Z.length = 19, A = Math.imul(C, S$), v = Math.imul(C, V$), v = v + Math.imul(L, S$) | 0, k = Math.imul(L, V$);
        var p6 = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (p6 >>> 26) | 0, p6 &= 67108863, A = Math.imul(l, S$), v = Math.imul(l, V$), v = v + Math.imul(a, S$) | 0, k = Math.imul(a, V$), A = A + Math.imul(C, N$) | 0, v = v + Math.imul(C, D$) | 0, v = v + Math.imul(L, N$) | 0, k = k + Math.imul(L, D$) | 0;
        var H6 = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (H6 >>> 26) | 0, H6 &= 67108863, A = Math.imul($$, S$), v = Math.imul($$, V$), v = v + Math.imul(t, S$) | 0, k = Math.imul(t, V$), A = A + Math.imul(l, N$) | 0, v = v + Math.imul(l, D$) | 0, v = v + Math.imul(a, N$) | 0, k = k + Math.imul(a, D$) | 0, A = A + Math.imul(C, L$) | 0, v = v + Math.imul(C, C$) | 0, v = v + Math.imul(L, L$) | 0, k = k + Math.imul(L, C$) | 0;
        var v6 = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (v6 >>> 26) | 0, v6 &= 67108863, A = Math.imul(Q, S$), v = Math.imul(Q, V$), v = v + Math.imul(v$, S$) | 0, k = Math.imul(v$, V$), A = A + Math.imul($$, N$) | 0, v = v + Math.imul($$, D$) | 0, v = v + Math.imul(t, N$) | 0, k = k + Math.imul(t, D$) | 0, A = A + Math.imul(l, L$) | 0, v = v + Math.imul(l, C$) | 0, v = v + Math.imul(a, L$) | 0, k = k + Math.imul(a, C$) | 0, A = A + Math.imul(C, g$) | 0, v = v + Math.imul(C, h$) | 0, v = v + Math.imul(L, g$) | 0, k = k + Math.imul(L, h$) | 0;
        var C6 = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (C6 >>> 26) | 0, C6 &= 67108863, A = Math.imul(m, S$), v = Math.imul(m, V$), v = v + Math.imul(r, S$) | 0, k = Math.imul(r, V$), A = A + Math.imul(Q, N$) | 0, v = v + Math.imul(Q, D$) | 0, v = v + Math.imul(v$, N$) | 0, k = k + Math.imul(v$, D$) | 0, A = A + Math.imul($$, L$) | 0, v = v + Math.imul($$, C$) | 0, v = v + Math.imul(t, L$) | 0, k = k + Math.imul(t, C$) | 0, A = A + Math.imul(l, g$) | 0, v = v + Math.imul(l, h$) | 0, v = v + Math.imul(a, g$) | 0, k = k + Math.imul(a, h$) | 0, A = A + Math.imul(C, b$) | 0, v = v + Math.imul(C, y$) | 0, v = v + Math.imul(L, b$) | 0, k = k + Math.imul(L, y$) | 0;
        var S6 = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (S6 >>> 26) | 0, S6 &= 67108863, A = Math.imul(e, S$), v = Math.imul(e, V$), v = v + Math.imul(_$2, S$) | 0, k = Math.imul(_$2, V$), A = A + Math.imul(m, N$) | 0, v = v + Math.imul(m, D$) | 0, v = v + Math.imul(r, N$) | 0, k = k + Math.imul(r, D$) | 0, A = A + Math.imul(Q, L$) | 0, v = v + Math.imul(Q, C$) | 0, v = v + Math.imul(v$, L$) | 0, k = k + Math.imul(v$, C$) | 0, A = A + Math.imul($$, g$) | 0, v = v + Math.imul($$, h$) | 0, v = v + Math.imul(t, g$) | 0, k = k + Math.imul(t, h$) | 0, A = A + Math.imul(l, b$) | 0, v = v + Math.imul(l, y$) | 0, v = v + Math.imul(a, b$) | 0, k = k + Math.imul(a, y$) | 0, A = A + Math.imul(C, E$) | 0, v = v + Math.imul(C, u) | 0, v = v + Math.imul(L, E$) | 0, k = k + Math.imul(L, u) | 0;
        var t6 = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (t6 >>> 26) | 0, t6 &= 67108863, A = Math.imul(d, S$), v = Math.imul(d, V$), v = v + Math.imul(o, S$) | 0, k = Math.imul(o, V$), A = A + Math.imul(e, N$) | 0, v = v + Math.imul(e, D$) | 0, v = v + Math.imul(_$2, N$) | 0, k = k + Math.imul(_$2, D$) | 0, A = A + Math.imul(m, L$) | 0, v = v + Math.imul(m, C$) | 0, v = v + Math.imul(r, L$) | 0, k = k + Math.imul(r, C$) | 0, A = A + Math.imul(Q, g$) | 0, v = v + Math.imul(Q, h$) | 0, v = v + Math.imul(v$, g$) | 0, k = k + Math.imul(v$, h$) | 0, A = A + Math.imul($$, b$) | 0, v = v + Math.imul($$, y$) | 0, v = v + Math.imul(t, b$) | 0, k = k + Math.imul(t, y$) | 0, A = A + Math.imul(l, E$) | 0, v = v + Math.imul(l, u) | 0, v = v + Math.imul(a, E$) | 0, k = k + Math.imul(a, u) | 0, A = A + Math.imul(C, K$) | 0, v = v + Math.imul(C, P$) | 0, v = v + Math.imul(L, K$) | 0, k = k + Math.imul(L, P$) | 0;
        var B6 = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (B6 >>> 26) | 0, B6 &= 67108863, A = Math.imul(B, S$), v = Math.imul(B, V$), v = v + Math.imul(F, S$) | 0, k = Math.imul(F, V$), A = A + Math.imul(d, N$) | 0, v = v + Math.imul(d, D$) | 0, v = v + Math.imul(o, N$) | 0, k = k + Math.imul(o, D$) | 0, A = A + Math.imul(e, L$) | 0, v = v + Math.imul(e, C$) | 0, v = v + Math.imul(_$2, L$) | 0, k = k + Math.imul(_$2, C$) | 0, A = A + Math.imul(m, g$) | 0, v = v + Math.imul(m, h$) | 0, v = v + Math.imul(r, g$) | 0, k = k + Math.imul(r, h$) | 0, A = A + Math.imul(Q, b$) | 0, v = v + Math.imul(Q, y$) | 0, v = v + Math.imul(v$, b$) | 0, k = k + Math.imul(v$, y$) | 0, A = A + Math.imul($$, E$) | 0, v = v + Math.imul($$, u) | 0, v = v + Math.imul(t, E$) | 0, k = k + Math.imul(t, u) | 0, A = A + Math.imul(l, K$) | 0, v = v + Math.imul(l, P$) | 0, v = v + Math.imul(a, K$) | 0, k = k + Math.imul(a, P$) | 0, A = A + Math.imul(C, k$) | 0, v = v + Math.imul(C, G$) | 0, v = v + Math.imul(L, k$) | 0, k = k + Math.imul(L, G$) | 0;
        var U6 = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (U6 >>> 26) | 0, U6 &= 67108863, A = Math.imul(z$, S$), v = Math.imul(z$, V$), v = v + Math.imul(j$, S$) | 0, k = Math.imul(j$, V$), A = A + Math.imul(B, N$) | 0, v = v + Math.imul(B, D$) | 0, v = v + Math.imul(F, N$) | 0, k = k + Math.imul(F, D$) | 0, A = A + Math.imul(d, L$) | 0, v = v + Math.imul(d, C$) | 0, v = v + Math.imul(o, L$) | 0, k = k + Math.imul(o, C$) | 0, A = A + Math.imul(e, g$) | 0, v = v + Math.imul(e, h$) | 0, v = v + Math.imul(_$2, g$) | 0, k = k + Math.imul(_$2, h$) | 0, A = A + Math.imul(m, b$) | 0, v = v + Math.imul(m, y$) | 0, v = v + Math.imul(r, b$) | 0, k = k + Math.imul(r, y$) | 0, A = A + Math.imul(Q, E$) | 0, v = v + Math.imul(Q, u) | 0, v = v + Math.imul(v$, E$) | 0, k = k + Math.imul(v$, u) | 0, A = A + Math.imul($$, K$) | 0, v = v + Math.imul($$, P$) | 0, v = v + Math.imul(t, K$) | 0, k = k + Math.imul(t, P$) | 0, A = A + Math.imul(l, k$) | 0, v = v + Math.imul(l, G$) | 0, v = v + Math.imul(a, k$) | 0, k = k + Math.imul(a, G$) | 0, A = A + Math.imul(C, R$) | 0, v = v + Math.imul(C, u$) | 0, v = v + Math.imul(L, R$) | 0, k = k + Math.imul(L, u$) | 0;
        var F6 = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (F6 >>> 26) | 0, F6 &= 67108863, A = Math.imul(Z$, S$), v = Math.imul(Z$, V$), v = v + Math.imul(A$, S$) | 0, k = Math.imul(A$, V$), A = A + Math.imul(z$, N$) | 0, v = v + Math.imul(z$, D$) | 0, v = v + Math.imul(j$, N$) | 0, k = k + Math.imul(j$, D$) | 0, A = A + Math.imul(B, L$) | 0, v = v + Math.imul(B, C$) | 0, v = v + Math.imul(F, L$) | 0, k = k + Math.imul(F, C$) | 0, A = A + Math.imul(d, g$) | 0, v = v + Math.imul(d, h$) | 0, v = v + Math.imul(o, g$) | 0, k = k + Math.imul(o, h$) | 0, A = A + Math.imul(e, b$) | 0, v = v + Math.imul(e, y$) | 0, v = v + Math.imul(_$2, b$) | 0, k = k + Math.imul(_$2, y$) | 0, A = A + Math.imul(m, E$) | 0, v = v + Math.imul(m, u) | 0, v = v + Math.imul(r, E$) | 0, k = k + Math.imul(r, u) | 0, A = A + Math.imul(Q, K$) | 0, v = v + Math.imul(Q, P$) | 0, v = v + Math.imul(v$, K$) | 0, k = k + Math.imul(v$, P$) | 0, A = A + Math.imul($$, k$) | 0, v = v + Math.imul($$, G$) | 0, v = v + Math.imul(t, k$) | 0, k = k + Math.imul(t, G$) | 0, A = A + Math.imul(l, R$) | 0, v = v + Math.imul(l, u$) | 0, v = v + Math.imul(a, R$) | 0, k = k + Math.imul(a, u$) | 0, A = A + Math.imul(C, I$) | 0, v = v + Math.imul(C, M$) | 0, v = v + Math.imul(L, I$) | 0, k = k + Math.imul(L, M$) | 0;
        var a6 = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (a6 >>> 26) | 0, a6 &= 67108863, A = Math.imul(Z$, N$), v = Math.imul(Z$, D$), v = v + Math.imul(A$, N$) | 0, k = Math.imul(A$, D$), A = A + Math.imul(z$, L$) | 0, v = v + Math.imul(z$, C$) | 0, v = v + Math.imul(j$, L$) | 0, k = k + Math.imul(j$, C$) | 0, A = A + Math.imul(B, g$) | 0, v = v + Math.imul(B, h$) | 0, v = v + Math.imul(F, g$) | 0, k = k + Math.imul(F, h$) | 0, A = A + Math.imul(d, b$) | 0, v = v + Math.imul(d, y$) | 0, v = v + Math.imul(o, b$) | 0, k = k + Math.imul(o, y$) | 0, A = A + Math.imul(e, E$) | 0, v = v + Math.imul(e, u) | 0, v = v + Math.imul(_$2, E$) | 0, k = k + Math.imul(_$2, u) | 0, A = A + Math.imul(m, K$) | 0, v = v + Math.imul(m, P$) | 0, v = v + Math.imul(r, K$) | 0, k = k + Math.imul(r, P$) | 0, A = A + Math.imul(Q, k$) | 0, v = v + Math.imul(Q, G$) | 0, v = v + Math.imul(v$, k$) | 0, k = k + Math.imul(v$, G$) | 0, A = A + Math.imul($$, R$) | 0, v = v + Math.imul($$, u$) | 0, v = v + Math.imul(t, R$) | 0, k = k + Math.imul(t, u$) | 0, A = A + Math.imul(l, I$) | 0, v = v + Math.imul(l, M$) | 0, v = v + Math.imul(a, I$) | 0, k = k + Math.imul(a, M$) | 0;
        var Q6 = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (Q6 >>> 26) | 0, Q6 &= 67108863, A = Math.imul(Z$, L$), v = Math.imul(Z$, C$), v = v + Math.imul(A$, L$) | 0, k = Math.imul(A$, C$), A = A + Math.imul(z$, g$) | 0, v = v + Math.imul(z$, h$) | 0, v = v + Math.imul(j$, g$) | 0, k = k + Math.imul(j$, h$) | 0, A = A + Math.imul(B, b$) | 0, v = v + Math.imul(B, y$) | 0, v = v + Math.imul(F, b$) | 0, k = k + Math.imul(F, y$) | 0, A = A + Math.imul(d, E$) | 0, v = v + Math.imul(d, u) | 0, v = v + Math.imul(o, E$) | 0, k = k + Math.imul(o, u) | 0, A = A + Math.imul(e, K$) | 0, v = v + Math.imul(e, P$) | 0, v = v + Math.imul(_$2, K$) | 0, k = k + Math.imul(_$2, P$) | 0, A = A + Math.imul(m, k$) | 0, v = v + Math.imul(m, G$) | 0, v = v + Math.imul(r, k$) | 0, k = k + Math.imul(r, G$) | 0, A = A + Math.imul(Q, R$) | 0, v = v + Math.imul(Q, u$) | 0, v = v + Math.imul(v$, R$) | 0, k = k + Math.imul(v$, u$) | 0, A = A + Math.imul($$, I$) | 0, v = v + Math.imul($$, M$) | 0, v = v + Math.imul(t, I$) | 0, k = k + Math.imul(t, M$) | 0;
        var e6 = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (e6 >>> 26) | 0, e6 &= 67108863, A = Math.imul(Z$, g$), v = Math.imul(Z$, h$), v = v + Math.imul(A$, g$) | 0, k = Math.imul(A$, h$), A = A + Math.imul(z$, b$) | 0, v = v + Math.imul(z$, y$) | 0, v = v + Math.imul(j$, b$) | 0, k = k + Math.imul(j$, y$) | 0, A = A + Math.imul(B, E$) | 0, v = v + Math.imul(B, u) | 0, v = v + Math.imul(F, E$) | 0, k = k + Math.imul(F, u) | 0, A = A + Math.imul(d, K$) | 0, v = v + Math.imul(d, P$) | 0, v = v + Math.imul(o, K$) | 0, k = k + Math.imul(o, P$) | 0, A = A + Math.imul(e, k$) | 0, v = v + Math.imul(e, G$) | 0, v = v + Math.imul(_$2, k$) | 0, k = k + Math.imul(_$2, G$) | 0, A = A + Math.imul(m, R$) | 0, v = v + Math.imul(m, u$) | 0, v = v + Math.imul(r, R$) | 0, k = k + Math.imul(r, u$) | 0, A = A + Math.imul(Q, I$) | 0, v = v + Math.imul(Q, M$) | 0, v = v + Math.imul(v$, I$) | 0, k = k + Math.imul(v$, M$) | 0;
        var s6 = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (s6 >>> 26) | 0, s6 &= 67108863, A = Math.imul(Z$, b$), v = Math.imul(Z$, y$), v = v + Math.imul(A$, b$) | 0, k = Math.imul(A$, y$), A = A + Math.imul(z$, E$) | 0, v = v + Math.imul(z$, u) | 0, v = v + Math.imul(j$, E$) | 0, k = k + Math.imul(j$, u) | 0, A = A + Math.imul(B, K$) | 0, v = v + Math.imul(B, P$) | 0, v = v + Math.imul(F, K$) | 0, k = k + Math.imul(F, P$) | 0, A = A + Math.imul(d, k$) | 0, v = v + Math.imul(d, G$) | 0, v = v + Math.imul(o, k$) | 0, k = k + Math.imul(o, G$) | 0, A = A + Math.imul(e, R$) | 0, v = v + Math.imul(e, u$) | 0, v = v + Math.imul(_$2, R$) | 0, k = k + Math.imul(_$2, u$) | 0, A = A + Math.imul(m, I$) | 0, v = v + Math.imul(m, M$) | 0, v = v + Math.imul(r, I$) | 0, k = k + Math.imul(r, M$) | 0;
        var $q = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + ($q >>> 26) | 0, $q &= 67108863, A = Math.imul(Z$, E$), v = Math.imul(Z$, u), v = v + Math.imul(A$, E$) | 0, k = Math.imul(A$, u), A = A + Math.imul(z$, K$) | 0, v = v + Math.imul(z$, P$) | 0, v = v + Math.imul(j$, K$) | 0, k = k + Math.imul(j$, P$) | 0, A = A + Math.imul(B, k$) | 0, v = v + Math.imul(B, G$) | 0, v = v + Math.imul(F, k$) | 0, k = k + Math.imul(F, G$) | 0, A = A + Math.imul(d, R$) | 0, v = v + Math.imul(d, u$) | 0, v = v + Math.imul(o, R$) | 0, k = k + Math.imul(o, u$) | 0, A = A + Math.imul(e, I$) | 0, v = v + Math.imul(e, M$) | 0, v = v + Math.imul(_$2, I$) | 0, k = k + Math.imul(_$2, M$) | 0;
        var qq = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (qq >>> 26) | 0, qq &= 67108863, A = Math.imul(Z$, K$), v = Math.imul(Z$, P$), v = v + Math.imul(A$, K$) | 0, k = Math.imul(A$, P$), A = A + Math.imul(z$, k$) | 0, v = v + Math.imul(z$, G$) | 0, v = v + Math.imul(j$, k$) | 0, k = k + Math.imul(j$, G$) | 0, A = A + Math.imul(B, R$) | 0, v = v + Math.imul(B, u$) | 0, v = v + Math.imul(F, R$) | 0, k = k + Math.imul(F, u$) | 0, A = A + Math.imul(d, I$) | 0, v = v + Math.imul(d, M$) | 0, v = v + Math.imul(o, I$) | 0, k = k + Math.imul(o, M$) | 0;
        var Kq = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (Kq >>> 26) | 0, Kq &= 67108863, A = Math.imul(Z$, k$), v = Math.imul(Z$, G$), v = v + Math.imul(A$, k$) | 0, k = Math.imul(A$, G$), A = A + Math.imul(z$, R$) | 0, v = v + Math.imul(z$, u$) | 0, v = v + Math.imul(j$, R$) | 0, k = k + Math.imul(j$, u$) | 0, A = A + Math.imul(B, I$) | 0, v = v + Math.imul(B, M$) | 0, v = v + Math.imul(F, I$) | 0, k = k + Math.imul(F, M$) | 0;
        var _q = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (_q >>> 26) | 0, _q &= 67108863, A = Math.imul(Z$, R$), v = Math.imul(Z$, u$), v = v + Math.imul(A$, R$) | 0, k = Math.imul(A$, u$), A = A + Math.imul(z$, I$) | 0, v = v + Math.imul(z$, M$) | 0, v = v + Math.imul(j$, I$) | 0, k = k + Math.imul(j$, M$) | 0;
        var Pq = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (Pq >>> 26) | 0, Pq &= 67108863, A = Math.imul(Z$, I$), v = Math.imul(Z$, M$), v = v + Math.imul(A$, I$) | 0, k = Math.imul(A$, M$);
        var Oq = (S + A | 0) + ((v & 8191) << 13) | 0;
        if (S = (k + (v >>> 13) | 0) + (Oq >>> 26) | 0, Oq &= 67108863, G[0] = p6, G[1] = H6, G[2] = v6, G[3] = C6, G[4] = S6, G[5] = t6, G[6] = B6, G[7] = U6, G[8] = F6, G[9] = a6, G[10] = Q6, G[11] = e6, G[12] = s6, G[13] = $q, G[14] = qq, G[15] = Kq, G[16] = _q, G[17] = Pq, G[18] = Oq, S !== 0) G[19] = S, Z.length++;
        return Z;
      }, "h");
      if (!Math.imul) h = E;
      function I(j, H, Z) {
        Z.negative = H.negative ^ j.negative, Z.length = j.length + H.length;
        var W = 0, w = 0;
        for (var G = 0; G < Z.length - 1; G++) {
          var S = w;
          w = 0;
          var A = W & 67108863, v = Math.min(G, H.length - 1);
          for (var k = Math.max(0, G - j.length + 1); k <= v; k++) {
            var R = G - k, C = j.words[R] | 0, L = H.words[k] | 0, x = C * L, l = x & 67108863;
            S = S + (x / 67108864 | 0) | 0, l = l + A | 0, A = l & 67108863, S = S + (l >>> 26) | 0, w += S >>> 26, S &= 67108863;
          }
          Z.words[G] = A, W = S, S = w;
        }
        if (W !== 0) Z.words[G] = W;
        else Z.length--;
        return Z.strip();
      }
      __name(I, "I");
      function D(j, H, Z) {
        var W = new g();
        return W.mulp(j, H, Z);
      }
      __name(D, "D");
      O.prototype.mulTo = function(j, H) {
        var Z, W = this.length + j.length;
        if (this.length === 10 && j.length === 10) Z = h(this, j, H);
        else if (W < 63) Z = E(this, j, H);
        else if (W < 1024) Z = I(this, j, H);
        else Z = D(this, j, H);
        return Z;
      };
      function g(j, H) {
        this.x = j, this.y = H;
      }
      __name(g, "g");
      g.prototype.makeRBT = function(j) {
        var H = Array(j), Z = O.prototype._countBits(j) - 1;
        for (var W = 0; W < j; W++) H[W] = this.revBin(W, Z, j);
        return H;
      }, g.prototype.revBin = function(j, H, Z) {
        if (j === 0 || j === Z - 1) return j;
        var W = 0;
        for (var w = 0; w < H; w++) W |= (j & 1) << H - w - 1, j >>= 1;
        return W;
      }, g.prototype.permute = function(j, H, Z, W, w, G) {
        for (var S = 0; S < G; S++) W[S] = H[j[S]], w[S] = Z[j[S]];
      }, g.prototype.transform = function(j, H, Z, W, w, G) {
        this.permute(G, j, H, Z, W, w);
        for (var S = 1; S < w; S <<= 1) {
          var A = S << 1, v = Math.cos(2 * Math.PI / A), k = Math.sin(2 * Math.PI / A);
          for (var R = 0; R < w; R += A) {
            var C = v, L = k;
            for (var x = 0; x < S; x++) {
              var l = Z[R + x], a = W[R + x], f$ = Z[R + x + S], $$ = W[R + x + S], t = C * f$ - L * $$;
              if ($$ = C * $$ + L * f$, f$ = t, Z[R + x] = l + f$, W[R + x] = a + $$, Z[R + x + S] = l - f$, W[R + x + S] = a - $$, x !== A) t = v * C - k * L, L = v * L + k * C, C = t;
            }
          }
        }
      }, g.prototype.guessLen13b = function(j, H) {
        var Z = Math.max(H, j) | 1, W = Z & 1, w = 0;
        for (Z = Z / 2 | 0; Z; Z = Z >>> 1) w++;
        return 1 << w + 1 + W;
      }, g.prototype.conjugate = function(j, H, Z) {
        if (Z <= 1) return;
        for (var W = 0; W < Z / 2; W++) {
          var w = j[W];
          j[W] = j[Z - W - 1], j[Z - W - 1] = w, w = H[W], H[W] = -H[Z - W - 1], H[Z - W - 1] = -w;
        }
      }, g.prototype.normalize13b = function(j, H) {
        var Z = 0;
        for (var W = 0; W < H / 2; W++) {
          var w = Math.round(j[2 * W + 1] / H) * 8192 + Math.round(j[2 * W] / H) + Z;
          if (j[W] = w & 67108863, w < 67108864) Z = 0;
          else Z = w / 67108864 | 0;
        }
        return j;
      }, g.prototype.convert13b = function(j, H, Z, W) {
        var w = 0;
        for (var G = 0; G < H; G++) w = w + (j[G] | 0), Z[2 * G] = w & 8191, w = w >>> 13, Z[2 * G + 1] = w & 8191, w = w >>> 13;
        for (G = 2 * H; G < W; ++G) Z[G] = 0;
        _(w === 0), _((w & -8192) === 0);
      }, g.prototype.stub = function(j) {
        var H = Array(j);
        for (var Z = 0; Z < j; Z++) H[Z] = 0;
        return H;
      }, g.prototype.mulp = function(j, H, Z) {
        var W = 2 * this.guessLen13b(j.length, H.length), w = this.makeRBT(W), G = this.stub(W), S = Array(W), A = Array(W), v = Array(W), k = Array(W), R = Array(W), C = Array(W), L = Z.words;
        L.length = W, this.convert13b(j.words, j.length, S, W), this.convert13b(H.words, H.length, k, W), this.transform(S, G, A, v, W, w), this.transform(k, G, R, C, W, w);
        for (var x = 0; x < W; x++) {
          var l = A[x] * R[x] - v[x] * C[x];
          v[x] = A[x] * C[x] + v[x] * R[x], A[x] = l;
        }
        return this.conjugate(A, v, W), this.transform(A, v, L, G, W, w), this.conjugate(L, G, W), this.normalize13b(L, W), Z.negative = j.negative ^ H.negative, Z.length = j.length + H.length, Z.strip();
      }, O.prototype.mul = function(j) {
        var H = new O(null);
        return H.words = Array(this.length + j.length), this.mulTo(j, H);
      }, O.prototype.mulf = function(j) {
        var H = new O(null);
        return H.words = Array(this.length + j.length), D(this, j, H);
      }, O.prototype.imul = function(j) {
        return this.clone().mulTo(j, this);
      }, O.prototype.imuln = function(j) {
        _(typeof j === "number"), _(j < 67108864);
        var H = 0;
        for (var Z = 0; Z < this.length; Z++) {
          var W = (this.words[Z] | 0) * j, w = (W & 67108863) + (H & 67108863);
          H >>= 26, H += W / 67108864 | 0, H += w >>> 26, this.words[Z] = w & 67108863;
        }
        if (H !== 0) this.words[Z] = H, this.length++;
        return this.length = j === 0 ? 1 : this.length, this;
      }, O.prototype.muln = function(j) {
        return this.clone().imuln(j);
      }, O.prototype.sqr = function() {
        return this.mul(this);
      }, O.prototype.isqr = function() {
        return this.imul(this.clone());
      }, O.prototype.pow = function(j) {
        var H = N(j);
        if (H.length === 0) return new O(1);
        var Z = this;
        for (var W = 0; W < H.length; W++, Z = Z.sqr()) if (H[W] !== 0) break;
        if (++W < H.length) for (var w = Z.sqr(); W < H.length; W++, w = w.sqr()) {
          if (H[W] === 0) continue;
          Z = Z.mul(w);
        }
        return Z;
      }, O.prototype.iushln = function(j) {
        _(typeof j === "number" && j >= 0);
        var H = j % 26, Z = (j - H) / 26, W = 67108863 >>> 26 - H << 26 - H, w;
        if (H !== 0) {
          var G = 0;
          for (w = 0; w < this.length; w++) {
            var S = this.words[w] & W, A = (this.words[w] | 0) - S << H;
            this.words[w] = A | G, G = S >>> 26 - H;
          }
          if (G) this.words[w] = G, this.length++;
        }
        if (Z !== 0) {
          for (w = this.length - 1; w >= 0; w--) this.words[w + Z] = this.words[w];
          for (w = 0; w < Z; w++) this.words[w] = 0;
          this.length += Z;
        }
        return this.strip();
      }, O.prototype.ishln = function(j) {
        return _(this.negative === 0), this.iushln(j);
      }, O.prototype.iushrn = function(j, H, Z) {
        _(typeof j === "number" && j >= 0);
        var W;
        if (H) W = (H - H % 26) / 26;
        else W = 0;
        var w = j % 26, G = Math.min((j - w) / 26, this.length), S = 67108863 ^ 67108863 >>> w << w, A = Z;
        if (W -= G, W = Math.max(0, W), A) {
          for (var v = 0; v < G; v++) A.words[v] = this.words[v];
          A.length = G;
        }
        if (G === 0) ;
        else if (this.length > G) {
          this.length -= G;
          for (v = 0; v < this.length; v++) this.words[v] = this.words[v + G];
        } else this.words[0] = 0, this.length = 1;
        var k = 0;
        for (v = this.length - 1; v >= 0 && (k !== 0 || v >= W); v--) {
          var R = this.words[v] | 0;
          this.words[v] = k << 26 - w | R >>> w, k = R & S;
        }
        if (A && k !== 0) A.words[A.length++] = k;
        if (this.length === 0) this.words[0] = 0, this.length = 1;
        return this.strip();
      }, O.prototype.ishrn = function(j, H, Z) {
        return _(this.negative === 0), this.iushrn(j, H, Z);
      }, O.prototype.shln = function(j) {
        return this.clone().ishln(j);
      }, O.prototype.ushln = function(j) {
        return this.clone().iushln(j);
      }, O.prototype.shrn = function(j) {
        return this.clone().ishrn(j);
      }, O.prototype.ushrn = function(j) {
        return this.clone().iushrn(j);
      }, O.prototype.testn = function(j) {
        _(typeof j === "number" && j >= 0);
        var H = j % 26, Z = (j - H) / 26, W = 1 << H;
        if (this.length <= Z) return false;
        var w = this.words[Z];
        return !!(w & W);
      }, O.prototype.imaskn = function(j) {
        _(typeof j === "number" && j >= 0);
        var H = j % 26, Z = (j - H) / 26;
        if (_(this.negative === 0, "imaskn works only with positive numbers"), this.length <= Z) return this;
        if (H !== 0) Z++;
        if (this.length = Math.min(Z, this.length), H !== 0) {
          var W = 67108863 ^ 67108863 >>> H << H;
          this.words[this.length - 1] &= W;
        }
        return this.strip();
      }, O.prototype.maskn = function(j) {
        return this.clone().imaskn(j);
      }, O.prototype.iaddn = function(j) {
        if (_(typeof j === "number"), _(j < 67108864), j < 0) return this.isubn(-j);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) < j) return this.words[0] = j - (this.words[0] | 0), this.negative = 0, this;
          return this.negative = 0, this.isubn(j), this.negative = 1, this;
        }
        return this._iaddn(j);
      }, O.prototype._iaddn = function(j) {
        this.words[0] += j;
        for (var H = 0; H < this.length && this.words[H] >= 67108864; H++) if (this.words[H] -= 67108864, H === this.length - 1) this.words[H + 1] = 1;
        else this.words[H + 1]++;
        return this.length = Math.max(this.length, H + 1), this;
      }, O.prototype.isubn = function(j) {
        if (_(typeof j === "number"), _(j < 67108864), j < 0) return this.iaddn(-j);
        if (this.negative !== 0) return this.negative = 0, this.iaddn(j), this.negative = 1, this;
        if (this.words[0] -= j, this.length === 1 && this.words[0] < 0) this.words[0] = -this.words[0], this.negative = 1;
        else for (var H = 0; H < this.length && this.words[H] < 0; H++) this.words[H] += 67108864, this.words[H + 1] -= 1;
        return this.strip();
      }, O.prototype.addn = function(j) {
        return this.clone().iaddn(j);
      }, O.prototype.subn = function(j) {
        return this.clone().isubn(j);
      }, O.prototype.iabs = function() {
        return this.negative = 0, this;
      }, O.prototype.abs = function() {
        return this.clone().iabs();
      }, O.prototype._ishlnsubmul = function(j, H, Z) {
        var W = j.length + Z, w;
        this._expand(W);
        var G, S = 0;
        for (w = 0; w < j.length; w++) {
          G = (this.words[w + Z] | 0) + S;
          var A = (j.words[w] | 0) * H;
          G -= A & 67108863, S = (G >> 26) - (A / 67108864 | 0), this.words[w + Z] = G & 67108863;
        }
        for (; w < this.length - Z; w++) G = (this.words[w + Z] | 0) + S, S = G >> 26, this.words[w + Z] = G & 67108863;
        if (S === 0) return this.strip();
        _(S === -1), S = 0;
        for (w = 0; w < this.length; w++) G = -(this.words[w] | 0) + S, S = G >> 26, this.words[w] = G & 67108863;
        return this.negative = 1, this.strip();
      }, O.prototype._wordDiv = function(j, H) {
        var Z = this.length - j.length, W = this.clone(), w = j, G = w.words[w.length - 1] | 0, S = this._countBits(G);
        if (Z = 26 - S, Z !== 0) w = w.ushln(Z), W.iushln(Z), G = w.words[w.length - 1] | 0;
        var A = W.length - w.length, v;
        if (H !== "mod") {
          v = new O(null), v.length = A + 1, v.words = Array(v.length);
          for (var k = 0; k < v.length; k++) v.words[k] = 0;
        }
        var R = W.clone()._ishlnsubmul(w, 1, A);
        if (R.negative === 0) {
          if (W = R, v) v.words[A] = 1;
        }
        for (var C = A - 1; C >= 0; C--) {
          var L = (W.words[w.length + C] | 0) * 67108864 + (W.words[w.length + C - 1] | 0);
          L = Math.min(L / G | 0, 67108863), W._ishlnsubmul(w, L, C);
          while (W.negative !== 0) if (L--, W.negative = 0, W._ishlnsubmul(w, 1, C), !W.isZero()) W.negative ^= 1;
          if (v) v.words[C] = L;
        }
        if (v) v.strip();
        if (W.strip(), H !== "div" && Z !== 0) W.iushrn(Z);
        return { div: v || null, mod: W };
      }, O.prototype.divmod = function(j, H, Z) {
        if (_(!j.isZero()), this.isZero()) return { div: new O(0), mod: new O(0) };
        var W, w, G;
        if (this.negative !== 0 && j.negative === 0) {
          if (G = this.neg().divmod(j, H), H !== "mod") W = G.div.neg();
          if (H !== "div") {
            if (w = G.mod.neg(), Z && w.negative !== 0) w.iadd(j);
          }
          return { div: W, mod: w };
        }
        if (this.negative === 0 && j.negative !== 0) {
          if (G = this.divmod(j.neg(), H), H !== "mod") W = G.div.neg();
          return { div: W, mod: G.mod };
        }
        if ((this.negative & j.negative) !== 0) {
          if (G = this.neg().divmod(j.neg(), H), H !== "div") {
            if (w = G.mod.neg(), Z && w.negative !== 0) w.isub(j);
          }
          return { div: G.div, mod: w };
        }
        if (j.length > this.length || this.cmp(j) < 0) return { div: new O(0), mod: this };
        if (j.length === 1) {
          if (H === "div") return { div: this.divn(j.words[0]), mod: null };
          if (H === "mod") return { div: null, mod: new O(this.modn(j.words[0])) };
          return { div: this.divn(j.words[0]), mod: new O(this.modn(j.words[0])) };
        }
        return this._wordDiv(j, H);
      }, O.prototype.div = function(j) {
        return this.divmod(j, "div", false).div;
      }, O.prototype.mod = function(j) {
        return this.divmod(j, "mod", false).mod;
      }, O.prototype.umod = function(j) {
        return this.divmod(j, "mod", true).mod;
      }, O.prototype.divRound = function(j) {
        var H = this.divmod(j);
        if (H.mod.isZero()) return H.div;
        var Z = H.div.negative !== 0 ? H.mod.isub(j) : H.mod, W = j.ushrn(1), w = j.andln(1), G = Z.cmp(W);
        if (G < 0 || w === 1 && G === 0) return H.div;
        return H.div.negative !== 0 ? H.div.isubn(1) : H.div.iaddn(1);
      }, O.prototype.modn = function(j) {
        _(j <= 67108863);
        var H = 67108864 % j, Z = 0;
        for (var W = this.length - 1; W >= 0; W--) Z = (H * Z + (this.words[W] | 0)) % j;
        return Z;
      }, O.prototype.idivn = function(j) {
        _(j <= 67108863);
        var H = 0;
        for (var Z = this.length - 1; Z >= 0; Z--) {
          var W = (this.words[Z] | 0) + H * 67108864;
          this.words[Z] = W / j | 0, H = W % j;
        }
        return this.strip();
      }, O.prototype.divn = function(j) {
        return this.clone().idivn(j);
      }, O.prototype.egcd = function(j) {
        _(j.negative === 0), _(!j.isZero());
        var H = this, Z = j.clone();
        if (H.negative !== 0) H = H.umod(j);
        else H = H.clone();
        var W = new O(1), w = new O(0), G = new O(0), S = new O(1), A = 0;
        while (H.isEven() && Z.isEven()) H.iushrn(1), Z.iushrn(1), ++A;
        var v = Z.clone(), k = H.clone();
        while (!H.isZero()) {
          for (var R = 0, C = 1; (H.words[0] & C) === 0 && R < 26; ++R, C <<= 1) ;
          if (R > 0) {
            H.iushrn(R);
            while (R-- > 0) {
              if (W.isOdd() || w.isOdd()) W.iadd(v), w.isub(k);
              W.iushrn(1), w.iushrn(1);
            }
          }
          for (var L = 0, x = 1; (Z.words[0] & x) === 0 && L < 26; ++L, x <<= 1) ;
          if (L > 0) {
            Z.iushrn(L);
            while (L-- > 0) {
              if (G.isOdd() || S.isOdd()) G.iadd(v), S.isub(k);
              G.iushrn(1), S.iushrn(1);
            }
          }
          if (H.cmp(Z) >= 0) H.isub(Z), W.isub(G), w.isub(S);
          else Z.isub(H), G.isub(W), S.isub(w);
        }
        return { a: G, b: S, gcd: Z.iushln(A) };
      }, O.prototype._invmp = function(j) {
        _(j.negative === 0), _(!j.isZero());
        var H = this, Z = j.clone();
        if (H.negative !== 0) H = H.umod(j);
        else H = H.clone();
        var W = new O(1), w = new O(0), G = Z.clone();
        while (H.cmpn(1) > 0 && Z.cmpn(1) > 0) {
          for (var S = 0, A = 1; (H.words[0] & A) === 0 && S < 26; ++S, A <<= 1) ;
          if (S > 0) {
            H.iushrn(S);
            while (S-- > 0) {
              if (W.isOdd()) W.iadd(G);
              W.iushrn(1);
            }
          }
          for (var v = 0, k = 1; (Z.words[0] & k) === 0 && v < 26; ++v, k <<= 1) ;
          if (v > 0) {
            Z.iushrn(v);
            while (v-- > 0) {
              if (w.isOdd()) w.iadd(G);
              w.iushrn(1);
            }
          }
          if (H.cmp(Z) >= 0) H.isub(Z), W.isub(w);
          else Z.isub(H), w.isub(W);
        }
        var R;
        if (H.cmpn(1) === 0) R = W;
        else R = w;
        if (R.cmpn(0) < 0) R.iadd(j);
        return R;
      }, O.prototype.gcd = function(j) {
        if (this.isZero()) return j.abs();
        if (j.isZero()) return this.abs();
        var H = this.clone(), Z = j.clone();
        H.negative = 0, Z.negative = 0;
        for (var W = 0; H.isEven() && Z.isEven(); W++) H.iushrn(1), Z.iushrn(1);
        do {
          while (H.isEven()) H.iushrn(1);
          while (Z.isEven()) Z.iushrn(1);
          var w = H.cmp(Z);
          if (w < 0) {
            var G = H;
            H = Z, Z = G;
          } else if (w === 0 || Z.cmpn(1) === 0) break;
          H.isub(Z);
        } while (true);
        return Z.iushln(W);
      }, O.prototype.invm = function(j) {
        return this.egcd(j).a.umod(j);
      }, O.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, O.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, O.prototype.andln = function(j) {
        return this.words[0] & j;
      }, O.prototype.bincn = function(j) {
        _(typeof j === "number");
        var H = j % 26, Z = (j - H) / 26, W = 1 << H;
        if (this.length <= Z) return this._expand(Z + 1), this.words[Z] |= W, this;
        var w = W;
        for (var G = Z; w !== 0 && G < this.length; G++) {
          var S = this.words[G] | 0;
          S += w, w = S >>> 26, S &= 67108863, this.words[G] = S;
        }
        if (w !== 0) this.words[G] = w, this.length++;
        return this;
      }, O.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, O.prototype.cmpn = function(j) {
        var H = j < 0;
        if (this.negative !== 0 && !H) return -1;
        if (this.negative === 0 && H) return 1;
        this.strip();
        var Z;
        if (this.length > 1) Z = 1;
        else {
          if (H) j = -j;
          _(j <= 67108863, "Number is too big");
          var W = this.words[0] | 0;
          Z = W === j ? 0 : W < j ? -1 : 1;
        }
        if (this.negative !== 0) return -Z | 0;
        return Z;
      }, O.prototype.cmp = function(j) {
        if (this.negative !== 0 && j.negative === 0) return -1;
        if (this.negative === 0 && j.negative !== 0) return 1;
        var H = this.ucmp(j);
        if (this.negative !== 0) return -H | 0;
        return H;
      }, O.prototype.ucmp = function(j) {
        if (this.length > j.length) return 1;
        if (this.length < j.length) return -1;
        var H = 0;
        for (var Z = this.length - 1; Z >= 0; Z--) {
          var W = this.words[Z] | 0, w = j.words[Z] | 0;
          if (W === w) continue;
          if (W < w) H = -1;
          else if (W > w) H = 1;
          break;
        }
        return H;
      }, O.prototype.gtn = function(j) {
        return this.cmpn(j) === 1;
      }, O.prototype.gt = function(j) {
        return this.cmp(j) === 1;
      }, O.prototype.gten = function(j) {
        return this.cmpn(j) >= 0;
      }, O.prototype.gte = function(j) {
        return this.cmp(j) >= 0;
      }, O.prototype.ltn = function(j) {
        return this.cmpn(j) === -1;
      }, O.prototype.lt = function(j) {
        return this.cmp(j) === -1;
      }, O.prototype.lten = function(j) {
        return this.cmpn(j) <= 0;
      }, O.prototype.lte = function(j) {
        return this.cmp(j) <= 0;
      }, O.prototype.eqn = function(j) {
        return this.cmpn(j) === 0;
      }, O.prototype.eq = function(j) {
        return this.cmp(j) === 0;
      }, O.red = function(j) {
        return new c(j);
      }, O.prototype.toRed = function(j) {
        return _(!this.red, "Already a number in reduction context"), _(this.negative === 0, "red works only with positives"), j.convertTo(this)._forceRed(j);
      }, O.prototype.fromRed = function() {
        return _(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, O.prototype._forceRed = function(j) {
        return this.red = j, this;
      }, O.prototype.forceRed = function(j) {
        return _(!this.red, "Already a number in reduction context"), this._forceRed(j);
      }, O.prototype.redAdd = function(j) {
        return _(this.red, "redAdd works only with red numbers"), this.red.add(this, j);
      }, O.prototype.redIAdd = function(j) {
        return _(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, j);
      }, O.prototype.redSub = function(j) {
        return _(this.red, "redSub works only with red numbers"), this.red.sub(this, j);
      }, O.prototype.redISub = function(j) {
        return _(this.red, "redISub works only with red numbers"), this.red.isub(this, j);
      }, O.prototype.redShl = function(j) {
        return _(this.red, "redShl works only with red numbers"), this.red.shl(this, j);
      }, O.prototype.redMul = function(j) {
        return _(this.red, "redMul works only with red numbers"), this.red._verify2(this, j), this.red.mul(this, j);
      }, O.prototype.redIMul = function(j) {
        return _(this.red, "redMul works only with red numbers"), this.red._verify2(this, j), this.red.imul(this, j);
      }, O.prototype.redSqr = function() {
        return _(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, O.prototype.redISqr = function() {
        return _(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, O.prototype.redSqrt = function() {
        return _(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, O.prototype.redInvm = function() {
        return _(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, O.prototype.redNeg = function() {
        return _(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, O.prototype.redPow = function(j) {
        return _(this.red && !j.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, j);
      };
      var b = { k256: null, p224: null, p192: null, p25519: null };
      function y(j, H) {
        this.name = j, this.p = new O(H, 16), this.n = this.p.bitLength(), this.k = new O(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      __name(y, "y");
      y.prototype._tmp = function() {
        var j = new O(null);
        return j.words = Array(Math.ceil(this.n / 13)), j;
      }, y.prototype.ireduce = function(j) {
        var H = j, Z;
        do
          this.split(H, this.tmp), H = this.imulK(H), H = H.iadd(this.tmp), Z = H.bitLength();
        while (Z > this.n);
        var W = Z < this.n ? -1 : H.ucmp(this.p);
        if (W === 0) H.words[0] = 0, H.length = 1;
        else if (W > 0) H.isub(this.p);
        else if (H.strip !== void 0) H.strip();
        else H._strip();
        return H;
      }, y.prototype.split = function(j, H) {
        j.iushrn(this.n, 0, H);
      }, y.prototype.imulK = function(j) {
        return j.imul(this.k);
      };
      function p() {
        y.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
      }
      __name(p, "p");
      Y(p, y), p.prototype.split = function(j, H) {
        var Z = 4194303, W = Math.min(j.length, 9);
        for (var w = 0; w < W; w++) H.words[w] = j.words[w];
        if (H.length = W, j.length <= 9) {
          j.words[0] = 0, j.length = 1;
          return;
        }
        var G = j.words[9];
        H.words[H.length++] = G & Z;
        for (w = 10; w < j.length; w++) {
          var S = j.words[w] | 0;
          j.words[w - 10] = (S & Z) << 4 | G >>> 22, G = S;
        }
        if (G >>>= 22, j.words[w - 10] = G, G === 0 && j.length > 10) j.length -= 10;
        else j.length -= 9;
      }, p.prototype.imulK = function(j) {
        j.words[j.length] = 0, j.words[j.length + 1] = 0, j.length += 2;
        var H = 0;
        for (var Z = 0; Z < j.length; Z++) {
          var W = j.words[Z] | 0;
          H += W * 977, j.words[Z] = H & 67108863, H = W * 64 + (H / 67108864 | 0);
        }
        if (j.words[j.length - 1] === 0) {
          if (j.length--, j.words[j.length - 1] === 0) j.length--;
        }
        return j;
      };
      function n() {
        y.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
      }
      __name(n, "n");
      Y(n, y);
      function s() {
        y.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
      }
      __name(s, "s");
      Y(s, y);
      function q$() {
        y.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
      }
      __name(q$, "q$");
      Y(q$, y), q$.prototype.imulK = function(j) {
        var H = 0;
        for (var Z = 0; Z < j.length; Z++) {
          var W = (j.words[Z] | 0) * 19 + H, w = W & 67108863;
          W >>>= 26, j.words[Z] = w, H = W;
        }
        if (H !== 0) j.words[j.length++] = H;
        return j;
      }, O._prime = function(j) {
        if (b[j]) return b[j];
        var H;
        if (j === "k256") H = new p();
        else if (j === "p224") H = new n();
        else if (j === "p192") H = new s();
        else if (j === "p25519") H = new q$();
        else throw Error("Unknown prime " + j);
        return b[j] = H, H;
      };
      function c(j) {
        if (typeof j === "string") {
          var H = O._prime(j);
          this.m = H.p, this.prime = H;
        } else _(j.gtn(1), "modulus must be greater than 1"), this.m = j, this.prime = null;
      }
      __name(c, "c");
      c.prototype._verify1 = function(j) {
        _(j.negative === 0, "red works only with positives"), _(j.red, "red works only with red numbers");
      }, c.prototype._verify2 = function(j, H) {
        _((j.negative | H.negative) === 0, "red works only with positives"), _(j.red && j.red === H.red, "red works only with red numbers");
      }, c.prototype.imod = function(j) {
        if (this.prime) return this.prime.ireduce(j)._forceRed(this);
        return j.umod(this.m)._forceRed(this);
      }, c.prototype.neg = function(j) {
        if (j.isZero()) return j.clone();
        return this.m.sub(j)._forceRed(this);
      }, c.prototype.add = function(j, H) {
        this._verify2(j, H);
        var Z = j.add(H);
        if (Z.cmp(this.m) >= 0) Z.isub(this.m);
        return Z._forceRed(this);
      }, c.prototype.iadd = function(j, H) {
        this._verify2(j, H);
        var Z = j.iadd(H);
        if (Z.cmp(this.m) >= 0) Z.isub(this.m);
        return Z;
      }, c.prototype.sub = function(j, H) {
        this._verify2(j, H);
        var Z = j.sub(H);
        if (Z.cmpn(0) < 0) Z.iadd(this.m);
        return Z._forceRed(this);
      }, c.prototype.isub = function(j, H) {
        this._verify2(j, H);
        var Z = j.isub(H);
        if (Z.cmpn(0) < 0) Z.iadd(this.m);
        return Z;
      }, c.prototype.shl = function(j, H) {
        return this._verify1(j), this.imod(j.ushln(H));
      }, c.prototype.imul = function(j, H) {
        return this._verify2(j, H), this.imod(j.imul(H));
      }, c.prototype.mul = function(j, H) {
        return this._verify2(j, H), this.imod(j.mul(H));
      }, c.prototype.isqr = function(j) {
        return this.imul(j, j.clone());
      }, c.prototype.sqr = function(j) {
        return this.mul(j, j);
      }, c.prototype.sqrt = function(j) {
        if (j.isZero()) return j.clone();
        var H = this.m.andln(3);
        if (_(H % 2 === 1), H === 3) {
          var Z = this.m.add(new O(1)).iushrn(2);
          return this.pow(j, Z);
        }
        var W = this.m.subn(1), w = 0;
        while (!W.isZero() && W.andln(1) === 0) w++, W.iushrn(1);
        _(!W.isZero());
        var G = new O(1).toRed(this), S = G.redNeg(), A = this.m.subn(1).iushrn(1), v = this.m.bitLength();
        v = new O(2 * v * v).toRed(this);
        while (this.pow(v, A).cmp(S) !== 0) v.redIAdd(S);
        var k = this.pow(v, W), R = this.pow(j, W.addn(1).iushrn(1)), C = this.pow(j, W), L = w;
        while (C.cmp(G) !== 0) {
          var x = C;
          for (var l = 0; x.cmp(G) !== 0; l++) x = x.redSqr();
          _(l < L);
          var a = this.pow(k, new O(1).iushln(L - l - 1));
          R = R.redMul(a), k = a.redSqr(), C = C.redMul(k), L = l;
        }
        return R;
      }, c.prototype.invm = function(j) {
        var H = j._invmp(this.m);
        if (H.negative !== 0) return H.negative = 0, this.imod(H).redNeg();
        else return this.imod(H);
      }, c.prototype.pow = function(j, H) {
        if (H.isZero()) return new O(1).toRed(this);
        if (H.cmpn(1) === 0) return j.clone();
        var Z = 4, W = Array(1 << Z);
        W[0] = new O(1).toRed(this), W[1] = j;
        for (var w = 2; w < W.length; w++) W[w] = this.mul(W[w - 1], j);
        var G = W[0], S = 0, A = 0, v = H.bitLength() % 26;
        if (v === 0) v = 26;
        for (w = H.length - 1; w >= 0; w--) {
          var k = H.words[w];
          for (var R = v - 1; R >= 0; R--) {
            var C = k >> R & 1;
            if (G !== W[0]) G = this.sqr(G);
            if (C === 0 && S === 0) {
              A = 0;
              continue;
            }
            if (S <<= 1, S |= C, A++, A !== Z && (w !== 0 || R !== 0)) continue;
            G = this.mul(G, W[S]), A = 0, S = 0;
          }
          v = 26;
        }
        return G;
      }, c.prototype.convertTo = function(j) {
        var H = j.umod(this.m);
        return H === j ? H.clone() : H;
      }, c.prototype.convertFrom = function(j) {
        var H = j.clone();
        return H.red = null, H;
      }, O.mont = function(j) {
        return new U(j);
      };
      function U(j) {
        if (c.call(this, j), this.shift = this.m.bitLength(), this.shift % 26 !== 0) this.shift += 26 - this.shift % 26;
        this.r = new O(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      __name(U, "U");
      Y(U, c), U.prototype.convertTo = function(j) {
        return this.imod(j.ushln(this.shift));
      }, U.prototype.convertFrom = function(j) {
        var H = this.imod(j.mul(this.rinv));
        return H.red = null, H;
      }, U.prototype.imul = function(j, H) {
        if (j.isZero() || H.isZero()) return j.words[0] = 0, j.length = 1, j;
        var Z = j.imul(H), W = Z.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), w = Z.isub(W).iushrn(this.shift), G = w;
        if (w.cmp(this.m) >= 0) G = w.isub(this.m);
        else if (w.cmpn(0) < 0) G = w.iadd(this.m);
        return G._forceRed(this);
      }, U.prototype.mul = function(j, H) {
        if (j.isZero() || H.isZero()) return new O(0)._forceRed(this);
        var Z = j.mul(H), W = Z.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), w = Z.isub(W).iushrn(this.shift), G = w;
        if (w.cmp(this.m) >= 0) G = w.isub(this.m);
        else if (w.cmpn(0) < 0) G = w.iadd(this.m);
        return G._forceRed(this);
      }, U.prototype.invm = function(j) {
        var H = this.imod(j._invmp(this.m).mul(this.r2));
        return H._forceRed(this);
      };
    })(typeof q > "u" || q, $);
  }), Co = r$(($) => {
    var q = F7(), K = z8(), P = $;
    P.define = function(Y, O) {
      return new _(Y, O);
    };
    function _(Y, O) {
      this.name = Y, this.body = O, this.decoders = {}, this.encoders = {};
    }
    __name(_, "_");
    _.prototype._createNamed = function(Y) {
      var O;
      try {
        O = (() => {
          throw new Error("Cannot require module vm");
        })().runInThisContext("(function " + this.name + `(entity) {
  this._initNamed(entity);
})`);
      } catch (z) {
        O = /* @__PURE__ */ __name(function(J) {
          this._initNamed(J);
        }, "O");
      }
      return K(O, Y), O.prototype._initNamed = function(z) {
        Y.call(this, z);
      }, new O(this);
    }, _.prototype._getDecoder = function(Y) {
      if (Y = Y || "der", !this.decoders.hasOwnProperty(Y)) this.decoders[Y] = this._createNamed(q.decoders[Y]);
      return this.decoders[Y];
    }, _.prototype.decode = function(Y, O, z) {
      return this._getDecoder(O).decode(Y, z);
    }, _.prototype._getEncoder = function(Y) {
      if (Y = Y || "der", !this.encoders.hasOwnProperty(Y)) this.encoders[Y] = this._createNamed(q.encoders[Y]);
      return this.encoders[Y];
    }, _.prototype.encode = function(Y, O, z) {
      return this._getEncoder(O).encode(Y, z);
    };
  }), ho = r$(($) => {
    var q = z8();
    function K(_) {
      this._reporterState = { obj: null, path: [], options: _ || {}, errors: [] };
    }
    __name(K, "K");
    $.Reporter = K, K.prototype.isError = function(_) {
      return _ instanceof P;
    }, K.prototype.save = function() {
      var _ = this._reporterState;
      return { obj: _.obj, pathLen: _.path.length };
    }, K.prototype.restore = function(_) {
      var Y = this._reporterState;
      Y.obj = _.obj, Y.path = Y.path.slice(0, _.pathLen);
    }, K.prototype.enterKey = function(_) {
      return this._reporterState.path.push(_);
    }, K.prototype.exitKey = function(_) {
      var Y = this._reporterState;
      Y.path = Y.path.slice(0, _ - 1);
    }, K.prototype.leaveKey = function(_, Y, O) {
      var z = this._reporterState;
      if (this.exitKey(_), z.obj !== null) z.obj[Y] = O;
    }, K.prototype.path = function() {
      return this._reporterState.path.join("/");
    }, K.prototype.enterObject = function() {
      var _ = this._reporterState, Y = _.obj;
      return _.obj = {}, Y;
    }, K.prototype.leaveObject = function(_) {
      var Y = this._reporterState, O = Y.obj;
      return Y.obj = _, O;
    }, K.prototype.error = function(_) {
      var Y, O = this._reporterState, z = _ instanceof P;
      if (z) Y = _;
      else Y = new P(O.path.map(function(J) {
        return "[" + JSON.stringify(J) + "]";
      }).join(""), _.message || _, _.stack);
      if (!O.options.partial) throw Y;
      if (!z) O.errors.push(Y);
      return Y;
    }, K.prototype.wrapResult = function(_) {
      var Y = this._reporterState;
      if (!Y.options.partial) return _;
      return { result: this.isError(_) ? null : _, errors: Y.errors };
    };
    function P(_, Y) {
      this.path = _, this.rethrow(Y);
    }
    __name(P, "P");
    q(P, Error), P.prototype.rethrow = function(_) {
      if (this.message = _ + " at: " + (this.path || "(shallow)"), Error.captureStackTrace) Error.captureStackTrace(this, P);
      if (!this.stack) try {
        throw Error(this.message);
      } catch (Y) {
        this.stack = Y.stack;
      }
      return this;
    };
  }), O0 = r$(($) => {
    var q = z8(), K = B7().Reporter, P = (fq(), J6(wq)).Buffer;
    function _(O, z) {
      if (K.call(this, z), !P.isBuffer(O)) {
        this.error("Input not Buffer");
        return;
      }
      this.base = O, this.offset = 0, this.length = O.length;
    }
    __name(_, "_");
    q(_, K), $.DecoderBuffer = _, _.prototype.save = function() {
      return { offset: this.offset, reporter: K.prototype.save.call(this) };
    }, _.prototype.restore = function(O) {
      var z = new _(this.base);
      return z.offset = O.offset, z.length = this.offset, this.offset = O.offset, K.prototype.restore.call(this, O.reporter), z;
    }, _.prototype.isEmpty = function() {
      return this.offset === this.length;
    }, _.prototype.readUInt8 = function(O) {
      if (this.offset + 1 <= this.length) return this.base.readUInt8(this.offset++, true);
      else return this.error(O || "DecoderBuffer overrun");
    }, _.prototype.skip = function(O, z) {
      if (!(this.offset + O <= this.length)) return this.error(z || "DecoderBuffer overrun");
      var J = new _(this.base);
      return J._reporterState = this._reporterState, J.offset = this.offset, J.length = this.offset + O, this.offset += O, J;
    }, _.prototype.raw = function(O) {
      return this.base.slice(O ? O.offset : this.offset, this.length);
    };
    function Y(O, z) {
      if (Array.isArray(O)) this.length = 0, this.value = O.map(function(J) {
        if (!(J instanceof Y)) J = new Y(J, z);
        return this.length += J.length, J;
      }, this);
      else if (typeof O === "number") {
        if (!(0 <= O && O <= 255)) return z.error("non-byte EncoderBuffer value");
        this.value = O, this.length = 1;
      } else if (typeof O === "string") this.value = O, this.length = P.byteLength(O);
      else if (P.isBuffer(O)) this.value = O, this.length = O.length;
      else return z.error("Unsupported type: " + typeof O);
    }
    __name(Y, "Y");
    $.EncoderBuffer = Y, Y.prototype.join = function(O, z) {
      if (!O) O = new P(this.length);
      if (!z) z = 0;
      if (this.length === 0) return O;
      if (Array.isArray(this.value)) this.value.forEach(function(J) {
        J.join(O, z), z += J.length;
      });
      else {
        if (typeof this.value === "number") O[z] = this.value;
        else if (typeof this.value === "string") O.write(this.value, z);
        else if (P.isBuffer(this.value)) this.value.copy(O, z);
        z += this.length;
      }
      return O;
    };
  }), Eo = r$(($, q) => {
    var K = B7().Reporter, P = B7().EncoderBuffer, _ = B7().DecoderBuffer, Y = K_(), O = ["seq", "seqof", "set", "setof", "objid", "bool", "gentime", "utctime", "null_", "enum", "int", "objDesc", "bitstr", "bmpstr", "charstr", "genstr", "graphstr", "ia5str", "iso646str", "numstr", "octstr", "printstr", "t61str", "unistr", "utf8str", "videostr"], z = ["key", "obj", "use", "optional", "explicit", "implicit", "def", "choice", "any", "contains"].concat(O), J = ["_peekTag", "_decodeTag", "_use", "_decodeStr", "_decodeObjid", "_decodeTime", "_decodeNull", "_decodeInt", "_decodeBool", "_decodeList", "_encodeComposite", "_encodeStr", "_encodeObjid", "_encodeTime", "_encodeNull", "_encodeInt", "_encodeBool"];
    function T(f, V) {
      var M = {};
      if (this._baseState = M, M.enc = f, M.parent = V || null, M.children = null, M.tag = null, M.args = null, M.reverseArgs = null, M.choice = null, M.optional = false, M.any = false, M.obj = false, M.use = null, M.useDecoder = null, M.key = null, M.default = null, M.explicit = null, M.implicit = null, M.contains = null, !M.parent) M.children = [], this._wrap();
    }
    __name(T, "T");
    q.exports = T;
    var X = ["enc", "parent", "children", "tag", "args", "reverseArgs", "choice", "optional", "any", "obj", "use", "alteredUse", "key", "default", "explicit", "implicit", "contains"];
    T.prototype.clone = function() {
      var f = this._baseState, V = {};
      X.forEach(function(N) {
        V[N] = f[N];
      });
      var M = new this.constructor(V.parent);
      return M._baseState = V, M;
    }, T.prototype._wrap = function() {
      var f = this._baseState;
      z.forEach(function(V) {
        this[V] = function() {
          var M = new this.constructor(this);
          return f.children.push(M), M[V].apply(M, arguments);
        };
      }, this);
    }, T.prototype._init = function(f) {
      var V = this._baseState;
      Y(V.parent === null), f.call(this), V.children = V.children.filter(function(M) {
        return M._baseState.parent === this;
      }, this), Y.equal(V.children.length, 1, "Root node can have only one child");
    }, T.prototype._useArgs = function(f) {
      var V = this._baseState, M = f.filter(function(N) {
        return N instanceof this.constructor;
      }, this);
      if (f = f.filter(function(N) {
        return !(N instanceof this.constructor);
      }, this), M.length !== 0) Y(V.children === null), V.children = M, M.forEach(function(N) {
        N._baseState.parent = this;
      }, this);
      if (f.length !== 0) Y(V.args === null), V.args = f, V.reverseArgs = f.map(function(N) {
        if (typeof N !== "object" || N.constructor !== Object) return N;
        var E = {};
        return Object.keys(N).forEach(function(h) {
          if (h == (h | 0)) h |= 0;
          var I = N[h];
          E[I] = h;
        }), E;
      });
    }, J.forEach(function(f) {
      T.prototype[f] = function() {
        var V = this._baseState;
        throw Error(f + " not implemented for encoding: " + V.enc);
      };
    }), O.forEach(function(f) {
      T.prototype[f] = function() {
        var V = this._baseState, M = Array.prototype.slice.call(arguments);
        return Y(V.tag === null), V.tag = f, this._useArgs(M), this;
      };
    }), T.prototype.use = function(f) {
      Y(f);
      var V = this._baseState;
      return Y(V.use === null), V.use = f, this;
    }, T.prototype.optional = function() {
      var f = this._baseState;
      return f.optional = true, this;
    }, T.prototype.def = function(f) {
      var V = this._baseState;
      return Y(V.default === null), V.default = f, V.optional = true, this;
    }, T.prototype.explicit = function(f) {
      var V = this._baseState;
      return Y(V.explicit === null && V.implicit === null), V.explicit = f, this;
    }, T.prototype.implicit = function(f) {
      var V = this._baseState;
      return Y(V.explicit === null && V.implicit === null), V.implicit = f, this;
    }, T.prototype.obj = function() {
      var f = this._baseState, V = Array.prototype.slice.call(arguments);
      if (f.obj = true, V.length !== 0) this._useArgs(V);
      return this;
    }, T.prototype.key = function(f) {
      var V = this._baseState;
      return Y(V.key === null), V.key = f, this;
    }, T.prototype.any = function() {
      var f = this._baseState;
      return f.any = true, this;
    }, T.prototype.choice = function(f) {
      var V = this._baseState;
      return Y(V.choice === null), V.choice = f, this._useArgs(Object.keys(f).map(function(M) {
        return f[M];
      })), this;
    }, T.prototype.contains = function(f) {
      var V = this._baseState;
      return Y(V.use === null), V.contains = f, this;
    }, T.prototype._decode = function(f, V) {
      var M = this._baseState;
      if (M.parent === null) return f.wrapResult(M.children[0]._decode(f, V));
      var N = M.default, E = true, h = null;
      if (M.key !== null) h = f.enterKey(M.key);
      if (M.optional) {
        var I = null;
        if (M.explicit !== null) I = M.explicit;
        else if (M.implicit !== null) I = M.implicit;
        else if (M.tag !== null) I = M.tag;
        if (I === null && !M.any) {
          var D = f.save();
          try {
            if (M.choice === null) this._decodeGeneric(M.tag, f, V);
            else this._decodeChoice(f, V);
            E = true;
          } catch (s) {
            E = false;
          }
          f.restore(D);
        } else if (E = this._peekTag(f, I, M.any), f.isError(E)) return E;
      }
      var g;
      if (M.obj && E) g = f.enterObject();
      if (E) {
        if (M.explicit !== null) {
          var b = this._decodeTag(f, M.explicit);
          if (f.isError(b)) return b;
          f = b;
        }
        var y = f.offset;
        if (M.use === null && M.choice === null) {
          if (M.any) var D = f.save();
          var p = this._decodeTag(f, M.implicit !== null ? M.implicit : M.tag, M.any);
          if (f.isError(p)) return p;
          if (M.any) N = f.raw(D);
          else f = p;
        }
        if (V && V.track && M.tag !== null) V.track(f.path(), y, f.length, "tagged");
        if (V && V.track && M.tag !== null) V.track(f.path(), f.offset, f.length, "content");
        if (M.any) N = N;
        else if (M.choice === null) N = this._decodeGeneric(M.tag, f, V);
        else N = this._decodeChoice(f, V);
        if (f.isError(N)) return N;
        if (!M.any && M.choice === null && M.children !== null) M.children.forEach(function(s) {
          s._decode(f, V);
        });
        if (M.contains && (M.tag === "octstr" || M.tag === "bitstr")) {
          var n = new _(N);
          N = this._getUse(M.contains, f._reporterState.obj)._decode(n, V);
        }
      }
      if (M.obj && E) N = f.leaveObject(g);
      if (M.key !== null && (N !== null || E === true)) f.leaveKey(h, M.key, N);
      else if (h !== null) f.exitKey(h);
      return N;
    }, T.prototype._decodeGeneric = function(f, V, M) {
      var N = this._baseState;
      if (f === "seq" || f === "set") return null;
      if (f === "seqof" || f === "setof") return this._decodeList(V, f, N.args[0], M);
      else if (/str$/.test(f)) return this._decodeStr(V, f, M);
      else if (f === "objid" && N.args) return this._decodeObjid(V, N.args[0], N.args[1], M);
      else if (f === "objid") return this._decodeObjid(V, null, null, M);
      else if (f === "gentime" || f === "utctime") return this._decodeTime(V, f, M);
      else if (f === "null_") return this._decodeNull(V, M);
      else if (f === "bool") return this._decodeBool(V, M);
      else if (f === "objDesc") return this._decodeStr(V, f, M);
      else if (f === "int" || f === "enum") return this._decodeInt(V, N.args && N.args[0], M);
      if (N.use !== null) return this._getUse(N.use, V._reporterState.obj)._decode(V, M);
      else return V.error("unknown tag: " + f);
    }, T.prototype._getUse = function(f, V) {
      var M = this._baseState;
      if (M.useDecoder = this._use(f, V), Y(M.useDecoder._baseState.parent === null), M.useDecoder = M.useDecoder._baseState.children[0], M.implicit !== M.useDecoder._baseState.implicit) M.useDecoder = M.useDecoder.clone(), M.useDecoder._baseState.implicit = M.implicit;
      return M.useDecoder;
    }, T.prototype._decodeChoice = function(f, V) {
      var M = this._baseState, N = null, E = false;
      if (Object.keys(M.choice).some(function(h) {
        var I = f.save(), D = M.choice[h];
        try {
          var g = D._decode(f, V);
          if (f.isError(g)) return false;
          N = { type: h, value: g }, E = true;
        } catch (b) {
          return f.restore(I), false;
        }
        return true;
      }, this), !E) return f.error("Choice not matched");
      return N;
    }, T.prototype._createEncoderBuffer = function(f) {
      return new P(f, this.reporter);
    }, T.prototype._encode = function(f, V, M) {
      var N = this._baseState;
      if (N.default !== null && N.default === f) return;
      var E = this._encodeValue(f, V, M);
      if (E === void 0) return;
      if (this._skipDefault(E, V, M)) return;
      return E;
    }, T.prototype._encodeValue = function(f, V, M) {
      var N = this._baseState;
      if (N.parent === null) return N.children[0]._encode(f, V || new K());
      var D = null;
      if (this.reporter = V, N.optional && f === void 0) if (N.default !== null) f = N.default;
      else return;
      var E = null, h = false;
      if (N.any) D = this._createEncoderBuffer(f);
      else if (N.choice) D = this._encodeChoice(f, V);
      else if (N.contains) E = this._getUse(N.contains, M)._encode(f, V), h = true;
      else if (N.children) E = N.children.map(function(y) {
        if (y._baseState.tag === "null_") return y._encode(null, V, f);
        if (y._baseState.key === null) return V.error("Child should have a key");
        var p = V.enterKey(y._baseState.key);
        if (typeof f !== "object") return V.error("Child expected, but input is not object");
        var n = y._encode(f[y._baseState.key], V, f);
        return V.leaveKey(p), n;
      }, this).filter(function(y) {
        return y;
      }), E = this._createEncoderBuffer(E);
      else if (N.tag === "seqof" || N.tag === "setof") {
        if (!(N.args && N.args.length === 1)) return V.error("Too many args for : " + N.tag);
        if (!Array.isArray(f)) return V.error("seqof/setof, but data is not Array");
        var I = this.clone();
        I._baseState.implicit = null, E = this._createEncoderBuffer(f.map(function(y) {
          var p = this._baseState;
          return this._getUse(p.args[0], f)._encode(y, V);
        }, I));
      } else if (N.use !== null) D = this._getUse(N.use, M)._encode(f, V);
      else E = this._encodePrimitive(N.tag, f), h = true;
      var D;
      if (!N.any && N.choice === null) {
        var g = N.implicit !== null ? N.implicit : N.tag, b = N.implicit === null ? "universal" : "context";
        if (g === null) {
          if (N.use === null) V.error("Tag could be omitted only for .use()");
        } else if (N.use === null) D = this._encodeComposite(g, h, b, E);
      }
      if (N.explicit !== null) D = this._encodeComposite(N.explicit, false, "context", D);
      return D;
    }, T.prototype._encodeChoice = function(f, V) {
      var M = this._baseState, N = M.choice[f.type];
      if (!N) Y(false, f.type + " not found in " + JSON.stringify(Object.keys(M.choice)));
      return N._encode(f.value, V);
    }, T.prototype._encodePrimitive = function(f, V) {
      var M = this._baseState;
      if (/str$/.test(f)) return this._encodeStr(V, f);
      else if (f === "objid" && M.args) return this._encodeObjid(V, M.reverseArgs[0], M.args[1]);
      else if (f === "objid") return this._encodeObjid(V, null, null);
      else if (f === "gentime" || f === "utctime") return this._encodeTime(V, f);
      else if (f === "null_") return this._encodeNull();
      else if (f === "int" || f === "enum") return this._encodeInt(V, M.args && M.reverseArgs[0]);
      else if (f === "bool") return this._encodeBool(V);
      else if (f === "objDesc") return this._encodeStr(V, f);
      else throw Error("Unsupported tag: " + f);
    }, T.prototype._isNumstr = function(f) {
      return /^[0-9 ]*$/.test(f);
    }, T.prototype._isPrintstr = function(f) {
      return /^[A-Za-z0-9 '\(\)\+,\-\.\/:=\?]*$/.test(f);
    };
  }), B7 = r$(($) => {
    var q = $;
    q.Reporter = ho().Reporter, q.DecoderBuffer = O0().DecoderBuffer, q.EncoderBuffer = O0().EncoderBuffer, q.Node = Eo();
  }), Ro = r$(($) => {
    var q = f0();
    $.tagClass = { 0: "universal", 1: "application", 2: "context", 3: "private" }, $.tagClassByName = q._reverse($.tagClass), $.tag = { 0: "end", 1: "bool", 2: "int", 3: "bitstr", 4: "octstr", 5: "null_", 6: "objid", 7: "objDesc", 8: "external", 9: "real", 10: "enum", 11: "embed", 12: "utf8str", 13: "relativeOid", 16: "seq", 17: "set", 18: "numstr", 19: "printstr", 20: "t61str", 21: "videostr", 22: "ia5str", 23: "utctime", 24: "gentime", 25: "graphstr", 26: "iso646str", 27: "genstr", 28: "unistr", 29: "charstr", 30: "bmpstr" }, $.tagByName = q._reverse($.tag);
  }), f0 = r$(($) => {
    var q = $;
    q._reverse = function(K) {
      var P = {};
      return Object.keys(K).forEach(function(_) {
        if ((_ | 0) == _) _ = _ | 0;
        var Y = K[_];
        P[Y] = _;
      }), P;
    }, q.der = Ro();
  }), Z0 = r$(($, q) => {
    var K = z8(), P = F7(), _ = P.base, Y = P.bignum, O = P.constants.der;
    function z(f) {
      this.enc = "der", this.name = f.name, this.entity = f, this.tree = new J(), this.tree._init(f.body);
    }
    __name(z, "z");
    q.exports = z, z.prototype.decode = function(f, V) {
      if (!(f instanceof _.DecoderBuffer)) f = new _.DecoderBuffer(f, V);
      return this.tree._decode(f, V);
    };
    function J(f) {
      _.Node.call(this, "der", f);
    }
    __name(J, "J");
    K(J, _.Node), J.prototype._peekTag = function(f, V, M) {
      if (f.isEmpty()) return false;
      var N = f.save(), E = T(f, 'Failed to peek tag: "' + V + '"');
      if (f.isError(E)) return E;
      return f.restore(N), E.tag === V || E.tagStr === V || E.tagStr + "of" === V || M;
    }, J.prototype._decodeTag = function(f, V, M) {
      var N = T(f, 'Failed to decode tag of "' + V + '"');
      if (f.isError(N)) return N;
      var E = X(f, N.primitive, 'Failed to get length of "' + V + '"');
      if (f.isError(E)) return E;
      if (!M && N.tag !== V && N.tagStr !== V && N.tagStr + "of" !== V) return f.error('Failed to match tag: "' + V + '"');
      if (N.primitive || E !== null) return f.skip(E, 'Failed to match body of: "' + V + '"');
      var h = f.save(), I = this._skipUntilEnd(f, 'Failed to skip indefinite length body: "' + this.tag + '"');
      if (f.isError(I)) return I;
      return E = f.offset - h.offset, f.restore(h), f.skip(E, 'Failed to match body of: "' + V + '"');
    }, J.prototype._skipUntilEnd = function(f, V) {
      while (true) {
        var M = T(f, V);
        if (f.isError(M)) return M;
        var N = X(f, M.primitive, V);
        if (f.isError(N)) return N;
        var E;
        if (M.primitive || N !== null) E = f.skip(N);
        else E = this._skipUntilEnd(f, V);
        if (f.isError(E)) return E;
        if (M.tagStr === "end") break;
      }
    }, J.prototype._decodeList = function(f, V, M, N) {
      var E = [];
      while (!f.isEmpty()) {
        var h = this._peekTag(f, "end");
        if (f.isError(h)) return h;
        var I = M.decode(f, "der", N);
        if (f.isError(I) && h) break;
        E.push(I);
      }
      return E;
    }, J.prototype._decodeStr = function(f, V) {
      if (V === "bitstr") {
        var M = f.readUInt8();
        if (f.isError(M)) return M;
        return { unused: M, data: f.raw() };
      } else if (V === "bmpstr") {
        var N = f.raw();
        if (N.length % 2 === 1) return f.error("Decoding of string type: bmpstr length mismatch");
        var E = "";
        for (var h = 0; h < N.length / 2; h++) E += String.fromCharCode(N.readUInt16BE(h * 2));
        return E;
      } else if (V === "numstr") {
        var I = f.raw().toString("ascii");
        if (!this._isNumstr(I)) return f.error("Decoding of string type: numstr unsupported characters");
        return I;
      } else if (V === "octstr") return f.raw();
      else if (V === "objDesc") return f.raw();
      else if (V === "printstr") {
        var D = f.raw().toString("ascii");
        if (!this._isPrintstr(D)) return f.error("Decoding of string type: printstr unsupported characters");
        return D;
      } else if (/str$/.test(V)) return f.raw().toString();
      else return f.error("Decoding of string type: " + V + " unsupported");
    }, J.prototype._decodeObjid = function(f, V, M) {
      var N, E = [], h = 0;
      while (!f.isEmpty()) {
        var I = f.readUInt8();
        if (h <<= 7, h |= I & 127, (I & 128) === 0) E.push(h), h = 0;
      }
      if (I & 128) E.push(h);
      var D = E[0] / 40 | 0, g = E[0] % 40;
      if (M) N = E;
      else N = [D, g].concat(E.slice(1));
      if (V) {
        var b = V[N.join(" ")];
        if (b === void 0) b = V[N.join(".")];
        if (b !== void 0) N = b;
      }
      return N;
    }, J.prototype._decodeTime = function(f, V) {
      var M = f.raw().toString();
      if (V === "gentime") var N = M.slice(0, 4) | 0, E = M.slice(4, 6) | 0, h = M.slice(6, 8) | 0, I = M.slice(8, 10) | 0, D = M.slice(10, 12) | 0, g = M.slice(12, 14) | 0;
      else if (V === "utctime") {
        var N = M.slice(0, 2) | 0, E = M.slice(2, 4) | 0, h = M.slice(4, 6) | 0, I = M.slice(6, 8) | 0, D = M.slice(8, 10) | 0, g = M.slice(10, 12) | 0;
        if (N < 70) N = 2e3 + N;
        else N = 1900 + N;
      } else return f.error("Decoding " + V + " time is not supported yet");
      return Date.UTC(N, E - 1, h, I, D, g, 0);
    }, J.prototype._decodeNull = function(f) {
      return null;
    }, J.prototype._decodeBool = function(f) {
      var V = f.readUInt8();
      if (f.isError(V)) return V;
      else return V !== 0;
    }, J.prototype._decodeInt = function(f, V) {
      var M = f.raw(), N = new Y(M);
      if (V) N = V[N.toString(10)] || N;
      return N;
    }, J.prototype._use = function(f, V) {
      if (typeof f === "function") f = f(V);
      return f._getDecoder("der").tree;
    };
    function T(f, V) {
      var M = f.readUInt8(V);
      if (f.isError(M)) return M;
      var N = O.tagClass[M >> 6], E = (M & 32) === 0;
      if ((M & 31) === 31) {
        var h = M;
        M = 0;
        while ((h & 128) === 128) {
          if (h = f.readUInt8(V), f.isError(h)) return h;
          M <<= 7, M |= h & 127;
        }
      } else M &= 31;
      var I = O.tag[M];
      return { cls: N, primitive: E, tag: M, tagStr: I };
    }
    __name(T, "T");
    function X(f, V, M) {
      var N = f.readUInt8(M);
      if (f.isError(N)) return N;
      if (!V && N === 128) return null;
      if ((N & 128) === 0) return N;
      var E = N & 127;
      if (E > 4) return f.error("length octect is too long");
      N = 0;
      for (var h = 0; h < E; h++) {
        N <<= 8;
        var I = f.readUInt8(M);
        if (f.isError(I)) return I;
        N |= I;
      }
      return N;
    }
    __name(X, "X");
  }), Io = r$(($, q) => {
    var K = z8(), P = (fq(), J6(wq)).Buffer, _ = Z0();
    function Y(O) {
      _.call(this, O), this.enc = "pem";
    }
    __name(Y, "Y");
    K(Y, _), q.exports = Y, Y.prototype.decode = function(O, z) {
      var J = O.toString().split(/[\r\n]+/g), T = z.label.toUpperCase(), X = /^-----(BEGIN|END) ([^-]+)-----$/, f = -1, V = -1;
      for (var M = 0; M < J.length; M++) {
        var N = J[M].match(X);
        if (N === null) continue;
        if (N[2] !== T) continue;
        if (f === -1) {
          if (N[1] !== "BEGIN") break;
          f = M;
        } else {
          if (N[1] !== "END") break;
          V = M;
          break;
        }
      }
      if (f === -1 || V === -1) throw Error("PEM section not found for: " + T);
      var E = J.slice(f + 1, V).join("");
      E.replace(/[^a-z0-9\+\/=]+/gi, "");
      var h = new P(E, "base64");
      return _.prototype.decode.call(this, h, z);
    };
  }), Do = r$(($) => {
    var q = $;
    q.der = Z0(), q.pem = Io();
  }), X0 = r$(($, q) => {
    var K = z8(), P = (fq(), J6(wq)).Buffer, _ = F7(), Y = _.base, O = _.constants.der;
    function z(f) {
      this.enc = "der", this.name = f.name, this.entity = f, this.tree = new J(), this.tree._init(f.body);
    }
    __name(z, "z");
    q.exports = z, z.prototype.encode = function(f, V) {
      return this.tree._encode(f, V).join();
    };
    function J(f) {
      Y.Node.call(this, "der", f);
    }
    __name(J, "J");
    K(J, Y.Node), J.prototype._encodeComposite = function(f, V, M, N) {
      var E = X(f, V, M, this.reporter);
      if (N.length < 128) {
        var D = new P(2);
        return D[0] = E, D[1] = N.length, this._createEncoderBuffer([D, N]);
      }
      var h = 1;
      for (var I = N.length; I >= 256; I >>= 8) h++;
      var D = new P(2 + h);
      D[0] = E, D[1] = 128 | h;
      for (var I = 1 + h, g = N.length; g > 0; I--, g >>= 8) D[I] = g & 255;
      return this._createEncoderBuffer([D, N]);
    }, J.prototype._encodeStr = function(f, V) {
      if (V === "bitstr") return this._createEncoderBuffer([f.unused | 0, f.data]);
      else if (V === "bmpstr") {
        var M = new P(f.length * 2);
        for (var N = 0; N < f.length; N++) M.writeUInt16BE(f.charCodeAt(N), N * 2);
        return this._createEncoderBuffer(M);
      } else if (V === "numstr") {
        if (!this._isNumstr(f)) return this.reporter.error("Encoding of string type: numstr supports only digits and space");
        return this._createEncoderBuffer(f);
      } else if (V === "printstr") {
        if (!this._isPrintstr(f)) return this.reporter.error("Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark");
        return this._createEncoderBuffer(f);
      } else if (/str$/.test(V)) return this._createEncoderBuffer(f);
      else if (V === "objDesc") return this._createEncoderBuffer(f);
      else return this.reporter.error("Encoding of string type: " + V + " unsupported");
    }, J.prototype._encodeObjid = function(f, V, M) {
      if (typeof f === "string") {
        if (!V) return this.reporter.error("string objid given, but no values map found");
        if (!V.hasOwnProperty(f)) return this.reporter.error("objid not found in values map");
        f = V[f].split(/[\s\.]+/g);
        for (var N = 0; N < f.length; N++) f[N] |= 0;
      } else if (Array.isArray(f)) {
        f = f.slice();
        for (var N = 0; N < f.length; N++) f[N] |= 0;
      }
      if (!Array.isArray(f)) return this.reporter.error("objid() should be either array or string, got: " + JSON.stringify(f));
      if (!M) {
        if (f[1] >= 40) return this.reporter.error("Second objid identifier OOB");
        f.splice(0, 2, f[0] * 40 + f[1]);
      }
      var E = 0;
      for (var N = 0; N < f.length; N++) {
        var h = f[N];
        for (E++; h >= 128; h >>= 7) E++;
      }
      var I = new P(E), D = I.length - 1;
      for (var N = f.length - 1; N >= 0; N--) {
        var h = f[N];
        I[D--] = h & 127;
        while ((h >>= 7) > 0) I[D--] = 128 | h & 127;
      }
      return this._createEncoderBuffer(I);
    };
    function T(f) {
      if (f < 10) return "0" + f;
      else return f;
    }
    __name(T, "T");
    J.prototype._encodeTime = function(f, V) {
      var M, N = new Date(f);
      if (V === "gentime") M = [T(N.getFullYear()), T(N.getUTCMonth() + 1), T(N.getUTCDate()), T(N.getUTCHours()), T(N.getUTCMinutes()), T(N.getUTCSeconds()), "Z"].join("");
      else if (V === "utctime") M = [T(N.getFullYear() % 100), T(N.getUTCMonth() + 1), T(N.getUTCDate()), T(N.getUTCHours()), T(N.getUTCMinutes()), T(N.getUTCSeconds()), "Z"].join("");
      else this.reporter.error("Encoding " + V + " time is not supported yet");
      return this._encodeStr(M, "octstr");
    }, J.prototype._encodeNull = function() {
      return this._createEncoderBuffer("");
    }, J.prototype._encodeInt = function(f, V) {
      if (typeof f === "string") {
        if (!V) return this.reporter.error("String int or enum given, but no values map");
        if (!V.hasOwnProperty(f)) return this.reporter.error("Values map doesn't contain: " + JSON.stringify(f));
        f = V[f];
      }
      if (typeof f !== "number" && !P.isBuffer(f)) {
        var M = f.toArray();
        if (!f.sign && M[0] & 128) M.unshift(0);
        f = new P(M);
      }
      if (P.isBuffer(f)) {
        var N = f.length;
        if (f.length === 0) N++;
        var h = new P(N);
        if (f.copy(h), f.length === 0) h[0] = 0;
        return this._createEncoderBuffer(h);
      }
      if (f < 128) return this._createEncoderBuffer(f);
      if (f < 256) return this._createEncoderBuffer([0, f]);
      var N = 1;
      for (var E = f; E >= 256; E >>= 8) N++;
      var h = Array(N);
      for (var E = h.length - 1; E >= 0; E--) h[E] = f & 255, f >>= 8;
      if (h[0] & 128) h.unshift(0);
      return this._createEncoderBuffer(new P(h));
    }, J.prototype._encodeBool = function(f) {
      return this._createEncoderBuffer(f ? 255 : 0);
    }, J.prototype._use = function(f, V) {
      if (typeof f === "function") f = f(V);
      return f._getEncoder("der").tree;
    }, J.prototype._skipDefault = function(f, V, M) {
      var N = this._baseState, E;
      if (N.default === null) return false;
      var h = f.join();
      if (N.defaultBuffer === void 0) N.defaultBuffer = this._encodeValue(N.default, V, M).join();
      if (h.length !== N.defaultBuffer.length) return false;
      for (E = 0; E < h.length; E++) if (h[E] !== N.defaultBuffer[E]) return false;
      return true;
    };
    function X(f, V, M, N) {
      var E;
      if (f === "seqof") f = "seq";
      else if (f === "setof") f = "set";
      if (O.tagByName.hasOwnProperty(f)) E = O.tagByName[f];
      else if (typeof f === "number" && (f | 0) === f) E = f;
      else return N.error("Unknown tag: " + f);
      if (E >= 31) return N.error("Multi-octet tag encoding unsupported");
      if (!V) E |= 32;
      return E |= O.tagClassByName[M || "universal"] << 6, E;
    }
    __name(X, "X");
  }), Lo = r$(($, q) => {
    var K = z8(), P = X0();
    function _(Y) {
      P.call(this, Y), this.enc = "pem";
    }
    __name(_, "_");
    K(_, P), q.exports = _, _.prototype.encode = function(Y, O) {
      var z = P.prototype.encode.call(this, Y), J = z.toString("base64"), T = ["-----BEGIN " + O.label + "-----"];
      for (var X = 0; X < J.length; X += 64) T.push(J.slice(X, X + 64));
      return T.push("-----END " + O.label + "-----"), T.join(`
`);
    };
  }), go = r$(($) => {
    var q = $;
    q.der = X0(), q.pem = Lo();
  }), F7 = r$(($) => {
    var q = $;
    q.bignum = No(), q.define = Co().define, q.base = B7(), q.constants = f0(), q.decoders = Do(), q.encoders = go();
  }), bo = r$(($, q) => {
    var K = F7(), P = K.define("Time", function() {
      this.choice({ utcTime: this.utctime(), generalTime: this.gentime() });
    }), _ = K.define("AttributeTypeValue", function() {
      this.seq().obj(this.key("type").objid(), this.key("value").any());
    }), Y = K.define("AlgorithmIdentifier", function() {
      this.seq().obj(this.key("algorithm").objid(), this.key("parameters").optional(), this.key("curve").objid().optional());
    }), O = K.define("SubjectPublicKeyInfo", function() {
      this.seq().obj(this.key("algorithm").use(Y), this.key("subjectPublicKey").bitstr());
    }), z = K.define("RelativeDistinguishedName", function() {
      this.setof(_);
    }), J = K.define("RDNSequence", function() {
      this.seqof(z);
    }), T = K.define("Name", function() {
      this.choice({ rdnSequence: this.use(J) });
    }), X = K.define("Validity", function() {
      this.seq().obj(this.key("notBefore").use(P), this.key("notAfter").use(P));
    }), f = K.define("Extension", function() {
      this.seq().obj(this.key("extnID").objid(), this.key("critical").bool().def(false), this.key("extnValue").octstr());
    }), V = K.define("TBSCertificate", function() {
      this.seq().obj(this.key("version").explicit(0).int().optional(), this.key("serialNumber").int(), this.key("signature").use(Y), this.key("issuer").use(T), this.key("validity").use(X), this.key("subject").use(T), this.key("subjectPublicKeyInfo").use(O), this.key("issuerUniqueID").implicit(1).bitstr().optional(), this.key("subjectUniqueID").implicit(2).bitstr().optional(), this.key("extensions").explicit(3).seqof(f).optional());
    }), M = K.define("X509Certificate", function() {
      this.seq().obj(this.key("tbsCertificate").use(V), this.key("signatureAlgorithm").use(Y), this.key("signatureValue").bitstr());
    });
    q.exports = M;
  }), yo = r$(($) => {
    var q = F7();
    $.certificate = bo();
    var K = q.define("RSAPrivateKey", function() {
      this.seq().obj(this.key("version").int(), this.key("modulus").int(), this.key("publicExponent").int(), this.key("privateExponent").int(), this.key("prime1").int(), this.key("prime2").int(), this.key("exponent1").int(), this.key("exponent2").int(), this.key("coefficient").int());
    });
    $.RSAPrivateKey = K;
    var P = q.define("RSAPublicKey", function() {
      this.seq().obj(this.key("modulus").int(), this.key("publicExponent").int());
    });
    $.RSAPublicKey = P;
    var _ = q.define("AlgorithmIdentifier", function() {
      this.seq().obj(this.key("algorithm").objid(), this.key("none").null_().optional(), this.key("curve").objid().optional(), this.key("params").seq().obj(this.key("p").int(), this.key("q").int(), this.key("g").int()).optional());
    }), Y = q.define("SubjectPublicKeyInfo", function() {
      this.seq().obj(this.key("algorithm").use(_), this.key("subjectPublicKey").bitstr());
    });
    $.PublicKey = Y;
    var O = q.define("PrivateKeyInfo", function() {
      this.seq().obj(this.key("version").int(), this.key("algorithm").use(_), this.key("subjectPrivateKey").octstr());
    });
    $.PrivateKey = O;
    var z = q.define("EncryptedPrivateKeyInfo", function() {
      this.seq().obj(this.key("algorithm").seq().obj(this.key("id").objid(), this.key("decrypt").seq().obj(this.key("kde").seq().obj(this.key("id").objid(), this.key("kdeparams").seq().obj(this.key("salt").octstr(), this.key("iters").int())), this.key("cipher").seq().obj(this.key("algo").objid(), this.key("iv").octstr()))), this.key("subjectPrivateKey").octstr());
    });
    $.EncryptedPrivateKey = z;
    var J = q.define("DSAPrivateKey", function() {
      this.seq().obj(this.key("version").int(), this.key("p").int(), this.key("q").int(), this.key("g").int(), this.key("pub_key").int(), this.key("priv_key").int());
    });
    $.DSAPrivateKey = J, $.DSAparam = q.define("DSAparam", function() {
      this.int();
    });
    var T = q.define("ECParameters", function() {
      this.choice({ namedCurve: this.objid() });
    }), X = q.define("ECPrivateKey", function() {
      this.seq().obj(this.key("version").int(), this.key("privateKey").octstr(), this.key("parameters").optional().explicit(0).use(T), this.key("publicKey").optional().explicit(1).bitstr());
    });
    $.ECPrivateKey = X, $.signature = q.define("signature", function() {
      this.seq().obj(this.key("r").int(), this.key("s").int());
    });
  }), uo = r$(($, q) => {
    q.exports = { "2.16.840.1.101.3.4.1.1": "aes-128-ecb", "2.16.840.1.101.3.4.1.2": "aes-128-cbc", "2.16.840.1.101.3.4.1.3": "aes-128-ofb", "2.16.840.1.101.3.4.1.4": "aes-128-cfb", "2.16.840.1.101.3.4.1.21": "aes-192-ecb", "2.16.840.1.101.3.4.1.22": "aes-192-cbc", "2.16.840.1.101.3.4.1.23": "aes-192-ofb", "2.16.840.1.101.3.4.1.24": "aes-192-cfb", "2.16.840.1.101.3.4.1.41": "aes-256-ecb", "2.16.840.1.101.3.4.1.42": "aes-256-cbc", "2.16.840.1.101.3.4.1.43": "aes-256-ofb", "2.16.840.1.101.3.4.1.44": "aes-256-cfb" };
  }), xo = r$(($, q) => {
    var K = q8().Buffer, P = dH().Transform, _ = z8();
    function Y(T) {
      P.call(this), this._block = K.allocUnsafe(T), this._blockSize = T, this._blockOffset = 0, this._length = [0, 0, 0, 0], this._finalized = false;
    }
    __name(Y, "Y");
    _(Y, P), Y.prototype._transform = function(T, X, f) {
      var V = null;
      try {
        this.update(T, X);
      } catch (M) {
        V = M;
      }
      f(V);
    }, Y.prototype._flush = function(T) {
      var X = null;
      try {
        this.push(this.digest());
      } catch (f) {
        X = f;
      }
      T(X);
    };
    var O = typeof Uint8Array < "u", z = typeof ArrayBuffer < "u" && typeof Uint8Array < "u" && ArrayBuffer.isView && (K.prototype instanceof Uint8Array || K.TYPED_ARRAY_SUPPORT);
    function J(T, X) {
      if (T instanceof K) return T;
      if (typeof T === "string") return K.from(T, X);
      if (z && ArrayBuffer.isView(T)) {
        if (T.byteLength === 0) return K.alloc(0);
        var f = K.from(T.buffer, T.byteOffset, T.byteLength);
        if (f.byteLength === T.byteLength) return f;
      }
      if (O && T instanceof Uint8Array) return K.from(T);
      if (K.isBuffer(T) && T.constructor && typeof T.constructor.isBuffer === "function" && T.constructor.isBuffer(T)) return K.from(T);
      throw TypeError('The "data" argument must be of type string or an instance of Buffer, TypedArray, or DataView.');
    }
    __name(J, "J");
    Y.prototype.update = function(T, X) {
      if (this._finalized) throw Error("Digest already called");
      T = J(T, X);
      var f = this._block, V = 0;
      while (this._blockOffset + T.length - V >= this._blockSize) {
        for (var M = this._blockOffset; M < this._blockSize; ) f[M++] = T[V++];
        this._update(), this._blockOffset = 0;
      }
      while (V < T.length) f[this._blockOffset++] = T[V++];
      for (var N = 0, E = T.length * 8; E > 0; ++N) if (this._length[N] += E, E = this._length[N] / 4294967296 | 0, E > 0) this._length[N] -= 4294967296 * E;
      return this;
    }, Y.prototype._update = function() {
      throw Error("_update is not implemented");
    }, Y.prototype.digest = function(T) {
      if (this._finalized) throw Error("Digest already called");
      this._finalized = true;
      var X = this._digest();
      if (T !== void 0) X = X.toString(T);
      this._block.fill(0), this._blockOffset = 0;
      for (var f = 0; f < 4; ++f) this._length[f] = 0;
      return X;
    }, Y.prototype._digest = function() {
      throw Error("_digest is not implemented");
    }, q.exports = Y;
  }), po = r$(($, q) => {
    var K = z8(), P = xo(), _ = q8().Buffer, Y = Array(16);
    function O() {
      P.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878;
    }
    __name(O, "O");
    K(O, P), O.prototype._update = function() {
      var V = Y;
      for (var M = 0; M < 16; ++M) V[M] = this._block.readInt32LE(M * 4);
      var N = this._a, E = this._b, h = this._c, I = this._d;
      N = J(N, E, h, I, V[0], 3614090360, 7), I = J(I, N, E, h, V[1], 3905402710, 12), h = J(h, I, N, E, V[2], 606105819, 17), E = J(E, h, I, N, V[3], 3250441966, 22), N = J(N, E, h, I, V[4], 4118548399, 7), I = J(I, N, E, h, V[5], 1200080426, 12), h = J(h, I, N, E, V[6], 2821735955, 17), E = J(E, h, I, N, V[7], 4249261313, 22), N = J(N, E, h, I, V[8], 1770035416, 7), I = J(I, N, E, h, V[9], 2336552879, 12), h = J(h, I, N, E, V[10], 4294925233, 17), E = J(E, h, I, N, V[11], 2304563134, 22), N = J(N, E, h, I, V[12], 1804603682, 7), I = J(I, N, E, h, V[13], 4254626195, 12), h = J(h, I, N, E, V[14], 2792965006, 17), E = J(E, h, I, N, V[15], 1236535329, 22), N = T(N, E, h, I, V[1], 4129170786, 5), I = T(I, N, E, h, V[6], 3225465664, 9), h = T(h, I, N, E, V[11], 643717713, 14), E = T(E, h, I, N, V[0], 3921069994, 20), N = T(N, E, h, I, V[5], 3593408605, 5), I = T(I, N, E, h, V[10], 38016083, 9), h = T(h, I, N, E, V[15], 3634488961, 14), E = T(E, h, I, N, V[4], 3889429448, 20), N = T(N, E, h, I, V[9], 568446438, 5), I = T(I, N, E, h, V[14], 3275163606, 9), h = T(h, I, N, E, V[3], 4107603335, 14), E = T(E, h, I, N, V[8], 1163531501, 20), N = T(N, E, h, I, V[13], 2850285829, 5), I = T(I, N, E, h, V[2], 4243563512, 9), h = T(h, I, N, E, V[7], 1735328473, 14), E = T(E, h, I, N, V[12], 2368359562, 20), N = X(N, E, h, I, V[5], 4294588738, 4), I = X(I, N, E, h, V[8], 2272392833, 11), h = X(h, I, N, E, V[11], 1839030562, 16), E = X(E, h, I, N, V[14], 4259657740, 23), N = X(N, E, h, I, V[1], 2763975236, 4), I = X(I, N, E, h, V[4], 1272893353, 11), h = X(h, I, N, E, V[7], 4139469664, 16), E = X(E, h, I, N, V[10], 3200236656, 23), N = X(N, E, h, I, V[13], 681279174, 4), I = X(I, N, E, h, V[0], 3936430074, 11), h = X(h, I, N, E, V[3], 3572445317, 16), E = X(E, h, I, N, V[6], 76029189, 23), N = X(N, E, h, I, V[9], 3654602809, 4), I = X(I, N, E, h, V[12], 3873151461, 11), h = X(h, I, N, E, V[15], 530742520, 16), E = X(E, h, I, N, V[2], 3299628645, 23), N = f(N, E, h, I, V[0], 4096336452, 6), I = f(I, N, E, h, V[7], 1126891415, 10), h = f(h, I, N, E, V[14], 2878612391, 15), E = f(E, h, I, N, V[5], 4237533241, 21), N = f(N, E, h, I, V[12], 1700485571, 6), I = f(I, N, E, h, V[3], 2399980690, 10), h = f(h, I, N, E, V[10], 4293915773, 15), E = f(E, h, I, N, V[1], 2240044497, 21), N = f(N, E, h, I, V[8], 1873313359, 6), I = f(I, N, E, h, V[15], 4264355552, 10), h = f(h, I, N, E, V[6], 2734768916, 15), E = f(E, h, I, N, V[13], 1309151649, 21), N = f(N, E, h, I, V[4], 4149444226, 6), I = f(I, N, E, h, V[11], 3174756917, 10), h = f(h, I, N, E, V[2], 718787259, 15), E = f(E, h, I, N, V[9], 3951481745, 21), this._a = this._a + N | 0, this._b = this._b + E | 0, this._c = this._c + h | 0, this._d = this._d + I | 0;
    }, O.prototype._digest = function() {
      if (this._block[this._blockOffset++] = 128, this._blockOffset > 56) this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0;
      this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
      var V = _.allocUnsafe(16);
      return V.writeInt32LE(this._a, 0), V.writeInt32LE(this._b, 4), V.writeInt32LE(this._c, 8), V.writeInt32LE(this._d, 12), V;
    };
    function z(V, M) {
      return V << M | V >>> 32 - M;
    }
    __name(z, "z");
    function J(V, M, N, E, h, I, D) {
      return z(V + (M & N | ~M & E) + h + I | 0, D) + M | 0;
    }
    __name(J, "J");
    function T(V, M, N, E, h, I, D) {
      return z(V + (M & E | N & ~E) + h + I | 0, D) + M | 0;
    }
    __name(T, "T");
    function X(V, M, N, E, h, I, D) {
      return z(V + (M ^ N ^ E) + h + I | 0, D) + M | 0;
    }
    __name(X, "X");
    function f(V, M, N, E, h, I, D) {
      return z(V + (N ^ (M | ~E)) + h + I | 0, D) + M | 0;
    }
    __name(f, "f");
    q.exports = O;
  }), co = r$(($, q) => {
    var K = q8().Buffer, P = po();
    function _(Y, O, z, J) {
      if (!K.isBuffer(Y)) Y = K.from(Y, "binary");
      if (O) {
        if (!K.isBuffer(O)) O = K.from(O, "binary");
        if (O.length !== 8) throw RangeError("salt should be Buffer with 8 byte length");
      }
      var T = z / 8, X = K.alloc(T), f = K.alloc(J || 0), V = K.alloc(0);
      while (T > 0 || J > 0) {
        var M = new P();
        if (M.update(V), M.update(Y), O) M.update(O);
        V = M.digest();
        var N = 0;
        if (T > 0) {
          var E = X.length - T;
          N = Math.min(T, V.length), V.copy(X, E, 0, N), T -= N;
        }
        if (N < V.length && J > 0) {
          var h = f.length - J, I = Math.min(J, V.length - N);
          V.copy(f, h, N, N + I), J -= I;
        }
      }
      return V.fill(0), { key: X, iv: f };
    }
    __name(_, "_");
    q.exports = _;
  }), A0 = r$(($) => {
    var q = (lq(), J6(dq));
    $.createCipher = $.Cipher = q.createCipher, $.createCipheriv = $.Cipheriv = q.createCipheriv, $.createDecipher = $.Decipher = q.createDecipher, $.createDecipheriv = $.Decipheriv = q.createDecipheriv, $.listCiphers = $.getCiphers = q.getCiphers;
  }), mo = r$(($, q) => {
    var K = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m, P = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m, _ = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m, Y = co(), O = A0(), z = q8().Buffer;
    q.exports = function(J, T) {
      var X = J.toString(), f = X.match(K), V;
      if (!f) {
        var M = X.match(_);
        V = z.from(M[2].replace(/[\r\n]/g, ""), "base64");
      } else {
        var N = "aes" + f[1], E = z.from(f[2], "hex"), h = z.from(f[3].replace(/[\r\n]/g, ""), "base64"), I = Y(T, E.slice(0, 8), parseInt(f[1], 10)).key, D = [], g = O.createDecipheriv(N, I, E);
        D.push(g.update(h)), D.push(g.final()), V = z.concat(D);
      }
      var b = X.match(P)[1];
      return { tag: b, data: V };
    };
  }), k0 = r$(($, q) => {
    var K = yo(), P = uo(), _ = mo(), Y = A0(), O = v0(), z = q8().Buffer;
    function J(X, f) {
      var V = X.algorithm.decrypt.kde.kdeparams.salt, M = parseInt(X.algorithm.decrypt.kde.kdeparams.iters.toString(), 10), N = P[X.algorithm.decrypt.cipher.algo.join(".")], E = X.algorithm.decrypt.cipher.iv, h = X.subjectPrivateKey, I = parseInt(N.split("-")[1], 10) / 8, D = O.pbkdf2Sync(f, V, M, I, "sha1"), g = Y.createDecipheriv(N, D, E), b = [];
      return b.push(g.update(h)), b.push(g.final()), z.concat(b);
    }
    __name(J, "J");
    function T(X) {
      var f;
      if (typeof X === "object" && !z.isBuffer(X)) f = X.passphrase, X = X.key;
      if (typeof X === "string") X = z.from(X);
      var V = _(X, f), M = V.tag, N = V.data, E, h;
      switch (M) {
        case "CERTIFICATE":
          h = K.certificate.decode(N, "der").tbsCertificate.subjectPublicKeyInfo;
        case "PUBLIC KEY":
          if (!h) h = K.PublicKey.decode(N, "der");
          switch (E = h.algorithm.algorithm.join("."), E) {
            case "1.2.840.113549.1.1.1":
              return K.RSAPublicKey.decode(h.subjectPublicKey.data, "der");
            case "1.2.840.10045.2.1":
              return h.subjectPrivateKey = h.subjectPublicKey, { type: "ec", data: h };
            case "1.2.840.10040.4.1":
              return h.algorithm.params.pub_key = K.DSAparam.decode(h.subjectPublicKey.data, "der"), { type: "dsa", data: h.algorithm.params };
            default:
              throw Error("unknown key id " + E);
          }
        case "ENCRYPTED PRIVATE KEY":
          N = K.EncryptedPrivateKey.decode(N, "der"), N = J(N, f);
        case "PRIVATE KEY":
          switch (h = K.PrivateKey.decode(N, "der"), E = h.algorithm.algorithm.join("."), E) {
            case "1.2.840.113549.1.1.1":
              return K.RSAPrivateKey.decode(h.subjectPrivateKey, "der");
            case "1.2.840.10045.2.1":
              return { curve: h.algorithm.curve, privateKey: K.ECPrivateKey.decode(h.subjectPrivateKey, "der").privateKey };
            case "1.2.840.10040.4.1":
              return h.algorithm.params.priv_key = K.DSAparam.decode(h.subjectPrivateKey, "der"), { type: "dsa", params: h.algorithm.params };
            default:
              throw Error("unknown key id " + E);
          }
        case "RSA PUBLIC KEY":
          return K.RSAPublicKey.decode(N, "der");
        case "RSA PRIVATE KEY":
          return K.RSAPrivateKey.decode(N, "der");
        case "DSA PRIVATE KEY":
          return { type: "dsa", params: K.DSAPrivateKey.decode(N, "der") };
        case "EC PRIVATE KEY":
          return N = K.ECPrivateKey.decode(N, "der"), { curve: N.parameters.value, privateKey: N.privateKey };
        default:
          throw Error("unknown key type " + M);
      }
    }
    __name(T, "T");
    T.signature = K.signature, q.exports = T;
  }), G0 = r$(($, q) => {
    var K = vO(), P = q8().Buffer;
    q.exports = function(Y, O) {
      var z = P.alloc(0), J = 0, T;
      while (z.length < O) T = _(J++), z = P.concat([z, K("sha1").update(Y).update(T).digest()]);
      return z.slice(0, O);
    };
    function _(Y) {
      var O = P.allocUnsafe(4);
      return O.writeUInt32BE(Y, 0), O;
    }
    __name(_, "_");
  }), V0 = r$(($, q) => {
    q.exports = function(K, P) {
      var _ = K.length, Y = -1;
      while (++Y < _) K[Y] ^= P[Y];
      return K;
    };
  }), BH = r$(($, q) => {
    (function(K, P) {
      function _(j, H) {
        if (!j) throw Error(H || "Assertion failed");
      }
      __name(_, "_");
      function Y(j, H) {
        j.super_ = H;
        var Z = /* @__PURE__ */ __name(function() {
        }, "Z");
        Z.prototype = H.prototype, j.prototype = new Z(), j.prototype.constructor = j;
      }
      __name(Y, "Y");
      function O(j, H, Z) {
        if (O.isBN(j)) return j;
        if (this.negative = 0, this.words = null, this.length = 0, this.red = null, j !== null) {
          if (H === "le" || H === "be") Z = H, H = 10;
          this._init(j || 0, H || 10, Z || "be");
        }
      }
      __name(O, "O");
      if (typeof K === "object") K.exports = O;
      else P.BN = O;
      O.BN = O, O.wordSize = 26;
      var z;
      try {
        if (typeof window < "u" && typeof window.Buffer < "u") z = window.Buffer;
        else z = (fq(), J6(wq)).Buffer;
      } catch (j) {
      }
      O.isBN = function(j) {
        if (j instanceof O) return true;
        return j !== null && typeof j === "object" && j.constructor.wordSize === O.wordSize && Array.isArray(j.words);
      }, O.max = function(j, H) {
        if (j.cmp(H) > 0) return j;
        return H;
      }, O.min = function(j, H) {
        if (j.cmp(H) < 0) return j;
        return H;
      }, O.prototype._init = function(j, H, Z) {
        if (typeof j === "number") return this._initNumber(j, H, Z);
        if (typeof j === "object") return this._initArray(j, H, Z);
        if (H === "hex") H = 16;
        _(H === (H | 0) && H >= 2 && H <= 36), j = j.toString().replace(/\s+/g, "");
        var W = 0;
        if (j[0] === "-") W++, this.negative = 1;
        if (W < j.length) {
          if (H === 16) this._parseHex(j, W, Z);
          else if (this._parseBase(j, H, W), Z === "le") this._initArray(this.toArray(), H, Z);
        }
      }, O.prototype._initNumber = function(j, H, Z) {
        if (j < 0) this.negative = 1, j = -j;
        if (j < 67108864) this.words = [j & 67108863], this.length = 1;
        else if (j < 4503599627370496) this.words = [j & 67108863, j / 67108864 & 67108863], this.length = 2;
        else _(j < 9007199254740992), this.words = [j & 67108863, j / 67108864 & 67108863, 1], this.length = 3;
        if (Z !== "le") return;
        this._initArray(this.toArray(), H, Z);
      }, O.prototype._initArray = function(j, H, Z) {
        if (_(typeof j.length === "number"), j.length <= 0) return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(j.length / 3), this.words = Array(this.length);
        for (var W = 0; W < this.length; W++) this.words[W] = 0;
        var w, G, S = 0;
        if (Z === "be") {
          for (W = j.length - 1, w = 0; W >= 0; W -= 3) if (G = j[W] | j[W - 1] << 8 | j[W - 2] << 16, this.words[w] |= G << S & 67108863, this.words[w + 1] = G >>> 26 - S & 67108863, S += 24, S >= 26) S -= 26, w++;
        } else if (Z === "le") {
          for (W = 0, w = 0; W < j.length; W += 3) if (G = j[W] | j[W + 1] << 8 | j[W + 2] << 16, this.words[w] |= G << S & 67108863, this.words[w + 1] = G >>> 26 - S & 67108863, S += 24, S >= 26) S -= 26, w++;
        }
        return this.strip();
      };
      function J(j, H) {
        var Z = j.charCodeAt(H);
        if (Z >= 65 && Z <= 70) return Z - 55;
        else if (Z >= 97 && Z <= 102) return Z - 87;
        else return Z - 48 & 15;
      }
      __name(J, "J");
      function T(j, H, Z) {
        var W = J(j, Z);
        if (Z - 1 >= H) W |= J(j, Z - 1) << 4;
        return W;
      }
      __name(T, "T");
      O.prototype._parseHex = function(j, H, Z) {
        this.length = Math.ceil((j.length - H) / 6), this.words = Array(this.length);
        for (var W = 0; W < this.length; W++) this.words[W] = 0;
        var w = 0, G = 0, S;
        if (Z === "be") for (W = j.length - 1; W >= H; W -= 2) if (S = T(j, H, W) << w, this.words[G] |= S & 67108863, w >= 18) w -= 18, G += 1, this.words[G] |= S >>> 26;
        else w += 8;
        else {
          var A = j.length - H;
          for (W = A % 2 === 0 ? H + 1 : H; W < j.length; W += 2) if (S = T(j, H, W) << w, this.words[G] |= S & 67108863, w >= 18) w -= 18, G += 1, this.words[G] |= S >>> 26;
          else w += 8;
        }
        this.strip();
      };
      function X(j, H, Z, W) {
        var w = 0, G = Math.min(j.length, Z);
        for (var S = H; S < G; S++) {
          var A = j.charCodeAt(S) - 48;
          if (w *= W, A >= 49) w += A - 49 + 10;
          else if (A >= 17) w += A - 17 + 10;
          else w += A;
        }
        return w;
      }
      __name(X, "X");
      O.prototype._parseBase = function(j, H, Z) {
        this.words = [0], this.length = 1;
        for (var W = 0, w = 1; w <= 67108863; w *= H) W++;
        W--, w = w / H | 0;
        var G = j.length - Z, S = G % W, A = Math.min(G, G - S) + Z, v = 0;
        for (var k = Z; k < A; k += W) if (v = X(j, k, k + W, H), this.imuln(w), this.words[0] + v < 67108864) this.words[0] += v;
        else this._iaddn(v);
        if (S !== 0) {
          var R = 1;
          v = X(j, k, j.length, H);
          for (k = 0; k < S; k++) R *= H;
          if (this.imuln(R), this.words[0] + v < 67108864) this.words[0] += v;
          else this._iaddn(v);
        }
        this.strip();
      }, O.prototype.copy = function(j) {
        j.words = Array(this.length);
        for (var H = 0; H < this.length; H++) j.words[H] = this.words[H];
        j.length = this.length, j.negative = this.negative, j.red = this.red;
      }, O.prototype.clone = function() {
        var j = new O(null);
        return this.copy(j), j;
      }, O.prototype._expand = function(j) {
        while (this.length < j) this.words[this.length++] = 0;
        return this;
      }, O.prototype.strip = function() {
        while (this.length > 1 && this.words[this.length - 1] === 0) this.length--;
        return this._normSign();
      }, O.prototype._normSign = function() {
        if (this.length === 1 && this.words[0] === 0) this.negative = 0;
        return this;
      }, O.prototype.inspect = function() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var f = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], V = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], M = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
      if (O.prototype.toString = function(j, H) {
        j = j || 10, H = H | 0 || 1;
        var Z;
        if (j === 16 || j === "hex") {
          Z = "";
          var W = 0, w = 0;
          for (var G = 0; G < this.length; G++) {
            var S = this.words[G], A = ((S << W | w) & 16777215).toString(16);
            if (w = S >>> 24 - W & 16777215, W += 2, W >= 26) W -= 26, G--;
            if (w !== 0 || G !== this.length - 1) Z = f[6 - A.length] + A + Z;
            else Z = A + Z;
          }
          if (w !== 0) Z = w.toString(16) + Z;
          while (Z.length % H !== 0) Z = "0" + Z;
          if (this.negative !== 0) Z = "-" + Z;
          return Z;
        }
        if (j === (j | 0) && j >= 2 && j <= 36) {
          var v = V[j], k = M[j];
          Z = "";
          var R = this.clone();
          R.negative = 0;
          while (!R.isZero()) {
            var C = R.modn(k).toString(j);
            if (R = R.idivn(k), !R.isZero()) Z = f[v - C.length] + C + Z;
            else Z = C + Z;
          }
          if (this.isZero()) Z = "0" + Z;
          while (Z.length % H !== 0) Z = "0" + Z;
          if (this.negative !== 0) Z = "-" + Z;
          return Z;
        }
        _(false, "Base should be between 2 and 36");
      }, O.prototype.toNumber = function() {
        var j = this.words[0];
        if (this.length === 2) j += this.words[1] * 67108864;
        else if (this.length === 3 && this.words[2] === 1) j += 4503599627370496 + this.words[1] * 67108864;
        else if (this.length > 2) _(false, "Number can only safely store up to 53 bits");
        return this.negative !== 0 ? -j : j;
      }, O.prototype.toJSON = function() {
        return this.toString(16);
      }, O.prototype.toBuffer = function(j, H) {
        return _(typeof z < "u"), this.toArrayLike(z, j, H);
      }, O.prototype.toArray = function(j, H) {
        return this.toArrayLike(Array, j, H);
      }, O.prototype.toArrayLike = function(j, H, Z) {
        var W = this.byteLength(), w = Z || Math.max(1, W);
        _(W <= w, "byte array longer than desired length"), _(w > 0, "Requested array length <= 0"), this.strip();
        var G = H === "le", S = new j(w), A, v, k = this.clone();
        if (!G) {
          for (v = 0; v < w - W; v++) S[v] = 0;
          for (v = 0; !k.isZero(); v++) A = k.andln(255), k.iushrn(8), S[w - v - 1] = A;
        } else {
          for (v = 0; !k.isZero(); v++) A = k.andln(255), k.iushrn(8), S[v] = A;
          for (; v < w; v++) S[v] = 0;
        }
        return S;
      }, Math.clz32) O.prototype._countBits = function(j) {
        return 32 - Math.clz32(j);
      };
      else O.prototype._countBits = function(j) {
        var H = j, Z = 0;
        if (H >= 4096) Z += 13, H >>>= 13;
        if (H >= 64) Z += 7, H >>>= 7;
        if (H >= 8) Z += 4, H >>>= 4;
        if (H >= 2) Z += 2, H >>>= 2;
        return Z + H;
      };
      O.prototype._zeroBits = function(j) {
        if (j === 0) return 26;
        var H = j, Z = 0;
        if ((H & 8191) === 0) Z += 13, H >>>= 13;
        if ((H & 127) === 0) Z += 7, H >>>= 7;
        if ((H & 15) === 0) Z += 4, H >>>= 4;
        if ((H & 3) === 0) Z += 2, H >>>= 2;
        if ((H & 1) === 0) Z++;
        return Z;
      }, O.prototype.bitLength = function() {
        var j = this.words[this.length - 1], H = this._countBits(j);
        return (this.length - 1) * 26 + H;
      };
      function N(j) {
        var H = Array(j.bitLength());
        for (var Z = 0; Z < H.length; Z++) {
          var W = Z / 26 | 0, w = Z % 26;
          H[Z] = (j.words[W] & 1 << w) >>> w;
        }
        return H;
      }
      __name(N, "N");
      O.prototype.zeroBits = function() {
        if (this.isZero()) return 0;
        var j = 0;
        for (var H = 0; H < this.length; H++) {
          var Z = this._zeroBits(this.words[H]);
          if (j += Z, Z !== 26) break;
        }
        return j;
      }, O.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, O.prototype.toTwos = function(j) {
        if (this.negative !== 0) return this.abs().inotn(j).iaddn(1);
        return this.clone();
      }, O.prototype.fromTwos = function(j) {
        if (this.testn(j - 1)) return this.notn(j).iaddn(1).ineg();
        return this.clone();
      }, O.prototype.isNeg = function() {
        return this.negative !== 0;
      }, O.prototype.neg = function() {
        return this.clone().ineg();
      }, O.prototype.ineg = function() {
        if (!this.isZero()) this.negative ^= 1;
        return this;
      }, O.prototype.iuor = function(j) {
        while (this.length < j.length) this.words[this.length++] = 0;
        for (var H = 0; H < j.length; H++) this.words[H] = this.words[H] | j.words[H];
        return this.strip();
      }, O.prototype.ior = function(j) {
        return _((this.negative | j.negative) === 0), this.iuor(j);
      }, O.prototype.or = function(j) {
        if (this.length > j.length) return this.clone().ior(j);
        return j.clone().ior(this);
      }, O.prototype.uor = function(j) {
        if (this.length > j.length) return this.clone().iuor(j);
        return j.clone().iuor(this);
      }, O.prototype.iuand = function(j) {
        var H;
        if (this.length > j.length) H = j;
        else H = this;
        for (var Z = 0; Z < H.length; Z++) this.words[Z] = this.words[Z] & j.words[Z];
        return this.length = H.length, this.strip();
      }, O.prototype.iand = function(j) {
        return _((this.negative | j.negative) === 0), this.iuand(j);
      }, O.prototype.and = function(j) {
        if (this.length > j.length) return this.clone().iand(j);
        return j.clone().iand(this);
      }, O.prototype.uand = function(j) {
        if (this.length > j.length) return this.clone().iuand(j);
        return j.clone().iuand(this);
      }, O.prototype.iuxor = function(j) {
        var H, Z;
        if (this.length > j.length) H = this, Z = j;
        else H = j, Z = this;
        for (var W = 0; W < Z.length; W++) this.words[W] = H.words[W] ^ Z.words[W];
        if (this !== H) for (; W < H.length; W++) this.words[W] = H.words[W];
        return this.length = H.length, this.strip();
      }, O.prototype.ixor = function(j) {
        return _((this.negative | j.negative) === 0), this.iuxor(j);
      }, O.prototype.xor = function(j) {
        if (this.length > j.length) return this.clone().ixor(j);
        return j.clone().ixor(this);
      }, O.prototype.uxor = function(j) {
        if (this.length > j.length) return this.clone().iuxor(j);
        return j.clone().iuxor(this);
      }, O.prototype.inotn = function(j) {
        _(typeof j === "number" && j >= 0);
        var H = Math.ceil(j / 26) | 0, Z = j % 26;
        if (this._expand(H), Z > 0) H--;
        for (var W = 0; W < H; W++) this.words[W] = ~this.words[W] & 67108863;
        if (Z > 0) this.words[W] = ~this.words[W] & 67108863 >> 26 - Z;
        return this.strip();
      }, O.prototype.notn = function(j) {
        return this.clone().inotn(j);
      }, O.prototype.setn = function(j, H) {
        _(typeof j === "number" && j >= 0);
        var Z = j / 26 | 0, W = j % 26;
        if (this._expand(Z + 1), H) this.words[Z] = this.words[Z] | 1 << W;
        else this.words[Z] = this.words[Z] & ~(1 << W);
        return this.strip();
      }, O.prototype.iadd = function(j) {
        var H;
        if (this.negative !== 0 && j.negative === 0) return this.negative = 0, H = this.isub(j), this.negative ^= 1, this._normSign();
        else if (this.negative === 0 && j.negative !== 0) return j.negative = 0, H = this.isub(j), j.negative = 1, H._normSign();
        var Z, W;
        if (this.length > j.length) Z = this, W = j;
        else Z = j, W = this;
        var w = 0;
        for (var G = 0; G < W.length; G++) H = (Z.words[G] | 0) + (W.words[G] | 0) + w, this.words[G] = H & 67108863, w = H >>> 26;
        for (; w !== 0 && G < Z.length; G++) H = (Z.words[G] | 0) + w, this.words[G] = H & 67108863, w = H >>> 26;
        if (this.length = Z.length, w !== 0) this.words[this.length] = w, this.length++;
        else if (Z !== this) for (; G < Z.length; G++) this.words[G] = Z.words[G];
        return this;
      }, O.prototype.add = function(j) {
        var H;
        if (j.negative !== 0 && this.negative === 0) return j.negative = 0, H = this.sub(j), j.negative ^= 1, H;
        else if (j.negative === 0 && this.negative !== 0) return this.negative = 0, H = j.sub(this), this.negative = 1, H;
        if (this.length > j.length) return this.clone().iadd(j);
        return j.clone().iadd(this);
      }, O.prototype.isub = function(j) {
        if (j.negative !== 0) {
          j.negative = 0;
          var H = this.iadd(j);
          return j.negative = 1, H._normSign();
        } else if (this.negative !== 0) return this.negative = 0, this.iadd(j), this.negative = 1, this._normSign();
        var Z = this.cmp(j);
        if (Z === 0) return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var W, w;
        if (Z > 0) W = this, w = j;
        else W = j, w = this;
        var G = 0;
        for (var S = 0; S < w.length; S++) H = (W.words[S] | 0) - (w.words[S] | 0) + G, G = H >> 26, this.words[S] = H & 67108863;
        for (; G !== 0 && S < W.length; S++) H = (W.words[S] | 0) + G, G = H >> 26, this.words[S] = H & 67108863;
        if (G === 0 && S < W.length && W !== this) for (; S < W.length; S++) this.words[S] = W.words[S];
        if (this.length = Math.max(this.length, S), W !== this) this.negative = 1;
        return this.strip();
      }, O.prototype.sub = function(j) {
        return this.clone().isub(j);
      };
      function E(j, H, Z) {
        Z.negative = H.negative ^ j.negative;
        var W = j.length + H.length | 0;
        Z.length = W, W = W - 1 | 0;
        var w = j.words[0] | 0, G = H.words[0] | 0, S = w * G, A = S & 67108863, v = S / 67108864 | 0;
        Z.words[0] = A;
        for (var k = 1; k < W; k++) {
          var R = v >>> 26, C = v & 67108863, L = Math.min(k, H.length - 1);
          for (var x = Math.max(0, k - j.length + 1); x <= L; x++) {
            var l = k - x | 0;
            w = j.words[l] | 0, G = H.words[x] | 0, S = w * G + C, R += S / 67108864 | 0, C = S & 67108863;
          }
          Z.words[k] = C | 0, v = R | 0;
        }
        if (v !== 0) Z.words[k] = v | 0;
        else Z.length--;
        return Z.strip();
      }
      __name(E, "E");
      var h = /* @__PURE__ */ __name(function(j, H, Z) {
        var W = j.words, w = H.words, G = Z.words, S = 0, A, v, k, R = W[0] | 0, C = R & 8191, L = R >>> 13, x = W[1] | 0, l = x & 8191, a = x >>> 13, f$ = W[2] | 0, $$ = f$ & 8191, t = f$ >>> 13, H$ = W[3] | 0, Q = H$ & 8191, v$ = H$ >>> 13, B$ = W[4] | 0, m = B$ & 8191, r = B$ >>> 13, J$ = W[5] | 0, e = J$ & 8191, _$2 = J$ >>> 13, Y$ = W[6] | 0, d = Y$ & 8191, o = Y$ >>> 13, W$ = W[7] | 0, B = W$ & 8191, F = W$ >>> 13, X$ = W[8] | 0, z$ = X$ & 8191, j$ = X$ >>> 13, X6 = W[9] | 0, Z$ = X6 & 8191, A$ = X6 >>> 13, l6 = w[0] | 0, S$ = l6 & 8191, V$ = l6 >>> 13, Mq = w[1] | 0, N$ = Mq & 8191, D$ = Mq >>> 13, Nq = w[2] | 0, L$ = Nq & 8191, C$ = Nq >>> 13, Zq = w[3] | 0, g$ = Zq & 8191, h$ = Zq >>> 13, zq = w[4] | 0, b$ = zq & 8191, y$ = zq >>> 13, Wq = w[5] | 0, E$ = Wq & 8191, u = Wq >>> 13, i = w[6] | 0, K$ = i & 8191, P$ = i >>> 13, i$ = w[7] | 0, k$ = i$ & 8191, G$ = i$ >>> 13, x6 = w[8] | 0, R$ = x6 & 8191, u$ = x6 >>> 13, Xq = w[9] | 0, I$ = Xq & 8191, M$ = Xq >>> 13;
        Z.negative = j.negative ^ H.negative, Z.length = 19, A = Math.imul(C, S$), v = Math.imul(C, V$), v = v + Math.imul(L, S$) | 0, k = Math.imul(L, V$);
        var p6 = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (p6 >>> 26) | 0, p6 &= 67108863, A = Math.imul(l, S$), v = Math.imul(l, V$), v = v + Math.imul(a, S$) | 0, k = Math.imul(a, V$), A = A + Math.imul(C, N$) | 0, v = v + Math.imul(C, D$) | 0, v = v + Math.imul(L, N$) | 0, k = k + Math.imul(L, D$) | 0;
        var H6 = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (H6 >>> 26) | 0, H6 &= 67108863, A = Math.imul($$, S$), v = Math.imul($$, V$), v = v + Math.imul(t, S$) | 0, k = Math.imul(t, V$), A = A + Math.imul(l, N$) | 0, v = v + Math.imul(l, D$) | 0, v = v + Math.imul(a, N$) | 0, k = k + Math.imul(a, D$) | 0, A = A + Math.imul(C, L$) | 0, v = v + Math.imul(C, C$) | 0, v = v + Math.imul(L, L$) | 0, k = k + Math.imul(L, C$) | 0;
        var v6 = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (v6 >>> 26) | 0, v6 &= 67108863, A = Math.imul(Q, S$), v = Math.imul(Q, V$), v = v + Math.imul(v$, S$) | 0, k = Math.imul(v$, V$), A = A + Math.imul($$, N$) | 0, v = v + Math.imul($$, D$) | 0, v = v + Math.imul(t, N$) | 0, k = k + Math.imul(t, D$) | 0, A = A + Math.imul(l, L$) | 0, v = v + Math.imul(l, C$) | 0, v = v + Math.imul(a, L$) | 0, k = k + Math.imul(a, C$) | 0, A = A + Math.imul(C, g$) | 0, v = v + Math.imul(C, h$) | 0, v = v + Math.imul(L, g$) | 0, k = k + Math.imul(L, h$) | 0;
        var C6 = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (C6 >>> 26) | 0, C6 &= 67108863, A = Math.imul(m, S$), v = Math.imul(m, V$), v = v + Math.imul(r, S$) | 0, k = Math.imul(r, V$), A = A + Math.imul(Q, N$) | 0, v = v + Math.imul(Q, D$) | 0, v = v + Math.imul(v$, N$) | 0, k = k + Math.imul(v$, D$) | 0, A = A + Math.imul($$, L$) | 0, v = v + Math.imul($$, C$) | 0, v = v + Math.imul(t, L$) | 0, k = k + Math.imul(t, C$) | 0, A = A + Math.imul(l, g$) | 0, v = v + Math.imul(l, h$) | 0, v = v + Math.imul(a, g$) | 0, k = k + Math.imul(a, h$) | 0, A = A + Math.imul(C, b$) | 0, v = v + Math.imul(C, y$) | 0, v = v + Math.imul(L, b$) | 0, k = k + Math.imul(L, y$) | 0;
        var S6 = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (S6 >>> 26) | 0, S6 &= 67108863, A = Math.imul(e, S$), v = Math.imul(e, V$), v = v + Math.imul(_$2, S$) | 0, k = Math.imul(_$2, V$), A = A + Math.imul(m, N$) | 0, v = v + Math.imul(m, D$) | 0, v = v + Math.imul(r, N$) | 0, k = k + Math.imul(r, D$) | 0, A = A + Math.imul(Q, L$) | 0, v = v + Math.imul(Q, C$) | 0, v = v + Math.imul(v$, L$) | 0, k = k + Math.imul(v$, C$) | 0, A = A + Math.imul($$, g$) | 0, v = v + Math.imul($$, h$) | 0, v = v + Math.imul(t, g$) | 0, k = k + Math.imul(t, h$) | 0, A = A + Math.imul(l, b$) | 0, v = v + Math.imul(l, y$) | 0, v = v + Math.imul(a, b$) | 0, k = k + Math.imul(a, y$) | 0, A = A + Math.imul(C, E$) | 0, v = v + Math.imul(C, u) | 0, v = v + Math.imul(L, E$) | 0, k = k + Math.imul(L, u) | 0;
        var t6 = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (t6 >>> 26) | 0, t6 &= 67108863, A = Math.imul(d, S$), v = Math.imul(d, V$), v = v + Math.imul(o, S$) | 0, k = Math.imul(o, V$), A = A + Math.imul(e, N$) | 0, v = v + Math.imul(e, D$) | 0, v = v + Math.imul(_$2, N$) | 0, k = k + Math.imul(_$2, D$) | 0, A = A + Math.imul(m, L$) | 0, v = v + Math.imul(m, C$) | 0, v = v + Math.imul(r, L$) | 0, k = k + Math.imul(r, C$) | 0, A = A + Math.imul(Q, g$) | 0, v = v + Math.imul(Q, h$) | 0, v = v + Math.imul(v$, g$) | 0, k = k + Math.imul(v$, h$) | 0, A = A + Math.imul($$, b$) | 0, v = v + Math.imul($$, y$) | 0, v = v + Math.imul(t, b$) | 0, k = k + Math.imul(t, y$) | 0, A = A + Math.imul(l, E$) | 0, v = v + Math.imul(l, u) | 0, v = v + Math.imul(a, E$) | 0, k = k + Math.imul(a, u) | 0, A = A + Math.imul(C, K$) | 0, v = v + Math.imul(C, P$) | 0, v = v + Math.imul(L, K$) | 0, k = k + Math.imul(L, P$) | 0;
        var B6 = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (B6 >>> 26) | 0, B6 &= 67108863, A = Math.imul(B, S$), v = Math.imul(B, V$), v = v + Math.imul(F, S$) | 0, k = Math.imul(F, V$), A = A + Math.imul(d, N$) | 0, v = v + Math.imul(d, D$) | 0, v = v + Math.imul(o, N$) | 0, k = k + Math.imul(o, D$) | 0, A = A + Math.imul(e, L$) | 0, v = v + Math.imul(e, C$) | 0, v = v + Math.imul(_$2, L$) | 0, k = k + Math.imul(_$2, C$) | 0, A = A + Math.imul(m, g$) | 0, v = v + Math.imul(m, h$) | 0, v = v + Math.imul(r, g$) | 0, k = k + Math.imul(r, h$) | 0, A = A + Math.imul(Q, b$) | 0, v = v + Math.imul(Q, y$) | 0, v = v + Math.imul(v$, b$) | 0, k = k + Math.imul(v$, y$) | 0, A = A + Math.imul($$, E$) | 0, v = v + Math.imul($$, u) | 0, v = v + Math.imul(t, E$) | 0, k = k + Math.imul(t, u) | 0, A = A + Math.imul(l, K$) | 0, v = v + Math.imul(l, P$) | 0, v = v + Math.imul(a, K$) | 0, k = k + Math.imul(a, P$) | 0, A = A + Math.imul(C, k$) | 0, v = v + Math.imul(C, G$) | 0, v = v + Math.imul(L, k$) | 0, k = k + Math.imul(L, G$) | 0;
        var U6 = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (U6 >>> 26) | 0, U6 &= 67108863, A = Math.imul(z$, S$), v = Math.imul(z$, V$), v = v + Math.imul(j$, S$) | 0, k = Math.imul(j$, V$), A = A + Math.imul(B, N$) | 0, v = v + Math.imul(B, D$) | 0, v = v + Math.imul(F, N$) | 0, k = k + Math.imul(F, D$) | 0, A = A + Math.imul(d, L$) | 0, v = v + Math.imul(d, C$) | 0, v = v + Math.imul(o, L$) | 0, k = k + Math.imul(o, C$) | 0, A = A + Math.imul(e, g$) | 0, v = v + Math.imul(e, h$) | 0, v = v + Math.imul(_$2, g$) | 0, k = k + Math.imul(_$2, h$) | 0, A = A + Math.imul(m, b$) | 0, v = v + Math.imul(m, y$) | 0, v = v + Math.imul(r, b$) | 0, k = k + Math.imul(r, y$) | 0, A = A + Math.imul(Q, E$) | 0, v = v + Math.imul(Q, u) | 0, v = v + Math.imul(v$, E$) | 0, k = k + Math.imul(v$, u) | 0, A = A + Math.imul($$, K$) | 0, v = v + Math.imul($$, P$) | 0, v = v + Math.imul(t, K$) | 0, k = k + Math.imul(t, P$) | 0, A = A + Math.imul(l, k$) | 0, v = v + Math.imul(l, G$) | 0, v = v + Math.imul(a, k$) | 0, k = k + Math.imul(a, G$) | 0, A = A + Math.imul(C, R$) | 0, v = v + Math.imul(C, u$) | 0, v = v + Math.imul(L, R$) | 0, k = k + Math.imul(L, u$) | 0;
        var F6 = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (F6 >>> 26) | 0, F6 &= 67108863, A = Math.imul(Z$, S$), v = Math.imul(Z$, V$), v = v + Math.imul(A$, S$) | 0, k = Math.imul(A$, V$), A = A + Math.imul(z$, N$) | 0, v = v + Math.imul(z$, D$) | 0, v = v + Math.imul(j$, N$) | 0, k = k + Math.imul(j$, D$) | 0, A = A + Math.imul(B, L$) | 0, v = v + Math.imul(B, C$) | 0, v = v + Math.imul(F, L$) | 0, k = k + Math.imul(F, C$) | 0, A = A + Math.imul(d, g$) | 0, v = v + Math.imul(d, h$) | 0, v = v + Math.imul(o, g$) | 0, k = k + Math.imul(o, h$) | 0, A = A + Math.imul(e, b$) | 0, v = v + Math.imul(e, y$) | 0, v = v + Math.imul(_$2, b$) | 0, k = k + Math.imul(_$2, y$) | 0, A = A + Math.imul(m, E$) | 0, v = v + Math.imul(m, u) | 0, v = v + Math.imul(r, E$) | 0, k = k + Math.imul(r, u) | 0, A = A + Math.imul(Q, K$) | 0, v = v + Math.imul(Q, P$) | 0, v = v + Math.imul(v$, K$) | 0, k = k + Math.imul(v$, P$) | 0, A = A + Math.imul($$, k$) | 0, v = v + Math.imul($$, G$) | 0, v = v + Math.imul(t, k$) | 0, k = k + Math.imul(t, G$) | 0, A = A + Math.imul(l, R$) | 0, v = v + Math.imul(l, u$) | 0, v = v + Math.imul(a, R$) | 0, k = k + Math.imul(a, u$) | 0, A = A + Math.imul(C, I$) | 0, v = v + Math.imul(C, M$) | 0, v = v + Math.imul(L, I$) | 0, k = k + Math.imul(L, M$) | 0;
        var a6 = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (a6 >>> 26) | 0, a6 &= 67108863, A = Math.imul(Z$, N$), v = Math.imul(Z$, D$), v = v + Math.imul(A$, N$) | 0, k = Math.imul(A$, D$), A = A + Math.imul(z$, L$) | 0, v = v + Math.imul(z$, C$) | 0, v = v + Math.imul(j$, L$) | 0, k = k + Math.imul(j$, C$) | 0, A = A + Math.imul(B, g$) | 0, v = v + Math.imul(B, h$) | 0, v = v + Math.imul(F, g$) | 0, k = k + Math.imul(F, h$) | 0, A = A + Math.imul(d, b$) | 0, v = v + Math.imul(d, y$) | 0, v = v + Math.imul(o, b$) | 0, k = k + Math.imul(o, y$) | 0, A = A + Math.imul(e, E$) | 0, v = v + Math.imul(e, u) | 0, v = v + Math.imul(_$2, E$) | 0, k = k + Math.imul(_$2, u) | 0, A = A + Math.imul(m, K$) | 0, v = v + Math.imul(m, P$) | 0, v = v + Math.imul(r, K$) | 0, k = k + Math.imul(r, P$) | 0, A = A + Math.imul(Q, k$) | 0, v = v + Math.imul(Q, G$) | 0, v = v + Math.imul(v$, k$) | 0, k = k + Math.imul(v$, G$) | 0, A = A + Math.imul($$, R$) | 0, v = v + Math.imul($$, u$) | 0, v = v + Math.imul(t, R$) | 0, k = k + Math.imul(t, u$) | 0, A = A + Math.imul(l, I$) | 0, v = v + Math.imul(l, M$) | 0, v = v + Math.imul(a, I$) | 0, k = k + Math.imul(a, M$) | 0;
        var Q6 = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (Q6 >>> 26) | 0, Q6 &= 67108863, A = Math.imul(Z$, L$), v = Math.imul(Z$, C$), v = v + Math.imul(A$, L$) | 0, k = Math.imul(A$, C$), A = A + Math.imul(z$, g$) | 0, v = v + Math.imul(z$, h$) | 0, v = v + Math.imul(j$, g$) | 0, k = k + Math.imul(j$, h$) | 0, A = A + Math.imul(B, b$) | 0, v = v + Math.imul(B, y$) | 0, v = v + Math.imul(F, b$) | 0, k = k + Math.imul(F, y$) | 0, A = A + Math.imul(d, E$) | 0, v = v + Math.imul(d, u) | 0, v = v + Math.imul(o, E$) | 0, k = k + Math.imul(o, u) | 0, A = A + Math.imul(e, K$) | 0, v = v + Math.imul(e, P$) | 0, v = v + Math.imul(_$2, K$) | 0, k = k + Math.imul(_$2, P$) | 0, A = A + Math.imul(m, k$) | 0, v = v + Math.imul(m, G$) | 0, v = v + Math.imul(r, k$) | 0, k = k + Math.imul(r, G$) | 0, A = A + Math.imul(Q, R$) | 0, v = v + Math.imul(Q, u$) | 0, v = v + Math.imul(v$, R$) | 0, k = k + Math.imul(v$, u$) | 0, A = A + Math.imul($$, I$) | 0, v = v + Math.imul($$, M$) | 0, v = v + Math.imul(t, I$) | 0, k = k + Math.imul(t, M$) | 0;
        var e6 = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (e6 >>> 26) | 0, e6 &= 67108863, A = Math.imul(Z$, g$), v = Math.imul(Z$, h$), v = v + Math.imul(A$, g$) | 0, k = Math.imul(A$, h$), A = A + Math.imul(z$, b$) | 0, v = v + Math.imul(z$, y$) | 0, v = v + Math.imul(j$, b$) | 0, k = k + Math.imul(j$, y$) | 0, A = A + Math.imul(B, E$) | 0, v = v + Math.imul(B, u) | 0, v = v + Math.imul(F, E$) | 0, k = k + Math.imul(F, u) | 0, A = A + Math.imul(d, K$) | 0, v = v + Math.imul(d, P$) | 0, v = v + Math.imul(o, K$) | 0, k = k + Math.imul(o, P$) | 0, A = A + Math.imul(e, k$) | 0, v = v + Math.imul(e, G$) | 0, v = v + Math.imul(_$2, k$) | 0, k = k + Math.imul(_$2, G$) | 0, A = A + Math.imul(m, R$) | 0, v = v + Math.imul(m, u$) | 0, v = v + Math.imul(r, R$) | 0, k = k + Math.imul(r, u$) | 0, A = A + Math.imul(Q, I$) | 0, v = v + Math.imul(Q, M$) | 0, v = v + Math.imul(v$, I$) | 0, k = k + Math.imul(v$, M$) | 0;
        var s6 = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (s6 >>> 26) | 0, s6 &= 67108863, A = Math.imul(Z$, b$), v = Math.imul(Z$, y$), v = v + Math.imul(A$, b$) | 0, k = Math.imul(A$, y$), A = A + Math.imul(z$, E$) | 0, v = v + Math.imul(z$, u) | 0, v = v + Math.imul(j$, E$) | 0, k = k + Math.imul(j$, u) | 0, A = A + Math.imul(B, K$) | 0, v = v + Math.imul(B, P$) | 0, v = v + Math.imul(F, K$) | 0, k = k + Math.imul(F, P$) | 0, A = A + Math.imul(d, k$) | 0, v = v + Math.imul(d, G$) | 0, v = v + Math.imul(o, k$) | 0, k = k + Math.imul(o, G$) | 0, A = A + Math.imul(e, R$) | 0, v = v + Math.imul(e, u$) | 0, v = v + Math.imul(_$2, R$) | 0, k = k + Math.imul(_$2, u$) | 0, A = A + Math.imul(m, I$) | 0, v = v + Math.imul(m, M$) | 0, v = v + Math.imul(r, I$) | 0, k = k + Math.imul(r, M$) | 0;
        var $q = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + ($q >>> 26) | 0, $q &= 67108863, A = Math.imul(Z$, E$), v = Math.imul(Z$, u), v = v + Math.imul(A$, E$) | 0, k = Math.imul(A$, u), A = A + Math.imul(z$, K$) | 0, v = v + Math.imul(z$, P$) | 0, v = v + Math.imul(j$, K$) | 0, k = k + Math.imul(j$, P$) | 0, A = A + Math.imul(B, k$) | 0, v = v + Math.imul(B, G$) | 0, v = v + Math.imul(F, k$) | 0, k = k + Math.imul(F, G$) | 0, A = A + Math.imul(d, R$) | 0, v = v + Math.imul(d, u$) | 0, v = v + Math.imul(o, R$) | 0, k = k + Math.imul(o, u$) | 0, A = A + Math.imul(e, I$) | 0, v = v + Math.imul(e, M$) | 0, v = v + Math.imul(_$2, I$) | 0, k = k + Math.imul(_$2, M$) | 0;
        var qq = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (qq >>> 26) | 0, qq &= 67108863, A = Math.imul(Z$, K$), v = Math.imul(Z$, P$), v = v + Math.imul(A$, K$) | 0, k = Math.imul(A$, P$), A = A + Math.imul(z$, k$) | 0, v = v + Math.imul(z$, G$) | 0, v = v + Math.imul(j$, k$) | 0, k = k + Math.imul(j$, G$) | 0, A = A + Math.imul(B, R$) | 0, v = v + Math.imul(B, u$) | 0, v = v + Math.imul(F, R$) | 0, k = k + Math.imul(F, u$) | 0, A = A + Math.imul(d, I$) | 0, v = v + Math.imul(d, M$) | 0, v = v + Math.imul(o, I$) | 0, k = k + Math.imul(o, M$) | 0;
        var Kq = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (Kq >>> 26) | 0, Kq &= 67108863, A = Math.imul(Z$, k$), v = Math.imul(Z$, G$), v = v + Math.imul(A$, k$) | 0, k = Math.imul(A$, G$), A = A + Math.imul(z$, R$) | 0, v = v + Math.imul(z$, u$) | 0, v = v + Math.imul(j$, R$) | 0, k = k + Math.imul(j$, u$) | 0, A = A + Math.imul(B, I$) | 0, v = v + Math.imul(B, M$) | 0, v = v + Math.imul(F, I$) | 0, k = k + Math.imul(F, M$) | 0;
        var _q = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (_q >>> 26) | 0, _q &= 67108863, A = Math.imul(Z$, R$), v = Math.imul(Z$, u$), v = v + Math.imul(A$, R$) | 0, k = Math.imul(A$, u$), A = A + Math.imul(z$, I$) | 0, v = v + Math.imul(z$, M$) | 0, v = v + Math.imul(j$, I$) | 0, k = k + Math.imul(j$, M$) | 0;
        var Pq = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (Pq >>> 26) | 0, Pq &= 67108863, A = Math.imul(Z$, I$), v = Math.imul(Z$, M$), v = v + Math.imul(A$, I$) | 0, k = Math.imul(A$, M$);
        var Oq = (S + A | 0) + ((v & 8191) << 13) | 0;
        if (S = (k + (v >>> 13) | 0) + (Oq >>> 26) | 0, Oq &= 67108863, G[0] = p6, G[1] = H6, G[2] = v6, G[3] = C6, G[4] = S6, G[5] = t6, G[6] = B6, G[7] = U6, G[8] = F6, G[9] = a6, G[10] = Q6, G[11] = e6, G[12] = s6, G[13] = $q, G[14] = qq, G[15] = Kq, G[16] = _q, G[17] = Pq, G[18] = Oq, S !== 0) G[19] = S, Z.length++;
        return Z;
      }, "h");
      if (!Math.imul) h = E;
      function I(j, H, Z) {
        Z.negative = H.negative ^ j.negative, Z.length = j.length + H.length;
        var W = 0, w = 0;
        for (var G = 0; G < Z.length - 1; G++) {
          var S = w;
          w = 0;
          var A = W & 67108863, v = Math.min(G, H.length - 1);
          for (var k = Math.max(0, G - j.length + 1); k <= v; k++) {
            var R = G - k, C = j.words[R] | 0, L = H.words[k] | 0, x = C * L, l = x & 67108863;
            S = S + (x / 67108864 | 0) | 0, l = l + A | 0, A = l & 67108863, S = S + (l >>> 26) | 0, w += S >>> 26, S &= 67108863;
          }
          Z.words[G] = A, W = S, S = w;
        }
        if (W !== 0) Z.words[G] = W;
        else Z.length--;
        return Z.strip();
      }
      __name(I, "I");
      function D(j, H, Z) {
        var W = new g();
        return W.mulp(j, H, Z);
      }
      __name(D, "D");
      O.prototype.mulTo = function(j, H) {
        var Z, W = this.length + j.length;
        if (this.length === 10 && j.length === 10) Z = h(this, j, H);
        else if (W < 63) Z = E(this, j, H);
        else if (W < 1024) Z = I(this, j, H);
        else Z = D(this, j, H);
        return Z;
      };
      function g(j, H) {
        this.x = j, this.y = H;
      }
      __name(g, "g");
      g.prototype.makeRBT = function(j) {
        var H = Array(j), Z = O.prototype._countBits(j) - 1;
        for (var W = 0; W < j; W++) H[W] = this.revBin(W, Z, j);
        return H;
      }, g.prototype.revBin = function(j, H, Z) {
        if (j === 0 || j === Z - 1) return j;
        var W = 0;
        for (var w = 0; w < H; w++) W |= (j & 1) << H - w - 1, j >>= 1;
        return W;
      }, g.prototype.permute = function(j, H, Z, W, w, G) {
        for (var S = 0; S < G; S++) W[S] = H[j[S]], w[S] = Z[j[S]];
      }, g.prototype.transform = function(j, H, Z, W, w, G) {
        this.permute(G, j, H, Z, W, w);
        for (var S = 1; S < w; S <<= 1) {
          var A = S << 1, v = Math.cos(2 * Math.PI / A), k = Math.sin(2 * Math.PI / A);
          for (var R = 0; R < w; R += A) {
            var C = v, L = k;
            for (var x = 0; x < S; x++) {
              var l = Z[R + x], a = W[R + x], f$ = Z[R + x + S], $$ = W[R + x + S], t = C * f$ - L * $$;
              if ($$ = C * $$ + L * f$, f$ = t, Z[R + x] = l + f$, W[R + x] = a + $$, Z[R + x + S] = l - f$, W[R + x + S] = a - $$, x !== A) t = v * C - k * L, L = v * L + k * C, C = t;
            }
          }
        }
      }, g.prototype.guessLen13b = function(j, H) {
        var Z = Math.max(H, j) | 1, W = Z & 1, w = 0;
        for (Z = Z / 2 | 0; Z; Z = Z >>> 1) w++;
        return 1 << w + 1 + W;
      }, g.prototype.conjugate = function(j, H, Z) {
        if (Z <= 1) return;
        for (var W = 0; W < Z / 2; W++) {
          var w = j[W];
          j[W] = j[Z - W - 1], j[Z - W - 1] = w, w = H[W], H[W] = -H[Z - W - 1], H[Z - W - 1] = -w;
        }
      }, g.prototype.normalize13b = function(j, H) {
        var Z = 0;
        for (var W = 0; W < H / 2; W++) {
          var w = Math.round(j[2 * W + 1] / H) * 8192 + Math.round(j[2 * W] / H) + Z;
          if (j[W] = w & 67108863, w < 67108864) Z = 0;
          else Z = w / 67108864 | 0;
        }
        return j;
      }, g.prototype.convert13b = function(j, H, Z, W) {
        var w = 0;
        for (var G = 0; G < H; G++) w = w + (j[G] | 0), Z[2 * G] = w & 8191, w = w >>> 13, Z[2 * G + 1] = w & 8191, w = w >>> 13;
        for (G = 2 * H; G < W; ++G) Z[G] = 0;
        _(w === 0), _((w & -8192) === 0);
      }, g.prototype.stub = function(j) {
        var H = Array(j);
        for (var Z = 0; Z < j; Z++) H[Z] = 0;
        return H;
      }, g.prototype.mulp = function(j, H, Z) {
        var W = 2 * this.guessLen13b(j.length, H.length), w = this.makeRBT(W), G = this.stub(W), S = Array(W), A = Array(W), v = Array(W), k = Array(W), R = Array(W), C = Array(W), L = Z.words;
        L.length = W, this.convert13b(j.words, j.length, S, W), this.convert13b(H.words, H.length, k, W), this.transform(S, G, A, v, W, w), this.transform(k, G, R, C, W, w);
        for (var x = 0; x < W; x++) {
          var l = A[x] * R[x] - v[x] * C[x];
          v[x] = A[x] * C[x] + v[x] * R[x], A[x] = l;
        }
        return this.conjugate(A, v, W), this.transform(A, v, L, G, W, w), this.conjugate(L, G, W), this.normalize13b(L, W), Z.negative = j.negative ^ H.negative, Z.length = j.length + H.length, Z.strip();
      }, O.prototype.mul = function(j) {
        var H = new O(null);
        return H.words = Array(this.length + j.length), this.mulTo(j, H);
      }, O.prototype.mulf = function(j) {
        var H = new O(null);
        return H.words = Array(this.length + j.length), D(this, j, H);
      }, O.prototype.imul = function(j) {
        return this.clone().mulTo(j, this);
      }, O.prototype.imuln = function(j) {
        _(typeof j === "number"), _(j < 67108864);
        var H = 0;
        for (var Z = 0; Z < this.length; Z++) {
          var W = (this.words[Z] | 0) * j, w = (W & 67108863) + (H & 67108863);
          H >>= 26, H += W / 67108864 | 0, H += w >>> 26, this.words[Z] = w & 67108863;
        }
        if (H !== 0) this.words[Z] = H, this.length++;
        return this.length = j === 0 ? 1 : this.length, this;
      }, O.prototype.muln = function(j) {
        return this.clone().imuln(j);
      }, O.prototype.sqr = function() {
        return this.mul(this);
      }, O.prototype.isqr = function() {
        return this.imul(this.clone());
      }, O.prototype.pow = function(j) {
        var H = N(j);
        if (H.length === 0) return new O(1);
        var Z = this;
        for (var W = 0; W < H.length; W++, Z = Z.sqr()) if (H[W] !== 0) break;
        if (++W < H.length) for (var w = Z.sqr(); W < H.length; W++, w = w.sqr()) {
          if (H[W] === 0) continue;
          Z = Z.mul(w);
        }
        return Z;
      }, O.prototype.iushln = function(j) {
        _(typeof j === "number" && j >= 0);
        var H = j % 26, Z = (j - H) / 26, W = 67108863 >>> 26 - H << 26 - H, w;
        if (H !== 0) {
          var G = 0;
          for (w = 0; w < this.length; w++) {
            var S = this.words[w] & W, A = (this.words[w] | 0) - S << H;
            this.words[w] = A | G, G = S >>> 26 - H;
          }
          if (G) this.words[w] = G, this.length++;
        }
        if (Z !== 0) {
          for (w = this.length - 1; w >= 0; w--) this.words[w + Z] = this.words[w];
          for (w = 0; w < Z; w++) this.words[w] = 0;
          this.length += Z;
        }
        return this.strip();
      }, O.prototype.ishln = function(j) {
        return _(this.negative === 0), this.iushln(j);
      }, O.prototype.iushrn = function(j, H, Z) {
        _(typeof j === "number" && j >= 0);
        var W;
        if (H) W = (H - H % 26) / 26;
        else W = 0;
        var w = j % 26, G = Math.min((j - w) / 26, this.length), S = 67108863 ^ 67108863 >>> w << w, A = Z;
        if (W -= G, W = Math.max(0, W), A) {
          for (var v = 0; v < G; v++) A.words[v] = this.words[v];
          A.length = G;
        }
        if (G === 0) ;
        else if (this.length > G) {
          this.length -= G;
          for (v = 0; v < this.length; v++) this.words[v] = this.words[v + G];
        } else this.words[0] = 0, this.length = 1;
        var k = 0;
        for (v = this.length - 1; v >= 0 && (k !== 0 || v >= W); v--) {
          var R = this.words[v] | 0;
          this.words[v] = k << 26 - w | R >>> w, k = R & S;
        }
        if (A && k !== 0) A.words[A.length++] = k;
        if (this.length === 0) this.words[0] = 0, this.length = 1;
        return this.strip();
      }, O.prototype.ishrn = function(j, H, Z) {
        return _(this.negative === 0), this.iushrn(j, H, Z);
      }, O.prototype.shln = function(j) {
        return this.clone().ishln(j);
      }, O.prototype.ushln = function(j) {
        return this.clone().iushln(j);
      }, O.prototype.shrn = function(j) {
        return this.clone().ishrn(j);
      }, O.prototype.ushrn = function(j) {
        return this.clone().iushrn(j);
      }, O.prototype.testn = function(j) {
        _(typeof j === "number" && j >= 0);
        var H = j % 26, Z = (j - H) / 26, W = 1 << H;
        if (this.length <= Z) return false;
        var w = this.words[Z];
        return !!(w & W);
      }, O.prototype.imaskn = function(j) {
        _(typeof j === "number" && j >= 0);
        var H = j % 26, Z = (j - H) / 26;
        if (_(this.negative === 0, "imaskn works only with positive numbers"), this.length <= Z) return this;
        if (H !== 0) Z++;
        if (this.length = Math.min(Z, this.length), H !== 0) {
          var W = 67108863 ^ 67108863 >>> H << H;
          this.words[this.length - 1] &= W;
        }
        return this.strip();
      }, O.prototype.maskn = function(j) {
        return this.clone().imaskn(j);
      }, O.prototype.iaddn = function(j) {
        if (_(typeof j === "number"), _(j < 67108864), j < 0) return this.isubn(-j);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) < j) return this.words[0] = j - (this.words[0] | 0), this.negative = 0, this;
          return this.negative = 0, this.isubn(j), this.negative = 1, this;
        }
        return this._iaddn(j);
      }, O.prototype._iaddn = function(j) {
        this.words[0] += j;
        for (var H = 0; H < this.length && this.words[H] >= 67108864; H++) if (this.words[H] -= 67108864, H === this.length - 1) this.words[H + 1] = 1;
        else this.words[H + 1]++;
        return this.length = Math.max(this.length, H + 1), this;
      }, O.prototype.isubn = function(j) {
        if (_(typeof j === "number"), _(j < 67108864), j < 0) return this.iaddn(-j);
        if (this.negative !== 0) return this.negative = 0, this.iaddn(j), this.negative = 1, this;
        if (this.words[0] -= j, this.length === 1 && this.words[0] < 0) this.words[0] = -this.words[0], this.negative = 1;
        else for (var H = 0; H < this.length && this.words[H] < 0; H++) this.words[H] += 67108864, this.words[H + 1] -= 1;
        return this.strip();
      }, O.prototype.addn = function(j) {
        return this.clone().iaddn(j);
      }, O.prototype.subn = function(j) {
        return this.clone().isubn(j);
      }, O.prototype.iabs = function() {
        return this.negative = 0, this;
      }, O.prototype.abs = function() {
        return this.clone().iabs();
      }, O.prototype._ishlnsubmul = function(j, H, Z) {
        var W = j.length + Z, w;
        this._expand(W);
        var G, S = 0;
        for (w = 0; w < j.length; w++) {
          G = (this.words[w + Z] | 0) + S;
          var A = (j.words[w] | 0) * H;
          G -= A & 67108863, S = (G >> 26) - (A / 67108864 | 0), this.words[w + Z] = G & 67108863;
        }
        for (; w < this.length - Z; w++) G = (this.words[w + Z] | 0) + S, S = G >> 26, this.words[w + Z] = G & 67108863;
        if (S === 0) return this.strip();
        _(S === -1), S = 0;
        for (w = 0; w < this.length; w++) G = -(this.words[w] | 0) + S, S = G >> 26, this.words[w] = G & 67108863;
        return this.negative = 1, this.strip();
      }, O.prototype._wordDiv = function(j, H) {
        var Z = this.length - j.length, W = this.clone(), w = j, G = w.words[w.length - 1] | 0, S = this._countBits(G);
        if (Z = 26 - S, Z !== 0) w = w.ushln(Z), W.iushln(Z), G = w.words[w.length - 1] | 0;
        var A = W.length - w.length, v;
        if (H !== "mod") {
          v = new O(null), v.length = A + 1, v.words = Array(v.length);
          for (var k = 0; k < v.length; k++) v.words[k] = 0;
        }
        var R = W.clone()._ishlnsubmul(w, 1, A);
        if (R.negative === 0) {
          if (W = R, v) v.words[A] = 1;
        }
        for (var C = A - 1; C >= 0; C--) {
          var L = (W.words[w.length + C] | 0) * 67108864 + (W.words[w.length + C - 1] | 0);
          L = Math.min(L / G | 0, 67108863), W._ishlnsubmul(w, L, C);
          while (W.negative !== 0) if (L--, W.negative = 0, W._ishlnsubmul(w, 1, C), !W.isZero()) W.negative ^= 1;
          if (v) v.words[C] = L;
        }
        if (v) v.strip();
        if (W.strip(), H !== "div" && Z !== 0) W.iushrn(Z);
        return { div: v || null, mod: W };
      }, O.prototype.divmod = function(j, H, Z) {
        if (_(!j.isZero()), this.isZero()) return { div: new O(0), mod: new O(0) };
        var W, w, G;
        if (this.negative !== 0 && j.negative === 0) {
          if (G = this.neg().divmod(j, H), H !== "mod") W = G.div.neg();
          if (H !== "div") {
            if (w = G.mod.neg(), Z && w.negative !== 0) w.iadd(j);
          }
          return { div: W, mod: w };
        }
        if (this.negative === 0 && j.negative !== 0) {
          if (G = this.divmod(j.neg(), H), H !== "mod") W = G.div.neg();
          return { div: W, mod: G.mod };
        }
        if ((this.negative & j.negative) !== 0) {
          if (G = this.neg().divmod(j.neg(), H), H !== "div") {
            if (w = G.mod.neg(), Z && w.negative !== 0) w.isub(j);
          }
          return { div: G.div, mod: w };
        }
        if (j.length > this.length || this.cmp(j) < 0) return { div: new O(0), mod: this };
        if (j.length === 1) {
          if (H === "div") return { div: this.divn(j.words[0]), mod: null };
          if (H === "mod") return { div: null, mod: new O(this.modn(j.words[0])) };
          return { div: this.divn(j.words[0]), mod: new O(this.modn(j.words[0])) };
        }
        return this._wordDiv(j, H);
      }, O.prototype.div = function(j) {
        return this.divmod(j, "div", false).div;
      }, O.prototype.mod = function(j) {
        return this.divmod(j, "mod", false).mod;
      }, O.prototype.umod = function(j) {
        return this.divmod(j, "mod", true).mod;
      }, O.prototype.divRound = function(j) {
        var H = this.divmod(j);
        if (H.mod.isZero()) return H.div;
        var Z = H.div.negative !== 0 ? H.mod.isub(j) : H.mod, W = j.ushrn(1), w = j.andln(1), G = Z.cmp(W);
        if (G < 0 || w === 1 && G === 0) return H.div;
        return H.div.negative !== 0 ? H.div.isubn(1) : H.div.iaddn(1);
      }, O.prototype.modn = function(j) {
        _(j <= 67108863);
        var H = 67108864 % j, Z = 0;
        for (var W = this.length - 1; W >= 0; W--) Z = (H * Z + (this.words[W] | 0)) % j;
        return Z;
      }, O.prototype.idivn = function(j) {
        _(j <= 67108863);
        var H = 0;
        for (var Z = this.length - 1; Z >= 0; Z--) {
          var W = (this.words[Z] | 0) + H * 67108864;
          this.words[Z] = W / j | 0, H = W % j;
        }
        return this.strip();
      }, O.prototype.divn = function(j) {
        return this.clone().idivn(j);
      }, O.prototype.egcd = function(j) {
        _(j.negative === 0), _(!j.isZero());
        var H = this, Z = j.clone();
        if (H.negative !== 0) H = H.umod(j);
        else H = H.clone();
        var W = new O(1), w = new O(0), G = new O(0), S = new O(1), A = 0;
        while (H.isEven() && Z.isEven()) H.iushrn(1), Z.iushrn(1), ++A;
        var v = Z.clone(), k = H.clone();
        while (!H.isZero()) {
          for (var R = 0, C = 1; (H.words[0] & C) === 0 && R < 26; ++R, C <<= 1) ;
          if (R > 0) {
            H.iushrn(R);
            while (R-- > 0) {
              if (W.isOdd() || w.isOdd()) W.iadd(v), w.isub(k);
              W.iushrn(1), w.iushrn(1);
            }
          }
          for (var L = 0, x = 1; (Z.words[0] & x) === 0 && L < 26; ++L, x <<= 1) ;
          if (L > 0) {
            Z.iushrn(L);
            while (L-- > 0) {
              if (G.isOdd() || S.isOdd()) G.iadd(v), S.isub(k);
              G.iushrn(1), S.iushrn(1);
            }
          }
          if (H.cmp(Z) >= 0) H.isub(Z), W.isub(G), w.isub(S);
          else Z.isub(H), G.isub(W), S.isub(w);
        }
        return { a: G, b: S, gcd: Z.iushln(A) };
      }, O.prototype._invmp = function(j) {
        _(j.negative === 0), _(!j.isZero());
        var H = this, Z = j.clone();
        if (H.negative !== 0) H = H.umod(j);
        else H = H.clone();
        var W = new O(1), w = new O(0), G = Z.clone();
        while (H.cmpn(1) > 0 && Z.cmpn(1) > 0) {
          for (var S = 0, A = 1; (H.words[0] & A) === 0 && S < 26; ++S, A <<= 1) ;
          if (S > 0) {
            H.iushrn(S);
            while (S-- > 0) {
              if (W.isOdd()) W.iadd(G);
              W.iushrn(1);
            }
          }
          for (var v = 0, k = 1; (Z.words[0] & k) === 0 && v < 26; ++v, k <<= 1) ;
          if (v > 0) {
            Z.iushrn(v);
            while (v-- > 0) {
              if (w.isOdd()) w.iadd(G);
              w.iushrn(1);
            }
          }
          if (H.cmp(Z) >= 0) H.isub(Z), W.isub(w);
          else Z.isub(H), w.isub(W);
        }
        var R;
        if (H.cmpn(1) === 0) R = W;
        else R = w;
        if (R.cmpn(0) < 0) R.iadd(j);
        return R;
      }, O.prototype.gcd = function(j) {
        if (this.isZero()) return j.abs();
        if (j.isZero()) return this.abs();
        var H = this.clone(), Z = j.clone();
        H.negative = 0, Z.negative = 0;
        for (var W = 0; H.isEven() && Z.isEven(); W++) H.iushrn(1), Z.iushrn(1);
        do {
          while (H.isEven()) H.iushrn(1);
          while (Z.isEven()) Z.iushrn(1);
          var w = H.cmp(Z);
          if (w < 0) {
            var G = H;
            H = Z, Z = G;
          } else if (w === 0 || Z.cmpn(1) === 0) break;
          H.isub(Z);
        } while (true);
        return Z.iushln(W);
      }, O.prototype.invm = function(j) {
        return this.egcd(j).a.umod(j);
      }, O.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, O.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, O.prototype.andln = function(j) {
        return this.words[0] & j;
      }, O.prototype.bincn = function(j) {
        _(typeof j === "number");
        var H = j % 26, Z = (j - H) / 26, W = 1 << H;
        if (this.length <= Z) return this._expand(Z + 1), this.words[Z] |= W, this;
        var w = W;
        for (var G = Z; w !== 0 && G < this.length; G++) {
          var S = this.words[G] | 0;
          S += w, w = S >>> 26, S &= 67108863, this.words[G] = S;
        }
        if (w !== 0) this.words[G] = w, this.length++;
        return this;
      }, O.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, O.prototype.cmpn = function(j) {
        var H = j < 0;
        if (this.negative !== 0 && !H) return -1;
        if (this.negative === 0 && H) return 1;
        this.strip();
        var Z;
        if (this.length > 1) Z = 1;
        else {
          if (H) j = -j;
          _(j <= 67108863, "Number is too big");
          var W = this.words[0] | 0;
          Z = W === j ? 0 : W < j ? -1 : 1;
        }
        if (this.negative !== 0) return -Z | 0;
        return Z;
      }, O.prototype.cmp = function(j) {
        if (this.negative !== 0 && j.negative === 0) return -1;
        if (this.negative === 0 && j.negative !== 0) return 1;
        var H = this.ucmp(j);
        if (this.negative !== 0) return -H | 0;
        return H;
      }, O.prototype.ucmp = function(j) {
        if (this.length > j.length) return 1;
        if (this.length < j.length) return -1;
        var H = 0;
        for (var Z = this.length - 1; Z >= 0; Z--) {
          var W = this.words[Z] | 0, w = j.words[Z] | 0;
          if (W === w) continue;
          if (W < w) H = -1;
          else if (W > w) H = 1;
          break;
        }
        return H;
      }, O.prototype.gtn = function(j) {
        return this.cmpn(j) === 1;
      }, O.prototype.gt = function(j) {
        return this.cmp(j) === 1;
      }, O.prototype.gten = function(j) {
        return this.cmpn(j) >= 0;
      }, O.prototype.gte = function(j) {
        return this.cmp(j) >= 0;
      }, O.prototype.ltn = function(j) {
        return this.cmpn(j) === -1;
      }, O.prototype.lt = function(j) {
        return this.cmp(j) === -1;
      }, O.prototype.lten = function(j) {
        return this.cmpn(j) <= 0;
      }, O.prototype.lte = function(j) {
        return this.cmp(j) <= 0;
      }, O.prototype.eqn = function(j) {
        return this.cmpn(j) === 0;
      }, O.prototype.eq = function(j) {
        return this.cmp(j) === 0;
      }, O.red = function(j) {
        return new c(j);
      }, O.prototype.toRed = function(j) {
        return _(!this.red, "Already a number in reduction context"), _(this.negative === 0, "red works only with positives"), j.convertTo(this)._forceRed(j);
      }, O.prototype.fromRed = function() {
        return _(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, O.prototype._forceRed = function(j) {
        return this.red = j, this;
      }, O.prototype.forceRed = function(j) {
        return _(!this.red, "Already a number in reduction context"), this._forceRed(j);
      }, O.prototype.redAdd = function(j) {
        return _(this.red, "redAdd works only with red numbers"), this.red.add(this, j);
      }, O.prototype.redIAdd = function(j) {
        return _(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, j);
      }, O.prototype.redSub = function(j) {
        return _(this.red, "redSub works only with red numbers"), this.red.sub(this, j);
      }, O.prototype.redISub = function(j) {
        return _(this.red, "redISub works only with red numbers"), this.red.isub(this, j);
      }, O.prototype.redShl = function(j) {
        return _(this.red, "redShl works only with red numbers"), this.red.shl(this, j);
      }, O.prototype.redMul = function(j) {
        return _(this.red, "redMul works only with red numbers"), this.red._verify2(this, j), this.red.mul(this, j);
      }, O.prototype.redIMul = function(j) {
        return _(this.red, "redMul works only with red numbers"), this.red._verify2(this, j), this.red.imul(this, j);
      }, O.prototype.redSqr = function() {
        return _(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, O.prototype.redISqr = function() {
        return _(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, O.prototype.redSqrt = function() {
        return _(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, O.prototype.redInvm = function() {
        return _(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, O.prototype.redNeg = function() {
        return _(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, O.prototype.redPow = function(j) {
        return _(this.red && !j.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, j);
      };
      var b = { k256: null, p224: null, p192: null, p25519: null };
      function y(j, H) {
        this.name = j, this.p = new O(H, 16), this.n = this.p.bitLength(), this.k = new O(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      __name(y, "y");
      y.prototype._tmp = function() {
        var j = new O(null);
        return j.words = Array(Math.ceil(this.n / 13)), j;
      }, y.prototype.ireduce = function(j) {
        var H = j, Z;
        do
          this.split(H, this.tmp), H = this.imulK(H), H = H.iadd(this.tmp), Z = H.bitLength();
        while (Z > this.n);
        var W = Z < this.n ? -1 : H.ucmp(this.p);
        if (W === 0) H.words[0] = 0, H.length = 1;
        else if (W > 0) H.isub(this.p);
        else if (H.strip !== void 0) H.strip();
        else H._strip();
        return H;
      }, y.prototype.split = function(j, H) {
        j.iushrn(this.n, 0, H);
      }, y.prototype.imulK = function(j) {
        return j.imul(this.k);
      };
      function p() {
        y.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
      }
      __name(p, "p");
      Y(p, y), p.prototype.split = function(j, H) {
        var Z = 4194303, W = Math.min(j.length, 9);
        for (var w = 0; w < W; w++) H.words[w] = j.words[w];
        if (H.length = W, j.length <= 9) {
          j.words[0] = 0, j.length = 1;
          return;
        }
        var G = j.words[9];
        H.words[H.length++] = G & Z;
        for (w = 10; w < j.length; w++) {
          var S = j.words[w] | 0;
          j.words[w - 10] = (S & Z) << 4 | G >>> 22, G = S;
        }
        if (G >>>= 22, j.words[w - 10] = G, G === 0 && j.length > 10) j.length -= 10;
        else j.length -= 9;
      }, p.prototype.imulK = function(j) {
        j.words[j.length] = 0, j.words[j.length + 1] = 0, j.length += 2;
        var H = 0;
        for (var Z = 0; Z < j.length; Z++) {
          var W = j.words[Z] | 0;
          H += W * 977, j.words[Z] = H & 67108863, H = W * 64 + (H / 67108864 | 0);
        }
        if (j.words[j.length - 1] === 0) {
          if (j.length--, j.words[j.length - 1] === 0) j.length--;
        }
        return j;
      };
      function n() {
        y.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
      }
      __name(n, "n");
      Y(n, y);
      function s() {
        y.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
      }
      __name(s, "s");
      Y(s, y);
      function q$() {
        y.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
      }
      __name(q$, "q$");
      Y(q$, y), q$.prototype.imulK = function(j) {
        var H = 0;
        for (var Z = 0; Z < j.length; Z++) {
          var W = (j.words[Z] | 0) * 19 + H, w = W & 67108863;
          W >>>= 26, j.words[Z] = w, H = W;
        }
        if (H !== 0) j.words[j.length++] = H;
        return j;
      }, O._prime = function(j) {
        if (b[j]) return b[j];
        var H;
        if (j === "k256") H = new p();
        else if (j === "p224") H = new n();
        else if (j === "p192") H = new s();
        else if (j === "p25519") H = new q$();
        else throw Error("Unknown prime " + j);
        return b[j] = H, H;
      };
      function c(j) {
        if (typeof j === "string") {
          var H = O._prime(j);
          this.m = H.p, this.prime = H;
        } else _(j.gtn(1), "modulus must be greater than 1"), this.m = j, this.prime = null;
      }
      __name(c, "c");
      c.prototype._verify1 = function(j) {
        _(j.negative === 0, "red works only with positives"), _(j.red, "red works only with red numbers");
      }, c.prototype._verify2 = function(j, H) {
        _((j.negative | H.negative) === 0, "red works only with positives"), _(j.red && j.red === H.red, "red works only with red numbers");
      }, c.prototype.imod = function(j) {
        if (this.prime) return this.prime.ireduce(j)._forceRed(this);
        return j.umod(this.m)._forceRed(this);
      }, c.prototype.neg = function(j) {
        if (j.isZero()) return j.clone();
        return this.m.sub(j)._forceRed(this);
      }, c.prototype.add = function(j, H) {
        this._verify2(j, H);
        var Z = j.add(H);
        if (Z.cmp(this.m) >= 0) Z.isub(this.m);
        return Z._forceRed(this);
      }, c.prototype.iadd = function(j, H) {
        this._verify2(j, H);
        var Z = j.iadd(H);
        if (Z.cmp(this.m) >= 0) Z.isub(this.m);
        return Z;
      }, c.prototype.sub = function(j, H) {
        this._verify2(j, H);
        var Z = j.sub(H);
        if (Z.cmpn(0) < 0) Z.iadd(this.m);
        return Z._forceRed(this);
      }, c.prototype.isub = function(j, H) {
        this._verify2(j, H);
        var Z = j.isub(H);
        if (Z.cmpn(0) < 0) Z.iadd(this.m);
        return Z;
      }, c.prototype.shl = function(j, H) {
        return this._verify1(j), this.imod(j.ushln(H));
      }, c.prototype.imul = function(j, H) {
        return this._verify2(j, H), this.imod(j.imul(H));
      }, c.prototype.mul = function(j, H) {
        return this._verify2(j, H), this.imod(j.mul(H));
      }, c.prototype.isqr = function(j) {
        return this.imul(j, j.clone());
      }, c.prototype.sqr = function(j) {
        return this.mul(j, j);
      }, c.prototype.sqrt = function(j) {
        if (j.isZero()) return j.clone();
        var H = this.m.andln(3);
        if (_(H % 2 === 1), H === 3) {
          var Z = this.m.add(new O(1)).iushrn(2);
          return this.pow(j, Z);
        }
        var W = this.m.subn(1), w = 0;
        while (!W.isZero() && W.andln(1) === 0) w++, W.iushrn(1);
        _(!W.isZero());
        var G = new O(1).toRed(this), S = G.redNeg(), A = this.m.subn(1).iushrn(1), v = this.m.bitLength();
        v = new O(2 * v * v).toRed(this);
        while (this.pow(v, A).cmp(S) !== 0) v.redIAdd(S);
        var k = this.pow(v, W), R = this.pow(j, W.addn(1).iushrn(1)), C = this.pow(j, W), L = w;
        while (C.cmp(G) !== 0) {
          var x = C;
          for (var l = 0; x.cmp(G) !== 0; l++) x = x.redSqr();
          _(l < L);
          var a = this.pow(k, new O(1).iushln(L - l - 1));
          R = R.redMul(a), k = a.redSqr(), C = C.redMul(k), L = l;
        }
        return R;
      }, c.prototype.invm = function(j) {
        var H = j._invmp(this.m);
        if (H.negative !== 0) return H.negative = 0, this.imod(H).redNeg();
        else return this.imod(H);
      }, c.prototype.pow = function(j, H) {
        if (H.isZero()) return new O(1).toRed(this);
        if (H.cmpn(1) === 0) return j.clone();
        var Z = 4, W = Array(1 << Z);
        W[0] = new O(1).toRed(this), W[1] = j;
        for (var w = 2; w < W.length; w++) W[w] = this.mul(W[w - 1], j);
        var G = W[0], S = 0, A = 0, v = H.bitLength() % 26;
        if (v === 0) v = 26;
        for (w = H.length - 1; w >= 0; w--) {
          var k = H.words[w];
          for (var R = v - 1; R >= 0; R--) {
            var C = k >> R & 1;
            if (G !== W[0]) G = this.sqr(G);
            if (C === 0 && S === 0) {
              A = 0;
              continue;
            }
            if (S <<= 1, S |= C, A++, A !== Z && (w !== 0 || R !== 0)) continue;
            G = this.mul(G, W[S]), A = 0, S = 0;
          }
          v = 26;
        }
        return G;
      }, c.prototype.convertTo = function(j) {
        var H = j.umod(this.m);
        return H === j ? H.clone() : H;
      }, c.prototype.convertFrom = function(j) {
        var H = j.clone();
        return H.red = null, H;
      }, O.mont = function(j) {
        return new U(j);
      };
      function U(j) {
        if (c.call(this, j), this.shift = this.m.bitLength(), this.shift % 26 !== 0) this.shift += 26 - this.shift % 26;
        this.r = new O(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      __name(U, "U");
      Y(U, c), U.prototype.convertTo = function(j) {
        return this.imod(j.ushln(this.shift));
      }, U.prototype.convertFrom = function(j) {
        var H = this.imod(j.mul(this.rinv));
        return H.red = null, H;
      }, U.prototype.imul = function(j, H) {
        if (j.isZero() || H.isZero()) return j.words[0] = 0, j.length = 1, j;
        var Z = j.imul(H), W = Z.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), w = Z.isub(W).iushrn(this.shift), G = w;
        if (w.cmp(this.m) >= 0) G = w.isub(this.m);
        else if (w.cmpn(0) < 0) G = w.iadd(this.m);
        return G._forceRed(this);
      }, U.prototype.mul = function(j, H) {
        if (j.isZero() || H.isZero()) return new O(0)._forceRed(this);
        var Z = j.mul(H), W = Z.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), w = Z.isub(W).iushrn(this.shift), G = w;
        if (w.cmp(this.m) >= 0) G = w.isub(this.m);
        else if (w.cmpn(0) < 0) G = w.iadd(this.m);
        return G._forceRed(this);
      }, U.prototype.invm = function(j) {
        var H = this.imod(j._invmp(this.m).mul(this.r2));
        return H._forceRed(this);
      };
    })(typeof q > "u" || q, $);
  }), S0 = r$(($, q) => {
    var K = BH(), P = q8().Buffer;
    function _(Y, O) {
      return P.from(Y.toRed(K.mont(O.modulus)).redPow(new K(O.publicExponent)).fromRed().toArray());
    }
    __name(_, "_");
    q.exports = _;
  }), lo = r$(($, q) => {
    (function(K, P) {
      function _(W, w) {
        if (!W) throw Error(w || "Assertion failed");
      }
      __name(_, "_");
      function Y(W, w) {
        W.super_ = w;
        var G = /* @__PURE__ */ __name(function() {
        }, "G");
        G.prototype = w.prototype, W.prototype = new G(), W.prototype.constructor = W;
      }
      __name(Y, "Y");
      function O(W, w, G) {
        if (O.isBN(W)) return W;
        if (this.negative = 0, this.words = null, this.length = 0, this.red = null, W !== null) {
          if (w === "le" || w === "be") G = w, w = 10;
          this._init(W || 0, w || 10, G || "be");
        }
      }
      __name(O, "O");
      if (typeof K === "object") K.exports = O;
      else P.BN = O;
      O.BN = O, O.wordSize = 26;
      var z;
      try {
        if (typeof window < "u" && typeof window.Buffer < "u") z = window.Buffer;
        else z = (fq(), J6(wq)).Buffer;
      } catch (W) {
      }
      O.isBN = function(W) {
        if (W instanceof O) return true;
        return W !== null && typeof W === "object" && W.constructor.wordSize === O.wordSize && Array.isArray(W.words);
      }, O.max = function(W, w) {
        if (W.cmp(w) > 0) return W;
        return w;
      }, O.min = function(W, w) {
        if (W.cmp(w) < 0) return W;
        return w;
      }, O.prototype._init = function(W, w, G) {
        if (typeof W === "number") return this._initNumber(W, w, G);
        if (typeof W === "object") return this._initArray(W, w, G);
        if (w === "hex") w = 16;
        _(w === (w | 0) && w >= 2 && w <= 36), W = W.toString().replace(/\s+/g, "");
        var S = 0;
        if (W[0] === "-") S++, this.negative = 1;
        if (S < W.length) {
          if (w === 16) this._parseHex(W, S, G);
          else if (this._parseBase(W, w, S), G === "le") this._initArray(this.toArray(), w, G);
        }
      }, O.prototype._initNumber = function(W, w, G) {
        if (W < 0) this.negative = 1, W = -W;
        if (W < 67108864) this.words = [W & 67108863], this.length = 1;
        else if (W < 4503599627370496) this.words = [W & 67108863, W / 67108864 & 67108863], this.length = 2;
        else _(W < 9007199254740992), this.words = [W & 67108863, W / 67108864 & 67108863, 1], this.length = 3;
        if (G !== "le") return;
        this._initArray(this.toArray(), w, G);
      }, O.prototype._initArray = function(W, w, G) {
        if (_(typeof W.length === "number"), W.length <= 0) return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(W.length / 3), this.words = Array(this.length);
        for (var S = 0; S < this.length; S++) this.words[S] = 0;
        var A, v, k = 0;
        if (G === "be") {
          for (S = W.length - 1, A = 0; S >= 0; S -= 3) if (v = W[S] | W[S - 1] << 8 | W[S - 2] << 16, this.words[A] |= v << k & 67108863, this.words[A + 1] = v >>> 26 - k & 67108863, k += 24, k >= 26) k -= 26, A++;
        } else if (G === "le") {
          for (S = 0, A = 0; S < W.length; S += 3) if (v = W[S] | W[S + 1] << 8 | W[S + 2] << 16, this.words[A] |= v << k & 67108863, this.words[A + 1] = v >>> 26 - k & 67108863, k += 24, k >= 26) k -= 26, A++;
        }
        return this._strip();
      };
      function J(W, w) {
        var G = W.charCodeAt(w);
        if (G >= 48 && G <= 57) return G - 48;
        else if (G >= 65 && G <= 70) return G - 55;
        else if (G >= 97 && G <= 102) return G - 87;
        else _(false, "Invalid character in " + W);
      }
      __name(J, "J");
      function T(W, w, G) {
        var S = J(W, G);
        if (G - 1 >= w) S |= J(W, G - 1) << 4;
        return S;
      }
      __name(T, "T");
      O.prototype._parseHex = function(W, w, G) {
        this.length = Math.ceil((W.length - w) / 6), this.words = Array(this.length);
        for (var S = 0; S < this.length; S++) this.words[S] = 0;
        var A = 0, v = 0, k;
        if (G === "be") for (S = W.length - 1; S >= w; S -= 2) if (k = T(W, w, S) << A, this.words[v] |= k & 67108863, A >= 18) A -= 18, v += 1, this.words[v] |= k >>> 26;
        else A += 8;
        else {
          var R = W.length - w;
          for (S = R % 2 === 0 ? w + 1 : w; S < W.length; S += 2) if (k = T(W, w, S) << A, this.words[v] |= k & 67108863, A >= 18) A -= 18, v += 1, this.words[v] |= k >>> 26;
          else A += 8;
        }
        this._strip();
      };
      function X(W, w, G, S) {
        var A = 0, v = 0, k = Math.min(W.length, G);
        for (var R = w; R < k; R++) {
          var C = W.charCodeAt(R) - 48;
          if (A *= S, C >= 49) v = C - 49 + 10;
          else if (C >= 17) v = C - 17 + 10;
          else v = C;
          _(C >= 0 && v < S, "Invalid character"), A += v;
        }
        return A;
      }
      __name(X, "X");
      O.prototype._parseBase = function(W, w, G) {
        this.words = [0], this.length = 1;
        for (var S = 0, A = 1; A <= 67108863; A *= w) S++;
        S--, A = A / w | 0;
        var v = W.length - G, k = v % S, R = Math.min(v, v - k) + G, C = 0;
        for (var L = G; L < R; L += S) if (C = X(W, L, L + S, w), this.imuln(A), this.words[0] + C < 67108864) this.words[0] += C;
        else this._iaddn(C);
        if (k !== 0) {
          var x = 1;
          C = X(W, L, W.length, w);
          for (L = 0; L < k; L++) x *= w;
          if (this.imuln(x), this.words[0] + C < 67108864) this.words[0] += C;
          else this._iaddn(C);
        }
        this._strip();
      }, O.prototype.copy = function(W) {
        W.words = Array(this.length);
        for (var w = 0; w < this.length; w++) W.words[w] = this.words[w];
        W.length = this.length, W.negative = this.negative, W.red = this.red;
      };
      function f(W, w) {
        W.words = w.words, W.length = w.length, W.negative = w.negative, W.red = w.red;
      }
      __name(f, "f");
      if (O.prototype._move = function(W) {
        f(W, this);
      }, O.prototype.clone = function() {
        var W = new O(null);
        return this.copy(W), W;
      }, O.prototype._expand = function(W) {
        while (this.length < W) this.words[this.length++] = 0;
        return this;
      }, O.prototype._strip = function() {
        while (this.length > 1 && this.words[this.length - 1] === 0) this.length--;
        return this._normSign();
      }, O.prototype._normSign = function() {
        if (this.length === 1 && this.words[0] === 0) this.negative = 0;
        return this;
      }, typeof Symbol < "u" && typeof Symbol.for === "function") try {
        O.prototype[Symbol.for("nodejs.util.inspect.custom")] = V;
      } catch (W) {
        O.prototype.inspect = V;
      }
      else O.prototype.inspect = V;
      function V() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      }
      __name(V, "V");
      var M = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], N = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], E = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
      if (O.prototype.toString = function(W, w) {
        W = W || 10, w = w | 0 || 1;
        var G;
        if (W === 16 || W === "hex") {
          G = "";
          var S = 0, A = 0;
          for (var v = 0; v < this.length; v++) {
            var k = this.words[v], R = ((k << S | A) & 16777215).toString(16);
            if (A = k >>> 24 - S & 16777215, S += 2, S >= 26) S -= 26, v--;
            if (A !== 0 || v !== this.length - 1) G = M[6 - R.length] + R + G;
            else G = R + G;
          }
          if (A !== 0) G = A.toString(16) + G;
          while (G.length % w !== 0) G = "0" + G;
          if (this.negative !== 0) G = "-" + G;
          return G;
        }
        if (W === (W | 0) && W >= 2 && W <= 36) {
          var C = N[W], L = E[W];
          G = "";
          var x = this.clone();
          x.negative = 0;
          while (!x.isZero()) {
            var l = x.modrn(L).toString(W);
            if (x = x.idivn(L), !x.isZero()) G = M[C - l.length] + l + G;
            else G = l + G;
          }
          if (this.isZero()) G = "0" + G;
          while (G.length % w !== 0) G = "0" + G;
          if (this.negative !== 0) G = "-" + G;
          return G;
        }
        _(false, "Base should be between 2 and 36");
      }, O.prototype.toNumber = function() {
        var W = this.words[0];
        if (this.length === 2) W += this.words[1] * 67108864;
        else if (this.length === 3 && this.words[2] === 1) W += 4503599627370496 + this.words[1] * 67108864;
        else if (this.length > 2) _(false, "Number can only safely store up to 53 bits");
        return this.negative !== 0 ? -W : W;
      }, O.prototype.toJSON = function() {
        return this.toString(16, 2);
      }, z) O.prototype.toBuffer = function(W, w) {
        return this.toArrayLike(z, W, w);
      };
      O.prototype.toArray = function(W, w) {
        return this.toArrayLike(Array, W, w);
      };
      var h = /* @__PURE__ */ __name(function(W, w) {
        if (W.allocUnsafe) return W.allocUnsafe(w);
        return new W(w);
      }, "h");
      if (O.prototype.toArrayLike = function(W, w, G) {
        this._strip();
        var S = this.byteLength(), A = G || Math.max(1, S);
        _(S <= A, "byte array longer than desired length"), _(A > 0, "Requested array length <= 0");
        var v = h(W, A), k = w === "le" ? "LE" : "BE";
        return this["_toArrayLike" + k](v, S), v;
      }, O.prototype._toArrayLikeLE = function(W, w) {
        var G = 0, S = 0;
        for (var A = 0, v = 0; A < this.length; A++) {
          var k = this.words[A] << v | S;
          if (W[G++] = k & 255, G < W.length) W[G++] = k >> 8 & 255;
          if (G < W.length) W[G++] = k >> 16 & 255;
          if (v === 6) {
            if (G < W.length) W[G++] = k >> 24 & 255;
            S = 0, v = 0;
          } else S = k >>> 24, v += 2;
        }
        if (G < W.length) {
          W[G++] = S;
          while (G < W.length) W[G++] = 0;
        }
      }, O.prototype._toArrayLikeBE = function(W, w) {
        var G = W.length - 1, S = 0;
        for (var A = 0, v = 0; A < this.length; A++) {
          var k = this.words[A] << v | S;
          if (W[G--] = k & 255, G >= 0) W[G--] = k >> 8 & 255;
          if (G >= 0) W[G--] = k >> 16 & 255;
          if (v === 6) {
            if (G >= 0) W[G--] = k >> 24 & 255;
            S = 0, v = 0;
          } else S = k >>> 24, v += 2;
        }
        if (G >= 0) {
          W[G--] = S;
          while (G >= 0) W[G--] = 0;
        }
      }, Math.clz32) O.prototype._countBits = function(W) {
        return 32 - Math.clz32(W);
      };
      else O.prototype._countBits = function(W) {
        var w = W, G = 0;
        if (w >= 4096) G += 13, w >>>= 13;
        if (w >= 64) G += 7, w >>>= 7;
        if (w >= 8) G += 4, w >>>= 4;
        if (w >= 2) G += 2, w >>>= 2;
        return G + w;
      };
      O.prototype._zeroBits = function(W) {
        if (W === 0) return 26;
        var w = W, G = 0;
        if ((w & 8191) === 0) G += 13, w >>>= 13;
        if ((w & 127) === 0) G += 7, w >>>= 7;
        if ((w & 15) === 0) G += 4, w >>>= 4;
        if ((w & 3) === 0) G += 2, w >>>= 2;
        if ((w & 1) === 0) G++;
        return G;
      }, O.prototype.bitLength = function() {
        var W = this.words[this.length - 1], w = this._countBits(W);
        return (this.length - 1) * 26 + w;
      };
      function I(W) {
        var w = Array(W.bitLength());
        for (var G = 0; G < w.length; G++) {
          var S = G / 26 | 0, A = G % 26;
          w[G] = W.words[S] >>> A & 1;
        }
        return w;
      }
      __name(I, "I");
      O.prototype.zeroBits = function() {
        if (this.isZero()) return 0;
        var W = 0;
        for (var w = 0; w < this.length; w++) {
          var G = this._zeroBits(this.words[w]);
          if (W += G, G !== 26) break;
        }
        return W;
      }, O.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, O.prototype.toTwos = function(W) {
        if (this.negative !== 0) return this.abs().inotn(W).iaddn(1);
        return this.clone();
      }, O.prototype.fromTwos = function(W) {
        if (this.testn(W - 1)) return this.notn(W).iaddn(1).ineg();
        return this.clone();
      }, O.prototype.isNeg = function() {
        return this.negative !== 0;
      }, O.prototype.neg = function() {
        return this.clone().ineg();
      }, O.prototype.ineg = function() {
        if (!this.isZero()) this.negative ^= 1;
        return this;
      }, O.prototype.iuor = function(W) {
        while (this.length < W.length) this.words[this.length++] = 0;
        for (var w = 0; w < W.length; w++) this.words[w] = this.words[w] | W.words[w];
        return this._strip();
      }, O.prototype.ior = function(W) {
        return _((this.negative | W.negative) === 0), this.iuor(W);
      }, O.prototype.or = function(W) {
        if (this.length > W.length) return this.clone().ior(W);
        return W.clone().ior(this);
      }, O.prototype.uor = function(W) {
        if (this.length > W.length) return this.clone().iuor(W);
        return W.clone().iuor(this);
      }, O.prototype.iuand = function(W) {
        var w;
        if (this.length > W.length) w = W;
        else w = this;
        for (var G = 0; G < w.length; G++) this.words[G] = this.words[G] & W.words[G];
        return this.length = w.length, this._strip();
      }, O.prototype.iand = function(W) {
        return _((this.negative | W.negative) === 0), this.iuand(W);
      }, O.prototype.and = function(W) {
        if (this.length > W.length) return this.clone().iand(W);
        return W.clone().iand(this);
      }, O.prototype.uand = function(W) {
        if (this.length > W.length) return this.clone().iuand(W);
        return W.clone().iuand(this);
      }, O.prototype.iuxor = function(W) {
        var w, G;
        if (this.length > W.length) w = this, G = W;
        else w = W, G = this;
        for (var S = 0; S < G.length; S++) this.words[S] = w.words[S] ^ G.words[S];
        if (this !== w) for (; S < w.length; S++) this.words[S] = w.words[S];
        return this.length = w.length, this._strip();
      }, O.prototype.ixor = function(W) {
        return _((this.negative | W.negative) === 0), this.iuxor(W);
      }, O.prototype.xor = function(W) {
        if (this.length > W.length) return this.clone().ixor(W);
        return W.clone().ixor(this);
      }, O.prototype.uxor = function(W) {
        if (this.length > W.length) return this.clone().iuxor(W);
        return W.clone().iuxor(this);
      }, O.prototype.inotn = function(W) {
        _(typeof W === "number" && W >= 0);
        var w = Math.ceil(W / 26) | 0, G = W % 26;
        if (this._expand(w), G > 0) w--;
        for (var S = 0; S < w; S++) this.words[S] = ~this.words[S] & 67108863;
        if (G > 0) this.words[S] = ~this.words[S] & 67108863 >> 26 - G;
        return this._strip();
      }, O.prototype.notn = function(W) {
        return this.clone().inotn(W);
      }, O.prototype.setn = function(W, w) {
        _(typeof W === "number" && W >= 0);
        var G = W / 26 | 0, S = W % 26;
        if (this._expand(G + 1), w) this.words[G] = this.words[G] | 1 << S;
        else this.words[G] = this.words[G] & ~(1 << S);
        return this._strip();
      }, O.prototype.iadd = function(W) {
        var w;
        if (this.negative !== 0 && W.negative === 0) return this.negative = 0, w = this.isub(W), this.negative ^= 1, this._normSign();
        else if (this.negative === 0 && W.negative !== 0) return W.negative = 0, w = this.isub(W), W.negative = 1, w._normSign();
        var G, S;
        if (this.length > W.length) G = this, S = W;
        else G = W, S = this;
        var A = 0;
        for (var v = 0; v < S.length; v++) w = (G.words[v] | 0) + (S.words[v] | 0) + A, this.words[v] = w & 67108863, A = w >>> 26;
        for (; A !== 0 && v < G.length; v++) w = (G.words[v] | 0) + A, this.words[v] = w & 67108863, A = w >>> 26;
        if (this.length = G.length, A !== 0) this.words[this.length] = A, this.length++;
        else if (G !== this) for (; v < G.length; v++) this.words[v] = G.words[v];
        return this;
      }, O.prototype.add = function(W) {
        var w;
        if (W.negative !== 0 && this.negative === 0) return W.negative = 0, w = this.sub(W), W.negative ^= 1, w;
        else if (W.negative === 0 && this.negative !== 0) return this.negative = 0, w = W.sub(this), this.negative = 1, w;
        if (this.length > W.length) return this.clone().iadd(W);
        return W.clone().iadd(this);
      }, O.prototype.isub = function(W) {
        if (W.negative !== 0) {
          W.negative = 0;
          var w = this.iadd(W);
          return W.negative = 1, w._normSign();
        } else if (this.negative !== 0) return this.negative = 0, this.iadd(W), this.negative = 1, this._normSign();
        var G = this.cmp(W);
        if (G === 0) return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var S, A;
        if (G > 0) S = this, A = W;
        else S = W, A = this;
        var v = 0;
        for (var k = 0; k < A.length; k++) w = (S.words[k] | 0) - (A.words[k] | 0) + v, v = w >> 26, this.words[k] = w & 67108863;
        for (; v !== 0 && k < S.length; k++) w = (S.words[k] | 0) + v, v = w >> 26, this.words[k] = w & 67108863;
        if (v === 0 && k < S.length && S !== this) for (; k < S.length; k++) this.words[k] = S.words[k];
        if (this.length = Math.max(this.length, k), S !== this) this.negative = 1;
        return this._strip();
      }, O.prototype.sub = function(W) {
        return this.clone().isub(W);
      };
      function D(W, w, G) {
        G.negative = w.negative ^ W.negative;
        var S = W.length + w.length | 0;
        G.length = S, S = S - 1 | 0;
        var A = W.words[0] | 0, v = w.words[0] | 0, k = A * v, R = k & 67108863, C = k / 67108864 | 0;
        G.words[0] = R;
        for (var L = 1; L < S; L++) {
          var x = C >>> 26, l = C & 67108863, a = Math.min(L, w.length - 1);
          for (var f$ = Math.max(0, L - W.length + 1); f$ <= a; f$++) {
            var $$ = L - f$ | 0;
            A = W.words[$$] | 0, v = w.words[f$] | 0, k = A * v + l, x += k / 67108864 | 0, l = k & 67108863;
          }
          G.words[L] = l | 0, C = x | 0;
        }
        if (C !== 0) G.words[L] = C | 0;
        else G.length--;
        return G._strip();
      }
      __name(D, "D");
      var g = /* @__PURE__ */ __name(function(W, w, G) {
        var S = W.words, A = w.words, v = G.words, k = 0, R, C, L, x = S[0] | 0, l = x & 8191, a = x >>> 13, f$ = S[1] | 0, $$ = f$ & 8191, t = f$ >>> 13, H$ = S[2] | 0, Q = H$ & 8191, v$ = H$ >>> 13, B$ = S[3] | 0, m = B$ & 8191, r = B$ >>> 13, J$ = S[4] | 0, e = J$ & 8191, _$2 = J$ >>> 13, Y$ = S[5] | 0, d = Y$ & 8191, o = Y$ >>> 13, W$ = S[6] | 0, B = W$ & 8191, F = W$ >>> 13, X$ = S[7] | 0, z$ = X$ & 8191, j$ = X$ >>> 13, X6 = S[8] | 0, Z$ = X6 & 8191, A$ = X6 >>> 13, l6 = S[9] | 0, S$ = l6 & 8191, V$ = l6 >>> 13, Mq = A[0] | 0, N$ = Mq & 8191, D$ = Mq >>> 13, Nq = A[1] | 0, L$ = Nq & 8191, C$ = Nq >>> 13, Zq = A[2] | 0, g$ = Zq & 8191, h$ = Zq >>> 13, zq = A[3] | 0, b$ = zq & 8191, y$ = zq >>> 13, Wq = A[4] | 0, E$ = Wq & 8191, u = Wq >>> 13, i = A[5] | 0, K$ = i & 8191, P$ = i >>> 13, i$ = A[6] | 0, k$ = i$ & 8191, G$ = i$ >>> 13, x6 = A[7] | 0, R$ = x6 & 8191, u$ = x6 >>> 13, Xq = A[8] | 0, I$ = Xq & 8191, M$ = Xq >>> 13, p6 = A[9] | 0, H6 = p6 & 8191, v6 = p6 >>> 13;
        G.negative = W.negative ^ w.negative, G.length = 19, R = Math.imul(l, N$), C = Math.imul(l, D$), C = C + Math.imul(a, N$) | 0, L = Math.imul(a, D$);
        var C6 = (k + R | 0) + ((C & 8191) << 13) | 0;
        k = (L + (C >>> 13) | 0) + (C6 >>> 26) | 0, C6 &= 67108863, R = Math.imul($$, N$), C = Math.imul($$, D$), C = C + Math.imul(t, N$) | 0, L = Math.imul(t, D$), R = R + Math.imul(l, L$) | 0, C = C + Math.imul(l, C$) | 0, C = C + Math.imul(a, L$) | 0, L = L + Math.imul(a, C$) | 0;
        var S6 = (k + R | 0) + ((C & 8191) << 13) | 0;
        k = (L + (C >>> 13) | 0) + (S6 >>> 26) | 0, S6 &= 67108863, R = Math.imul(Q, N$), C = Math.imul(Q, D$), C = C + Math.imul(v$, N$) | 0, L = Math.imul(v$, D$), R = R + Math.imul($$, L$) | 0, C = C + Math.imul($$, C$) | 0, C = C + Math.imul(t, L$) | 0, L = L + Math.imul(t, C$) | 0, R = R + Math.imul(l, g$) | 0, C = C + Math.imul(l, h$) | 0, C = C + Math.imul(a, g$) | 0, L = L + Math.imul(a, h$) | 0;
        var t6 = (k + R | 0) + ((C & 8191) << 13) | 0;
        k = (L + (C >>> 13) | 0) + (t6 >>> 26) | 0, t6 &= 67108863, R = Math.imul(m, N$), C = Math.imul(m, D$), C = C + Math.imul(r, N$) | 0, L = Math.imul(r, D$), R = R + Math.imul(Q, L$) | 0, C = C + Math.imul(Q, C$) | 0, C = C + Math.imul(v$, L$) | 0, L = L + Math.imul(v$, C$) | 0, R = R + Math.imul($$, g$) | 0, C = C + Math.imul($$, h$) | 0, C = C + Math.imul(t, g$) | 0, L = L + Math.imul(t, h$) | 0, R = R + Math.imul(l, b$) | 0, C = C + Math.imul(l, y$) | 0, C = C + Math.imul(a, b$) | 0, L = L + Math.imul(a, y$) | 0;
        var B6 = (k + R | 0) + ((C & 8191) << 13) | 0;
        k = (L + (C >>> 13) | 0) + (B6 >>> 26) | 0, B6 &= 67108863, R = Math.imul(e, N$), C = Math.imul(e, D$), C = C + Math.imul(_$2, N$) | 0, L = Math.imul(_$2, D$), R = R + Math.imul(m, L$) | 0, C = C + Math.imul(m, C$) | 0, C = C + Math.imul(r, L$) | 0, L = L + Math.imul(r, C$) | 0, R = R + Math.imul(Q, g$) | 0, C = C + Math.imul(Q, h$) | 0, C = C + Math.imul(v$, g$) | 0, L = L + Math.imul(v$, h$) | 0, R = R + Math.imul($$, b$) | 0, C = C + Math.imul($$, y$) | 0, C = C + Math.imul(t, b$) | 0, L = L + Math.imul(t, y$) | 0, R = R + Math.imul(l, E$) | 0, C = C + Math.imul(l, u) | 0, C = C + Math.imul(a, E$) | 0, L = L + Math.imul(a, u) | 0;
        var U6 = (k + R | 0) + ((C & 8191) << 13) | 0;
        k = (L + (C >>> 13) | 0) + (U6 >>> 26) | 0, U6 &= 67108863, R = Math.imul(d, N$), C = Math.imul(d, D$), C = C + Math.imul(o, N$) | 0, L = Math.imul(o, D$), R = R + Math.imul(e, L$) | 0, C = C + Math.imul(e, C$) | 0, C = C + Math.imul(_$2, L$) | 0, L = L + Math.imul(_$2, C$) | 0, R = R + Math.imul(m, g$) | 0, C = C + Math.imul(m, h$) | 0, C = C + Math.imul(r, g$) | 0, L = L + Math.imul(r, h$) | 0, R = R + Math.imul(Q, b$) | 0, C = C + Math.imul(Q, y$) | 0, C = C + Math.imul(v$, b$) | 0, L = L + Math.imul(v$, y$) | 0, R = R + Math.imul($$, E$) | 0, C = C + Math.imul($$, u) | 0, C = C + Math.imul(t, E$) | 0, L = L + Math.imul(t, u) | 0, R = R + Math.imul(l, K$) | 0, C = C + Math.imul(l, P$) | 0, C = C + Math.imul(a, K$) | 0, L = L + Math.imul(a, P$) | 0;
        var F6 = (k + R | 0) + ((C & 8191) << 13) | 0;
        k = (L + (C >>> 13) | 0) + (F6 >>> 26) | 0, F6 &= 67108863, R = Math.imul(B, N$), C = Math.imul(B, D$), C = C + Math.imul(F, N$) | 0, L = Math.imul(F, D$), R = R + Math.imul(d, L$) | 0, C = C + Math.imul(d, C$) | 0, C = C + Math.imul(o, L$) | 0, L = L + Math.imul(o, C$) | 0, R = R + Math.imul(e, g$) | 0, C = C + Math.imul(e, h$) | 0, C = C + Math.imul(_$2, g$) | 0, L = L + Math.imul(_$2, h$) | 0, R = R + Math.imul(m, b$) | 0, C = C + Math.imul(m, y$) | 0, C = C + Math.imul(r, b$) | 0, L = L + Math.imul(r, y$) | 0, R = R + Math.imul(Q, E$) | 0, C = C + Math.imul(Q, u) | 0, C = C + Math.imul(v$, E$) | 0, L = L + Math.imul(v$, u) | 0, R = R + Math.imul($$, K$) | 0, C = C + Math.imul($$, P$) | 0, C = C + Math.imul(t, K$) | 0, L = L + Math.imul(t, P$) | 0, R = R + Math.imul(l, k$) | 0, C = C + Math.imul(l, G$) | 0, C = C + Math.imul(a, k$) | 0, L = L + Math.imul(a, G$) | 0;
        var a6 = (k + R | 0) + ((C & 8191) << 13) | 0;
        k = (L + (C >>> 13) | 0) + (a6 >>> 26) | 0, a6 &= 67108863, R = Math.imul(z$, N$), C = Math.imul(z$, D$), C = C + Math.imul(j$, N$) | 0, L = Math.imul(j$, D$), R = R + Math.imul(B, L$) | 0, C = C + Math.imul(B, C$) | 0, C = C + Math.imul(F, L$) | 0, L = L + Math.imul(F, C$) | 0, R = R + Math.imul(d, g$) | 0, C = C + Math.imul(d, h$) | 0, C = C + Math.imul(o, g$) | 0, L = L + Math.imul(o, h$) | 0, R = R + Math.imul(e, b$) | 0, C = C + Math.imul(e, y$) | 0, C = C + Math.imul(_$2, b$) | 0, L = L + Math.imul(_$2, y$) | 0, R = R + Math.imul(m, E$) | 0, C = C + Math.imul(m, u) | 0, C = C + Math.imul(r, E$) | 0, L = L + Math.imul(r, u) | 0, R = R + Math.imul(Q, K$) | 0, C = C + Math.imul(Q, P$) | 0, C = C + Math.imul(v$, K$) | 0, L = L + Math.imul(v$, P$) | 0, R = R + Math.imul($$, k$) | 0, C = C + Math.imul($$, G$) | 0, C = C + Math.imul(t, k$) | 0, L = L + Math.imul(t, G$) | 0, R = R + Math.imul(l, R$) | 0, C = C + Math.imul(l, u$) | 0, C = C + Math.imul(a, R$) | 0, L = L + Math.imul(a, u$) | 0;
        var Q6 = (k + R | 0) + ((C & 8191) << 13) | 0;
        k = (L + (C >>> 13) | 0) + (Q6 >>> 26) | 0, Q6 &= 67108863, R = Math.imul(Z$, N$), C = Math.imul(Z$, D$), C = C + Math.imul(A$, N$) | 0, L = Math.imul(A$, D$), R = R + Math.imul(z$, L$) | 0, C = C + Math.imul(z$, C$) | 0, C = C + Math.imul(j$, L$) | 0, L = L + Math.imul(j$, C$) | 0, R = R + Math.imul(B, g$) | 0, C = C + Math.imul(B, h$) | 0, C = C + Math.imul(F, g$) | 0, L = L + Math.imul(F, h$) | 0, R = R + Math.imul(d, b$) | 0, C = C + Math.imul(d, y$) | 0, C = C + Math.imul(o, b$) | 0, L = L + Math.imul(o, y$) | 0, R = R + Math.imul(e, E$) | 0, C = C + Math.imul(e, u) | 0, C = C + Math.imul(_$2, E$) | 0, L = L + Math.imul(_$2, u) | 0, R = R + Math.imul(m, K$) | 0, C = C + Math.imul(m, P$) | 0, C = C + Math.imul(r, K$) | 0, L = L + Math.imul(r, P$) | 0, R = R + Math.imul(Q, k$) | 0, C = C + Math.imul(Q, G$) | 0, C = C + Math.imul(v$, k$) | 0, L = L + Math.imul(v$, G$) | 0, R = R + Math.imul($$, R$) | 0, C = C + Math.imul($$, u$) | 0, C = C + Math.imul(t, R$) | 0, L = L + Math.imul(t, u$) | 0, R = R + Math.imul(l, I$) | 0, C = C + Math.imul(l, M$) | 0, C = C + Math.imul(a, I$) | 0, L = L + Math.imul(a, M$) | 0;
        var e6 = (k + R | 0) + ((C & 8191) << 13) | 0;
        k = (L + (C >>> 13) | 0) + (e6 >>> 26) | 0, e6 &= 67108863, R = Math.imul(S$, N$), C = Math.imul(S$, D$), C = C + Math.imul(V$, N$) | 0, L = Math.imul(V$, D$), R = R + Math.imul(Z$, L$) | 0, C = C + Math.imul(Z$, C$) | 0, C = C + Math.imul(A$, L$) | 0, L = L + Math.imul(A$, C$) | 0, R = R + Math.imul(z$, g$) | 0, C = C + Math.imul(z$, h$) | 0, C = C + Math.imul(j$, g$) | 0, L = L + Math.imul(j$, h$) | 0, R = R + Math.imul(B, b$) | 0, C = C + Math.imul(B, y$) | 0, C = C + Math.imul(F, b$) | 0, L = L + Math.imul(F, y$) | 0, R = R + Math.imul(d, E$) | 0, C = C + Math.imul(d, u) | 0, C = C + Math.imul(o, E$) | 0, L = L + Math.imul(o, u) | 0, R = R + Math.imul(e, K$) | 0, C = C + Math.imul(e, P$) | 0, C = C + Math.imul(_$2, K$) | 0, L = L + Math.imul(_$2, P$) | 0, R = R + Math.imul(m, k$) | 0, C = C + Math.imul(m, G$) | 0, C = C + Math.imul(r, k$) | 0, L = L + Math.imul(r, G$) | 0, R = R + Math.imul(Q, R$) | 0, C = C + Math.imul(Q, u$) | 0, C = C + Math.imul(v$, R$) | 0, L = L + Math.imul(v$, u$) | 0, R = R + Math.imul($$, I$) | 0, C = C + Math.imul($$, M$) | 0, C = C + Math.imul(t, I$) | 0, L = L + Math.imul(t, M$) | 0, R = R + Math.imul(l, H6) | 0, C = C + Math.imul(l, v6) | 0, C = C + Math.imul(a, H6) | 0, L = L + Math.imul(a, v6) | 0;
        var s6 = (k + R | 0) + ((C & 8191) << 13) | 0;
        k = (L + (C >>> 13) | 0) + (s6 >>> 26) | 0, s6 &= 67108863, R = Math.imul(S$, L$), C = Math.imul(S$, C$), C = C + Math.imul(V$, L$) | 0, L = Math.imul(V$, C$), R = R + Math.imul(Z$, g$) | 0, C = C + Math.imul(Z$, h$) | 0, C = C + Math.imul(A$, g$) | 0, L = L + Math.imul(A$, h$) | 0, R = R + Math.imul(z$, b$) | 0, C = C + Math.imul(z$, y$) | 0, C = C + Math.imul(j$, b$) | 0, L = L + Math.imul(j$, y$) | 0, R = R + Math.imul(B, E$) | 0, C = C + Math.imul(B, u) | 0, C = C + Math.imul(F, E$) | 0, L = L + Math.imul(F, u) | 0, R = R + Math.imul(d, K$) | 0, C = C + Math.imul(d, P$) | 0, C = C + Math.imul(o, K$) | 0, L = L + Math.imul(o, P$) | 0, R = R + Math.imul(e, k$) | 0, C = C + Math.imul(e, G$) | 0, C = C + Math.imul(_$2, k$) | 0, L = L + Math.imul(_$2, G$) | 0, R = R + Math.imul(m, R$) | 0, C = C + Math.imul(m, u$) | 0, C = C + Math.imul(r, R$) | 0, L = L + Math.imul(r, u$) | 0, R = R + Math.imul(Q, I$) | 0, C = C + Math.imul(Q, M$) | 0, C = C + Math.imul(v$, I$) | 0, L = L + Math.imul(v$, M$) | 0, R = R + Math.imul($$, H6) | 0, C = C + Math.imul($$, v6) | 0, C = C + Math.imul(t, H6) | 0, L = L + Math.imul(t, v6) | 0;
        var $q = (k + R | 0) + ((C & 8191) << 13) | 0;
        k = (L + (C >>> 13) | 0) + ($q >>> 26) | 0, $q &= 67108863, R = Math.imul(S$, g$), C = Math.imul(S$, h$), C = C + Math.imul(V$, g$) | 0, L = Math.imul(V$, h$), R = R + Math.imul(Z$, b$) | 0, C = C + Math.imul(Z$, y$) | 0, C = C + Math.imul(A$, b$) | 0, L = L + Math.imul(A$, y$) | 0, R = R + Math.imul(z$, E$) | 0, C = C + Math.imul(z$, u) | 0, C = C + Math.imul(j$, E$) | 0, L = L + Math.imul(j$, u) | 0, R = R + Math.imul(B, K$) | 0, C = C + Math.imul(B, P$) | 0, C = C + Math.imul(F, K$) | 0, L = L + Math.imul(F, P$) | 0, R = R + Math.imul(d, k$) | 0, C = C + Math.imul(d, G$) | 0, C = C + Math.imul(o, k$) | 0, L = L + Math.imul(o, G$) | 0, R = R + Math.imul(e, R$) | 0, C = C + Math.imul(e, u$) | 0, C = C + Math.imul(_$2, R$) | 0, L = L + Math.imul(_$2, u$) | 0, R = R + Math.imul(m, I$) | 0, C = C + Math.imul(m, M$) | 0, C = C + Math.imul(r, I$) | 0, L = L + Math.imul(r, M$) | 0, R = R + Math.imul(Q, H6) | 0, C = C + Math.imul(Q, v6) | 0, C = C + Math.imul(v$, H6) | 0, L = L + Math.imul(v$, v6) | 0;
        var qq = (k + R | 0) + ((C & 8191) << 13) | 0;
        k = (L + (C >>> 13) | 0) + (qq >>> 26) | 0, qq &= 67108863, R = Math.imul(S$, b$), C = Math.imul(S$, y$), C = C + Math.imul(V$, b$) | 0, L = Math.imul(V$, y$), R = R + Math.imul(Z$, E$) | 0, C = C + Math.imul(Z$, u) | 0, C = C + Math.imul(A$, E$) | 0, L = L + Math.imul(A$, u) | 0, R = R + Math.imul(z$, K$) | 0, C = C + Math.imul(z$, P$) | 0, C = C + Math.imul(j$, K$) | 0, L = L + Math.imul(j$, P$) | 0, R = R + Math.imul(B, k$) | 0, C = C + Math.imul(B, G$) | 0, C = C + Math.imul(F, k$) | 0, L = L + Math.imul(F, G$) | 0, R = R + Math.imul(d, R$) | 0, C = C + Math.imul(d, u$) | 0, C = C + Math.imul(o, R$) | 0, L = L + Math.imul(o, u$) | 0, R = R + Math.imul(e, I$) | 0, C = C + Math.imul(e, M$) | 0, C = C + Math.imul(_$2, I$) | 0, L = L + Math.imul(_$2, M$) | 0, R = R + Math.imul(m, H6) | 0, C = C + Math.imul(m, v6) | 0, C = C + Math.imul(r, H6) | 0, L = L + Math.imul(r, v6) | 0;
        var Kq = (k + R | 0) + ((C & 8191) << 13) | 0;
        k = (L + (C >>> 13) | 0) + (Kq >>> 26) | 0, Kq &= 67108863, R = Math.imul(S$, E$), C = Math.imul(S$, u), C = C + Math.imul(V$, E$) | 0, L = Math.imul(V$, u), R = R + Math.imul(Z$, K$) | 0, C = C + Math.imul(Z$, P$) | 0, C = C + Math.imul(A$, K$) | 0, L = L + Math.imul(A$, P$) | 0, R = R + Math.imul(z$, k$) | 0, C = C + Math.imul(z$, G$) | 0, C = C + Math.imul(j$, k$) | 0, L = L + Math.imul(j$, G$) | 0, R = R + Math.imul(B, R$) | 0, C = C + Math.imul(B, u$) | 0, C = C + Math.imul(F, R$) | 0, L = L + Math.imul(F, u$) | 0, R = R + Math.imul(d, I$) | 0, C = C + Math.imul(d, M$) | 0, C = C + Math.imul(o, I$) | 0, L = L + Math.imul(o, M$) | 0, R = R + Math.imul(e, H6) | 0, C = C + Math.imul(e, v6) | 0, C = C + Math.imul(_$2, H6) | 0, L = L + Math.imul(_$2, v6) | 0;
        var _q = (k + R | 0) + ((C & 8191) << 13) | 0;
        k = (L + (C >>> 13) | 0) + (_q >>> 26) | 0, _q &= 67108863, R = Math.imul(S$, K$), C = Math.imul(S$, P$), C = C + Math.imul(V$, K$) | 0, L = Math.imul(V$, P$), R = R + Math.imul(Z$, k$) | 0, C = C + Math.imul(Z$, G$) | 0, C = C + Math.imul(A$, k$) | 0, L = L + Math.imul(A$, G$) | 0, R = R + Math.imul(z$, R$) | 0, C = C + Math.imul(z$, u$) | 0, C = C + Math.imul(j$, R$) | 0, L = L + Math.imul(j$, u$) | 0, R = R + Math.imul(B, I$) | 0, C = C + Math.imul(B, M$) | 0, C = C + Math.imul(F, I$) | 0, L = L + Math.imul(F, M$) | 0, R = R + Math.imul(d, H6) | 0, C = C + Math.imul(d, v6) | 0, C = C + Math.imul(o, H6) | 0, L = L + Math.imul(o, v6) | 0;
        var Pq = (k + R | 0) + ((C & 8191) << 13) | 0;
        k = (L + (C >>> 13) | 0) + (Pq >>> 26) | 0, Pq &= 67108863, R = Math.imul(S$, k$), C = Math.imul(S$, G$), C = C + Math.imul(V$, k$) | 0, L = Math.imul(V$, G$), R = R + Math.imul(Z$, R$) | 0, C = C + Math.imul(Z$, u$) | 0, C = C + Math.imul(A$, R$) | 0, L = L + Math.imul(A$, u$) | 0, R = R + Math.imul(z$, I$) | 0, C = C + Math.imul(z$, M$) | 0, C = C + Math.imul(j$, I$) | 0, L = L + Math.imul(j$, M$) | 0, R = R + Math.imul(B, H6) | 0, C = C + Math.imul(B, v6) | 0, C = C + Math.imul(F, H6) | 0, L = L + Math.imul(F, v6) | 0;
        var Oq = (k + R | 0) + ((C & 8191) << 13) | 0;
        k = (L + (C >>> 13) | 0) + (Oq >>> 26) | 0, Oq &= 67108863, R = Math.imul(S$, R$), C = Math.imul(S$, u$), C = C + Math.imul(V$, R$) | 0, L = Math.imul(V$, u$), R = R + Math.imul(Z$, I$) | 0, C = C + Math.imul(Z$, M$) | 0, C = C + Math.imul(A$, I$) | 0, L = L + Math.imul(A$, M$) | 0, R = R + Math.imul(z$, H6) | 0, C = C + Math.imul(z$, v6) | 0, C = C + Math.imul(j$, H6) | 0, L = L + Math.imul(j$, v6) | 0;
        var RO = (k + R | 0) + ((C & 8191) << 13) | 0;
        k = (L + (C >>> 13) | 0) + (RO >>> 26) | 0, RO &= 67108863, R = Math.imul(S$, I$), C = Math.imul(S$, M$), C = C + Math.imul(V$, I$) | 0, L = Math.imul(V$, M$), R = R + Math.imul(Z$, H6) | 0, C = C + Math.imul(Z$, v6) | 0, C = C + Math.imul(A$, H6) | 0, L = L + Math.imul(A$, v6) | 0;
        var IO = (k + R | 0) + ((C & 8191) << 13) | 0;
        k = (L + (C >>> 13) | 0) + (IO >>> 26) | 0, IO &= 67108863, R = Math.imul(S$, H6), C = Math.imul(S$, v6), C = C + Math.imul(V$, H6) | 0, L = Math.imul(V$, v6);
        var DO = (k + R | 0) + ((C & 8191) << 13) | 0;
        if (k = (L + (C >>> 13) | 0) + (DO >>> 26) | 0, DO &= 67108863, v[0] = C6, v[1] = S6, v[2] = t6, v[3] = B6, v[4] = U6, v[5] = F6, v[6] = a6, v[7] = Q6, v[8] = e6, v[9] = s6, v[10] = $q, v[11] = qq, v[12] = Kq, v[13] = _q, v[14] = Pq, v[15] = Oq, v[16] = RO, v[17] = IO, v[18] = DO, k !== 0) v[19] = k, G.length++;
        return G;
      }, "g");
      if (!Math.imul) g = D;
      function b(W, w, G) {
        G.negative = w.negative ^ W.negative, G.length = W.length + w.length;
        var S = 0, A = 0;
        for (var v = 0; v < G.length - 1; v++) {
          var k = A;
          A = 0;
          var R = S & 67108863, C = Math.min(v, w.length - 1);
          for (var L = Math.max(0, v - W.length + 1); L <= C; L++) {
            var x = v - L, l = W.words[x] | 0, a = w.words[L] | 0, f$ = l * a, $$ = f$ & 67108863;
            k = k + (f$ / 67108864 | 0) | 0, $$ = $$ + R | 0, R = $$ & 67108863, k = k + ($$ >>> 26) | 0, A += k >>> 26, k &= 67108863;
          }
          G.words[v] = R, S = k, k = A;
        }
        if (S !== 0) G.words[v] = S;
        else G.length--;
        return G._strip();
      }
      __name(b, "b");
      function y(W, w, G) {
        return b(W, w, G);
      }
      __name(y, "y");
      O.prototype.mulTo = function(W, w) {
        var G, S = this.length + W.length;
        if (this.length === 10 && W.length === 10) G = g(this, W, w);
        else if (S < 63) G = D(this, W, w);
        else if (S < 1024) G = b(this, W, w);
        else G = y(this, W, w);
        return G;
      };
      function p(W, w) {
        this.x = W, this.y = w;
      }
      __name(p, "p");
      p.prototype.makeRBT = function(W) {
        var w = Array(W), G = O.prototype._countBits(W) - 1;
        for (var S = 0; S < W; S++) w[S] = this.revBin(S, G, W);
        return w;
      }, p.prototype.revBin = function(W, w, G) {
        if (W === 0 || W === G - 1) return W;
        var S = 0;
        for (var A = 0; A < w; A++) S |= (W & 1) << w - A - 1, W >>= 1;
        return S;
      }, p.prototype.permute = function(W, w, G, S, A, v) {
        for (var k = 0; k < v; k++) S[k] = w[W[k]], A[k] = G[W[k]];
      }, p.prototype.transform = function(W, w, G, S, A, v) {
        this.permute(v, W, w, G, S, A);
        for (var k = 1; k < A; k <<= 1) {
          var R = k << 1, C = Math.cos(2 * Math.PI / R), L = Math.sin(2 * Math.PI / R);
          for (var x = 0; x < A; x += R) {
            var l = C, a = L;
            for (var f$ = 0; f$ < k; f$++) {
              var $$ = G[x + f$], t = S[x + f$], H$ = G[x + f$ + k], Q = S[x + f$ + k], v$ = l * H$ - a * Q;
              if (Q = l * Q + a * H$, H$ = v$, G[x + f$] = $$ + H$, S[x + f$] = t + Q, G[x + f$ + k] = $$ - H$, S[x + f$ + k] = t - Q, f$ !== R) v$ = C * l - L * a, a = C * a + L * l, l = v$;
            }
          }
        }
      }, p.prototype.guessLen13b = function(W, w) {
        var G = Math.max(w, W) | 1, S = G & 1, A = 0;
        for (G = G / 2 | 0; G; G = G >>> 1) A++;
        return 1 << A + 1 + S;
      }, p.prototype.conjugate = function(W, w, G) {
        if (G <= 1) return;
        for (var S = 0; S < G / 2; S++) {
          var A = W[S];
          W[S] = W[G - S - 1], W[G - S - 1] = A, A = w[S], w[S] = -w[G - S - 1], w[G - S - 1] = -A;
        }
      }, p.prototype.normalize13b = function(W, w) {
        var G = 0;
        for (var S = 0; S < w / 2; S++) {
          var A = Math.round(W[2 * S + 1] / w) * 8192 + Math.round(W[2 * S] / w) + G;
          if (W[S] = A & 67108863, A < 67108864) G = 0;
          else G = A / 67108864 | 0;
        }
        return W;
      }, p.prototype.convert13b = function(W, w, G, S) {
        var A = 0;
        for (var v = 0; v < w; v++) A = A + (W[v] | 0), G[2 * v] = A & 8191, A = A >>> 13, G[2 * v + 1] = A & 8191, A = A >>> 13;
        for (v = 2 * w; v < S; ++v) G[v] = 0;
        _(A === 0), _((A & -8192) === 0);
      }, p.prototype.stub = function(W) {
        var w = Array(W);
        for (var G = 0; G < W; G++) w[G] = 0;
        return w;
      }, p.prototype.mulp = function(W, w, G) {
        var S = 2 * this.guessLen13b(W.length, w.length), A = this.makeRBT(S), v = this.stub(S), k = Array(S), R = Array(S), C = Array(S), L = Array(S), x = Array(S), l = Array(S), a = G.words;
        a.length = S, this.convert13b(W.words, W.length, k, S), this.convert13b(w.words, w.length, L, S), this.transform(k, v, R, C, S, A), this.transform(L, v, x, l, S, A);
        for (var f$ = 0; f$ < S; f$++) {
          var $$ = R[f$] * x[f$] - C[f$] * l[f$];
          C[f$] = R[f$] * l[f$] + C[f$] * x[f$], R[f$] = $$;
        }
        return this.conjugate(R, C, S), this.transform(R, C, a, v, S, A), this.conjugate(a, v, S), this.normalize13b(a, S), G.negative = W.negative ^ w.negative, G.length = W.length + w.length, G._strip();
      }, O.prototype.mul = function(W) {
        var w = new O(null);
        return w.words = Array(this.length + W.length), this.mulTo(W, w);
      }, O.prototype.mulf = function(W) {
        var w = new O(null);
        return w.words = Array(this.length + W.length), y(this, W, w);
      }, O.prototype.imul = function(W) {
        return this.clone().mulTo(W, this);
      }, O.prototype.imuln = function(W) {
        var w = W < 0;
        if (w) W = -W;
        _(typeof W === "number"), _(W < 67108864);
        var G = 0;
        for (var S = 0; S < this.length; S++) {
          var A = (this.words[S] | 0) * W, v = (A & 67108863) + (G & 67108863);
          G >>= 26, G += A / 67108864 | 0, G += v >>> 26, this.words[S] = v & 67108863;
        }
        if (G !== 0) this.words[S] = G, this.length++;
        return this.length = W === 0 ? 1 : this.length, w ? this.ineg() : this;
      }, O.prototype.muln = function(W) {
        return this.clone().imuln(W);
      }, O.prototype.sqr = function() {
        return this.mul(this);
      }, O.prototype.isqr = function() {
        return this.imul(this.clone());
      }, O.prototype.pow = function(W) {
        var w = I(W);
        if (w.length === 0) return new O(1);
        var G = this;
        for (var S = 0; S < w.length; S++, G = G.sqr()) if (w[S] !== 0) break;
        if (++S < w.length) for (var A = G.sqr(); S < w.length; S++, A = A.sqr()) {
          if (w[S] === 0) continue;
          G = G.mul(A);
        }
        return G;
      }, O.prototype.iushln = function(W) {
        _(typeof W === "number" && W >= 0);
        var w = W % 26, G = (W - w) / 26, S = 67108863 >>> 26 - w << 26 - w, A;
        if (w !== 0) {
          var v = 0;
          for (A = 0; A < this.length; A++) {
            var k = this.words[A] & S, R = (this.words[A] | 0) - k << w;
            this.words[A] = R | v, v = k >>> 26 - w;
          }
          if (v) this.words[A] = v, this.length++;
        }
        if (G !== 0) {
          for (A = this.length - 1; A >= 0; A--) this.words[A + G] = this.words[A];
          for (A = 0; A < G; A++) this.words[A] = 0;
          this.length += G;
        }
        return this._strip();
      }, O.prototype.ishln = function(W) {
        return _(this.negative === 0), this.iushln(W);
      }, O.prototype.iushrn = function(W, w, G) {
        _(typeof W === "number" && W >= 0);
        var S;
        if (w) S = (w - w % 26) / 26;
        else S = 0;
        var A = W % 26, v = Math.min((W - A) / 26, this.length), k = 67108863 ^ 67108863 >>> A << A, R = G;
        if (S -= v, S = Math.max(0, S), R) {
          for (var C = 0; C < v; C++) R.words[C] = this.words[C];
          R.length = v;
        }
        if (v === 0) ;
        else if (this.length > v) {
          this.length -= v;
          for (C = 0; C < this.length; C++) this.words[C] = this.words[C + v];
        } else this.words[0] = 0, this.length = 1;
        var L = 0;
        for (C = this.length - 1; C >= 0 && (L !== 0 || C >= S); C--) {
          var x = this.words[C] | 0;
          this.words[C] = L << 26 - A | x >>> A, L = x & k;
        }
        if (R && L !== 0) R.words[R.length++] = L;
        if (this.length === 0) this.words[0] = 0, this.length = 1;
        return this._strip();
      }, O.prototype.ishrn = function(W, w, G) {
        return _(this.negative === 0), this.iushrn(W, w, G);
      }, O.prototype.shln = function(W) {
        return this.clone().ishln(W);
      }, O.prototype.ushln = function(W) {
        return this.clone().iushln(W);
      }, O.prototype.shrn = function(W) {
        return this.clone().ishrn(W);
      }, O.prototype.ushrn = function(W) {
        return this.clone().iushrn(W);
      }, O.prototype.testn = function(W) {
        _(typeof W === "number" && W >= 0);
        var w = W % 26, G = (W - w) / 26, S = 1 << w;
        if (this.length <= G) return false;
        var A = this.words[G];
        return !!(A & S);
      }, O.prototype.imaskn = function(W) {
        _(typeof W === "number" && W >= 0);
        var w = W % 26, G = (W - w) / 26;
        if (_(this.negative === 0, "imaskn works only with positive numbers"), this.length <= G) return this;
        if (w !== 0) G++;
        if (this.length = Math.min(G, this.length), w !== 0) {
          var S = 67108863 ^ 67108863 >>> w << w;
          this.words[this.length - 1] &= S;
        }
        return this._strip();
      }, O.prototype.maskn = function(W) {
        return this.clone().imaskn(W);
      }, O.prototype.iaddn = function(W) {
        if (_(typeof W === "number"), _(W < 67108864), W < 0) return this.isubn(-W);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) <= W) return this.words[0] = W - (this.words[0] | 0), this.negative = 0, this;
          return this.negative = 0, this.isubn(W), this.negative = 1, this;
        }
        return this._iaddn(W);
      }, O.prototype._iaddn = function(W) {
        this.words[0] += W;
        for (var w = 0; w < this.length && this.words[w] >= 67108864; w++) if (this.words[w] -= 67108864, w === this.length - 1) this.words[w + 1] = 1;
        else this.words[w + 1]++;
        return this.length = Math.max(this.length, w + 1), this;
      }, O.prototype.isubn = function(W) {
        if (_(typeof W === "number"), _(W < 67108864), W < 0) return this.iaddn(-W);
        if (this.negative !== 0) return this.negative = 0, this.iaddn(W), this.negative = 1, this;
        if (this.words[0] -= W, this.length === 1 && this.words[0] < 0) this.words[0] = -this.words[0], this.negative = 1;
        else for (var w = 0; w < this.length && this.words[w] < 0; w++) this.words[w] += 67108864, this.words[w + 1] -= 1;
        return this._strip();
      }, O.prototype.addn = function(W) {
        return this.clone().iaddn(W);
      }, O.prototype.subn = function(W) {
        return this.clone().isubn(W);
      }, O.prototype.iabs = function() {
        return this.negative = 0, this;
      }, O.prototype.abs = function() {
        return this.clone().iabs();
      }, O.prototype._ishlnsubmul = function(W, w, G) {
        var S = W.length + G, A;
        this._expand(S);
        var v, k = 0;
        for (A = 0; A < W.length; A++) {
          v = (this.words[A + G] | 0) + k;
          var R = (W.words[A] | 0) * w;
          v -= R & 67108863, k = (v >> 26) - (R / 67108864 | 0), this.words[A + G] = v & 67108863;
        }
        for (; A < this.length - G; A++) v = (this.words[A + G] | 0) + k, k = v >> 26, this.words[A + G] = v & 67108863;
        if (k === 0) return this._strip();
        _(k === -1), k = 0;
        for (A = 0; A < this.length; A++) v = -(this.words[A] | 0) + k, k = v >> 26, this.words[A] = v & 67108863;
        return this.negative = 1, this._strip();
      }, O.prototype._wordDiv = function(W, w) {
        var G = this.length - W.length, S = this.clone(), A = W, v = A.words[A.length - 1] | 0, k = this._countBits(v);
        if (G = 26 - k, G !== 0) A = A.ushln(G), S.iushln(G), v = A.words[A.length - 1] | 0;
        var R = S.length - A.length, C;
        if (w !== "mod") {
          C = new O(null), C.length = R + 1, C.words = Array(C.length);
          for (var L = 0; L < C.length; L++) C.words[L] = 0;
        }
        var x = S.clone()._ishlnsubmul(A, 1, R);
        if (x.negative === 0) {
          if (S = x, C) C.words[R] = 1;
        }
        for (var l = R - 1; l >= 0; l--) {
          var a = (S.words[A.length + l] | 0) * 67108864 + (S.words[A.length + l - 1] | 0);
          a = Math.min(a / v | 0, 67108863), S._ishlnsubmul(A, a, l);
          while (S.negative !== 0) if (a--, S.negative = 0, S._ishlnsubmul(A, 1, l), !S.isZero()) S.negative ^= 1;
          if (C) C.words[l] = a;
        }
        if (C) C._strip();
        if (S._strip(), w !== "div" && G !== 0) S.iushrn(G);
        return { div: C || null, mod: S };
      }, O.prototype.divmod = function(W, w, G) {
        if (_(!W.isZero()), this.isZero()) return { div: new O(0), mod: new O(0) };
        var S, A, v;
        if (this.negative !== 0 && W.negative === 0) {
          if (v = this.neg().divmod(W, w), w !== "mod") S = v.div.neg();
          if (w !== "div") {
            if (A = v.mod.neg(), G && A.negative !== 0) A.iadd(W);
          }
          return { div: S, mod: A };
        }
        if (this.negative === 0 && W.negative !== 0) {
          if (v = this.divmod(W.neg(), w), w !== "mod") S = v.div.neg();
          return { div: S, mod: v.mod };
        }
        if ((this.negative & W.negative) !== 0) {
          if (v = this.neg().divmod(W.neg(), w), w !== "div") {
            if (A = v.mod.neg(), G && A.negative !== 0) A.isub(W);
          }
          return { div: v.div, mod: A };
        }
        if (W.length > this.length || this.cmp(W) < 0) return { div: new O(0), mod: this };
        if (W.length === 1) {
          if (w === "div") return { div: this.divn(W.words[0]), mod: null };
          if (w === "mod") return { div: null, mod: new O(this.modrn(W.words[0])) };
          return { div: this.divn(W.words[0]), mod: new O(this.modrn(W.words[0])) };
        }
        return this._wordDiv(W, w);
      }, O.prototype.div = function(W) {
        return this.divmod(W, "div", false).div;
      }, O.prototype.mod = function(W) {
        return this.divmod(W, "mod", false).mod;
      }, O.prototype.umod = function(W) {
        return this.divmod(W, "mod", true).mod;
      }, O.prototype.divRound = function(W) {
        var w = this.divmod(W);
        if (w.mod.isZero()) return w.div;
        var G = w.div.negative !== 0 ? w.mod.isub(W) : w.mod, S = W.ushrn(1), A = W.andln(1), v = G.cmp(S);
        if (v < 0 || A === 1 && v === 0) return w.div;
        return w.div.negative !== 0 ? w.div.isubn(1) : w.div.iaddn(1);
      }, O.prototype.modrn = function(W) {
        var w = W < 0;
        if (w) W = -W;
        _(W <= 67108863);
        var G = 67108864 % W, S = 0;
        for (var A = this.length - 1; A >= 0; A--) S = (G * S + (this.words[A] | 0)) % W;
        return w ? -S : S;
      }, O.prototype.modn = function(W) {
        return this.modrn(W);
      }, O.prototype.idivn = function(W) {
        var w = W < 0;
        if (w) W = -W;
        _(W <= 67108863);
        var G = 0;
        for (var S = this.length - 1; S >= 0; S--) {
          var A = (this.words[S] | 0) + G * 67108864;
          this.words[S] = A / W | 0, G = A % W;
        }
        return this._strip(), w ? this.ineg() : this;
      }, O.prototype.divn = function(W) {
        return this.clone().idivn(W);
      }, O.prototype.egcd = function(W) {
        _(W.negative === 0), _(!W.isZero());
        var w = this, G = W.clone();
        if (w.negative !== 0) w = w.umod(W);
        else w = w.clone();
        var S = new O(1), A = new O(0), v = new O(0), k = new O(1), R = 0;
        while (w.isEven() && G.isEven()) w.iushrn(1), G.iushrn(1), ++R;
        var C = G.clone(), L = w.clone();
        while (!w.isZero()) {
          for (var x = 0, l = 1; (w.words[0] & l) === 0 && x < 26; ++x, l <<= 1) ;
          if (x > 0) {
            w.iushrn(x);
            while (x-- > 0) {
              if (S.isOdd() || A.isOdd()) S.iadd(C), A.isub(L);
              S.iushrn(1), A.iushrn(1);
            }
          }
          for (var a = 0, f$ = 1; (G.words[0] & f$) === 0 && a < 26; ++a, f$ <<= 1) ;
          if (a > 0) {
            G.iushrn(a);
            while (a-- > 0) {
              if (v.isOdd() || k.isOdd()) v.iadd(C), k.isub(L);
              v.iushrn(1), k.iushrn(1);
            }
          }
          if (w.cmp(G) >= 0) w.isub(G), S.isub(v), A.isub(k);
          else G.isub(w), v.isub(S), k.isub(A);
        }
        return { a: v, b: k, gcd: G.iushln(R) };
      }, O.prototype._invmp = function(W) {
        _(W.negative === 0), _(!W.isZero());
        var w = this, G = W.clone();
        if (w.negative !== 0) w = w.umod(W);
        else w = w.clone();
        var S = new O(1), A = new O(0), v = G.clone();
        while (w.cmpn(1) > 0 && G.cmpn(1) > 0) {
          for (var k = 0, R = 1; (w.words[0] & R) === 0 && k < 26; ++k, R <<= 1) ;
          if (k > 0) {
            w.iushrn(k);
            while (k-- > 0) {
              if (S.isOdd()) S.iadd(v);
              S.iushrn(1);
            }
          }
          for (var C = 0, L = 1; (G.words[0] & L) === 0 && C < 26; ++C, L <<= 1) ;
          if (C > 0) {
            G.iushrn(C);
            while (C-- > 0) {
              if (A.isOdd()) A.iadd(v);
              A.iushrn(1);
            }
          }
          if (w.cmp(G) >= 0) w.isub(G), S.isub(A);
          else G.isub(w), A.isub(S);
        }
        var x;
        if (w.cmpn(1) === 0) x = S;
        else x = A;
        if (x.cmpn(0) < 0) x.iadd(W);
        return x;
      }, O.prototype.gcd = function(W) {
        if (this.isZero()) return W.abs();
        if (W.isZero()) return this.abs();
        var w = this.clone(), G = W.clone();
        w.negative = 0, G.negative = 0;
        for (var S = 0; w.isEven() && G.isEven(); S++) w.iushrn(1), G.iushrn(1);
        do {
          while (w.isEven()) w.iushrn(1);
          while (G.isEven()) G.iushrn(1);
          var A = w.cmp(G);
          if (A < 0) {
            var v = w;
            w = G, G = v;
          } else if (A === 0 || G.cmpn(1) === 0) break;
          w.isub(G);
        } while (true);
        return G.iushln(S);
      }, O.prototype.invm = function(W) {
        return this.egcd(W).a.umod(W);
      }, O.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, O.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, O.prototype.andln = function(W) {
        return this.words[0] & W;
      }, O.prototype.bincn = function(W) {
        _(typeof W === "number");
        var w = W % 26, G = (W - w) / 26, S = 1 << w;
        if (this.length <= G) return this._expand(G + 1), this.words[G] |= S, this;
        var A = S;
        for (var v = G; A !== 0 && v < this.length; v++) {
          var k = this.words[v] | 0;
          k += A, A = k >>> 26, k &= 67108863, this.words[v] = k;
        }
        if (A !== 0) this.words[v] = A, this.length++;
        return this;
      }, O.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, O.prototype.cmpn = function(W) {
        var w = W < 0;
        if (this.negative !== 0 && !w) return -1;
        if (this.negative === 0 && w) return 1;
        this._strip();
        var G;
        if (this.length > 1) G = 1;
        else {
          if (w) W = -W;
          _(W <= 67108863, "Number is too big");
          var S = this.words[0] | 0;
          G = S === W ? 0 : S < W ? -1 : 1;
        }
        if (this.negative !== 0) return -G | 0;
        return G;
      }, O.prototype.cmp = function(W) {
        if (this.negative !== 0 && W.negative === 0) return -1;
        if (this.negative === 0 && W.negative !== 0) return 1;
        var w = this.ucmp(W);
        if (this.negative !== 0) return -w | 0;
        return w;
      }, O.prototype.ucmp = function(W) {
        if (this.length > W.length) return 1;
        if (this.length < W.length) return -1;
        var w = 0;
        for (var G = this.length - 1; G >= 0; G--) {
          var S = this.words[G] | 0, A = W.words[G] | 0;
          if (S === A) continue;
          if (S < A) w = -1;
          else if (S > A) w = 1;
          break;
        }
        return w;
      }, O.prototype.gtn = function(W) {
        return this.cmpn(W) === 1;
      }, O.prototype.gt = function(W) {
        return this.cmp(W) === 1;
      }, O.prototype.gten = function(W) {
        return this.cmpn(W) >= 0;
      }, O.prototype.gte = function(W) {
        return this.cmp(W) >= 0;
      }, O.prototype.ltn = function(W) {
        return this.cmpn(W) === -1;
      }, O.prototype.lt = function(W) {
        return this.cmp(W) === -1;
      }, O.prototype.lten = function(W) {
        return this.cmpn(W) <= 0;
      }, O.prototype.lte = function(W) {
        return this.cmp(W) <= 0;
      }, O.prototype.eqn = function(W) {
        return this.cmpn(W) === 0;
      }, O.prototype.eq = function(W) {
        return this.cmp(W) === 0;
      }, O.red = function(W) {
        return new H(W);
      }, O.prototype.toRed = function(W) {
        return _(!this.red, "Already a number in reduction context"), _(this.negative === 0, "red works only with positives"), W.convertTo(this)._forceRed(W);
      }, O.prototype.fromRed = function() {
        return _(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, O.prototype._forceRed = function(W) {
        return this.red = W, this;
      }, O.prototype.forceRed = function(W) {
        return _(!this.red, "Already a number in reduction context"), this._forceRed(W);
      }, O.prototype.redAdd = function(W) {
        return _(this.red, "redAdd works only with red numbers"), this.red.add(this, W);
      }, O.prototype.redIAdd = function(W) {
        return _(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, W);
      }, O.prototype.redSub = function(W) {
        return _(this.red, "redSub works only with red numbers"), this.red.sub(this, W);
      }, O.prototype.redISub = function(W) {
        return _(this.red, "redISub works only with red numbers"), this.red.isub(this, W);
      }, O.prototype.redShl = function(W) {
        return _(this.red, "redShl works only with red numbers"), this.red.shl(this, W);
      }, O.prototype.redMul = function(W) {
        return _(this.red, "redMul works only with red numbers"), this.red._verify2(this, W), this.red.mul(this, W);
      }, O.prototype.redIMul = function(W) {
        return _(this.red, "redMul works only with red numbers"), this.red._verify2(this, W), this.red.imul(this, W);
      }, O.prototype.redSqr = function() {
        return _(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, O.prototype.redISqr = function() {
        return _(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, O.prototype.redSqrt = function() {
        return _(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, O.prototype.redInvm = function() {
        return _(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, O.prototype.redNeg = function() {
        return _(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, O.prototype.redPow = function(W) {
        return _(this.red && !W.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, W);
      };
      var n = { k256: null, p224: null, p192: null, p25519: null };
      function s(W, w) {
        this.name = W, this.p = new O(w, 16), this.n = this.p.bitLength(), this.k = new O(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      __name(s, "s");
      s.prototype._tmp = function() {
        var W = new O(null);
        return W.words = Array(Math.ceil(this.n / 13)), W;
      }, s.prototype.ireduce = function(W) {
        var w = W, G;
        do
          this.split(w, this.tmp), w = this.imulK(w), w = w.iadd(this.tmp), G = w.bitLength();
        while (G > this.n);
        var S = G < this.n ? -1 : w.ucmp(this.p);
        if (S === 0) w.words[0] = 0, w.length = 1;
        else if (S > 0) w.isub(this.p);
        else if (w.strip !== void 0) w.strip();
        else w._strip();
        return w;
      }, s.prototype.split = function(W, w) {
        W.iushrn(this.n, 0, w);
      }, s.prototype.imulK = function(W) {
        return W.imul(this.k);
      };
      function q$() {
        s.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
      }
      __name(q$, "q$");
      Y(q$, s), q$.prototype.split = function(W, w) {
        var G = 4194303, S = Math.min(W.length, 9);
        for (var A = 0; A < S; A++) w.words[A] = W.words[A];
        if (w.length = S, W.length <= 9) {
          W.words[0] = 0, W.length = 1;
          return;
        }
        var v = W.words[9];
        w.words[w.length++] = v & G;
        for (A = 10; A < W.length; A++) {
          var k = W.words[A] | 0;
          W.words[A - 10] = (k & G) << 4 | v >>> 22, v = k;
        }
        if (v >>>= 22, W.words[A - 10] = v, v === 0 && W.length > 10) W.length -= 10;
        else W.length -= 9;
      }, q$.prototype.imulK = function(W) {
        W.words[W.length] = 0, W.words[W.length + 1] = 0, W.length += 2;
        var w = 0;
        for (var G = 0; G < W.length; G++) {
          var S = W.words[G] | 0;
          w += S * 977, W.words[G] = w & 67108863, w = S * 64 + (w / 67108864 | 0);
        }
        if (W.words[W.length - 1] === 0) {
          if (W.length--, W.words[W.length - 1] === 0) W.length--;
        }
        return W;
      };
      function c() {
        s.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
      }
      __name(c, "c");
      Y(c, s);
      function U() {
        s.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
      }
      __name(U, "U");
      Y(U, s);
      function j() {
        s.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
      }
      __name(j, "j");
      Y(j, s), j.prototype.imulK = function(W) {
        var w = 0;
        for (var G = 0; G < W.length; G++) {
          var S = (W.words[G] | 0) * 19 + w, A = S & 67108863;
          S >>>= 26, W.words[G] = A, w = S;
        }
        if (w !== 0) W.words[W.length++] = w;
        return W;
      }, O._prime = function(W) {
        if (n[W]) return n[W];
        var w;
        if (W === "k256") w = new q$();
        else if (W === "p224") w = new c();
        else if (W === "p192") w = new U();
        else if (W === "p25519") w = new j();
        else throw Error("Unknown prime " + W);
        return n[W] = w, w;
      };
      function H(W) {
        if (typeof W === "string") {
          var w = O._prime(W);
          this.m = w.p, this.prime = w;
        } else _(W.gtn(1), "modulus must be greater than 1"), this.m = W, this.prime = null;
      }
      __name(H, "H");
      H.prototype._verify1 = function(W) {
        _(W.negative === 0, "red works only with positives"), _(W.red, "red works only with red numbers");
      }, H.prototype._verify2 = function(W, w) {
        _((W.negative | w.negative) === 0, "red works only with positives"), _(W.red && W.red === w.red, "red works only with red numbers");
      }, H.prototype.imod = function(W) {
        if (this.prime) return this.prime.ireduce(W)._forceRed(this);
        return f(W, W.umod(this.m)._forceRed(this)), W;
      }, H.prototype.neg = function(W) {
        if (W.isZero()) return W.clone();
        return this.m.sub(W)._forceRed(this);
      }, H.prototype.add = function(W, w) {
        this._verify2(W, w);
        var G = W.add(w);
        if (G.cmp(this.m) >= 0) G.isub(this.m);
        return G._forceRed(this);
      }, H.prototype.iadd = function(W, w) {
        this._verify2(W, w);
        var G = W.iadd(w);
        if (G.cmp(this.m) >= 0) G.isub(this.m);
        return G;
      }, H.prototype.sub = function(W, w) {
        this._verify2(W, w);
        var G = W.sub(w);
        if (G.cmpn(0) < 0) G.iadd(this.m);
        return G._forceRed(this);
      }, H.prototype.isub = function(W, w) {
        this._verify2(W, w);
        var G = W.isub(w);
        if (G.cmpn(0) < 0) G.iadd(this.m);
        return G;
      }, H.prototype.shl = function(W, w) {
        return this._verify1(W), this.imod(W.ushln(w));
      }, H.prototype.imul = function(W, w) {
        return this._verify2(W, w), this.imod(W.imul(w));
      }, H.prototype.mul = function(W, w) {
        return this._verify2(W, w), this.imod(W.mul(w));
      }, H.prototype.isqr = function(W) {
        return this.imul(W, W.clone());
      }, H.prototype.sqr = function(W) {
        return this.mul(W, W);
      }, H.prototype.sqrt = function(W) {
        if (W.isZero()) return W.clone();
        var w = this.m.andln(3);
        if (_(w % 2 === 1), w === 3) {
          var G = this.m.add(new O(1)).iushrn(2);
          return this.pow(W, G);
        }
        var S = this.m.subn(1), A = 0;
        while (!S.isZero() && S.andln(1) === 0) A++, S.iushrn(1);
        _(!S.isZero());
        var v = new O(1).toRed(this), k = v.redNeg(), R = this.m.subn(1).iushrn(1), C = this.m.bitLength();
        C = new O(2 * C * C).toRed(this);
        while (this.pow(C, R).cmp(k) !== 0) C.redIAdd(k);
        var L = this.pow(C, S), x = this.pow(W, S.addn(1).iushrn(1)), l = this.pow(W, S), a = A;
        while (l.cmp(v) !== 0) {
          var f$ = l;
          for (var $$ = 0; f$.cmp(v) !== 0; $$++) f$ = f$.redSqr();
          _($$ < a);
          var t = this.pow(L, new O(1).iushln(a - $$ - 1));
          x = x.redMul(t), L = t.redSqr(), l = l.redMul(L), a = $$;
        }
        return x;
      }, H.prototype.invm = function(W) {
        var w = W._invmp(this.m);
        if (w.negative !== 0) return w.negative = 0, this.imod(w).redNeg();
        else return this.imod(w);
      }, H.prototype.pow = function(W, w) {
        if (w.isZero()) return new O(1).toRed(this);
        if (w.cmpn(1) === 0) return W.clone();
        var G = 4, S = Array(1 << G);
        S[0] = new O(1).toRed(this), S[1] = W;
        for (var A = 2; A < S.length; A++) S[A] = this.mul(S[A - 1], W);
        var v = S[0], k = 0, R = 0, C = w.bitLength() % 26;
        if (C === 0) C = 26;
        for (A = w.length - 1; A >= 0; A--) {
          var L = w.words[A];
          for (var x = C - 1; x >= 0; x--) {
            var l = L >> x & 1;
            if (v !== S[0]) v = this.sqr(v);
            if (l === 0 && k === 0) {
              R = 0;
              continue;
            }
            if (k <<= 1, k |= l, R++, R !== G && (A !== 0 || x !== 0)) continue;
            v = this.mul(v, S[k]), R = 0, k = 0;
          }
          C = 26;
        }
        return v;
      }, H.prototype.convertTo = function(W) {
        var w = W.umod(this.m);
        return w === W ? w.clone() : w;
      }, H.prototype.convertFrom = function(W) {
        var w = W.clone();
        return w.red = null, w;
      }, O.mont = function(W) {
        return new Z(W);
      };
      function Z(W) {
        if (H.call(this, W), this.shift = this.m.bitLength(), this.shift % 26 !== 0) this.shift += 26 - this.shift % 26;
        this.r = new O(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      __name(Z, "Z");
      Y(Z, H), Z.prototype.convertTo = function(W) {
        return this.imod(W.ushln(this.shift));
      }, Z.prototype.convertFrom = function(W) {
        var w = this.imod(W.mul(this.rinv));
        return w.red = null, w;
      }, Z.prototype.imul = function(W, w) {
        if (W.isZero() || w.isZero()) return W.words[0] = 0, W.length = 1, W;
        var G = W.imul(w), S = G.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), A = G.isub(S).iushrn(this.shift), v = A;
        if (A.cmp(this.m) >= 0) v = A.isub(this.m);
        else if (A.cmpn(0) < 0) v = A.iadd(this.m);
        return v._forceRed(this);
      }, Z.prototype.mul = function(W, w) {
        if (W.isZero() || w.isZero()) return new O(0)._forceRed(this);
        var G = W.mul(w), S = G.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), A = G.isub(S).iushrn(this.shift), v = A;
        if (A.cmp(this.m) >= 0) v = A.isub(this.m);
        else if (A.cmpn(0) < 0) v = A.iadd(this.m);
        return v._forceRed(this);
      }, Z.prototype.invm = function(W) {
        var w = this.imod(W._invmp(this.m).mul(this.r2));
        return w._forceRed(this);
      };
    })(typeof q > "u" || q, $);
  }), M0 = r$(($, q) => {
    var K = lo(), P = jO(), _ = q8().Buffer;
    function Y(J) {
      var T = J.modulus.byteLength(), X;
      do
        X = new K(P(T));
      while (X.cmp(J.modulus) >= 0 || !X.umod(J.prime1) || !X.umod(J.prime2));
      return X;
    }
    __name(Y, "Y");
    function O(J) {
      var T = Y(J), X = T.toRed(K.mont(J.modulus)).redPow(new K(J.publicExponent)).fromRed();
      return { blinder: X, unblinder: T.invm(J.modulus) };
    }
    __name(O, "O");
    function z(J, T) {
      var X = O(T), f = T.modulus.byteLength(), V = new K(J).mul(X.blinder).umod(T.modulus), M = V.toRed(K.mont(T.prime1)), N = V.toRed(K.mont(T.prime2)), E = T.coefficient, h = T.prime1, I = T.prime2, D = M.redPow(T.exponent1).fromRed(), g = N.redPow(T.exponent2).fromRed(), b = D.isub(g).imul(E).umod(h).imul(I);
      return g.iadd(b).imul(X.unblinder).umod(T.modulus).toArrayLike(_, "be", f);
    }
    __name(z, "z");
    z.getr = Y, q.exports = z;
  }), ro = r$(($, q) => {
    var K = k0(), P = jO(), _ = vO(), Y = G0(), O = V0(), z = BH(), J = S0(), T = M0(), X = q8().Buffer;
    q.exports = function(N, E, h) {
      var I;
      if (N.padding) I = N.padding;
      else if (h) I = 1;
      else I = 4;
      var D = K(N), g;
      if (I === 4) g = f(D, E);
      else if (I === 1) g = V(D, E, h);
      else if (I === 3) {
        if (g = new z(E), g.cmp(D.modulus) >= 0) throw Error("data too long for modulus");
      } else throw Error("unknown padding");
      if (h) return T(g, D);
      else return J(g, D);
    };
    function f(N, E) {
      var h = N.modulus.byteLength(), I = E.length, D = _("sha1").update(X.alloc(0)).digest(), g = D.length, b = 2 * g;
      if (I > h - b - 2) throw Error("message too long");
      var y = X.alloc(h - I - b - 2), p = h - g - 1, n = P(g), s = O(X.concat([D, y, X.alloc(1, 1), E], p), Y(n, p)), q$ = O(n, Y(s, g));
      return new z(X.concat([X.alloc(1), q$, s], h));
    }
    __name(f, "f");
    function V(N, E, h) {
      var I = E.length, D = N.modulus.byteLength();
      if (I > D - 11) throw Error("message too long");
      var g;
      if (h) g = X.alloc(D - I - 3, 255);
      else g = M(D - I - 3);
      return new z(X.concat([X.from([0, h ? 1 : 2]), g, X.alloc(1), E], D));
    }
    __name(V, "V");
    function M(N) {
      var E = X.allocUnsafe(N), h = 0, I = P(N * 2), D = 0, g;
      while (h < N) {
        if (D === I.length) I = P(N * 2), D = 0;
        if (g = I[D++], g) E[h++] = g;
      }
      return E;
    }
    __name(M, "M");
  }), oo = r$(($, q) => {
    var K = k0(), P = G0(), _ = V0(), Y = BH(), O = M0(), z = vO(), J = S0(), T = q8().Buffer;
    q.exports = function(M, N, E) {
      var h;
      if (M.padding) h = M.padding;
      else if (E) h = 1;
      else h = 4;
      var I = K(M), D = I.modulus.byteLength();
      if (N.length > D || new Y(N).cmp(I.modulus) >= 0) throw Error("decryption error");
      var g;
      if (E) g = J(new Y(N), I);
      else g = O(N, I);
      var b = T.alloc(D - g.length);
      if (g = T.concat([b, g], D), h === 4) return X(I, g);
      else if (h === 1) return f(I, g, E);
      else if (h === 3) return g;
      else throw Error("unknown padding");
    };
    function X(M, N) {
      var E = M.modulus.byteLength(), h = z("sha1").update(T.alloc(0)).digest(), I = h.length;
      if (N[0] !== 0) throw Error("decryption error");
      var D = N.slice(1, I + 1), g = N.slice(I + 1), b = _(D, P(g, I)), y = _(g, P(b, E - I - 1));
      if (V(h, y.slice(0, I))) throw Error("decryption error");
      var p = I;
      while (y[p] === 0) p++;
      if (y[p++] !== 1) throw Error("decryption error");
      return y.slice(p);
    }
    __name(X, "X");
    function f(M, N, E) {
      var h = N.slice(0, 2), I = 2, D = 0;
      while (N[I++] !== 0) if (I >= N.length) {
        D++;
        break;
      }
      var g = N.slice(2, I - 1);
      if (h.toString("hex") !== "0002" && !E || h.toString("hex") !== "0001" && E) D++;
      if (g.length < 8) D++;
      if (D) throw Error("decryption error");
      return N.slice(I);
    }
    __name(f, "f");
    function V(M, N) {
      M = T.from(M), N = T.from(N);
      var E = 0, h = M.length;
      if (M.length !== N.length) E++, h = Math.min(M.length, N.length);
      var I = -1;
      while (++I < h) E += M[I] ^ N[I];
      return E;
    }
    __name(V, "V");
  }), lH = r$(($) => {
    $.publicEncrypt = ro(), $.privateDecrypt = oo(), $.privateEncrypt = function(q, K) {
      return $.publicEncrypt(q, K, true);
    }, $.publicDecrypt = function(q, K) {
      return $.privateDecrypt(q, K, true);
    };
  }), no = r$(($) => {
    var q = (lq(), J6(dq));
    if (typeof q.publicEncrypt !== "function") q = lH();
    if ($.publicEncrypt = q.publicEncrypt, $.privateDecrypt = q.privateDecrypt, typeof q.privateEncrypt !== "function") $.privateEncrypt = lH().privateEncrypt;
    else $.privateEncrypt = q.privateEncrypt;
    if (typeof q.publicDecrypt !== "function") $.publicDecrypt = lH().publicDecrypt;
    else $.publicDecrypt = q.publicDecrypt;
  }), io = r$(($) => {
    var q = q8(), K = jO(), P = q.Buffer, _ = q.kMaxLength, Y = globalThis.crypto || globalThis.msCrypto, O = Math.pow(2, 32) - 1;
    function z(V, M) {
      if (typeof V !== "number" || V !== V) throw TypeError("offset must be a number");
      if (V > O || V < 0) throw TypeError("offset must be a uint32");
      if (V > _ || V > M) throw RangeError("offset out of range");
    }
    __name(z, "z");
    function J(V, M, N) {
      if (typeof V !== "number" || V !== V) throw TypeError("size must be a number");
      if (V > O || V < 0) throw TypeError("size must be a uint32");
      if (V + M > N || V > _) throw RangeError("buffer too small");
    }
    __name(J, "J");
    Y && Y.getRandomValues, $.randomFill = T, $.randomFillSync = f;
    function T(V, M, N, E) {
      if (!P.isBuffer(V) && !(V instanceof globalThis.Uint8Array)) throw TypeError('"buf" argument must be a Buffer or Uint8Array');
      if (typeof M === "function") E = M, M = 0, N = V.length;
      else if (typeof N === "function") E = N, N = V.length - M;
      else if (typeof E !== "function") throw TypeError('"cb" argument must be a function');
      return z(M, V.length), J(N, M, V.length), X(V, M, N, E);
    }
    __name(T, "T");
    function X(V, M, N, E) {
      if (false) var h, I;
      if (E) {
        K(N, function(g, b) {
          if (g) return E(g);
          b.copy(V, M), E(null, V);
        });
        return;
      }
      var D = K(N);
      return D.copy(V, M), V;
    }
    __name(X, "X");
    function f(V, M, N) {
      if (typeof M > "u") M = 0;
      if (!P.isBuffer(V) && !(V instanceof globalThis.Uint8Array)) throw TypeError('"buf" argument must be a Buffer or Uint8Array');
      if (z(M, V.length), N === void 0) N = V.length - M;
      return J(N, M, V.length), X(V, M, N);
    }
    __name(f, "f");
  }), to = r$(($, q) => {
    var K = (lq(), J6(dq));
    if (typeof K.randomFill === "function" && typeof K.randomFillSync === "function") $.randomFill = K.randomFill, $.randomFillSync = K.randomFillSync;
    else q.exports = io();
  }), Bo = r$(($) => {
    $.randomBytes = $.rng = $.pseudoRandomBytes = $.prng = jO(), $.createHash = $.Hash = vO(), $.createHmac = $.Hmac = Y0();
    var q = ar(), K = Object.keys(q), P = ["sha1", "sha224", "sha256", "sha384", "sha512", "md5", "rmd160"].concat(K);
    $.getHashes = function() {
      return P;
    };
    var _ = v0();
    $.pbkdf2 = _.pbkdf2, $.pbkdf2Sync = _.pbkdf2Sync;
    var Y = er();
    $.Cipher = Y.Cipher, $.createCipher = Y.createCipher, $.Cipheriv = Y.Cipheriv, $.createCipheriv = Y.createCipheriv, $.Decipher = Y.Decipher, $.createDecipher = Y.createDecipher, $.Decipheriv = Y.Decipheriv, $.createDecipheriv = Y.createDecipheriv, $.getCiphers = Y.getCiphers, $.listCiphers = Y.listCiphers;
    var O = sr();
    $.DiffieHellmanGroup = O.DiffieHellmanGroup, $.createDiffieHellmanGroup = O.createDiffieHellmanGroup, $.getDiffieHellman = O.getDiffieHellman, $.createDiffieHellman = O.createDiffieHellman, $.DiffieHellman = O.DiffieHellman;
    var z = $o();
    $.createSign = z.createSign, $.Sign = z.Sign, $.createVerify = z.createVerify, $.Verify = z.Verify, $.createECDH = Mo();
    var J = no();
    $.publicEncrypt = J.publicEncrypt, $.privateEncrypt = J.privateEncrypt, $.publicDecrypt = J.publicDecrypt, $.privateDecrypt = J.privateDecrypt;
    var T = to();
    $.randomFill = T.randomFill, $.randomFillSync = T.randomFillSync, $.createCredentials = function() {
      throw Error(`sorry, createCredentials is not implemented yet
we accept pull requests
https://github.com/browserify/crypto-browserify`);
    }, $.constants = { DH_CHECK_P_NOT_SAFE_PRIME: 2, DH_CHECK_P_NOT_PRIME: 1, DH_UNABLE_TO_CHECK_GENERATOR: 4, DH_NOT_SUITABLE_GENERATOR: 8, NPN_ENABLED: 1, ALPN_ENABLED: 1, RSA_PKCS1_PADDING: 1, RSA_SSLV23_PADDING: 2, RSA_NO_PADDING: 3, RSA_PKCS1_OAEP_PADDING: 4, RSA_X931_PADDING: 5, RSA_PKCS1_PSS_PADDING: 6, POINT_CONVERSION_COMPRESSED: 2, POINT_CONVERSION_UNCOMPRESSED: 4, POINT_CONVERSION_HYBRID: 6 };
  }), f6 = Fr(Bo(), 1), Uo = f6.prng, Fo = f6.pseudoRandomBytes, ao = f6.rng, Qo = f6.randomBytes, eo = f6.Hash, so = f6.createHash, $n = f6.Hmac, qn = f6.createHmac, Kn = f6.getHashes, _n = f6.pbkdf2, Pn = f6.pbkdf2Sync, On = f6.Cipher, Yn = f6.createCipher, jn = f6.Cipheriv, vn = f6.createCipheriv, zn = f6.Decipher, Wn = f6.createDecipher, Hn = f6.Decipheriv, Jn = f6.createDecipheriv, Tn = f6.getCiphers, wn = f6.listCiphers, fn = f6.DiffieHellmanGroup, Zn = f6.createDiffieHellmanGroup, Xn = f6.getDiffieHellman, An = f6.createDiffieHellman, kn = f6.DiffieHellman, Gn = f6.createSign, Vn = f6.Sign, Sn = f6.createVerify, Mn = f6.Verify, Nn = f6.createECDH, Cn = f6.publicEncrypt, hn = f6.privateEncrypt, En = f6.publicDecrypt, Rn = f6.privateDecrypt, In = f6.randomFill, Dn = f6.randomFillSync, Ln = f6.createCredentials, gn = f6.constants, xn = ["p192", "p224", "p256", "p384", "p521", "curve25519", "ed25519", "secp256k1", "secp224r1", "prime256v1", "prime192v1", "ed25519", "secp384r1", "secp521r1"];
  cn = crypto, mn = crypto;
});
var N0 = x$((gP$, dn) => {
  dn.exports = { name: "dotenv", version: "17.2.3", description: "Loads environment variables from .env file", main: "lib/main.js", types: "lib/main.d.ts", exports: { ".": { types: "./lib/main.d.ts", require: "./lib/main.js", default: "./lib/main.js" }, "./config": "./config.js", "./config.js": "./config.js", "./lib/env-options": "./lib/env-options.js", "./lib/env-options.js": "./lib/env-options.js", "./lib/cli-options": "./lib/cli-options.js", "./lib/cli-options.js": "./lib/cli-options.js", "./package.json": "./package.json" }, scripts: { "dts-check": "tsc --project tests/types/tsconfig.json", lint: "standard", pretest: "npm run lint && npm run dts-check", test: "tap run tests/**/*.js --allow-empty-coverage --disable-coverage --timeout=60000", "test:coverage": "tap run tests/**/*.js --show-full-coverage --timeout=60000 --coverage-report=text --coverage-report=lcov", prerelease: "npm test", release: "standard-version" }, repository: { type: "git", url: "git://github.com/motdotla/dotenv.git" }, homepage: "https://github.com/motdotla/dotenv#readme", funding: "https://dotenvx.com", keywords: ["dotenv", "env", ".env", "environment", "variables", "config", "settings"], readmeFilename: "README.md", license: "BSD-2-Clause", devDependencies: { "@types/node": "^18.11.3", decache: "^4.6.2", sinon: "^14.0.1", standard: "^17.0.0", "standard-version": "^9.5.0", tap: "^19.2.0", typescript: "^4.8.4" }, engines: { node: ">=12" }, browser: { fs: false } };
});
var D0 = x$((bP$, hK) => {
  var UH = /* @__PURE__ */ __name((() => ({})), "UH"), WO = (TH(), J6(JH)), ln = (fH(), J6(wH)), rn = (lq(), J6(dq)), on = N0(), FH = on.version, C0 = [" encrypt with Dotenvx: https://dotenvx.com", " prevent committing .env to code: https://dotenvx.com/precommit", " prevent building .env in docker: https://dotenvx.com/prebuild", " add observability to secrets: https://dotenvx.com/ops", " sync secrets across teammates & machines: https://dotenvx.com/ops", " backup and recover secrets: https://dotenvx.com/ops", " audit secrets and track compliance: https://dotenvx.com/ops", " add secrets lifecycle management: https://dotenvx.com/ops", " add access controls to secrets: https://dotenvx.com/ops", "  run anywhere with `dotenvx run -- yourcommand`", "  specify custom .env file path with { path: '/custom/path/.env' }", "  enable debug logging with { debug: true }", "  override existing env vars with { override: true }", "  suppress all logs with { quiet: true }", "  write to custom object with { processEnv: myObject }", "  load multiple .env files with { path: ['.env.local', '.env'] }"];
  function nn() {
    return C0[Math.floor(Math.random() * C0.length)];
  }
  __name(nn, "nn");
  function l4($) {
    if (typeof $ === "string") return !["false", "0", "no", "off", ""].includes($.toLowerCase());
    return Boolean($);
  }
  __name(l4, "l4");
  function tn() {
    return process.stdout.isTTY;
  }
  __name(tn, "tn");
  function Bn($) {
    return tn() ? `\x1B[2m${$}\x1B[0m` : $;
  }
  __name(Bn, "Bn");
  var Un = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg;
  function Fn($) {
    let q = {}, K = $.toString();
    K = K.replace(/\r\n?/mg, `
`);
    let P;
    while ((P = Un.exec(K)) != null) {
      let _ = P[1], Y = P[2] || "";
      Y = Y.trim();
      let O = Y[0];
      if (Y = Y.replace(/^(['"`])([\s\S]*)\1$/mg, "$2"), O === '"') Y = Y.replace(/\\n/g, `
`), Y = Y.replace(/\\r/g, "\r");
      q[_] = Y;
    }
    return q;
  }
  __name(Fn, "Fn");
  function an($) {
    $ = $ || {};
    let q = I0($);
    $.path = q;
    let K = vq.configDotenv($);
    if (!K.parsed) {
      let O = Error(`MISSING_DATA: Cannot parse ${q} for an unknown reason`);
      throw O.code = "MISSING_DATA", O;
    }
    let P = R0($).split(","), _ = P.length, Y;
    for (let O = 0; O < _; O++) try {
      let z = P[O].trim(), J = en(K, z);
      Y = vq.decrypt(J.ciphertext, J.key);
      break;
    } catch (z) {
      if (O + 1 >= _) throw z;
    }
    return vq.parse(Y);
  }
  __name(an, "an");
  function Qn($) {
    console.error(`[dotenv@${FH}][WARN] ${$}`);
  }
  __name(Qn, "Qn");
  function a7($) {
    console.log(`[dotenv@${FH}][DEBUG] ${$}`);
  }
  __name(a7, "a7");
  function E0($) {
    console.log(`[dotenv@${FH}] ${$}`);
  }
  __name(E0, "E0");
  function R0($) {
    if ($ && $.DOTENV_KEY && $.DOTENV_KEY.length > 0) return $.DOTENV_KEY;
    if (process.env.DOTENV_KEY && process.env.DOTENV_KEY.length > 0) return process.env.DOTENV_KEY;
    return "";
  }
  __name(R0, "R0");
  function en($, q) {
    let K;
    try {
      K = new URL(q);
    } catch (z) {
      if (z.code === "ERR_INVALID_URL") {
        let J = Error("INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=development");
        throw J.code = "INVALID_DOTENV_KEY", J;
      }
      throw z;
    }
    let P = K.password;
    if (!P) {
      let z = Error("INVALID_DOTENV_KEY: Missing key part");
      throw z.code = "INVALID_DOTENV_KEY", z;
    }
    let _ = K.searchParams.get("environment");
    if (!_) {
      let z = Error("INVALID_DOTENV_KEY: Missing environment part");
      throw z.code = "INVALID_DOTENV_KEY", z;
    }
    let Y = `DOTENV_VAULT_${_.toUpperCase()}`, O = $.parsed[Y];
    if (!O) {
      let z = Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${Y} in your .env.vault file.`);
      throw z.code = "NOT_FOUND_DOTENV_ENVIRONMENT", z;
    }
    return { ciphertext: O, key: P };
  }
  __name(en, "en");
  function I0($) {
    let q = null;
    if ($ && $.path && $.path.length > 0) if (Array.isArray($.path)) {
      for (let K of $.path) if (UH.existsSync(K)) q = K.endsWith(".vault") ? K : `${K}.vault`;
    } else q = $.path.endsWith(".vault") ? $.path : `${$.path}.vault`;
    else q = WO.resolve(process.cwd(), ".env.vault");
    if (UH.existsSync(q)) return q;
    return null;
  }
  __name(I0, "I0");
  function h0($) {
    return $[0] === "~" ? WO.join(ln.homedir(), $.slice(1)) : $;
  }
  __name(h0, "h0");
  function sn($) {
    let q = l4(process.env.DOTENV_CONFIG_DEBUG || $ && $.debug), K = l4(process.env.DOTENV_CONFIG_QUIET || $ && $.quiet);
    if (q || !K) E0("Loading env from encrypted .env.vault");
    let P = vq._parseVault($), _ = process.env;
    if ($ && $.processEnv != null) _ = $.processEnv;
    return vq.populate(_, P, $), { parsed: P };
  }
  __name(sn, "sn");
  function $i($) {
    let q = WO.resolve(process.cwd(), ".env"), K = "utf8", P = process.env;
    if ($ && $.processEnv != null) P = $.processEnv;
    let _ = l4(P.DOTENV_CONFIG_DEBUG || $ && $.debug), Y = l4(P.DOTENV_CONFIG_QUIET || $ && $.quiet);
    if ($ && $.encoding) K = $.encoding;
    else if (_) a7("No encoding is specified. UTF-8 is used by default");
    let O = [q];
    if ($ && $.path) if (!Array.isArray($.path)) O = [h0($.path)];
    else {
      O = [];
      for (let X of $.path) O.push(h0(X));
    }
    let z, J = {};
    for (let X of O) try {
      let f = vq.parse(UH.readFileSync(X, { encoding: K }));
      vq.populate(J, f, $);
    } catch (f) {
      if (_) a7(`Failed to load ${X} ${f.message}`);
      z = f;
    }
    let T = vq.populate(P, J, $);
    if (_ = l4(P.DOTENV_CONFIG_DEBUG || _), Y = l4(P.DOTENV_CONFIG_QUIET || Y), _ || !Y) {
      let X = Object.keys(T).length, f = [];
      for (let V of O) try {
        let M = WO.relative(process.cwd(), V);
        f.push(M);
      } catch (M) {
        if (_) a7(`Failed to load ${V} ${M.message}`);
        z = M;
      }
      E0(`injecting env (${X}) from ${f.join(",")} ${Bn(`-- tip: ${nn()}`)}`);
    }
    if (z) return { parsed: J, error: z };
    else return { parsed: J };
  }
  __name($i, "$i");
  function qi($) {
    if (R0($).length === 0) return vq.configDotenv($);
    let q = I0($);
    if (!q) return Qn(`You set DOTENV_KEY but you are missing a .env.vault file at ${q}. Did you forget to build it?`), vq.configDotenv($);
    return vq._configVault($);
  }
  __name(qi, "qi");
  function Ki($, q) {
    let K = Buffer.from(q.slice(-64), "hex"), P = Buffer.from($, "base64"), _ = P.subarray(0, 12), Y = P.subarray(-16);
    P = P.subarray(12, -16);
    try {
      let O = rn.createDecipheriv("aes-256-gcm", K, _);
      return O.setAuthTag(Y), `${O.update(P)}${O.final()}`;
    } catch (O) {
      let z = O instanceof RangeError, J = O.message === "Invalid key length", T = O.message === "Unsupported state or unable to authenticate data";
      if (z || J) {
        let X = Error("INVALID_DOTENV_KEY: It must be 64 characters long (or more)");
        throw X.code = "INVALID_DOTENV_KEY", X;
      } else if (T) {
        let X = Error("DECRYPTION_FAILED: Please check your DOTENV_KEY");
        throw X.code = "DECRYPTION_FAILED", X;
      } else throw O;
    }
  }
  __name(Ki, "Ki");
  function _i($, q, K = {}) {
    let P = Boolean(K && K.debug), _ = Boolean(K && K.override), Y = {};
    if (typeof q !== "object") {
      let O = Error("OBJECT_REQUIRED: Please check the processEnv argument being passed to populate");
      throw O.code = "OBJECT_REQUIRED", O;
    }
    for (let O of Object.keys(q)) if (Object.prototype.hasOwnProperty.call($, O)) {
      if (_ === true) $[O] = q[O], Y[O] = q[O];
      if (P) if (_ === true) a7(`"${O}" is already defined and WAS overwritten`);
      else a7(`"${O}" is already defined and was NOT overwritten`);
    } else $[O] = q[O], Y[O] = q[O];
    return Y;
  }
  __name(_i, "_i");
  var vq = { configDotenv: $i, _configVault: sn, _parseVault: an, config: qi, decrypt: Ki, parse: Fn, populate: _i };
  bP$.configDotenv = vq.configDotenv;
  bP$._configVault = vq._configVault;
  bP$._parseVault = vq._parseVault;
  bP$.config = vq.config;
  bP$.decrypt = vq.decrypt;
  bP$.parse = vq.parse;
  bP$.populate = vq.populate;
  hK.exports = vq;
});
var B0 = x$((q7$, KJ) => {
  var W6 = String, t0 = /* @__PURE__ */ __name(function() {
    return { isColorSupported: false, reset: W6, bold: W6, dim: W6, italic: W6, underline: W6, inverse: W6, hidden: W6, strikethrough: W6, black: W6, red: W6, green: W6, yellow: W6, blue: W6, magenta: W6, cyan: W6, white: W6, gray: W6, bgBlack: W6, bgRed: W6, bgGreen: W6, bgYellow: W6, bgBlue: W6, bgMagenta: W6, bgCyan: W6, bgWhite: W6, blackBright: W6, redBright: W6, greenBright: W6, yellowBright: W6, blueBright: W6, magentaBright: W6, cyanBright: W6, whiteBright: W6, bgBlackBright: W6, bgRedBright: W6, bgGreenBright: W6, bgYellowBright: W6, bgBlueBright: W6, bgMagentaBright: W6, bgCyanBright: W6, bgWhiteBright: W6 };
  }, "t0");
  KJ.exports = t0();
  KJ.exports.createColors = t0;
});
function W1($) {
  if (!$ || !/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test($)) throw Error(`Invalid UUID format: ${$}`);
  return $;
}
__name(W1, "W1");
var KP;
((Y) => {
  Y.IMAGE = "image";
  Y.VIDEO = "video";
  Y.AUDIO = "audio";
  Y.DOCUMENT = "document";
  Y.LINK = "link";
})(KP ||= {});
var iM;
((Y) => {
  Y.DOCUMENT = "document";
  Y.FRAGMENT = "fragment";
  Y.MESSAGE = "message";
  Y.DESCRIPTION = "description";
  Y.CUSTOM = "custom";
})(iM ||= {});
var tM;
((P) => {
  P.OWNER = "OWNER";
  P.ADMIN = "ADMIN";
  P.NONE = "NONE";
})(tM ||= {});
var _P;
((X) => {
  X.SELF = "SELF";
  X.DM = "DM";
  X.GROUP = "GROUP";
  X.VOICE_DM = "VOICE_DM";
  X.VOICE_GROUP = "VOICE_GROUP";
  X.FEED = "FEED";
  X.THREAD = "THREAD";
  X.WORLD = "WORLD";
  X.FORUM = "FORUM";
  X.API = "API";
})(_P ||= {});
var BM;
((K) => {
  K.ACTIVE = "active";
  K.INACTIVE = "inactive";
})(BM ||= {});
var tt = { TRANSCRIPTION: "transcription", VIDEO: "video", BROWSER: "browser", PDF: "pdf", REMOTE_FILES: "aws_s3", WEB_SEARCH: "web_search", EMAIL: "email", TEE: "tee", TASK: "task", WALLET: "wallet", LP_POOL: "lp_pool", TOKEN_DATA: "token_data", MESSAGE_SERVICE: "message_service", MESSAGE: "message", POST: "post", UNKNOWN: "unknown" };
var _LO = class _LO {
  runtime;
  constructor($) {
    if ($) this.runtime = $;
  }
  config;
  static async start($) {
    throw Error("Not implemented");
  }
  static async stop($) {
    throw Error("Not implemented");
  }
};
__name(_LO, "LO");
__publicField(_LO, "serviceType");
var LO = _LO;
function Bt($, q) {
  return $.getService(q);
}
__name(Bt, "Bt");
function Ut($, q = "UNKNOWN_ERROR") {
  if ($ instanceof Error) return { code: q, message: $.message, cause: $ };
  return { code: q, message: String($) };
}
__name(Ut, "Ut");
var M6 = { SMALL: "TEXT_SMALL", MEDIUM: "TEXT_LARGE", LARGE: "TEXT_LARGE", TEXT_SMALL: "TEXT_SMALL", TEXT_LARGE: "TEXT_LARGE", TEXT_EMBEDDING: "TEXT_EMBEDDING", TEXT_TOKENIZER_ENCODE: "TEXT_TOKENIZER_ENCODE", TEXT_TOKENIZER_DECODE: "TEXT_TOKENIZER_DECODE", TEXT_REASONING_SMALL: "REASONING_SMALL", TEXT_REASONING_LARGE: "REASONING_LARGE", TEXT_COMPLETION: "TEXT_COMPLETION", IMAGE: "IMAGE", IMAGE_DESCRIPTION: "IMAGE_DESCRIPTION", TRANSCRIPTION: "TRANSCRIPTION", TEXT_TO_SPEECH: "TEXT_TO_SPEECH", AUDIO: "AUDIO", VIDEO: "VIDEO", OBJECT_SMALL: "OBJECT_SMALL", OBJECT_LARGE: "OBJECT_LARGE" };
var PP = { DEFAULT_MAX_TOKENS: "DEFAULT_MAX_TOKENS", DEFAULT_TEMPERATURE: "DEFAULT_TEMPERATURE", DEFAULT_FREQUENCY_PENALTY: "DEFAULT_FREQUENCY_PENALTY", DEFAULT_PRESENCE_PENALTY: "DEFAULT_PRESENCE_PENALTY", TEXT_SMALL_MAX_TOKENS: "TEXT_SMALL_MAX_TOKENS", TEXT_SMALL_TEMPERATURE: "TEXT_SMALL_TEMPERATURE", TEXT_SMALL_FREQUENCY_PENALTY: "TEXT_SMALL_FREQUENCY_PENALTY", TEXT_SMALL_PRESENCE_PENALTY: "TEXT_SMALL_PRESENCE_PENALTY", TEXT_LARGE_MAX_TOKENS: "TEXT_LARGE_MAX_TOKENS", TEXT_LARGE_TEMPERATURE: "TEXT_LARGE_TEMPERATURE", TEXT_LARGE_FREQUENCY_PENALTY: "TEXT_LARGE_FREQUENCY_PENALTY", TEXT_LARGE_PRESENCE_PENALTY: "TEXT_LARGE_PRESENCE_PENALTY", OBJECT_SMALL_MAX_TOKENS: "OBJECT_SMALL_MAX_TOKENS", OBJECT_SMALL_TEMPERATURE: "OBJECT_SMALL_TEMPERATURE", OBJECT_SMALL_FREQUENCY_PENALTY: "OBJECT_SMALL_FREQUENCY_PENALTY", OBJECT_SMALL_PRESENCE_PENALTY: "OBJECT_SMALL_PRESENCE_PENALTY", OBJECT_LARGE_MAX_TOKENS: "OBJECT_LARGE_MAX_TOKENS", OBJECT_LARGE_TEMPERATURE: "OBJECT_LARGE_TEMPERATURE", OBJECT_LARGE_FREQUENCY_PENALTY: "OBJECT_LARGE_FREQUENCY_PENALTY", OBJECT_LARGE_PRESENCE_PENALTY: "OBJECT_LARGE_PRESENCE_PENALTY", MODEL_MAX_TOKEN: "MODEL_MAX_TOKEN", MODEL_TEMPERATURE: "MODEL_TEMPERATURE", MODEL_FREQ_PENALTY: "MODEL_FREQ_PENALTY", MODEL_PRESENCE_PENALTY: "MODEL_PRESENCE_PENALTY" };
var Qt = { SMALL: 384, MEDIUM: 512, LARGE: 768, XL: 1024, XXL: 1536, XXXL: 3072 };
var gO;
((j) => {
  j.WORLD_JOINED = "WORLD_JOINED";
  j.WORLD_CONNECTED = "WORLD_CONNECTED";
  j.WORLD_LEFT = "WORLD_LEFT";
  j.ENTITY_JOINED = "ENTITY_JOINED";
  j.ENTITY_LEFT = "ENTITY_LEFT";
  j.ENTITY_UPDATED = "ENTITY_UPDATED";
  j.ROOM_JOINED = "ROOM_JOINED";
  j.ROOM_LEFT = "ROOM_LEFT";
  j.MESSAGE_RECEIVED = "MESSAGE_RECEIVED";
  j.MESSAGE_SENT = "MESSAGE_SENT";
  j.MESSAGE_DELETED = "MESSAGE_DELETED";
  j.CHANNEL_CLEARED = "CHANNEL_CLEARED";
  j.VOICE_MESSAGE_RECEIVED = "VOICE_MESSAGE_RECEIVED";
  j.VOICE_MESSAGE_SENT = "VOICE_MESSAGE_SENT";
  j.REACTION_RECEIVED = "REACTION_RECEIVED";
  j.POST_GENERATED = "POST_GENERATED";
  j.INTERACTION_RECEIVED = "INTERACTION_RECEIVED";
  j.RUN_STARTED = "RUN_STARTED";
  j.RUN_ENDED = "RUN_ENDED";
  j.RUN_TIMEOUT = "RUN_TIMEOUT";
  j.ACTION_STARTED = "ACTION_STARTED";
  j.ACTION_COMPLETED = "ACTION_COMPLETED";
  j.EVALUATOR_STARTED = "EVALUATOR_STARTED";
  j.EVALUATOR_COMPLETED = "EVALUATOR_COMPLETED";
  j.MODEL_USED = "MODEL_USED";
  j.EMBEDDING_GENERATION_REQUESTED = "EMBEDDING_GENERATION_REQUESTED";
  j.EMBEDDING_GENERATION_COMPLETED = "EMBEDDING_GENERATION_COMPLETED";
  j.EMBEDDING_GENERATION_FAILED = "EMBEDDING_GENERATION_FAILED";
})(gO ||= {});
var UM;
((P) => {
  P.DISCORD = "DISCORD";
  P.TELEGRAM = "TELEGRAM";
  P.TWITTER = "TWITTER";
})(UM ||= {});
var FM;
((_) => {
  _.OFF = "OFF";
  _.LOCAL = "LOCAL";
  _.DOCKER = "DOCKER";
  _.PRODUCTION = "PRODUCTION";
})(FM ||= {});
var aM;
((q) => q.TDX_DSTACK = "tdx_dstack")(aM ||= {});
var QM;
((O) => {
  O[O.ROOM_JOINING = 1] = "ROOM_JOINING";
  O[O.SEND_MESSAGE = 2] = "SEND_MESSAGE";
  O[O.MESSAGE = 3] = "MESSAGE";
  O[O.ACK = 4] = "ACK";
  O[O.THINKING = 5] = "THINKING";
  O[O.CONTROL = 6] = "CONTROL";
})(QM ||= {});
var eM = Object.defineProperty;
var Z6 = /* @__PURE__ */ __name(($, q) => {
  for (var K in q) eM($, K, { get: q[K], enumerable: true });
}, "Z6");
var _a;
var H1 = (_a = class {
  pageContent;
  metadata;
  id;
  constructor($) {
    this.pageContent = $.pageContent !== void 0 ? $.pageContent.toString() : "", this.metadata = $.metadata ?? {}, this.id = $.id;
  }
}, __name(_a, "H1"), _a);
var QJ = K8(oJ(), 1);
var ON = K8(aJ(), 1);
function eJ($, q) {
  return q?.[$] || QJ.default($);
}
__name(eJ, "eJ");
function sJ($, q, K) {
  let P = {};
  for (let _ in $) if (Object.hasOwn($, _)) P[q(_, K)] = $[_];
  return P;
}
__name(sJ, "sJ");
var YN = {};
Z6(YN, { Serializable: /* @__PURE__ */ __name(() => DK, "Serializable"), get_lc_unique_name: /* @__PURE__ */ __name(() => J1, "get_lc_unique_name") });
function $T($) {
  return Array.isArray($) ? [...$] : { ...$ };
}
__name($T, "$T");
function jN($, q) {
  let K = $T($);
  for (let [P, _] of Object.entries(q)) {
    let [Y, ...O] = P.split(".").reverse(), z = K;
    for (let J of O.reverse()) {
      if (z[J] === void 0) break;
      z[J] = $T(z[J]), z = z[J];
    }
    if (z[Y] !== void 0) z[Y] = { lc: 1, type: "secret", id: [_] };
  }
  return K;
}
__name(jN, "jN");
function J1($) {
  let q = Object.getPrototypeOf($);
  if (typeof $.lc_name === "function" && (typeof q.lc_name !== "function" || $.lc_name() !== q.lc_name())) return $.lc_name();
  else return $.name;
}
__name(J1, "J1");
var _a2;
var DK = (_a2 = class {
  lc_serializable = false;
  lc_kwargs;
  static lc_name() {
    return this.name;
  }
  get lc_id() {
    return [...this.lc_namespace, J1(this.constructor)];
  }
  get lc_secrets() {
    return;
  }
  get lc_attributes() {
    return;
  }
  get lc_aliases() {
    return;
  }
  get lc_serializable_keys() {
    return;
  }
  constructor(q, ...K) {
    if (this.lc_serializable_keys !== void 0) this.lc_kwargs = Object.fromEntries(Object.entries(q || {}).filter(([P]) => this.lc_serializable_keys?.includes(P)));
    else this.lc_kwargs = q ?? {};
  }
  toJSON() {
    if (!this.lc_serializable) return this.toJSONNotImplemented();
    if (this.lc_kwargs instanceof _a2 || typeof this.lc_kwargs !== "object" || Array.isArray(this.lc_kwargs)) return this.toJSONNotImplemented();
    let q = {}, K = {}, P = Object.keys(this.lc_kwargs).reduce((_, Y) => {
      return _[Y] = Y in this ? this[Y] : this.lc_kwargs[Y], _;
    }, {});
    for (let _ = Object.getPrototypeOf(this); _; _ = Object.getPrototypeOf(_)) Object.assign(q, Reflect.get(_, "lc_aliases", this)), Object.assign(K, Reflect.get(_, "lc_secrets", this)), Object.assign(P, Reflect.get(_, "lc_attributes", this));
    return Object.keys(K).forEach((_) => {
      let Y = this, O = P, [z, ...J] = _.split(".").reverse();
      for (let T of J.reverse()) {
        if (!(T in Y) || Y[T] === void 0) return;
        if (!(T in O) || O[T] === void 0) {
          if (typeof Y[T] === "object" && Y[T] != null) O[T] = {};
          else if (Array.isArray(Y[T])) O[T] = [];
        }
        Y = Y[T], O = O[T];
      }
      if (z in Y && Y[z] !== void 0) O[z] = O[z] || Y[z];
    }), { lc: 1, type: "constructor", id: this.lc_id, kwargs: sJ(Object.keys(K).length ? jN(P, K) : P, eJ, q) };
  }
  toJSONNotImplemented() {
    return { lc: 1, type: "not_implemented", id: this.lc_id };
  }
}, __name(_a2, "$"), _a2);
function yO($) {
  return !!($ && typeof $ === "object" && "type" in $ && $.type === "tool_call");
}
__name(yO, "yO");
var _a3;
var qT = (_a3 = class extends Error {
  output;
  constructor($, q) {
    super($);
    this.output = q;
  }
}, __name(_a3, "qT"), _a3);
var KT = Symbol.for("ls:tracing_async_local_storage");
var LK = Symbol.for("lc:context_variables");
var _T = /* @__PURE__ */ __name(($) => {
  globalThis[KT] = $;
}, "_T");
var gK = /* @__PURE__ */ __name(() => {
  return globalThis[KT];
}, "gK");
function d_($) {
  return typeof $ === "object" && $ !== null && "type" in $ && typeof $.type === "string" && "source_type" in $ && ($.source_type === "url" || $.source_type === "base64" || $.source_type === "text" || $.source_type === "id");
}
__name(d_, "d_");
function PT($) {
  return d_($) && $.source_type === "url" && "url" in $ && typeof $.url === "string";
}
__name(PT, "PT");
function OT($) {
  return d_($) && $.source_type === "base64" && "data" in $ && typeof $.data === "string";
}
__name(OT, "OT");
function YT($) {
  return d_($) && $.source_type === "id" && "id" in $ && typeof $.id === "string";
}
__name(YT, "YT");
function uO({ dataUrl: $, asTypedArray: q = false }) {
  let K = $.match(/^data:(\w+\/\w+);base64,([A-Za-z0-9+/]+=*)$/), P;
  if (K) {
    P = K[1].toLowerCase();
    let _ = q ? Uint8Array.from(atob(K[2]), (Y) => Y.charCodeAt(0)) : K[2];
    return { mime_type: P, data: _ };
  }
  return;
}
__name(uO, "uO");
function e$($, q) {
  return _6($) && $.type === q;
}
__name(e$, "e$");
function _6($) {
  return typeof $ === "object" && $ !== null;
}
__name(_6, "_6");
function oq($) {
  return Array.isArray($);
}
__name(oq, "oq");
function U$($) {
  return typeof $ === "string";
}
__name(U$, "U$");
function _8($) {
  return typeof $ === "number";
}
__name(_8, "_8");
function T1($) {
  return $ instanceof Uint8Array;
}
__name(T1, "T1");
function xO($) {
  try {
    return JSON.parse($);
  } catch {
    return;
  }
}
__name(xO, "xO");
var PK = /* @__PURE__ */ __name(($) => $(), "PK");
function vN($) {
  if ($.type === "char_location" && U$($.document_title) && _8($.start_char_index) && _8($.end_char_index) && U$($.cited_text)) {
    let { document_title: q, start_char_index: K, end_char_index: P, cited_text: _, ...Y } = $;
    return { ...Y, type: "citation", source: "char", title: q ?? void 0, startIndex: K, endIndex: P, citedText: _ };
  }
  if ($.type === "page_location" && U$($.document_title) && _8($.start_page_number) && _8($.end_page_number) && U$($.cited_text)) {
    let { document_title: q, start_page_number: K, end_page_number: P, cited_text: _, ...Y } = $;
    return { ...Y, type: "citation", source: "page", title: q ?? void 0, startIndex: K, endIndex: P, citedText: _ };
  }
  if ($.type === "content_block_location" && U$($.document_title) && _8($.start_block_index) && _8($.end_block_index) && U$($.cited_text)) {
    let { document_title: q, start_block_index: K, end_block_index: P, cited_text: _, ...Y } = $;
    return { ...Y, type: "citation", source: "block", title: q ?? void 0, startIndex: K, endIndex: P, citedText: _ };
  }
  if ($.type === "web_search_result_location" && U$($.url) && U$($.title) && U$($.encrypted_index) && U$($.cited_text)) {
    let { url: q, title: K, encrypted_index: P, cited_text: _, ...Y } = $;
    return { ...Y, type: "citation", source: "url", url: q, title: K, startIndex: Number(P), endIndex: Number(P), citedText: _ };
  }
  if ($.type === "search_result_location" && U$($.source) && U$($.title) && _8($.start_block_index) && _8($.end_block_index) && U$($.cited_text)) {
    let { source: q, title: K, start_block_index: P, end_block_index: _, cited_text: Y, ...O } = $;
    return { ...O, type: "citation", source: "search", url: q, title: K ?? void 0, startIndex: P, endIndex: _, citedText: Y };
  }
  return;
}
__name(vN, "vN");
function vT($) {
  if (e$($, "document") && _6($.source) && "type" in $.source) {
    if ($.source.type === "base64" && U$($.source.media_type) && U$($.source.data)) return { type: "file", mimeType: $.source.media_type, data: $.source.data };
    else if ($.source.type === "url" && U$($.source.url)) return { type: "file", url: $.source.url };
    else if ($.source.type === "file" && U$($.source.file_id)) return { type: "file", fileId: $.source.file_id };
    else if ($.source.type === "text" && U$($.source.data)) return { type: "file", mimeType: String($.source.media_type ?? "text/plain"), data: $.source.data };
  } else if (e$($, "image") && _6($.source) && "type" in $.source) {
    if ($.source.type === "base64" && U$($.source.media_type) && U$($.source.data)) return { type: "image", mimeType: $.source.media_type, data: $.source.data };
    else if ($.source.type === "url" && U$($.source.url)) return { type: "image", url: $.source.url };
    else if ($.source.type === "file" && U$($.source.file_id)) return { type: "image", fileId: $.source.file_id };
  }
  return;
}
__name(vT, "vT");
function zT($) {
  function* q() {
    for (let K of $) {
      let P = vT(K);
      if (P) yield P;
      else yield K;
    }
  }
  __name(q, "q");
  return Array.from(q());
}
__name(zT, "zT");
function jT($) {
  function* q() {
    let K = typeof $.content === "string" ? [{ type: "text", text: $.content }] : $.content;
    for (let P of K) {
      if (e$(P, "text") && U$(P.text)) {
        let { text: _, citations: Y, ...O } = P;
        if (oq(Y) && Y.length) {
          let z = Y.reduce((J, T) => {
            let X = vN(T);
            if (X) return [...J, X];
            return J;
          }, []);
          yield { ...O, type: "text", text: _, annotations: z };
          continue;
        } else {
          yield { ...O, type: "text", text: _ };
          continue;
        }
      } else if (e$(P, "thinking") && U$(P.thinking)) {
        let { thinking: _, signature: Y, ...O } = P;
        yield { ...O, type: "reasoning", reasoning: _, signature: Y };
        continue;
      } else if (e$(P, "redacted_thinking")) {
        yield { type: "non_standard", value: P };
        continue;
      } else if (e$(P, "tool_use") && U$(P.name) && U$(P.id)) {
        yield { type: "tool_call", id: P.id, name: P.name, args: P.input };
        continue;
      } else if (e$(P, "input_json_delta")) {
        if (zN($) && $.tool_call_chunks?.length) {
          let _ = $.tool_call_chunks[0];
          yield { type: "tool_call_chunk", id: _.id, name: _.name, args: _.args, index: _.index };
          continue;
        }
      } else if (e$(P, "server_tool_use") && U$(P.name) && U$(P.id)) {
        let { name: _, id: Y } = P;
        if (_ === "web_search") {
          let O = PK(() => {
            if (typeof P.input === "string") return P.input;
            else if (_6(P.input) && U$(P.input.query)) return P.input.query;
            else if (U$(P.partial_json)) {
              let z = xO(P.partial_json);
              if (z?.query) return z.query;
            }
            return "";
          });
          yield { id: Y, type: "server_tool_call", name: "web_search", args: { query: O } };
          continue;
        } else if (P.name === "code_execution") {
          let O = PK(() => {
            if (typeof P.input === "string") return P.input;
            else if (_6(P.input) && U$(P.input.code)) return P.input.code;
            else if (U$(P.partial_json)) {
              let z = xO(P.partial_json);
              if (z?.code) return z.code;
            }
            return "";
          });
          yield { id: Y, type: "server_tool_call", name: "code_execution", args: { code: O } };
          continue;
        }
      } else if (e$(P, "web_search_tool_result") && U$(P.tool_use_id) && oq(P.content)) {
        let { content: _, tool_use_id: Y } = P, O = _.reduce((z, J) => {
          if (e$(J, "web_search_result")) return [...z, J.url];
          return z;
        }, []);
        yield { type: "server_tool_call_result", name: "web_search", toolCallId: Y, status: "success", output: { urls: O } };
        continue;
      } else if (e$(P, "code_execution_tool_result") && U$(P.tool_use_id) && _6(P.content)) {
        yield { type: "server_tool_call_result", name: "code_execution", toolCallId: P.tool_use_id, status: "success", output: P.content };
        continue;
      } else if (e$(P, "mcp_tool_use")) {
        yield { id: P.id, type: "server_tool_call", name: "mcp_tool_use", args: P.input };
        continue;
      } else if (e$(P, "mcp_tool_result") && U$(P.tool_use_id) && _6(P.content)) {
        yield { type: "server_tool_call_result", name: "mcp_tool_use", toolCallId: P.tool_use_id, status: "success", output: P.content };
        continue;
      } else if (e$(P, "container_upload")) {
        yield { type: "server_tool_call", name: "container_upload", args: P.input };
        continue;
      } else if (e$(P, "search_result")) {
        yield { id: P.id, type: "non_standard", value: P };
        continue;
      } else if (e$(P, "tool_result")) {
        yield { id: P.id, type: "non_standard", value: P };
        continue;
      } else {
        let _ = vT(P);
        if (_) {
          yield _;
          continue;
        }
      }
      yield { type: "non_standard", value: P };
    }
  }
  __name(q, "q");
  return Array.from(q());
}
__name(jT, "jT");
var WT = { translateContent: jT, translateContentChunk: jT };
function zN($) {
  return typeof $?._getType === "function" && typeof $.concat === "function" && $._getType() === "ai";
}
__name(zN, "zN");
function WN($) {
  if (PT($)) return { type: $.type, mimeType: $.mime_type, url: $.url, metadata: $.metadata };
  if (OT($)) return { type: $.type, mimeType: $.mime_type ?? "application/octet-stream", data: $.data, metadata: $.metadata };
  if (YT($)) return { type: $.type, mimeType: $.mime_type, fileId: $.id, metadata: $.metadata };
  return $;
}
__name(WN, "WN");
function HT($) {
  return $.map(WN);
}
__name(HT, "HT");
function JT($) {
  if (e$($, "image_url") && _6($.image_url)) return true;
  if (e$($, "input_audio") && _6($.input_audio)) return true;
  if (e$($, "file") && _6($.file)) return true;
  return false;
}
__name(JT, "JT");
function TT($) {
  if (e$($, "image_url") && _6($.image_url) && U$($.image_url.url)) {
    let q = uO({ dataUrl: $.image_url.url });
    if (q) return { type: "image", mimeType: q.mime_type, data: q.data };
    else return { type: "image", url: $.image_url.url };
  } else if (e$($, "input_audio") && _6($.input_audio) && U$($.input_audio.data) && U$($.input_audio.format)) return { type: "audio", data: $.input_audio.data, mimeType: `audio/${$.input_audio.format}` };
  else if (e$($, "file") && _6($.file) && U$($.file.data)) {
    let q = uO({ dataUrl: $.file.data });
    if (q) return { type: "file", data: q.data, mimeType: q.mime_type };
    else if (U$($.file.file_id)) return { type: "file", fileId: $.file.file_id };
  }
  return $;
}
__name(TT, "TT");
function HN($) {
  let q = [];
  if (typeof $.content === "string") q.push({ type: "text", text: $.content });
  else q.push(...w1($.content));
  for (let K of $.tool_calls ?? []) q.push({ type: "tool_call", id: K.id, name: K.name, args: K.args });
  return q;
}
__name(HN, "HN");
function JN($) {
  let q = [];
  if (typeof $.content === "string") q.push({ type: "text", text: $.content });
  else q.push(...w1($.content));
  for (let K of $.tool_calls ?? []) q.push({ type: "tool_call", id: K.id, name: K.name, args: K.args });
  return q;
}
__name(JN, "JN");
function w1($) {
  let q = [];
  for (let K of $) if (JT(K)) q.push(TT(K));
  else q.push(K);
  return q;
}
__name(w1, "w1");
function TN($) {
  if ($.type === "url_citation") {
    let { url: q, title: K, start_index: P, end_index: _ } = $;
    return { type: "citation", url: q, title: K, startIndex: P, endIndex: _ };
  }
  if ($.type === "file_citation") {
    let { file_id: q, filename: K, index: P } = $;
    return { type: "citation", title: K, startIndex: P, endIndex: P, fileId: q };
  }
  return $;
}
__name(TN, "TN");
function wT($) {
  function* q() {
    if (_6($.additional_kwargs?.reasoning) && oq($.additional_kwargs.reasoning.summary)) yield { type: "reasoning", reasoning: $.additional_kwargs.reasoning.summary.reduce((_, Y) => {
      if (_6(Y) && U$(Y.text)) return `${_}${Y.text}`;
      return _;
    }, "") };
    let K = typeof $.content === "string" ? [{ type: "text", text: $.content }] : $.content;
    for (let P of K) if (e$(P, "text")) {
      let { text: _, annotations: Y, ...O } = P;
      if (Array.isArray(Y)) yield { ...O, type: "text", text: String(_), annotations: Y.map(TN) };
      else yield { ...O, type: "text", text: String(_) };
    }
    for (let P of $.tool_calls ?? []) yield { type: "tool_call", id: P.id, name: P.name, args: P.args };
    if (_6($.additional_kwargs) && oq($.additional_kwargs.tool_outputs)) for (let P of $.additional_kwargs.tool_outputs) {
      if (e$(P, "web_search_call")) {
        yield { id: P.id, type: "server_tool_call", name: "web_search", args: { query: P.query } };
        continue;
      } else if (e$(P, "file_search_call")) {
        yield { id: P.id, type: "server_tool_call", name: "file_search", args: { query: P.query } };
        continue;
      } else if (e$(P, "computer_call")) {
        yield { type: "non_standard", value: P };
        continue;
      } else if (e$(P, "code_interpreter_call")) {
        if (U$(P.code)) yield { id: P.id, type: "server_tool_call", name: "code_interpreter", args: { code: P.code } };
        if (oq(P.outputs)) {
          let _ = PK(() => {
            if (P.status === "in_progress") return;
            if (P.status === "completed") return 0;
            if (P.status === "incomplete") return 127;
            if (P.status === "interpreting") return;
            if (P.status === "failed") return 1;
            return;
          });
          for (let Y of P.outputs) if (e$(Y, "logs")) {
            yield { type: "server_tool_call_result", toolCallId: P.id ?? "", status: "success", output: { type: "code_interpreter_output", returnCode: _ ?? 0, stderr: [0, void 0].includes(_) ? void 0 : String(Y.logs), stdout: [0, void 0].includes(_) ? String(Y.logs) : void 0 } };
            continue;
          }
        }
        continue;
      } else if (e$(P, "mcp_call")) {
        yield { id: P.id, type: "server_tool_call", name: "mcp_call", args: P.input };
        continue;
      } else if (e$(P, "mcp_list_tools")) {
        yield { id: P.id, type: "server_tool_call", name: "mcp_list_tools", args: P.input };
        continue;
      } else if (e$(P, "mcp_approval_request")) {
        yield { type: "non_standard", value: P };
        continue;
      } else if (e$(P, "image_generation_call")) {
        yield { type: "non_standard", value: P };
        continue;
      }
      if (_6(P)) yield { type: "non_standard", value: P };
    }
  }
  __name(q, "q");
  return Array.from(q());
}
__name(wT, "wT");
function wN($) {
  function* q() {
    yield* wT($);
    for (let K of $.tool_call_chunks ?? []) yield { type: "tool_call_chunk", id: K.id, name: K.name, args: K.args };
  }
  __name(q, "q");
  return Array.from(q());
}
__name(wN, "wN");
var fT = { translateContent: /* @__PURE__ */ __name(($) => {
  if (typeof $.content === "string") return HN($);
  return wT($);
}, "translateContent"), translateContentChunk: /* @__PURE__ */ __name(($) => {
  if (typeof $.content === "string") return JN($);
  return wN($);
}, "translateContentChunk") };
function ZT($) {
  return typeof $ === "object" && $ !== null && "type" in $ && "content" in $ && (typeof $.content === "string" || Array.isArray($.content));
}
__name(ZT, "ZT");
function XT($, q = "pretty") {
  if (q === "pretty") return fN($);
  return JSON.stringify($);
}
__name(XT, "XT");
function fN($) {
  let q = [], K = ` ${$.type.charAt(0).toUpperCase() + $.type.slice(1)} Message `, P = Math.floor((80 - K.length) / 2), _ = "=".repeat(P), Y = K.length % 2 === 0 ? _ : `${_}=`;
  if (q.push(`${_}${K}${Y}`), $.type === "ai") {
    let O = $;
    if (O.tool_calls && O.tool_calls.length > 0) {
      q.push("Tool Calls:");
      for (let z of O.tool_calls) {
        q.push(`  ${z.name} (${z.id})`), q.push(` Call ID: ${z.id}`), q.push("  Args:");
        for (let [J, T] of Object.entries(z.args)) q.push(`    ${J}: ${T}`);
      }
    }
  }
  if ($.type === "tool") {
    let O = $;
    if (O.name) q.push(`Name: ${O.name}`);
  }
  if (typeof $.content === "string" && $.content.trim()) {
    if (q.length > 1) q.push("");
    q.push($.content);
  }
  return q.join(`
`);
}
__name(fN, "fN");
var pO = Symbol.for("langchain.message");
function bK($, q) {
  if (typeof $ === "string") {
    if ($ === "") return q;
    if (typeof q === "string") return $ + q;
    else if (Array.isArray(q) && q.some((K) => d_(K))) return [{ type: "text", source_type: "text", text: $ }, ...q];
    else return [{ type: "text", text: $ }, ...q];
  } else if (Array.isArray(q)) return OP($, q) ?? [...$, ...q];
  else if (q === "") return $;
  else if (Array.isArray($) && $.some((K) => d_(K))) return [...$, { type: "file", source_type: "text", text: q }];
  else return [...$, { type: "text", text: q }];
}
__name(bK, "bK");
function AT($, q) {
  if ($ === "error" || q === "error") return "error";
  return "success";
}
__name(AT, "AT");
function ZN($, q) {
  function K(P, _) {
    if (typeof P !== "object" || P === null || P === void 0) return P;
    if (_ >= q) {
      if (Array.isArray(P)) return "[Array]";
      return "[Object]";
    }
    if (Array.isArray(P)) return P.map((O) => K(O, _ + 1));
    let Y = {};
    for (let O of Object.keys(P)) Y[O] = K(P[O], _ + 1);
    return Y;
  }
  __name(K, "K");
  return JSON.stringify(K($, 0), null, 2);
}
__name(ZN, "ZN");
var _a4;
var OK = (_a4 = class extends DK {
  lc_namespace = ["langchain_core", "messages"];
  lc_serializable = true;
  get lc_aliases() {
    return { additional_kwargs: "additional_kwargs", response_metadata: "response_metadata" };
  }
  [pO] = true;
  id;
  name;
  content;
  additional_kwargs;
  response_metadata;
  _getType() {
    return this.type;
  }
  getType() {
    return this._getType();
  }
  constructor($) {
    let q = typeof $ === "string" || Array.isArray($) ? { content: $ } : $;
    if (!q.additional_kwargs) q.additional_kwargs = {};
    if (!q.response_metadata) q.response_metadata = {};
    super(q);
    if (this.name = q.name, q.content === void 0 && q.contentBlocks !== void 0) this.content = q.contentBlocks, this.response_metadata = { output_version: "v1", ...q.response_metadata };
    else if (q.content !== void 0) this.content = q.content ?? [], this.response_metadata = q.response_metadata;
    else this.content = [], this.response_metadata = q.response_metadata;
    this.additional_kwargs = q.additional_kwargs, this.id = q.id;
  }
  get text() {
    if (typeof this.content === "string") return this.content;
    if (!Array.isArray(this.content)) return "";
    return this.content.map(($) => {
      if (typeof $ === "string") return $;
      if ($.type === "text") return $.text;
      return "";
    }).join("");
  }
  get contentBlocks() {
    let $ = typeof this.content === "string" ? [{ type: "text", text: this.content }] : this.content;
    return [HT, w1, zT].reduce((P, _) => _(P), $);
  }
  toDict() {
    return { type: this.getType(), data: this.toJSON().kwargs };
  }
  static lc_name() {
    return "BaseMessage";
  }
  get _printableFields() {
    return { id: this.id, content: this.content, name: this.name, additional_kwargs: this.additional_kwargs, response_metadata: this.response_metadata };
  }
  static isInstance($) {
    return typeof $ === "object" && $ !== null && pO in $ && $[pO] === true && ZT($);
  }
  _updateId($) {
    this.id = $, this.lc_kwargs.id = $;
  }
  get [Symbol.toStringTag]() {
    return this.constructor.lc_name();
  }
  [Symbol.for("nodejs.util.inspect.custom")]($) {
    if ($ === null) return this;
    let q = ZN(this._printableFields, Math.max(4, $));
    return `${this.constructor.lc_name()} ${q}`;
  }
  toFormattedString($ = "pretty") {
    return XT(this, $);
  }
}, __name(_a4, "OK"), _a4);
function nq($ = {}, q = {}) {
  let K = { ...$ };
  for (let [P, _] of Object.entries(q)) if (K[P] == null) K[P] = _;
  else if (_ == null) continue;
  else if (typeof K[P] !== typeof _ || Array.isArray(K[P]) !== Array.isArray(_)) throw Error(`field[${P}] already exists in the message chunk, but with a different type.`);
  else if (typeof K[P] === "string") if (P === "type") continue;
  else if (["id", "name", "output_version", "model_provider"].includes(P)) K[P] = _;
  else K[P] += _;
  else if (typeof K[P] === "object" && !Array.isArray(K[P])) K[P] = nq(K[P], _);
  else if (Array.isArray(K[P])) K[P] = OP(K[P], _);
  else if (K[P] === _) continue;
  else console.warn(`field[${P}] already exists in this message chunk and value has unsupported type.`);
  return K;
}
__name(nq, "nq");
function OP($, q) {
  if ($ === void 0 && q === void 0) return;
  else if ($ === void 0 || q === void 0) return $ || q;
  else {
    let K = [...$];
    for (let P of q) if (typeof P === "object" && P !== null && "index" in P && typeof P.index === "number") {
      let _ = K.findIndex((Y) => {
        let O = typeof Y === "object", z = "index" in Y && Y.index === P.index, J = "id" in Y && "id" in P && Y?.id === P?.id, T = !("id" in Y) || !Y?.id || !("id" in P) || !P?.id;
        return O && z && (J || T);
      });
      if (_ !== -1 && typeof K[_] === "object" && K[_] !== null) K[_] = nq(K[_], P);
      else K.push(P);
    } else if (typeof P === "object" && P !== null && "text" in P && P.text === "") continue;
    else K.push(P);
    return K;
  }
}
__name(OP, "OP");
function kT($, q) {
  if (!$ && !q) throw Error("Cannot merge two undefined objects.");
  if (!$ || !q) return $ || q;
  else if (typeof $ !== typeof q) throw Error(`Cannot merge objects of different types.
Left ${typeof $}
Right ${typeof q}`);
  else if (typeof $ === "string" && typeof q === "string") return $ + q;
  else if (Array.isArray($) && Array.isArray(q)) return OP($, q);
  else if (typeof $ === "object" && typeof q === "object") return nq($, q);
  else if ($ === q) return $;
  else throw Error(`Can not merge objects of different types.
Left ${$}
Right ${q}`);
}
__name(kT, "kT");
var _a5;
var yK = (_a5 = class extends OK {
  static isInstance($) {
    return super.isInstance($) && "concat" in $ && typeof $.concat === "function";
  }
}, __name(_a5, "yK"), _a5);
var XN = {};
Z6(XN, { ToolMessage: /* @__PURE__ */ __name(() => GT, "ToolMessage"), ToolMessageChunk: /* @__PURE__ */ __name(() => kN, "ToolMessageChunk"), defaultToolCallParser: /* @__PURE__ */ __name(() => VT, "defaultToolCallParser"), isDirectToolOutput: /* @__PURE__ */ __name(() => AN, "isDirectToolOutput"), isToolMessage: /* @__PURE__ */ __name(() => GN, "isToolMessage"), isToolMessageChunk: /* @__PURE__ */ __name(() => VN, "isToolMessageChunk") });
function AN($) {
  return $ != null && typeof $ === "object" && "lc_direct_tool_output" in $ && $.lc_direct_tool_output === true;
}
__name(AN, "AN");
var _a6;
var GT = (_a6 = class extends OK {
  static lc_name() {
    return "ToolMessage";
  }
  get lc_aliases() {
    return { tool_call_id: "tool_call_id" };
  }
  lc_direct_tool_output = true;
  type = "tool";
  status;
  tool_call_id;
  metadata;
  artifact;
  constructor($, q, K) {
    let P = typeof $ === "string" || Array.isArray($) ? { content: $, name: K, tool_call_id: q } : $;
    super(P);
    this.tool_call_id = P.tool_call_id, this.artifact = P.artifact, this.status = P.status, this.metadata = P.metadata;
  }
  static isInstance($) {
    return super.isInstance($) && $.type === "tool";
  }
  get _printableFields() {
    return { ...super._printableFields, tool_call_id: this.tool_call_id, artifact: this.artifact };
  }
}, __name(_a6, "GT"), _a6);
var _a7;
var kN = (_a7 = class extends yK {
  type = "tool";
  tool_call_id;
  status;
  artifact;
  constructor($) {
    super($);
    this.tool_call_id = $.tool_call_id, this.artifact = $.artifact, this.status = $.status;
  }
  static lc_name() {
    return "ToolMessageChunk";
  }
  concat($) {
    return new this.constructor({ content: bK(this.content, $.content), additional_kwargs: nq(this.additional_kwargs, $.additional_kwargs), response_metadata: nq(this.response_metadata, $.response_metadata), artifact: kT(this.artifact, $.artifact), tool_call_id: this.tool_call_id, id: this.id ?? $.id, status: AT(this.status, $.status) });
  }
  get _printableFields() {
    return { ...super._printableFields, tool_call_id: this.tool_call_id, artifact: this.artifact };
  }
}, __name(_a7, "kN"), _a7);
function VT($) {
  let q = [], K = [];
  for (let P of $) if (!P.function) continue;
  else {
    let _ = P.function.name;
    try {
      let Y = JSON.parse(P.function.arguments);
      q.push({ name: _ || "", args: Y || {}, id: P.id });
    } catch {
      K.push({ name: _, args: P.function.arguments, id: P.id, error: "Malformed args." });
    }
  }
  return [q, K];
}
__name(VT, "VT");
function GN($) {
  return typeof $ === "object" && $ !== null && "getType" in $ && typeof $.getType === "function" && $.getType() === "tool";
}
__name(GN, "GN");
function VN($) {
  return $._getType() === "tool";
}
__name(VN, "VN");
function ST($) {
  if (typeof $ > "u") return null;
  try {
    return JSON.parse($);
  } catch {
  }
  let q = "", K = [], P = false, _ = false;
  for (let Y of $) {
    if (P) if (Y === '"' && !_) P = false;
    else if (Y === `
` && !_) Y = "\\n";
    else if (Y === "\\") _ = !_;
    else _ = false;
    else if (Y === '"') P = true, _ = false;
    else if (Y === "{") K.push("}");
    else if (Y === "[") K.push("]");
    else if (Y === "}" || Y === "]") if (K && K[K.length - 1] === Y) K.pop();
    else return null;
    q += Y;
  }
  if (P) q += '"';
  for (let Y = K.length - 1; Y >= 0; Y -= 1) q += K[Y];
  try {
    return JSON.parse(q);
  } catch {
    return null;
  }
}
__name(ST, "ST");
function cO($) {
  switch ($) {
    case "csv":
      return "text/csv";
    case "doc":
      return "application/vnd.openxmlformats-officedocument.wordprocessingml.document";
    case "docx":
      return "application/vnd.openxmlformats-officedocument.wordprocessingml.document";
    case "html":
      return "text/html";
    case "md":
      return "text/markdown";
    case "pdf":
      return "application/pdf";
    case "txt":
      return "text/plain";
    case "xls":
      return "application/vnd.ms-excel";
    case "xlsx":
      return "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet";
    case "gif":
      return "image/gif";
    case "jpeg":
      return "image/jpeg";
    case "jpg":
      return "image/jpeg";
    case "png":
      return "image/png";
    case "webp":
      return "image/webp";
    case "flv":
      return "video/flv";
    case "mkv":
      return "video/mkv";
    case "mov":
      return "video/mov";
    case "mp4":
      return "video/mp4";
    case "mpeg":
      return "video/mpeg";
    case "mpg":
      return "video/mpg";
    case "three_gp":
      return "video/three_gp";
    case "webm":
      return "video/webm";
    case "wmv":
      return "video/wmv";
    default:
      return "application/octet-stream";
  }
}
__name(cO, "cO");
function SN($) {
  if (_6($.document) && _6($.document.source)) {
    let q = _6($.document) && U$($.document.format) ? $.document.format : "", K = cO(q);
    if (_6($.document.source)) {
      if (_6($.document.source.s3Location) && U$($.document.source.s3Location.uri)) return { type: "file", mimeType: K, fileId: $.document.source.s3Location.uri };
      if (T1($.document.source.bytes)) return { type: "file", mimeType: K, data: $.document.source.bytes };
      if (U$($.document.source.text)) return { type: "file", mimeType: K, data: Buffer.from($.document.source.text).toString("base64") };
      if (oq($.document.source.content)) {
        let P = $.document.source.content.reduce((_, Y) => {
          if (_6(Y) && U$(Y.text)) return _ + Y.text;
          return _;
        }, "");
        return { type: "file", mimeType: K, data: P };
      }
    }
  }
  return { type: "non_standard", value: $ };
}
__name(SN, "SN");
function MN($) {
  if (e$($, "image") && _6($.image)) {
    let q = _6($.image) && U$($.image.format) ? $.image.format : "", K = cO(q);
    if (_6($.image.source)) {
      if (_6($.image.source.s3Location) && U$($.image.source.s3Location.uri)) return { type: "image", mimeType: K, fileId: $.image.source.s3Location.uri };
      if (T1($.image.source.bytes)) return { type: "image", mimeType: K, data: $.image.source.bytes };
    }
  }
  return { type: "non_standard", value: $ };
}
__name(MN, "MN");
function NN($) {
  if (e$($, "video") && _6($.video)) {
    let q = _6($.video) && U$($.video.format) ? $.video.format : "", K = cO(q);
    if (_6($.video.source)) {
      if (_6($.video.source.s3Location) && U$($.video.source.s3Location.uri)) return { type: "video", mimeType: K, fileId: $.video.source.s3Location.uri };
      if (T1($.video.source.bytes)) return { type: "video", mimeType: K, data: $.video.source.bytes };
    }
  }
  return { type: "non_standard", value: $ };
}
__name(NN, "NN");
function MT($) {
  function* q() {
    let K = typeof $.content === "string" ? [{ type: "text", text: $.content }] : $.content;
    for (let P of K) {
      if (e$(P, "cache_point")) {
        yield { type: "non_standard", value: P };
        continue;
      } else if (e$(P, "citations_content") && _6(P.citationsContent)) {
        let _ = oq(P.citationsContent.content) ? P.citationsContent.content.reduce((O, z) => {
          if (_6(z) && U$(z.text)) return O + z.text;
          return O;
        }, "") : "", Y = oq(P.citationsContent.citations) ? P.citationsContent.citations.reduce((O, z) => {
          if (_6(z)) {
            let J = oq(z.sourceContent) ? z.sourceContent.reduce((X, f) => {
              if (_6(f) && U$(f.text)) return X + f.text;
              return X;
            }, "") : "", T = PK(() => {
              if (_6(z.location)) {
                let X = z.location.documentChar || z.location.documentPage || z.location.documentChunk;
                if (_6(X)) return { source: _8(X.documentIndex) ? X.documentIndex.toString() : void 0, startIndex: _8(X.start) ? X.start : void 0, endIndex: _8(X.end) ? X.end : void 0 };
              }
              return {};
            });
            O.push({ type: "citation", citedText: J, ...T });
          }
          return O;
        }, []) : [];
        yield { type: "text", text: _, annotations: Y };
        continue;
      } else if (e$(P, "document") && _6(P.document)) {
        yield SN(P);
        continue;
      } else if (e$(P, "guard_content")) {
        yield { type: "non_standard", value: P };
        continue;
      } else if (e$(P, "image") && _6(P.image)) {
        yield MN(P);
        continue;
      } else if (e$(P, "reasoning_content") && U$(P.reasoningText)) {
        yield { type: "reasoning", reasoning: P.reasoningText };
        continue;
      } else if (e$(P, "text") && U$(P.text)) {
        yield { type: "text", text: P.text };
        continue;
      } else if (e$(P, "tool_result")) {
        yield { type: "non_standard", value: P };
        continue;
      } else if (e$(P, "tool_call")) continue;
      else if (e$(P, "video") && _6(P.video)) {
        yield NN(P);
        continue;
      }
      yield { type: "non_standard", value: P };
    }
  }
  __name(q, "q");
  return Array.from(q());
}
__name(MT, "MT");
var NT = { translateContent: MT, translateContentChunk: MT };
function CT($) {
  function* q() {
    let K = typeof $.content === "string" ? [{ type: "text", text: $.content }] : $.content;
    for (let P of K) {
      if (e$(P, "text") && U$(P.text)) {
        yield { type: "text", text: P.text };
        continue;
      } else if (e$(P, "inlineData") && _6(P.inlineData) && U$(P.inlineData.mimeType) && U$(P.inlineData.data)) {
        yield { type: "file", mimeType: P.inlineData.mimeType, data: P.inlineData.data };
        continue;
      } else if (e$(P, "functionCall") && _6(P.functionCall) && U$(P.functionCall.name) && _6(P.functionCall.args)) {
        yield { type: "tool_call", id: $.id, name: P.functionCall.name, args: P.functionCall.args };
        continue;
      } else if (e$(P, "functionResponse")) {
        yield { type: "non_standard", value: P };
        continue;
      } else if (e$(P, "fileData") && _6(P.fileData) && U$(P.fileData.mimeType) && U$(P.fileData.fileUri)) {
        yield { type: "file", mimeType: P.fileData.mimeType, fileId: P.fileData.fileUri };
        continue;
      } else if (e$(P, "executableCode")) {
        yield { type: "non_standard", value: P };
        continue;
      } else if (e$(P, "codeExecutionResult")) {
        yield { type: "non_standard", value: P };
        continue;
      }
      yield { type: "non_standard", value: P };
    }
  }
  __name(q, "q");
  return Array.from(q());
}
__name(CT, "CT");
var hT = { translateContent: CT, translateContentChunk: CT };
function ET($) {
  function* q() {
    let K = typeof $.content === "string" ? [{ type: "text", text: $.content }] : $.content;
    for (let P of K) {
      if (e$(P, "reasoning") && U$(P.reasoning)) {
        let _ = PK(() => {
          let Y = K.indexOf(P);
          if (oq($.additional_kwargs?.signatures) && Y >= 0) return $.additional_kwargs.signatures.at(Y);
          return;
        });
        if (U$(_)) yield { type: "reasoning", reasoning: P.reasoning, signature: _ };
        else yield { type: "reasoning", reasoning: P.reasoning };
        continue;
      } else if (e$(P, "text") && U$(P.text)) {
        yield { type: "text", text: P.text };
        continue;
      } else if (e$(P, "image_url")) {
        if (U$(P.image_url)) if (P.image_url.startsWith("data:")) {
          let _ = /^data:([^;]+);base64,(.+)$/, Y = P.image_url.match(_);
          if (Y) yield { type: "image", data: Y[2], mimeType: Y[1] };
          else yield { type: "image", url: P.image_url };
        } else yield { type: "image", url: P.image_url };
        continue;
      } else if (e$(P, "media") && U$(P.mimeType) && U$(P.data)) {
        yield { type: "file", mimeType: P.mimeType, data: P.data };
        continue;
      }
      yield { type: "non_standard", value: P };
    }
  }
  __name(q, "q");
  return Array.from(q());
}
__name(ET, "ET");
var RT = { translateContent: ET, translateContentChunk: ET };
globalThis.lc_block_translators_registry ??= /* @__PURE__ */ new Map([["anthropic", WT], ["bedrock-converse", NT], ["google-genai", hT], ["google-vertexai", RT], ["openai", fT]]);
function IT($) {
  return globalThis.lc_block_translators_registry.get($);
}
__name(IT, "IT");
function DT($, q) {
  return nq($ ?? {}, q ?? {});
}
__name(DT, "DT");
function LT($, q) {
  let K = {};
  if ($?.audio !== void 0 || q?.audio !== void 0) K.audio = ($?.audio ?? 0) + (q?.audio ?? 0);
  if ($?.image !== void 0 || q?.image !== void 0) K.image = ($?.image ?? 0) + (q?.image ?? 0);
  if ($?.video !== void 0 || q?.video !== void 0) K.video = ($?.video ?? 0) + (q?.video ?? 0);
  if ($?.document !== void 0 || q?.document !== void 0) K.document = ($?.document ?? 0) + (q?.document ?? 0);
  if ($?.text !== void 0 || q?.text !== void 0) K.text = ($?.text ?? 0) + (q?.text ?? 0);
  return K;
}
__name(LT, "LT");
function CN($, q) {
  let K = { ...LT($, q) };
  if ($?.cache_read !== void 0 || q?.cache_read !== void 0) K.cache_read = ($?.cache_read ?? 0) + (q?.cache_read ?? 0);
  if ($?.cache_creation !== void 0 || q?.cache_creation !== void 0) K.cache_creation = ($?.cache_creation ?? 0) + (q?.cache_creation ?? 0);
  return K;
}
__name(CN, "CN");
function hN($, q) {
  let K = { ...LT($, q) };
  if ($?.reasoning !== void 0 || q?.reasoning !== void 0) K.reasoning = ($?.reasoning ?? 0) + (q?.reasoning ?? 0);
  return K;
}
__name(hN, "hN");
function gT($, q) {
  return { input_tokens: ($?.input_tokens ?? 0) + (q?.input_tokens ?? 0), output_tokens: ($?.output_tokens ?? 0) + (q?.output_tokens ?? 0), total_tokens: ($?.total_tokens ?? 0) + (q?.total_tokens ?? 0), input_token_details: CN($?.input_token_details, q?.input_token_details), output_token_details: hN($?.output_token_details, q?.output_token_details) };
}
__name(gT, "gT");
var _a8;
var YP = (_a8 = class extends yK {
  type = "ai";
  tool_calls = [];
  invalid_tool_calls = [];
  tool_call_chunks = [];
  usage_metadata;
  constructor($) {
    let q;
    if (typeof $ === "string" || Array.isArray($)) q = { content: $, tool_calls: [], invalid_tool_calls: [], tool_call_chunks: [] };
    else if ($.tool_call_chunks === void 0 || $.tool_call_chunks.length === 0) q = { ...$, tool_calls: $.tool_calls ?? [], invalid_tool_calls: [], tool_call_chunks: [], usage_metadata: $.usage_metadata !== void 0 ? $.usage_metadata : void 0 };
    else {
      let P = ($.tool_call_chunks ?? []).reduce((O, z) => {
        let J = O.findIndex(([T]) => {
          if ("id" in z && z.id && "index" in z && z.index !== void 0) return z.id === T.id && z.index === T.index;
          if ("id" in z && z.id) return z.id === T.id;
          if ("index" in z && z.index !== void 0) return z.index === T.index;
          return false;
        });
        if (J !== -1) O[J].push(z);
        else O.push([z]);
        return O;
      }, []), _ = [], Y = [];
      for (let O of P) {
        let z = null, J = O[0]?.name ?? "", T = O.map((V) => V.args || "").join(""), X = T.length ? T : "{}", f = O[0]?.id;
        try {
          if (z = ST(X), !f || z === null || typeof z !== "object" || Array.isArray(z)) throw Error("Malformed tool call chunk args.");
          _.push({ name: J, args: z, id: f, type: "tool_call" });
        } catch {
          Y.push({ name: J, args: X, id: f, error: "Malformed args.", type: "invalid_tool_call" });
        }
      }
      q = { ...$, tool_calls: _, invalid_tool_calls: Y, usage_metadata: $.usage_metadata !== void 0 ? $.usage_metadata : void 0 };
    }
    super(q);
    this.tool_call_chunks = q.tool_call_chunks ?? this.tool_call_chunks, this.tool_calls = q.tool_calls ?? this.tool_calls, this.invalid_tool_calls = q.invalid_tool_calls ?? this.invalid_tool_calls, this.usage_metadata = q.usage_metadata;
  }
  get lc_aliases() {
    return { ...super.lc_aliases, tool_calls: "tool_calls", invalid_tool_calls: "invalid_tool_calls", tool_call_chunks: "tool_call_chunks" };
  }
  static lc_name() {
    return "AIMessageChunk";
  }
  get contentBlocks() {
    if (this.response_metadata && "output_version" in this.response_metadata && this.response_metadata.output_version === "v1") return this.content;
    if (this.response_metadata && "model_provider" in this.response_metadata && typeof this.response_metadata.model_provider === "string") {
      let q = IT(this.response_metadata.model_provider);
      if (q) return q.translateContent(this);
    }
    let $ = super.contentBlocks;
    if (this.tool_calls) {
      if (typeof this.content !== "string") {
        let q = this.content.filter((K) => K.type === "tool_call").map((K) => K.id);
        for (let K of this.tool_calls) if (K.id && !q.includes(K.id)) $.push({ ...K, type: "tool_call", id: K.id, name: K.name, args: K.args });
      }
    }
    return $;
  }
  get _printableFields() {
    return { ...super._printableFields, tool_calls: this.tool_calls, tool_call_chunks: this.tool_call_chunks, invalid_tool_calls: this.invalid_tool_calls, usage_metadata: this.usage_metadata };
  }
  concat($) {
    let q = { content: bK(this.content, $.content), additional_kwargs: nq(this.additional_kwargs, $.additional_kwargs), response_metadata: DT(this.response_metadata, $.response_metadata), tool_call_chunks: [], id: this.id ?? $.id };
    if (this.tool_call_chunks !== void 0 || $.tool_call_chunks !== void 0) {
      let P = OP(this.tool_call_chunks, $.tool_call_chunks);
      if (P !== void 0 && P.length > 0) q.tool_call_chunks = P;
    }
    if (this.usage_metadata !== void 0 || $.usage_metadata !== void 0) q.usage_metadata = gT(this.usage_metadata, $.usage_metadata);
    return new this.constructor(q);
  }
  static isInstance($) {
    return super.isInstance($) && $.type === "ai";
  }
}, __name(_a8, "YP"), _a8);
function bT($, q = "Human", K = "AI") {
  let P = [];
  for (let _ of $) {
    let Y;
    if (_._getType() === "human") Y = q;
    else if (_._getType() === "ai") Y = K;
    else if (_._getType() === "system") Y = "System";
    else if (_._getType() === "tool") Y = "Tool";
    else if (_._getType() === "generic") Y = _.role;
    else throw Error(`Got unsupported message type: ${_._getType()}`);
    let O = _.name ? `${_.name}, ` : "", z = typeof _.content === "string" ? _.content : JSON.stringify(_.content, null, 2);
    P.push(`${Y}: ${O}${z}`);
  }
  return P.join(`
`);
}
__name(bT, "bT");
var EN = {};
Z6(EN, { getEnv: /* @__PURE__ */ __name(() => cT, "getEnv"), getEnvironmentVariable: /* @__PURE__ */ __name(() => N8, "getEnvironmentVariable"), getRuntimeEnvironment: /* @__PURE__ */ __name(() => dO, "getRuntimeEnvironment"), isBrowser: /* @__PURE__ */ __name(() => yT, "isBrowser"), isDeno: /* @__PURE__ */ __name(() => f1, "isDeno"), isJsDom: /* @__PURE__ */ __name(() => xT, "isJsDom"), isNode: /* @__PURE__ */ __name(() => pT, "isNode"), isWebWorker: /* @__PURE__ */ __name(() => uT, "isWebWorker") });
var yT = /* @__PURE__ */ __name(() => typeof window < "u" && typeof window.document < "u", "yT");
var uT = /* @__PURE__ */ __name(() => typeof globalThis === "object" && globalThis.constructor && globalThis.constructor.name === "DedicatedWorkerGlobalScope", "uT");
var xT = /* @__PURE__ */ __name(() => typeof window < "u" && window.name === "nodejs" || typeof navigator < "u" && navigator.userAgent.includes("jsdom"), "xT");
var f1 = /* @__PURE__ */ __name(() => typeof Deno < "u", "f1");
var pT = /* @__PURE__ */ __name(() => typeof process < "u" && typeof process.versions < "u" && typeof process.versions.node < "u" && !f1(), "pT");
var cT = /* @__PURE__ */ __name(() => {
  let $;
  if (yT()) $ = "browser";
  else if (pT()) $ = "node";
  else if (uT()) $ = "webworker";
  else if (xT()) $ = "jsdom";
  else if (f1()) $ = "deno";
  else $ = "other";
  return $;
}, "cT");
var mO;
function dO() {
  if (mO === void 0) mO = { library: "langchain-js", runtime: cT() };
  return mO;
}
__name(dO, "dO");
function N8($) {
  try {
    if (typeof process < "u") return process.env?.[$];
    else if (f1()) return Deno?.env.get($);
    else return;
  } catch {
    return;
  }
}
__name(N8, "N8");
var mT = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;
function RN($) {
  return typeof $ === "string" && mT.test($);
}
__name(RN, "RN");
var l_ = RN;
var Aq = [];
for (jP = 0; jP < 256; ++jP) Aq.push((jP + 256).toString(16).slice(1));
var jP;
function dT($, q = 0) {
  return (Aq[$[q + 0]] + Aq[$[q + 1]] + Aq[$[q + 2]] + Aq[$[q + 3]] + "-" + Aq[$[q + 4]] + Aq[$[q + 5]] + "-" + Aq[$[q + 6]] + Aq[$[q + 7]] + "-" + Aq[$[q + 8]] + Aq[$[q + 9]] + "-" + Aq[$[q + 10]] + Aq[$[q + 11]] + Aq[$[q + 12]] + Aq[$[q + 13]] + Aq[$[q + 14]] + Aq[$[q + 15]]).toLowerCase();
}
__name(dT, "dT");
var Z1;
var IN = new Uint8Array(16);
function lO() {
  if (!Z1) {
    if (Z1 = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto), !Z1) throw Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
  }
  return Z1(IN);
}
__name(lO, "lO");
var DN = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var rO = { randomUUID: DN };
function LN($, q, K) {
  if (rO.randomUUID && !q && !$) return rO.randomUUID();
  $ = $ || {};
  var P = $.random || ($.rng || lO)();
  if (P[6] = P[6] & 15 | 64, P[8] = P[8] & 63 | 128, q) {
    K = K || 0;
    for (var _ = 0; _ < 16; ++_) q[K + _] = P[_];
    return q;
  }
  return dT(P);
}
__name(LN, "LN");
var iq = LN;
var bN = {};
Z6(bN, { BaseCallbackHandler: /* @__PURE__ */ __name(() => Y_, "BaseCallbackHandler"), callbackHandlerPrefersStreaming: /* @__PURE__ */ __name(() => uN, "callbackHandlerPrefersStreaming"), isBaseCallbackHandler: /* @__PURE__ */ __name(() => oO, "isBaseCallbackHandler") });
var _a9;
var yN = (_a9 = class {
}, __name(_a9, "yN"), _a9);
function uN($) {
  return "lc_prefer_streaming" in $ && $.lc_prefer_streaming;
}
__name(uN, "uN");
var _a10;
var Y_ = (_a10 = class extends yN {
  lc_serializable = false;
  get lc_namespace() {
    return ["langchain_core", "callbacks", this.name];
  }
  get lc_secrets() {
    return;
  }
  get lc_attributes() {
    return;
  }
  get lc_aliases() {
    return;
  }
  get lc_serializable_keys() {
    return;
  }
  static lc_name() {
    return this.name;
  }
  get lc_id() {
    return [...this.lc_namespace, J1(this.constructor)];
  }
  lc_kwargs;
  ignoreLLM = false;
  ignoreChain = false;
  ignoreAgent = false;
  ignoreRetriever = false;
  ignoreCustomEvent = false;
  raiseError = false;
  awaitHandlers = N8("LANGCHAIN_CALLBACKS_BACKGROUND") === "false";
  constructor($) {
    super();
    if (this.lc_kwargs = $ || {}, $) this.ignoreLLM = $.ignoreLLM ?? this.ignoreLLM, this.ignoreChain = $.ignoreChain ?? this.ignoreChain, this.ignoreAgent = $.ignoreAgent ?? this.ignoreAgent, this.ignoreRetriever = $.ignoreRetriever ?? this.ignoreRetriever, this.ignoreCustomEvent = $.ignoreCustomEvent ?? this.ignoreCustomEvent, this.raiseError = $.raiseError ?? this.raiseError, this.awaitHandlers = this.raiseError || ($._awaitHandler ?? this.awaitHandlers);
  }
  copy() {
    return new this.constructor(this);
  }
  toJSON() {
    return DK.prototype.toJSON.call(this);
  }
  toJSONNotImplemented() {
    return DK.prototype.toJSONNotImplemented.call(this);
  }
  static fromMethods($) {
    const _q = class _q extends Y_ {
      name = iq();
      constructor() {
        super();
        Object.assign(this, $);
      }
    };
    __name(_q, "q");
    let q = _q;
    return new q();
  }
}, __name(_a10, "Y_"), _a10);
var oO = /* @__PURE__ */ __name(($) => {
  let q = $;
  return q !== void 0 && typeof q.copy === "function" && typeof q.name === "string" && typeof q.awaitHandlers === "boolean";
}, "oO");
var kq = [];
for (vP = 0; vP < 256; ++vP) kq.push((vP + 256).toString(16).slice(1));
var vP;
function X1($, q = 0) {
  return (kq[$[q + 0]] + kq[$[q + 1]] + kq[$[q + 2]] + kq[$[q + 3]] + "-" + kq[$[q + 4]] + kq[$[q + 5]] + "-" + kq[$[q + 6]] + kq[$[q + 7]] + "-" + kq[$[q + 8]] + kq[$[q + 9]] + "-" + kq[$[q + 10]] + kq[$[q + 11]] + kq[$[q + 12]] + kq[$[q + 13]] + kq[$[q + 14]] + kq[$[q + 15]]).toLowerCase();
}
__name(X1, "X1");
var A1;
var xN = new Uint8Array(16);
function zP() {
  if (!A1) {
    if (A1 = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto), !A1) throw Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
  }
  return A1(xN);
}
__name(zP, "zP");
var pN = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var nO = { randomUUID: pN };
function cN($, q, K) {
  if (nO.randomUUID && !q && !$) return nO.randomUUID();
  $ = $ || {};
  var P = $.random || ($.rng || zP)();
  if (P[6] = P[6] & 15 | 64, P[8] = P[8] & 63 | 128, q) {
    K = K || 0;
    for (var _ = 0; _ < 16; ++_) q[K + _] = P[_];
    return q;
  }
  return X1(P);
}
__name(cN, "cN");
var j_ = cN;
var lT = null;
var rT = null;
var C8 = 0;
function mN($, q, K) {
  $ = $ || {};
  var P = q && K || 0, _ = q || new Uint8Array(16), Y = $.random || ($.rng || zP)(), O = $.msecs !== void 0 ? $.msecs : Date.now(), z = $.seq !== void 0 ? $.seq : null, J = rT, T = lT;
  if (O > C8 && $.msecs === void 0) {
    if (C8 = O, z !== null) J = null, T = null;
  }
  if (z !== null) {
    if (z > 2147483647) z = 2147483647;
    J = z >>> 19 & 4095, T = z & 524287;
  }
  if (J === null || T === null) J = Y[6] & 127, J = J << 8 | Y[7], T = Y[8] & 63, T = T << 8 | Y[9], T = T << 5 | Y[10] >>> 3;
  if (O + 1e4 > C8 && z === null) {
    if (++T > 524287) {
      if (T = 0, ++J > 4095) J = 0, C8++;
    }
  } else C8 = O;
  return rT = J, lT = T, _[P++] = C8 / 1099511627776 & 255, _[P++] = C8 / 4294967296 & 255, _[P++] = C8 / 16777216 & 255, _[P++] = C8 / 65536 & 255, _[P++] = C8 / 256 & 255, _[P++] = C8 & 255, _[P++] = J >>> 4 & 15 | 112, _[P++] = J & 255, _[P++] = T >>> 13 & 63 | 128, _[P++] = T >>> 5 & 255, _[P++] = T << 3 & 255 | Y[10] & 7, _[P++] = Y[11], _[P++] = Y[12], _[P++] = Y[13], _[P++] = Y[14], _[P++] = Y[15], q || X1(_);
}
__name(mN, "mN");
var iO = mN;
var oT = "gen_ai.operation.name";
var nT = "gen_ai.system";
var tO = "gen_ai.request.model";
var iT = "gen_ai.response.model";
var BO = "gen_ai.usage.input_tokens";
var UO = "gen_ai.usage.output_tokens";
var FO = "gen_ai.usage.total_tokens";
var tT = "gen_ai.request.max_tokens";
var BT = "gen_ai.request.temperature";
var UT = "gen_ai.request.top_p";
var FT = "gen_ai.request.frequency_penalty";
var aT = "gen_ai.request.presence_penalty";
var QT = "gen_ai.response.finish_reasons";
var eT = "gen_ai.prompt";
var sT = "gen_ai.completion";
var $w = "gen_ai.request.extra_query";
var qw = "gen_ai.request.extra_body";
var Kw = "gen_ai.serialized.name";
var _w = "gen_ai.serialized.signature";
var Pw = "gen_ai.serialized.doc";
var Ow = "gen_ai.response.id";
var Yw = "gen_ai.response.service_tier";
var jw = "gen_ai.response.system_fingerprint";
var vw = "gen_ai.usage.input_token_details";
var zw = "gen_ai.usage.output_token_details";
var Ww = "langsmith.trace.session_id";
var Hw = "langsmith.trace.session_name";
var Jw = "langsmith.span.kind";
var Tw = "langsmith.trace.name";
var ww = "langsmith.metadata";
var aO = "langsmith.span.tags";
var fw = "langsmith.request.streaming";
var Zw = "langsmith.request.headers";
var rN = /* @__PURE__ */ __name((...$) => fetch(...$), "rN");
var Xw = Symbol.for("ls:fetch_implementation");
var Aw = /* @__PURE__ */ __name(() => {
  let $ = globalThis[Xw];
  if (!$) return false;
  return typeof $ === "function" && "Headers" in $ && "Request" in $ && "Response" in $;
}, "Aw");
var kw = /* @__PURE__ */ __name(($) => {
  return async (...q) => {
    if ($ || r6("DEBUG") === "true") {
      let [P, _] = q;
      console.log(` ${_?.method || "GET"} ${P}`);
    }
    let K = await (globalThis[Xw] ?? rN)(...q);
    if ($ || r6("DEBUG") === "true") console.log(` ${K.status} ${K.statusText} ${K.url}`);
    return K;
  };
}, "kw");
var WP = /* @__PURE__ */ __name(() => {
  return r6("PROJECT") ?? P8("LANGCHAIN_SESSION") ?? "default";
}, "WP");
var Gw = {};
function v_($) {
  if (!Gw[$]) console.warn($), Gw[$] = true;
}
__name(v_, "v_");
var Sw = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
var Vw = false;
function O6($, q) {
  if (!Sw.test($)) {
    let K = q !== void 0 ? `Invalid UUID for ${q}: ${$}` : `Invalid UUID: ${$}`;
    throw Error(K);
  }
  return $;
}
__name(O6, "O6");
function k1($) {
  let q = typeof $ === "string" ? Date.parse($) : $;
  return iO({ msecs: q, seq: 0 });
}
__name(k1, "k1");
function oN($) {
  if (!Sw.test($)) return null;
  let q = $[14];
  return parseInt(q, 16);
}
__name(oN, "oN");
function G1($, q) {
  let K = oN($);
  if (K !== null && K !== 7 && !Vw) Vw = true, v_("LangSmith now uses UUID v7 for run and trace identifiers. This warning appears when passing custom IDs. Please use: import { uuidv7 } from 'langsmith'; const id = uuidv7(); Future versions will require UUID v7.");
}
__name(G1, "G1");
var V1 = "0.3.80";
var m8;
var nN = /* @__PURE__ */ __name(() => typeof window < "u" && typeof window.document < "u", "nN");
var iN = /* @__PURE__ */ __name(() => typeof globalThis === "object" && globalThis.constructor && globalThis.constructor.name === "DedicatedWorkerGlobalScope", "iN");
var tN = /* @__PURE__ */ __name(() => typeof window < "u" && window.name === "nodejs" || typeof navigator < "u" && navigator.userAgent.includes("jsdom"), "tN");
var Mw = /* @__PURE__ */ __name(() => typeof Deno < "u", "Mw");
var BN = /* @__PURE__ */ __name(() => typeof process < "u" && typeof process.versions < "u" && typeof process.versions.node < "u" && !Mw(), "BN");
var sO = /* @__PURE__ */ __name(() => {
  if (m8) return m8;
  if (typeof Bun < "u") m8 = "bun";
  else if (nN()) m8 = "browser";
  else if (BN()) m8 = "node";
  else if (iN()) m8 = "webworker";
  else if (tN()) m8 = "jsdom";
  else if (Mw()) m8 = "deno";
  else m8 = "other";
  return m8;
}, "sO");
var QO;
function S1() {
  if (QO === void 0) {
    let $ = sO(), q = FN();
    QO = { library: "langsmith", runtime: $, sdk: "langsmith-js", sdk_version: V1, ...q };
  }
  return QO;
}
__name(S1, "S1");
function $2() {
  let $ = UN(), q = {}, K = ["LANGCHAIN_API_KEY", "LANGCHAIN_ENDPOINT", "LANGCHAIN_TRACING_V2", "LANGCHAIN_PROJECT", "LANGCHAIN_SESSION", "LANGSMITH_API_KEY", "LANGSMITH_ENDPOINT", "LANGSMITH_TRACING_V2", "LANGSMITH_PROJECT", "LANGSMITH_SESSION"];
  for (let [P, _] of Object.entries($)) if (typeof _ === "string" && !K.includes(P) && !P.toLowerCase().includes("key") && !P.toLowerCase().includes("secret") && !P.toLowerCase().includes("token")) if (P === "LANGCHAIN_REVISION_ID") q.revision_id = _;
  else q[P] = _;
  return q;
}
__name($2, "$2");
function UN() {
  let $ = {};
  try {
    if (typeof process < "u" && process.env) {
      for (let [q, K] of Object.entries(process.env)) if ((q.startsWith("LANGCHAIN_") || q.startsWith("LANGSMITH_")) && K != null) if ((q.toLowerCase().includes("key") || q.toLowerCase().includes("secret") || q.toLowerCase().includes("token")) && typeof K === "string") $[q] = K.slice(0, 2) + "*".repeat(K.length - 4) + K.slice(-2);
      else $[q] = K;
    }
  } catch (q) {
  }
  return $;
}
__name(UN, "UN");
function P8($) {
  try {
    return typeof process < "u" ? process.env?.[$] : void 0;
  } catch (q) {
    return;
  }
}
__name(P8, "P8");
function r6($) {
  return P8(`LANGSMITH_${$}`) || P8(`LANGCHAIN_${$}`);
}
__name(r6, "r6");
var eO;
function FN() {
  if (eO !== void 0) return eO;
  let $ = ["VERCEL_GIT_COMMIT_SHA", "NEXT_PUBLIC_VERCEL_GIT_COMMIT_SHA", "COMMIT_REF", "RENDER_GIT_COMMIT", "CI_COMMIT_SHA", "CIRCLE_SHA1", "CF_PAGES_COMMIT_SHA", "REACT_APP_GIT_SHA", "SOURCE_VERSION", "GITHUB_SHA", "TRAVIS_COMMIT", "GIT_COMMIT", "BUILD_VCS_NUMBER", "bamboo_planRepository_revision", "Build.SourceVersion", "BITBUCKET_COMMIT", "DRONE_COMMIT_SHA", "SEMAPHORE_GIT_SHA", "BUILDKITE_COMMIT"], q = {};
  for (let K of $) {
    let P = P8(K);
    if (P !== void 0) q[K] = P;
  }
  return eO = q, q;
}
__name(FN, "FN");
function M1() {
  return P8("OTEL_ENABLED") === "true" || r6("OTEL_ENABLED") === "true";
}
__name(M1, "M1");
var _Cw = class _Cw {
  constructor() {
    Object.defineProperty(this, "hasWarned", { enumerable: true, configurable: true, writable: true, value: false });
  }
  startActiveSpan($, ...q) {
    if (!this.hasWarned && M1()) console.warn('You have enabled OTEL export via the `OTEL_ENABLED` or `LANGSMITH_OTEL_ENABLED` environment variable, but have not initialized the required OTEL instances. Please add:\n```\nimport { initializeOTEL } from "langsmith/experimental/otel/setup";\ninitializeOTEL();\n```\nat the beginning of your code.'), this.hasWarned = true;
    let K;
    if (q.length === 1 && typeof q[0] === "function") K = q[0];
    else if (q.length === 2 && typeof q[1] === "function") K = q[1];
    else if (q.length === 3 && typeof q[2] === "function") K = q[2];
    if (typeof K === "function") return K();
    return;
  }
};
__name(_Cw, "Cw");
var Cw = _Cw;
var _hw = class _hw {
  constructor() {
    Object.defineProperty(this, "mockTracer", { enumerable: true, configurable: true, writable: true, value: new Cw() });
  }
  getTracer($, q) {
    return this.mockTracer;
  }
  getActiveSpan() {
    return;
  }
  setSpan($, q) {
    return $;
  }
  getSpan($) {
    return;
  }
  setSpanContext($, q) {
    return $;
  }
  getTracerProvider() {
    return;
  }
  setGlobalTracerProvider($) {
    return false;
  }
};
__name(_hw, "hw");
var hw = _hw;
var _Ew = class _Ew {
  active() {
    return {};
  }
  with($, q) {
    return q();
  }
};
__name(_Ew, "Ew");
var Ew = _Ew;
var q2 = Symbol.for("ls:otel_trace");
var K2 = Symbol.for("ls:otel_context");
var Nw = Symbol.for("ls:otel_get_default_otlp_tracer_provider");
var aN = new hw();
var QN = new Ew();
var _Rw = class _Rw {
  getTraceInstance() {
    return globalThis[q2] ?? aN;
  }
  getContextInstance() {
    return globalThis[K2] ?? QN;
  }
  initializeGlobalInstances($) {
    if (globalThis[q2] === void 0) globalThis[q2] = $.trace;
    if (globalThis[K2] === void 0) globalThis[K2] = $.context;
  }
  setDefaultOTLPTracerComponents($) {
    globalThis[Nw] = $;
  }
  getDefaultOTLPTracerComponents() {
    return globalThis[Nw] ?? void 0;
  }
};
__name(_Rw, "Rw");
var Rw = _Rw;
var _2 = new Rw();
function N1() {
  return _2.getTraceInstance();
}
__name(N1, "N1");
function Iw() {
  return _2.getContextInstance();
}
__name(Iw, "Iw");
function Dw() {
  return _2.getDefaultOTLPTracerComponents();
}
__name(Dw, "Dw");
var eN = { llm: "chat", tool: "execute_tool", retriever: "embeddings", embedding: "embeddings", prompt: "chat" };
function sN($) {
  return eN[$] || $;
}
__name(sN, "sN");
var _P2 = class _P2 {
  constructor() {
    Object.defineProperty(this, "spans", { enumerable: true, configurable: true, writable: true, value: /* @__PURE__ */ new Map() });
  }
  exportBatch($, q) {
    for (let K of $) try {
      if (!K.run) continue;
      if (K.operation === "post") {
        let P = this.createSpanForRun(K, K.run, q.get(K.id));
        if (P && !K.run.end_time) this.spans.set(K.id, P);
      } else this.updateSpanForRun(K, K.run);
    } catch (P) {
      console.error(`Error processing operation ${K.id}:`, P);
    }
  }
  createSpanForRun($, q, K) {
    let P = K && N1().getSpan(K);
    if (!P) return;
    try {
      return this.finishSpanSetup(P, q, $);
    } catch (_) {
      console.error(`Failed to create span for run ${$.id}:`, _);
      return;
    }
  }
  finishSpanSetup($, q, K) {
    if (this.setSpanAttributes($, q, K), q.error) $.setStatus({ code: 2 }), $.recordException(Error(q.error));
    else $.setStatus({ code: 1 });
    if (q.end_time) $.end(new Date(q.end_time));
    return $;
  }
  updateSpanForRun($, q) {
    try {
      let K = this.spans.get($.id);
      if (!K) {
        console.debug(`No span found for run ${$.id} during update`);
        return;
      }
      if (this.setSpanAttributes(K, q, $), q.error) K.setStatus({ code: 2 }), K.recordException(Error(q.error));
      else K.setStatus({ code: 1 });
      let P = q.end_time;
      if (P) K.end(new Date(P)), this.spans.delete($.id);
    } catch (K) {
      console.error(`Failed to update span for run ${$.id}:`, K);
    }
  }
  extractModelName($) {
    if ($.extra?.metadata) {
      let q = $.extra.metadata;
      if (q.ls_model_name) return q.ls_model_name;
      if (q.invocation_params) {
        let K = q.invocation_params;
        if (K.model) return K.model;
        else if (K.model_name) return K.model_name;
      }
    }
    return;
  }
  setSpanAttributes($, q, K) {
    if ("run_type" in q && q.run_type) {
      $.setAttribute(Jw, q.run_type);
      let O = sN(q.run_type || "chain");
      $.setAttribute(oT, O);
    }
    if ("name" in q && q.name) $.setAttribute(Tw, q.name);
    if ("session_id" in q && q.session_id) $.setAttribute(Ww, q.session_id);
    if ("session_name" in q && q.session_name) $.setAttribute(Hw, q.session_name);
    this.setGenAiSystem($, q);
    let P = this.extractModelName(q);
    if (P) $.setAttribute(tO, P);
    if ("prompt_tokens" in q && typeof q.prompt_tokens === "number") $.setAttribute(BO, q.prompt_tokens);
    if ("completion_tokens" in q && typeof q.completion_tokens === "number") $.setAttribute(UO, q.completion_tokens);
    if ("total_tokens" in q && typeof q.total_tokens === "number") $.setAttribute(FO, q.total_tokens);
    this.setInvocationParameters($, q);
    let _ = q.extra?.metadata || {};
    for (let [O, z] of Object.entries(_)) if (z !== null && z !== void 0) $.setAttribute(`${ww}.${O}`, String(z));
    let Y = q.tags;
    if (Y && Array.isArray(Y)) $.setAttribute(aO, Y.join(", "));
    else if (Y) $.setAttribute(aO, String(Y));
    if ("serialized" in q && typeof q.serialized === "object") {
      let O = q.serialized;
      if (O.name) $.setAttribute(Kw, String(O.name));
      if (O.signature) $.setAttribute(_w, String(O.signature));
      if (O.doc) $.setAttribute(Pw, String(O.doc));
    }
    this.setIOAttributes($, K);
  }
  setGenAiSystem($, q) {
    let K = "langchain", P = this.extractModelName(q);
    if (P) {
      let _ = P.toLowerCase();
      if (_.includes("anthropic") || _.startsWith("claude")) K = "anthropic";
      else if (_.includes("bedrock")) K = "aws.bedrock";
      else if (_.includes("azure") && _.includes("openai")) K = "az.ai.openai";
      else if (_.includes("azure") && _.includes("inference")) K = "az.ai.inference";
      else if (_.includes("cohere")) K = "cohere";
      else if (_.includes("deepseek")) K = "deepseek";
      else if (_.includes("gemini")) K = "gemini";
      else if (_.includes("groq")) K = "groq";
      else if (_.includes("watson") || _.includes("ibm")) K = "ibm.watsonx.ai";
      else if (_.includes("mistral")) K = "mistral_ai";
      else if (_.includes("gpt") || _.includes("openai")) K = "openai";
      else if (_.includes("perplexity") || _.includes("sonar")) K = "perplexity";
      else if (_.includes("vertex")) K = "vertex_ai";
      else if (_.includes("xai") || _.includes("grok")) K = "xai";
    }
    $.setAttribute(nT, K);
  }
  setInvocationParameters($, q) {
    if (!q.extra?.metadata?.invocation_params) return;
    let K = q.extra.metadata.invocation_params;
    if (K.max_tokens !== void 0) $.setAttribute(tT, K.max_tokens);
    if (K.temperature !== void 0) $.setAttribute(BT, K.temperature);
    if (K.top_p !== void 0) $.setAttribute(UT, K.top_p);
    if (K.frequency_penalty !== void 0) $.setAttribute(FT, K.frequency_penalty);
    if (K.presence_penalty !== void 0) $.setAttribute(aT, K.presence_penalty);
  }
  setIOAttributes($, q) {
    if (q.run.inputs) try {
      let K = q.run.inputs;
      if (typeof K === "object" && K !== null) {
        if (K.model && Array.isArray(K.messages)) $.setAttribute(tO, K.model);
        if (K.stream !== void 0) $.setAttribute(fw, K.stream);
        if (K.extra_headers) $.setAttribute(Zw, JSON.stringify(K.extra_headers));
        if (K.extra_query) $.setAttribute($w, JSON.stringify(K.extra_query));
        if (K.extra_body) $.setAttribute(qw, JSON.stringify(K.extra_body));
      }
      $.setAttribute(eT, JSON.stringify(K));
    } catch (K) {
      console.debug(`Failed to process inputs for run ${q.id}`, K);
    }
    if (q.run.outputs) try {
      let K = q.run.outputs, P = this.getUnifiedRunTokens(K);
      if (P) $.setAttribute(BO, P[0]), $.setAttribute(UO, P[1]), $.setAttribute(FO, P[0] + P[1]);
      if (K && typeof K === "object") {
        if (K.model) $.setAttribute(iT, String(K.model));
        if (K.id) $.setAttribute(Ow, K.id);
        if (K.choices && Array.isArray(K.choices)) {
          let _ = K.choices.map((Y) => Y.finish_reason).filter((Y) => Y).map(String);
          if (_.length > 0) $.setAttribute(QT, _.join(", "));
        }
        if (K.service_tier) $.setAttribute(Yw, K.service_tier);
        if (K.system_fingerprint) $.setAttribute(jw, K.system_fingerprint);
        if (K.usage_metadata && typeof K.usage_metadata === "object") {
          let _ = K.usage_metadata;
          if (_.input_token_details) $.setAttribute(vw, JSON.stringify(_.input_token_details));
          if (_.output_token_details) $.setAttribute(zw, JSON.stringify(_.output_token_details));
        }
      }
      $.setAttribute(sT, JSON.stringify(K));
    } catch (K) {
      console.debug(`Failed to process outputs for run ${q.id}`, K);
    }
  }
  getUnifiedRunTokens($) {
    if (!$) return null;
    let q = this.extractUnifiedRunTokens($.usage_metadata);
    if (q) return q;
    let K = Object.keys($);
    for (let Y of K) {
      let O = $[Y];
      if (!O || typeof O !== "object") continue;
      if (q = this.extractUnifiedRunTokens(O.usage_metadata), q) return q;
      if (O.lc === 1 && O.kwargs && typeof O.kwargs === "object") {
        if (q = this.extractUnifiedRunTokens(O.kwargs.usage_metadata), q) return q;
      }
    }
    let P = $.generations || [];
    if (!Array.isArray(P)) return null;
    let _ = Array.isArray(P[0]) ? P.flat() : P;
    for (let Y of _) if (typeof Y === "object" && Y.message && typeof Y.message === "object" && Y.message.kwargs && typeof Y.message.kwargs === "object") {
      if (q = this.extractUnifiedRunTokens(Y.message.kwargs.usage_metadata), q) return q;
    }
    return null;
  }
  extractUnifiedRunTokens($) {
    if (!$ || typeof $ !== "object") return null;
    if (typeof $.input_tokens !== "number" || typeof $.output_tokens !== "number") return null;
    return [$.input_tokens, $.output_tokens];
  }
};
__name(_P2, "P2");
var P2 = _P2;
var aw = K8(h1(), 1);
var L1 = K8(D1(), 1);
var GC = [429, 500, 502, 503, 504];
var _g1 = class _g1 {
  constructor($) {
    if (Object.defineProperty(this, "maxConcurrency", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "maxRetries", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "maxQueueSizeBytes", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "queue", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "onFailedResponseHook", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "queueSizeBytes", { enumerable: true, configurable: true, writable: true, value: 0 }), this.maxConcurrency = $.maxConcurrency ?? 1 / 0, this.maxRetries = $.maxRetries ?? 6, this.maxQueueSizeBytes = $.maxQueueSizeBytes, "default" in L1.default) this.queue = new L1.default.default({ concurrency: this.maxConcurrency });
    else this.queue = new L1.default({ concurrency: this.maxConcurrency });
    this.onFailedResponseHook = $?.onFailedResponseHook;
  }
  call($, ...q) {
    return this.callWithOptions({}, $, ...q);
  }
  callWithOptions($, q, ...K) {
    let P = $.sizeBytes ?? 0;
    if (this.maxQueueSizeBytes !== void 0 && P > 0 && this.queueSizeBytes + P > this.maxQueueSizeBytes) return Promise.reject(Error(`Queue size limit (${this.maxQueueSizeBytes} bytes) exceeded. Current queue size: ${this.queueSizeBytes} bytes, attempted addition: ${P} bytes.`));
    if (P > 0) this.queueSizeBytes += P;
    let _ = this.onFailedResponseHook, Y = this.queue.add(() => aw.default(() => q(...K).catch((O) => {
      if (O instanceof Error) throw O;
      else throw Error(O);
    }), { async onFailedAttempt(O) {
      if (O.message.startsWith("Cancel") || O.message.startsWith("TimeoutError") || O.name === "TimeoutError" || O.message.startsWith("AbortError")) throw O;
      if (O?.code === "ECONNABORTED") throw O;
      let z = O?.response;
      if (_) {
        if (await _(z)) return;
      }
      let J = z?.status ?? O?.status;
      if (J) {
        if (!GC.includes(+J)) throw O;
      }
    }, retries: this.maxRetries, randomize: true }), { throwOnTimeout: true });
    if (P > 0) Y = Y.finally(() => {
      this.queueSizeBytes -= P;
    });
    if ($.signal) return Promise.race([Y, new Promise((O, z) => {
      $.signal?.addEventListener("abort", () => {
        z(Error("AbortError"));
      });
    })]);
    return Y;
  }
};
__name(_g1, "g1");
var g1 = _g1;
function v2($) {
  return typeof $?._getType === "function";
}
__name(v2, "v2");
function z2($) {
  let q = { type: $._getType(), data: { content: $.content } };
  if ($?.additional_kwargs && Object.keys($.additional_kwargs).length > 0) q.data.additional_kwargs = { ...$.additional_kwargs };
  return q;
}
__name(z2, "z2");
var TR = K8(lZ(), 1);
function YK($) {
  if (!$ || $.split("/").length > 2 || $.startsWith("/") || $.endsWith("/") || $.split(":").length > 2) throw Error(`Invalid identifier format: ${$}`);
  let [q, K] = $.split(":"), P = K || "latest";
  if (q.includes("/")) {
    let [_, Y] = q.split("/", 2);
    if (!_ || !Y) throw Error(`Invalid identifier format: ${$}`);
    return [_, Y, P];
  } else {
    if (!q) throw Error(`Invalid identifier format: ${$}`);
    return ["-", q, P];
  }
}
__name(YK, "YK");
var _rZ = class _rZ extends Error {
  constructor($) {
    super($);
    Object.defineProperty(this, "status", { enumerable: true, configurable: true, writable: true, value: void 0 }), this.name = "LangSmithConflictError", this.status = 409;
  }
};
__name(_rZ, "rZ");
var rZ = _rZ;
async function $6($, q, K) {
  let P;
  if ($.ok) {
    if (K) P = await $.text();
    return;
  }
  if ($.status === 403) try {
    if ((await $.json())?.error === "org_scoped_key_requires_workspace") P = "This API key is org-scoped and requires workspace specification. Please provide 'workspaceId' parameter, or set LANGSMITH_WORKSPACE_ID environment variable.";
  } catch (O) {
    let z = Error(`${$.status} ${$.statusText}`);
    throw z.status = $?.status, z;
  }
  if (P === void 0) try {
    P = await $.text();
  } catch (O) {
    P = "";
  }
  let _ = `Failed to ${q}. Received status [${$.status}]: ${$.statusText}. Message: ${P}`;
  if ($.status === 409) throw new rZ(_);
  let Y = Error(_);
  throw Y.status = $.status, Y;
}
__name($6, "$6");
var oZ = "ERR_CONFLICTING_ENDPOINTS";
var _C2 = class _C2 extends Error {
  constructor() {
    super("You cannot provide both LANGSMITH_ENDPOINT / LANGCHAIN_ENDPOINT and LANGSMITH_RUNS_ENDPOINTS.");
    Object.defineProperty(this, "code", { enumerable: true, configurable: true, writable: true, value: oZ }), this.name = "ConflictingEndpointsError";
  }
};
__name(_C2, "C2");
var C2 = _C2;
function nZ($) {
  return typeof $ === "object" && $ !== null && $.code === oZ;
}
__name(nZ, "nZ");
var iZ = "[...]";
var wR = { result: "[Circular]" };
var B1 = [];
var o_ = [];
var fR = new TextEncoder();
function ZR() {
  return { depthLimit: Number.MAX_SAFE_INTEGER, edgesLimit: Number.MAX_SAFE_INTEGER };
}
__name(ZR, "ZR");
function t1($) {
  return fR.encode($);
}
__name(t1, "t1");
function tZ($) {
  if ($ && typeof $ === "object" && $ !== null) {
    if ($ instanceof Map) return Object.fromEntries($);
    else if ($ instanceof Set) return Array.from($);
    else if ($ instanceof Date) return $.toISOString();
    else if ($ instanceof RegExp) return $.toString();
    else if ($ instanceof Error) return { name: $.name, message: $.message };
  } else if (typeof $ === "bigint") return $.toString();
  return $;
}
__name(tZ, "tZ");
function XR($) {
  return function(q, K) {
    if ($) {
      let P = $.call(this, q, K);
      if (P !== void 0) return P;
    }
    return tZ(K);
  };
}
__name(XR, "XR");
function tq($, q, K, P, _) {
  try {
    let Y = JSON.stringify($, XR(K), P);
    return t1(Y);
  } catch (Y) {
    if (!Y.message?.includes("Converting circular structure to JSON")) return console.warn(`[WARNING]: LangSmith received unserializable value.${q ? `
Context: ${q}` : ""}`), t1("[Unserializable]");
    if (r6("SUPPRESS_CIRCULAR_JSON_WARNINGS") !== "true" && console.warn(`[WARNING]: LangSmith received circular JSON. This will decrease tracer performance. ${q ? `
Context: ${q}` : ""}`), typeof _ > "u") _ = ZR();
    E2($, "", 0, [], void 0, 0, _);
    let O;
    try {
      if (o_.length === 0) O = JSON.stringify($, K, P);
      else O = JSON.stringify($, AR(K), P);
    } catch (z) {
      return t1("[unable to serialize, circular reference is too complex to analyze]");
    } finally {
      while (B1.length !== 0) {
        let z = B1.pop();
        if (z.length === 4) Object.defineProperty(z[0], z[1], z[3]);
        else z[0][z[1]] = z[2];
      }
    }
    return t1(O);
  }
}
__name(tq, "tq");
function h2($, q, K, P) {
  var _ = Object.getOwnPropertyDescriptor(P, K);
  if (_.get !== void 0) if (_.configurable) Object.defineProperty(P, K, { value: $ }), B1.push([P, K, q, _]);
  else o_.push([q, K, $]);
  else P[K] = $, B1.push([P, K, q]);
}
__name(h2, "h2");
function E2($, q, K, P, _, Y, O) {
  Y += 1;
  var z;
  if (typeof $ === "object" && $ !== null) {
    for (z = 0; z < P.length; z++) if (P[z] === $) {
      h2(wR, $, q, _);
      return;
    }
    if (typeof O.depthLimit < "u" && Y > O.depthLimit) {
      h2(iZ, $, q, _);
      return;
    }
    if (typeof O.edgesLimit < "u" && K + 1 > O.edgesLimit) {
      h2(iZ, $, q, _);
      return;
    }
    if (P.push($), Array.isArray($)) for (z = 0; z < $.length; z++) E2($[z], z, z, P, $, Y, O);
    else {
      $ = tZ($);
      var J = Object.keys($);
      for (z = 0; z < J.length; z++) {
        var T = J[z];
        E2($[T], T, z, P, $, Y, O);
      }
    }
    P.pop();
  }
}
__name(E2, "E2");
function AR($) {
  return $ = typeof $ < "u" ? $ : function(q, K) {
    return K;
  }, function(q, K) {
    if (o_.length > 0) for (var P = 0; P < o_.length; P++) {
      var _ = o_[P];
      if (_[1] === q && _[0] === K) {
        K = _[2], o_.splice(P, 1);
        break;
      }
    }
    return $.call(this, q, K);
  };
}
__name(AR, "AR");
function BZ($, q) {
  let K = S1(), P = q ?? $2(), _ = $.extra ?? {}, Y = _.metadata;
  return $.extra = { ..._, runtime: { ...K, ..._?.runtime }, metadata: { ...P, ...P.revision_id || "revision_id" in $ && $.revision_id ? { revision_id: ("revision_id" in $ ? $.revision_id : void 0) ?? P.revision_id } : {}, ...Y } }, $;
}
__name(BZ, "BZ");
var kR = /* @__PURE__ */ __name(($) => {
  let q = $?.toString() ?? r6("TRACING_SAMPLING_RATE");
  if (q === void 0) return;
  let K = parseFloat(q);
  if (K < 0 || K > 1) throw Error(`LANGSMITH_TRACING_SAMPLING_RATE must be between 0 and 1 if set. Got: ${K}`);
  return K;
}, "kR");
var GR = /* @__PURE__ */ __name(($) => {
  let K = $.replace("http://", "").replace("https://", "").split("/")[0].split(":")[0];
  return K === "localhost" || K === "127.0.0.1" || K === "::1";
}, "GR");
async function VR($) {
  let q = [];
  for await (let K of $) q.push(K);
  return q;
}
__name(VR, "VR");
function U1($) {
  if ($ === void 0) return;
  return $.trim().replace(/^"(.*)"$/, "$1").replace(/^'(.*)'$/, "$1");
}
__name(U1, "U1");
var SR = /* @__PURE__ */ __name(async ($) => {
  if ($?.status === 429) {
    let q = parseInt($.headers.get("retry-after") ?? "10", 10) * 1e3;
    if (q > 0) return await new Promise((K) => setTimeout(K, q)), true;
  }
  return false;
}, "SR");
function UZ($) {
  if (typeof $ === "number") return Number($.toFixed(4));
  return $;
}
__name(UZ, "UZ");
var MR = 25165824;
var QZ = 1073741824;
var NR = 1e4;
var CR = 100;
var FZ = "https://api.smith.langchain.com";
var _eZ = class _eZ {
  constructor($) {
    Object.defineProperty(this, "items", { enumerable: true, configurable: true, writable: true, value: [] }), Object.defineProperty(this, "sizeBytes", { enumerable: true, configurable: true, writable: true, value: 0 }), Object.defineProperty(this, "maxSizeBytes", { enumerable: true, configurable: true, writable: true, value: void 0 }), this.maxSizeBytes = $ ?? QZ;
  }
  peek() {
    return this.items[0];
  }
  push($) {
    let q, K = new Promise((_) => {
      q = _;
    }), P = tq($.item, `Serializing run with id: ${$.item.id}`).length;
    if (this.sizeBytes + P > this.maxSizeBytes && this.items.length > 0) return console.warn(`AutoBatchQueue size limit (${this.maxSizeBytes} bytes) exceeded. Dropping run with id: ${$.item.id}. Current queue size: ${this.sizeBytes} bytes, attempted addition: ${P} bytes.`), q(), K;
    return this.items.push({ action: $.action, payload: $.item, otelContext: $.otelContext, apiKey: $.apiKey, apiUrl: $.apiUrl, itemPromiseResolve: q, itemPromise: K, size: P }), this.sizeBytes += P, K;
  }
  pop({ upToSizeBytes: $, upToSize: q }) {
    if ($ < 1) throw Error("Number of bytes to pop off may not be less than 1.");
    let K = [], P = 0;
    while (P + (this.peek()?.size ?? 0) < $ && this.items.length > 0 && K.length < q) {
      let _ = this.items.shift();
      if (_) K.push(_), P += _.size, this.sizeBytes -= _.size;
    }
    if (K.length === 0 && this.items.length > 0) {
      let _ = this.items.shift();
      K.push(_), P += _.size, this.sizeBytes -= _.size;
    }
    return [K.map((_) => ({ action: _.action, item: _.payload, otelContext: _.otelContext, apiKey: _.apiKey, apiUrl: _.apiUrl, size: _.size })), () => K.forEach((_) => _.itemPromiseResolve())];
  }
};
__name(_eZ, "eZ");
var eZ = _eZ;
var _uK = class _uK {
  get _fetch() {
    return this.fetchImplementation || kw(this.debug);
  }
  constructor($ = {}) {
    Object.defineProperty(this, "apiKey", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "apiUrl", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "webUrl", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "workspaceId", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "caller", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "batchIngestCaller", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "timeout_ms", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "_tenantId", { enumerable: true, configurable: true, writable: true, value: null }), Object.defineProperty(this, "hideInputs", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "hideOutputs", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "tracingSampleRate", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "filteredPostUuids", { enumerable: true, configurable: true, writable: true, value: /* @__PURE__ */ new Set() }), Object.defineProperty(this, "autoBatchTracing", { enumerable: true, configurable: true, writable: true, value: true }), Object.defineProperty(this, "autoBatchQueue", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "autoBatchTimeout", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "autoBatchAggregationDelayMs", { enumerable: true, configurable: true, writable: true, value: 250 }), Object.defineProperty(this, "batchSizeBytesLimit", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "batchSizeLimit", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "fetchOptions", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "settings", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "blockOnRootRunFinalization", { enumerable: true, configurable: true, writable: true, value: P8("LANGSMITH_TRACING_BACKGROUND") === "false" }), Object.defineProperty(this, "traceBatchConcurrency", { enumerable: true, configurable: true, writable: true, value: 5 }), Object.defineProperty(this, "_serverInfo", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "_getServerInfoPromise", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "manualFlushMode", { enumerable: true, configurable: true, writable: true, value: false }), Object.defineProperty(this, "langSmithToOTELTranslator", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "fetchImplementation", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "cachedLSEnvVarsForMetadata", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "multipartStreamingDisabled", { enumerable: true, configurable: true, writable: true, value: false }), Object.defineProperty(this, "debug", { enumerable: true, configurable: true, writable: true, value: P8("LANGSMITH_DEBUG") === "true" });
    let q = _uK.getDefaultClientConfig();
    if (this.tracingSampleRate = kR($.tracingSamplingRate), this.apiUrl = U1($.apiUrl ?? q.apiUrl) ?? "", this.apiUrl.endsWith("/")) this.apiUrl = this.apiUrl.slice(0, -1);
    if (this.apiKey = U1($.apiKey ?? q.apiKey), this.webUrl = U1($.webUrl ?? q.webUrl), this.webUrl?.endsWith("/")) this.webUrl = this.webUrl.slice(0, -1);
    if (this.workspaceId = U1($.workspaceId ?? r6("WORKSPACE_ID")), this.timeout_ms = $.timeout_ms ?? 9e4, this.caller = new g1({ ...$.callerOptions ?? {}, maxRetries: 4, debug: $.debug ?? this.debug }), this.traceBatchConcurrency = $.traceBatchConcurrency ?? this.traceBatchConcurrency, this.traceBatchConcurrency < 1) throw Error("Trace batch concurrency must be positive.");
    this.debug = $.debug ?? this.debug, this.fetchImplementation = $.fetchImplementation;
    let K = $.maxIngestMemoryBytes ?? QZ;
    if (this.batchIngestCaller = new g1({ maxRetries: 4, maxConcurrency: this.traceBatchConcurrency, maxQueueSizeBytes: K, ...$.callerOptions ?? {}, onFailedResponseHook: SR, debug: $.debug ?? this.debug }), this.hideInputs = $.hideInputs ?? $.anonymizer ?? q.hideInputs, this.hideOutputs = $.hideOutputs ?? $.anonymizer ?? q.hideOutputs, this.autoBatchTracing = $.autoBatchTracing ?? this.autoBatchTracing, this.autoBatchQueue = new eZ(K), this.blockOnRootRunFinalization = $.blockOnRootRunFinalization ?? this.blockOnRootRunFinalization, this.batchSizeBytesLimit = $.batchSizeBytesLimit, this.batchSizeLimit = $.batchSizeLimit, this.fetchOptions = $.fetchOptions || {}, this.manualFlushMode = $.manualFlushMode ?? this.manualFlushMode, M1()) this.langSmithToOTELTranslator = new P2();
    this.cachedLSEnvVarsForMetadata = $2();
  }
  static getDefaultClientConfig() {
    let $ = r6("API_KEY"), q = r6("ENDPOINT") ?? FZ, K = r6("HIDE_INPUTS") === "true", P = r6("HIDE_OUTPUTS") === "true";
    return { apiUrl: q, apiKey: $, webUrl: void 0, hideInputs: K, hideOutputs: P };
  }
  getHostUrl() {
    if (this.webUrl) return this.webUrl;
    else if (GR(this.apiUrl)) return this.webUrl = "http://localhost:3000", this.webUrl;
    else if (this.apiUrl.endsWith("/api/v1")) return this.webUrl = this.apiUrl.replace("/api/v1", ""), this.webUrl;
    else if (this.apiUrl.includes("/api") && !this.apiUrl.split(".", 1)[0].endsWith("api")) return this.webUrl = this.apiUrl.replace("/api", ""), this.webUrl;
    else if (this.apiUrl.split(".", 1)[0].includes("dev")) return this.webUrl = "https://dev.smith.langchain.com", this.webUrl;
    else if (this.apiUrl.split(".", 1)[0].includes("eu")) return this.webUrl = "https://eu.smith.langchain.com", this.webUrl;
    else if (this.apiUrl.split(".", 1)[0].includes("beta")) return this.webUrl = "https://beta.smith.langchain.com", this.webUrl;
    else return this.webUrl = "https://smith.langchain.com", this.webUrl;
  }
  get headers() {
    let $ = { "User-Agent": `langsmith-js/${V1}` };
    if (this.apiKey) $["x-api-key"] = `${this.apiKey}`;
    if (this.workspaceId) $["x-tenant-id"] = this.workspaceId;
    return $;
  }
  _getPlatformEndpointPath($) {
    return this.apiUrl.slice(-3) !== "/v1" && this.apiUrl.slice(-4) !== "/v1/" ? `/v1/platform/${$}` : `/platform/${$}`;
  }
  async processInputs($) {
    if (this.hideInputs === false) return $;
    if (this.hideInputs === true) return {};
    if (typeof this.hideInputs === "function") return this.hideInputs($);
    return $;
  }
  async processOutputs($) {
    if (this.hideOutputs === false) return $;
    if (this.hideOutputs === true) return {};
    if (typeof this.hideOutputs === "function") return this.hideOutputs($);
    return $;
  }
  async prepareRunCreateOrUpdateInputs($) {
    let q = { ...$ };
    if (q.inputs !== void 0) q.inputs = await this.processInputs(q.inputs);
    if (q.outputs !== void 0) q.outputs = await this.processOutputs(q.outputs);
    return q;
  }
  async _getResponse($, q) {
    let K = q?.toString() ?? "", P = `${this.apiUrl}${$}?${K}`;
    return await this.caller.call(async () => {
      let Y = await this._fetch(P, { method: "GET", headers: this.headers, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions });
      return await $6(Y, `fetch ${$}`), Y;
    });
  }
  async _get($, q) {
    return (await this._getResponse($, q)).json();
  }
  async *_getPaginated($, q = new URLSearchParams(), K) {
    let P = Number(q.get("offset")) || 0, _ = Number(q.get("limit")) || 100;
    while (true) {
      q.set("offset", String(P)), q.set("limit", String(_));
      let Y = `${this.apiUrl}${$}?${q}`, O = await this.caller.call(async () => {
        let J = await this._fetch(Y, { method: "GET", headers: this.headers, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions });
        return await $6(J, `fetch ${$}`), J;
      }), z = K ? K(await O.json()) : await O.json();
      if (z.length === 0) break;
      if (yield z, z.length < _) break;
      P += z.length;
    }
  }
  async *_getCursorPaginatedList($, q = null, K = "POST", P = "runs") {
    let _ = q ? { ...q } : {};
    while (true) {
      let Y = JSON.stringify(_), z = await (await this.caller.call(async () => {
        let T = await this._fetch(`${this.apiUrl}${$}`, { method: K, headers: { ...this.headers, "Content-Type": "application/json" }, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions, body: Y });
        return await $6(T, `fetch ${$}`), T;
      })).json();
      if (!z) break;
      if (!z[P]) break;
      yield z[P];
      let J = z.cursors;
      if (!J) break;
      if (!J.next) break;
      _.cursor = J.next;
    }
  }
  _shouldSample() {
    if (this.tracingSampleRate === void 0) return true;
    return Math.random() < this.tracingSampleRate;
  }
  _filterForSampling($, q = false) {
    if (this.tracingSampleRate === void 0) return $;
    if (q) {
      let K = [];
      for (let P of $) if (!this.filteredPostUuids.has(P.trace_id)) K.push(P);
      else if (P.id === P.trace_id) this.filteredPostUuids.delete(P.trace_id);
      return K;
    } else {
      let K = [];
      for (let P of $) {
        let _ = P.trace_id ?? P.id;
        if (this.filteredPostUuids.has(_)) continue;
        if (P.id === _) if (this._shouldSample()) K.push(P);
        else this.filteredPostUuids.add(_);
        else K.push(P);
      }
      return K;
    }
  }
  async _getBatchSizeLimitBytes() {
    let $ = await this._ensureServerInfo();
    return this.batchSizeBytesLimit ?? $.batch_ingest_config?.size_limit_bytes ?? MR;
  }
  async _getBatchSizeLimit() {
    let $ = await this._ensureServerInfo();
    return this.batchSizeLimit ?? $.batch_ingest_config?.size_limit ?? CR;
  }
  async _getDatasetExamplesMultiPartSupport() {
    return (await this._ensureServerInfo()).instance_flags?.dataset_examples_multipart_enabled ?? false;
  }
  drainAutoBatchQueue({ batchSizeLimitBytes: $, batchSizeLimit: q }) {
    let K = [];
    while (this.autoBatchQueue.items.length > 0) {
      let [P, _] = this.autoBatchQueue.pop({ upToSizeBytes: $, upToSize: q });
      if (!P.length) {
        _();
        break;
      }
      let Y = P.reduce((J, T) => {
        let X = T.apiUrl ?? this.apiUrl, f = T.apiKey ?? this.apiKey, M = T.apiKey === this.apiKey && T.apiUrl === this.apiUrl ? "default" : `${X}|${f}`;
        if (!J[M]) J[M] = [];
        return J[M].push(T), J;
      }, {}), O = [];
      for (let [J, T] of Object.entries(Y)) {
        let X = this._processBatch(T, { apiUrl: J === "default" ? void 0 : J.split("|")[0], apiKey: J === "default" ? void 0 : J.split("|")[1] });
        O.push(X);
      }
      let z = Promise.all(O).finally(_);
      K.push(z);
    }
    return Promise.all(K);
  }
  async _processBatch($, q) {
    if (!$.length) return;
    let K = $.reduce((P, _) => P + (_.size ?? 0), 0);
    try {
      if (this.langSmithToOTELTranslator !== void 0) this._sendBatchToOTELTranslator($);
      else {
        let P = { runCreates: $.filter((Y) => Y.action === "create").map((Y) => Y.item), runUpdates: $.filter((Y) => Y.action === "update").map((Y) => Y.item) }, _ = await this._ensureServerInfo();
        if (_?.batch_ingest_config?.use_multipart_endpoint) {
          let Y = _?.instance_flags?.gzip_body_enabled;
          await this.multipartIngestRuns(P, { ...q, useGzip: Y, sizeBytes: K });
        } else await this.batchIngestRuns(P, { ...q, sizeBytes: K });
      }
    } catch (P) {
      console.error("Error exporting batch:", P);
    }
  }
  _sendBatchToOTELTranslator($) {
    if (this.langSmithToOTELTranslator !== void 0) {
      let q = /* @__PURE__ */ new Map(), K = [];
      for (let P of $) if (P.item.id && P.otelContext) if (q.set(P.item.id, P.otelContext), P.action === "create") K.push({ operation: "post", id: P.item.id, trace_id: P.item.trace_id ?? P.item.id, run: P.item });
      else K.push({ operation: "patch", id: P.item.id, trace_id: P.item.trace_id ?? P.item.id, run: P.item });
      this.langSmithToOTELTranslator.exportBatch(K, q);
    }
  }
  async processRunOperation($) {
    clearTimeout(this.autoBatchTimeout), this.autoBatchTimeout = void 0, $.item = BZ($.item, this.cachedLSEnvVarsForMetadata);
    let q = this.autoBatchQueue.push($);
    if (this.manualFlushMode) return q;
    let K = await this._getBatchSizeLimitBytes(), P = await this._getBatchSizeLimit();
    if (this.autoBatchQueue.sizeBytes > K || this.autoBatchQueue.items.length > P) this.drainAutoBatchQueue({ batchSizeLimitBytes: K, batchSizeLimit: P });
    if (this.autoBatchQueue.items.length > 0) this.autoBatchTimeout = setTimeout(() => {
      this.autoBatchTimeout = void 0, this.drainAutoBatchQueue({ batchSizeLimitBytes: K, batchSizeLimit: P });
    }, this.autoBatchAggregationDelayMs);
    return q;
  }
  async _getServerInfo() {
    let q = await (await this.caller.call(async () => {
      let K = await this._fetch(`${this.apiUrl}/info`, { method: "GET", headers: { Accept: "application/json" }, signal: AbortSignal.timeout(NR), ...this.fetchOptions });
      return await $6(K, "get server info"), K;
    })).json();
    if (this.debug) console.log(`
=== LangSmith Server Configuration ===
` + JSON.stringify(q, null, 2) + `
`);
    return q;
  }
  async _ensureServerInfo() {
    if (this._getServerInfoPromise === void 0) this._getServerInfoPromise = (async () => {
      if (this._serverInfo === void 0) try {
        this._serverInfo = await this._getServerInfo();
      } catch ($) {
        console.warn(`[LANGSMITH]: Failed to fetch info on supported operations. Falling back to batch operations and default limits. Info: ${$.status ?? "Unspecified status code"} ${$.message}`);
      }
      return this._serverInfo ?? {};
    })();
    return this._getServerInfoPromise.then(($) => {
      if (this._serverInfo === void 0) this._getServerInfoPromise = void 0;
      return $;
    });
  }
  async _getSettings() {
    if (!this.settings) this.settings = this._get("/settings");
    return await this.settings;
  }
  async flush() {
    let $ = await this._getBatchSizeLimitBytes(), q = await this._getBatchSizeLimit();
    await this.drainAutoBatchQueue({ batchSizeLimitBytes: $, batchSizeLimit: q });
  }
  _cloneCurrentOTELContext() {
    let $ = N1(), q = Iw();
    if (this.langSmithToOTELTranslator !== void 0) {
      let K = $.getActiveSpan();
      if (K) return $.setSpan(q.active(), K);
    }
    return;
  }
  async createRun($, q) {
    if (!this._filterForSampling([$]).length) return;
    let K = { ...this.headers, "Content-Type": "application/json" }, P = $.project_name;
    delete $.project_name;
    let _ = await this.prepareRunCreateOrUpdateInputs({ session_name: P, ...$, start_time: $.start_time ?? Date.now() });
    if (this.autoBatchTracing && _.trace_id !== void 0 && _.dotted_order !== void 0) {
      let z = this._cloneCurrentOTELContext();
      this.processRunOperation({ action: "create", item: _, otelContext: z, apiKey: q?.apiKey, apiUrl: q?.apiUrl }).catch(console.error);
      return;
    }
    let Y = BZ(_, this.cachedLSEnvVarsForMetadata);
    if (q?.apiKey !== void 0) K["x-api-key"] = q.apiKey;
    if (q?.workspaceId !== void 0) K["x-tenant-id"] = q.workspaceId;
    let O = tq(Y, `Creating run with id: ${Y.id}`);
    await this.caller.call(async () => {
      let z = await this._fetch(`${q?.apiUrl ?? this.apiUrl}/runs`, { method: "POST", headers: K, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions, body: O });
      return await $6(z, "create run", true), z;
    });
  }
  async batchIngestRuns({ runCreates: $, runUpdates: q }, K) {
    if ($ === void 0 && q === void 0) return;
    let P = await Promise.all($?.map((z) => this.prepareRunCreateOrUpdateInputs(z)) ?? []), _ = await Promise.all(q?.map((z) => this.prepareRunCreateOrUpdateInputs(z)) ?? []);
    if (P.length > 0 && _.length > 0) {
      let z = P.reduce((T, X) => {
        if (!X.id) return T;
        return T[X.id] = X, T;
      }, {}), J = [];
      for (let T of _) if (T.id !== void 0 && z[T.id]) z[T.id] = { ...z[T.id], ...T };
      else J.push(T);
      P = Object.values(z), _ = J;
    }
    let Y = { post: P, patch: _ };
    if (!Y.post.length && !Y.patch.length) return;
    let O = { post: [], patch: [] };
    for (let z of ["post", "patch"]) {
      let J = z, T = Y[J].reverse(), X = T.pop();
      while (X !== void 0) O[J].push(X), X = T.pop();
    }
    if (O.post.length > 0 || O.patch.length > 0) {
      let z = O.post.map((J) => J.id).concat(O.patch.map((J) => J.id)).join(",");
      await this._postBatchIngestRuns(tq(O, `Ingesting runs with ids: ${z}`), K);
    }
  }
  async _postBatchIngestRuns($, q) {
    let K = { ...this.headers, "Content-Type": "application/json", Accept: "application/json" };
    if (q?.apiKey !== void 0) K["x-api-key"] = q.apiKey;
    await this.batchIngestCaller.callWithOptions({ sizeBytes: q?.sizeBytes }, async () => {
      let P = await this._fetch(`${q?.apiUrl ?? this.apiUrl}/runs/batch`, { method: "POST", headers: K, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions, body: $ });
      return await $6(P, "batch create run", true), P;
    });
  }
  async multipartIngestRuns({ runCreates: $, runUpdates: q }, K) {
    if ($ === void 0 && q === void 0) return;
    let P = {}, _ = [];
    for (let X of $ ?? []) {
      let f = await this.prepareRunCreateOrUpdateInputs(X);
      if (f.id !== void 0 && f.attachments !== void 0) P[f.id] = f.attachments;
      delete f.attachments, _.push(f);
    }
    let Y = [];
    for (let X of q ?? []) Y.push(await this.prepareRunCreateOrUpdateInputs(X));
    if (_.find((X) => {
      return X.trace_id === void 0 || X.dotted_order === void 0;
    }) !== void 0) throw Error('Multipart ingest requires "trace_id" and "dotted_order" to be set when creating a run');
    if (Y.find((X) => {
      return X.trace_id === void 0 || X.dotted_order === void 0;
    }) !== void 0) throw Error('Multipart ingest requires "trace_id" and "dotted_order" to be set when updating a run');
    if (_.length > 0 && Y.length > 0) {
      let X = _.reduce((V, M) => {
        if (!M.id) return V;
        return V[M.id] = M, V;
      }, {}), f = [];
      for (let V of Y) if (V.id !== void 0 && X[V.id]) X[V.id] = { ...X[V.id], ...V };
      else f.push(V);
      _ = Object.values(X), Y = f;
    }
    if (_.length === 0 && Y.length === 0) return;
    let J = [], T = [];
    for (let [X, f] of [["post", _], ["patch", Y]]) for (let V of f) {
      let { inputs: M, outputs: N, events: E, extra: h, error: I, serialized: D, attachments: g, ...b } = V, y = { inputs: M, outputs: N, events: E, extra: h, error: I, serialized: D }, p = tq(b, `Serializing for multipart ingestion of run with id: ${b.id}`);
      T.push({ name: `${X}.${b.id}`, payload: new Blob([p], { type: `application/json; length=${p.length}` }) });
      for (let [n, s] of Object.entries(y)) {
        if (s === void 0) continue;
        let q$ = tq(s, `Serializing ${n} for multipart ingestion of run with id: ${b.id}`);
        T.push({ name: `${X}.${b.id}.${n}`, payload: new Blob([q$], { type: `application/json; length=${q$.length}` }) });
      }
      if (b.id !== void 0) {
        let n = P[b.id];
        if (n) {
          delete P[b.id];
          for (let [s, q$] of Object.entries(n)) {
            let c, U;
            if (Array.isArray(q$)) [c, U] = q$;
            else c = q$.mimeType, U = q$.data;
            if (s.includes(".")) {
              console.warn(`Skipping attachment '${s}' for run ${b.id}: Invalid attachment name. Attachment names must not contain periods ('.'). Please rename the attachment and try again.`);
              continue;
            }
            T.push({ name: `attachment.${b.id}.${s}`, payload: new Blob([U], { type: `${c}; length=${U.byteLength}` }) });
          }
        }
      }
      J.push(`trace=${b.trace_id},id=${b.id}`);
    }
    await this._sendMultipartRequest(T, J.join("; "), K);
  }
  async _createNodeFetchBody($, q) {
    let K = [];
    for (let Y of $) K.push(new Blob([`--${q}\r
`])), K.push(new Blob([`Content-Disposition: form-data; name="${Y.name}"\r
`, `Content-Type: ${Y.payload.type}\r
\r
`])), K.push(Y.payload), K.push(new Blob([`\r
`]));
    return K.push(new Blob([`--${q}--\r
`])), await new Blob(K).arrayBuffer();
  }
  async _createMultipartStream($, q) {
    let K = new TextEncoder();
    return new ReadableStream({ async start(_) {
      let Y = /* @__PURE__ */ __name(async (O) => {
        if (typeof O === "string") _.enqueue(K.encode(O));
        else _.enqueue(O);
      }, "Y");
      for (let O of $) {
        await Y(`--${q}\r
`), await Y(`Content-Disposition: form-data; name="${O.name}"\r
`), await Y(`Content-Type: ${O.payload.type}\r
\r
`);
        let J = O.payload.stream().getReader();
        try {
          let T;
          while (!(T = await J.read()).done) _.enqueue(T.value);
        } finally {
          J.releaseLock();
        }
        await Y(`\r
`);
      }
      await Y(`--${q}--\r
`), _.close();
    } });
  }
  async _sendMultipartRequest($, q, K) {
    let P = "----LangSmithFormBoundary" + Math.random().toString(36).slice(2), _ = Aw(), Y = /* @__PURE__ */ __name(() => this._createNodeFetchBody($, P), "Y"), O = /* @__PURE__ */ __name(() => this._createMultipartStream($, P), "O"), z = /* @__PURE__ */ __name(async (J) => {
      return this.batchIngestCaller.callWithOptions({ sizeBytes: K?.sizeBytes }, async () => {
        let T = await J(), X = { ...this.headers, "Content-Type": `multipart/form-data; boundary=${P}` };
        if (K?.apiKey !== void 0) X["x-api-key"] = K.apiKey;
        let f = T;
        if (K?.useGzip && typeof T === "object" && "pipeThrough" in T) f = T.pipeThrough(new CompressionStream("gzip")), X["Content-Encoding"] = "gzip";
        let V = await this._fetch(`${K?.apiUrl ?? this.apiUrl}/runs/multipart`, { method: "POST", headers: X, body: f, duplex: "half", signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions });
        return await $6(V, "Failed to send multipart request", true), V;
      });
    }, "z");
    try {
      let J, T = false;
      if (!_ && !this.multipartStreamingDisabled && sO() !== "bun") T = true, J = await z(O);
      else J = await z(Y);
      if ((!this.multipartStreamingDisabled || T) && J.status === 422 && (K?.apiUrl ?? this.apiUrl) !== FZ) console.warn(`Streaming multipart upload to ${K?.apiUrl ?? this.apiUrl}/runs/multipart failed. This usually means the host does not support chunked uploads. Retrying with a buffered upload for operation "${q}".`), this.multipartStreamingDisabled = true, J = await z(Y);
    } catch (J) {
      console.warn(`${J.message.trim()}

Context: ${q}`);
    }
  }
  async updateRun($, q, K) {
    if (O6($), q.inputs) q.inputs = await this.processInputs(q.inputs);
    if (q.outputs) q.outputs = await this.processOutputs(q.outputs);
    let P = { ...q, id: $ };
    if (!this._filterForSampling([P], true).length) return;
    if (this.autoBatchTracing && P.trace_id !== void 0 && P.dotted_order !== void 0) {
      let O = this._cloneCurrentOTELContext();
      if (q.end_time !== void 0 && P.parent_run_id === void 0 && this.blockOnRootRunFinalization && !this.manualFlushMode) {
        await this.processRunOperation({ action: "update", item: P, otelContext: O, apiKey: K?.apiKey, apiUrl: K?.apiUrl }).catch(console.error);
        return;
      } else this.processRunOperation({ action: "update", item: P, otelContext: O, apiKey: K?.apiKey, apiUrl: K?.apiUrl }).catch(console.error);
      return;
    }
    let _ = { ...this.headers, "Content-Type": "application/json" };
    if (K?.apiKey !== void 0) _["x-api-key"] = K.apiKey;
    if (K?.workspaceId !== void 0) _["x-tenant-id"] = K.workspaceId;
    let Y = tq(q, `Serializing payload to update run with id: ${$}`);
    await this.caller.call(async () => {
      let O = await this._fetch(`${K?.apiUrl ?? this.apiUrl}/runs/${$}`, { method: "PATCH", headers: _, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions, body: Y });
      return await $6(O, "update run", true), O;
    });
  }
  async readRun($, { loadChildRuns: q } = { loadChildRuns: false }) {
    O6($);
    let K = await this._get(`/runs/${$}`);
    if (q) K = await this._loadChildRuns(K);
    return K;
  }
  async getRunUrl({ runId: $, run: q, projectOpts: K }) {
    if (q !== void 0) {
      let P;
      if (q.session_id) P = q.session_id;
      else if (K?.projectName) P = (await this.readProject({ projectName: K?.projectName })).id;
      else if (K?.projectId) P = K?.projectId;
      else P = (await this.readProject({ projectName: r6("PROJECT") || "default" })).id;
      let _ = await this._getTenantId();
      return `${this.getHostUrl()}/o/${_}/projects/p/${P}/r/${q.id}?poll=true`;
    } else if ($ !== void 0) {
      let P = await this.readRun($);
      if (!P.app_path) throw Error(`Run ${$} has no app_path`);
      return `${this.getHostUrl()}${P.app_path}`;
    } else throw Error("Must provide either runId or run");
  }
  async _loadChildRuns($) {
    let q = await VR(this.listRuns({ isRoot: false, projectId: $.session_id, traceId: $.trace_id })), K = {}, P = {};
    q.sort((_, Y) => (_?.dotted_order ?? "").localeCompare(Y?.dotted_order ?? ""));
    for (let _ of q) {
      if (_.parent_run_id === null || _.parent_run_id === void 0) throw Error(`Child run ${_.id} has no parent`);
      if (_.dotted_order?.startsWith($.dotted_order ?? "") && _.id !== $.id) {
        if (!(_.parent_run_id in K)) K[_.parent_run_id] = [];
        K[_.parent_run_id].push(_), P[_.id] = _;
      }
    }
    $.child_runs = K[$.id] || [];
    for (let _ in K) if (_ !== $.id) P[_].child_runs = K[_];
    return $;
  }
  async *listRuns($) {
    let { projectId: q, projectName: K, parentRunId: P, traceId: _, referenceExampleId: Y, startTime: O, executionOrder: z, isRoot: J, runType: T, error: X, id: f, query: V, filter: M, traceFilter: N, treeFilter: E, limit: h, select: I, order: D } = $, g = [];
    if (q) g = Array.isArray(q) ? q : [q];
    if (K) {
      let n = Array.isArray(K) ? K : [K], s = await Promise.all(n.map((q$) => this.readProject({ projectName: q$ }).then((c) => c.id)));
      g.push(...s);
    }
    let b = ["app_path", "completion_cost", "completion_tokens", "dotted_order", "end_time", "error", "events", "extra", "feedback_stats", "first_token_time", "id", "inputs", "name", "outputs", "parent_run_id", "parent_run_ids", "prompt_cost", "prompt_tokens", "reference_example_id", "run_type", "session_id", "start_time", "status", "tags", "total_cost", "total_tokens", "trace_id"], y = { session: g.length ? g : null, run_type: T, reference_example: Y, query: V, filter: M, trace_filter: N, tree_filter: E, execution_order: z, parent_run: P, start_time: O ? O.toISOString() : null, error: X, id: f, limit: h, trace: _, select: I ? I : b, is_root: J, order: D };
    if (y.select.includes("child_run_ids")) v_("Deprecated: 'child_run_ids' in the listRuns select parameter is deprecated and will be removed in a future version.");
    let p = 0;
    for await (let n of this._getCursorPaginatedList("/runs/query", y)) if (h) {
      if (p >= h) break;
      if (n.length + p > h) {
        yield* n.slice(0, h - p);
        break;
      }
      p += n.length, yield* n;
    } else yield* n;
  }
  async *listGroupRuns($) {
    let { projectId: q, projectName: K, groupBy: P, filter: _, startTime: Y, endTime: O, limit: z, offset: J } = $, X = { session_id: q || (await this.readProject({ projectName: K })).id, group_by: P, filter: _, start_time: Y ? Y.toISOString() : null, end_time: O ? O.toISOString() : null, limit: Number(z) || 100 }, f = Number(J) || 0, V = "/runs/group", M = `${this.apiUrl}${V}`;
    while (true) {
      let N = { ...X, offset: f }, E = Object.fromEntries(Object.entries(N).filter(([y, p]) => p !== void 0)), h = JSON.stringify(E), D = await (await this.caller.call(async () => {
        let y = await this._fetch(M, { method: "POST", headers: { ...this.headers, "Content-Type": "application/json" }, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions, body: h });
        return await $6(y, `Failed to fetch ${V}`), y;
      })).json(), { groups: g, total: b } = D;
      if (g.length === 0) break;
      for (let y of g) yield y;
      if (f += g.length, f >= b) break;
    }
  }
  async getRunStats({ id: $, trace: q, parentRun: K, runType: P, projectNames: _, projectIds: Y, referenceExampleIds: O, startTime: z, endTime: J, error: T, query: X, filter: f, traceFilter: V, treeFilter: M, isRoot: N, dataSourceType: E }) {
    let h = Y || [];
    if (_) h = [...Y || [], ...await Promise.all(_.map((p) => this.readProject({ projectName: p }).then((n) => n.id)))];
    let D = Object.fromEntries(Object.entries({ id: $, trace: q, parent_run: K, run_type: P, session: h, reference_example: O, start_time: z, end_time: J, error: T, query: X, filter: f, trace_filter: V, tree_filter: M, is_root: N, data_source_type: E }).filter(([p, n]) => n !== void 0)), g = JSON.stringify(D);
    return await (await this.caller.call(async () => {
      let p = await this._fetch(`${this.apiUrl}/runs/stats`, { method: "POST", headers: { ...this.headers, "Content-Type": "application/json" }, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions, body: g });
      return await $6(p, "get run stats"), p;
    })).json();
  }
  async shareRun($, { shareId: q } = {}) {
    let K = { run_id: $, share_token: q || j_() };
    O6($);
    let P = JSON.stringify(K), Y = await (await this.caller.call(async () => {
      let O = await this._fetch(`${this.apiUrl}/runs/${$}/share`, { method: "PUT", headers: this.headers, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions, body: P });
      return await $6(O, "share run"), O;
    })).json();
    if (Y === null || !("share_token" in Y)) throw Error("Invalid response from server");
    return `${this.getHostUrl()}/public/${Y.share_token}/r`;
  }
  async unshareRun($) {
    O6($), await this.caller.call(async () => {
      let q = await this._fetch(`${this.apiUrl}/runs/${$}/share`, { method: "DELETE", headers: this.headers, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions });
      return await $6(q, "unshare run", true), q;
    });
  }
  async readRunSharedLink($) {
    O6($);
    let K = await (await this.caller.call(async () => {
      let P = await this._fetch(`${this.apiUrl}/runs/${$}/share`, { method: "GET", headers: this.headers, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions });
      return await $6(P, "read run shared link"), P;
    })).json();
    if (K === null || !("share_token" in K)) return;
    return `${this.getHostUrl()}/public/${K.share_token}/r`;
  }
  async listSharedRuns($, { runIds: q } = {}) {
    let K = new URLSearchParams({ share_token: $ });
    if (q !== void 0) for (let Y of q) K.append("id", Y);
    return O6($), await (await this.caller.call(async () => {
      let Y = await this._fetch(`${this.apiUrl}/public/${$}/runs${K}`, { method: "GET", headers: this.headers, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions });
      return await $6(Y, "list shared runs"), Y;
    })).json();
  }
  async readDatasetSharedSchema($, q) {
    if (!$ && !q) throw Error("Either datasetId or datasetName must be given");
    if (!$) $ = (await this.readDataset({ datasetName: q })).id;
    O6($);
    let P = await (await this.caller.call(async () => {
      let _ = await this._fetch(`${this.apiUrl}/datasets/${$}/share`, { method: "GET", headers: this.headers, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions });
      return await $6(_, "read dataset shared schema"), _;
    })).json();
    return P.url = `${this.getHostUrl()}/public/${P.share_token}/d`, P;
  }
  async shareDataset($, q) {
    if (!$ && !q) throw Error("Either datasetId or datasetName must be given");
    if (!$) $ = (await this.readDataset({ datasetName: q })).id;
    let K = { dataset_id: $ };
    O6($);
    let P = JSON.stringify(K), Y = await (await this.caller.call(async () => {
      let O = await this._fetch(`${this.apiUrl}/datasets/${$}/share`, { method: "PUT", headers: this.headers, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions, body: P });
      return await $6(O, "share dataset"), O;
    })).json();
    return Y.url = `${this.getHostUrl()}/public/${Y.share_token}/d`, Y;
  }
  async unshareDataset($) {
    O6($), await this.caller.call(async () => {
      let q = await this._fetch(`${this.apiUrl}/datasets/${$}/share`, { method: "DELETE", headers: this.headers, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions });
      return await $6(q, "unshare dataset", true), q;
    });
  }
  async readSharedDataset($) {
    return O6($), await (await this.caller.call(async () => {
      let P = await this._fetch(`${this.apiUrl}/public/${$}/datasets`, { method: "GET", headers: this.headers, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions });
      return await $6(P, "read shared dataset"), P;
    })).json();
  }
  async listSharedExamples($, q) {
    let K = {};
    if (q?.exampleIds) K.id = q.exampleIds;
    let P = new URLSearchParams();
    Object.entries(K).forEach(([O, z]) => {
      if (Array.isArray(z)) z.forEach((J) => P.append(O, J));
      else P.append(O, z);
    });
    let _ = await this.caller.call(async () => {
      let O = await this._fetch(`${this.apiUrl}/public/${$}/examples?${P.toString()}`, { method: "GET", headers: this.headers, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions });
      return await $6(O, "list shared examples"), O;
    }), Y = await _.json();
    if (!_.ok) {
      if ("detail" in Y) throw Error(`Failed to list shared examples.
Status: ${_.status}
Message: ${Array.isArray(Y.detail) ? Y.detail.join(`
`) : "Unspecified error"}`);
      throw Error(`Failed to list shared examples: ${_.status} ${_.statusText}`);
    }
    return Y.map((O) => ({ ...O, _hostUrl: this.getHostUrl() }));
  }
  async createProject({ projectName: $, description: q = null, metadata: K = null, upsert: P = false, projectExtra: _ = null, referenceDatasetId: Y = null }) {
    let O = P ? "?upsert=true" : "", z = `${this.apiUrl}/sessions${O}`, J = _ || {};
    if (K) J.metadata = K;
    let T = { name: $, extra: J, description: q };
    if (Y !== null) T.reference_dataset_id = Y;
    let X = JSON.stringify(T);
    return await (await this.caller.call(async () => {
      let M = await this._fetch(z, { method: "POST", headers: { ...this.headers, "Content-Type": "application/json" }, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions, body: X });
      return await $6(M, "create project"), M;
    })).json();
  }
  async updateProject($, { name: q = null, description: K = null, metadata: P = null, projectExtra: _ = null, endTime: Y = null }) {
    let O = `${this.apiUrl}/sessions/${$}`, z = _;
    if (P) z = { ...z || {}, metadata: P };
    let J = JSON.stringify({ name: q, extra: z, description: K, end_time: Y ? new Date(Y).toISOString() : null });
    return await (await this.caller.call(async () => {
      let f = await this._fetch(O, { method: "PATCH", headers: { ...this.headers, "Content-Type": "application/json" }, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions, body: J });
      return await $6(f, "update project"), f;
    })).json();
  }
  async hasProject({ projectId: $, projectName: q }) {
    let K = "/sessions", P = new URLSearchParams();
    if ($ !== void 0 && q !== void 0) throw Error("Must provide either projectName or projectId, not both");
    else if ($ !== void 0) O6($), K += `/${$}`;
    else if (q !== void 0) P.append("name", q);
    else throw Error("Must provide projectName or projectId");
    let _ = await this.caller.call(async () => {
      let Y = await this._fetch(`${this.apiUrl}${K}?${P}`, { method: "GET", headers: this.headers, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions });
      return await $6(Y, "has project"), Y;
    });
    try {
      let Y = await _.json();
      if (!_.ok) return false;
      if (Array.isArray(Y)) return Y.length > 0;
      return true;
    } catch (Y) {
      return false;
    }
  }
  async readProject({ projectId: $, projectName: q, includeStats: K }) {
    let P = "/sessions", _ = new URLSearchParams();
    if ($ !== void 0 && q !== void 0) throw Error("Must provide either projectName or projectId, not both");
    else if ($ !== void 0) O6($), P += `/${$}`;
    else if (q !== void 0) _.append("name", q);
    else throw Error("Must provide projectName or projectId");
    if (K !== void 0) _.append("include_stats", K.toString());
    let Y = await this._get(P, _), O;
    if (Array.isArray(Y)) {
      if (Y.length === 0) throw Error(`Project[id=${$}, name=${q}] not found`);
      O = Y[0];
    } else O = Y;
    return O;
  }
  async getProjectUrl({ projectId: $, projectName: q }) {
    if ($ === void 0 && q === void 0) throw Error("Must provide either projectName or projectId");
    let K = await this.readProject({ projectId: $, projectName: q }), P = await this._getTenantId();
    return `${this.getHostUrl()}/o/${P}/projects/p/${K.id}`;
  }
  async getDatasetUrl({ datasetId: $, datasetName: q }) {
    if ($ === void 0 && q === void 0) throw Error("Must provide either datasetName or datasetId");
    let K = await this.readDataset({ datasetId: $, datasetName: q }), P = await this._getTenantId();
    return `${this.getHostUrl()}/o/${P}/datasets/${K.id}`;
  }
  async _getTenantId() {
    if (this._tenantId !== null) return this._tenantId;
    let $ = new URLSearchParams({ limit: "1" });
    for await (let q of this._getPaginated("/sessions", $)) return this._tenantId = q[0].tenant_id, q[0].tenant_id;
    throw Error("No projects found to resolve tenant.");
  }
  async *listProjects({ projectIds: $, name: q, nameContains: K, referenceDatasetId: P, referenceDatasetName: _, includeStats: Y, datasetVersion: O, referenceFree: z, metadata: J } = {}) {
    let T = new URLSearchParams();
    if ($ !== void 0) for (let X of $) T.append("id", X);
    if (q !== void 0) T.append("name", q);
    if (K !== void 0) T.append("name_contains", K);
    if (P !== void 0) T.append("reference_dataset", P);
    else if (_ !== void 0) {
      let X = await this.readDataset({ datasetName: _ });
      T.append("reference_dataset", X.id);
    }
    if (Y !== void 0) T.append("include_stats", Y.toString());
    if (O !== void 0) T.append("dataset_version", O);
    if (z !== void 0) T.append("reference_free", z.toString());
    if (J !== void 0) T.append("metadata", JSON.stringify(J));
    for await (let X of this._getPaginated("/sessions", T)) yield* X;
  }
  async deleteProject({ projectId: $, projectName: q }) {
    let K;
    if ($ === void 0 && q === void 0) throw Error("Must provide projectName or projectId");
    else if ($ !== void 0 && q !== void 0) throw Error("Must provide either projectName or projectId, not both");
    else if ($ === void 0) K = (await this.readProject({ projectName: q })).id;
    else K = $;
    O6(K), await this.caller.call(async () => {
      let P = await this._fetch(`${this.apiUrl}/sessions/${K}`, { method: "DELETE", headers: this.headers, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions });
      return await $6(P, `delete session ${K} (${q})`, true), P;
    });
  }
  async uploadCsv({ csvFile: $, fileName: q, inputKeys: K, outputKeys: P, description: _, dataType: Y, name: O }) {
    let z = `${this.apiUrl}/datasets/upload`, J = new FormData();
    if (J.append("file", $, q), K.forEach((f) => {
      J.append("input_keys", f);
    }), P.forEach((f) => {
      J.append("output_keys", f);
    }), _) J.append("description", _);
    if (Y) J.append("data_type", Y);
    if (O) J.append("name", O);
    return await (await this.caller.call(async () => {
      let f = await this._fetch(z, { method: "POST", headers: this.headers, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions, body: J });
      return await $6(f, "upload CSV"), f;
    })).json();
  }
  async createDataset($, { description: q, dataType: K, inputsSchema: P, outputsSchema: _, metadata: Y } = {}) {
    let O = { name: $, description: q, extra: Y ? { metadata: Y } : void 0 };
    if (K) O.data_type = K;
    if (P) O.inputs_schema_definition = P;
    if (_) O.outputs_schema_definition = _;
    let z = JSON.stringify(O);
    return await (await this.caller.call(async () => {
      let X = await this._fetch(`${this.apiUrl}/datasets`, { method: "POST", headers: { ...this.headers, "Content-Type": "application/json" }, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions, body: z });
      return await $6(X, "create dataset"), X;
    })).json();
  }
  async readDataset({ datasetId: $, datasetName: q }) {
    let K = "/datasets", P = new URLSearchParams({ limit: "1" });
    if ($ && q) throw Error("Must provide either datasetName or datasetId, not both");
    else if ($) O6($), K += `/${$}`;
    else if (q) P.append("name", q);
    else throw Error("Must provide datasetName or datasetId");
    let _ = await this._get(K, P), Y;
    if (Array.isArray(_)) {
      if (_.length === 0) throw Error(`Dataset[id=${$}, name=${q}] not found`);
      Y = _[0];
    } else Y = _;
    return Y;
  }
  async hasDataset({ datasetId: $, datasetName: q }) {
    try {
      return await this.readDataset({ datasetId: $, datasetName: q }), true;
    } catch (K) {
      if (K instanceof Error && K.message.toLocaleLowerCase().includes("not found")) return false;
      throw K;
    }
  }
  async diffDatasetVersions({ datasetId: $, datasetName: q, fromVersion: K, toVersion: P }) {
    let _ = $;
    if (_ === void 0 && q === void 0) throw Error("Must provide either datasetName or datasetId");
    else if (_ !== void 0 && q !== void 0) throw Error("Must provide either datasetName or datasetId, not both");
    else if (_ === void 0) _ = (await this.readDataset({ datasetName: q })).id;
    let Y = new URLSearchParams({ from_version: typeof K === "string" ? K : K.toISOString(), to_version: typeof P === "string" ? P : P.toISOString() });
    return await this._get(`/datasets/${_}/versions/diff`, Y);
  }
  async readDatasetOpenaiFinetuning({ datasetId: $, datasetName: q }) {
    if ($ !== void 0) ;
    else if (q !== void 0) $ = (await this.readDataset({ datasetName: q })).id;
    else throw Error("Must provide either datasetName or datasetId");
    return (await (await this._getResponse(`/datasets/${$}/openai_ft`)).text()).trim().split(`
`).map((O) => JSON.parse(O));
  }
  async *listDatasets({ limit: $ = 100, offset: q = 0, datasetIds: K, datasetName: P, datasetNameContains: _, metadata: Y } = {}) {
    let z = new URLSearchParams({ limit: $.toString(), offset: q.toString() });
    if (K !== void 0) for (let J of K) z.append("id", J);
    if (P !== void 0) z.append("name", P);
    if (_ !== void 0) z.append("name_contains", _);
    if (Y !== void 0) z.append("metadata", JSON.stringify(Y));
    for await (let J of this._getPaginated("/datasets", z)) yield* J;
  }
  async updateDataset($) {
    let { datasetId: q, datasetName: K, ...P } = $;
    if (!q && !K) throw Error("Must provide either datasetName or datasetId");
    let _ = q ?? (await this.readDataset({ datasetName: K })).id;
    O6(_);
    let Y = JSON.stringify(P);
    return await (await this.caller.call(async () => {
      let z = await this._fetch(`${this.apiUrl}/datasets/${_}`, { method: "PATCH", headers: { ...this.headers, "Content-Type": "application/json" }, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions, body: Y });
      return await $6(z, "update dataset"), z;
    })).json();
  }
  async updateDatasetTag($) {
    let { datasetId: q, datasetName: K, asOf: P, tag: _ } = $;
    if (!q && !K) throw Error("Must provide either datasetName or datasetId");
    let Y = q ?? (await this.readDataset({ datasetName: K })).id;
    O6(Y);
    let O = JSON.stringify({ as_of: typeof P === "string" ? P : P.toISOString(), tag: _ });
    await this.caller.call(async () => {
      let z = await this._fetch(`${this.apiUrl}/datasets/${Y}/tags`, { method: "PUT", headers: { ...this.headers, "Content-Type": "application/json" }, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions, body: O });
      return await $6(z, "update dataset tags", true), z;
    });
  }
  async deleteDataset({ datasetId: $, datasetName: q }) {
    let K = "/datasets", P = $;
    if ($ !== void 0 && q !== void 0) throw Error("Must provide either datasetName or datasetId, not both");
    else if (q !== void 0) P = (await this.readDataset({ datasetName: q })).id;
    if (P !== void 0) O6(P), K += `/${P}`;
    else throw Error("Must provide datasetName or datasetId");
    await this.caller.call(async () => {
      let _ = await this._fetch(this.apiUrl + K, { method: "DELETE", headers: this.headers, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions });
      return await $6(_, `delete ${K}`, true), _;
    });
  }
  async indexDataset({ datasetId: $, datasetName: q, tag: K }) {
    let P = $;
    if (!P && !q) throw Error("Must provide either datasetName or datasetId");
    else if (P && q) throw Error("Must provide either datasetName or datasetId, not both");
    else if (!P) P = (await this.readDataset({ datasetName: q })).id;
    O6(P);
    let Y = JSON.stringify({ tag: K });
    await (await this.caller.call(async () => {
      let z = await this._fetch(`${this.apiUrl}/datasets/${P}/index`, { method: "POST", headers: { ...this.headers, "Content-Type": "application/json" }, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions, body: Y });
      return await $6(z, "index dataset"), z;
    })).json();
  }
  async similarExamples($, q, K, { filter: P } = {}) {
    let _ = { limit: K, inputs: $ };
    if (P !== void 0) _.filter = P;
    O6(q);
    let Y = JSON.stringify(_);
    return (await (await this.caller.call(async () => {
      let J = await this._fetch(`${this.apiUrl}/datasets/${q}/search`, { headers: { ...this.headers, "Content-Type": "application/json" }, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions, method: "POST", body: Y });
      return await $6(J, "fetch similar examples"), J;
    })).json()).examples;
  }
  async createExample($, q, K) {
    if (aZ($)) {
      if (q !== void 0 || K !== void 0) throw Error("Cannot provide outputs or options when using ExampleCreate object");
    }
    let P = q ? K?.datasetId : $.dataset_id, _ = q ? K?.datasetName : $.dataset_name;
    if (P === void 0 && _ === void 0) throw Error("Must provide either datasetName or datasetId");
    else if (P !== void 0 && _ !== void 0) throw Error("Must provide either datasetName or datasetId, not both");
    else if (P === void 0) P = (await this.readDataset({ datasetName: _ })).id;
    let Y = (q ? K?.createdAt : $.created_at) || /* @__PURE__ */ new Date(), O;
    if (!aZ($)) O = { inputs: $, outputs: q, created_at: Y?.toISOString(), id: K?.exampleId, metadata: K?.metadata, split: K?.split, source_run_id: K?.sourceRunId, use_source_run_io: K?.useSourceRunIO, use_source_run_attachments: K?.useSourceRunAttachments, attachments: K?.attachments };
    else O = $;
    let z = await this._uploadExamplesMultipart(P, [O]);
    return await this.readExample(z.example_ids?.[0] ?? j_());
  }
  async createExamples($) {
    if (Array.isArray($)) {
      if ($.length === 0) return [];
      let I = $, D = I[0].dataset_id, g = I[0].dataset_name;
      if (D === void 0 && g === void 0) throw Error("Must provide either datasetName or datasetId");
      else if (D !== void 0 && g !== void 0) throw Error("Must provide either datasetName or datasetId, not both");
      else if (D === void 0) D = (await this.readDataset({ datasetName: g })).id;
      let b = await this._uploadExamplesMultipart(D, I);
      return await Promise.all(b.example_ids.map((p) => this.readExample(p)));
    }
    let { inputs: q, outputs: K, metadata: P, splits: _, sourceRunIds: Y, useSourceRunIOs: O, useSourceRunAttachments: z, attachments: J, exampleIds: T, datasetId: X, datasetName: f } = $;
    if (q === void 0) throw Error("Must provide inputs when using legacy parameters");
    let V = X, M = f;
    if (V === void 0 && M === void 0) throw Error("Must provide either datasetName or datasetId");
    else if (V !== void 0 && M !== void 0) throw Error("Must provide either datasetName or datasetId, not both");
    else if (V === void 0) V = (await this.readDataset({ datasetName: M })).id;
    let N = q.map((I, D) => {
      return { dataset_id: V, inputs: I, outputs: K?.[D], metadata: P?.[D], split: _?.[D], id: T?.[D], attachments: J?.[D], source_run_id: Y?.[D], use_source_run_io: O?.[D], use_source_run_attachments: z?.[D] };
    }), E = await this._uploadExamplesMultipart(V, N);
    return await Promise.all(E.example_ids.map((I) => this.readExample(I)));
  }
  async createLLMExample($, q, K) {
    return this.createExample({ input: $ }, { output: q }, K);
  }
  async createChatExample($, q, K) {
    let P = $.map((Y) => {
      if (v2(Y)) return z2(Y);
      return Y;
    }), _ = v2(q) ? z2(q) : q;
    return this.createExample({ input: P }, { output: _ }, K);
  }
  async readExample($) {
    O6($);
    let q = `/examples/${$}`, K = await this._get(q), { attachment_urls: P, ..._ } = K, Y = _;
    if (P) Y.attachments = Object.entries(P).reduce((O, [z, J]) => {
      return O[z.slice(11)] = { presigned_url: J.presigned_url, mime_type: J.mime_type }, O;
    }, {});
    return Y;
  }
  async *listExamples({ datasetId: $, datasetName: q, exampleIds: K, asOf: P, splits: _, inlineS3Urls: Y, metadata: O, limit: z, offset: J, filter: T, includeAttachments: X } = {}) {
    let f;
    if ($ !== void 0 && q !== void 0) throw Error("Must provide either datasetName or datasetId, not both");
    else if ($ !== void 0) f = $;
    else if (q !== void 0) f = (await this.readDataset({ datasetName: q })).id;
    else throw Error("Must provide a datasetName or datasetId");
    let V = new URLSearchParams({ dataset: f }), M = P ? typeof P === "string" ? P : P?.toISOString() : void 0;
    if (M) V.append("as_of", M);
    let N = Y ?? true;
    if (V.append("inline_s3_urls", N.toString()), K !== void 0) for (let h of K) V.append("id", h);
    if (_ !== void 0) for (let h of _) V.append("splits", h);
    if (O !== void 0) {
      let h = JSON.stringify(O);
      V.append("metadata", h);
    }
    if (z !== void 0) V.append("limit", z.toString());
    if (J !== void 0) V.append("offset", J.toString());
    if (T !== void 0) V.append("filter", T);
    if (X === true) ["attachment_urls", "outputs", "metadata"].forEach((h) => V.append("select", h));
    let E = 0;
    for await (let h of this._getPaginated("/examples", V)) {
      for (let I of h) {
        let { attachment_urls: D, ...g } = I, b = g;
        if (D) b.attachments = Object.entries(D).reduce((y, [p, n]) => {
          return y[p.slice(11)] = { presigned_url: n.presigned_url, mime_type: n.mime_type || void 0 }, y;
        }, {});
        yield b, E++;
      }
      if (z !== void 0 && E >= z) break;
    }
  }
  async deleteExample($) {
    O6($);
    let q = `/examples/${$}`;
    await this.caller.call(async () => {
      let K = await this._fetch(this.apiUrl + q, { method: "DELETE", headers: this.headers, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions });
      return await $6(K, `delete ${q}`, true), K;
    });
  }
  async updateExample($, q) {
    let K;
    if (q) K = $;
    else K = $.id;
    O6(K);
    let P;
    if (q) P = { id: K, ...q };
    else P = $;
    let _;
    if (P.dataset_id !== void 0) _ = P.dataset_id;
    else _ = (await this.readExample(K)).dataset_id;
    return this._updateExamplesMultipart(_, [P]);
  }
  async updateExamples($) {
    let q;
    if ($[0].dataset_id === void 0) q = (await this.readExample($[0].id)).dataset_id;
    else q = $[0].dataset_id;
    return this._updateExamplesMultipart(q, $);
  }
  async readDatasetVersion({ datasetId: $, datasetName: q, asOf: K, tag: P }) {
    let _;
    if (!$) _ = (await this.readDataset({ datasetName: q })).id;
    else _ = $;
    if (O6(_), K && P || !K && !P) throw Error("Exactly one of asOf and tag must be specified.");
    let Y = new URLSearchParams();
    if (K !== void 0) Y.append("as_of", typeof K === "string" ? K : K.toISOString());
    if (P !== void 0) Y.append("tag", P);
    return await (await this.caller.call(async () => {
      let z = await this._fetch(`${this.apiUrl}/datasets/${_}/version?${Y.toString()}`, { method: "GET", headers: { ...this.headers }, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions });
      return await $6(z, "read dataset version"), z;
    })).json();
  }
  async listDatasetSplits({ datasetId: $, datasetName: q, asOf: K }) {
    let P;
    if ($ === void 0 && q === void 0) throw Error("Must provide dataset name or ID");
    else if ($ !== void 0 && q !== void 0) throw Error("Must provide either datasetName or datasetId, not both");
    else if ($ === void 0) P = (await this.readDataset({ datasetName: q })).id;
    else P = $;
    O6(P);
    let _ = new URLSearchParams(), Y = K ? typeof K === "string" ? K : K?.toISOString() : void 0;
    if (Y) _.append("as_of", Y);
    return await this._get(`/datasets/${P}/splits`, _);
  }
  async updateDatasetSplits({ datasetId: $, datasetName: q, splitName: K, exampleIds: P, remove: _ = false }) {
    let Y;
    if ($ === void 0 && q === void 0) throw Error("Must provide dataset name or ID");
    else if ($ !== void 0 && q !== void 0) throw Error("Must provide either datasetName or datasetId, not both");
    else if ($ === void 0) Y = (await this.readDataset({ datasetName: q })).id;
    else Y = $;
    O6(Y);
    let O = { split_name: K, examples: P.map((J) => {
      return O6(J), J;
    }), remove: _ }, z = JSON.stringify(O);
    await this.caller.call(async () => {
      let J = await this._fetch(`${this.apiUrl}/datasets/${Y}/splits`, { method: "PUT", headers: { ...this.headers, "Content-Type": "application/json" }, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions, body: z });
      return await $6(J, "update dataset splits", true), J;
    });
  }
  async evaluateRun($, q, { sourceInfo: K, loadChildRuns: P, referenceExample: _ } = { loadChildRuns: false }) {
    v_("This method is deprecated and will be removed in future LangSmith versions, use `evaluate` from `langsmith/evaluation` instead.");
    let Y;
    if (typeof $ === "string") Y = await this.readRun($, { loadChildRuns: P });
    else if (typeof $ === "object" && "id" in $) Y = $;
    else throw Error(`Invalid run type: ${typeof $}`);
    if (Y.reference_example_id !== null && Y.reference_example_id !== void 0) _ = await this.readExample(Y.reference_example_id);
    let O = await q.evaluateRun(Y, _), [z, J] = await this._logEvaluationFeedback(O, Y, K);
    return J[0];
  }
  async createFeedback($, q, { score: K, value: P, correction: _, comment: Y, sourceInfo: O, feedbackSourceType: z = "api", sourceRunId: J, feedbackId: T, feedbackConfig: X, projectId: f, comparativeExperimentId: V }) {
    if (!$ && !f) throw Error("One of runId or projectId must be provided");
    if ($ && f) throw Error("Only one of runId or projectId can be provided");
    let M = { type: z ?? "api", metadata: O ?? {} };
    if (J !== void 0 && M?.metadata !== void 0 && !M.metadata.__run) M.metadata.__run = { run_id: J };
    if (M?.metadata !== void 0 && M.metadata.__run?.run_id !== void 0) O6(M.metadata.__run.run_id);
    let N = { id: T ?? j_(), run_id: $, key: q, score: UZ(K), value: P, correction: _, comment: Y, feedback_source: M, comparative_experiment_id: V, feedbackConfig: X, session_id: f }, E = JSON.stringify(N), h = `${this.apiUrl}/feedback`;
    return await this.caller.call(async () => {
      let I = await this._fetch(h, { method: "POST", headers: { ...this.headers, "Content-Type": "application/json" }, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions, body: E });
      return await $6(I, "create feedback", true), I;
    }), N;
  }
  async updateFeedback($, { score: q, value: K, correction: P, comment: _ }) {
    let Y = {};
    if (q !== void 0 && q !== null) Y.score = UZ(q);
    if (K !== void 0 && K !== null) Y.value = K;
    if (P !== void 0 && P !== null) Y.correction = P;
    if (_ !== void 0 && _ !== null) Y.comment = _;
    O6($);
    let O = JSON.stringify(Y);
    await this.caller.call(async () => {
      let z = await this._fetch(`${this.apiUrl}/feedback/${$}`, { method: "PATCH", headers: { ...this.headers, "Content-Type": "application/json" }, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions, body: O });
      return await $6(z, "update feedback", true), z;
    });
  }
  async readFeedback($) {
    O6($);
    let q = `/feedback/${$}`;
    return await this._get(q);
  }
  async deleteFeedback($) {
    O6($);
    let q = `/feedback/${$}`;
    await this.caller.call(async () => {
      let K = await this._fetch(this.apiUrl + q, { method: "DELETE", headers: this.headers, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions });
      return await $6(K, `delete ${q}`, true), K;
    });
  }
  async *listFeedback({ runIds: $, feedbackKeys: q, feedbackSourceTypes: K } = {}) {
    let P = new URLSearchParams();
    if ($) for (let _ of $) O6(_), P.append("run", _);
    if (q) for (let _ of q) P.append("key", _);
    if (K) for (let _ of K) P.append("source", _);
    for await (let _ of this._getPaginated("/feedback", P)) yield* _;
  }
  async createPresignedFeedbackToken($, q, { expiration: K, feedbackConfig: P } = {}) {
    let _ = { run_id: $, feedback_key: q, feedback_config: P };
    if (K) {
      if (typeof K === "string") _.expires_at = K;
      else if (K?.hours || K?.minutes || K?.days) _.expires_in = K;
    } else _.expires_in = { hours: 3 };
    let Y = JSON.stringify(_);
    return await (await this.caller.call(async () => {
      let z = await this._fetch(`${this.apiUrl}/feedback/tokens`, { method: "POST", headers: { ...this.headers, "Content-Type": "application/json" }, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions, body: Y });
      return await $6(z, "create presigned feedback token"), z;
    })).json();
  }
  async createComparativeExperiment({ name: $, experimentIds: q, referenceDatasetId: K, createdAt: P, description: _, metadata: Y, id: O }) {
    if (q.length === 0) throw Error("At least one experiment is required");
    if (!K) K = (await this.readProject({ projectId: q[0] })).reference_dataset_id;
    if (!K == null) throw Error("A reference dataset is required");
    let z = { id: O, name: $, experiment_ids: q, reference_dataset_id: K, description: _, created_at: (P ?? /* @__PURE__ */ new Date())?.toISOString(), extra: {} };
    if (Y) z.extra.metadata = Y;
    let J = JSON.stringify(z);
    return (await this.caller.call(async () => {
      let X = await this._fetch(`${this.apiUrl}/datasets/comparative`, { method: "POST", headers: { ...this.headers, "Content-Type": "application/json" }, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions, body: J });
      return await $6(X, "create comparative experiment"), X;
    })).json();
  }
  async *listPresignedFeedbackTokens($) {
    O6($);
    let q = new URLSearchParams({ run_id: $ });
    for await (let K of this._getPaginated("/feedback/tokens", q)) yield* K;
  }
  _selectEvalResults($) {
    let q;
    if ("results" in $) q = $.results;
    else if (Array.isArray($)) q = $;
    else q = [$];
    return q;
  }
  async _logEvaluationFeedback($, q, K) {
    let P = this._selectEvalResults($), _ = [];
    for (let Y of P) {
      let O = K || {};
      if (Y.evaluatorInfo) O = { ...Y.evaluatorInfo, ...O };
      let z = null;
      if (Y.targetRunId) z = Y.targetRunId;
      else if (q) z = q.id;
      _.push(await this.createFeedback(z, Y.key, { score: Y.score, value: Y.value, comment: Y.comment, correction: Y.correction, sourceInfo: O, sourceRunId: Y.sourceRunId, feedbackConfig: Y.feedbackConfig, feedbackSourceType: "model" }));
    }
    return [P, _];
  }
  async logEvaluationFeedback($, q, K) {
    let [P] = await this._logEvaluationFeedback($, q, K);
    return P;
  }
  async *listAnnotationQueues($ = {}) {
    let { queueIds: q, name: K, nameContains: P, limit: _ } = $, Y = new URLSearchParams();
    if (q) q.forEach((z, J) => {
      O6(z, `queueIds[${J}]`), Y.append("ids", z);
    });
    if (K) Y.append("name", K);
    if (P) Y.append("name_contains", P);
    Y.append("limit", (_ !== void 0 ? Math.min(_, 100) : 100).toString());
    let O = 0;
    for await (let z of this._getPaginated("/annotation-queues", Y)) if (yield* z, O++, _ !== void 0 && O >= _) break;
  }
  async createAnnotationQueue($) {
    let { name: q, description: K, queueId: P, rubricInstructions: _ } = $, Y = { name: q, description: K, id: P || j_(), rubric_instructions: _ }, O = JSON.stringify(Object.fromEntries(Object.entries(Y).filter(([J, T]) => T !== void 0)));
    return (await this.caller.call(async () => {
      let J = await this._fetch(`${this.apiUrl}/annotation-queues`, { method: "POST", headers: { ...this.headers, "Content-Type": "application/json" }, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions, body: O });
      return await $6(J, "create annotation queue"), J;
    })).json();
  }
  async readAnnotationQueue($) {
    return (await this.caller.call(async () => {
      let K = await this._fetch(`${this.apiUrl}/annotation-queues/${O6($, "queueId")}`, { method: "GET", headers: this.headers, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions });
      return await $6(K, "read annotation queue"), K;
    })).json();
  }
  async updateAnnotationQueue($, q) {
    let { name: K, description: P, rubricInstructions: _ } = q, Y = JSON.stringify({ name: K, description: P, rubric_instructions: _ });
    await this.caller.call(async () => {
      let O = await this._fetch(`${this.apiUrl}/annotation-queues/${O6($, "queueId")}`, { method: "PATCH", headers: { ...this.headers, "Content-Type": "application/json" }, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions, body: Y });
      return await $6(O, "update annotation queue", true), O;
    });
  }
  async deleteAnnotationQueue($) {
    await this.caller.call(async () => {
      let q = await this._fetch(`${this.apiUrl}/annotation-queues/${O6($, "queueId")}`, { method: "DELETE", headers: { ...this.headers, Accept: "application/json" }, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions });
      return await $6(q, "delete annotation queue", true), q;
    });
  }
  async addRunsToAnnotationQueue($, q) {
    let K = JSON.stringify(q.map((P, _) => O6(P, `runIds[${_}]`).toString()));
    await this.caller.call(async () => {
      let P = await this._fetch(`${this.apiUrl}/annotation-queues/${O6($, "queueId")}/runs`, { method: "POST", headers: { ...this.headers, "Content-Type": "application/json" }, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions, body: K });
      return await $6(P, "add runs to annotation queue", true), P;
    });
  }
  async getRunFromAnnotationQueue($, q) {
    let K = `/annotation-queues/${O6($, "queueId")}/run`;
    return (await this.caller.call(async () => {
      let _ = await this._fetch(`${this.apiUrl}${K}/${q}`, { method: "GET", headers: this.headers, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions });
      return await $6(_, "get run from annotation queue"), _;
    })).json();
  }
  async deleteRunFromAnnotationQueue($, q) {
    await this.caller.call(async () => {
      let K = await this._fetch(`${this.apiUrl}/annotation-queues/${O6($, "queueId")}/runs/${O6(q, "queueRunId")}`, { method: "DELETE", headers: { ...this.headers, Accept: "application/json" }, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions });
      return await $6(K, "delete run from annotation queue", true), K;
    });
  }
  async getSizeFromAnnotationQueue($) {
    return (await this.caller.call(async () => {
      let K = await this._fetch(`${this.apiUrl}/annotation-queues/${O6($, "queueId")}/size`, { method: "GET", headers: this.headers, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions });
      return await $6(K, "get size from annotation queue"), K;
    })).json();
  }
  async _currentTenantIsOwner($) {
    let q = await this._getSettings();
    return $ == "-" || q.tenant_handle === $;
  }
  async _ownerConflictError($, q) {
    let K = await this._getSettings();
    return Error(`Cannot ${$} for another tenant.

      Current tenant: ${K.tenant_handle}

      Requested tenant: ${q}`);
  }
  async _getLatestCommitHash($) {
    let K = await (await this.caller.call(async () => {
      let P = await this._fetch(`${this.apiUrl}/commits/${$}/?limit=1&offset=0`, { method: "GET", headers: this.headers, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions });
      return await $6(P, "get latest commit hash"), P;
    })).json();
    if (K.commits.length === 0) return;
    return K.commits[0].commit_hash;
  }
  async _likeOrUnlikePrompt($, q) {
    let [K, P, _] = YK($), Y = JSON.stringify({ like: q });
    return (await this.caller.call(async () => {
      let z = await this._fetch(`${this.apiUrl}/likes/${K}/${P}`, { method: "POST", headers: { ...this.headers, "Content-Type": "application/json" }, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions, body: Y });
      return await $6(z, `${q ? "like" : "unlike"} prompt`), z;
    })).json();
  }
  async _getPromptUrl($) {
    let [q, K, P] = YK($);
    if (!await this._currentTenantIsOwner(q)) if (P !== "latest") return `${this.getHostUrl()}/hub/${q}/${K}/${P.substring(0, 8)}`;
    else return `${this.getHostUrl()}/hub/${q}/${K}`;
    else {
      let _ = await this._getSettings();
      if (P !== "latest") return `${this.getHostUrl()}/prompts/${K}/${P.substring(0, 8)}?organizationId=${_.id}`;
      else return `${this.getHostUrl()}/prompts/${K}?organizationId=${_.id}`;
    }
  }
  async promptExists($) {
    return !!await this.getPrompt($);
  }
  async likePrompt($) {
    return this._likeOrUnlikePrompt($, true);
  }
  async unlikePrompt($) {
    return this._likeOrUnlikePrompt($, false);
  }
  async *listCommits($) {
    for await (let q of this._getPaginated(`/commits/${$}/`, new URLSearchParams(), (K) => K.commits)) yield* q;
  }
  async *listPrompts($) {
    let q = new URLSearchParams();
    if (q.append("sort_field", $?.sortField ?? "updated_at"), q.append("sort_direction", "desc"), q.append("is_archived", (!!$?.isArchived).toString()), $?.isPublic !== void 0) q.append("is_public", $.isPublic.toString());
    if ($?.query) q.append("query", $.query);
    for await (let K of this._getPaginated("/repos", q, (P) => P.repos)) yield* K;
  }
  async getPrompt($) {
    let [q, K, P] = YK($), Y = await (await this.caller.call(async () => {
      let O = await this._fetch(`${this.apiUrl}/repos/${q}/${K}`, { method: "GET", headers: this.headers, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions });
      if (O?.status === 404) return null;
      return await $6(O, "get prompt"), O;
    }))?.json();
    if (Y?.repo) return Y.repo;
    else return null;
  }
  async createPrompt($, q) {
    let K = await this._getSettings();
    if (q?.isPublic && !K.tenant_handle) throw Error(`Cannot create a public prompt without first

        creating a LangChain Hub handle.
        You can add a handle by creating a public prompt at:

        https://smith.langchain.com/prompts`);
    let [P, _, Y] = YK($);
    if (!await this._currentTenantIsOwner(P)) throw await this._ownerConflictError("create a prompt", P);
    let O = { repo_handle: _, ...q?.description && { description: q.description }, ...q?.readme && { readme: q.readme }, ...q?.tags && { tags: q.tags }, is_public: !!q?.isPublic }, z = JSON.stringify(O), J = await this.caller.call(async () => {
      let X = await this._fetch(`${this.apiUrl}/repos/`, { method: "POST", headers: { ...this.headers, "Content-Type": "application/json" }, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions, body: z });
      return await $6(X, "create prompt"), X;
    }), { repo: T } = await J.json();
    return T;
  }
  async createCommit($, q, K) {
    if (!await this.promptExists($)) throw Error("Prompt does not exist, you must create it first.");
    let [P, _, Y] = YK($), O = K?.parentCommitHash === "latest" || !K?.parentCommitHash ? await this._getLatestCommitHash(`${P}/${_}`) : K?.parentCommitHash, z = { manifest: JSON.parse(JSON.stringify(q)), parent_commit: O }, J = JSON.stringify(z), X = await (await this.caller.call(async () => {
      let f = await this._fetch(`${this.apiUrl}/commits/${P}/${_}`, { method: "POST", headers: { ...this.headers, "Content-Type": "application/json" }, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions, body: J });
      return await $6(f, "create commit"), f;
    })).json();
    return this._getPromptUrl(`${P}/${_}${X.commit_hash ? `:${X.commit_hash}` : ""}`);
  }
  async updateExamplesMultipart($, q = []) {
    return this._updateExamplesMultipart($, q);
  }
  async _updateExamplesMultipart($, q = []) {
    if (!await this._getDatasetExamplesMultiPartSupport()) throw Error("Your LangSmith deployment does not allow using the multipart examples endpoint, please upgrade your deployment to the latest version.");
    let K = new FormData();
    for (let Y of q) {
      let O = Y.id, z = { ...Y.metadata && { metadata: Y.metadata }, ...Y.split && { split: Y.split } }, J = tq(z, `Serializing body for example with id: ${O}`), T = new Blob([J], { type: "application/json" });
      if (K.append(O, T), Y.inputs) {
        let X = tq(Y.inputs, `Serializing inputs for example with id: ${O}`), f = new Blob([X], { type: "application/json" });
        K.append(`${O}.inputs`, f);
      }
      if (Y.outputs) {
        let X = tq(Y.outputs, `Serializing outputs whle updating example with id: ${O}`), f = new Blob([X], { type: "application/json" });
        K.append(`${O}.outputs`, f);
      }
      if (Y.attachments) for (let [X, f] of Object.entries(Y.attachments)) {
        let V, M;
        if (Array.isArray(f)) [V, M] = f;
        else V = f.mimeType, M = f.data;
        let N = new Blob([M], { type: `${V}; length=${M.byteLength}` });
        K.append(`${O}.attachment.${X}`, N);
      }
      if (Y.attachments_operations) {
        let X = tq(Y.attachments_operations, `Serializing attachments while updating example with id: ${O}`), f = new Blob([X], { type: "application/json" });
        K.append(`${O}.attachments_operations`, f);
      }
    }
    let P = $ ?? q[0]?.dataset_id;
    return (await this.caller.call(async () => {
      let Y = await this._fetch(`${this.apiUrl}${this._getPlatformEndpointPath(`datasets/${P}/examples`)}`, { method: "PATCH", headers: this.headers, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions, body: K });
      return await $6(Y, "update examples"), Y;
    })).json();
  }
  async uploadExamplesMultipart($, q = []) {
    return this._uploadExamplesMultipart($, q);
  }
  async _uploadExamplesMultipart($, q = []) {
    if (!await this._getDatasetExamplesMultiPartSupport()) throw Error("Your LangSmith deployment does not allow using the multipart examples endpoint, please upgrade your deployment to the latest version.");
    let K = new FormData();
    for (let _ of q) {
      let Y = (_.id ?? j_()).toString(), O = { created_at: _.created_at, ..._.metadata && { metadata: _.metadata }, ..._.split && { split: _.split }, ..._.source_run_id && { source_run_id: _.source_run_id }, ..._.use_source_run_io && { use_source_run_io: _.use_source_run_io }, ..._.use_source_run_attachments && { use_source_run_attachments: _.use_source_run_attachments } }, z = tq(O, `Serializing body for uploaded example with id: ${Y}`), J = new Blob([z], { type: "application/json" });
      if (K.append(Y, J), _.inputs) {
        let T = tq(_.inputs, `Serializing inputs for uploaded example with id: ${Y}`), X = new Blob([T], { type: "application/json" });
        K.append(`${Y}.inputs`, X);
      }
      if (_.outputs) {
        let T = tq(_.outputs, `Serializing outputs for uploaded example with id: ${Y}`), X = new Blob([T], { type: "application/json" });
        K.append(`${Y}.outputs`, X);
      }
      if (_.attachments) for (let [T, X] of Object.entries(_.attachments)) {
        let f, V;
        if (Array.isArray(X)) [f, V] = X;
        else f = X.mimeType, V = X.data;
        let M = new Blob([V], { type: `${f}; length=${V.byteLength}` });
        K.append(`${Y}.attachment.${T}`, M);
      }
    }
    return (await this.caller.call(async () => {
      let _ = await this._fetch(`${this.apiUrl}${this._getPlatformEndpointPath(`datasets/${$}/examples`)}`, { method: "POST", headers: this.headers, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions, body: K });
      return await $6(_, "upload examples"), _;
    })).json();
  }
  async updatePrompt($, q) {
    if (!await this.promptExists($)) throw Error("Prompt does not exist, you must create it first.");
    let [K, P] = YK($);
    if (!await this._currentTenantIsOwner(K)) throw await this._ownerConflictError("update a prompt", K);
    let _ = {};
    if (q?.description !== void 0) _.description = q.description;
    if (q?.readme !== void 0) _.readme = q.readme;
    if (q?.tags !== void 0) _.tags = q.tags;
    if (q?.isPublic !== void 0) _.is_public = q.isPublic;
    if (q?.isArchived !== void 0) _.is_archived = q.isArchived;
    if (Object.keys(_).length === 0) throw Error("No valid update options provided");
    let Y = JSON.stringify(_);
    return (await this.caller.call(async () => {
      let z = await this._fetch(`${this.apiUrl}/repos/${K}/${P}`, { method: "PATCH", headers: { ...this.headers, "Content-Type": "application/json" }, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions, body: Y });
      return await $6(z, "update prompt"), z;
    })).json();
  }
  async deletePrompt($) {
    if (!await this.promptExists($)) throw Error("Prompt does not exist, you must create it first.");
    let [q, K, P] = YK($);
    if (!await this._currentTenantIsOwner(q)) throw await this._ownerConflictError("delete a prompt", q);
    return (await this.caller.call(async () => {
      let Y = await this._fetch(`${this.apiUrl}/repos/${q}/${K}`, { method: "DELETE", headers: this.headers, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions });
      return await $6(Y, "delete prompt"), Y;
    })).json();
  }
  async pullPromptCommit($, q) {
    let [K, P, _] = YK($), O = await (await this.caller.call(async () => {
      let z = await this._fetch(`${this.apiUrl}/commits/${K}/${P}/${_}${q?.includeModel ? "?include_model=true" : ""}`, { method: "GET", headers: this.headers, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions });
      return await $6(z, "pull prompt commit"), z;
    })).json();
    return { owner: K, repo: P, commit_hash: O.commit_hash, manifest: O.manifest, examples: O.examples };
  }
  async _pullPrompt($, q) {
    let K = await this.pullPromptCommit($, { includeModel: q?.includeModel });
    return JSON.stringify(K.manifest);
  }
  async pushPrompt($, q) {
    if (await this.promptExists($)) {
      if (q && Object.keys(q).some((P) => P !== "object")) await this.updatePrompt($, { description: q?.description, readme: q?.readme, tags: q?.tags, isPublic: q?.isPublic });
    } else await this.createPrompt($, { description: q?.description, readme: q?.readme, tags: q?.tags, isPublic: q?.isPublic });
    if (!q?.object) return await this._getPromptUrl($);
    return await this.createCommit($, q?.object, { parentCommitHash: q?.parentCommitHash });
  }
  async clonePublicDataset($, q = {}) {
    let { sourceApiUrl: K = this.apiUrl, datasetName: P } = q, [_, Y] = this.parseTokenOrUrl($, K), O = new _uK({ apiUrl: _, apiKey: "placeholder" }), z = await O.readSharedDataset(Y), J = P || z.name;
    try {
      if (await this.hasDataset({ datasetId: J })) {
        console.log(`Dataset ${J} already exists in your tenant. Skipping.`);
        return;
      }
    } catch (f) {
    }
    let T = await O.listSharedExamples(Y), X = await this.createDataset(J, { description: z.description, dataType: z.data_type || "kv", inputsSchema: z.inputs_schema_definition ?? void 0, outputsSchema: z.outputs_schema_definition ?? void 0 });
    try {
      await this.createExamples({ inputs: T.map((f) => f.inputs), outputs: T.flatMap((f) => f.outputs ? [f.outputs] : []), datasetId: X.id });
    } catch (f) {
      throw console.error(`An error occurred while creating dataset ${J}. You should delete it manually.`), f;
    }
  }
  parseTokenOrUrl($, q, K = 2, P = "dataset") {
    try {
      return O6($), [q, $];
    } catch (_) {
    }
    try {
      let Y = new URL($).pathname.split("/").filter((O) => O !== "");
      if (Y.length >= K) {
        let O = Y[Y.length - K];
        return [q, O];
      } else throw Error(`Invalid public ${P} URL: ${$}`);
    } catch (_) {
      throw Error(`Invalid public ${P} URL or token: ${$}`);
    }
  }
  async awaitPendingTraceBatches() {
    if (this.manualFlushMode) return console.warn("[WARNING]: When tracing in manual flush mode, you must call `await client.flush()` manually to submit trace batches."), Promise.resolve();
    if (await Promise.all([...this.autoBatchQueue.items.map(({ itemPromise: $ }) => $), this.batchIngestCaller.queue.onIdle()]), this.langSmithToOTELTranslator !== void 0) await Dw()?.DEFAULT_LANGSMITH_SPAN_PROCESSOR?.forceFlush();
  }
};
__name(_uK, "uK");
var uK = _uK;
function aZ($) {
  return "dataset_id" in $ || "dataset_name" in $;
}
__name(aZ, "aZ");
var sZ = /* @__PURE__ */ __name(($) => {
  if ($ !== void 0) return $;
  return !!["TRACING_V2", "TRACING"].find((K) => r6(K) === "true");
}, "sZ");
var F1 = Symbol.for("lc:context_variables");
function hR($) {
  return $.replace(/[-:.]/g, "");
}
__name(hR, "hR");
function qX($, q = 1) {
  let K = q.toFixed(0).slice(0, 3).padStart(3, "0");
  return `${new Date($).toISOString().slice(0, -1)}${K}Z`;
}
__name(qX, "qX");
function R2($, q, K = 1) {
  let P = qX($, K);
  return { dottedOrder: hR(P) + q, microsecondPrecisionDatestring: P };
}
__name(R2, "R2");
var _a1 = class _a1 {
  constructor($, q, K, P) {
    Object.defineProperty(this, "metadata", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "tags", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "project_name", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "replicas", { enumerable: true, configurable: true, writable: true, value: void 0 }), this.metadata = $, this.tags = q, this.project_name = K, this.replicas = P;
  }
  static fromHeader($) {
    let q = $.split(","), K = {}, P = [], _, Y;
    for (let O of q) {
      let [z, J] = O.split("="), T = decodeURIComponent(J);
      if (z === "langsmith-metadata") K = JSON.parse(T);
      else if (z === "langsmith-tags") P = T.split(",");
      else if (z === "langsmith-project") _ = T;
      else if (z === "langsmith-replicas") Y = JSON.parse(T);
    }
    return new _a1(K, P, _, Y);
  }
  toHeader() {
    let $ = [];
    if (this.metadata && Object.keys(this.metadata).length > 0) $.push(`langsmith-metadata=${encodeURIComponent(JSON.stringify(this.metadata))}`);
    if (this.tags && this.tags.length > 0) $.push(`langsmith-tags=${encodeURIComponent(this.tags.join(","))}`);
    if (this.project_name) $.push(`langsmith-project=${encodeURIComponent(this.project_name)}`);
    return $.join(",");
  }
};
__name(_a1, "a1");
var a1 = _a1;
var _Yq = class _Yq {
  constructor($) {
    if (Object.defineProperty(this, "id", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "name", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "run_type", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "project_name", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "parent_run", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "parent_run_id", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "child_runs", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "start_time", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "end_time", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "extra", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "tags", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "error", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "serialized", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "inputs", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "outputs", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "reference_example_id", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "client", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "events", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "trace_id", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "dotted_order", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "tracingEnabled", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "execution_order", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "child_execution_order", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "attachments", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "replicas", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "_serialized_start_time", { enumerable: true, configurable: true, writable: true, value: void 0 }), KX($)) {
      Object.assign(this, { ...$ });
      return;
    }
    let q = _Yq.getDefaultConfig(), { metadata: K, ...P } = $, _ = P.client ?? _Yq.getSharedClient(), Y = { ...K, ...P?.extra?.metadata };
    if (P.extra = { ...P.extra, metadata: Y }, "id" in P && P.id == null) delete P.id;
    if (Object.assign(this, { ...q, ...P, client: _ }), this.execution_order ??= 1, this.child_execution_order ??= 1, !this.dotted_order) this._serialized_start_time = qX(this.start_time, this.execution_order);
    if (!this.id) this.id = k1(this._serialized_start_time ?? this.start_time);
    if (P.id) G1(P.id, "run_id");
    if (!this.trace_id) if (this.parent_run) this.trace_id = this.parent_run.trace_id ?? this.id;
    else this.trace_id = this.id;
    else if (P.trace_id) G1(P.trace_id, "trace_id");
    if (P.parent_run_id) G1(P.parent_run_id, "parent_run_id");
    if (this.replicas = DR(this.replicas), !this.dotted_order) {
      let { dottedOrder: O } = R2(this.start_time, this.id, this.execution_order);
      if (this.parent_run) this.dotted_order = this.parent_run.dotted_order + "." + O;
      else this.dotted_order = O;
    }
  }
  set metadata($) {
    this.extra = { ...this.extra, metadata: { ...this.extra?.metadata, ...$ } };
  }
  get metadata() {
    return this.extra?.metadata;
  }
  static getDefaultConfig() {
    let $ = Date.now();
    return { run_type: "chain", project_name: WP(), child_runs: [], api_url: P8("LANGCHAIN_ENDPOINT") ?? "http://localhost:1984", api_key: P8("LANGCHAIN_API_KEY"), caller_options: {}, start_time: $, serialized: {}, inputs: {}, extra: {} };
  }
  static getSharedClient() {
    if (!_Yq.sharedClient) _Yq.sharedClient = new uK();
    return _Yq.sharedClient;
  }
  createChild($) {
    let q = this.child_execution_order + 1, K = new _Yq({ ...$, parent_run: this, project_name: this.project_name, replicas: this.replicas, client: this.client, tracingEnabled: this.tracingEnabled, execution_order: q, child_execution_order: q });
    if (F1 in this) K[F1] = this[F1];
    let P = Symbol.for("lc:child_config"), _ = $.extra?.[P] ?? this.extra[P];
    if (RR(_)) {
      let z = { ..._ }, J = ER(z.callbacks) ? z.callbacks.copy?.() : void 0;
      if (J) Object.assign(J, { _parentRunId: K.id }), J.handlers?.find(_X)?.updateFromRunTree?.(K), z.callbacks = J;
      K.extra[P] = z;
    }
    let Y = /* @__PURE__ */ new Set(), O = this;
    while (O != null && !Y.has(O.id)) Y.add(O.id), O.child_execution_order = Math.max(O.child_execution_order, q), O = O.parent_run;
    return this.child_runs.push(K), K;
  }
  async end($, q, K = Date.now(), P) {
    if (this.outputs = this.outputs ?? $, this.error = this.error ?? q, this.end_time = this.end_time ?? K, P && Object.keys(P).length > 0) this.extra = this.extra ? { ...this.extra, metadata: { ...this.extra.metadata, ...P } } : { metadata: P };
  }
  _convertToCreate($, q, K = true) {
    let P = $.extra ?? {};
    if (P?.runtime?.library === void 0) {
      if (!P.runtime) P.runtime = {};
      if (q) {
        for (let [O, z] of Object.entries(q)) if (!P.runtime[O]) P.runtime[O] = z;
      }
    }
    let _, Y;
    if (!K) _ = $.child_runs.map((O) => this._convertToCreate(O, q, K)), Y = void 0;
    else Y = $.parent_run?.id ?? $.parent_run_id, _ = [];
    return { id: $.id, name: $.name, start_time: $._serialized_start_time ?? $.start_time, end_time: $.end_time, run_type: $.run_type, reference_example_id: $.reference_example_id, extra: P, serialized: $.serialized, error: $.error, inputs: $.inputs, outputs: $.outputs, session_name: $.project_name, child_runs: _, parent_run_id: Y, trace_id: $.trace_id, dotted_order: $.dotted_order, tags: $.tags, attachments: $.attachments, events: $.events };
  }
  _remapForProject($, q, K = true) {
    return { ...this._convertToCreate(this, q, K), session_name: $ };
  }
  async postRun($ = true) {
    try {
      let q = S1();
      if (this.replicas && this.replicas.length > 0) for (let { projectName: K, apiKey: P, apiUrl: _, workspaceId: Y } of this.replicas) {
        let O = this._remapForProject(K ?? this.project_name, q, true);
        await this.client.createRun(O, { apiKey: P, apiUrl: _, workspaceId: Y });
      }
      else {
        let K = this._convertToCreate(this, q, $);
        await this.client.createRun(K);
      }
      if (!$) {
        v_("Posting with excludeChildRuns=false is deprecated and will be removed in a future version.");
        for (let K of this.child_runs) await K.postRun(false);
      }
    } catch (q) {
      console.error(`Error in postRun for run ${this.id}:`, q);
    }
  }
  async patchRun($) {
    if (this.replicas && this.replicas.length > 0) for (let { projectName: q, apiKey: K, apiUrl: P, workspaceId: _, updates: Y } of this.replicas) {
      let O = this._remapForProject(q ?? this.project_name), z = { id: O.id, name: O.name, run_type: O.run_type, start_time: O.start_time, outputs: O.outputs, error: O.error, parent_run_id: O.parent_run_id, session_name: O.session_name, reference_example_id: O.reference_example_id, end_time: O.end_time, dotted_order: O.dotted_order, trace_id: O.trace_id, events: O.events, tags: O.tags, extra: O.extra, attachments: this.attachments, ...Y };
      if (!$?.excludeInputs) z.inputs = O.inputs;
      await this.client.updateRun(O.id, z, { apiKey: K, apiUrl: P, workspaceId: _ });
    }
    else try {
      let q = { name: this.name, run_type: this.run_type, start_time: this._serialized_start_time ?? this.start_time, end_time: this.end_time, error: this.error, outputs: this.outputs, parent_run_id: this.parent_run?.id ?? this.parent_run_id, reference_example_id: this.reference_example_id, extra: this.extra, events: this.events, dotted_order: this.dotted_order, trace_id: this.trace_id, tags: this.tags, attachments: this.attachments, session_name: this.project_name };
      if (!$?.excludeInputs) q.inputs = this.inputs;
      await this.client.updateRun(this.id, q);
    } catch (q) {
      console.error(`Error in patchRun for run ${this.id}`, q);
    }
  }
  toJSON() {
    return this._convertToCreate(this, void 0, false);
  }
  addEvent($) {
    if (!this.events) this.events = [];
    if (typeof $ === "string") this.events.push({ name: "event", time: (/* @__PURE__ */ new Date()).toISOString(), message: $ });
    else this.events.push({ ...$, time: $.time ?? (/* @__PURE__ */ new Date()).toISOString() });
  }
  static fromRunnableConfig($, q) {
    let K = $?.callbacks, P, _, Y, O = sZ();
    if (K) {
      let J = K?.getParentRunId?.() ?? "", T = K?.handlers?.find((X) => X?.name == "langchain_tracer");
      P = T?.getRun?.(J), _ = T?.projectName, Y = T?.client, O = O || !!T;
    }
    if (!P) return new _Yq({ ...q, client: Y, tracingEnabled: O, project_name: _ });
    return new _Yq({ name: P.name, id: P.id, trace_id: P.trace_id, dotted_order: P.dotted_order, client: Y, tracingEnabled: O, project_name: _, tags: [...new Set((P?.tags ?? []).concat($?.tags ?? []))], extra: { metadata: { ...P?.extra?.metadata, ...$?.metadata } } }).createChild(q);
  }
  static fromDottedOrder($) {
    return this.fromHeaders({ "langsmith-trace": $ });
  }
  static fromHeaders($, q) {
    let K = "get" in $ && typeof $.get === "function" ? { "langsmith-trace": $.get("langsmith-trace"), baggage: $.get("baggage") } : $, P = K["langsmith-trace"];
    if (!P || typeof P !== "string") return;
    let _ = P.trim(), Y = _.split(".").map((J) => {
      let [T, X] = J.split("Z");
      return { strTime: T, time: Date.parse(T + "Z"), uuid: X };
    }), O = Y[0].uuid, z = { ...q, name: q?.name ?? "parent", run_type: q?.run_type ?? "chain", start_time: q?.start_time ?? Date.now(), id: Y.at(-1)?.uuid, trace_id: O, dotted_order: _ };
    if (K.baggage && typeof K.baggage === "string") {
      let J = a1.fromHeader(K.baggage);
      z.metadata = J.metadata, z.tags = J.tags, z.project_name = J.project_name, z.replicas = J.replicas;
    }
    return new _Yq(z);
  }
  toHeaders($) {
    let q = { "langsmith-trace": this.dotted_order, baggage: new a1(this.extra?.metadata, this.tags, this.project_name, this.replicas).toHeader() };
    if ($) for (let [K, P] of Object.entries(q)) $.set(K, P);
    return q;
  }
};
__name(_Yq, "Yq");
var Yq = _Yq;
Object.defineProperty(Yq, "sharedClient", { enumerable: true, configurable: true, writable: true, value: null });
function KX($) {
  return $ != null && typeof $.createChild === "function" && typeof $.postRun === "function";
}
__name(KX, "KX");
function _X($) {
  return typeof $ === "object" && $ != null && typeof $.name === "string" && $.name === "langchain_tracer";
}
__name(_X, "_X");
function $X($) {
  return Array.isArray($) && $.some((q) => _X(q));
}
__name($X, "$X");
function ER($) {
  return typeof $ === "object" && $ != null && Array.isArray($.handlers);
}
__name(ER, "ER");
function RR($) {
  return $ != null && typeof $.callbacks === "object" && ($X($.callbacks?.handlers) || $X($.callbacks));
}
__name(RR, "RR");
function IR() {
  let $ = P8("LANGSMITH_RUNS_ENDPOINTS");
  if (!$) return [];
  try {
    let q = JSON.parse($);
    if (Array.isArray(q)) {
      let K = [];
      for (let P of q) {
        if (typeof P !== "object" || P === null) {
          console.warn(`Invalid item type in LANGSMITH_RUNS_ENDPOINTS: expected object, got ${typeof P}`);
          continue;
        }
        if (typeof P.api_url !== "string") {
          console.warn(`Invalid api_url type in LANGSMITH_RUNS_ENDPOINTS: expected string, got ${typeof P.api_url}`);
          continue;
        }
        if (typeof P.api_key !== "string") {
          console.warn(`Invalid api_key type in LANGSMITH_RUNS_ENDPOINTS: expected string, got ${typeof P.api_key}`);
          continue;
        }
        K.push({ apiUrl: P.api_url.replace(/\/$/, ""), apiKey: P.api_key });
      }
      return K;
    } else if (typeof q === "object" && q !== null) {
      LR(q);
      let K = [];
      for (let [P, _] of Object.entries(q)) {
        let Y = P.replace(/\/$/, "");
        if (typeof _ === "string") K.push({ apiUrl: Y, apiKey: _ });
        else {
          console.warn(`Invalid value type in LANGSMITH_RUNS_ENDPOINTS for URL ${P}: expected string, got ${typeof _}`);
          continue;
        }
      }
      return K;
    } else return console.warn(`Invalid LANGSMITH_RUNS_ENDPOINTS  must be valid JSON array of objects with api_url and api_key properties, or object mapping url->apiKey, got ${typeof q}`), [];
  } catch (q) {
    if (nZ(q)) throw q;
    return console.warn("Invalid LANGSMITH_RUNS_ENDPOINTS  must be valid JSON array of objects with api_url and api_key properties, or object mapping url->apiKey"), [];
  }
}
__name(IR, "IR");
function DR($) {
  if ($) return $.map((q) => {
    if (Array.isArray(q)) return { projectName: q[0], updates: q[1] };
    return q;
  });
  return IR();
}
__name(DR, "DR");
function LR($) {
  if (Object.keys($).length > 0 && r6("ENDPOINT")) throw new C2();
}
__name(LR, "LR");
var gR = {};
Z6(gR, { BaseTracer: /* @__PURE__ */ __name(() => E8, "BaseTracer"), isBaseTracer: /* @__PURE__ */ __name(() => W_, "isBaseTracer") });
var bR = /* @__PURE__ */ __name(($) => {
  if (!$) return;
  return $.events = $.events ?? [], $.child_runs = $.child_runs ?? [], $;
}, "bR");
function D2($, q) {
  if (!$) return;
  return new Yq({ ...$, start_time: $._serialized_start_time ?? $.start_time, parent_run: D2(q), child_runs: $.child_runs.map((K) => D2(K)).filter((K) => K !== void 0), extra: { ...$.extra, runtime: dO() }, tracingEnabled: false });
}
__name(D2, "D2");
function I2($, q) {
  return $ && !Array.isArray($) && typeof $ === "object" ? $ : { [q]: $ };
}
__name(I2, "I2");
function W_($) {
  return typeof $._addRunToRunMap === "function";
}
__name(W_, "W_");
var _a11;
var E8 = (_a11 = class extends Y_ {
  runMap = /* @__PURE__ */ new Map();
  runTreeMap = /* @__PURE__ */ new Map();
  usesRunTreeMap = false;
  constructor($) {
    super(...arguments);
  }
  copy() {
    return this;
  }
  getRunById($) {
    if ($ === void 0) return;
    return this.usesRunTreeMap ? bR(this.runTreeMap.get($)) : this.runMap.get($);
  }
  stringifyError($) {
    if ($ instanceof Error) return $.message + ($?.stack ? `

${$.stack}` : "");
    if (typeof $ === "string") return $;
    return `${$}`;
  }
  _addChildRun($, q) {
    $.child_runs.push(q);
  }
  _addRunToRunMap($) {
    let { dottedOrder: q, microsecondPrecisionDatestring: K } = R2(new Date($.start_time).getTime(), $.id, $.execution_order), P = { ...$ }, _ = this.getRunById(P.parent_run_id);
    if (P.parent_run_id !== void 0) {
      if (_) {
        if (this._addChildRun(_, P), _.child_execution_order = Math.max(_.child_execution_order, P.child_execution_order), P.trace_id = _.trace_id, _.dotted_order !== void 0) P.dotted_order = [_.dotted_order, q].join("."), P._serialized_start_time = K;
      }
    } else P.trace_id = P.id, P.dotted_order = q, P._serialized_start_time = K;
    if (this.usesRunTreeMap) {
      let Y = D2(P, _);
      if (Y !== void 0) this.runTreeMap.set(P.id, Y);
    } else this.runMap.set(P.id, P);
    return P;
  }
  async _endTrace($) {
    let q = $.parent_run_id !== void 0 && this.getRunById($.parent_run_id);
    if (q) q.child_execution_order = Math.max(q.child_execution_order, $.child_execution_order);
    else await this.persistRun($);
    if (await this.onRunUpdate?.($), this.usesRunTreeMap) this.runTreeMap.delete($.id);
    else this.runMap.delete($.id);
  }
  _getExecutionOrder($) {
    let q = $ !== void 0 && this.getRunById($);
    if (!q) return 1;
    return q.child_execution_order + 1;
  }
  _createRunForLLMStart($, q, K, P, _, Y, O, z) {
    let J = this._getExecutionOrder(P), T = Date.now(), X = O ? { ..._, metadata: O } : _, f = { id: K, name: z ?? $.id[$.id.length - 1], parent_run_id: P, start_time: T, serialized: $, events: [{ name: "start", time: new Date(T).toISOString() }], inputs: { prompts: q }, execution_order: J, child_runs: [], child_execution_order: J, run_type: "llm", extra: X ?? {}, tags: Y || [] };
    return this._addRunToRunMap(f);
  }
  async handleLLMStart($, q, K, P, _, Y, O, z) {
    let J = this.getRunById(K) ?? this._createRunForLLMStart($, q, K, P, _, Y, O, z);
    return await this.onRunCreate?.(J), await this.onLLMStart?.(J), J;
  }
  _createRunForChatModelStart($, q, K, P, _, Y, O, z) {
    let J = this._getExecutionOrder(P), T = Date.now(), X = O ? { ..._, metadata: O } : _, f = { id: K, name: z ?? $.id[$.id.length - 1], parent_run_id: P, start_time: T, serialized: $, events: [{ name: "start", time: new Date(T).toISOString() }], inputs: { messages: q }, execution_order: J, child_runs: [], child_execution_order: J, run_type: "llm", extra: X ?? {}, tags: Y || [] };
    return this._addRunToRunMap(f);
  }
  async handleChatModelStart($, q, K, P, _, Y, O, z) {
    let J = this.getRunById(K) ?? this._createRunForChatModelStart($, q, K, P, _, Y, O, z);
    return await this.onRunCreate?.(J), await this.onLLMStart?.(J), J;
  }
  async handleLLMEnd($, q, K, P, _) {
    let Y = this.getRunById(q);
    if (!Y || Y?.run_type !== "llm") throw Error("No LLM run to end.");
    return Y.end_time = Date.now(), Y.outputs = $, Y.events.push({ name: "end", time: new Date(Y.end_time).toISOString() }), Y.extra = { ...Y.extra, ..._ }, await this.onLLMEnd?.(Y), await this._endTrace(Y), Y;
  }
  async handleLLMError($, q, K, P, _) {
    let Y = this.getRunById(q);
    if (!Y || Y?.run_type !== "llm") throw Error("No LLM run to end.");
    return Y.end_time = Date.now(), Y.error = this.stringifyError($), Y.events.push({ name: "error", time: new Date(Y.end_time).toISOString() }), Y.extra = { ...Y.extra, ..._ }, await this.onLLMError?.(Y), await this._endTrace(Y), Y;
  }
  _createRunForChainStart($, q, K, P, _, Y, O, z) {
    let J = this._getExecutionOrder(P), T = Date.now(), X = { id: K, name: z ?? $.id[$.id.length - 1], parent_run_id: P, start_time: T, serialized: $, events: [{ name: "start", time: new Date(T).toISOString() }], inputs: q, execution_order: J, child_execution_order: J, run_type: O ?? "chain", child_runs: [], extra: Y ? { metadata: Y } : {}, tags: _ || [] };
    return this._addRunToRunMap(X);
  }
  async handleChainStart($, q, K, P, _, Y, O, z) {
    let J = this.getRunById(K) ?? this._createRunForChainStart($, q, K, P, _, Y, O, z);
    return await this.onRunCreate?.(J), await this.onChainStart?.(J), J;
  }
  async handleChainEnd($, q, K, P, _) {
    let Y = this.getRunById(q);
    if (!Y) throw Error("No chain run to end.");
    if (Y.end_time = Date.now(), Y.outputs = I2($, "output"), Y.events.push({ name: "end", time: new Date(Y.end_time).toISOString() }), _?.inputs !== void 0) Y.inputs = I2(_.inputs, "input");
    return await this.onChainEnd?.(Y), await this._endTrace(Y), Y;
  }
  async handleChainError($, q, K, P, _) {
    let Y = this.getRunById(q);
    if (!Y) throw Error("No chain run to end.");
    if (Y.end_time = Date.now(), Y.error = this.stringifyError($), Y.events.push({ name: "error", time: new Date(Y.end_time).toISOString() }), _?.inputs !== void 0) Y.inputs = I2(_.inputs, "input");
    return await this.onChainError?.(Y), await this._endTrace(Y), Y;
  }
  _createRunForToolStart($, q, K, P, _, Y, O) {
    let z = this._getExecutionOrder(P), J = Date.now(), T = { id: K, name: O ?? $.id[$.id.length - 1], parent_run_id: P, start_time: J, serialized: $, events: [{ name: "start", time: new Date(J).toISOString() }], inputs: { input: q }, execution_order: z, child_execution_order: z, run_type: "tool", child_runs: [], extra: Y ? { metadata: Y } : {}, tags: _ || [] };
    return this._addRunToRunMap(T);
  }
  async handleToolStart($, q, K, P, _, Y, O) {
    let z = this.getRunById(K) ?? this._createRunForToolStart($, q, K, P, _, Y, O);
    return await this.onRunCreate?.(z), await this.onToolStart?.(z), z;
  }
  async handleToolEnd($, q) {
    let K = this.getRunById(q);
    if (!K || K?.run_type !== "tool") throw Error("No tool run to end");
    return K.end_time = Date.now(), K.outputs = { output: $ }, K.events.push({ name: "end", time: new Date(K.end_time).toISOString() }), await this.onToolEnd?.(K), await this._endTrace(K), K;
  }
  async handleToolError($, q) {
    let K = this.getRunById(q);
    if (!K || K?.run_type !== "tool") throw Error("No tool run to end");
    return K.end_time = Date.now(), K.error = this.stringifyError($), K.events.push({ name: "error", time: new Date(K.end_time).toISOString() }), await this.onToolError?.(K), await this._endTrace(K), K;
  }
  async handleAgentAction($, q) {
    let K = this.getRunById(q);
    if (!K || K?.run_type !== "chain") return;
    let P = K;
    P.actions = P.actions || [], P.actions.push($), P.events.push({ name: "agent_action", time: (/* @__PURE__ */ new Date()).toISOString(), kwargs: { action: $ } }), await this.onAgentAction?.(K);
  }
  async handleAgentEnd($, q) {
    let K = this.getRunById(q);
    if (!K || K?.run_type !== "chain") return;
    K.events.push({ name: "agent_end", time: (/* @__PURE__ */ new Date()).toISOString(), kwargs: { action: $ } }), await this.onAgentEnd?.(K);
  }
  _createRunForRetrieverStart($, q, K, P, _, Y, O) {
    let z = this._getExecutionOrder(P), J = Date.now(), T = { id: K, name: O ?? $.id[$.id.length - 1], parent_run_id: P, start_time: J, serialized: $, events: [{ name: "start", time: new Date(J).toISOString() }], inputs: { query: q }, execution_order: z, child_execution_order: z, run_type: "retriever", child_runs: [], extra: Y ? { metadata: Y } : {}, tags: _ || [] };
    return this._addRunToRunMap(T);
  }
  async handleRetrieverStart($, q, K, P, _, Y, O) {
    let z = this.getRunById(K) ?? this._createRunForRetrieverStart($, q, K, P, _, Y, O);
    return await this.onRunCreate?.(z), await this.onRetrieverStart?.(z), z;
  }
  async handleRetrieverEnd($, q) {
    let K = this.getRunById(q);
    if (!K || K?.run_type !== "retriever") throw Error("No retriever run to end");
    return K.end_time = Date.now(), K.outputs = { documents: $ }, K.events.push({ name: "end", time: new Date(K.end_time).toISOString() }), await this.onRetrieverEnd?.(K), await this._endTrace(K), K;
  }
  async handleRetrieverError($, q) {
    let K = this.getRunById(q);
    if (!K || K?.run_type !== "retriever") throw Error("No retriever run to end");
    return K.end_time = Date.now(), K.error = this.stringifyError($), K.events.push({ name: "error", time: new Date(K.end_time).toISOString() }), await this.onRetrieverError?.(K), await this._endTrace(K), K;
  }
  async handleText($, q) {
    let K = this.getRunById(q);
    if (!K || K?.run_type !== "chain") return;
    K.events.push({ name: "text", time: (/* @__PURE__ */ new Date()).toISOString(), kwargs: { text: $ } }), await this.onText?.(K);
  }
  async handleLLMNewToken($, q, K, P, _, Y) {
    let O = this.getRunById(K);
    if (!O || O?.run_type !== "llm") throw Error('Invalid "runId" provided to "handleLLMNewToken" callback.');
    return O.events.push({ name: "new_token", time: (/* @__PURE__ */ new Date()).toISOString(), kwargs: { token: $, idx: q, chunk: Y?.chunk } }), await this.onLLMNewToken?.(O, $, { chunk: Y?.chunk }), O;
  }
}, __name(_a11, "E8"), _a11);
var L2 = K8(jX(), 1);
var uR = {};
Z6(uR, { ConsoleCallbackHandler: /* @__PURE__ */ __name(() => Q1, "ConsoleCallbackHandler") });
function yq($, q) {
  return `${$.open}${q}${$.close}`;
}
__name(yq, "yq");
function w8($, q) {
  try {
    return JSON.stringify($, null, 2);
  } catch {
    return q;
  }
}
__name(w8, "w8");
function vX($) {
  if (typeof $ === "string") return $.trim();
  if ($ === null || $ === void 0) return $;
  return w8($, $.toString());
}
__name(vX, "vX");
function xK($) {
  if (!$.end_time) return "";
  let q = $.end_time - $.start_time;
  if (q < 1e3) return `${q}ms`;
  return `${(q / 1e3).toFixed(2)}s`;
}
__name(xK, "xK");
var { color: Bq } = L2.default;
var _a12;
var Q1 = (_a12 = class extends E8 {
  name = "console_callback_handler";
  persistRun($) {
    return Promise.resolve();
  }
  getParents($) {
    let q = [], K = $;
    while (K.parent_run_id) {
      let P = this.runMap.get(K.parent_run_id);
      if (P) q.push(P), K = P;
      else break;
    }
    return q;
  }
  getBreadcrumbs($) {
    let K = [...this.getParents($).reverse(), $].map((P, _, Y) => {
      let O = `${P.execution_order}:${P.run_type}:${P.name}`;
      return _ === Y.length - 1 ? yq(L2.default.bold, O) : O;
    }).join(" > ");
    return yq(Bq.grey, K);
  }
  onChainStart($) {
    let q = this.getBreadcrumbs($);
    console.log(`${yq(Bq.green, "[chain/start]")} [${q}] Entering Chain run with input: ${w8($.inputs, "[inputs]")}`);
  }
  onChainEnd($) {
    let q = this.getBreadcrumbs($);
    console.log(`${yq(Bq.cyan, "[chain/end]")} [${q}] [${xK($)}] Exiting Chain run with output: ${w8($.outputs, "[outputs]")}`);
  }
  onChainError($) {
    let q = this.getBreadcrumbs($);
    console.log(`${yq(Bq.red, "[chain/error]")} [${q}] [${xK($)}] Chain run errored with error: ${w8($.error, "[error]")}`);
  }
  onLLMStart($) {
    let q = this.getBreadcrumbs($), K = "prompts" in $.inputs ? { prompts: $.inputs.prompts.map((P) => P.trim()) } : $.inputs;
    console.log(`${yq(Bq.green, "[llm/start]")} [${q}] Entering LLM run with input: ${w8(K, "[inputs]")}`);
  }
  onLLMEnd($) {
    let q = this.getBreadcrumbs($);
    console.log(`${yq(Bq.cyan, "[llm/end]")} [${q}] [${xK($)}] Exiting LLM run with output: ${w8($.outputs, "[response]")}`);
  }
  onLLMError($) {
    let q = this.getBreadcrumbs($);
    console.log(`${yq(Bq.red, "[llm/error]")} [${q}] [${xK($)}] LLM run errored with error: ${w8($.error, "[error]")}`);
  }
  onToolStart($) {
    let q = this.getBreadcrumbs($);
    console.log(`${yq(Bq.green, "[tool/start]")} [${q}] Entering Tool run with input: "${vX($.inputs.input)}"`);
  }
  onToolEnd($) {
    let q = this.getBreadcrumbs($);
    console.log(`${yq(Bq.cyan, "[tool/end]")} [${q}] [${xK($)}] Exiting Tool run with output: "${vX($.outputs?.output)}"`);
  }
  onToolError($) {
    let q = this.getBreadcrumbs($);
    console.log(`${yq(Bq.red, "[tool/error]")} [${q}] [${xK($)}] Tool run errored with error: ${w8($.error, "[error]")}`);
  }
  onRetrieverStart($) {
    let q = this.getBreadcrumbs($);
    console.log(`${yq(Bq.green, "[retriever/start]")} [${q}] Entering Retriever run with input: ${w8($.inputs, "[inputs]")}`);
  }
  onRetrieverEnd($) {
    let q = this.getBreadcrumbs($);
    console.log(`${yq(Bq.cyan, "[retriever/end]")} [${q}] [${xK($)}] Exiting Retriever run with output: ${w8($.outputs, "[outputs]")}`);
  }
  onRetrieverError($) {
    let q = this.getBreadcrumbs($);
    console.log(`${yq(Bq.red, "[retriever/error]")} [${q}] [${xK($)}] Retriever run errored with error: ${w8($.error, "[error]")}`);
  }
  onAgentAction($) {
    let q = $, K = this.getBreadcrumbs($);
    console.log(`${yq(Bq.blue, "[agent/action]")} [${K}] Agent selected action: ${w8(q.actions[q.actions.length - 1], "[action]")}`);
  }
}, __name(_a12, "Q1"), _a12);
var g2;
var e1 = /* @__PURE__ */ __name(() => {
  if (g2 === void 0) {
    let $ = N8("LANGCHAIN_CALLBACKS_BACKGROUND") === "false" ? { blockOnRootRunFinalization: true } : {};
    g2 = new uK($);
  }
  return g2;
}, "e1");
var _zX = class _zX {
  getStore() {
    return;
  }
  run($, q) {
    return q();
  }
};
__name(_zX, "zX");
var zX = _zX;
var b2 = Symbol.for("ls:tracing_async_local_storage");
var xR = new zX();
var _WX = class _WX {
  getInstance() {
    return globalThis[b2] ?? xR;
  }
  initializeGlobalInstance($) {
    if (globalThis[b2] === void 0) globalThis[b2] = $;
  }
};
__name(_WX, "WX");
var WX = _WX;
var pR = new WX();
function HX($ = false) {
  let q = pR.getInstance().getStore();
  if (!$ && q === void 0) throw Error(`Could not get the current run tree.

Please make sure you are calling this method within a traceable function and that tracing is enabled.`);
  return q;
}
__name(HX, "HX");
function s1($) {
  return typeof $ === "function" && "langsmith:traceable" in $;
}
__name(s1, "s1");
var cR = {};
Z6(cR, { LangChainTracer: /* @__PURE__ */ __name(() => GP, "LangChainTracer") });
var _a13;
var GP = (_a13 = class extends E8 {
  name = "langchain_tracer";
  projectName;
  exampleId;
  client;
  replicas;
  usesRunTreeMap = true;
  constructor(q = {}) {
    super(q);
    let { exampleId: K, projectName: P, client: _, replicas: Y } = q;
    this.projectName = P ?? WP(), this.replicas = Y, this.exampleId = K, this.client = _ ?? e1();
    let O = _a13.getTraceableRunTree();
    if (O) this.updateFromRunTree(O);
  }
  async persistRun(q) {
  }
  async onRunCreate(q) {
    await this.getRunTreeWithTracingConfig(q.id)?.postRun();
  }
  async onRunUpdate(q) {
    await this.getRunTreeWithTracingConfig(q.id)?.patchRun();
  }
  getRun(q) {
    return this.runTreeMap.get(q);
  }
  updateFromRunTree(q) {
    this.runTreeMap.set(q.id, q);
    let K = q, P = /* @__PURE__ */ new Set();
    while (K.parent_run) {
      if (P.has(K.id)) break;
      if (P.add(K.id), !K.parent_run) break;
      K = K.parent_run;
    }
    P.clear();
    let _ = [K];
    while (_.length > 0) {
      let Y = _.shift();
      if (!Y || P.has(Y.id)) continue;
      if (P.add(Y.id), this.runTreeMap.set(Y.id, Y), Y.child_runs) _.push(...Y.child_runs);
    }
    this.client = q.client ?? this.client, this.replicas = q.replicas ?? this.replicas, this.projectName = q.project_name ?? this.projectName, this.exampleId = q.reference_example_id ?? this.exampleId;
  }
  getRunTreeWithTracingConfig(q) {
    let K = this.runTreeMap.get(q);
    if (!K) return;
    return new Yq({ ...K, client: this.client, project_name: this.projectName, replicas: this.replicas, reference_example_id: this.exampleId, tracingEnabled: true });
  }
  static getTraceableRunTree() {
    try {
      return HX(true);
    } catch {
      return;
    }
  }
}, __name(_a13, "$"), _a13);
var $9 = K8(D1(), 1);
var H_;
function mR() {
  return new ("default" in $9.default ? $9.default.default : $9.default)({ autoStart: true, concurrency: 1 });
}
__name(mR, "mR");
function dR() {
  if (typeof H_ > "u") H_ = mR();
  return H_;
}
__name(dR, "dR");
async function c6($, q) {
  if (q === true) {
    let K = gK();
    if (K !== void 0) await K.run(void 0, async () => $());
    else await $();
  } else H_ = dR(), H_.add(async () => {
    let K = gK();
    if (K !== void 0) await K.run(void 0, async () => $());
    else await $();
  });
}
__name(c6, "c6");
async function JX() {
  let $ = e1();
  await Promise.allSettled([typeof H_ < "u" ? H_.onIdle() : Promise.resolve(), $.awaitPendingTraceBatches()]);
}
__name(JX, "JX");
var lR = {};
Z6(lR, { awaitAllCallbacks: /* @__PURE__ */ __name(() => JX, "awaitAllCallbacks"), consumeCallback: /* @__PURE__ */ __name(() => c6, "consumeCallback") });
var TX = /* @__PURE__ */ __name(($) => {
  if ($ !== void 0) return $;
  return !!["LANGSMITH_TRACING_V2", "LANGCHAIN_TRACING_V2", "LANGSMITH_TRACING", "LANGCHAIN_TRACING"].find((K) => N8(K) === "true");
}, "TX");
function y2($) {
  let q = gK();
  if (q === void 0) return;
  return q.getStore()?.[LK]?.[$];
}
__name(y2, "y2");
var rR = Symbol("lc:configure_hooks");
var wX = /* @__PURE__ */ __name(() => y2(rR) || [], "wX");
var oR = {};
Z6(oR, { BaseCallbackManager: /* @__PURE__ */ __name(() => fX, "BaseCallbackManager"), BaseRunManager: /* @__PURE__ */ __name(() => VP, "BaseRunManager"), CallbackManager: /* @__PURE__ */ __name(() => jK, "CallbackManager"), CallbackManagerForChainRun: /* @__PURE__ */ __name(() => XX, "CallbackManagerForChainRun"), CallbackManagerForLLMRun: /* @__PURE__ */ __name(() => u2, "CallbackManagerForLLMRun"), CallbackManagerForRetrieverRun: /* @__PURE__ */ __name(() => ZX, "CallbackManagerForRetrieverRun"), CallbackManagerForToolRun: /* @__PURE__ */ __name(() => AX, "CallbackManagerForToolRun"), ensureHandler: /* @__PURE__ */ __name(() => n_, "ensureHandler"), parseCallbackConfigArg: /* @__PURE__ */ __name(() => nR, "parseCallbackConfigArg") });
function nR($) {
  if (!$) return {};
  else if (Array.isArray($) || "name" in $) return { callbacks: $ };
  else return $;
}
__name(nR, "nR");
var _a14;
var fX = (_a14 = class {
  setHandler($) {
    return this.setHandlers([$]);
  }
}, __name(_a14, "fX"), _a14);
var _a15;
var VP = (_a15 = class {
  constructor($, q, K, P, _, Y, O, z) {
    this.runId = $, this.handlers = q, this.inheritableHandlers = K, this.tags = P, this.inheritableTags = _, this.metadata = Y, this.inheritableMetadata = O, this._parentRunId = z;
  }
  get parentRunId() {
    return this._parentRunId;
  }
  async handleText($) {
    await Promise.all(this.handlers.map((q) => c6(async () => {
      try {
        await q.handleText?.($, this.runId, this._parentRunId, this.tags);
      } catch (K) {
        if ((q.raiseError ? console.error : console.warn)(`Error in handler ${q.constructor.name}, handleText: ${K}`), q.raiseError) throw K;
      }
    }, q.awaitHandlers)));
  }
  async handleCustomEvent($, q, K, P, _) {
    await Promise.all(this.handlers.map((Y) => c6(async () => {
      try {
        await Y.handleCustomEvent?.($, q, this.runId, this.tags, this.metadata);
      } catch (O) {
        if ((Y.raiseError ? console.error : console.warn)(`Error in handler ${Y.constructor.name}, handleCustomEvent: ${O}`), Y.raiseError) throw O;
      }
    }, Y.awaitHandlers)));
  }
}, __name(_a15, "VP"), _a15);
var _a16;
var ZX = (_a16 = class extends VP {
  getChild($) {
    let q = new jK(this.runId);
    if (q.setHandlers(this.inheritableHandlers), q.addTags(this.inheritableTags), q.addMetadata(this.inheritableMetadata), $) q.addTags([$], false);
    return q;
  }
  async handleRetrieverEnd($) {
    await Promise.all(this.handlers.map((q) => c6(async () => {
      if (!q.ignoreRetriever) try {
        await q.handleRetrieverEnd?.($, this.runId, this._parentRunId, this.tags);
      } catch (K) {
        if ((q.raiseError ? console.error : console.warn)(`Error in handler ${q.constructor.name}, handleRetriever`), q.raiseError) throw K;
      }
    }, q.awaitHandlers)));
  }
  async handleRetrieverError($) {
    await Promise.all(this.handlers.map((q) => c6(async () => {
      if (!q.ignoreRetriever) try {
        await q.handleRetrieverError?.($, this.runId, this._parentRunId, this.tags);
      } catch (K) {
        if ((q.raiseError ? console.error : console.warn)(`Error in handler ${q.constructor.name}, handleRetrieverError: ${K}`), q.raiseError) throw $;
      }
    }, q.awaitHandlers)));
  }
}, __name(_a16, "ZX"), _a16);
var _a17;
var u2 = (_a17 = class extends VP {
  async handleLLMNewToken($, q, K, P, _, Y) {
    await Promise.all(this.handlers.map((O) => c6(async () => {
      if (!O.ignoreLLM) try {
        await O.handleLLMNewToken?.($, q ?? { prompt: 0, completion: 0 }, this.runId, this._parentRunId, this.tags, Y);
      } catch (z) {
        if ((O.raiseError ? console.error : console.warn)(`Error in handler ${O.constructor.name}, handleLLMNewToken: ${z}`), O.raiseError) throw z;
      }
    }, O.awaitHandlers)));
  }
  async handleLLMError($, q, K, P, _) {
    await Promise.all(this.handlers.map((Y) => c6(async () => {
      if (!Y.ignoreLLM) try {
        await Y.handleLLMError?.($, this.runId, this._parentRunId, this.tags, _);
      } catch (O) {
        if ((Y.raiseError ? console.error : console.warn)(`Error in handler ${Y.constructor.name}, handleLLMError: ${O}`), Y.raiseError) throw O;
      }
    }, Y.awaitHandlers)));
  }
  async handleLLMEnd($, q, K, P, _) {
    await Promise.all(this.handlers.map((Y) => c6(async () => {
      if (!Y.ignoreLLM) try {
        await Y.handleLLMEnd?.($, this.runId, this._parentRunId, this.tags, _);
      } catch (O) {
        if ((Y.raiseError ? console.error : console.warn)(`Error in handler ${Y.constructor.name}, handleLLMEnd: ${O}`), Y.raiseError) throw O;
      }
    }, Y.awaitHandlers)));
  }
}, __name(_a17, "u2"), _a17);
var _a18;
var XX = (_a18 = class extends VP {
  getChild($) {
    let q = new jK(this.runId);
    if (q.setHandlers(this.inheritableHandlers), q.addTags(this.inheritableTags), q.addMetadata(this.inheritableMetadata), $) q.addTags([$], false);
    return q;
  }
  async handleChainError($, q, K, P, _) {
    await Promise.all(this.handlers.map((Y) => c6(async () => {
      if (!Y.ignoreChain) try {
        await Y.handleChainError?.($, this.runId, this._parentRunId, this.tags, _);
      } catch (O) {
        if ((Y.raiseError ? console.error : console.warn)(`Error in handler ${Y.constructor.name}, handleChainError: ${O}`), Y.raiseError) throw O;
      }
    }, Y.awaitHandlers)));
  }
  async handleChainEnd($, q, K, P, _) {
    await Promise.all(this.handlers.map((Y) => c6(async () => {
      if (!Y.ignoreChain) try {
        await Y.handleChainEnd?.($, this.runId, this._parentRunId, this.tags, _);
      } catch (O) {
        if ((Y.raiseError ? console.error : console.warn)(`Error in handler ${Y.constructor.name}, handleChainEnd: ${O}`), Y.raiseError) throw O;
      }
    }, Y.awaitHandlers)));
  }
  async handleAgentAction($) {
    await Promise.all(this.handlers.map((q) => c6(async () => {
      if (!q.ignoreAgent) try {
        await q.handleAgentAction?.($, this.runId, this._parentRunId, this.tags);
      } catch (K) {
        if ((q.raiseError ? console.error : console.warn)(`Error in handler ${q.constructor.name}, handleAgentAction: ${K}`), q.raiseError) throw K;
      }
    }, q.awaitHandlers)));
  }
  async handleAgentEnd($) {
    await Promise.all(this.handlers.map((q) => c6(async () => {
      if (!q.ignoreAgent) try {
        await q.handleAgentEnd?.($, this.runId, this._parentRunId, this.tags);
      } catch (K) {
        if ((q.raiseError ? console.error : console.warn)(`Error in handler ${q.constructor.name}, handleAgentEnd: ${K}`), q.raiseError) throw K;
      }
    }, q.awaitHandlers)));
  }
}, __name(_a18, "XX"), _a18);
var _a19;
var AX = (_a19 = class extends VP {
  getChild($) {
    let q = new jK(this.runId);
    if (q.setHandlers(this.inheritableHandlers), q.addTags(this.inheritableTags), q.addMetadata(this.inheritableMetadata), $) q.addTags([$], false);
    return q;
  }
  async handleToolError($) {
    await Promise.all(this.handlers.map((q) => c6(async () => {
      if (!q.ignoreAgent) try {
        await q.handleToolError?.($, this.runId, this._parentRunId, this.tags);
      } catch (K) {
        if ((q.raiseError ? console.error : console.warn)(`Error in handler ${q.constructor.name}, handleToolError: ${K}`), q.raiseError) throw K;
      }
    }, q.awaitHandlers)));
  }
  async handleToolEnd($) {
    await Promise.all(this.handlers.map((q) => c6(async () => {
      if (!q.ignoreAgent) try {
        await q.handleToolEnd?.($, this.runId, this._parentRunId, this.tags);
      } catch (K) {
        if ((q.raiseError ? console.error : console.warn)(`Error in handler ${q.constructor.name}, handleToolEnd: ${K}`), q.raiseError) throw K;
      }
    }, q.awaitHandlers)));
  }
}, __name(_a19, "AX"), _a19);
var _a20;
var jK = (_a20 = class extends fX {
  handlers = [];
  inheritableHandlers = [];
  tags = [];
  inheritableTags = [];
  metadata = {};
  inheritableMetadata = {};
  name = "callback_manager";
  _parentRunId;
  constructor(q, K) {
    super();
    this.handlers = K?.handlers ?? this.handlers, this.inheritableHandlers = K?.inheritableHandlers ?? this.inheritableHandlers, this.tags = K?.tags ?? this.tags, this.inheritableTags = K?.inheritableTags ?? this.inheritableTags, this.metadata = K?.metadata ?? this.metadata, this.inheritableMetadata = K?.inheritableMetadata ?? this.inheritableMetadata, this._parentRunId = q;
  }
  getParentRunId() {
    return this._parentRunId;
  }
  async handleLLMStart(q, K, P = void 0, _ = void 0, Y = void 0, O = void 0, z = void 0, J = void 0) {
    return Promise.all(K.map(async (T, X) => {
      let f = X === 0 && P ? P : iq();
      return await Promise.all(this.handlers.map((V) => {
        if (V.ignoreLLM) return;
        if (W_(V)) V._createRunForLLMStart(q, [T], f, this._parentRunId, Y, this.tags, this.metadata, J);
        return c6(async () => {
          try {
            await V.handleLLMStart?.(q, [T], f, this._parentRunId, Y, this.tags, this.metadata, J);
          } catch (M) {
            if ((V.raiseError ? console.error : console.warn)(`Error in handler ${V.constructor.name}, handleLLMStart: ${M}`), V.raiseError) throw M;
          }
        }, V.awaitHandlers);
      })), new u2(f, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);
    }));
  }
  async handleChatModelStart(q, K, P = void 0, _ = void 0, Y = void 0, O = void 0, z = void 0, J = void 0) {
    return Promise.all(K.map(async (T, X) => {
      let f = X === 0 && P ? P : iq();
      return await Promise.all(this.handlers.map((V) => {
        if (V.ignoreLLM) return;
        if (W_(V)) V._createRunForChatModelStart(q, [T], f, this._parentRunId, Y, this.tags, this.metadata, J);
        return c6(async () => {
          try {
            if (V.handleChatModelStart) await V.handleChatModelStart?.(q, [T], f, this._parentRunId, Y, this.tags, this.metadata, J);
            else if (V.handleLLMStart) {
              let M = bT(T);
              await V.handleLLMStart?.(q, [M], f, this._parentRunId, Y, this.tags, this.metadata, J);
            }
          } catch (M) {
            if ((V.raiseError ? console.error : console.warn)(`Error in handler ${V.constructor.name}, handleLLMStart: ${M}`), V.raiseError) throw M;
          }
        }, V.awaitHandlers);
      })), new u2(f, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);
    }));
  }
  async handleChainStart(q, K, P = iq(), _ = void 0, Y = void 0, O = void 0, z = void 0) {
    return await Promise.all(this.handlers.map((J) => {
      if (J.ignoreChain) return;
      if (W_(J)) J._createRunForChainStart(q, K, P, this._parentRunId, this.tags, this.metadata, _, z);
      return c6(async () => {
        try {
          await J.handleChainStart?.(q, K, P, this._parentRunId, this.tags, this.metadata, _, z);
        } catch (T) {
          if ((J.raiseError ? console.error : console.warn)(`Error in handler ${J.constructor.name}, handleChainStart: ${T}`), J.raiseError) throw T;
        }
      }, J.awaitHandlers);
    })), new XX(P, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);
  }
  async handleToolStart(q, K, P = iq(), _ = void 0, Y = void 0, O = void 0, z = void 0) {
    return await Promise.all(this.handlers.map((J) => {
      if (J.ignoreAgent) return;
      if (W_(J)) J._createRunForToolStart(q, K, P, this._parentRunId, this.tags, this.metadata, z);
      return c6(async () => {
        try {
          await J.handleToolStart?.(q, K, P, this._parentRunId, this.tags, this.metadata, z);
        } catch (T) {
          if ((J.raiseError ? console.error : console.warn)(`Error in handler ${J.constructor.name}, handleToolStart: ${T}`), J.raiseError) throw T;
        }
      }, J.awaitHandlers);
    })), new AX(P, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);
  }
  async handleRetrieverStart(q, K, P = iq(), _ = void 0, Y = void 0, O = void 0, z = void 0) {
    return await Promise.all(this.handlers.map((J) => {
      if (J.ignoreRetriever) return;
      if (W_(J)) J._createRunForRetrieverStart(q, K, P, this._parentRunId, this.tags, this.metadata, z);
      return c6(async () => {
        try {
          await J.handleRetrieverStart?.(q, K, P, this._parentRunId, this.tags, this.metadata, z);
        } catch (T) {
          if ((J.raiseError ? console.error : console.warn)(`Error in handler ${J.constructor.name}, handleRetrieverStart: ${T}`), J.raiseError) throw T;
        }
      }, J.awaitHandlers);
    })), new ZX(P, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);
  }
  async handleCustomEvent(q, K, P, _, Y) {
    await Promise.all(this.handlers.map((O) => c6(async () => {
      if (!O.ignoreCustomEvent) try {
        await O.handleCustomEvent?.(q, K, P, this.tags, this.metadata);
      } catch (z) {
        if ((O.raiseError ? console.error : console.warn)(`Error in handler ${O.constructor.name}, handleCustomEvent: ${z}`), O.raiseError) throw z;
      }
    }, O.awaitHandlers)));
  }
  addHandler(q, K = true) {
    if (this.handlers.push(q), K) this.inheritableHandlers.push(q);
  }
  removeHandler(q) {
    this.handlers = this.handlers.filter((K) => K !== q), this.inheritableHandlers = this.inheritableHandlers.filter((K) => K !== q);
  }
  setHandlers(q, K = true) {
    this.handlers = [], this.inheritableHandlers = [];
    for (let P of q) this.addHandler(P, K);
  }
  addTags(q, K = true) {
    if (this.removeTags(q), this.tags.push(...q), K) this.inheritableTags.push(...q);
  }
  removeTags(q) {
    this.tags = this.tags.filter((K) => !q.includes(K)), this.inheritableTags = this.inheritableTags.filter((K) => !q.includes(K));
  }
  addMetadata(q, K = true) {
    if (this.metadata = { ...this.metadata, ...q }, K) this.inheritableMetadata = { ...this.inheritableMetadata, ...q };
  }
  removeMetadata(q) {
    for (let K of Object.keys(q)) delete this.metadata[K], delete this.inheritableMetadata[K];
  }
  copy(q = [], K = true) {
    let P = new _a20(this._parentRunId);
    for (let _ of this.handlers) {
      let Y = this.inheritableHandlers.includes(_);
      P.addHandler(_, Y);
    }
    for (let _ of this.tags) {
      let Y = this.inheritableTags.includes(_);
      P.addTags([_], Y);
    }
    for (let _ of Object.keys(this.metadata)) {
      let Y = Object.keys(this.inheritableMetadata).includes(_);
      P.addMetadata({ [_]: this.metadata[_] }, Y);
    }
    for (let _ of q) {
      if (P.handlers.filter((Y) => Y.name === "console_callback_handler").some((Y) => Y.name === _.name)) continue;
      P.addHandler(_, K);
    }
    return P;
  }
  static fromHandlers(q) {
    const _K2 = class _K2 extends Y_ {
      name = iq();
      constructor() {
        super();
        Object.assign(this, q);
      }
    };
    __name(_K2, "K");
    let K = _K2;
    let P = new this();
    return P.addHandler(new K()), P;
  }
  static configure(q, K, P, _, Y, O, z) {
    return this._configureSync(q, K, P, _, Y, O, z);
  }
  static _configureSync(q, K, P, _, Y, O, z) {
    let J;
    if (q || K) {
      if (Array.isArray(q) || !q) J = new _a20(), J.setHandlers(q?.map(n_) ?? [], true);
      else J = q;
      J = J.copy(Array.isArray(K) ? K.map(n_) : K?.handlers, false);
    }
    let T = N8("LANGCHAIN_VERBOSE") === "true" || z?.verbose, X = GP.getTraceableRunTree()?.tracingEnabled || TX(), f = X || (N8("LANGCHAIN_TRACING") ?? false);
    if (T || f) {
      if (!J) J = new _a20();
      if (T && !J.handlers.some((V) => V.name === Q1.prototype.name)) {
        let V = new Q1();
        J.addHandler(V, true);
      }
      if (f && !J.handlers.some((V) => V.name === "langchain_tracer")) {
        if (X) {
          let V = new GP();
          J.addHandler(V, true);
        }
      }
      if (X) {
        let V = GP.getTraceableRunTree();
        if (V && J._parentRunId === void 0) J._parentRunId = V.id, J.handlers.find((N) => N.name === "langchain_tracer")?.updateFromRunTree(V);
      }
    }
    for (let { contextVar: V, inheritable: M = true, handlerClass: N, envVar: E } of wX()) {
      let h = E && N8(E) === "true" && N, I, D = V !== void 0 ? y2(V) : void 0;
      if (D && oO(D)) I = D;
      else if (h) I = new N({});
      if (I !== void 0) {
        if (!J) J = new _a20();
        if (!J.handlers.some((g) => g.name === I.name)) J.addHandler(I, M);
      }
    }
    if (P || _) {
      if (J) J.addTags(P ?? []), J.addTags(_ ?? [], false);
    }
    if (Y || O) {
      if (J) J.addMetadata(Y ?? {}), J.addMetadata(O ?? {}, false);
    }
    return J;
  }
}, __name(_a20, "$"), _a20);
function n_($) {
  if ("name" in $) return $;
  return Y_.fromMethods($);
}
__name(n_, "n_");
var _a21;
var x2 = (_a21 = class {
  getStore() {
    return;
  }
  run($, q) {
    return q();
  }
  enterWith($) {
    return;
  }
}, __name(_a21, "x2"), _a21);
var iR = new x2();
var kX = Symbol.for("lc:child_config");
var _a22;
var tR = (_a22 = class {
  getInstance() {
    return gK() ?? iR;
  }
  getRunnableConfig() {
    return this.getInstance().getStore()?.extra?.[kX];
  }
  runWithConfig($, q, K) {
    let P = jK._configureSync($?.callbacks, void 0, $?.tags, void 0, $?.metadata), _ = this.getInstance(), Y = _.getStore(), O = P?.getParentRunId(), z = P?.handlers?.find((T) => T?.name === "langchain_tracer"), J;
    if (z && O) J = z.getRunTreeWithTracingConfig(O);
    else if (!K) J = new Yq({ name: "<runnable_lambda>", tracingEnabled: false });
    if (J) J.extra = { ...J.extra, [kX]: $ };
    if (Y !== void 0 && Y[LK] !== void 0) {
      if (J === void 0) J = {};
      J[LK] = Y[LK];
    }
    return _.run(J, q);
  }
  initializeGlobalInstance($) {
    if (gK() === void 0) _T($);
  }
}, __name(_a22, "tR"), _a22);
var Uq = new tR();
var BR = {};
Z6(BR, { AsyncLocalStorageProviderSingleton: /* @__PURE__ */ __name(() => Uq, "AsyncLocalStorageProviderSingleton"), MockAsyncLocalStorage: /* @__PURE__ */ __name(() => x2, "MockAsyncLocalStorage"), _CONTEXT_VARIABLES_KEY: /* @__PURE__ */ __name(() => LK, "_CONTEXT_VARIABLES_KEY") });
var q9 = 25;
async function f8($) {
  return jK._configureSync($?.callbacks, void 0, $?.tags, void 0, $?.metadata);
}
__name(f8, "f8");
function p2(...$) {
  let q = {};
  for (let K of $.filter((P) => !!P)) for (let P of Object.keys(K)) if (P === "metadata") q[P] = { ...q[P], ...K[P] };
  else if (P === "tags") {
    let _ = q[P] ?? [];
    q[P] = [...new Set(_.concat(K[P] ?? []))];
  } else if (P === "configurable") q[P] = { ...q[P], ...K[P] };
  else if (P === "timeout") {
    if (q.timeout === void 0) q.timeout = K.timeout;
    else if (K.timeout !== void 0) q.timeout = Math.min(q.timeout, K.timeout);
  } else if (P === "signal") {
    if (q.signal === void 0) q.signal = K.signal;
    else if (K.signal !== void 0) if ("any" in AbortSignal) q.signal = AbortSignal.any([q.signal, K.signal]);
    else q.signal = K.signal;
  } else if (P === "callbacks") {
    let _ = q.callbacks, Y = K.callbacks;
    if (Array.isArray(Y)) if (!_) q.callbacks = Y;
    else if (Array.isArray(_)) q.callbacks = _.concat(Y);
    else {
      let O = _.copy();
      for (let z of Y) O.addHandler(n_(z), true);
      q.callbacks = O;
    }
    else if (Y) if (!_) q.callbacks = Y;
    else if (Array.isArray(_)) {
      let O = Y.copy();
      for (let z of _) O.addHandler(n_(z), true);
      q.callbacks = O;
    } else q.callbacks = new jK(Y._parentRunId, { handlers: _.handlers.concat(Y.handlers), inheritableHandlers: _.inheritableHandlers.concat(Y.inheritableHandlers), tags: Array.from(new Set(_.tags.concat(Y.tags))), inheritableTags: Array.from(new Set(_.inheritableTags.concat(Y.inheritableTags))), metadata: { ..._.metadata, ...Y.metadata } });
  } else {
    let _ = P;
    q[_] = K[_] ?? q[_];
  }
  return q;
}
__name(p2, "p2");
var UR = /* @__PURE__ */ new Set(["string", "number", "boolean"]);
function N6($) {
  let q = Uq.getRunnableConfig(), K = { tags: [], metadata: {}, recursionLimit: 25, runId: void 0 };
  if (q) {
    let { runId: P, runName: _, ...Y } = q;
    K = Object.entries(Y).reduce((O, [z, J]) => {
      if (J !== void 0) O[z] = J;
      return O;
    }, K);
  }
  if ($) K = Object.entries($).reduce((P, [_, Y]) => {
    if (Y !== void 0) P[_] = Y;
    return P;
  }, K);
  if (K?.configurable) {
    for (let P of Object.keys(K.configurable)) if (UR.has(typeof K.configurable[P]) && !K.metadata?.[P]) {
      if (!K.metadata) K.metadata = {};
      K.metadata[P] = K.configurable[P];
    }
  }
  if (K.timeout !== void 0) {
    if (K.timeout <= 0) throw Error("Timeout must be a positive number");
    let P = AbortSignal.timeout(K.timeout);
    if (K.signal !== void 0) {
      if ("any" in AbortSignal) K.signal = AbortSignal.any([K.signal, P]);
    } else K.signal = P;
    delete K.timeout;
  }
  return K;
}
__name(N6, "N6");
function Rq($ = {}, { callbacks: q, maxConcurrency: K, recursionLimit: P, runName: _, configurable: Y, runId: O } = {}) {
  let z = N6($);
  if (q !== void 0) delete z.runName, z.callbacks = q;
  if (P !== void 0) z.recursionLimit = P;
  if (K !== void 0) z.maxConcurrency = K;
  if (_ !== void 0) z.runName = _;
  if (Y !== void 0) z.configurable = { ...z.configurable, ...Y };
  if (O !== void 0) delete z.runId;
  return z;
}
__name(Rq, "Rq");
function vK($) {
  if (!$) return;
  return { configurable: $.configurable, recursionLimit: $.recursionLimit, callbacks: $.callbacks, tags: $.tags, metadata: $.metadata, maxConcurrency: $.maxConcurrency, timeout: $.timeout, signal: $.signal, store: $.store };
}
__name(vK, "vK");
async function l8($, q) {
  if (q === void 0) return $;
  let K;
  return Promise.race([$.catch((P) => {
    if (!q?.aborted) throw P;
    else return;
  }), new Promise((P, _) => {
    if (K = /* @__PURE__ */ __name(() => {
      _(i_(q));
    }, "K"), q.addEventListener("abort", K), q.aborted) _(i_(q));
  })]).finally(() => q.removeEventListener("abort", K));
}
__name(l8, "l8");
function i_($) {
  if ($?.reason instanceof Error) return $.reason;
  if (typeof $?.reason === "string") return Error($.reason);
  return Error("Aborted");
}
__name(i_, "i_");
var FR = {};
Z6(FR, { AsyncGeneratorWithSetup: /* @__PURE__ */ __name(() => pK, "AsyncGeneratorWithSetup"), IterableReadableStream: /* @__PURE__ */ __name(() => uq, "IterableReadableStream"), atee: /* @__PURE__ */ __name(() => K9, "atee"), concat: /* @__PURE__ */ __name(() => _9, "concat"), pipeGeneratorWithSetup: /* @__PURE__ */ __name(() => c2, "pipeGeneratorWithSetup") });
var _a23;
var uq = (_a23 = class extends ReadableStream {
  reader;
  ensureReader() {
    if (!this.reader) this.reader = this.getReader();
  }
  async next() {
    this.ensureReader();
    try {
      let q = await this.reader.read();
      if (q.done) return this.reader.releaseLock(), { done: true, value: void 0 };
      else return { done: false, value: q.value };
    } catch (q) {
      throw this.reader.releaseLock(), q;
    }
  }
  async return() {
    if (this.ensureReader(), this.locked) {
      let q = this.reader.cancel();
      this.reader.releaseLock(), await q;
    }
    return { done: true, value: void 0 };
  }
  async throw(q) {
    if (this.ensureReader(), this.locked) {
      let K = this.reader.cancel();
      this.reader.releaseLock(), await K;
    }
    throw q;
  }
  [Symbol.asyncIterator]() {
    return this;
  }
  async [Symbol.asyncDispose]() {
    await this.return();
  }
  static fromReadableStream(q) {
    let K = q.getReader();
    return new _a23({ start(P) {
      return _();
      function _() {
        return K.read().then(({ done: Y, value: O }) => {
          if (Y) {
            P.close();
            return;
          }
          return P.enqueue(O), _();
        });
      }
      __name(_, "_");
    }, cancel() {
      K.releaseLock();
    } });
  }
  static fromAsyncGenerator(q) {
    return new _a23({ async pull(K) {
      let { value: P, done: _ } = await q.next();
      if (_) K.close();
      K.enqueue(P);
    }, async cancel(K) {
      await q.return(K);
    } });
  }
}, __name(_a23, "$"), _a23);
function K9($, q = 2) {
  let K = Array.from({ length: q }, () => []);
  return K.map(async function* (_) {
    while (true) if (_.length === 0) {
      let Y = await $.next();
      for (let O of K) O.push(Y);
    } else if (_[0].done) return;
    else yield _.shift().value;
  });
}
__name(K9, "K9");
function _9($, q) {
  if (Array.isArray($) && Array.isArray(q)) return $.concat(q);
  else if (typeof $ === "string" && typeof q === "string") return $ + q;
  else if (typeof $ === "number" && typeof q === "number") return $ + q;
  else if ("concat" in $ && typeof $.concat === "function") return $.concat(q);
  else if (typeof $ === "object" && typeof q === "object") {
    let K = { ...$ };
    for (let [P, _] of Object.entries(q)) if (P in K && !Array.isArray(K[P])) K[P] = _9(K[P], _);
    else K[P] = _;
    return K;
  } else throw Error(`Cannot concat ${typeof $} and ${typeof q}`);
}
__name(_9, "_9");
var _a24;
var pK = (_a24 = class {
  generator;
  setup;
  config;
  signal;
  firstResult;
  firstResultUsed = false;
  constructor($) {
    this.generator = $.generator, this.config = $.config, this.signal = $.signal ?? this.config?.signal, this.setup = new Promise((q, K) => {
      Uq.runWithConfig(vK($.config), async () => {
        if (this.firstResult = $.generator.next(), $.startSetup) this.firstResult.then($.startSetup).then(q, K);
        else this.firstResult.then((P) => q(void 0), K);
      }, true);
    });
  }
  async next(...$) {
    if (this.signal?.throwIfAborted(), !this.firstResultUsed) return this.firstResultUsed = true, this.firstResult;
    return Uq.runWithConfig(vK(this.config), this.signal ? async () => {
      return l8(this.generator.next(...$), this.signal);
    } : async () => {
      return this.generator.next(...$);
    }, true);
  }
  async return($) {
    return this.generator.return($);
  }
  async throw($) {
    return this.generator.throw($);
  }
  [Symbol.asyncIterator]() {
    return this;
  }
  async [Symbol.asyncDispose]() {
    await this.return();
  }
}, __name(_a24, "pK"), _a24);
async function c2($, q, K, P, ..._) {
  let Y = new pK({ generator: q, startSetup: K, signal: P }), O = await Y.setup;
  return { output: $(Y, O, ..._), setup: O };
}
__name(c2, "c2");
var aR = Object.prototype.hasOwnProperty;
function VX($, q) {
  return aR.call($, q);
}
__name(VX, "VX");
function SX($) {
  if (Array.isArray($)) {
    let K = Array($.length);
    for (let P = 0; P < K.length; P++) K[P] = "" + P;
    return K;
  }
  if (Object.keys) return Object.keys($);
  let q = [];
  for (let K in $) if (VX($, K)) q.push(K);
  return q;
}
__name(SX, "SX");
function R8($) {
  switch (typeof $) {
    case "object":
      return JSON.parse(JSON.stringify($));
    case "undefined":
      return null;
    default:
      return $;
  }
}
__name(R8, "R8");
function O9($) {
  let q = 0, K = $.length, P;
  while (q < K) {
    if (P = $.charCodeAt(q), P >= 48 && P <= 57) {
      q++;
      continue;
    }
    return false;
  }
  return true;
}
__name(O9, "O9");
function m2($) {
  if ($.indexOf("/") === -1 && $.indexOf("~") === -1) return $;
  return $.replace(/~/g, "~0").replace(/\//g, "~1");
}
__name(m2, "m2");
function Y9($) {
  return $.replace(/~1/g, "/").replace(/~0/g, "~");
}
__name(Y9, "Y9");
function P9($) {
  if ($ === void 0) return true;
  if ($) {
    if (Array.isArray($)) {
      for (let K = 0, P = $.length; K < P; K++) if (P9($[K])) return true;
    } else if (typeof $ === "object") {
      let K = SX($), P = K.length;
      for (var q = 0; q < P; q++) if (P9($[K[q]])) return true;
    }
  }
  return false;
}
__name(P9, "P9");
function GX($, q) {
  let K = [$];
  for (let P in q) {
    let _ = typeof q[P] === "object" ? JSON.stringify(q[P], null, 2) : q[P];
    if (typeof _ < "u") K.push(`${P}: ${_}`);
  }
  return K.join(`
`);
}
__name(GX, "GX");
var _a25;
var j9 = (_a25 = class extends Error {
  constructor($, q, K, P, _) {
    super(GX($, { name: q, index: K, operation: P, tree: _ }));
    this.name = q, this.index = K, this.operation = P, this.tree = _, Object.setPrototypeOf(this, new.target.prototype), this.message = GX($, { name: q, index: K, operation: P, tree: _ });
  }
}, __name(_a25, "j9"), _a25);
var d2 = {};
Z6(d2, { JsonPatchError: /* @__PURE__ */ __name(() => m6, "JsonPatchError"), _areEquals: /* @__PURE__ */ __name(() => B_, "_areEquals"), applyOperation: /* @__PURE__ */ __name(() => cK, "applyOperation"), applyPatch: /* @__PURE__ */ __name(() => J_, "applyPatch"), applyReducer: /* @__PURE__ */ __name(() => MX, "applyReducer"), deepClone: /* @__PURE__ */ __name(() => QR, "deepClone"), getValueByPointer: /* @__PURE__ */ __name(() => SP, "getValueByPointer"), validate: /* @__PURE__ */ __name(() => l2, "validate"), validator: /* @__PURE__ */ __name(() => MP, "validator") });
var m6 = j9;
var QR = R8;
var t_ = { add: /* @__PURE__ */ __name(function($, q, K) {
  return $[q] = this.value, { newDocument: K };
}, "add"), remove: /* @__PURE__ */ __name(function($, q, K) {
  var P = $[q];
  return delete $[q], { newDocument: K, removed: P };
}, "remove"), replace: /* @__PURE__ */ __name(function($, q, K) {
  var P = $[q];
  return $[q] = this.value, { newDocument: K, removed: P };
}, "replace"), move: /* @__PURE__ */ __name(function($, q, K) {
  let P = SP(K, this.path);
  if (P) P = R8(P);
  let _ = cK(K, { op: "remove", path: this.from }).removed;
  return cK(K, { op: "add", path: this.path, value: _ }), { newDocument: K, removed: P };
}, "move"), copy: /* @__PURE__ */ __name(function($, q, K) {
  let P = SP(K, this.from);
  return cK(K, { op: "add", path: this.path, value: R8(P) }), { newDocument: K };
}, "copy"), test: /* @__PURE__ */ __name(function($, q, K) {
  return { newDocument: K, test: B_($[q], this.value) };
}, "test"), _get: /* @__PURE__ */ __name(function($, q, K) {
  return this.value = $[q], { newDocument: K };
}, "_get") };
var eR = { add: /* @__PURE__ */ __name(function($, q, K) {
  if (O9(q)) $.splice(q, 0, this.value);
  else $[q] = this.value;
  return { newDocument: K, index: q };
}, "add"), remove: /* @__PURE__ */ __name(function($, q, K) {
  var P = $.splice(q, 1);
  return { newDocument: K, removed: P[0] };
}, "remove"), replace: /* @__PURE__ */ __name(function($, q, K) {
  var P = $[q];
  return $[q] = this.value, { newDocument: K, removed: P };
}, "replace"), move: t_.move, copy: t_.copy, test: t_.test, _get: t_._get };
function SP($, q) {
  if (q == "") return $;
  var K = { op: "_get", path: q };
  return cK($, K), K.value;
}
__name(SP, "SP");
function cK($, q, K = false, P = true, _ = true, Y = 0) {
  if (K) if (typeof K == "function") K(q, 0, $, q.path);
  else MP(q, 0);
  if (q.path === "") {
    let O = { newDocument: $ };
    if (q.op === "add") return O.newDocument = q.value, O;
    else if (q.op === "replace") return O.newDocument = q.value, O.removed = $, O;
    else if (q.op === "move" || q.op === "copy") {
      if (O.newDocument = SP($, q.from), q.op === "move") O.removed = $;
      return O;
    } else if (q.op === "test") {
      if (O.test = B_($, q.value), O.test === false) throw new m6("Test operation failed", "TEST_OPERATION_FAILED", Y, q, $);
      return O.newDocument = $, O;
    } else if (q.op === "remove") return O.removed = $, O.newDocument = null, O;
    else if (q.op === "_get") return q.value = $, O;
    else if (K) throw new m6("Operation `op` property is not one of operations defined in RFC-6902", "OPERATION_OP_INVALID", Y, q, $);
    else return O;
  } else {
    if (!P) $ = R8($);
    let z = (q.path || "").split("/"), J = $, T = 1, X = z.length, f = void 0, V, M;
    if (typeof K == "function") M = K;
    else M = MP;
    while (true) {
      if (V = z[T], V && V.indexOf("~") != -1) V = Y9(V);
      if (_ && (V == "__proto__" || V == "prototype" && T > 0 && z[T - 1] == "constructor")) throw TypeError("JSON-Patch: modifying `__proto__` or `constructor/prototype` prop is banned for security reasons, if this was on purpose, please set `banPrototypeModifications` flag false and pass it to this function. More info in fast-json-patch README");
      if (K) {
        if (f === void 0) {
          if (J[V] === void 0) f = z.slice(0, T).join("/");
          else if (T == X - 1) f = q.path;
          if (f !== void 0) M(q, 0, $, f);
        }
      }
      if (T++, Array.isArray(J)) {
        if (V === "-") V = J.length;
        else if (K && !O9(V)) throw new m6("Expected an unsigned base-10 integer value, making the new referenced value the array element with the zero-based index", "OPERATION_PATH_ILLEGAL_ARRAY_INDEX", Y, q, $);
        else if (O9(V)) V = ~~V;
        if (T >= X) {
          if (K && q.op === "add" && V > J.length) throw new m6("The specified index MUST NOT be greater than the number of elements in the array", "OPERATION_VALUE_OUT_OF_BOUNDS", Y, q, $);
          let N = eR[q.op].call(q, J, V, $);
          if (N.test === false) throw new m6("Test operation failed", "TEST_OPERATION_FAILED", Y, q, $);
          return N;
        }
      } else if (T >= X) {
        let N = t_[q.op].call(q, J, V, $);
        if (N.test === false) throw new m6("Test operation failed", "TEST_OPERATION_FAILED", Y, q, $);
        return N;
      }
      if (J = J[V], K && T < X && (!J || typeof J !== "object")) throw new m6("Cannot perform operation at the desired path", "OPERATION_PATH_UNRESOLVABLE", Y, q, $);
    }
  }
}
__name(cK, "cK");
function J_($, q, K, P = true, _ = true) {
  if (K) {
    if (!Array.isArray(q)) throw new m6("Patch sequence must be an array", "SEQUENCE_NOT_AN_ARRAY");
  }
  if (!P) $ = R8($);
  let Y = Array(q.length);
  for (let O = 0, z = q.length; O < z; O++) Y[O] = cK($, q[O], K, true, _, O), $ = Y[O].newDocument;
  return Y.newDocument = $, Y;
}
__name(J_, "J_");
function MX($, q, K) {
  let P = cK($, q);
  if (P.test === false) throw new m6("Test operation failed", "TEST_OPERATION_FAILED", K, q, $);
  return P.newDocument;
}
__name(MX, "MX");
function MP($, q, K, P) {
  if (typeof $ !== "object" || $ === null || Array.isArray($)) throw new m6("Operation is not an object", "OPERATION_NOT_AN_OBJECT", q, $, K);
  else if (!t_[$.op]) throw new m6("Operation `op` property is not one of operations defined in RFC-6902", "OPERATION_OP_INVALID", q, $, K);
  else if (typeof $.path !== "string") throw new m6("Operation `path` property is not a string", "OPERATION_PATH_INVALID", q, $, K);
  else if ($.path.indexOf("/") !== 0 && $.path.length > 0) throw new m6('Operation `path` property must start with "/"', "OPERATION_PATH_INVALID", q, $, K);
  else if (($.op === "move" || $.op === "copy") && typeof $.from !== "string") throw new m6("Operation `from` property is not present (applicable in `move` and `copy` operations)", "OPERATION_FROM_REQUIRED", q, $, K);
  else if (($.op === "add" || $.op === "replace" || $.op === "test") && $.value === void 0) throw new m6("Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)", "OPERATION_VALUE_REQUIRED", q, $, K);
  else if (($.op === "add" || $.op === "replace" || $.op === "test") && P9($.value)) throw new m6("Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)", "OPERATION_VALUE_CANNOT_CONTAIN_UNDEFINED", q, $, K);
  else if (K) {
    if ($.op == "add") {
      var _ = $.path.split("/").length, Y = P.split("/").length;
      if (_ !== Y + 1 && _ !== Y) throw new m6("Cannot perform an `add` operation at the desired path", "OPERATION_PATH_CANNOT_ADD", q, $, K);
    } else if ($.op === "replace" || $.op === "remove" || $.op === "_get") {
      if ($.path !== P) throw new m6("Cannot perform the operation at a path that does not exist", "OPERATION_PATH_UNRESOLVABLE", q, $, K);
    } else if ($.op === "move" || $.op === "copy") {
      var O = { op: "_get", path: $.from, value: void 0 }, z = l2([O], K);
      if (z && z.name === "OPERATION_PATH_UNRESOLVABLE") throw new m6("Cannot perform the operation from a path that does not exist", "OPERATION_FROM_UNRESOLVABLE", q, $, K);
    }
  }
}
__name(MP, "MP");
function l2($, q, K) {
  try {
    if (!Array.isArray($)) throw new m6("Patch sequence must be an array", "SEQUENCE_NOT_AN_ARRAY");
    if (q) J_(R8(q), R8($), K || true);
    else {
      K = K || MP;
      for (var P = 0; P < $.length; P++) K($[P], P, q, void 0);
    }
  } catch (_) {
    if (_ instanceof m6) return _;
    else throw _;
  }
}
__name(l2, "l2");
function B_($, q) {
  if ($ === q) return true;
  if ($ && q && typeof $ == "object" && typeof q == "object") {
    var K = Array.isArray($), P = Array.isArray(q), _, Y, O;
    if (K && P) {
      if (Y = $.length, Y != q.length) return false;
      for (_ = Y; _-- !== 0; ) if (!B_($[_], q[_])) return false;
      return true;
    }
    if (K != P) return false;
    var z = Object.keys($);
    if (Y = z.length, Y !== Object.keys(q).length) return false;
    for (_ = Y; _-- !== 0; ) if (!q.hasOwnProperty(z[_])) return false;
    for (_ = Y; _-- !== 0; ) if (O = z[_], !B_($[O], q[O])) return false;
    return true;
  }
  return $ !== $ && q !== q;
}
__name(B_, "B_");
var js = { ...d2, JsonPatchError: j9, deepClone: R8, escapePathComponent: m2, unescapePathComponent: Y9 };
var sR = {};
Z6(sR, { LogStreamCallbackHandler: /* @__PURE__ */ __name(() => z9, "LogStreamCallbackHandler"), RunLog: /* @__PURE__ */ __name(() => v9, "RunLog"), RunLogPatch: /* @__PURE__ */ __name(() => r8, "RunLogPatch"), isLogStreamHandler: /* @__PURE__ */ __name(() => r2, "isLogStreamHandler") });
var _a26;
var r8 = (_a26 = class {
  ops;
  constructor($) {
    this.ops = $.ops ?? [];
  }
  concat($) {
    let q = this.ops.concat($.ops), K = J_({}, q);
    return new v9({ ops: q, state: K[K.length - 1].newDocument });
  }
}, __name(_a26, "r8"), _a26);
var _a27;
var v9 = (_a27 = class extends r8 {
  state;
  constructor(q) {
    super(q);
    this.state = q.state;
  }
  concat(q) {
    let K = this.ops.concat(q.ops), P = J_(this.state, q.ops);
    return new _a27({ ops: K, state: P[P.length - 1].newDocument });
  }
  static fromRunLogPatch(q) {
    let K = J_({}, q.ops);
    return new _a27({ ops: q.ops, state: K[K.length - 1].newDocument });
  }
}, __name(_a27, "$"), _a27);
var r2 = /* @__PURE__ */ __name(($) => $.name === "log_stream_tracer", "r2");
async function NX($, q) {
  if (q === "original") throw Error("Do not assign inputs with original schema drop the key for now. When inputs are added to streamLog they should be added with standardized schema for streaming events.");
  let { inputs: K } = $;
  if (["retriever", "llm", "prompt"].includes($.run_type)) return K;
  if (Object.keys(K).length === 1 && K?.input === "") return;
  return K.input;
}
__name(NX, "NX");
async function CX($, q) {
  let { outputs: K } = $;
  if (q === "original") return K;
  if (["retriever", "llm", "prompt"].includes($.run_type)) return K;
  if (K !== void 0 && Object.keys(K).length === 1 && K?.output !== void 0) return K.output;
  return K;
}
__name(CX, "CX");
function $I($) {
  return $ !== void 0 && $.message !== void 0;
}
__name($I, "$I");
var _a28;
var z9 = (_a28 = class extends E8 {
  autoClose = true;
  includeNames;
  includeTypes;
  includeTags;
  excludeNames;
  excludeTypes;
  excludeTags;
  _schemaFormat = "original";
  rootId;
  keyMapByRunId = {};
  counterMapByRunName = {};
  transformStream;
  writer;
  receiveStream;
  name = "log_stream_tracer";
  lc_prefer_streaming = true;
  constructor($) {
    super({ _awaitHandler: true, ...$ });
    this.autoClose = $?.autoClose ?? true, this.includeNames = $?.includeNames, this.includeTypes = $?.includeTypes, this.includeTags = $?.includeTags, this.excludeNames = $?.excludeNames, this.excludeTypes = $?.excludeTypes, this.excludeTags = $?.excludeTags, this._schemaFormat = $?._schemaFormat ?? this._schemaFormat, this.transformStream = new TransformStream(), this.writer = this.transformStream.writable.getWriter(), this.receiveStream = uq.fromReadableStream(this.transformStream.readable);
  }
  [Symbol.asyncIterator]() {
    return this.receiveStream;
  }
  async persistRun($) {
  }
  _includeRun($) {
    if ($.id === this.rootId) return false;
    let q = $.tags ?? [], K = this.includeNames === void 0 && this.includeTags === void 0 && this.includeTypes === void 0;
    if (this.includeNames !== void 0) K = K || this.includeNames.includes($.name);
    if (this.includeTypes !== void 0) K = K || this.includeTypes.includes($.run_type);
    if (this.includeTags !== void 0) K = K || q.find((P) => this.includeTags?.includes(P)) !== void 0;
    if (this.excludeNames !== void 0) K = K && !this.excludeNames.includes($.name);
    if (this.excludeTypes !== void 0) K = K && !this.excludeTypes.includes($.run_type);
    if (this.excludeTags !== void 0) K = K && q.every((P) => !this.excludeTags?.includes(P));
    return K;
  }
  async *tapOutputIterable($, q) {
    for await (let K of q) {
      if ($ !== this.rootId) {
        let P = this.keyMapByRunId[$];
        if (P) await this.writer.write(new r8({ ops: [{ op: "add", path: `/logs/${P}/streamed_output/-`, value: K }] }));
      }
      yield K;
    }
  }
  async onRunCreate($) {
    if (this.rootId === void 0) this.rootId = $.id, await this.writer.write(new r8({ ops: [{ op: "replace", path: "", value: { id: $.id, name: $.name, type: $.run_type, streamed_output: [], final_output: void 0, logs: {} } }] }));
    if (!this._includeRun($)) return;
    if (this.counterMapByRunName[$.name] === void 0) this.counterMapByRunName[$.name] = 0;
    this.counterMapByRunName[$.name] += 1;
    let q = this.counterMapByRunName[$.name];
    this.keyMapByRunId[$.id] = q === 1 ? $.name : `${$.name}:${q}`;
    let K = { id: $.id, name: $.name, type: $.run_type, tags: $.tags ?? [], metadata: $.extra?.metadata ?? {}, start_time: new Date($.start_time).toISOString(), streamed_output: [], streamed_output_str: [], final_output: void 0, end_time: void 0 };
    if (this._schemaFormat === "streaming_events") K.inputs = await NX($, this._schemaFormat);
    await this.writer.write(new r8({ ops: [{ op: "add", path: `/logs/${this.keyMapByRunId[$.id]}`, value: K }] }));
  }
  async onRunUpdate($) {
    try {
      let q = this.keyMapByRunId[$.id];
      if (q === void 0) return;
      let K = [];
      if (this._schemaFormat === "streaming_events") K.push({ op: "replace", path: `/logs/${q}/inputs`, value: await NX($, this._schemaFormat) });
      if (K.push({ op: "add", path: `/logs/${q}/final_output`, value: await CX($, this._schemaFormat) }), $.end_time !== void 0) K.push({ op: "add", path: `/logs/${q}/end_time`, value: new Date($.end_time).toISOString() });
      let P = new r8({ ops: K });
      await this.writer.write(P);
    } finally {
      if ($.id === this.rootId) {
        let q = new r8({ ops: [{ op: "replace", path: "/final_output", value: await CX($, this._schemaFormat) }] });
        if (await this.writer.write(q), this.autoClose) await this.writer.close();
      }
    }
  }
  async onLLMNewToken($, q, K) {
    let P = this.keyMapByRunId[$.id];
    if (P === void 0) return;
    let _ = $.inputs.messages !== void 0, Y;
    if (_) if ($I(K?.chunk)) Y = K?.chunk;
    else Y = new YP({ id: `run-${$.id}`, content: q });
    else Y = q;
    let O = new r8({ ops: [{ op: "add", path: `/logs/${P}/streamed_output_str/-`, value: q }, { op: "add", path: `/logs/${P}/streamed_output/-`, value: Y }] });
    await this.writer.write(O);
  }
}, __name(_a28, "z9"), _a28);
var qI = {};
Z6(qI, { ChatGenerationChunk: /* @__PURE__ */ __name(() => _I, "ChatGenerationChunk"), GenerationChunk: /* @__PURE__ */ __name(() => NP, "GenerationChunk"), RUN_KEY: /* @__PURE__ */ __name(() => KI, "RUN_KEY") });
var KI = "__run";
var _a29;
var NP = (_a29 = class {
  text;
  generationInfo;
  constructor(q) {
    this.text = q.text, this.generationInfo = q.generationInfo;
  }
  concat(q) {
    return new _a29({ text: this.text + q.text, generationInfo: { ...this.generationInfo, ...q.generationInfo } });
  }
}, __name(_a29, "$"), _a29);
var _a30;
var _I = (_a30 = class extends NP {
  message;
  constructor(q) {
    super(q);
    this.message = q.message;
  }
  concat(q) {
    return new _a30({ text: this.text + q.text, generationInfo: { ...this.generationInfo, ...q.generationInfo }, message: this.message.concat(q.message) });
  }
}, __name(_a30, "$"), _a30);
function W9({ name: $, serialized: q }) {
  if ($ !== void 0) return $;
  if (q?.name !== void 0) return q.name;
  else if (q?.id !== void 0 && Array.isArray(q?.id)) return q.id[q.id.length - 1];
  return "Unnamed";
}
__name(W9, "W9");
var hX = /* @__PURE__ */ __name(($) => $.name === "event_stream_tracer", "hX");
var _a31;
var EX = (_a31 = class extends E8 {
  autoClose = true;
  includeNames;
  includeTypes;
  includeTags;
  excludeNames;
  excludeTypes;
  excludeTags;
  runInfoMap = /* @__PURE__ */ new Map();
  tappedPromises = /* @__PURE__ */ new Map();
  transformStream;
  writer;
  receiveStream;
  name = "event_stream_tracer";
  lc_prefer_streaming = true;
  constructor($) {
    super({ _awaitHandler: true, ...$ });
    this.autoClose = $?.autoClose ?? true, this.includeNames = $?.includeNames, this.includeTypes = $?.includeTypes, this.includeTags = $?.includeTags, this.excludeNames = $?.excludeNames, this.excludeTypes = $?.excludeTypes, this.excludeTags = $?.excludeTags, this.transformStream = new TransformStream(), this.writer = this.transformStream.writable.getWriter(), this.receiveStream = uq.fromReadableStream(this.transformStream.readable);
  }
  [Symbol.asyncIterator]() {
    return this.receiveStream;
  }
  async persistRun($) {
  }
  _includeRun($) {
    let q = $.tags ?? [], K = this.includeNames === void 0 && this.includeTags === void 0 && this.includeTypes === void 0;
    if (this.includeNames !== void 0) K = K || this.includeNames.includes($.name);
    if (this.includeTypes !== void 0) K = K || this.includeTypes.includes($.runType);
    if (this.includeTags !== void 0) K = K || q.find((P) => this.includeTags?.includes(P)) !== void 0;
    if (this.excludeNames !== void 0) K = K && !this.excludeNames.includes($.name);
    if (this.excludeTypes !== void 0) K = K && !this.excludeTypes.includes($.runType);
    if (this.excludeTags !== void 0) K = K && q.every((P) => !this.excludeTags?.includes(P));
    return K;
  }
  async *tapOutputIterable($, q) {
    let K = await q.next();
    if (K.done) return;
    let P = this.runInfoMap.get($);
    if (P === void 0) {
      yield K.value;
      return;
    }
    function _(O, z) {
      if (O === "llm" && typeof z === "string") return new NP({ text: z });
      return z;
    }
    __name(_, "_");
    let Y = this.tappedPromises.get($);
    if (Y === void 0) {
      let O;
      Y = new Promise((z) => {
        O = z;
      }), this.tappedPromises.set($, Y);
      try {
        let z = { event: `on_${P.runType}_stream`, run_id: $, name: P.name, tags: P.tags, metadata: P.metadata, data: {} };
        await this.send({ ...z, data: { chunk: _(P.runType, K.value) } }, P), yield K.value;
        for await (let J of q) {
          if (P.runType !== "tool" && P.runType !== "retriever") await this.send({ ...z, data: { chunk: _(P.runType, J) } }, P);
          yield J;
        }
      } finally {
        O?.();
      }
    } else {
      yield K.value;
      for await (let O of q) yield O;
    }
  }
  async send($, q) {
    if (this._includeRun(q)) await this.writer.write($);
  }
  async sendEndEvent($, q) {
    let K = this.tappedPromises.get($.run_id);
    if (K !== void 0) K.then(() => {
      this.send($, q);
    });
    else await this.send($, q);
  }
  async onLLMStart($) {
    let q = W9($), K = $.inputs.messages !== void 0 ? "chat_model" : "llm", P = { tags: $.tags ?? [], metadata: $.extra?.metadata ?? {}, name: q, runType: K, inputs: $.inputs };
    this.runInfoMap.set($.id, P);
    let _ = `on_${K}_start`;
    await this.send({ event: _, data: { input: $.inputs }, name: q, tags: $.tags ?? [], run_id: $.id, metadata: $.extra?.metadata ?? {} }, P);
  }
  async onLLMNewToken($, q, K) {
    let P = this.runInfoMap.get($.id), _, Y;
    if (P === void 0) throw Error(`onLLMNewToken: Run ID ${$.id} not found in run map.`);
    if (this.runInfoMap.size === 1) return;
    if (P.runType === "chat_model") if (Y = "on_chat_model_stream", K?.chunk === void 0) _ = new YP({ content: q, id: `run-${$.id}` });
    else _ = K.chunk.message;
    else if (P.runType === "llm") if (Y = "on_llm_stream", K?.chunk === void 0) _ = new NP({ text: q });
    else _ = K.chunk;
    else throw Error(`Unexpected run type ${P.runType}`);
    await this.send({ event: Y, data: { chunk: _ }, run_id: $.id, name: P.name, tags: P.tags, metadata: P.metadata }, P);
  }
  async onLLMEnd($) {
    let q = this.runInfoMap.get($.id);
    this.runInfoMap.delete($.id);
    let K;
    if (q === void 0) throw Error(`onLLMEnd: Run ID ${$.id} not found in run map.`);
    let P = $.outputs?.generations, _;
    if (q.runType === "chat_model") {
      for (let Y of P ?? []) {
        if (_ !== void 0) break;
        _ = Y[0]?.message;
      }
      K = "on_chat_model_end";
    } else if (q.runType === "llm") _ = { generations: P?.map((Y) => {
      return Y.map((O) => {
        return { text: O.text, generationInfo: O.generationInfo };
      });
    }), llmOutput: $.outputs?.llmOutput ?? {} }, K = "on_llm_end";
    else throw Error(`onLLMEnd: Unexpected run type: ${q.runType}`);
    await this.sendEndEvent({ event: K, data: { output: _, input: q.inputs }, run_id: $.id, name: q.name, tags: q.tags, metadata: q.metadata }, q);
  }
  async onChainStart($) {
    let q = W9($), K = $.run_type ?? "chain", P = { tags: $.tags ?? [], metadata: $.extra?.metadata ?? {}, name: q, runType: $.run_type }, _ = {};
    if ($.inputs.input === "" && Object.keys($.inputs).length === 1) _ = {}, P.inputs = {};
    else if ($.inputs.input !== void 0) _.input = $.inputs.input, P.inputs = $.inputs.input;
    else _.input = $.inputs, P.inputs = $.inputs;
    this.runInfoMap.set($.id, P), await this.send({ event: `on_${K}_start`, data: _, name: q, tags: $.tags ?? [], run_id: $.id, metadata: $.extra?.metadata ?? {} }, P);
  }
  async onChainEnd($) {
    let q = this.runInfoMap.get($.id);
    if (this.runInfoMap.delete($.id), q === void 0) throw Error(`onChainEnd: Run ID ${$.id} not found in run map.`);
    let K = `on_${$.run_type}_end`, P = $.inputs ?? q.inputs ?? {}, Y = { output: $.outputs?.output ?? $.outputs, input: P };
    if (P.input && Object.keys(P).length === 1) Y.input = P.input, q.inputs = P.input;
    await this.sendEndEvent({ event: K, data: Y, run_id: $.id, name: q.name, tags: q.tags, metadata: q.metadata ?? {} }, q);
  }
  async onToolStart($) {
    let q = W9($), K = { tags: $.tags ?? [], metadata: $.extra?.metadata ?? {}, name: q, runType: "tool", inputs: $.inputs ?? {} };
    this.runInfoMap.set($.id, K), await this.send({ event: "on_tool_start", data: { input: $.inputs ?? {} }, name: q, run_id: $.id, tags: $.tags ?? [], metadata: $.extra?.metadata ?? {} }, K);
  }
  async onToolEnd($) {
    let q = this.runInfoMap.get($.id);
    if (this.runInfoMap.delete($.id), q === void 0) throw Error(`onToolEnd: Run ID ${$.id} not found in run map.`);
    if (q.inputs === void 0) throw Error(`onToolEnd: Run ID ${$.id} is a tool call, and is expected to have traced inputs.`);
    let K = $.outputs?.output === void 0 ? $.outputs : $.outputs.output;
    await this.sendEndEvent({ event: "on_tool_end", data: { output: K, input: q.inputs }, run_id: $.id, name: q.name, tags: q.tags, metadata: q.metadata }, q);
  }
  async onRetrieverStart($) {
    let q = W9($), K = "retriever", P = { tags: $.tags ?? [], metadata: $.extra?.metadata ?? {}, name: q, runType: "retriever", inputs: { query: $.inputs.query } };
    this.runInfoMap.set($.id, P), await this.send({ event: "on_retriever_start", data: { input: { query: $.inputs.query } }, name: q, tags: $.tags ?? [], run_id: $.id, metadata: $.extra?.metadata ?? {} }, P);
  }
  async onRetrieverEnd($) {
    let q = this.runInfoMap.get($.id);
    if (this.runInfoMap.delete($.id), q === void 0) throw Error(`onRetrieverEnd: Run ID ${$.id} not found in run map.`);
    await this.sendEndEvent({ event: "on_retriever_end", data: { output: $.outputs?.documents ?? $.outputs, input: q.inputs }, run_id: $.id, name: q.name, tags: q.tags, metadata: q.metadata }, q);
  }
  async handleCustomEvent($, q, K) {
    let P = this.runInfoMap.get(K);
    if (P === void 0) throw Error(`handleCustomEvent: Run ID ${K} not found in run map.`);
    await this.send({ event: "on_custom_event", run_id: K, name: $, tags: P.tags, metadata: P.metadata, data: q }, P);
  }
  async finish() {
    let $ = [...this.tappedPromises.values()];
    Promise.all($).finally(() => {
      this.writer.close();
    });
  }
}, __name(_a31, "EX"), _a31);
var RX = K8(h1(), 1);
var H9 = K8(D1(), 1);
var PI = {};
Z6(PI, { AsyncCaller: /* @__PURE__ */ __name(() => CP, "AsyncCaller") });
var OI = [400, 401, 402, 403, 404, 405, 406, 407, 409];
var YI = /* @__PURE__ */ __name(($) => {
  if ($.message.startsWith("Cancel") || $.message.startsWith("AbortError") || $.name === "AbortError") throw $;
  if ($?.code === "ECONNABORTED") throw $;
  let q = $?.response?.status ?? $?.status;
  if (q && OI.includes(+q)) throw $;
  if ($?.error?.code === "insufficient_quota") {
    let K = Error($?.message);
    throw K.name = "InsufficientQuotaError", K;
  }
}, "YI");
var _a32;
var CP = (_a32 = class {
  maxConcurrency;
  maxRetries;
  onFailedAttempt;
  queue;
  constructor($) {
    this.maxConcurrency = $.maxConcurrency ?? 1 / 0, this.maxRetries = $.maxRetries ?? 6, this.onFailedAttempt = $.onFailedAttempt ?? YI;
    let q = "default" in H9.default ? H9.default.default : H9.default;
    this.queue = new q({ concurrency: this.maxConcurrency });
  }
  call($, ...q) {
    return this.queue.add(() => RX.default(() => $(...q).catch((K) => {
      if (K instanceof Error) throw K;
      else throw Error(K);
    }), { onFailedAttempt: this.onFailedAttempt, retries: this.maxRetries, randomize: true }), { throwOnTimeout: true });
  }
  callWithOptions($, q, ...K) {
    if ($.signal) {
      let P;
      return Promise.race([this.call(q, ...K), new Promise((_, Y) => {
        P = /* @__PURE__ */ __name(() => {
          Y(i_($.signal));
        }, "P"), $.signal?.addEventListener("abort", P);
      })]).finally(() => {
        if ($.signal && P) $.signal.removeEventListener("abort", P);
      });
    }
    return this.call(q, ...K);
  }
  fetch(...$) {
    return this.call(() => fetch(...$).then((q) => q.ok ? q : Promise.reject(q)));
  }
}, __name(_a32, "CP"), _a32);
var _a33;
var o2 = (_a33 = class extends E8 {
  name = "RootListenersTracer";
  rootId;
  config;
  argOnStart;
  argOnEnd;
  argOnError;
  constructor({ config: $, onStart: q, onEnd: K, onError: P }) {
    super({ _awaitHandler: true });
    this.config = $, this.argOnStart = q, this.argOnEnd = K, this.argOnError = P;
  }
  persistRun($) {
    return Promise.resolve();
  }
  async onRunCreate($) {
    if (this.rootId) return;
    if (this.rootId = $.id, this.argOnStart) await this.argOnStart($, this.config);
  }
  async onRunUpdate($) {
    if ($.id !== this.rootId) return;
    if (!$.error) {
      if (this.argOnEnd) await this.argOnEnd($, this.config);
    } else if (this.argOnError) await this.argOnError($, this.config);
  }
}, __name(_a33, "o2"), _a33);
function hP($) {
  return $ ? $.lc_runnable : false;
}
__name(hP, "hP");
var _a34;
var IX = (_a34 = class {
  includeNames;
  includeTypes;
  includeTags;
  excludeNames;
  excludeTypes;
  excludeTags;
  constructor($) {
    this.includeNames = $.includeNames, this.includeTypes = $.includeTypes, this.includeTags = $.includeTags, this.excludeNames = $.excludeNames, this.excludeTypes = $.excludeTypes, this.excludeTags = $.excludeTags;
  }
  includeEvent($, q) {
    let K = this.includeNames === void 0 && this.includeTypes === void 0 && this.includeTags === void 0, P = $.tags ?? [];
    if (this.includeNames !== void 0) K = K || this.includeNames.includes($.name);
    if (this.includeTypes !== void 0) K = K || this.includeTypes.includes(q);
    if (this.includeTags !== void 0) K = K || P.some((_) => this.includeTags?.includes(_));
    if (this.excludeNames !== void 0) K = K && !this.excludeNames.includes($.name);
    if (this.excludeTypes !== void 0) K = K && !this.excludeTypes.includes(q);
    if (this.excludeTags !== void 0) K = K && P.every((_) => !this.excludeTags?.includes(_));
    return K;
  }
}, __name(_a34, "IX"), _a34);
var JK = {};
rq(JK, { version: /* @__PURE__ */ __name(() => QY, "version"), util: /* @__PURE__ */ __name(() => l$, "util"), treeifyError: /* @__PURE__ */ __name(() => $Y, "treeifyError"), toJSONSchema: /* @__PURE__ */ __name(() => j4, "toJSONSchema"), toDotPath: /* @__PURE__ */ __name(() => uX, "toDotPath"), safeParseAsync: /* @__PURE__ */ __name(() => _Y, "safeParseAsync"), safeParse: /* @__PURE__ */ __name(() => KY, "safeParse"), safeEncodeAsync: /* @__PURE__ */ __name(() => mI, "safeEncodeAsync"), safeEncode: /* @__PURE__ */ __name(() => pI, "safeEncode"), safeDecodeAsync: /* @__PURE__ */ __name(() => dI, "safeDecodeAsync"), safeDecode: /* @__PURE__ */ __name(() => cI, "safeDecode"), registry: /* @__PURE__ */ __name(() => p9, "registry"), regexes: /* @__PURE__ */ __name(() => Z8, "regexes"), prettifyError: /* @__PURE__ */ __name(() => qY, "prettifyError"), parseAsync: /* @__PURE__ */ __name(() => s_, "parseAsync"), parse: /* @__PURE__ */ __name(() => pP, "parse"), locales: /* @__PURE__ */ __name(() => UP, "locales"), isValidJWT: /* @__PURE__ */ __name(() => sX, "isValidJWT"), isValidBase64URL: /* @__PURE__ */ __name(() => eX, "isValidBase64URL"), isValidBase64: /* @__PURE__ */ __name(() => Aj, "isValidBase64"), globalRegistry: /* @__PURE__ */ __name(() => Hq, "globalRegistry"), globalConfig: /* @__PURE__ */ __name(() => EP, "globalConfig"), formatError: /* @__PURE__ */ __name(() => xP, "formatError"), flattenError: /* @__PURE__ */ __name(() => uP, "flattenError"), encodeAsync: /* @__PURE__ */ __name(() => uI, "encodeAsync"), encode: /* @__PURE__ */ __name(() => bI, "encode"), decodeAsync: /* @__PURE__ */ __name(() => xI, "decodeAsync"), decode: /* @__PURE__ */ __name(() => yI, "decode"), config: /* @__PURE__ */ __name(() => o6, "config"), clone: /* @__PURE__ */ __name(() => n6, "clone"), _xid: /* @__PURE__ */ __name(() => U9, "_xid"), _void: /* @__PURE__ */ __name(() => Av, "_void"), _uuidv7: /* @__PURE__ */ __name(() => r9, "_uuidv7"), _uuidv6: /* @__PURE__ */ __name(() => l9, "_uuidv6"), _uuidv4: /* @__PURE__ */ __name(() => d9, "_uuidv4"), _uuid: /* @__PURE__ */ __name(() => m9, "_uuid"), _url: /* @__PURE__ */ __name(() => QP, "_url"), _uppercase: /* @__PURE__ */ __name(() => K7, "_uppercase"), _unknown: /* @__PURE__ */ __name(() => P5, "_unknown"), _union: /* @__PURE__ */ __name(() => zL, "_union"), _undefined: /* @__PURE__ */ __name(() => fv, "_undefined"), _ulid: /* @__PURE__ */ __name(() => B9, "_ulid"), _uint64: /* @__PURE__ */ __name(() => Tv, "_uint64"), _uint32: /* @__PURE__ */ __name(() => jv, "_uint32"), _tuple: /* @__PURE__ */ __name(() => JL, "_tuple"), _trim: /* @__PURE__ */ __name(() => v7, "_trim"), _transform: /* @__PURE__ */ __name(() => kL, "_transform"), _toUpperCase: /* @__PURE__ */ __name(() => W7, "_toUpperCase"), _toLowerCase: /* @__PURE__ */ __name(() => z7, "_toLowerCase"), _templateLiteral: /* @__PURE__ */ __name(() => RL, "_templateLiteral"), _symbol: /* @__PURE__ */ __name(() => wv, "_symbol"), _superRefine: /* @__PURE__ */ __name(() => Lv, "_superRefine"), _success: /* @__PURE__ */ __name(() => NL, "_success"), _stringbool: /* @__PURE__ */ __name(() => gv, "_stringbool"), _stringFormat: /* @__PURE__ */ __name(() => Y4, "_stringFormat"), _string: /* @__PURE__ */ __name(() => U3, "_string"), _startsWith: /* @__PURE__ */ __name(() => P7, "_startsWith"), _size: /* @__PURE__ */ __name(() => sP, "_size"), _set: /* @__PURE__ */ __name(() => fL, "_set"), _safeParseAsync: /* @__PURE__ */ __name(() => q4, "_safeParseAsync"), _safeParse: /* @__PURE__ */ __name(() => $4, "_safeParse"), _safeEncodeAsync: /* @__PURE__ */ __name(() => G9, "_safeEncodeAsync"), _safeEncode: /* @__PURE__ */ __name(() => A9, "_safeEncode"), _safeDecodeAsync: /* @__PURE__ */ __name(() => V9, "_safeDecodeAsync"), _safeDecode: /* @__PURE__ */ __name(() => k9, "_safeDecode"), _regex: /* @__PURE__ */ __name(() => $7, "_regex"), _refine: /* @__PURE__ */ __name(() => Dv, "_refine"), _record: /* @__PURE__ */ __name(() => TL, "_record"), _readonly: /* @__PURE__ */ __name(() => EL, "_readonly"), _property: /* @__PURE__ */ __name(() => hv, "_property"), _promise: /* @__PURE__ */ __name(() => DL, "_promise"), _positive: /* @__PURE__ */ __name(() => Sv, "_positive"), _pipe: /* @__PURE__ */ __name(() => hL, "_pipe"), _parseAsync: /* @__PURE__ */ __name(() => e_, "_parseAsync"), _parse: /* @__PURE__ */ __name(() => Q_, "_parse"), _overwrite: /* @__PURE__ */ __name(() => HK, "_overwrite"), _optional: /* @__PURE__ */ __name(() => GL, "_optional"), _number: /* @__PURE__ */ __name(() => qv, "_number"), _nullable: /* @__PURE__ */ __name(() => VL, "_nullable"), _null: /* @__PURE__ */ __name(() => Zv, "_null"), _normalize: /* @__PURE__ */ __name(() => j7, "_normalize"), _nonpositive: /* @__PURE__ */ __name(() => Nv, "_nonpositive"), _nonoptional: /* @__PURE__ */ __name(() => ML, "_nonoptional"), _nonnegative: /* @__PURE__ */ __name(() => Cv, "_nonnegative"), _never: /* @__PURE__ */ __name(() => eP, "_never"), _negative: /* @__PURE__ */ __name(() => Mv, "_negative"), _nativeEnum: /* @__PURE__ */ __name(() => XL, "_nativeEnum"), _nanoid: /* @__PURE__ */ __name(() => n9, "_nanoid"), _nan: /* @__PURE__ */ __name(() => Vv, "_nan"), _multipleOf: /* @__PURE__ */ __name(() => X_, "_multipleOf"), _minSize: /* @__PURE__ */ __name(() => A_, "_minSize"), _minLength: /* @__PURE__ */ __name(() => nK, "_minLength"), _min: /* @__PURE__ */ __name(() => aq, "_min"), _mime: /* @__PURE__ */ __name(() => Y7, "_mime"), _maxSize: /* @__PURE__ */ __name(() => _4, "_maxSize"), _maxLength: /* @__PURE__ */ __name(() => P4, "_maxLength"), _max: /* @__PURE__ */ __name(() => X8, "_max"), _map: /* @__PURE__ */ __name(() => wL, "_map"), _lte: /* @__PURE__ */ __name(() => X8, "_lte"), _lt: /* @__PURE__ */ __name(() => zK, "_lt"), _lowercase: /* @__PURE__ */ __name(() => q7, "_lowercase"), _literal: /* @__PURE__ */ __name(() => AL, "_literal"), _length: /* @__PURE__ */ __name(() => O4, "_length"), _lazy: /* @__PURE__ */ __name(() => IL, "_lazy"), _ksuid: /* @__PURE__ */ __name(() => F9, "_ksuid"), _jwt: /* @__PURE__ */ __name(() => _5, "_jwt"), _isoTime: /* @__PURE__ */ __name(() => s3, "_isoTime"), _isoDuration: /* @__PURE__ */ __name(() => $v, "_isoDuration"), _isoDateTime: /* @__PURE__ */ __name(() => Q3, "_isoDateTime"), _isoDate: /* @__PURE__ */ __name(() => e3, "_isoDate"), _ipv6: /* @__PURE__ */ __name(() => Q9, "_ipv6"), _ipv4: /* @__PURE__ */ __name(() => a9, "_ipv4"), _intersection: /* @__PURE__ */ __name(() => HL, "_intersection"), _int64: /* @__PURE__ */ __name(() => Jv, "_int64"), _int32: /* @__PURE__ */ __name(() => Yv, "_int32"), _int: /* @__PURE__ */ __name(() => _v, "_int"), _includes: /* @__PURE__ */ __name(() => _7, "_includes"), _guid: /* @__PURE__ */ __name(() => aP, "_guid"), _gte: /* @__PURE__ */ __name(() => aq, "_gte"), _gt: /* @__PURE__ */ __name(() => WK, "_gt"), _float64: /* @__PURE__ */ __name(() => Ov, "_float64"), _float32: /* @__PURE__ */ __name(() => Pv, "_float32"), _file: /* @__PURE__ */ __name(() => Rv, "_file"), _enum: /* @__PURE__ */ __name(() => ZL, "_enum"), _endsWith: /* @__PURE__ */ __name(() => O7, "_endsWith"), _encodeAsync: /* @__PURE__ */ __name(() => Z9, "_encodeAsync"), _encode: /* @__PURE__ */ __name(() => w9, "_encode"), _emoji: /* @__PURE__ */ __name(() => o9, "_emoji"), _email: /* @__PURE__ */ __name(() => c9, "_email"), _e164: /* @__PURE__ */ __name(() => K5, "_e164"), _discriminatedUnion: /* @__PURE__ */ __name(() => WL, "_discriminatedUnion"), _default: /* @__PURE__ */ __name(() => SL, "_default"), _decodeAsync: /* @__PURE__ */ __name(() => X9, "_decodeAsync"), _decode: /* @__PURE__ */ __name(() => f9, "_decode"), _date: /* @__PURE__ */ __name(() => kv, "_date"), _custom: /* @__PURE__ */ __name(() => Iv, "_custom"), _cuid2: /* @__PURE__ */ __name(() => t9, "_cuid2"), _cuid: /* @__PURE__ */ __name(() => i9, "_cuid"), _coercedString: /* @__PURE__ */ __name(() => F3, "_coercedString"), _coercedNumber: /* @__PURE__ */ __name(() => Kv, "_coercedNumber"), _coercedDate: /* @__PURE__ */ __name(() => Gv, "_coercedDate"), _coercedBoolean: /* @__PURE__ */ __name(() => zv, "_coercedBoolean"), _coercedBigint: /* @__PURE__ */ __name(() => Hv, "_coercedBigint"), _cidrv6: /* @__PURE__ */ __name(() => s9, "_cidrv6"), _cidrv4: /* @__PURE__ */ __name(() => e9, "_cidrv4"), _check: /* @__PURE__ */ __name(() => YA, "_check"), _catch: /* @__PURE__ */ __name(() => CL, "_catch"), _boolean: /* @__PURE__ */ __name(() => vv, "_boolean"), _bigint: /* @__PURE__ */ __name(() => Wv, "_bigint"), _base64url: /* @__PURE__ */ __name(() => q5, "_base64url"), _base64: /* @__PURE__ */ __name(() => $5, "_base64"), _array: /* @__PURE__ */ __name(() => Ev, "_array"), _any: /* @__PURE__ */ __name(() => Xv, "_any"), TimePrecision: /* @__PURE__ */ __name(() => a3, "TimePrecision"), NEVER: /* @__PURE__ */ __name(() => n2, "NEVER"), JSONSchemaGenerator: /* @__PURE__ */ __name(() => O5, "JSONSchemaGenerator"), JSONSchema: /* @__PURE__ */ __name(() => jA, "JSONSchema"), Doc: /* @__PURE__ */ __name(() => C9, "Doc"), $output: /* @__PURE__ */ __name(() => t3, "$output"), $input: /* @__PURE__ */ __name(() => B3, "$input"), $constructor: /* @__PURE__ */ __name(() => O$, "$constructor"), $brand: /* @__PURE__ */ __name(() => i2, "$brand"), $ZodXID: /* @__PURE__ */ __name(() => vj, "$ZodXID"), $ZodVoid: /* @__PURE__ */ __name(() => Dj, "$ZodVoid"), $ZodUnknown: /* @__PURE__ */ __name(() => b9, "$ZodUnknown"), $ZodUnion: /* @__PURE__ */ __name(() => y9, "$ZodUnion"), $ZodUndefined: /* @__PURE__ */ __name(() => Ej, "$ZodUndefined"), $ZodUUID: /* @__PURE__ */ __name(() => $j, "$ZodUUID"), $ZodURL: /* @__PURE__ */ __name(() => Kj, "$ZodURL"), $ZodULID: /* @__PURE__ */ __name(() => jj, "$ZodULID"), $ZodType: /* @__PURE__ */ __name(() => P6, "$ZodType"), $ZodTuple: /* @__PURE__ */ __name(() => u9, "$ZodTuple"), $ZodTransform: /* @__PURE__ */ __name(() => rj, "$ZodTransform"), $ZodTemplateLiteral: /* @__PURE__ */ __name(() => ej, "$ZodTemplateLiteral"), $ZodSymbol: /* @__PURE__ */ __name(() => hj, "$ZodSymbol"), $ZodSuccess: /* @__PURE__ */ __name(() => Bj, "$ZodSuccess"), $ZodStringFormat: /* @__PURE__ */ __name(() => h6, "$ZodStringFormat"), $ZodString: /* @__PURE__ */ __name(() => Z_, "$ZodString"), $ZodSet: /* @__PURE__ */ __name(() => cj, "$ZodSet"), $ZodRegistry: /* @__PURE__ */ __name(() => FP, "$ZodRegistry"), $ZodRecord: /* @__PURE__ */ __name(() => xj, "$ZodRecord"), $ZodRealError: /* @__PURE__ */ __name(() => Fq, "$ZodRealError"), $ZodReadonly: /* @__PURE__ */ __name(() => Qj, "$ZodReadonly"), $ZodPromise: /* @__PURE__ */ __name(() => $3, "$ZodPromise"), $ZodPrefault: /* @__PURE__ */ __name(() => ij, "$ZodPrefault"), $ZodPipe: /* @__PURE__ */ __name(() => aj, "$ZodPipe"), $ZodOptional: /* @__PURE__ */ __name(() => x9, "$ZodOptional"), $ZodObjectJIT: /* @__PURE__ */ __name(() => bj, "$ZodObjectJIT"), $ZodObject: /* @__PURE__ */ __name(() => KA, "$ZodObject"), $ZodNumberFormat: /* @__PURE__ */ __name(() => Nj, "$ZodNumberFormat"), $ZodNumber: /* @__PURE__ */ __name(() => L9, "$ZodNumber"), $ZodNullable: /* @__PURE__ */ __name(() => oj, "$ZodNullable"), $ZodNull: /* @__PURE__ */ __name(() => Rj, "$ZodNull"), $ZodNonOptional: /* @__PURE__ */ __name(() => tj, "$ZodNonOptional"), $ZodNever: /* @__PURE__ */ __name(() => lP, "$ZodNever"), $ZodNanoID: /* @__PURE__ */ __name(() => Pj, "$ZodNanoID"), $ZodNaN: /* @__PURE__ */ __name(() => Fj, "$ZodNaN"), $ZodMap: /* @__PURE__ */ __name(() => pj, "$ZodMap"), $ZodLiteral: /* @__PURE__ */ __name(() => dj, "$ZodLiteral"), $ZodLazy: /* @__PURE__ */ __name(() => q3, "$ZodLazy"), $ZodKSUID: /* @__PURE__ */ __name(() => zj, "$ZodKSUID"), $ZodJWT: /* @__PURE__ */ __name(() => Sj, "$ZodJWT"), $ZodIntersection: /* @__PURE__ */ __name(() => uj, "$ZodIntersection"), $ZodISOTime: /* @__PURE__ */ __name(() => Jj, "$ZodISOTime"), $ZodISODuration: /* @__PURE__ */ __name(() => Tj, "$ZodISODuration"), $ZodISODateTime: /* @__PURE__ */ __name(() => Wj, "$ZodISODateTime"), $ZodISODate: /* @__PURE__ */ __name(() => Hj, "$ZodISODate"), $ZodIPv6: /* @__PURE__ */ __name(() => fj, "$ZodIPv6"), $ZodIPv4: /* @__PURE__ */ __name(() => wj, "$ZodIPv4"), $ZodGUID: /* @__PURE__ */ __name(() => sY, "$ZodGUID"), $ZodFunction: /* @__PURE__ */ __name(() => sj, "$ZodFunction"), $ZodFile: /* @__PURE__ */ __name(() => lj, "$ZodFile"), $ZodError: /* @__PURE__ */ __name(() => yP, "$ZodError"), $ZodEnum: /* @__PURE__ */ __name(() => mj, "$ZodEnum"), $ZodEncodeError: /* @__PURE__ */ __name(() => T_, "$ZodEncodeError"), $ZodEmoji: /* @__PURE__ */ __name(() => _j, "$ZodEmoji"), $ZodEmail: /* @__PURE__ */ __name(() => qj, "$ZodEmail"), $ZodE164: /* @__PURE__ */ __name(() => Vj, "$ZodE164"), $ZodDiscriminatedUnion: /* @__PURE__ */ __name(() => yj, "$ZodDiscriminatedUnion"), $ZodDefault: /* @__PURE__ */ __name(() => nj, "$ZodDefault"), $ZodDate: /* @__PURE__ */ __name(() => Lj, "$ZodDate"), $ZodCustomStringFormat: /* @__PURE__ */ __name(() => Mj, "$ZodCustomStringFormat"), $ZodCustom: /* @__PURE__ */ __name(() => K3, "$ZodCustom"), $ZodCodec: /* @__PURE__ */ __name(() => rP, "$ZodCodec"), $ZodCheckUpperCase: /* @__PURE__ */ __name(() => nY, "$ZodCheckUpperCase"), $ZodCheckStringFormat: /* @__PURE__ */ __name(() => K4, "$ZodCheckStringFormat"), $ZodCheckStartsWith: /* @__PURE__ */ __name(() => tY, "$ZodCheckStartsWith"), $ZodCheckSizeEquals: /* @__PURE__ */ __name(() => cY, "$ZodCheckSizeEquals"), $ZodCheckRegex: /* @__PURE__ */ __name(() => rY, "$ZodCheckRegex"), $ZodCheckProperty: /* @__PURE__ */ __name(() => UY, "$ZodCheckProperty"), $ZodCheckOverwrite: /* @__PURE__ */ __name(() => aY, "$ZodCheckOverwrite"), $ZodCheckNumberFormat: /* @__PURE__ */ __name(() => yY, "$ZodCheckNumberFormat"), $ZodCheckMultipleOf: /* @__PURE__ */ __name(() => bY, "$ZodCheckMultipleOf"), $ZodCheckMinSize: /* @__PURE__ */ __name(() => pY, "$ZodCheckMinSize"), $ZodCheckMinLength: /* @__PURE__ */ __name(() => dY, "$ZodCheckMinLength"), $ZodCheckMimeType: /* @__PURE__ */ __name(() => FY, "$ZodCheckMimeType"), $ZodCheckMaxSize: /* @__PURE__ */ __name(() => xY, "$ZodCheckMaxSize"), $ZodCheckMaxLength: /* @__PURE__ */ __name(() => mY, "$ZodCheckMaxLength"), $ZodCheckLowerCase: /* @__PURE__ */ __name(() => oY, "$ZodCheckLowerCase"), $ZodCheckLessThan: /* @__PURE__ */ __name(() => M9, "$ZodCheckLessThan"), $ZodCheckLengthEquals: /* @__PURE__ */ __name(() => lY, "$ZodCheckLengthEquals"), $ZodCheckIncludes: /* @__PURE__ */ __name(() => iY, "$ZodCheckIncludes"), $ZodCheckGreaterThan: /* @__PURE__ */ __name(() => N9, "$ZodCheckGreaterThan"), $ZodCheckEndsWith: /* @__PURE__ */ __name(() => BY, "$ZodCheckEndsWith"), $ZodCheckBigIntFormat: /* @__PURE__ */ __name(() => uY, "$ZodCheckBigIntFormat"), $ZodCheck: /* @__PURE__ */ __name(() => I6, "$ZodCheck"), $ZodCatch: /* @__PURE__ */ __name(() => Uj, "$ZodCatch"), $ZodCUID2: /* @__PURE__ */ __name(() => Yj, "$ZodCUID2"), $ZodCUID: /* @__PURE__ */ __name(() => Oj, "$ZodCUID"), $ZodCIDRv6: /* @__PURE__ */ __name(() => Xj, "$ZodCIDRv6"), $ZodCIDRv4: /* @__PURE__ */ __name(() => Zj, "$ZodCIDRv4"), $ZodBoolean: /* @__PURE__ */ __name(() => dP, "$ZodBoolean"), $ZodBigIntFormat: /* @__PURE__ */ __name(() => Cj, "$ZodBigIntFormat"), $ZodBigInt: /* @__PURE__ */ __name(() => g9, "$ZodBigInt"), $ZodBase64URL: /* @__PURE__ */ __name(() => Gj, "$ZodBase64URL"), $ZodBase64: /* @__PURE__ */ __name(() => kj, "$ZodBase64"), $ZodAsyncError: /* @__PURE__ */ __name(() => o8, "$ZodAsyncError"), $ZodArray: /* @__PURE__ */ __name(() => gj, "$ZodArray"), $ZodAny: /* @__PURE__ */ __name(() => Ij, "$ZodAny") });
var n2 = Object.freeze({ status: "aborted" });
function O$($, q, K) {
  function P(z, J) {
    var T;
    Object.defineProperty(z, "_zod", { value: z._zod ?? {}, enumerable: false }), (T = z._zod).traits ?? (T.traits = /* @__PURE__ */ new Set()), z._zod.traits.add($), q(z, J);
    for (let X in O.prototype) if (!(X in z)) Object.defineProperty(z, X, { value: O.prototype[X].bind(z) });
    z._zod.constr = O, z._zod.def = J;
  }
  __name(P, "P");
  let _ = K?.Parent ?? Object;
  const _Y2 = class _Y2 extends _ {
  };
  __name(_Y2, "Y");
  let Y = _Y2;
  Object.defineProperty(Y, "name", { value: $ });
  function O(z) {
    var J;
    let T = K?.Parent ? new Y() : this;
    P(T, z), (J = T._zod).deferred ?? (J.deferred = []);
    for (let X of T._zod.deferred) X();
    return T;
  }
  __name(O, "O");
  return Object.defineProperty(O, "init", { value: P }), Object.defineProperty(O, Symbol.hasInstance, { value: /* @__PURE__ */ __name((z) => {
    if (K?.Parent && z instanceof K.Parent) return true;
    return z?._zod?.traits?.has($);
  }, "value") }), Object.defineProperty(O, "name", { value: $ }), O;
}
__name(O$, "O$");
var i2 = Symbol("zod_brand");
var _o8 = class _o8 extends Error {
  constructor() {
    super("Encountered Promise during synchronous parse. Use .parseAsync() instead.");
  }
};
__name(_o8, "o8");
var o8 = _o8;
var _T_ = class _T_ extends Error {
  constructor($) {
    super(`Encountered unidirectional transform during encode: ${$}`);
    this.name = "ZodEncodeError";
  }
};
__name(_T_, "T_");
var T_ = _T_;
var EP = {};
function o6($) {
  if ($) Object.assign(EP, $);
  return EP;
}
__name(o6, "o6");
var l$ = {};
rq(l$, { unwrapMessage: /* @__PURE__ */ __name(() => RP, "unwrapMessage"), uint8ArrayToHex: /* @__PURE__ */ __name(() => LI, "uint8ArrayToHex"), uint8ArrayToBase64url: /* @__PURE__ */ __name(() => II, "uint8ArrayToBase64url"), uint8ArrayToBase64: /* @__PURE__ */ __name(() => gX, "uint8ArrayToBase64"), stringifyPrimitive: /* @__PURE__ */ __name(() => m$, "stringifyPrimitive"), shallowClone: /* @__PURE__ */ __name(() => F2, "shallowClone"), safeExtend: /* @__PURE__ */ __name(() => MI, "safeExtend"), required: /* @__PURE__ */ __name(() => hI, "required"), randomString: /* @__PURE__ */ __name(() => ZI, "randomString"), propertyKeyTypes: /* @__PURE__ */ __name(() => LP, "propertyKeyTypes"), promiseAllObject: /* @__PURE__ */ __name(() => fI, "promiseAllObject"), primitiveTypes: /* @__PURE__ */ __name(() => a2, "primitiveTypes"), prefixIssues: /* @__PURE__ */ __name(() => O8, "prefixIssues"), pick: /* @__PURE__ */ __name(() => GI, "pick"), partial: /* @__PURE__ */ __name(() => CI, "partial"), optionalKeys: /* @__PURE__ */ __name(() => Q2, "optionalKeys"), omit: /* @__PURE__ */ __name(() => VI, "omit"), objectClone: /* @__PURE__ */ __name(() => JI, "objectClone"), numKeys: /* @__PURE__ */ __name(() => XI, "numKeys"), nullish: /* @__PURE__ */ __name(() => mK, "nullish"), normalizeParams: /* @__PURE__ */ __name(() => d$, "normalizeParams"), mergeDefs: /* @__PURE__ */ __name(() => lK, "mergeDefs"), merge: /* @__PURE__ */ __name(() => NI, "merge"), jsonStringifyReplacer: /* @__PURE__ */ __name(() => U_, "jsonStringifyReplacer"), joinValues: /* @__PURE__ */ __name(() => T$, "joinValues"), issue: /* @__PURE__ */ __name(() => a_, "issue"), isPlainObject: /* @__PURE__ */ __name(() => rK, "isPlainObject"), isObject: /* @__PURE__ */ __name(() => w_, "isObject"), hexToUint8Array: /* @__PURE__ */ __name(() => DI, "hexToUint8Array"), getSizableOrigin: /* @__PURE__ */ __name(() => gP, "getSizableOrigin"), getParsedType: /* @__PURE__ */ __name(() => AI, "getParsedType"), getLengthableOrigin: /* @__PURE__ */ __name(() => bP, "getLengthableOrigin"), getEnumValues: /* @__PURE__ */ __name(() => IP, "getEnumValues"), getElementAtPath: /* @__PURE__ */ __name(() => wI, "getElementAtPath"), floatSafeRemainder: /* @__PURE__ */ __name(() => B2, "floatSafeRemainder"), finalizeIssue: /* @__PURE__ */ __name(() => Y8, "finalizeIssue"), extend: /* @__PURE__ */ __name(() => SI, "extend"), escapeRegex: /* @__PURE__ */ __name(() => n8, "escapeRegex"), esc: /* @__PURE__ */ __name(() => J9, "esc"), defineLazy: /* @__PURE__ */ __name(() => A6, "defineLazy"), createTransparentProxy: /* @__PURE__ */ __name(() => kI, "createTransparentProxy"), cloneDef: /* @__PURE__ */ __name(() => TI, "cloneDef"), clone: /* @__PURE__ */ __name(() => n6, "clone"), cleanRegex: /* @__PURE__ */ __name(() => DP, "cleanRegex"), cleanEnum: /* @__PURE__ */ __name(() => EI, "cleanEnum"), captureStackTrace: /* @__PURE__ */ __name(() => T9, "captureStackTrace"), cached: /* @__PURE__ */ __name(() => F_, "cached"), base64urlToUint8Array: /* @__PURE__ */ __name(() => RI, "base64urlToUint8Array"), base64ToUint8Array: /* @__PURE__ */ __name(() => LX, "base64ToUint8Array"), assignProp: /* @__PURE__ */ __name(() => dK, "assignProp"), assertNotEqual: /* @__PURE__ */ __name(() => vI, "assertNotEqual"), assertNever: /* @__PURE__ */ __name(() => WI, "assertNever"), assertIs: /* @__PURE__ */ __name(() => zI, "assertIs"), assertEqual: /* @__PURE__ */ __name(() => jI, "assertEqual"), assert: /* @__PURE__ */ __name(() => HI, "assert"), allowsEval: /* @__PURE__ */ __name(() => U2, "allowsEval"), aborted: /* @__PURE__ */ __name(() => oK, "aborted"), NUMBER_FORMAT_RANGES: /* @__PURE__ */ __name(() => e2, "NUMBER_FORMAT_RANGES"), Class: /* @__PURE__ */ __name(() => bX, "Class"), BIGINT_FORMAT_RANGES: /* @__PURE__ */ __name(() => s2, "BIGINT_FORMAT_RANGES") });
function jI($) {
  return $;
}
__name(jI, "jI");
function vI($) {
  return $;
}
__name(vI, "vI");
function zI($) {
}
__name(zI, "zI");
function WI($) {
  throw Error();
}
__name(WI, "WI");
function HI($) {
}
__name(HI, "HI");
function IP($) {
  let q = Object.values($).filter((P) => typeof P === "number");
  return Object.entries($).filter(([P, _]) => q.indexOf(+P) === -1).map(([P, _]) => _);
}
__name(IP, "IP");
function T$($, q = "|") {
  return $.map((K) => m$(K)).join(q);
}
__name(T$, "T$");
function U_($, q) {
  if (typeof q === "bigint") return q.toString();
  return q;
}
__name(U_, "U_");
function F_($) {
  return { get value() {
    {
      let K = $();
      return Object.defineProperty(this, "value", { value: K }), K;
    }
    throw Error("cached value already set");
  } };
}
__name(F_, "F_");
function mK($) {
  return $ === null || $ === void 0;
}
__name(mK, "mK");
function DP($) {
  let q = $.startsWith("^") ? 1 : 0, K = $.endsWith("$") ? $.length - 1 : $.length;
  return $.slice(q, K);
}
__name(DP, "DP");
function B2($, q) {
  let K = ($.toString().split(".")[1] || "").length, P = q.toString(), _ = (P.split(".")[1] || "").length;
  if (_ === 0 && /\d?e-\d?/.test(P)) {
    let J = P.match(/\d?e-(\d?)/);
    if (J?.[1]) _ = Number.parseInt(J[1]);
  }
  let Y = K > _ ? K : _, O = Number.parseInt($.toFixed(Y).replace(".", "")), z = Number.parseInt(q.toFixed(Y).replace(".", ""));
  return O % z / 10 ** Y;
}
__name(B2, "B2");
var DX = Symbol("evaluating");
function A6($, q, K) {
  let P = void 0;
  Object.defineProperty($, q, { get() {
    if (P === DX) return;
    if (P === void 0) P = DX, P = K();
    return P;
  }, set(_) {
    Object.defineProperty($, q, { value: _ });
  }, configurable: true });
}
__name(A6, "A6");
function JI($) {
  return Object.create(Object.getPrototypeOf($), Object.getOwnPropertyDescriptors($));
}
__name(JI, "JI");
function dK($, q, K) {
  Object.defineProperty($, q, { value: K, writable: true, enumerable: true, configurable: true });
}
__name(dK, "dK");
function lK(...$) {
  let q = {};
  for (let K of $) {
    let P = Object.getOwnPropertyDescriptors(K);
    Object.assign(q, P);
  }
  return Object.defineProperties({}, q);
}
__name(lK, "lK");
function TI($) {
  return lK($._zod.def);
}
__name(TI, "TI");
function wI($, q) {
  if (!q) return $;
  return q.reduce((K, P) => K?.[P], $);
}
__name(wI, "wI");
function fI($) {
  let q = Object.keys($), K = q.map((P) => $[P]);
  return Promise.all(K).then((P) => {
    let _ = {};
    for (let Y = 0; Y < q.length; Y++) _[q[Y]] = P[Y];
    return _;
  });
}
__name(fI, "fI");
function ZI($ = 10) {
  let K = "";
  for (let P = 0; P < $; P++) K += "abcdefghijklmnopqrstuvwxyz"[Math.floor(Math.random() * 26)];
  return K;
}
__name(ZI, "ZI");
function J9($) {
  return JSON.stringify($);
}
__name(J9, "J9");
var T9 = "captureStackTrace" in Error ? Error.captureStackTrace : (...$) => {
};
function w_($) {
  return typeof $ === "object" && $ !== null && !Array.isArray($);
}
__name(w_, "w_");
var U2 = F_(() => {
  if (typeof navigator < "u" && navigator?.userAgent?.includes("Cloudflare")) return false;
  try {
    return new Function(""), true;
  } catch ($) {
    return false;
  }
});
function rK($) {
  if (w_($) === false) return false;
  let q = $.constructor;
  if (q === void 0) return true;
  let K = q.prototype;
  if (w_(K) === false) return false;
  if (Object.prototype.hasOwnProperty.call(K, "isPrototypeOf") === false) return false;
  return true;
}
__name(rK, "rK");
function F2($) {
  if (rK($)) return { ...$ };
  if (Array.isArray($)) return [...$];
  return $;
}
__name(F2, "F2");
function XI($) {
  let q = 0;
  for (let K in $) if (Object.prototype.hasOwnProperty.call($, K)) q++;
  return q;
}
__name(XI, "XI");
var AI = /* @__PURE__ */ __name(($) => {
  let q = typeof $;
  switch (q) {
    case "undefined":
      return "undefined";
    case "string":
      return "string";
    case "number":
      return Number.isNaN($) ? "nan" : "number";
    case "boolean":
      return "boolean";
    case "function":
      return "function";
    case "bigint":
      return "bigint";
    case "symbol":
      return "symbol";
    case "object":
      if (Array.isArray($)) return "array";
      if ($ === null) return "null";
      if ($.then && typeof $.then === "function" && $.catch && typeof $.catch === "function") return "promise";
      if (typeof Map < "u" && $ instanceof Map) return "map";
      if (typeof Set < "u" && $ instanceof Set) return "set";
      if (typeof Date < "u" && $ instanceof Date) return "date";
      if (typeof File < "u" && $ instanceof File) return "file";
      return "object";
    default:
      throw Error(`Unknown data type: ${q}`);
  }
}, "AI");
var LP = /* @__PURE__ */ new Set(["string", "number", "symbol"]);
var a2 = /* @__PURE__ */ new Set(["string", "number", "bigint", "boolean", "symbol", "undefined"]);
function n8($) {
  return $.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
__name(n8, "n8");
function n6($, q, K) {
  let P = new $._zod.constr(q ?? $._zod.def);
  if (!q || K?.parent) P._zod.parent = $;
  return P;
}
__name(n6, "n6");
function d$($) {
  let q = $;
  if (!q) return {};
  if (typeof q === "string") return { error: /* @__PURE__ */ __name(() => q, "error") };
  if (q?.message !== void 0) {
    if (q?.error !== void 0) throw Error("Cannot specify both `message` and `error` params");
    q.error = q.message;
  }
  if (delete q.message, typeof q.error === "string") return { ...q, error: /* @__PURE__ */ __name(() => q.error, "error") };
  return q;
}
__name(d$, "d$");
function kI($) {
  let q;
  return new Proxy({}, { get(K, P, _) {
    return q ?? (q = $()), Reflect.get(q, P, _);
  }, set(K, P, _, Y) {
    return q ?? (q = $()), Reflect.set(q, P, _, Y);
  }, has(K, P) {
    return q ?? (q = $()), Reflect.has(q, P);
  }, deleteProperty(K, P) {
    return q ?? (q = $()), Reflect.deleteProperty(q, P);
  }, ownKeys(K) {
    return q ?? (q = $()), Reflect.ownKeys(q);
  }, getOwnPropertyDescriptor(K, P) {
    return q ?? (q = $()), Reflect.getOwnPropertyDescriptor(q, P);
  }, defineProperty(K, P, _) {
    return q ?? (q = $()), Reflect.defineProperty(q, P, _);
  } });
}
__name(kI, "kI");
function m$($) {
  if (typeof $ === "bigint") return $.toString() + "n";
  if (typeof $ === "string") return `"${$}"`;
  return `${$}`;
}
__name(m$, "m$");
function Q2($) {
  return Object.keys($).filter((q) => {
    return $[q]._zod.optin === "optional" && $[q]._zod.optout === "optional";
  });
}
__name(Q2, "Q2");
var e2 = { safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER], int32: [-2147483648, 2147483647], uint32: [0, 4294967295], float32: [-34028234663852886e22, 34028234663852886e22], float64: [-Number.MAX_VALUE, Number.MAX_VALUE] };
var s2 = { int64: [BigInt("-9223372036854775808"), BigInt("9223372036854775807")], uint64: [BigInt(0), BigInt("18446744073709551615")] };
function GI($, q) {
  let K = $._zod.def, P = lK($._zod.def, { get shape() {
    let _ = {};
    for (let Y in q) {
      if (!(Y in K.shape)) throw Error(`Unrecognized key: "${Y}"`);
      if (!q[Y]) continue;
      _[Y] = K.shape[Y];
    }
    return dK(this, "shape", _), _;
  }, checks: [] });
  return n6($, P);
}
__name(GI, "GI");
function VI($, q) {
  let K = $._zod.def, P = lK($._zod.def, { get shape() {
    let _ = { ...$._zod.def.shape };
    for (let Y in q) {
      if (!(Y in K.shape)) throw Error(`Unrecognized key: "${Y}"`);
      if (!q[Y]) continue;
      delete _[Y];
    }
    return dK(this, "shape", _), _;
  }, checks: [] });
  return n6($, P);
}
__name(VI, "VI");
function SI($, q) {
  if (!rK(q)) throw Error("Invalid input to extend: expected a plain object");
  let K = $._zod.def.checks;
  if (K && K.length > 0) throw Error("Object schemas containing refinements cannot be extended. Use `.safeExtend()` instead.");
  let _ = lK($._zod.def, { get shape() {
    let Y = { ...$._zod.def.shape, ...q };
    return dK(this, "shape", Y), Y;
  }, checks: [] });
  return n6($, _);
}
__name(SI, "SI");
function MI($, q) {
  if (!rK(q)) throw Error("Invalid input to safeExtend: expected a plain object");
  let K = { ...$._zod.def, get shape() {
    let P = { ...$._zod.def.shape, ...q };
    return dK(this, "shape", P), P;
  }, checks: $._zod.def.checks };
  return n6($, K);
}
__name(MI, "MI");
function NI($, q) {
  let K = lK($._zod.def, { get shape() {
    let P = { ...$._zod.def.shape, ...q._zod.def.shape };
    return dK(this, "shape", P), P;
  }, get catchall() {
    return q._zod.def.catchall;
  }, checks: [] });
  return n6($, K);
}
__name(NI, "NI");
function CI($, q, K) {
  let P = lK(q._zod.def, { get shape() {
    let _ = q._zod.def.shape, Y = { ..._ };
    if (K) for (let O in K) {
      if (!(O in _)) throw Error(`Unrecognized key: "${O}"`);
      if (!K[O]) continue;
      Y[O] = $ ? new $({ type: "optional", innerType: _[O] }) : _[O];
    }
    else for (let O in _) Y[O] = $ ? new $({ type: "optional", innerType: _[O] }) : _[O];
    return dK(this, "shape", Y), Y;
  }, checks: [] });
  return n6(q, P);
}
__name(CI, "CI");
function hI($, q, K) {
  let P = lK(q._zod.def, { get shape() {
    let _ = q._zod.def.shape, Y = { ..._ };
    if (K) for (let O in K) {
      if (!(O in Y)) throw Error(`Unrecognized key: "${O}"`);
      if (!K[O]) continue;
      Y[O] = new $({ type: "nonoptional", innerType: _[O] });
    }
    else for (let O in _) Y[O] = new $({ type: "nonoptional", innerType: _[O] });
    return dK(this, "shape", Y), Y;
  }, checks: [] });
  return n6(q, P);
}
__name(hI, "hI");
function oK($, q = 0) {
  if ($.aborted === true) return true;
  for (let K = q; K < $.issues.length; K++) if ($.issues[K]?.continue !== true) return true;
  return false;
}
__name(oK, "oK");
function O8($, q) {
  return q.map((K) => {
    var P;
    return (P = K).path ?? (P.path = []), K.path.unshift($), K;
  });
}
__name(O8, "O8");
function RP($) {
  return typeof $ === "string" ? $ : $?.message;
}
__name(RP, "RP");
function Y8($, q, K) {
  let P = { ...$, path: $.path ?? [] };
  if (!$.message) {
    let _ = RP($.inst?._zod.def?.error?.($)) ?? RP(q?.error?.($)) ?? RP(K.customError?.($)) ?? RP(K.localeError?.($)) ?? "Invalid input";
    P.message = _;
  }
  if (delete P.inst, delete P.continue, !q?.reportInput) delete P.input;
  return P;
}
__name(Y8, "Y8");
function gP($) {
  if ($ instanceof Set) return "set";
  if ($ instanceof Map) return "map";
  if ($ instanceof File) return "file";
  return "unknown";
}
__name(gP, "gP");
function bP($) {
  if (Array.isArray($)) return "array";
  if (typeof $ === "string") return "string";
  return "unknown";
}
__name(bP, "bP");
function a_(...$) {
  let [q, K, P] = $;
  if (typeof q === "string") return { message: q, code: "custom", input: K, inst: P };
  return { ...q };
}
__name(a_, "a_");
function EI($) {
  return Object.entries($).filter(([q, K]) => {
    return Number.isNaN(Number.parseInt(q, 10));
  }).map((q) => q[1]);
}
__name(EI, "EI");
function LX($) {
  let q = atob($), K = new Uint8Array(q.length);
  for (let P = 0; P < q.length; P++) K[P] = q.charCodeAt(P);
  return K;
}
__name(LX, "LX");
function gX($) {
  let q = "";
  for (let K = 0; K < $.length; K++) q += String.fromCharCode($[K]);
  return btoa(q);
}
__name(gX, "gX");
function RI($) {
  let q = $.replace(/-/g, "+").replace(/_/g, "/"), K = "=".repeat((4 - q.length % 4) % 4);
  return LX(q + K);
}
__name(RI, "RI");
function II($) {
  return gX($).replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}
__name(II, "II");
function DI($) {
  let q = $.replace(/^0x/, "");
  if (q.length % 2 !== 0) throw Error("Invalid hex string length");
  let K = new Uint8Array(q.length / 2);
  for (let P = 0; P < q.length; P += 2) K[P / 2] = Number.parseInt(q.slice(P, P + 2), 16);
  return K;
}
__name(DI, "DI");
function LI($) {
  return Array.from($).map((q) => q.toString(16).padStart(2, "0")).join("");
}
__name(LI, "LI");
var _bX = class _bX {
  constructor(...$) {
  }
};
__name(_bX, "bX");
var bX = _bX;
var yX = /* @__PURE__ */ __name(($, q) => {
  $.name = "$ZodError", Object.defineProperty($, "_zod", { value: $._zod, enumerable: false }), Object.defineProperty($, "issues", { value: q, enumerable: false }), $.message = JSON.stringify(q, U_, 2), Object.defineProperty($, "toString", { value: /* @__PURE__ */ __name(() => $.message, "value"), enumerable: false });
}, "yX");
var yP = O$("$ZodError", yX);
var Fq = O$("$ZodError", yX, { Parent: Error });
function uP($, q = (K) => K.message) {
  let K = {}, P = [];
  for (let _ of $.issues) if (_.path.length > 0) K[_.path[0]] = K[_.path[0]] || [], K[_.path[0]].push(q(_));
  else P.push(q(_));
  return { formErrors: P, fieldErrors: K };
}
__name(uP, "uP");
function xP($, q) {
  let K = q || function(Y) {
    return Y.message;
  }, P = { _errors: [] }, _ = /* @__PURE__ */ __name((Y) => {
    for (let O of Y.issues) if (O.code === "invalid_union" && O.errors.length) O.errors.map((z) => _({ issues: z }));
    else if (O.code === "invalid_key") _({ issues: O.issues });
    else if (O.code === "invalid_element") _({ issues: O.issues });
    else if (O.path.length === 0) P._errors.push(K(O));
    else {
      let z = P, J = 0;
      while (J < O.path.length) {
        let T = O.path[J];
        if (J !== O.path.length - 1) z[T] = z[T] || { _errors: [] };
        else z[T] = z[T] || { _errors: [] }, z[T]._errors.push(K(O));
        z = z[T], J++;
      }
    }
  }, "_");
  return _($), P;
}
__name(xP, "xP");
function $Y($, q) {
  let K = q || function(Y) {
    return Y.message;
  }, P = { errors: [] }, _ = /* @__PURE__ */ __name((Y, O = []) => {
    var z, J;
    for (let T of Y.issues) if (T.code === "invalid_union" && T.errors.length) T.errors.map((X) => _({ issues: X }, T.path));
    else if (T.code === "invalid_key") _({ issues: T.issues }, T.path);
    else if (T.code === "invalid_element") _({ issues: T.issues }, T.path);
    else {
      let X = [...O, ...T.path];
      if (X.length === 0) {
        P.errors.push(K(T));
        continue;
      }
      let f = P, V = 0;
      while (V < X.length) {
        let M = X[V], N = V === X.length - 1;
        if (typeof M === "string") f.properties ?? (f.properties = {}), (z = f.properties)[M] ?? (z[M] = { errors: [] }), f = f.properties[M];
        else f.items ?? (f.items = []), (J = f.items)[M] ?? (J[M] = { errors: [] }), f = f.items[M];
        if (N) f.errors.push(K(T));
        V++;
      }
    }
  }, "_");
  return _($), P;
}
__name($Y, "$Y");
function uX($) {
  let q = [], K = $.map((P) => typeof P === "object" ? P.key : P);
  for (let P of K) if (typeof P === "number") q.push(`[${P}]`);
  else if (typeof P === "symbol") q.push(`[${JSON.stringify(String(P))}]`);
  else if (/[^\w$]/.test(P)) q.push(`[${JSON.stringify(P)}]`);
  else {
    if (q.length) q.push(".");
    q.push(P);
  }
  return q.join("");
}
__name(uX, "uX");
function qY($) {
  let q = [], K = [...$.issues].sort((P, _) => (P.path ?? []).length - (_.path ?? []).length);
  for (let P of K) if (q.push(` ${P.message}`), P.path?.length) q.push(`   at ${uX(P.path)}`);
  return q.join(`
`);
}
__name(qY, "qY");
var Q_ = /* @__PURE__ */ __name(($) => (q, K, P, _) => {
  let Y = P ? Object.assign(P, { async: false }) : { async: false }, O = q._zod.run({ value: K, issues: [] }, Y);
  if (O instanceof Promise) throw new o8();
  if (O.issues.length) {
    let z = new (_?.Err ?? $)(O.issues.map((J) => Y8(J, Y, o6())));
    throw T9(z, _?.callee), z;
  }
  return O.value;
}, "Q_");
var pP = Q_(Fq);
var e_ = /* @__PURE__ */ __name(($) => async (q, K, P, _) => {
  let Y = P ? Object.assign(P, { async: true }) : { async: true }, O = q._zod.run({ value: K, issues: [] }, Y);
  if (O instanceof Promise) O = await O;
  if (O.issues.length) {
    let z = new (_?.Err ?? $)(O.issues.map((J) => Y8(J, Y, o6())));
    throw T9(z, _?.callee), z;
  }
  return O.value;
}, "e_");
var s_ = e_(Fq);
var $4 = /* @__PURE__ */ __name(($) => (q, K, P) => {
  let _ = P ? { ...P, async: false } : { async: false }, Y = q._zod.run({ value: K, issues: [] }, _);
  if (Y instanceof Promise) throw new o8();
  return Y.issues.length ? { success: false, error: new ($ ?? yP)(Y.issues.map((O) => Y8(O, _, o6()))) } : { success: true, data: Y.value };
}, "$4");
var KY = $4(Fq);
var q4 = /* @__PURE__ */ __name(($) => async (q, K, P) => {
  let _ = P ? Object.assign(P, { async: true }) : { async: true }, Y = q._zod.run({ value: K, issues: [] }, _);
  if (Y instanceof Promise) Y = await Y;
  return Y.issues.length ? { success: false, error: new $(Y.issues.map((O) => Y8(O, _, o6()))) } : { success: true, data: Y.value };
}, "q4");
var _Y = q4(Fq);
var w9 = /* @__PURE__ */ __name(($) => (q, K, P) => {
  let _ = P ? Object.assign(P, { direction: "backward" }) : { direction: "backward" };
  return Q_($)(q, K, _);
}, "w9");
var bI = w9(Fq);
var f9 = /* @__PURE__ */ __name(($) => (q, K, P) => {
  return Q_($)(q, K, P);
}, "f9");
var yI = f9(Fq);
var Z9 = /* @__PURE__ */ __name(($) => async (q, K, P) => {
  let _ = P ? Object.assign(P, { direction: "backward" }) : { direction: "backward" };
  return e_($)(q, K, _);
}, "Z9");
var uI = Z9(Fq);
var X9 = /* @__PURE__ */ __name(($) => async (q, K, P) => {
  return e_($)(q, K, P);
}, "X9");
var xI = X9(Fq);
var A9 = /* @__PURE__ */ __name(($) => (q, K, P) => {
  let _ = P ? Object.assign(P, { direction: "backward" }) : { direction: "backward" };
  return $4($)(q, K, _);
}, "A9");
var pI = A9(Fq);
var k9 = /* @__PURE__ */ __name(($) => (q, K, P) => {
  return $4($)(q, K, P);
}, "k9");
var cI = k9(Fq);
var G9 = /* @__PURE__ */ __name(($) => async (q, K, P) => {
  let _ = P ? Object.assign(P, { direction: "backward" }) : { direction: "backward" };
  return q4($)(q, K, _);
}, "G9");
var mI = G9(Fq);
var V9 = /* @__PURE__ */ __name(($) => async (q, K, P) => {
  return q4($)(q, K, P);
}, "V9");
var dI = V9(Fq);
var Z8 = {};
rq(Z8, { xid: /* @__PURE__ */ __name(() => jY, "xid"), uuid7: /* @__PURE__ */ __name(() => nI, "uuid7"), uuid6: /* @__PURE__ */ __name(() => oI, "uuid6"), uuid4: /* @__PURE__ */ __name(() => rI, "uuid4"), uuid: /* @__PURE__ */ __name(() => f_, "uuid"), uppercase: /* @__PURE__ */ __name(() => gY, "uppercase"), unicodeEmail: /* @__PURE__ */ __name(() => xX, "unicodeEmail"), undefined: /* @__PURE__ */ __name(() => DY, "undefined"), ulid: /* @__PURE__ */ __name(() => YY, "ulid"), time: /* @__PURE__ */ __name(() => SY, "time"), string: /* @__PURE__ */ __name(() => NY, "string"), sha512_hex: /* @__PURE__ */ __name(() => zD, "sha512_hex"), sha512_base64url: /* @__PURE__ */ __name(() => HD, "sha512_base64url"), sha512_base64: /* @__PURE__ */ __name(() => WD, "sha512_base64"), sha384_hex: /* @__PURE__ */ __name(() => YD, "sha384_hex"), sha384_base64url: /* @__PURE__ */ __name(() => vD, "sha384_base64url"), sha384_base64: /* @__PURE__ */ __name(() => jD, "sha384_base64"), sha256_hex: /* @__PURE__ */ __name(() => _D, "sha256_hex"), sha256_base64url: /* @__PURE__ */ __name(() => OD, "sha256_base64url"), sha256_base64: /* @__PURE__ */ __name(() => PD, "sha256_base64"), sha1_hex: /* @__PURE__ */ __name(() => $D, "sha1_hex"), sha1_base64url: /* @__PURE__ */ __name(() => KD, "sha1_base64url"), sha1_base64: /* @__PURE__ */ __name(() => qD, "sha1_base64"), rfc5322Email: /* @__PURE__ */ __name(() => tI, "rfc5322Email"), number: /* @__PURE__ */ __name(() => EY, "number"), null: /* @__PURE__ */ __name(() => IY, "null"), nanoid: /* @__PURE__ */ __name(() => zY, "nanoid"), md5_hex: /* @__PURE__ */ __name(() => QI, "md5_hex"), md5_base64url: /* @__PURE__ */ __name(() => sI, "md5_base64url"), md5_base64: /* @__PURE__ */ __name(() => eI, "md5_base64"), lowercase: /* @__PURE__ */ __name(() => LY, "lowercase"), ksuid: /* @__PURE__ */ __name(() => vY, "ksuid"), ipv6: /* @__PURE__ */ __name(() => fY, "ipv6"), ipv4: /* @__PURE__ */ __name(() => wY, "ipv4"), integer: /* @__PURE__ */ __name(() => hY, "integer"), idnEmail: /* @__PURE__ */ __name(() => BI, "idnEmail"), html5Email: /* @__PURE__ */ __name(() => iI, "html5Email"), hostname: /* @__PURE__ */ __name(() => kY, "hostname"), hex: /* @__PURE__ */ __name(() => aI, "hex"), guid: /* @__PURE__ */ __name(() => HY, "guid"), extendedDuration: /* @__PURE__ */ __name(() => lI, "extendedDuration"), emoji: /* @__PURE__ */ __name(() => TY, "emoji"), email: /* @__PURE__ */ __name(() => JY, "email"), e164: /* @__PURE__ */ __name(() => GY, "e164"), duration: /* @__PURE__ */ __name(() => WY, "duration"), domain: /* @__PURE__ */ __name(() => FI, "domain"), datetime: /* @__PURE__ */ __name(() => MY, "datetime"), date: /* @__PURE__ */ __name(() => VY, "date"), cuid2: /* @__PURE__ */ __name(() => OY, "cuid2"), cuid: /* @__PURE__ */ __name(() => PY, "cuid"), cidrv6: /* @__PURE__ */ __name(() => XY, "cidrv6"), cidrv4: /* @__PURE__ */ __name(() => ZY, "cidrv4"), browserEmail: /* @__PURE__ */ __name(() => UI, "browserEmail"), boolean: /* @__PURE__ */ __name(() => RY, "boolean"), bigint: /* @__PURE__ */ __name(() => CY, "bigint"), base64url: /* @__PURE__ */ __name(() => S9, "base64url"), base64: /* @__PURE__ */ __name(() => AY, "base64") });
var PY = /^[cC][^\s-]{8,}$/;
var OY = /^[0-9a-z]+$/;
var YY = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/;
var jY = /^[0-9a-vA-V]{20}$/;
var vY = /^[A-Za-z0-9]{27}$/;
var zY = /^[a-zA-Z0-9_-]{21}$/;
var WY = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/;
var lI = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
var HY = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/;
var f_ = /* @__PURE__ */ __name(($) => {
  if (!$) return /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/;
  return new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${$}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`);
}, "f_");
var rI = f_(4);
var oI = f_(6);
var nI = f_(7);
var JY = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/;
var iI = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
var tI = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
var xX = /^[^\s@"]{1,64}@[^\s@]{1,255}$/u;
var BI = xX;
var UI = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
function TY() {
  return new RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", "u");
}
__name(TY, "TY");
var wY = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
var fY = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$/;
var ZY = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/;
var XY = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
var AY = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/;
var S9 = /^[A-Za-z0-9_-]*$/;
var kY = /^(?=.{1,253}\.?$)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[-0-9a-zA-Z]{0,61}[0-9a-zA-Z])?)*\.?$/;
var FI = /^([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$/;
var GY = /^\+(?:[0-9]){6,14}[0-9]$/;
var pX = "(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))";
var VY = new RegExp(`^${pX}$`);
function cX($) {
  return typeof $.precision === "number" ? $.precision === -1 ? "(?:[01]\\d|2[0-3]):[0-5]\\d" : $.precision === 0 ? "(?:[01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d" : `(?:[01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d\\.\\d{${$.precision}}` : "(?:[01]\\d|2[0-3]):[0-5]\\d(?::[0-5]\\d(?:\\.\\d+)?)?";
}
__name(cX, "cX");
function SY($) {
  return new RegExp(`^${cX($)}$`);
}
__name(SY, "SY");
function MY($) {
  let q = cX({ precision: $.precision }), K = ["Z"];
  if ($.local) K.push("");
  if ($.offset) K.push("([+-](?:[01]\\d|2[0-3]):[0-5]\\d)");
  let P = `${q}(?:${K.join("|")})`;
  return new RegExp(`^${pX}T(?:${P})$`);
}
__name(MY, "MY");
var NY = /* @__PURE__ */ __name(($) => {
  let q = $ ? `[\\s\\S]{${$?.minimum ?? 0},${$?.maximum ?? ""}}` : "[\\s\\S]*";
  return new RegExp(`^${q}$`);
}, "NY");
var CY = /^-?\d+n?$/;
var hY = /^-?\d+$/;
var EY = /^-?\d+(?:\.\d+)?/;
var RY = /^(?:true|false)$/i;
var IY = /^null$/i;
var DY = /^undefined$/i;
var LY = /^[^A-Z]*$/;
var gY = /^[^a-z]*$/;
var aI = /^[0-9a-fA-F]*$/;
function cP($, q) {
  return new RegExp(`^[A-Za-z0-9+/]{${$}}${q}$`);
}
__name(cP, "cP");
function mP($) {
  return new RegExp(`^[A-Za-z0-9_-]{${$}}$`);
}
__name(mP, "mP");
var QI = /^[0-9a-fA-F]{32}$/;
var eI = cP(22, "==");
var sI = mP(22);
var $D = /^[0-9a-fA-F]{40}$/;
var qD = cP(27, "=");
var KD = mP(27);
var _D = /^[0-9a-fA-F]{64}$/;
var PD = cP(43, "=");
var OD = mP(43);
var YD = /^[0-9a-fA-F]{96}$/;
var jD = cP(64, "");
var vD = mP(64);
var zD = /^[0-9a-fA-F]{128}$/;
var WD = cP(86, "==");
var HD = mP(86);
var I6 = O$("$ZodCheck", ($, q) => {
  var K;
  $._zod ?? ($._zod = {}), $._zod.def = q, (K = $._zod).onattach ?? (K.onattach = []);
});
var dX = { number: "number", bigint: "bigint", object: "date" };
var M9 = O$("$ZodCheckLessThan", ($, q) => {
  I6.init($, q);
  let K = dX[typeof q.value];
  $._zod.onattach.push((P) => {
    let _ = P._zod.bag, Y = (q.inclusive ? _.maximum : _.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;
    if (q.value < Y) if (q.inclusive) _.maximum = q.value;
    else _.exclusiveMaximum = q.value;
  }), $._zod.check = (P) => {
    if (q.inclusive ? P.value <= q.value : P.value < q.value) return;
    P.issues.push({ origin: K, code: "too_big", maximum: q.value, input: P.value, inclusive: q.inclusive, inst: $, continue: !q.abort });
  };
});
var N9 = O$("$ZodCheckGreaterThan", ($, q) => {
  I6.init($, q);
  let K = dX[typeof q.value];
  $._zod.onattach.push((P) => {
    let _ = P._zod.bag, Y = (q.inclusive ? _.minimum : _.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;
    if (q.value > Y) if (q.inclusive) _.minimum = q.value;
    else _.exclusiveMinimum = q.value;
  }), $._zod.check = (P) => {
    if (q.inclusive ? P.value >= q.value : P.value > q.value) return;
    P.issues.push({ origin: K, code: "too_small", minimum: q.value, input: P.value, inclusive: q.inclusive, inst: $, continue: !q.abort });
  };
});
var bY = O$("$ZodCheckMultipleOf", ($, q) => {
  I6.init($, q), $._zod.onattach.push((K) => {
    var P;
    (P = K._zod.bag).multipleOf ?? (P.multipleOf = q.value);
  }), $._zod.check = (K) => {
    if (typeof K.value !== typeof q.value) throw Error("Cannot mix number and bigint in multiple_of check.");
    if (typeof K.value === "bigint" ? K.value % q.value === BigInt(0) : B2(K.value, q.value) === 0) return;
    K.issues.push({ origin: typeof K.value, code: "not_multiple_of", divisor: q.value, input: K.value, inst: $, continue: !q.abort });
  };
});
var yY = O$("$ZodCheckNumberFormat", ($, q) => {
  I6.init($, q), q.format = q.format || "float64";
  let K = q.format?.includes("int"), P = K ? "int" : "number", [_, Y] = e2[q.format];
  $._zod.onattach.push((O) => {
    let z = O._zod.bag;
    if (z.format = q.format, z.minimum = _, z.maximum = Y, K) z.pattern = hY;
  }), $._zod.check = (O) => {
    let z = O.value;
    if (K) {
      if (!Number.isInteger(z)) {
        O.issues.push({ expected: P, format: q.format, code: "invalid_type", continue: false, input: z, inst: $ });
        return;
      }
      if (!Number.isSafeInteger(z)) {
        if (z > 0) O.issues.push({ input: z, code: "too_big", maximum: Number.MAX_SAFE_INTEGER, note: "Integers must be within the safe integer range.", inst: $, origin: P, continue: !q.abort });
        else O.issues.push({ input: z, code: "too_small", minimum: Number.MIN_SAFE_INTEGER, note: "Integers must be within the safe integer range.", inst: $, origin: P, continue: !q.abort });
        return;
      }
    }
    if (z < _) O.issues.push({ origin: "number", input: z, code: "too_small", minimum: _, inclusive: true, inst: $, continue: !q.abort });
    if (z > Y) O.issues.push({ origin: "number", input: z, code: "too_big", maximum: Y, inst: $ });
  };
});
var uY = O$("$ZodCheckBigIntFormat", ($, q) => {
  I6.init($, q);
  let [K, P] = s2[q.format];
  $._zod.onattach.push((_) => {
    let Y = _._zod.bag;
    Y.format = q.format, Y.minimum = K, Y.maximum = P;
  }), $._zod.check = (_) => {
    let Y = _.value;
    if (Y < K) _.issues.push({ origin: "bigint", input: Y, code: "too_small", minimum: K, inclusive: true, inst: $, continue: !q.abort });
    if (Y > P) _.issues.push({ origin: "bigint", input: Y, code: "too_big", maximum: P, inst: $ });
  };
});
var xY = O$("$ZodCheckMaxSize", ($, q) => {
  var K;
  I6.init($, q), (K = $._zod.def).when ?? (K.when = (P) => {
    let _ = P.value;
    return !mK(_) && _.size !== void 0;
  }), $._zod.onattach.push((P) => {
    let _ = P._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    if (q.maximum < _) P._zod.bag.maximum = q.maximum;
  }), $._zod.check = (P) => {
    let _ = P.value;
    if (_.size <= q.maximum) return;
    P.issues.push({ origin: gP(_), code: "too_big", maximum: q.maximum, inclusive: true, input: _, inst: $, continue: !q.abort });
  };
});
var pY = O$("$ZodCheckMinSize", ($, q) => {
  var K;
  I6.init($, q), (K = $._zod.def).when ?? (K.when = (P) => {
    let _ = P.value;
    return !mK(_) && _.size !== void 0;
  }), $._zod.onattach.push((P) => {
    let _ = P._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    if (q.minimum > _) P._zod.bag.minimum = q.minimum;
  }), $._zod.check = (P) => {
    let _ = P.value;
    if (_.size >= q.minimum) return;
    P.issues.push({ origin: gP(_), code: "too_small", minimum: q.minimum, inclusive: true, input: _, inst: $, continue: !q.abort });
  };
});
var cY = O$("$ZodCheckSizeEquals", ($, q) => {
  var K;
  I6.init($, q), (K = $._zod.def).when ?? (K.when = (P) => {
    let _ = P.value;
    return !mK(_) && _.size !== void 0;
  }), $._zod.onattach.push((P) => {
    let _ = P._zod.bag;
    _.minimum = q.size, _.maximum = q.size, _.size = q.size;
  }), $._zod.check = (P) => {
    let _ = P.value, Y = _.size;
    if (Y === q.size) return;
    let O = Y > q.size;
    P.issues.push({ origin: gP(_), ...O ? { code: "too_big", maximum: q.size } : { code: "too_small", minimum: q.size }, inclusive: true, exact: true, input: P.value, inst: $, continue: !q.abort });
  };
});
var mY = O$("$ZodCheckMaxLength", ($, q) => {
  var K;
  I6.init($, q), (K = $._zod.def).when ?? (K.when = (P) => {
    let _ = P.value;
    return !mK(_) && _.length !== void 0;
  }), $._zod.onattach.push((P) => {
    let _ = P._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    if (q.maximum < _) P._zod.bag.maximum = q.maximum;
  }), $._zod.check = (P) => {
    let _ = P.value;
    if (_.length <= q.maximum) return;
    let O = bP(_);
    P.issues.push({ origin: O, code: "too_big", maximum: q.maximum, inclusive: true, input: _, inst: $, continue: !q.abort });
  };
});
var dY = O$("$ZodCheckMinLength", ($, q) => {
  var K;
  I6.init($, q), (K = $._zod.def).when ?? (K.when = (P) => {
    let _ = P.value;
    return !mK(_) && _.length !== void 0;
  }), $._zod.onattach.push((P) => {
    let _ = P._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    if (q.minimum > _) P._zod.bag.minimum = q.minimum;
  }), $._zod.check = (P) => {
    let _ = P.value;
    if (_.length >= q.minimum) return;
    let O = bP(_);
    P.issues.push({ origin: O, code: "too_small", minimum: q.minimum, inclusive: true, input: _, inst: $, continue: !q.abort });
  };
});
var lY = O$("$ZodCheckLengthEquals", ($, q) => {
  var K;
  I6.init($, q), (K = $._zod.def).when ?? (K.when = (P) => {
    let _ = P.value;
    return !mK(_) && _.length !== void 0;
  }), $._zod.onattach.push((P) => {
    let _ = P._zod.bag;
    _.minimum = q.length, _.maximum = q.length, _.length = q.length;
  }), $._zod.check = (P) => {
    let _ = P.value, Y = _.length;
    if (Y === q.length) return;
    let O = bP(_), z = Y > q.length;
    P.issues.push({ origin: O, ...z ? { code: "too_big", maximum: q.length } : { code: "too_small", minimum: q.length }, inclusive: true, exact: true, input: P.value, inst: $, continue: !q.abort });
  };
});
var K4 = O$("$ZodCheckStringFormat", ($, q) => {
  var K, P;
  if (I6.init($, q), $._zod.onattach.push((_) => {
    let Y = _._zod.bag;
    if (Y.format = q.format, q.pattern) Y.patterns ?? (Y.patterns = /* @__PURE__ */ new Set()), Y.patterns.add(q.pattern);
  }), q.pattern) (K = $._zod).check ?? (K.check = (_) => {
    if (q.pattern.lastIndex = 0, q.pattern.test(_.value)) return;
    _.issues.push({ origin: "string", code: "invalid_format", format: q.format, input: _.value, ...q.pattern ? { pattern: q.pattern.toString() } : {}, inst: $, continue: !q.abort });
  });
  else (P = $._zod).check ?? (P.check = () => {
  });
});
var rY = O$("$ZodCheckRegex", ($, q) => {
  K4.init($, q), $._zod.check = (K) => {
    if (q.pattern.lastIndex = 0, q.pattern.test(K.value)) return;
    K.issues.push({ origin: "string", code: "invalid_format", format: "regex", input: K.value, pattern: q.pattern.toString(), inst: $, continue: !q.abort });
  };
});
var oY = O$("$ZodCheckLowerCase", ($, q) => {
  q.pattern ?? (q.pattern = LY), K4.init($, q);
});
var nY = O$("$ZodCheckUpperCase", ($, q) => {
  q.pattern ?? (q.pattern = gY), K4.init($, q);
});
var iY = O$("$ZodCheckIncludes", ($, q) => {
  I6.init($, q);
  let K = n8(q.includes), P = new RegExp(typeof q.position === "number" ? `^.{${q.position}}${K}` : K);
  q.pattern = P, $._zod.onattach.push((_) => {
    let Y = _._zod.bag;
    Y.patterns ?? (Y.patterns = /* @__PURE__ */ new Set()), Y.patterns.add(P);
  }), $._zod.check = (_) => {
    if (_.value.includes(q.includes, q.position)) return;
    _.issues.push({ origin: "string", code: "invalid_format", format: "includes", includes: q.includes, input: _.value, inst: $, continue: !q.abort });
  };
});
var tY = O$("$ZodCheckStartsWith", ($, q) => {
  I6.init($, q);
  let K = new RegExp(`^${n8(q.prefix)}.*`);
  q.pattern ?? (q.pattern = K), $._zod.onattach.push((P) => {
    let _ = P._zod.bag;
    _.patterns ?? (_.patterns = /* @__PURE__ */ new Set()), _.patterns.add(K);
  }), $._zod.check = (P) => {
    if (P.value.startsWith(q.prefix)) return;
    P.issues.push({ origin: "string", code: "invalid_format", format: "starts_with", prefix: q.prefix, input: P.value, inst: $, continue: !q.abort });
  };
});
var BY = O$("$ZodCheckEndsWith", ($, q) => {
  I6.init($, q);
  let K = new RegExp(`.*${n8(q.suffix)}$`);
  q.pattern ?? (q.pattern = K), $._zod.onattach.push((P) => {
    let _ = P._zod.bag;
    _.patterns ?? (_.patterns = /* @__PURE__ */ new Set()), _.patterns.add(K);
  }), $._zod.check = (P) => {
    if (P.value.endsWith(q.suffix)) return;
    P.issues.push({ origin: "string", code: "invalid_format", format: "ends_with", suffix: q.suffix, input: P.value, inst: $, continue: !q.abort });
  };
});
function mX($, q, K) {
  if ($.issues.length) q.issues.push(...O8(K, $.issues));
}
__name(mX, "mX");
var UY = O$("$ZodCheckProperty", ($, q) => {
  I6.init($, q), $._zod.check = (K) => {
    let P = q.schema._zod.run({ value: K.value[q.property], issues: [] }, {});
    if (P instanceof Promise) return P.then((_) => mX(_, K, q.property));
    mX(P, K, q.property);
    return;
  };
});
var FY = O$("$ZodCheckMimeType", ($, q) => {
  I6.init($, q);
  let K = new Set(q.mime);
  $._zod.onattach.push((P) => {
    P._zod.bag.mime = q.mime;
  }), $._zod.check = (P) => {
    if (K.has(P.value.type)) return;
    P.issues.push({ code: "invalid_value", values: q.mime, input: P.value.type, inst: $, continue: !q.abort });
  };
});
var aY = O$("$ZodCheckOverwrite", ($, q) => {
  I6.init($, q), $._zod.check = (K) => {
    K.value = q.tx(K.value);
  };
});
var _C9 = class _C9 {
  constructor($ = []) {
    if (this.content = [], this.indent = 0, this) this.args = $;
  }
  indented($) {
    this.indent += 1, $(this), this.indent -= 1;
  }
  write($) {
    if (typeof $ === "function") {
      $(this, { execution: "sync" }), $(this, { execution: "async" });
      return;
    }
    let K = $.split(`
`).filter((Y) => Y), P = Math.min(...K.map((Y) => Y.length - Y.trimStart().length)), _ = K.map((Y) => Y.slice(P)).map((Y) => " ".repeat(this.indent * 2) + Y);
    for (let Y of _) this.content.push(Y);
  }
  compile() {
    let $ = Function, q = this?.args, P = [...(this?.content ?? [""]).map((_) => `  ${_}`)];
    return new $(...q, P.join(`
`));
  }
};
__name(_C9, "C9");
var C9 = _C9;
var QY = { major: 4, minor: 1, patch: 11 };
var P6 = O$("$ZodType", ($, q) => {
  var K;
  $ ?? ($ = {}), $._zod.def = q, $._zod.bag = $._zod.bag || {}, $._zod.version = QY;
  let P = [...$._zod.def.checks ?? []];
  if ($._zod.traits.has("$ZodCheck")) P.unshift($);
  for (let _ of P) for (let Y of _._zod.onattach) Y($);
  if (P.length === 0) (K = $._zod).deferred ?? (K.deferred = []), $._zod.deferred?.push(() => {
    $._zod.run = $._zod.parse;
  });
  else {
    let _ = /* @__PURE__ */ __name((O, z, J) => {
      let T = oK(O), X;
      for (let f of z) {
        if (f._zod.def.when) {
          if (!f._zod.def.when(O)) continue;
        } else if (T) continue;
        let V = O.issues.length, M = f._zod.check(O);
        if (M instanceof Promise && J?.async === false) throw new o8();
        if (X || M instanceof Promise) X = (X ?? Promise.resolve()).then(async () => {
          if (await M, O.issues.length === V) return;
          if (!T) T = oK(O, V);
        });
        else {
          if (O.issues.length === V) continue;
          if (!T) T = oK(O, V);
        }
      }
      if (X) return X.then(() => {
        return O;
      });
      return O;
    }, "_"), Y = /* @__PURE__ */ __name((O, z, J) => {
      if (oK(O)) return O.aborted = true, O;
      let T = _(z, P, J);
      if (T instanceof Promise) {
        if (J.async === false) throw new o8();
        return T.then((X) => $._zod.parse(X, J));
      }
      return $._zod.parse(T, J);
    }, "Y");
    $._zod.run = (O, z) => {
      if (z.skipChecks) return $._zod.parse(O, z);
      if (z.direction === "backward") {
        let T = $._zod.parse({ value: O.value, issues: [] }, { ...z, skipChecks: true });
        if (T instanceof Promise) return T.then((X) => {
          return Y(X, O, z);
        });
        return Y(T, O, z);
      }
      let J = $._zod.parse(O, z);
      if (J instanceof Promise) {
        if (z.async === false) throw new o8();
        return J.then((T) => _(T, P, z));
      }
      return _(J, P, z);
    };
  }
  $["~standard"] = { validate: /* @__PURE__ */ __name((_) => {
    try {
      let Y = KY($, _);
      return Y.success ? { value: Y.data } : { issues: Y.error?.issues };
    } catch (Y) {
      return _Y($, _).then((O) => O.success ? { value: O.data } : { issues: O.error?.issues });
    }
  }, "validate"), vendor: "zod", version: 1 };
});
var Z_ = O$("$ZodString", ($, q) => {
  P6.init($, q), $._zod.pattern = [...$?._zod.bag?.patterns ?? []].pop() ?? NY($._zod.bag), $._zod.parse = (K, P) => {
    if (q.coerce) try {
      K.value = String(K.value);
    } catch (_) {
    }
    if (typeof K.value === "string") return K;
    return K.issues.push({ expected: "string", code: "invalid_type", input: K.value, inst: $ }), K;
  };
});
var h6 = O$("$ZodStringFormat", ($, q) => {
  K4.init($, q), Z_.init($, q);
});
var sY = O$("$ZodGUID", ($, q) => {
  q.pattern ?? (q.pattern = HY), h6.init($, q);
});
var $j = O$("$ZodUUID", ($, q) => {
  if (q.version) {
    let P = { v1: 1, v2: 2, v3: 3, v4: 4, v5: 5, v6: 6, v7: 7, v8: 8 }[q.version];
    if (P === void 0) throw Error(`Invalid UUID version: "${q.version}"`);
    q.pattern ?? (q.pattern = f_(P));
  } else q.pattern ?? (q.pattern = f_());
  h6.init($, q);
});
var qj = O$("$ZodEmail", ($, q) => {
  q.pattern ?? (q.pattern = JY), h6.init($, q);
});
var Kj = O$("$ZodURL", ($, q) => {
  h6.init($, q), $._zod.check = (K) => {
    try {
      let P = K.value.trim(), _ = new URL(P);
      if (q.hostname) {
        if (q.hostname.lastIndex = 0, !q.hostname.test(_.hostname)) K.issues.push({ code: "invalid_format", format: "url", note: "Invalid hostname", pattern: kY.source, input: K.value, inst: $, continue: !q.abort });
      }
      if (q.protocol) {
        if (q.protocol.lastIndex = 0, !q.protocol.test(_.protocol.endsWith(":") ? _.protocol.slice(0, -1) : _.protocol)) K.issues.push({ code: "invalid_format", format: "url", note: "Invalid protocol", pattern: q.protocol.source, input: K.value, inst: $, continue: !q.abort });
      }
      if (q.normalize) K.value = _.href;
      else K.value = P;
      return;
    } catch (P) {
      K.issues.push({ code: "invalid_format", format: "url", input: K.value, inst: $, continue: !q.abort });
    }
  };
});
var _j = O$("$ZodEmoji", ($, q) => {
  q.pattern ?? (q.pattern = TY()), h6.init($, q);
});
var Pj = O$("$ZodNanoID", ($, q) => {
  q.pattern ?? (q.pattern = zY), h6.init($, q);
});
var Oj = O$("$ZodCUID", ($, q) => {
  q.pattern ?? (q.pattern = PY), h6.init($, q);
});
var Yj = O$("$ZodCUID2", ($, q) => {
  q.pattern ?? (q.pattern = OY), h6.init($, q);
});
var jj = O$("$ZodULID", ($, q) => {
  q.pattern ?? (q.pattern = YY), h6.init($, q);
});
var vj = O$("$ZodXID", ($, q) => {
  q.pattern ?? (q.pattern = jY), h6.init($, q);
});
var zj = O$("$ZodKSUID", ($, q) => {
  q.pattern ?? (q.pattern = vY), h6.init($, q);
});
var Wj = O$("$ZodISODateTime", ($, q) => {
  q.pattern ?? (q.pattern = MY(q)), h6.init($, q);
});
var Hj = O$("$ZodISODate", ($, q) => {
  q.pattern ?? (q.pattern = VY), h6.init($, q);
});
var Jj = O$("$ZodISOTime", ($, q) => {
  q.pattern ?? (q.pattern = SY(q)), h6.init($, q);
});
var Tj = O$("$ZodISODuration", ($, q) => {
  q.pattern ?? (q.pattern = WY), h6.init($, q);
});
var wj = O$("$ZodIPv4", ($, q) => {
  q.pattern ?? (q.pattern = wY), h6.init($, q), $._zod.onattach.push((K) => {
    let P = K._zod.bag;
    P.format = "ipv4";
  });
});
var fj = O$("$ZodIPv6", ($, q) => {
  q.pattern ?? (q.pattern = fY), h6.init($, q), $._zod.onattach.push((K) => {
    let P = K._zod.bag;
    P.format = "ipv6";
  }), $._zod.check = (K) => {
    try {
      new URL(`http://[${K.value}]`);
    } catch {
      K.issues.push({ code: "invalid_format", format: "ipv6", input: K.value, inst: $, continue: !q.abort });
    }
  };
});
var Zj = O$("$ZodCIDRv4", ($, q) => {
  q.pattern ?? (q.pattern = ZY), h6.init($, q);
});
var Xj = O$("$ZodCIDRv6", ($, q) => {
  q.pattern ?? (q.pattern = XY), h6.init($, q), $._zod.check = (K) => {
    let P = K.value.split("/");
    try {
      if (P.length !== 2) throw Error();
      let [_, Y] = P;
      if (!Y) throw Error();
      let O = Number(Y);
      if (`${O}` !== Y) throw Error();
      if (O < 0 || O > 128) throw Error();
      new URL(`http://[${_}]`);
    } catch {
      K.issues.push({ code: "invalid_format", format: "cidrv6", input: K.value, inst: $, continue: !q.abort });
    }
  };
});
function Aj($) {
  if ($ === "") return true;
  if ($.length % 4 !== 0) return false;
  try {
    return atob($), true;
  } catch {
    return false;
  }
}
__name(Aj, "Aj");
var kj = O$("$ZodBase64", ($, q) => {
  q.pattern ?? (q.pattern = AY), h6.init($, q), $._zod.onattach.push((K) => {
    K._zod.bag.contentEncoding = "base64";
  }), $._zod.check = (K) => {
    if (Aj(K.value)) return;
    K.issues.push({ code: "invalid_format", format: "base64", input: K.value, inst: $, continue: !q.abort });
  };
});
function eX($) {
  if (!S9.test($)) return false;
  let q = $.replace(/[-_]/g, (P) => P === "-" ? "+" : "/"), K = q.padEnd(Math.ceil(q.length / 4) * 4, "=");
  return Aj(K);
}
__name(eX, "eX");
var Gj = O$("$ZodBase64URL", ($, q) => {
  q.pattern ?? (q.pattern = S9), h6.init($, q), $._zod.onattach.push((K) => {
    K._zod.bag.contentEncoding = "base64url";
  }), $._zod.check = (K) => {
    if (eX(K.value)) return;
    K.issues.push({ code: "invalid_format", format: "base64url", input: K.value, inst: $, continue: !q.abort });
  };
});
var Vj = O$("$ZodE164", ($, q) => {
  q.pattern ?? (q.pattern = GY), h6.init($, q);
});
function sX($, q = null) {
  try {
    let K = $.split(".");
    if (K.length !== 3) return false;
    let [P] = K;
    if (!P) return false;
    let _ = JSON.parse(atob(P));
    if ("typ" in _ && _?.typ !== "JWT") return false;
    if (!_.alg) return false;
    if (q && (!("alg" in _) || _.alg !== q)) return false;
    return true;
  } catch {
    return false;
  }
}
__name(sX, "sX");
var Sj = O$("$ZodJWT", ($, q) => {
  h6.init($, q), $._zod.check = (K) => {
    if (sX(K.value, q.alg)) return;
    K.issues.push({ code: "invalid_format", format: "jwt", input: K.value, inst: $, continue: !q.abort });
  };
});
var Mj = O$("$ZodCustomStringFormat", ($, q) => {
  h6.init($, q), $._zod.check = (K) => {
    if (q.fn(K.value)) return;
    K.issues.push({ code: "invalid_format", format: q.format, input: K.value, inst: $, continue: !q.abort });
  };
});
var L9 = O$("$ZodNumber", ($, q) => {
  P6.init($, q), $._zod.pattern = $._zod.bag.pattern ?? EY, $._zod.parse = (K, P) => {
    if (q.coerce) try {
      K.value = Number(K.value);
    } catch (O) {
    }
    let _ = K.value;
    if (typeof _ === "number" && !Number.isNaN(_) && Number.isFinite(_)) return K;
    let Y = typeof _ === "number" ? Number.isNaN(_) ? "NaN" : !Number.isFinite(_) ? "Infinity" : void 0 : void 0;
    return K.issues.push({ expected: "number", code: "invalid_type", input: _, inst: $, ...Y ? { received: Y } : {} }), K;
  };
});
var Nj = O$("$ZodNumber", ($, q) => {
  yY.init($, q), L9.init($, q);
});
var dP = O$("$ZodBoolean", ($, q) => {
  P6.init($, q), $._zod.pattern = RY, $._zod.parse = (K, P) => {
    if (q.coerce) try {
      K.value = Boolean(K.value);
    } catch (Y) {
    }
    let _ = K.value;
    if (typeof _ === "boolean") return K;
    return K.issues.push({ expected: "boolean", code: "invalid_type", input: _, inst: $ }), K;
  };
});
var g9 = O$("$ZodBigInt", ($, q) => {
  P6.init($, q), $._zod.pattern = CY, $._zod.parse = (K, P) => {
    if (q.coerce) try {
      K.value = BigInt(K.value);
    } catch (_) {
    }
    if (typeof K.value === "bigint") return K;
    return K.issues.push({ expected: "bigint", code: "invalid_type", input: K.value, inst: $ }), K;
  };
});
var Cj = O$("$ZodBigInt", ($, q) => {
  uY.init($, q), g9.init($, q);
});
var hj = O$("$ZodSymbol", ($, q) => {
  P6.init($, q), $._zod.parse = (K, P) => {
    let _ = K.value;
    if (typeof _ === "symbol") return K;
    return K.issues.push({ expected: "symbol", code: "invalid_type", input: _, inst: $ }), K;
  };
});
var Ej = O$("$ZodUndefined", ($, q) => {
  P6.init($, q), $._zod.pattern = DY, $._zod.values = /* @__PURE__ */ new Set([void 0]), $._zod.optin = "optional", $._zod.optout = "optional", $._zod.parse = (K, P) => {
    let _ = K.value;
    if (typeof _ > "u") return K;
    return K.issues.push({ expected: "undefined", code: "invalid_type", input: _, inst: $ }), K;
  };
});
var Rj = O$("$ZodNull", ($, q) => {
  P6.init($, q), $._zod.pattern = IY, $._zod.values = /* @__PURE__ */ new Set([null]), $._zod.parse = (K, P) => {
    let _ = K.value;
    if (_ === null) return K;
    return K.issues.push({ expected: "null", code: "invalid_type", input: _, inst: $ }), K;
  };
});
var Ij = O$("$ZodAny", ($, q) => {
  P6.init($, q), $._zod.parse = (K) => K;
});
var b9 = O$("$ZodUnknown", ($, q) => {
  P6.init($, q), $._zod.parse = (K) => K;
});
var lP = O$("$ZodNever", ($, q) => {
  P6.init($, q), $._zod.parse = (K, P) => {
    return K.issues.push({ expected: "never", code: "invalid_type", input: K.value, inst: $ }), K;
  };
});
var Dj = O$("$ZodVoid", ($, q) => {
  P6.init($, q), $._zod.parse = (K, P) => {
    let _ = K.value;
    if (typeof _ > "u") return K;
    return K.issues.push({ expected: "void", code: "invalid_type", input: _, inst: $ }), K;
  };
});
var Lj = O$("$ZodDate", ($, q) => {
  P6.init($, q), $._zod.parse = (K, P) => {
    if (q.coerce) try {
      K.value = new Date(K.value);
    } catch (z) {
    }
    let _ = K.value, Y = _ instanceof Date;
    if (Y && !Number.isNaN(_.getTime())) return K;
    return K.issues.push({ expected: "date", code: "invalid_type", input: _, ...Y ? { received: "Invalid Date" } : {}, inst: $ }), K;
  };
});
function rX($, q, K) {
  if ($.issues.length) q.issues.push(...O8(K, $.issues));
  q.value[K] = $.value;
}
__name(rX, "rX");
var gj = O$("$ZodArray", ($, q) => {
  P6.init($, q), $._zod.parse = (K, P) => {
    let _ = K.value;
    if (!Array.isArray(_)) return K.issues.push({ expected: "array", code: "invalid_type", input: _, inst: $ }), K;
    K.value = Array(_.length);
    let Y = [];
    for (let O = 0; O < _.length; O++) {
      let z = _[O], J = q.element._zod.run({ value: z, issues: [] }, P);
      if (J instanceof Promise) Y.push(J.then((T) => rX(T, K, O)));
      else rX(J, K, O);
    }
    if (Y.length) return Promise.all(Y).then(() => K);
    return K;
  };
});
function D9($, q, K, P) {
  if ($.issues.length) q.issues.push(...O8(K, $.issues));
  if ($.value === void 0) {
    if (K in P) q.value[K] = void 0;
  } else q.value[K] = $.value;
}
__name(D9, "D9");
function $A($) {
  let q = Object.keys($.shape);
  for (let P of q) if (!$.shape?.[P]?._zod?.traits?.has("$ZodType")) throw Error(`Invalid element at key "${P}": expected a Zod schema`);
  let K = Q2($.shape);
  return { ...$, keys: q, keySet: new Set(q), numKeys: q.length, optionalKeys: new Set(K) };
}
__name($A, "$A");
function qA($, q, K, P, _, Y) {
  let O = [], z = _.keySet, J = _.catchall._zod, T = J.def.type;
  for (let X of Object.keys(q)) {
    if (z.has(X)) continue;
    if (T === "never") {
      O.push(X);
      continue;
    }
    let f = J.run({ value: q[X], issues: [] }, P);
    if (f instanceof Promise) $.push(f.then((V) => D9(V, K, X, q)));
    else D9(f, K, X, q);
  }
  if (O.length) K.issues.push({ code: "unrecognized_keys", keys: O, input: q, inst: Y });
  if (!$.length) return K;
  return Promise.all($).then(() => {
    return K;
  });
}
__name(qA, "qA");
var KA = O$("$ZodObject", ($, q) => {
  if (P6.init($, q), !Object.getOwnPropertyDescriptor(q, "shape")?.get) {
    let z = q.shape;
    Object.defineProperty(q, "shape", { get: /* @__PURE__ */ __name(() => {
      let J = { ...z };
      return Object.defineProperty(q, "shape", { value: J }), J;
    }, "get") });
  }
  let P = F_(() => $A(q));
  A6($._zod, "propValues", () => {
    let z = q.shape, J = {};
    for (let T in z) {
      let X = z[T]._zod;
      if (X.values) {
        J[T] ?? (J[T] = /* @__PURE__ */ new Set());
        for (let f of X.values) J[T].add(f);
      }
    }
    return J;
  });
  let _ = w_, Y = q.catchall, O;
  $._zod.parse = (z, J) => {
    O ?? (O = P.value);
    let T = z.value;
    if (!_(T)) return z.issues.push({ expected: "object", code: "invalid_type", input: T, inst: $ }), z;
    z.value = {};
    let X = [], f = O.shape;
    for (let V of O.keys) {
      let N = f[V]._zod.run({ value: T[V], issues: [] }, J);
      if (N instanceof Promise) X.push(N.then((E) => D9(E, z, V, T)));
      else D9(N, z, V, T);
    }
    if (!Y) return X.length ? Promise.all(X).then(() => z) : z;
    return qA(X, T, z, J, P.value, $);
  };
});
var bj = O$("$ZodObjectJIT", ($, q) => {
  KA.init($, q);
  let K = $._zod.parse, P = F_(() => $A(q)), _ = /* @__PURE__ */ __name((V) => {
    let M = new C9(["shape", "payload", "ctx"]), N = P.value, E = /* @__PURE__ */ __name((g) => {
      let b = J9(g);
      return `shape[${b}]._zod.run({ value: input[${b}], issues: [] }, ctx)`;
    }, "E");
    M.write("const input = payload.value;");
    let h = /* @__PURE__ */ Object.create(null), I = 0;
    for (let g of N.keys) h[g] = `key_${I++}`;
    M.write("const newResult = {};");
    for (let g of N.keys) {
      let b = h[g], y = J9(g);
      M.write(`const ${b} = ${E(g)};`), M.write(`
        if (${b}.issues.length) {
          payload.issues = payload.issues.concat(${b}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${y}, ...iss.path] : [${y}]
          })));
        }
        
        
        if (${b}.value === undefined) {
          if (${y} in input) {
            newResult[${y}] = undefined;
          }
        } else {
          newResult[${y}] = ${b}.value;
        }
        
      `);
    }
    M.write("payload.value = newResult;"), M.write("return payload;");
    let D = M.compile();
    return (g, b) => D(V, g, b);
  }, "_"), Y, O = w_, z = !EP.jitless, T = z && U2.value, X = q.catchall, f;
  $._zod.parse = (V, M) => {
    f ?? (f = P.value);
    let N = V.value;
    if (!O(N)) return V.issues.push({ expected: "object", code: "invalid_type", input: N, inst: $ }), V;
    if (z && T && M?.async === false && M.jitless !== true) {
      if (!Y) Y = _(q.shape);
      if (V = Y(V, M), !X) return V;
      return qA([], N, V, M, f, $);
    }
    return K(V, M);
  };
});
function oX($, q, K, P) {
  for (let Y of $) if (Y.issues.length === 0) return q.value = Y.value, q;
  let _ = $.filter((Y) => !oK(Y));
  if (_.length === 1) return q.value = _[0].value, _[0];
  return q.issues.push({ code: "invalid_union", input: q.value, inst: K, errors: $.map((Y) => Y.issues.map((O) => Y8(O, P, o6()))) }), q;
}
__name(oX, "oX");
var y9 = O$("$ZodUnion", ($, q) => {
  P6.init($, q), A6($._zod, "optin", () => q.options.some((_) => _._zod.optin === "optional") ? "optional" : void 0), A6($._zod, "optout", () => q.options.some((_) => _._zod.optout === "optional") ? "optional" : void 0), A6($._zod, "values", () => {
    if (q.options.every((_) => _._zod.values)) return new Set(q.options.flatMap((_) => Array.from(_._zod.values)));
    return;
  }), A6($._zod, "pattern", () => {
    if (q.options.every((_) => _._zod.pattern)) {
      let _ = q.options.map((Y) => Y._zod.pattern);
      return new RegExp(`^(${_.map((Y) => DP(Y.source)).join("|")})$`);
    }
    return;
  });
  let K = q.options.length === 1, P = q.options[0]._zod.run;
  $._zod.parse = (_, Y) => {
    if (K) return P(_, Y);
    let O = false, z = [];
    for (let J of q.options) {
      let T = J._zod.run({ value: _.value, issues: [] }, Y);
      if (T instanceof Promise) z.push(T), O = true;
      else {
        if (T.issues.length === 0) return T;
        z.push(T);
      }
    }
    if (!O) return oX(z, _, $, Y);
    return Promise.all(z).then((J) => {
      return oX(J, _, $, Y);
    });
  };
});
var yj = O$("$ZodDiscriminatedUnion", ($, q) => {
  y9.init($, q);
  let K = $._zod.parse;
  A6($._zod, "propValues", () => {
    let _ = {};
    for (let Y of q.options) {
      let O = Y._zod.propValues;
      if (!O || Object.keys(O).length === 0) throw Error(`Invalid discriminated union option at index "${q.options.indexOf(Y)}"`);
      for (let [z, J] of Object.entries(O)) {
        if (!_[z]) _[z] = /* @__PURE__ */ new Set();
        for (let T of J) _[z].add(T);
      }
    }
    return _;
  });
  let P = F_(() => {
    let _ = q.options, Y = /* @__PURE__ */ new Map();
    for (let O of _) {
      let z = O._zod.propValues?.[q.discriminator];
      if (!z || z.size === 0) throw Error(`Invalid discriminated union option at index "${q.options.indexOf(O)}"`);
      for (let J of z) {
        if (Y.has(J)) throw Error(`Duplicate discriminator value "${String(J)}"`);
        Y.set(J, O);
      }
    }
    return Y;
  });
  $._zod.parse = (_, Y) => {
    let O = _.value;
    if (!w_(O)) return _.issues.push({ code: "invalid_type", expected: "object", input: O, inst: $ }), _;
    let z = P.value.get(O?.[q.discriminator]);
    if (z) return z._zod.run(_, Y);
    if (q.unionFallback) return K(_, Y);
    return _.issues.push({ code: "invalid_union", errors: [], note: "No matching discriminator", discriminator: q.discriminator, input: O, path: [q.discriminator], inst: $ }), _;
  };
});
var uj = O$("$ZodIntersection", ($, q) => {
  P6.init($, q), $._zod.parse = (K, P) => {
    let _ = K.value, Y = q.left._zod.run({ value: _, issues: [] }, P), O = q.right._zod.run({ value: _, issues: [] }, P);
    if (Y instanceof Promise || O instanceof Promise) return Promise.all([Y, O]).then(([J, T]) => {
      return nX(K, J, T);
    });
    return nX(K, Y, O);
  };
});
function eY($, q) {
  if ($ === q) return { valid: true, data: $ };
  if ($ instanceof Date && q instanceof Date && +$ === +q) return { valid: true, data: $ };
  if (rK($) && rK(q)) {
    let K = Object.keys(q), P = Object.keys($).filter((Y) => K.indexOf(Y) !== -1), _ = { ...$, ...q };
    for (let Y of P) {
      let O = eY($[Y], q[Y]);
      if (!O.valid) return { valid: false, mergeErrorPath: [Y, ...O.mergeErrorPath] };
      _[Y] = O.data;
    }
    return { valid: true, data: _ };
  }
  if (Array.isArray($) && Array.isArray(q)) {
    if ($.length !== q.length) return { valid: false, mergeErrorPath: [] };
    let K = [];
    for (let P = 0; P < $.length; P++) {
      let _ = $[P], Y = q[P], O = eY(_, Y);
      if (!O.valid) return { valid: false, mergeErrorPath: [P, ...O.mergeErrorPath] };
      K.push(O.data);
    }
    return { valid: true, data: K };
  }
  return { valid: false, mergeErrorPath: [] };
}
__name(eY, "eY");
function nX($, q, K) {
  if (q.issues.length) $.issues.push(...q.issues);
  if (K.issues.length) $.issues.push(...K.issues);
  if (oK($)) return $;
  let P = eY(q.value, K.value);
  if (!P.valid) throw Error(`Unmergable intersection. Error path: ${JSON.stringify(P.mergeErrorPath)}`);
  return $.value = P.data, $;
}
__name(nX, "nX");
var u9 = O$("$ZodTuple", ($, q) => {
  P6.init($, q);
  let K = q.items, P = K.length - [...K].reverse().findIndex((_) => _._zod.optin !== "optional");
  $._zod.parse = (_, Y) => {
    let O = _.value;
    if (!Array.isArray(O)) return _.issues.push({ input: O, inst: $, expected: "tuple", code: "invalid_type" }), _;
    _.value = [];
    let z = [];
    if (!q.rest) {
      let T = O.length > K.length, X = O.length < P - 1;
      if (T || X) return _.issues.push({ ...T ? { code: "too_big", maximum: K.length } : { code: "too_small", minimum: K.length }, input: O, inst: $, origin: "array" }), _;
    }
    let J = -1;
    for (let T of K) {
      if (J++, J >= O.length) {
        if (J >= P) continue;
      }
      let X = T._zod.run({ value: O[J], issues: [] }, Y);
      if (X instanceof Promise) z.push(X.then((f) => h9(f, _, J)));
      else h9(X, _, J);
    }
    if (q.rest) {
      let T = O.slice(K.length);
      for (let X of T) {
        J++;
        let f = q.rest._zod.run({ value: X, issues: [] }, Y);
        if (f instanceof Promise) z.push(f.then((V) => h9(V, _, J)));
        else h9(f, _, J);
      }
    }
    if (z.length) return Promise.all(z).then(() => _);
    return _;
  };
});
function h9($, q, K) {
  if ($.issues.length) q.issues.push(...O8(K, $.issues));
  q.value[K] = $.value;
}
__name(h9, "h9");
var xj = O$("$ZodRecord", ($, q) => {
  P6.init($, q), $._zod.parse = (K, P) => {
    let _ = K.value;
    if (!rK(_)) return K.issues.push({ expected: "record", code: "invalid_type", input: _, inst: $ }), K;
    let Y = [];
    if (q.keyType._zod.values) {
      let O = q.keyType._zod.values;
      K.value = {};
      for (let J of O) if (typeof J === "string" || typeof J === "number" || typeof J === "symbol") {
        let T = q.valueType._zod.run({ value: _[J], issues: [] }, P);
        if (T instanceof Promise) Y.push(T.then((X) => {
          if (X.issues.length) K.issues.push(...O8(J, X.issues));
          K.value[J] = X.value;
        }));
        else {
          if (T.issues.length) K.issues.push(...O8(J, T.issues));
          K.value[J] = T.value;
        }
      }
      let z;
      for (let J in _) if (!O.has(J)) z = z ?? [], z.push(J);
      if (z && z.length > 0) K.issues.push({ code: "unrecognized_keys", input: _, inst: $, keys: z });
    } else {
      K.value = {};
      for (let O of Reflect.ownKeys(_)) {
        if (O === "__proto__") continue;
        let z = q.keyType._zod.run({ value: O, issues: [] }, P);
        if (z instanceof Promise) throw Error("Async schemas not supported in object keys currently");
        if (z.issues.length) {
          K.issues.push({ code: "invalid_key", origin: "record", issues: z.issues.map((T) => Y8(T, P, o6())), input: O, path: [O], inst: $ }), K.value[z.value] = z.value;
          continue;
        }
        let J = q.valueType._zod.run({ value: _[O], issues: [] }, P);
        if (J instanceof Promise) Y.push(J.then((T) => {
          if (T.issues.length) K.issues.push(...O8(O, T.issues));
          K.value[z.value] = T.value;
        }));
        else {
          if (J.issues.length) K.issues.push(...O8(O, J.issues));
          K.value[z.value] = J.value;
        }
      }
    }
    if (Y.length) return Promise.all(Y).then(() => K);
    return K;
  };
});
var pj = O$("$ZodMap", ($, q) => {
  P6.init($, q), $._zod.parse = (K, P) => {
    let _ = K.value;
    if (!(_ instanceof Map)) return K.issues.push({ expected: "map", code: "invalid_type", input: _, inst: $ }), K;
    let Y = [];
    K.value = /* @__PURE__ */ new Map();
    for (let [O, z] of _) {
      let J = q.keyType._zod.run({ value: O, issues: [] }, P), T = q.valueType._zod.run({ value: z, issues: [] }, P);
      if (J instanceof Promise || T instanceof Promise) Y.push(Promise.all([J, T]).then(([X, f]) => {
        iX(X, f, K, O, _, $, P);
      }));
      else iX(J, T, K, O, _, $, P);
    }
    if (Y.length) return Promise.all(Y).then(() => K);
    return K;
  };
});
function iX($, q, K, P, _, Y, O) {
  if ($.issues.length) if (LP.has(typeof P)) K.issues.push(...O8(P, $.issues));
  else K.issues.push({ code: "invalid_key", origin: "map", input: _, inst: Y, issues: $.issues.map((z) => Y8(z, O, o6())) });
  if (q.issues.length) if (LP.has(typeof P)) K.issues.push(...O8(P, q.issues));
  else K.issues.push({ origin: "map", code: "invalid_element", input: _, inst: Y, key: P, issues: q.issues.map((z) => Y8(z, O, o6())) });
  K.value.set($.value, q.value);
}
__name(iX, "iX");
var cj = O$("$ZodSet", ($, q) => {
  P6.init($, q), $._zod.parse = (K, P) => {
    let _ = K.value;
    if (!(_ instanceof Set)) return K.issues.push({ input: _, inst: $, expected: "set", code: "invalid_type" }), K;
    let Y = [];
    K.value = /* @__PURE__ */ new Set();
    for (let O of _) {
      let z = q.valueType._zod.run({ value: O, issues: [] }, P);
      if (z instanceof Promise) Y.push(z.then((J) => tX(J, K)));
      else tX(z, K);
    }
    if (Y.length) return Promise.all(Y).then(() => K);
    return K;
  };
});
function tX($, q) {
  if ($.issues.length) q.issues.push(...$.issues);
  q.value.add($.value);
}
__name(tX, "tX");
var mj = O$("$ZodEnum", ($, q) => {
  P6.init($, q);
  let K = IP(q.entries), P = new Set(K);
  $._zod.values = P, $._zod.pattern = new RegExp(`^(${K.filter((_) => LP.has(typeof _)).map((_) => typeof _ === "string" ? n8(_) : _.toString()).join("|")})$`), $._zod.parse = (_, Y) => {
    let O = _.value;
    if (P.has(O)) return _;
    return _.issues.push({ code: "invalid_value", values: K, input: O, inst: $ }), _;
  };
});
var dj = O$("$ZodLiteral", ($, q) => {
  if (P6.init($, q), q.values.length === 0) throw Error("Cannot create literal schema with no valid values");
  $._zod.values = new Set(q.values), $._zod.pattern = new RegExp(`^(${q.values.map((K) => typeof K === "string" ? n8(K) : K ? n8(K.toString()) : String(K)).join("|")})$`), $._zod.parse = (K, P) => {
    let _ = K.value;
    if ($._zod.values.has(_)) return K;
    return K.issues.push({ code: "invalid_value", values: q.values, input: _, inst: $ }), K;
  };
});
var lj = O$("$ZodFile", ($, q) => {
  P6.init($, q), $._zod.parse = (K, P) => {
    let _ = K.value;
    if (_ instanceof File) return K;
    return K.issues.push({ expected: "file", code: "invalid_type", input: _, inst: $ }), K;
  };
});
var rj = O$("$ZodTransform", ($, q) => {
  P6.init($, q), $._zod.parse = (K, P) => {
    if (P.direction === "backward") throw new T_($.constructor.name);
    let _ = q.transform(K.value, K);
    if (P.async) return (_ instanceof Promise ? _ : Promise.resolve(_)).then((O) => {
      return K.value = O, K;
    });
    if (_ instanceof Promise) throw new o8();
    return K.value = _, K;
  };
});
function BX($, q) {
  if ($.issues.length && q === void 0) return { issues: [], value: void 0 };
  return $;
}
__name(BX, "BX");
var x9 = O$("$ZodOptional", ($, q) => {
  P6.init($, q), $._zod.optin = "optional", $._zod.optout = "optional", A6($._zod, "values", () => {
    return q.innerType._zod.values ? /* @__PURE__ */ new Set([...q.innerType._zod.values, void 0]) : void 0;
  }), A6($._zod, "pattern", () => {
    let K = q.innerType._zod.pattern;
    return K ? new RegExp(`^(${DP(K.source)})?$`) : void 0;
  }), $._zod.parse = (K, P) => {
    if (q.innerType._zod.optin === "optional") {
      let _ = q.innerType._zod.run(K, P);
      if (_ instanceof Promise) return _.then((Y) => BX(Y, K.value));
      return BX(_, K.value);
    }
    if (K.value === void 0) return K;
    return q.innerType._zod.run(K, P);
  };
});
var oj = O$("$ZodNullable", ($, q) => {
  P6.init($, q), A6($._zod, "optin", () => q.innerType._zod.optin), A6($._zod, "optout", () => q.innerType._zod.optout), A6($._zod, "pattern", () => {
    let K = q.innerType._zod.pattern;
    return K ? new RegExp(`^(${DP(K.source)}|null)$`) : void 0;
  }), A6($._zod, "values", () => {
    return q.innerType._zod.values ? /* @__PURE__ */ new Set([...q.innerType._zod.values, null]) : void 0;
  }), $._zod.parse = (K, P) => {
    if (K.value === null) return K;
    return q.innerType._zod.run(K, P);
  };
});
var nj = O$("$ZodDefault", ($, q) => {
  P6.init($, q), $._zod.optin = "optional", A6($._zod, "values", () => q.innerType._zod.values), $._zod.parse = (K, P) => {
    if (P.direction === "backward") return q.innerType._zod.run(K, P);
    if (K.value === void 0) return K.value = q.defaultValue, K;
    let _ = q.innerType._zod.run(K, P);
    if (_ instanceof Promise) return _.then((Y) => UX(Y, q));
    return UX(_, q);
  };
});
function UX($, q) {
  if ($.value === void 0) $.value = q.defaultValue;
  return $;
}
__name(UX, "UX");
var ij = O$("$ZodPrefault", ($, q) => {
  P6.init($, q), $._zod.optin = "optional", A6($._zod, "values", () => q.innerType._zod.values), $._zod.parse = (K, P) => {
    if (P.direction === "backward") return q.innerType._zod.run(K, P);
    if (K.value === void 0) K.value = q.defaultValue;
    return q.innerType._zod.run(K, P);
  };
});
var tj = O$("$ZodNonOptional", ($, q) => {
  P6.init($, q), A6($._zod, "values", () => {
    let K = q.innerType._zod.values;
    return K ? new Set([...K].filter((P) => P !== void 0)) : void 0;
  }), $._zod.parse = (K, P) => {
    let _ = q.innerType._zod.run(K, P);
    if (_ instanceof Promise) return _.then((Y) => FX(Y, $));
    return FX(_, $);
  };
});
function FX($, q) {
  if (!$.issues.length && $.value === void 0) $.issues.push({ code: "invalid_type", expected: "nonoptional", input: $.value, inst: q });
  return $;
}
__name(FX, "FX");
var Bj = O$("$ZodSuccess", ($, q) => {
  P6.init($, q), $._zod.parse = (K, P) => {
    if (P.direction === "backward") throw new T_("ZodSuccess");
    let _ = q.innerType._zod.run(K, P);
    if (_ instanceof Promise) return _.then((Y) => {
      return K.value = Y.issues.length === 0, K;
    });
    return K.value = _.issues.length === 0, K;
  };
});
var Uj = O$("$ZodCatch", ($, q) => {
  P6.init($, q), A6($._zod, "optin", () => q.innerType._zod.optin), A6($._zod, "optout", () => q.innerType._zod.optout), A6($._zod, "values", () => q.innerType._zod.values), $._zod.parse = (K, P) => {
    if (P.direction === "backward") return q.innerType._zod.run(K, P);
    let _ = q.innerType._zod.run(K, P);
    if (_ instanceof Promise) return _.then((Y) => {
      if (K.value = Y.value, Y.issues.length) K.value = q.catchValue({ ...K, error: { issues: Y.issues.map((O) => Y8(O, P, o6())) }, input: K.value }), K.issues = [];
      return K;
    });
    if (K.value = _.value, _.issues.length) K.value = q.catchValue({ ...K, error: { issues: _.issues.map((Y) => Y8(Y, P, o6())) }, input: K.value }), K.issues = [];
    return K;
  };
});
var Fj = O$("$ZodNaN", ($, q) => {
  P6.init($, q), $._zod.parse = (K, P) => {
    if (typeof K.value !== "number" || !Number.isNaN(K.value)) return K.issues.push({ input: K.value, inst: $, expected: "nan", code: "invalid_type" }), K;
    return K;
  };
});
var aj = O$("$ZodPipe", ($, q) => {
  P6.init($, q), A6($._zod, "values", () => q.in._zod.values), A6($._zod, "optin", () => q.in._zod.optin), A6($._zod, "optout", () => q.out._zod.optout), A6($._zod, "propValues", () => q.in._zod.propValues), $._zod.parse = (K, P) => {
    if (P.direction === "backward") {
      let Y = q.out._zod.run(K, P);
      if (Y instanceof Promise) return Y.then((O) => E9(O, q.in, P));
      return E9(Y, q.in, P);
    }
    let _ = q.in._zod.run(K, P);
    if (_ instanceof Promise) return _.then((Y) => E9(Y, q.out, P));
    return E9(_, q.out, P);
  };
});
function E9($, q, K) {
  if ($.issues.length) return $.aborted = true, $;
  return q._zod.run({ value: $.value, issues: $.issues }, K);
}
__name(E9, "E9");
var rP = O$("$ZodCodec", ($, q) => {
  P6.init($, q), A6($._zod, "values", () => q.in._zod.values), A6($._zod, "optin", () => q.in._zod.optin), A6($._zod, "optout", () => q.out._zod.optout), A6($._zod, "propValues", () => q.in._zod.propValues), $._zod.parse = (K, P) => {
    if ((P.direction || "forward") === "forward") {
      let Y = q.in._zod.run(K, P);
      if (Y instanceof Promise) return Y.then((O) => R9(O, q, P));
      return R9(Y, q, P);
    } else {
      let Y = q.out._zod.run(K, P);
      if (Y instanceof Promise) return Y.then((O) => R9(O, q, P));
      return R9(Y, q, P);
    }
  };
});
function R9($, q, K) {
  if ($.issues.length) return $.aborted = true, $;
  if ((K.direction || "forward") === "forward") {
    let _ = q.transform($.value, $);
    if (_ instanceof Promise) return _.then((Y) => I9($, Y, q.out, K));
    return I9($, _, q.out, K);
  } else {
    let _ = q.reverseTransform($.value, $);
    if (_ instanceof Promise) return _.then((Y) => I9($, Y, q.in, K));
    return I9($, _, q.in, K);
  }
}
__name(R9, "R9");
function I9($, q, K, P) {
  if ($.issues.length) return $.aborted = true, $;
  return K._zod.run({ value: q, issues: $.issues }, P);
}
__name(I9, "I9");
var Qj = O$("$ZodReadonly", ($, q) => {
  P6.init($, q), A6($._zod, "propValues", () => q.innerType._zod.propValues), A6($._zod, "values", () => q.innerType._zod.values), A6($._zod, "optin", () => q.innerType._zod.optin), A6($._zod, "optout", () => q.innerType._zod.optout), $._zod.parse = (K, P) => {
    if (P.direction === "backward") return q.innerType._zod.run(K, P);
    let _ = q.innerType._zod.run(K, P);
    if (_ instanceof Promise) return _.then(aX);
    return aX(_);
  };
});
function aX($) {
  return $.value = Object.freeze($.value), $;
}
__name(aX, "aX");
var ej = O$("$ZodTemplateLiteral", ($, q) => {
  P6.init($, q);
  let K = [];
  for (let P of q.parts) if (typeof P === "object" && P !== null) {
    if (!P._zod.pattern) throw Error(`Invalid template literal part, no pattern found: ${[...P._zod.traits].shift()}`);
    let _ = P._zod.pattern instanceof RegExp ? P._zod.pattern.source : P._zod.pattern;
    if (!_) throw Error(`Invalid template literal part: ${P._zod.traits}`);
    let Y = _.startsWith("^") ? 1 : 0, O = _.endsWith("$") ? _.length - 1 : _.length;
    K.push(_.slice(Y, O));
  } else if (P === null || a2.has(typeof P)) K.push(n8(`${P}`));
  else throw Error(`Invalid template literal part: ${P}`);
  $._zod.pattern = new RegExp(`^${K.join("")}$`), $._zod.parse = (P, _) => {
    if (typeof P.value !== "string") return P.issues.push({ input: P.value, inst: $, expected: "template_literal", code: "invalid_type" }), P;
    if ($._zod.pattern.lastIndex = 0, !$._zod.pattern.test(P.value)) return P.issues.push({ input: P.value, inst: $, code: "invalid_format", format: q.format ?? "template_literal", pattern: $._zod.pattern.source }), P;
    return P;
  };
});
var sj = O$("$ZodFunction", ($, q) => {
  return P6.init($, q), $._def = q, $._zod.def = q, $.implement = (K) => {
    if (typeof K !== "function") throw Error("implement() must be called with a function");
    return function(...P) {
      let _ = $._def.input ? pP($._def.input, P) : P, Y = Reflect.apply(K, this, _);
      if ($._def.output) return pP($._def.output, Y);
      return Y;
    };
  }, $.implementAsync = (K) => {
    if (typeof K !== "function") throw Error("implementAsync() must be called with a function");
    return async function(...P) {
      let _ = $._def.input ? await s_($._def.input, P) : P, Y = await Reflect.apply(K, this, _);
      if ($._def.output) return await s_($._def.output, Y);
      return Y;
    };
  }, $._zod.parse = (K, P) => {
    if (typeof K.value !== "function") return K.issues.push({ code: "invalid_type", expected: "function", input: K.value, inst: $ }), K;
    if ($._def.output && $._def.output._zod.def.type === "promise") K.value = $.implementAsync(K.value);
    else K.value = $.implement(K.value);
    return K;
  }, $.input = (...K) => {
    let P = $.constructor;
    if (Array.isArray(K[0])) return new P({ type: "function", input: new u9({ type: "tuple", items: K[0], rest: K[1] }), output: $._def.output });
    return new P({ type: "function", input: K[0], output: $._def.output });
  }, $.output = (K) => {
    return new $.constructor({ type: "function", input: $._def.input, output: K });
  }, $;
});
var $3 = O$("$ZodPromise", ($, q) => {
  P6.init($, q), $._zod.parse = (K, P) => {
    return Promise.resolve(K.value).then((_) => q.innerType._zod.run({ value: _, issues: [] }, P));
  };
});
var q3 = O$("$ZodLazy", ($, q) => {
  P6.init($, q), A6($._zod, "innerType", () => q.getter()), A6($._zod, "pattern", () => $._zod.innerType._zod.pattern), A6($._zod, "propValues", () => $._zod.innerType._zod.propValues), A6($._zod, "optin", () => $._zod.innerType._zod.optin ?? void 0), A6($._zod, "optout", () => $._zod.innerType._zod.optout ?? void 0), $._zod.parse = (K, P) => {
    return $._zod.innerType._zod.run(K, P);
  };
});
var K3 = O$("$ZodCustom", ($, q) => {
  I6.init($, q), P6.init($, q), $._zod.parse = (K, P) => {
    return K;
  }, $._zod.check = (K) => {
    let P = K.value, _ = q.fn(P);
    if (_ instanceof Promise) return _.then((Y) => QX(Y, K, P, $));
    QX(_, K, P, $);
    return;
  };
});
function QX($, q, K, P) {
  if (!$) {
    let _ = { code: "custom", input: K, inst: P, path: [...P._zod.def.path ?? []], continue: !P._zod.def.abort };
    if (P._zod.def.params) _.params = P._zod.def.params;
    q.issues.push(a_(_));
  }
}
__name(QX, "QX");
var UP = {};
rq(UP, { zhTW: /* @__PURE__ */ __name(() => n3, "zhTW"), zhCN: /* @__PURE__ */ __name(() => o3, "zhCN"), yo: /* @__PURE__ */ __name(() => i3, "yo"), vi: /* @__PURE__ */ __name(() => r3, "vi"), ur: /* @__PURE__ */ __name(() => l3, "ur"), uk: /* @__PURE__ */ __name(() => BP, "uk"), ua: /* @__PURE__ */ __name(() => d3, "ua"), tr: /* @__PURE__ */ __name(() => m3, "tr"), th: /* @__PURE__ */ __name(() => c3, "th"), ta: /* @__PURE__ */ __name(() => p3, "ta"), sv: /* @__PURE__ */ __name(() => x3, "sv"), sl: /* @__PURE__ */ __name(() => u3, "sl"), ru: /* @__PURE__ */ __name(() => y3, "ru"), pt: /* @__PURE__ */ __name(() => b3, "pt"), ps: /* @__PURE__ */ __name(() => L3, "ps"), pl: /* @__PURE__ */ __name(() => g3, "pl"), ota: /* @__PURE__ */ __name(() => D3, "ota"), no: /* @__PURE__ */ __name(() => I3, "no"), nl: /* @__PURE__ */ __name(() => R3, "nl"), ms: /* @__PURE__ */ __name(() => E3, "ms"), mk: /* @__PURE__ */ __name(() => h3, "mk"), lt: /* @__PURE__ */ __name(() => C3, "lt"), ko: /* @__PURE__ */ __name(() => N3, "ko"), km: /* @__PURE__ */ __name(() => nP, "km"), kh: /* @__PURE__ */ __name(() => M3, "kh"), ka: /* @__PURE__ */ __name(() => S3, "ka"), ja: /* @__PURE__ */ __name(() => V3, "ja"), it: /* @__PURE__ */ __name(() => G3, "it"), is: /* @__PURE__ */ __name(() => k3, "is"), id: /* @__PURE__ */ __name(() => A3, "id"), hu: /* @__PURE__ */ __name(() => X3, "hu"), he: /* @__PURE__ */ __name(() => Z3, "he"), frCA: /* @__PURE__ */ __name(() => f3, "frCA"), fr: /* @__PURE__ */ __name(() => w3, "fr"), fi: /* @__PURE__ */ __name(() => T3, "fi"), fa: /* @__PURE__ */ __name(() => J3, "fa"), es: /* @__PURE__ */ __name(() => H3, "es"), eo: /* @__PURE__ */ __name(() => W3, "eo"), en: /* @__PURE__ */ __name(() => oP, "en"), de: /* @__PURE__ */ __name(() => z3, "de"), da: /* @__PURE__ */ __name(() => v3, "da"), cs: /* @__PURE__ */ __name(() => j3, "cs"), ca: /* @__PURE__ */ __name(() => Y3, "ca"), be: /* @__PURE__ */ __name(() => O3, "be"), az: /* @__PURE__ */ __name(() => P3, "az"), ar: /* @__PURE__ */ __name(() => _3, "ar") });
var TD = /* @__PURE__ */ __name(() => {
  let $ = { string: { unit: "", verb: " " }, file: { unit: "", verb: " " }, array: { unit: "", verb: " " }, set: { unit: "", verb: " " } };
  function q(_) {
    return $[_] ?? null;
  }
  __name(q, "q");
  let K = /* @__PURE__ */ __name((_) => {
    let Y = typeof _;
    switch (Y) {
      case "number":
        return Number.isNaN(_) ? "NaN" : "number";
      case "object": {
        if (Array.isArray(_)) return "array";
        if (_ === null) return "null";
        if (Object.getPrototypeOf(_) !== Object.prototype && _.constructor) return _.constructor.name;
      }
    }
    return Y;
  }, "K"), P = { regex: "", email: " ", url: "", emoji: "", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "   ISO", date: "  ISO", time: "  ISO", duration: "  ISO", ipv4: " IPv4", ipv6: " IPv6", cidrv4: "   IPv4", cidrv6: "   IPv6", base64: "  base64-encoded", base64url: "  base64url-encoded", json_string: "   JSON", e164: "   E.164", jwt: "JWT", template_literal: "" };
  return (_) => {
    switch (_.code) {
      case "invalid_type":
        return `  :   ${_.expected}    ${K(_.input)}`;
      case "invalid_value":
        if (_.values.length === 1) return `  :   ${m$(_.values[0])}`;
        return `  :     : ${T$(_.values, "|")}`;
      case "too_big": {
        let Y = _.inclusive ? "<=" : "<", O = q(_.origin);
        if (O) return `   :    ${_.origin ?? ""} ${Y} ${_.maximum.toString()} ${O.unit ?? ""}`;
        return `  :    ${_.origin ?? ""} ${Y} ${_.maximum.toString()}`;
      }
      case "too_small": {
        let Y = _.inclusive ? ">=" : ">", O = q(_.origin);
        if (O) return `  :   ${_.origin}   ${Y} ${_.minimum.toString()} ${O.unit}`;
        return `  :   ${_.origin}   ${Y} ${_.minimum.toString()}`;
      }
      case "invalid_format": {
        let Y = _;
        if (Y.format === "starts_with") return `  :     "${_.prefix}"`;
        if (Y.format === "ends_with") return `  :     "${Y.suffix}"`;
        if (Y.format === "includes") return `  :    "${Y.includes}"`;
        if (Y.format === "regex") return `  :     ${Y.pattern}`;
        return `${P[Y.format] ?? _.format}  `;
      }
      case "not_multiple_of":
        return `  :      ${_.divisor}`;
      case "unrecognized_keys":
        return `${_.keys.length > 1 ? "" : ""} ${_.keys.length > 1 ? "" : ""}: ${T$(_.keys, " ")}`;
      case "invalid_key":
        return `    ${_.origin}`;
      case "invalid_union":
        return "  ";
      case "invalid_element":
        return `    ${_.origin}`;
      default:
        return "  ";
    }
  };
}, "TD");
function _3() {
  return { localeError: TD() };
}
__name(_3, "_3");
var wD = /* @__PURE__ */ __name(() => {
  let $ = { string: { unit: "simvol", verb: "olmaldr" }, file: { unit: "bayt", verb: "olmaldr" }, array: { unit: "element", verb: "olmaldr" }, set: { unit: "element", verb: "olmaldr" } };
  function q(_) {
    return $[_] ?? null;
  }
  __name(q, "q");
  let K = /* @__PURE__ */ __name((_) => {
    let Y = typeof _;
    switch (Y) {
      case "number":
        return Number.isNaN(_) ? "NaN" : "number";
      case "object": {
        if (Array.isArray(_)) return "array";
        if (_ === null) return "null";
        if (Object.getPrototypeOf(_) !== Object.prototype && _.constructor) return _.constructor.name;
      }
    }
    return Y;
  }, "K"), P = { regex: "input", email: "email address", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO datetime", date: "ISO date", time: "ISO time", duration: "ISO duration", ipv4: "IPv4 address", ipv6: "IPv6 address", cidrv4: "IPv4 range", cidrv6: "IPv6 range", base64: "base64-encoded string", base64url: "base64url-encoded string", json_string: "JSON string", e164: "E.164 number", jwt: "JWT", template_literal: "input" };
  return (_) => {
    switch (_.code) {
      case "invalid_type":
        return `Yanl dyr: gzlniln ${_.expected}, daxil olan ${K(_.input)}`;
      case "invalid_value":
        if (_.values.length === 1) return `Yanl dyr: gzlniln ${m$(_.values[0])}`;
        return `Yanl seim: aadaklardan biri olmaldr: ${T$(_.values, "|")}`;
      case "too_big": {
        let Y = _.inclusive ? "<=" : "<", O = q(_.origin);
        if (O) return `ox byk: gzlniln ${_.origin ?? "dyr"} ${Y}${_.maximum.toString()} ${O.unit ?? "element"}`;
        return `ox byk: gzlniln ${_.origin ?? "dyr"} ${Y}${_.maximum.toString()}`;
      }
      case "too_small": {
        let Y = _.inclusive ? ">=" : ">", O = q(_.origin);
        if (O) return `ox kiik: gzlniln ${_.origin} ${Y}${_.minimum.toString()} ${O.unit}`;
        return `ox kiik: gzlniln ${_.origin} ${Y}${_.minimum.toString()}`;
      }
      case "invalid_format": {
        let Y = _;
        if (Y.format === "starts_with") return `Yanl mtn: "${Y.prefix}" il balamaldr`;
        if (Y.format === "ends_with") return `Yanl mtn: "${Y.suffix}" il bitmlidir`;
        if (Y.format === "includes") return `Yanl mtn: "${Y.includes}" daxil olmaldr`;
        if (Y.format === "regex") return `Yanl mtn: ${Y.pattern} ablonuna uyun olmaldr`;
        return `Yanl ${P[Y.format] ?? _.format}`;
      }
      case "not_multiple_of":
        return `Yanl dd: ${_.divisor} il bln biln olmaldr`;
      case "unrecognized_keys":
        return `Tannmayan aar${_.keys.length > 1 ? "lar" : ""}: ${T$(_.keys, ", ")}`;
      case "invalid_key":
        return `${_.origin} daxilind yanl aar`;
      case "invalid_union":
        return "Yanl dyr";
      case "invalid_element":
        return `${_.origin} daxilind yanl dyr`;
      default:
        return "Yanl dyr";
    }
  };
}, "wD");
function P3() {
  return { localeError: wD() };
}
__name(P3, "P3");
function _A($, q, K, P) {
  let _ = Math.abs($), Y = _ % 10, O = _ % 100;
  if (O >= 11 && O <= 19) return P;
  if (Y === 1) return q;
  if (Y >= 2 && Y <= 4) return K;
  return P;
}
__name(_A, "_A");
var fD = /* @__PURE__ */ __name(() => {
  let $ = { string: { unit: { one: "", few: "", many: "" }, verb: "" }, array: { unit: { one: "", few: "", many: "" }, verb: "" }, set: { unit: { one: "", few: "", many: "" }, verb: "" }, file: { unit: { one: "", few: "", many: "" }, verb: "" } };
  function q(_) {
    return $[_] ?? null;
  }
  __name(q, "q");
  let K = /* @__PURE__ */ __name((_) => {
    let Y = typeof _;
    switch (Y) {
      case "number":
        return Number.isNaN(_) ? "NaN" : "";
      case "object": {
        if (Array.isArray(_)) return "";
        if (_ === null) return "null";
        if (Object.getPrototypeOf(_) !== Object.prototype && _.constructor) return _.constructor.name;
      }
    }
    return Y;
  }, "K"), P = { regex: "", email: "email ", url: "URL", emoji: "", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO   ", date: "ISO ", time: "ISO ", duration: "ISO ", ipv4: "IPv4 ", ipv6: "IPv6 ", cidrv4: "IPv4 ", cidrv6: "IPv6 ", base64: "   base64", base64url: "   base64url", json_string: "JSON ", e164: " E.164", jwt: "JWT", template_literal: "" };
  return (_) => {
    switch (_.code) {
      case "invalid_type":
        return ` :  ${_.expected},  ${K(_.input)}`;
      case "invalid_value":
        if (_.values.length === 1) return ` :  ${m$(_.values[0])}`;
        return ` :    ${T$(_.values, "|")}`;
      case "too_big": {
        let Y = _.inclusive ? "<=" : "<", O = q(_.origin);
        if (O) {
          let z = Number(_.maximum), J = _A(z, O.unit.one, O.unit.few, O.unit.many);
          return ` : ,  ${_.origin ?? ""}  ${O.verb} ${Y}${_.maximum.toString()} ${J}`;
        }
        return ` : ,  ${_.origin ?? ""}   ${Y}${_.maximum.toString()}`;
      }
      case "too_small": {
        let Y = _.inclusive ? ">=" : ">", O = q(_.origin);
        if (O) {
          let z = Number(_.minimum), J = _A(z, O.unit.one, O.unit.few, O.unit.many);
          return ` : ,  ${_.origin}  ${O.verb} ${Y}${_.minimum.toString()} ${J}`;
        }
        return ` : ,  ${_.origin}   ${Y}${_.minimum.toString()}`;
      }
      case "invalid_format": {
        let Y = _;
        if (Y.format === "starts_with") return ` :    "${Y.prefix}"`;
        if (Y.format === "ends_with") return ` :    "${Y.suffix}"`;
        if (Y.format === "includes") return ` :   "${Y.includes}"`;
        if (Y.format === "regex") return ` :    ${Y.pattern}`;
        return ` ${P[Y.format] ?? _.format}`;
      }
      case "not_multiple_of":
        return ` :    ${_.divisor}`;
      case "unrecognized_keys":
        return ` ${_.keys.length > 1 ? "" : ""}: ${T$(_.keys, ", ")}`;
      case "invalid_key":
        return `   ${_.origin}`;
      case "invalid_union":
        return " ";
      case "invalid_element":
        return `   ${_.origin}`;
      default:
        return " ";
    }
  };
}, "fD");
function O3() {
  return { localeError: fD() };
}
__name(O3, "O3");
var ZD = /* @__PURE__ */ __name(() => {
  let $ = { string: { unit: "carcters", verb: "contenir" }, file: { unit: "bytes", verb: "contenir" }, array: { unit: "elements", verb: "contenir" }, set: { unit: "elements", verb: "contenir" } };
  function q(_) {
    return $[_] ?? null;
  }
  __name(q, "q");
  let K = /* @__PURE__ */ __name((_) => {
    let Y = typeof _;
    switch (Y) {
      case "number":
        return Number.isNaN(_) ? "NaN" : "number";
      case "object": {
        if (Array.isArray(_)) return "array";
        if (_ === null) return "null";
        if (Object.getPrototypeOf(_) !== Object.prototype && _.constructor) return _.constructor.name;
      }
    }
    return Y;
  }, "K"), P = { regex: "entrada", email: "adrea electrnica", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "data i hora ISO", date: "data ISO", time: "hora ISO", duration: "durada ISO", ipv4: "adrea IPv4", ipv6: "adrea IPv6", cidrv4: "rang IPv4", cidrv6: "rang IPv6", base64: "cadena codificada en base64", base64url: "cadena codificada en base64url", json_string: "cadena JSON", e164: "nmero E.164", jwt: "JWT", template_literal: "entrada" };
  return (_) => {
    switch (_.code) {
      case "invalid_type":
        return `Tipus invlid: s'esperava ${_.expected}, s'ha rebut ${K(_.input)}`;
      case "invalid_value":
        if (_.values.length === 1) return `Valor invlid: s'esperava ${m$(_.values[0])}`;
        return `Opci invlida: s'esperava una de ${T$(_.values, " o ")}`;
      case "too_big": {
        let Y = _.inclusive ? "com a mxim" : "menys de", O = q(_.origin);
        if (O) return `Massa gran: s'esperava que ${_.origin ?? "el valor"} contingus ${Y} ${_.maximum.toString()} ${O.unit ?? "elements"}`;
        return `Massa gran: s'esperava que ${_.origin ?? "el valor"} fos ${Y} ${_.maximum.toString()}`;
      }
      case "too_small": {
        let Y = _.inclusive ? "com a mnim" : "ms de", O = q(_.origin);
        if (O) return `Massa petit: s'esperava que ${_.origin} contingus ${Y} ${_.minimum.toString()} ${O.unit}`;
        return `Massa petit: s'esperava que ${_.origin} fos ${Y} ${_.minimum.toString()}`;
      }
      case "invalid_format": {
        let Y = _;
        if (Y.format === "starts_with") return `Format invlid: ha de comenar amb "${Y.prefix}"`;
        if (Y.format === "ends_with") return `Format invlid: ha d'acabar amb "${Y.suffix}"`;
        if (Y.format === "includes") return `Format invlid: ha d'incloure "${Y.includes}"`;
        if (Y.format === "regex") return `Format invlid: ha de coincidir amb el patr ${Y.pattern}`;
        return `Format invlid per a ${P[Y.format] ?? _.format}`;
      }
      case "not_multiple_of":
        return `Nmero invlid: ha de ser mltiple de ${_.divisor}`;
      case "unrecognized_keys":
        return `Clau${_.keys.length > 1 ? "s" : ""} no reconeguda${_.keys.length > 1 ? "s" : ""}: ${T$(_.keys, ", ")}`;
      case "invalid_key":
        return `Clau invlida a ${_.origin}`;
      case "invalid_union":
        return "Entrada invlida";
      case "invalid_element":
        return `Element invlid a ${_.origin}`;
      default:
        return "Entrada invlida";
    }
  };
}, "ZD");
function Y3() {
  return { localeError: ZD() };
}
__name(Y3, "Y3");
var XD = /* @__PURE__ */ __name(() => {
  let $ = { string: { unit: "znak", verb: "mt" }, file: { unit: "bajt", verb: "mt" }, array: { unit: "prvk", verb: "mt" }, set: { unit: "prvk", verb: "mt" } };
  function q(_) {
    return $[_] ?? null;
  }
  __name(q, "q");
  let K = /* @__PURE__ */ __name((_) => {
    let Y = typeof _;
    switch (Y) {
      case "number":
        return Number.isNaN(_) ? "NaN" : "slo";
      case "string":
        return "etzec";
      case "boolean":
        return "boolean";
      case "bigint":
        return "bigint";
      case "function":
        return "funkce";
      case "symbol":
        return "symbol";
      case "undefined":
        return "undefined";
      case "object": {
        if (Array.isArray(_)) return "pole";
        if (_ === null) return "null";
        if (Object.getPrototypeOf(_) !== Object.prototype && _.constructor) return _.constructor.name;
      }
    }
    return Y;
  }, "K"), P = { regex: "regulrn vraz", email: "e-mailov adresa", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "datum a as ve formtu ISO", date: "datum ve formtu ISO", time: "as ve formtu ISO", duration: "doba trvn ISO", ipv4: "IPv4 adresa", ipv6: "IPv6 adresa", cidrv4: "rozsah IPv4", cidrv6: "rozsah IPv6", base64: "etzec zakdovan ve formtu base64", base64url: "etzec zakdovan ve formtu base64url", json_string: "etzec ve formtu JSON", e164: "slo E.164", jwt: "JWT", template_literal: "vstup" };
  return (_) => {
    switch (_.code) {
      case "invalid_type":
        return `Neplatn vstup: oekvno ${_.expected}, obdreno ${K(_.input)}`;
      case "invalid_value":
        if (_.values.length === 1) return `Neplatn vstup: oekvno ${m$(_.values[0])}`;
        return `Neplatn monost: oekvna jedna z hodnot ${T$(_.values, "|")}`;
      case "too_big": {
        let Y = _.inclusive ? "<=" : "<", O = q(_.origin);
        if (O) return `Hodnota je pli velk: ${_.origin ?? "hodnota"} mus mt ${Y}${_.maximum.toString()} ${O.unit ?? "prvk"}`;
        return `Hodnota je pli velk: ${_.origin ?? "hodnota"} mus bt ${Y}${_.maximum.toString()}`;
      }
      case "too_small": {
        let Y = _.inclusive ? ">=" : ">", O = q(_.origin);
        if (O) return `Hodnota je pli mal: ${_.origin ?? "hodnota"} mus mt ${Y}${_.minimum.toString()} ${O.unit ?? "prvk"}`;
        return `Hodnota je pli mal: ${_.origin ?? "hodnota"} mus bt ${Y}${_.minimum.toString()}`;
      }
      case "invalid_format": {
        let Y = _;
        if (Y.format === "starts_with") return `Neplatn etzec: mus zanat na "${Y.prefix}"`;
        if (Y.format === "ends_with") return `Neplatn etzec: mus konit na "${Y.suffix}"`;
        if (Y.format === "includes") return `Neplatn etzec: mus obsahovat "${Y.includes}"`;
        if (Y.format === "regex") return `Neplatn etzec: mus odpovdat vzoru ${Y.pattern}`;
        return `Neplatn formt ${P[Y.format] ?? _.format}`;
      }
      case "not_multiple_of":
        return `Neplatn slo: mus bt nsobkem ${_.divisor}`;
      case "unrecognized_keys":
        return `Neznm kle: ${T$(_.keys, ", ")}`;
      case "invalid_key":
        return `Neplatn kl v ${_.origin}`;
      case "invalid_union":
        return "Neplatn vstup";
      case "invalid_element":
        return `Neplatn hodnota v ${_.origin}`;
      default:
        return "Neplatn vstup";
    }
  };
}, "XD");
function j3() {
  return { localeError: XD() };
}
__name(j3, "j3");
var AD = /* @__PURE__ */ __name(() => {
  let $ = { string: { unit: "tegn", verb: "havde" }, file: { unit: "bytes", verb: "havde" }, array: { unit: "elementer", verb: "indeholdt" }, set: { unit: "elementer", verb: "indeholdt" } }, q = { string: "streng", number: "tal", boolean: "boolean", array: "liste", object: "objekt", set: "st", file: "fil" };
  function K(O) {
    return $[O] ?? null;
  }
  __name(K, "K");
  function P(O) {
    return q[O] ?? O;
  }
  __name(P, "P");
  let _ = /* @__PURE__ */ __name((O) => {
    let z = typeof O;
    switch (z) {
      case "number":
        return Number.isNaN(O) ? "NaN" : "tal";
      case "object": {
        if (Array.isArray(O)) return "liste";
        if (O === null) return "null";
        if (Object.getPrototypeOf(O) !== Object.prototype && O.constructor) return O.constructor.name;
        return "objekt";
      }
    }
    return z;
  }, "_"), Y = { regex: "input", email: "e-mailadresse", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO dato- og klokkeslt", date: "ISO-dato", time: "ISO-klokkeslt", duration: "ISO-varighed", ipv4: "IPv4-omrde", ipv6: "IPv6-omrde", cidrv4: "IPv4-spektrum", cidrv6: "IPv6-spektrum", base64: "base64-kodet streng", base64url: "base64url-kodet streng", json_string: "JSON-streng", e164: "E.164-nummer", jwt: "JWT", template_literal: "input" };
  return (O) => {
    switch (O.code) {
      case "invalid_type":
        return `Ugyldigt input: forventede ${P(O.expected)}, fik ${P(_(O.input))}`;
      case "invalid_value":
        if (O.values.length === 1) return `Ugyldig vrdi: forventede ${m$(O.values[0])}`;
        return `Ugyldigt valg: forventede en af flgende ${T$(O.values, "|")}`;
      case "too_big": {
        let z = O.inclusive ? "<=" : "<", J = K(O.origin), T = P(O.origin);
        if (J) return `For stor: forventede ${T ?? "value"} ${J.verb} ${z} ${O.maximum.toString()} ${J.unit ?? "elementer"}`;
        return `For stor: forventede ${T ?? "value"} havde ${z} ${O.maximum.toString()}`;
      }
      case "too_small": {
        let z = O.inclusive ? ">=" : ">", J = K(O.origin), T = P(O.origin);
        if (J) return `For lille: forventede ${T} ${J.verb} ${z} ${O.minimum.toString()} ${J.unit}`;
        return `For lille: forventede ${T} havde ${z} ${O.minimum.toString()}`;
      }
      case "invalid_format": {
        let z = O;
        if (z.format === "starts_with") return `Ugyldig streng: skal starte med "${z.prefix}"`;
        if (z.format === "ends_with") return `Ugyldig streng: skal ende med "${z.suffix}"`;
        if (z.format === "includes") return `Ugyldig streng: skal indeholde "${z.includes}"`;
        if (z.format === "regex") return `Ugyldig streng: skal matche mnsteret ${z.pattern}`;
        return `Ugyldig ${Y[z.format] ?? O.format}`;
      }
      case "not_multiple_of":
        return `Ugyldigt tal: skal vre deleligt med ${O.divisor}`;
      case "unrecognized_keys":
        return `${O.keys.length > 1 ? "Ukendte ngler" : "Ukendt ngle"}: ${T$(O.keys, ", ")}`;
      case "invalid_key":
        return `Ugyldig ngle i ${O.origin}`;
      case "invalid_union":
        return "Ugyldigt input: matcher ingen af de tilladte typer";
      case "invalid_element":
        return `Ugyldig vrdi i ${O.origin}`;
      default:
        return "Ugyldigt input";
    }
  };
}, "AD");
function v3() {
  return { localeError: AD() };
}
__name(v3, "v3");
var kD = /* @__PURE__ */ __name(() => {
  let $ = { string: { unit: "Zeichen", verb: "zu haben" }, file: { unit: "Bytes", verb: "zu haben" }, array: { unit: "Elemente", verb: "zu haben" }, set: { unit: "Elemente", verb: "zu haben" } };
  function q(_) {
    return $[_] ?? null;
  }
  __name(q, "q");
  let K = /* @__PURE__ */ __name((_) => {
    let Y = typeof _;
    switch (Y) {
      case "number":
        return Number.isNaN(_) ? "NaN" : "Zahl";
      case "object": {
        if (Array.isArray(_)) return "Array";
        if (_ === null) return "null";
        if (Object.getPrototypeOf(_) !== Object.prototype && _.constructor) return _.constructor.name;
      }
    }
    return Y;
  }, "K"), P = { regex: "Eingabe", email: "E-Mail-Adresse", url: "URL", emoji: "Emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO-Datum und -Uhrzeit", date: "ISO-Datum", time: "ISO-Uhrzeit", duration: "ISO-Dauer", ipv4: "IPv4-Adresse", ipv6: "IPv6-Adresse", cidrv4: "IPv4-Bereich", cidrv6: "IPv6-Bereich", base64: "Base64-codierter String", base64url: "Base64-URL-codierter String", json_string: "JSON-String", e164: "E.164-Nummer", jwt: "JWT", template_literal: "Eingabe" };
  return (_) => {
    switch (_.code) {
      case "invalid_type":
        return `Ungltige Eingabe: erwartet ${_.expected}, erhalten ${K(_.input)}`;
      case "invalid_value":
        if (_.values.length === 1) return `Ungltige Eingabe: erwartet ${m$(_.values[0])}`;
        return `Ungltige Option: erwartet eine von ${T$(_.values, "|")}`;
      case "too_big": {
        let Y = _.inclusive ? "<=" : "<", O = q(_.origin);
        if (O) return `Zu gro: erwartet, dass ${_.origin ?? "Wert"} ${Y}${_.maximum.toString()} ${O.unit ?? "Elemente"} hat`;
        return `Zu gro: erwartet, dass ${_.origin ?? "Wert"} ${Y}${_.maximum.toString()} ist`;
      }
      case "too_small": {
        let Y = _.inclusive ? ">=" : ">", O = q(_.origin);
        if (O) return `Zu klein: erwartet, dass ${_.origin} ${Y}${_.minimum.toString()} ${O.unit} hat`;
        return `Zu klein: erwartet, dass ${_.origin} ${Y}${_.minimum.toString()} ist`;
      }
      case "invalid_format": {
        let Y = _;
        if (Y.format === "starts_with") return `Ungltiger String: muss mit "${Y.prefix}" beginnen`;
        if (Y.format === "ends_with") return `Ungltiger String: muss mit "${Y.suffix}" enden`;
        if (Y.format === "includes") return `Ungltiger String: muss "${Y.includes}" enthalten`;
        if (Y.format === "regex") return `Ungltiger String: muss dem Muster ${Y.pattern} entsprechen`;
        return `Ungltig: ${P[Y.format] ?? _.format}`;
      }
      case "not_multiple_of":
        return `Ungltige Zahl: muss ein Vielfaches von ${_.divisor} sein`;
      case "unrecognized_keys":
        return `${_.keys.length > 1 ? "Unbekannte Schlssel" : "Unbekannter Schlssel"}: ${T$(_.keys, ", ")}`;
      case "invalid_key":
        return `Ungltiger Schlssel in ${_.origin}`;
      case "invalid_union":
        return "Ungltige Eingabe";
      case "invalid_element":
        return `Ungltiger Wert in ${_.origin}`;
      default:
        return "Ungltige Eingabe";
    }
  };
}, "kD");
function z3() {
  return { localeError: kD() };
}
__name(z3, "z3");
var GD = /* @__PURE__ */ __name(($) => {
  let q = typeof $;
  switch (q) {
    case "number":
      return Number.isNaN($) ? "NaN" : "number";
    case "object": {
      if (Array.isArray($)) return "array";
      if ($ === null) return "null";
      if (Object.getPrototypeOf($) !== Object.prototype && $.constructor) return $.constructor.name;
    }
  }
  return q;
}, "GD");
var VD = /* @__PURE__ */ __name(() => {
  let $ = { string: { unit: "characters", verb: "to have" }, file: { unit: "bytes", verb: "to have" }, array: { unit: "items", verb: "to have" }, set: { unit: "items", verb: "to have" } };
  function q(P) {
    return $[P] ?? null;
  }
  __name(q, "q");
  let K = { regex: "input", email: "email address", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO datetime", date: "ISO date", time: "ISO time", duration: "ISO duration", ipv4: "IPv4 address", ipv6: "IPv6 address", cidrv4: "IPv4 range", cidrv6: "IPv6 range", base64: "base64-encoded string", base64url: "base64url-encoded string", json_string: "JSON string", e164: "E.164 number", jwt: "JWT", template_literal: "input" };
  return (P) => {
    switch (P.code) {
      case "invalid_type":
        return `Invalid input: expected ${P.expected}, received ${GD(P.input)}`;
      case "invalid_value":
        if (P.values.length === 1) return `Invalid input: expected ${m$(P.values[0])}`;
        return `Invalid option: expected one of ${T$(P.values, "|")}`;
      case "too_big": {
        let _ = P.inclusive ? "<=" : "<", Y = q(P.origin);
        if (Y) return `Too big: expected ${P.origin ?? "value"} to have ${_}${P.maximum.toString()} ${Y.unit ?? "elements"}`;
        return `Too big: expected ${P.origin ?? "value"} to be ${_}${P.maximum.toString()}`;
      }
      case "too_small": {
        let _ = P.inclusive ? ">=" : ">", Y = q(P.origin);
        if (Y) return `Too small: expected ${P.origin} to have ${_}${P.minimum.toString()} ${Y.unit}`;
        return `Too small: expected ${P.origin} to be ${_}${P.minimum.toString()}`;
      }
      case "invalid_format": {
        let _ = P;
        if (_.format === "starts_with") return `Invalid string: must start with "${_.prefix}"`;
        if (_.format === "ends_with") return `Invalid string: must end with "${_.suffix}"`;
        if (_.format === "includes") return `Invalid string: must include "${_.includes}"`;
        if (_.format === "regex") return `Invalid string: must match pattern ${_.pattern}`;
        return `Invalid ${K[_.format] ?? P.format}`;
      }
      case "not_multiple_of":
        return `Invalid number: must be a multiple of ${P.divisor}`;
      case "unrecognized_keys":
        return `Unrecognized key${P.keys.length > 1 ? "s" : ""}: ${T$(P.keys, ", ")}`;
      case "invalid_key":
        return `Invalid key in ${P.origin}`;
      case "invalid_union":
        return "Invalid input";
      case "invalid_element":
        return `Invalid value in ${P.origin}`;
      default:
        return "Invalid input";
    }
  };
}, "VD");
function oP() {
  return { localeError: VD() };
}
__name(oP, "oP");
var SD = /* @__PURE__ */ __name(($) => {
  let q = typeof $;
  switch (q) {
    case "number":
      return Number.isNaN($) ? "NaN" : "nombro";
    case "object": {
      if (Array.isArray($)) return "tabelo";
      if ($ === null) return "senvalora";
      if (Object.getPrototypeOf($) !== Object.prototype && $.constructor) return $.constructor.name;
    }
  }
  return q;
}, "SD");
var MD = /* @__PURE__ */ __name(() => {
  let $ = { string: { unit: "karaktrojn", verb: "havi" }, file: { unit: "bajtojn", verb: "havi" }, array: { unit: "elementojn", verb: "havi" }, set: { unit: "elementojn", verb: "havi" } };
  function q(P) {
    return $[P] ?? null;
  }
  __name(q, "q");
  let K = { regex: "enigo", email: "retadreso", url: "URL", emoji: "emoio", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO-datotempo", date: "ISO-dato", time: "ISO-tempo", duration: "ISO-daro", ipv4: "IPv4-adreso", ipv6: "IPv6-adreso", cidrv4: "IPv4-rango", cidrv6: "IPv6-rango", base64: "64-ume kodita karaktraro", base64url: "URL-64-ume kodita karaktraro", json_string: "JSON-karaktraro", e164: "E.164-nombro", jwt: "JWT", template_literal: "enigo" };
  return (P) => {
    switch (P.code) {
      case "invalid_type":
        return `Nevalida enigo: atendiis ${P.expected}, riceviis ${SD(P.input)}`;
      case "invalid_value":
        if (P.values.length === 1) return `Nevalida enigo: atendiis ${m$(P.values[0])}`;
        return `Nevalida opcio: atendiis unu el ${T$(P.values, "|")}`;
      case "too_big": {
        let _ = P.inclusive ? "<=" : "<", Y = q(P.origin);
        if (Y) return `Tro granda: atendiis ke ${P.origin ?? "valoro"} havu ${_}${P.maximum.toString()} ${Y.unit ?? "elementojn"}`;
        return `Tro granda: atendiis ke ${P.origin ?? "valoro"} havu ${_}${P.maximum.toString()}`;
      }
      case "too_small": {
        let _ = P.inclusive ? ">=" : ">", Y = q(P.origin);
        if (Y) return `Tro malgranda: atendiis ke ${P.origin} havu ${_}${P.minimum.toString()} ${Y.unit}`;
        return `Tro malgranda: atendiis ke ${P.origin} estu ${_}${P.minimum.toString()}`;
      }
      case "invalid_format": {
        let _ = P;
        if (_.format === "starts_with") return `Nevalida karaktraro: devas komencii per "${_.prefix}"`;
        if (_.format === "ends_with") return `Nevalida karaktraro: devas finii per "${_.suffix}"`;
        if (_.format === "includes") return `Nevalida karaktraro: devas inkluzivi "${_.includes}"`;
        if (_.format === "regex") return `Nevalida karaktraro: devas kongrui kun la modelo ${_.pattern}`;
        return `Nevalida ${K[_.format] ?? P.format}`;
      }
      case "not_multiple_of":
        return `Nevalida nombro: devas esti oblo de ${P.divisor}`;
      case "unrecognized_keys":
        return `Nekonata${P.keys.length > 1 ? "j" : ""} losilo${P.keys.length > 1 ? "j" : ""}: ${T$(P.keys, ", ")}`;
      case "invalid_key":
        return `Nevalida losilo en ${P.origin}`;
      case "invalid_union":
        return "Nevalida enigo";
      case "invalid_element":
        return `Nevalida valoro en ${P.origin}`;
      default:
        return "Nevalida enigo";
    }
  };
}, "MD");
function W3() {
  return { localeError: MD() };
}
__name(W3, "W3");
var ND = /* @__PURE__ */ __name(() => {
  let $ = { string: { unit: "caracteres", verb: "tener" }, file: { unit: "bytes", verb: "tener" }, array: { unit: "elementos", verb: "tener" }, set: { unit: "elementos", verb: "tener" } }, q = { string: "texto", number: "nmero", boolean: "booleano", array: "arreglo", object: "objeto", set: "conjunto", file: "archivo", date: "fecha", bigint: "nmero grande", symbol: "smbolo", undefined: "indefinido", null: "nulo", function: "funcin", map: "mapa", record: "registro", tuple: "tupla", enum: "enumeracin", union: "unin", literal: "literal", promise: "promesa", void: "vaco", never: "nunca", unknown: "desconocido", any: "cualquiera" };
  function K(O) {
    return $[O] ?? null;
  }
  __name(K, "K");
  function P(O) {
    return q[O] ?? O;
  }
  __name(P, "P");
  let _ = /* @__PURE__ */ __name((O) => {
    let z = typeof O;
    switch (z) {
      case "number":
        return Number.isNaN(O) ? "NaN" : "number";
      case "object": {
        if (Array.isArray(O)) return "array";
        if (O === null) return "null";
        if (Object.getPrototypeOf(O) !== Object.prototype) return O.constructor.name;
        return "object";
      }
    }
    return z;
  }, "_"), Y = { regex: "entrada", email: "direccin de correo electrnico", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "fecha y hora ISO", date: "fecha ISO", time: "hora ISO", duration: "duracin ISO", ipv4: "direccin IPv4", ipv6: "direccin IPv6", cidrv4: "rango IPv4", cidrv6: "rango IPv6", base64: "cadena codificada en base64", base64url: "URL codificada en base64", json_string: "cadena JSON", e164: "nmero E.164", jwt: "JWT", template_literal: "entrada" };
  return (O) => {
    switch (O.code) {
      case "invalid_type":
        return `Entrada invlida: se esperaba ${P(O.expected)}, recibido ${P(_(O.input))}`;
      case "invalid_value":
        if (O.values.length === 1) return `Entrada invlida: se esperaba ${m$(O.values[0])}`;
        return `Opcin invlida: se esperaba una de ${T$(O.values, "|")}`;
      case "too_big": {
        let z = O.inclusive ? "<=" : "<", J = K(O.origin), T = P(O.origin);
        if (J) return `Demasiado grande: se esperaba que ${T ?? "valor"} tuviera ${z}${O.maximum.toString()} ${J.unit ?? "elementos"}`;
        return `Demasiado grande: se esperaba que ${T ?? "valor"} fuera ${z}${O.maximum.toString()}`;
      }
      case "too_small": {
        let z = O.inclusive ? ">=" : ">", J = K(O.origin), T = P(O.origin);
        if (J) return `Demasiado pequeo: se esperaba que ${T} tuviera ${z}${O.minimum.toString()} ${J.unit}`;
        return `Demasiado pequeo: se esperaba que ${T} fuera ${z}${O.minimum.toString()}`;
      }
      case "invalid_format": {
        let z = O;
        if (z.format === "starts_with") return `Cadena invlida: debe comenzar con "${z.prefix}"`;
        if (z.format === "ends_with") return `Cadena invlida: debe terminar en "${z.suffix}"`;
        if (z.format === "includes") return `Cadena invlida: debe incluir "${z.includes}"`;
        if (z.format === "regex") return `Cadena invlida: debe coincidir con el patrn ${z.pattern}`;
        return `Invlido ${Y[z.format] ?? O.format}`;
      }
      case "not_multiple_of":
        return `Nmero invlido: debe ser mltiplo de ${O.divisor}`;
      case "unrecognized_keys":
        return `Llave${O.keys.length > 1 ? "s" : ""} desconocida${O.keys.length > 1 ? "s" : ""}: ${T$(O.keys, ", ")}`;
      case "invalid_key":
        return `Llave invlida en ${P(O.origin)}`;
      case "invalid_union":
        return "Entrada invlida";
      case "invalid_element":
        return `Valor invlido en ${P(O.origin)}`;
      default:
        return "Entrada invlida";
    }
  };
}, "ND");
function H3() {
  return { localeError: ND() };
}
__name(H3, "H3");
var CD = /* @__PURE__ */ __name(() => {
  let $ = { string: { unit: "", verb: " " }, file: { unit: "", verb: " " }, array: { unit: "", verb: " " }, set: { unit: "", verb: " " } };
  function q(_) {
    return $[_] ?? null;
  }
  __name(q, "q");
  let K = /* @__PURE__ */ __name((_) => {
    let Y = typeof _;
    switch (Y) {
      case "number":
        return Number.isNaN(_) ? "NaN" : "";
      case "object": {
        if (Array.isArray(_)) return "";
        if (_ === null) return "null";
        if (Object.getPrototypeOf(_) !== Object.prototype && _.constructor) return _.constructor.name;
      }
    }
    return Y;
  }, "K"), P = { regex: "", email: " ", url: "URL", emoji: "", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "   ", date: " ", time: " ", duration: "  ", ipv4: "IPv4 ", ipv6: "IPv6 ", cidrv4: "IPv4 ", cidrv6: "IPv6 ", base64: "base64-encoded ", base64url: "base64url-encoded ", json_string: "JSON ", e164: "E.164 ", jwt: "JWT", template_literal: "" };
  return (_) => {
    switch (_.code) {
      case "invalid_type":
        return ` :  ${_.expected}  ${K(_.input)}  `;
      case "invalid_value":
        if (_.values.length === 1) return ` :  ${m$(_.values[0])} `;
        return ` :    ${T$(_.values, "|")} `;
      case "too_big": {
        let Y = _.inclusive ? "<=" : "<", O = q(_.origin);
        if (O) return ` : ${_.origin ?? ""}  ${Y}${_.maximum.toString()} ${O.unit ?? ""} `;
        return ` : ${_.origin ?? ""}  ${Y}${_.maximum.toString()} `;
      }
      case "too_small": {
        let Y = _.inclusive ? ">=" : ">", O = q(_.origin);
        if (O) return ` : ${_.origin}  ${Y}${_.minimum.toString()} ${O.unit} `;
        return ` : ${_.origin}  ${Y}${_.minimum.toString()} `;
      }
      case "invalid_format": {
        let Y = _;
        if (Y.format === "starts_with") return ` :   "${Y.prefix}"  `;
        if (Y.format === "ends_with") return ` :   "${Y.suffix}"  `;
        if (Y.format === "includes") return ` :   "${Y.includes}" `;
        if (Y.format === "regex") return ` :    ${Y.pattern}   `;
        return `${P[Y.format] ?? _.format} `;
      }
      case "not_multiple_of":
        return ` :   ${_.divisor} `;
      case "unrecognized_keys":
        return `${_.keys.length > 1 ? "" : ""} : ${T$(_.keys, ", ")}`;
      case "invalid_key":
        return `   ${_.origin}`;
      case "invalid_union":
        return " ";
      case "invalid_element":
        return `   ${_.origin}`;
      default:
        return " ";
    }
  };
}, "CD");
function J3() {
  return { localeError: CD() };
}
__name(J3, "J3");
var hD = /* @__PURE__ */ __name(() => {
  let $ = { string: { unit: "merkki", subject: "merkkijonon" }, file: { unit: "tavua", subject: "tiedoston" }, array: { unit: "alkiota", subject: "listan" }, set: { unit: "alkiota", subject: "joukon" }, number: { unit: "", subject: "luvun" }, bigint: { unit: "", subject: "suuren kokonaisluvun" }, int: { unit: "", subject: "kokonaisluvun" }, date: { unit: "", subject: "pivmrn" } };
  function q(_) {
    return $[_] ?? null;
  }
  __name(q, "q");
  let K = /* @__PURE__ */ __name((_) => {
    let Y = typeof _;
    switch (Y) {
      case "number":
        return Number.isNaN(_) ? "NaN" : "number";
      case "object": {
        if (Array.isArray(_)) return "array";
        if (_ === null) return "null";
        if (Object.getPrototypeOf(_) !== Object.prototype && _.constructor) return _.constructor.name;
      }
    }
    return Y;
  }, "K"), P = { regex: "snnllinen lauseke", email: "shkpostiosoite", url: "URL-osoite", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO-aikaleima", date: "ISO-pivmr", time: "ISO-aika", duration: "ISO-kesto", ipv4: "IPv4-osoite", ipv6: "IPv6-osoite", cidrv4: "IPv4-alue", cidrv6: "IPv6-alue", base64: "base64-koodattu merkkijono", base64url: "base64url-koodattu merkkijono", json_string: "JSON-merkkijono", e164: "E.164-luku", jwt: "JWT", template_literal: "templaattimerkkijono" };
  return (_) => {
    switch (_.code) {
      case "invalid_type":
        return `Virheellinen tyyppi: odotettiin ${_.expected}, oli ${K(_.input)}`;
      case "invalid_value":
        if (_.values.length === 1) return `Virheellinen syte: tytyy olla ${m$(_.values[0])}`;
        return `Virheellinen valinta: tytyy olla yksi seuraavista: ${T$(_.values, "|")}`;
      case "too_big": {
        let Y = _.inclusive ? "<=" : "<", O = q(_.origin);
        if (O) return `Liian suuri: ${O.subject} tytyy olla ${Y}${_.maximum.toString()} ${O.unit}`.trim();
        return `Liian suuri: arvon tytyy olla ${Y}${_.maximum.toString()}`;
      }
      case "too_small": {
        let Y = _.inclusive ? ">=" : ">", O = q(_.origin);
        if (O) return `Liian pieni: ${O.subject} tytyy olla ${Y}${_.minimum.toString()} ${O.unit}`.trim();
        return `Liian pieni: arvon tytyy olla ${Y}${_.minimum.toString()}`;
      }
      case "invalid_format": {
        let Y = _;
        if (Y.format === "starts_with") return `Virheellinen syte: tytyy alkaa "${Y.prefix}"`;
        if (Y.format === "ends_with") return `Virheellinen syte: tytyy loppua "${Y.suffix}"`;
        if (Y.format === "includes") return `Virheellinen syte: tytyy sislt "${Y.includes}"`;
        if (Y.format === "regex") return `Virheellinen syte: tytyy vastata snnllist lauseketta ${Y.pattern}`;
        return `Virheellinen ${P[Y.format] ?? _.format}`;
      }
      case "not_multiple_of":
        return `Virheellinen luku: tytyy olla luvun ${_.divisor} monikerta`;
      case "unrecognized_keys":
        return `${_.keys.length > 1 ? "Tuntemattomat avaimet" : "Tuntematon avain"}: ${T$(_.keys, ", ")}`;
      case "invalid_key":
        return "Virheellinen avain tietueessa";
      case "invalid_union":
        return "Virheellinen unioni";
      case "invalid_element":
        return "Virheellinen arvo joukossa";
      default:
        return "Virheellinen syte";
    }
  };
}, "hD");
function T3() {
  return { localeError: hD() };
}
__name(T3, "T3");
var ED = /* @__PURE__ */ __name(() => {
  let $ = { string: { unit: "caractres", verb: "avoir" }, file: { unit: "octets", verb: "avoir" }, array: { unit: "lments", verb: "avoir" }, set: { unit: "lments", verb: "avoir" } };
  function q(_) {
    return $[_] ?? null;
  }
  __name(q, "q");
  let K = /* @__PURE__ */ __name((_) => {
    let Y = typeof _;
    switch (Y) {
      case "number":
        return Number.isNaN(_) ? "NaN" : "nombre";
      case "object": {
        if (Array.isArray(_)) return "tableau";
        if (_ === null) return "null";
        if (Object.getPrototypeOf(_) !== Object.prototype && _.constructor) return _.constructor.name;
      }
    }
    return Y;
  }, "K"), P = { regex: "entre", email: "adresse e-mail", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "date et heure ISO", date: "date ISO", time: "heure ISO", duration: "dure ISO", ipv4: "adresse IPv4", ipv6: "adresse IPv6", cidrv4: "plage IPv4", cidrv6: "plage IPv6", base64: "chane encode en base64", base64url: "chane encode en base64url", json_string: "chane JSON", e164: "numro E.164", jwt: "JWT", template_literal: "entre" };
  return (_) => {
    switch (_.code) {
      case "invalid_type":
        return `Entre invalide : ${_.expected} attendu, ${K(_.input)} reu`;
      case "invalid_value":
        if (_.values.length === 1) return `Entre invalide : ${m$(_.values[0])} attendu`;
        return `Option invalide : une valeur parmi ${T$(_.values, "|")} attendue`;
      case "too_big": {
        let Y = _.inclusive ? "<=" : "<", O = q(_.origin);
        if (O) return `Trop grand : ${_.origin ?? "valeur"} doit ${O.verb} ${Y}${_.maximum.toString()} ${O.unit ?? "lment(s)"}`;
        return `Trop grand : ${_.origin ?? "valeur"} doit tre ${Y}${_.maximum.toString()}`;
      }
      case "too_small": {
        let Y = _.inclusive ? ">=" : ">", O = q(_.origin);
        if (O) return `Trop petit : ${_.origin} doit ${O.verb} ${Y}${_.minimum.toString()} ${O.unit}`;
        return `Trop petit : ${_.origin} doit tre ${Y}${_.minimum.toString()}`;
      }
      case "invalid_format": {
        let Y = _;
        if (Y.format === "starts_with") return `Chane invalide : doit commencer par "${Y.prefix}"`;
        if (Y.format === "ends_with") return `Chane invalide : doit se terminer par "${Y.suffix}"`;
        if (Y.format === "includes") return `Chane invalide : doit inclure "${Y.includes}"`;
        if (Y.format === "regex") return `Chane invalide : doit correspondre au modle ${Y.pattern}`;
        return `${P[Y.format] ?? _.format} invalide`;
      }
      case "not_multiple_of":
        return `Nombre invalide : doit tre un multiple de ${_.divisor}`;
      case "unrecognized_keys":
        return `Cl${_.keys.length > 1 ? "s" : ""} non reconnue${_.keys.length > 1 ? "s" : ""} : ${T$(_.keys, ", ")}`;
      case "invalid_key":
        return `Cl invalide dans ${_.origin}`;
      case "invalid_union":
        return "Entre invalide";
      case "invalid_element":
        return `Valeur invalide dans ${_.origin}`;
      default:
        return "Entre invalide";
    }
  };
}, "ED");
function w3() {
  return { localeError: ED() };
}
__name(w3, "w3");
var RD = /* @__PURE__ */ __name(() => {
  let $ = { string: { unit: "caractres", verb: "avoir" }, file: { unit: "octets", verb: "avoir" }, array: { unit: "lments", verb: "avoir" }, set: { unit: "lments", verb: "avoir" } };
  function q(_) {
    return $[_] ?? null;
  }
  __name(q, "q");
  let K = /* @__PURE__ */ __name((_) => {
    let Y = typeof _;
    switch (Y) {
      case "number":
        return Number.isNaN(_) ? "NaN" : "number";
      case "object": {
        if (Array.isArray(_)) return "array";
        if (_ === null) return "null";
        if (Object.getPrototypeOf(_) !== Object.prototype && _.constructor) return _.constructor.name;
      }
    }
    return Y;
  }, "K"), P = { regex: "entre", email: "adresse courriel", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "date-heure ISO", date: "date ISO", time: "heure ISO", duration: "dure ISO", ipv4: "adresse IPv4", ipv6: "adresse IPv6", cidrv4: "plage IPv4", cidrv6: "plage IPv6", base64: "chane encode en base64", base64url: "chane encode en base64url", json_string: "chane JSON", e164: "numro E.164", jwt: "JWT", template_literal: "entre" };
  return (_) => {
    switch (_.code) {
      case "invalid_type":
        return `Entre invalide : attendu ${_.expected}, reu ${K(_.input)}`;
      case "invalid_value":
        if (_.values.length === 1) return `Entre invalide : attendu ${m$(_.values[0])}`;
        return `Option invalide : attendu l'une des valeurs suivantes ${T$(_.values, "|")}`;
      case "too_big": {
        let Y = _.inclusive ? "" : "<", O = q(_.origin);
        if (O) return `Trop grand : attendu que ${_.origin ?? "la valeur"} ait ${Y}${_.maximum.toString()} ${O.unit}`;
        return `Trop grand : attendu que ${_.origin ?? "la valeur"} soit ${Y}${_.maximum.toString()}`;
      }
      case "too_small": {
        let Y = _.inclusive ? "" : ">", O = q(_.origin);
        if (O) return `Trop petit : attendu que ${_.origin} ait ${Y}${_.minimum.toString()} ${O.unit}`;
        return `Trop petit : attendu que ${_.origin} soit ${Y}${_.minimum.toString()}`;
      }
      case "invalid_format": {
        let Y = _;
        if (Y.format === "starts_with") return `Chane invalide : doit commencer par "${Y.prefix}"`;
        if (Y.format === "ends_with") return `Chane invalide : doit se terminer par "${Y.suffix}"`;
        if (Y.format === "includes") return `Chane invalide : doit inclure "${Y.includes}"`;
        if (Y.format === "regex") return `Chane invalide : doit correspondre au motif ${Y.pattern}`;
        return `${P[Y.format] ?? _.format} invalide`;
      }
      case "not_multiple_of":
        return `Nombre invalide : doit tre un multiple de ${_.divisor}`;
      case "unrecognized_keys":
        return `Cl${_.keys.length > 1 ? "s" : ""} non reconnue${_.keys.length > 1 ? "s" : ""} : ${T$(_.keys, ", ")}`;
      case "invalid_key":
        return `Cl invalide dans ${_.origin}`;
      case "invalid_union":
        return "Entre invalide";
      case "invalid_element":
        return `Valeur invalide dans ${_.origin}`;
      default:
        return "Entre invalide";
    }
  };
}, "RD");
function f3() {
  return { localeError: RD() };
}
__name(f3, "f3");
var ID = /* @__PURE__ */ __name(() => {
  let $ = { string: { unit: "", verb: "" }, file: { unit: "", verb: "" }, array: { unit: "", verb: "" }, set: { unit: "", verb: "" } };
  function q(_) {
    return $[_] ?? null;
  }
  __name(q, "q");
  let K = /* @__PURE__ */ __name((_) => {
    let Y = typeof _;
    switch (Y) {
      case "number":
        return Number.isNaN(_) ? "NaN" : "number";
      case "object": {
        if (Array.isArray(_)) return "array";
        if (_ === null) return "null";
        if (Object.getPrototypeOf(_) !== Object.prototype && _.constructor) return _.constructor.name;
      }
    }
    return Y;
  }, "K"), P = { regex: "", email: " ", url: " ", emoji: "'", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "  ISO", date: " ISO", time: " ISO", duration: "  ISO", ipv4: " IPv4", ipv6: " IPv6", cidrv4: " IPv4", cidrv6: " IPv6", base64: "  64", base64url: "  64  ", json_string: " JSON", e164: " E.164", jwt: "JWT", template_literal: "" };
  return (_) => {
    switch (_.code) {
      case "invalid_type":
        return `  :  ${_.expected},  ${K(_.input)}`;
      case "invalid_value":
        if (_.values.length === 1) return `  :  ${m$(_.values[0])}`;
        return `  :     ${T$(_.values, "|")}`;
      case "too_big": {
        let Y = _.inclusive ? "<=" : "<", O = q(_.origin);
        if (O) return ` : ${_.origin ?? "value"}   ${Y}${_.maximum.toString()} ${O.unit ?? "elements"}`;
        return ` : ${_.origin ?? "value"}   ${Y}${_.maximum.toString()}`;
      }
      case "too_small": {
        let Y = _.inclusive ? ">=" : ">", O = q(_.origin);
        if (O) return ` : ${_.origin}   ${Y}${_.minimum.toString()} ${O.unit}`;
        return ` : ${_.origin}   ${Y}${_.minimum.toString()}`;
      }
      case "invalid_format": {
        let Y = _;
        if (Y.format === "starts_with") return `  :   "${Y.prefix}"`;
        if (Y.format === "ends_with") return `  :    "${Y.suffix}"`;
        if (Y.format === "includes") return `  :   "${Y.includes}"`;
        if (Y.format === "regex") return `  :    ${Y.pattern}`;
        return `${P[Y.format] ?? _.format}  `;
      }
      case "not_multiple_of":
        return `  :     ${_.divisor}`;
      case "unrecognized_keys":
        return `${_.keys.length > 1 ? "" : ""}  ${_.keys.length > 1 ? "" : ""}: ${T$(_.keys, ", ")}`;
      case "invalid_key":
        return `   ${_.origin}`;
      case "invalid_union":
        return "  ";
      case "invalid_element":
        return `   ${_.origin}`;
      default:
        return "  ";
    }
  };
}, "ID");
function Z3() {
  return { localeError: ID() };
}
__name(Z3, "Z3");
var DD = /* @__PURE__ */ __name(() => {
  let $ = { string: { unit: "karakter", verb: "legyen" }, file: { unit: "byte", verb: "legyen" }, array: { unit: "elem", verb: "legyen" }, set: { unit: "elem", verb: "legyen" } };
  function q(_) {
    return $[_] ?? null;
  }
  __name(q, "q");
  let K = /* @__PURE__ */ __name((_) => {
    let Y = typeof _;
    switch (Y) {
      case "number":
        return Number.isNaN(_) ? "NaN" : "szm";
      case "object": {
        if (Array.isArray(_)) return "tmb";
        if (_ === null) return "null";
        if (Object.getPrototypeOf(_) !== Object.prototype && _.constructor) return _.constructor.name;
      }
    }
    return Y;
  }, "K"), P = { regex: "bemenet", email: "email cm", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO idblyeg", date: "ISO dtum", time: "ISO id", duration: "ISO idintervallum", ipv4: "IPv4 cm", ipv6: "IPv6 cm", cidrv4: "IPv4 tartomny", cidrv6: "IPv6 tartomny", base64: "base64-kdolt string", base64url: "base64url-kdolt string", json_string: "JSON string", e164: "E.164 szm", jwt: "JWT", template_literal: "bemenet" };
  return (_) => {
    switch (_.code) {
      case "invalid_type":
        return `rvnytelen bemenet: a vrt rtk ${_.expected}, a kapott rtk ${K(_.input)}`;
      case "invalid_value":
        if (_.values.length === 1) return `rvnytelen bemenet: a vrt rtk ${m$(_.values[0])}`;
        return `rvnytelen opci: valamelyik rtk vrt ${T$(_.values, "|")}`;
      case "too_big": {
        let Y = _.inclusive ? "<=" : "<", O = q(_.origin);
        if (O) return `Tl nagy: ${_.origin ?? "rtk"} mrete tl nagy ${Y}${_.maximum.toString()} ${O.unit ?? "elem"}`;
        return `Tl nagy: a bemeneti rtk ${_.origin ?? "rtk"} tl nagy: ${Y}${_.maximum.toString()}`;
      }
      case "too_small": {
        let Y = _.inclusive ? ">=" : ">", O = q(_.origin);
        if (O) return `Tl kicsi: a bemeneti rtk ${_.origin} mrete tl kicsi ${Y}${_.minimum.toString()} ${O.unit}`;
        return `Tl kicsi: a bemeneti rtk ${_.origin} tl kicsi ${Y}${_.minimum.toString()}`;
      }
      case "invalid_format": {
        let Y = _;
        if (Y.format === "starts_with") return `rvnytelen string: "${Y.prefix}" rtkkel kell kezddnie`;
        if (Y.format === "ends_with") return `rvnytelen string: "${Y.suffix}" rtkkel kell vgzdnie`;
        if (Y.format === "includes") return `rvnytelen string: "${Y.includes}" rtket kell tartalmaznia`;
        if (Y.format === "regex") return `rvnytelen string: ${Y.pattern} mintnak kell megfelelnie`;
        return `rvnytelen ${P[Y.format] ?? _.format}`;
      }
      case "not_multiple_of":
        return `rvnytelen szm: ${_.divisor} tbbszrsnek kell lennie`;
      case "unrecognized_keys":
        return `Ismeretlen kulcs${_.keys.length > 1 ? "s" : ""}: ${T$(_.keys, ", ")}`;
      case "invalid_key":
        return `rvnytelen kulcs ${_.origin}`;
      case "invalid_union":
        return "rvnytelen bemenet";
      case "invalid_element":
        return `rvnytelen rtk: ${_.origin}`;
      default:
        return "rvnytelen bemenet";
    }
  };
}, "DD");
function X3() {
  return { localeError: DD() };
}
__name(X3, "X3");
var LD = /* @__PURE__ */ __name(() => {
  let $ = { string: { unit: "karakter", verb: "memiliki" }, file: { unit: "byte", verb: "memiliki" }, array: { unit: "item", verb: "memiliki" }, set: { unit: "item", verb: "memiliki" } };
  function q(_) {
    return $[_] ?? null;
  }
  __name(q, "q");
  let K = /* @__PURE__ */ __name((_) => {
    let Y = typeof _;
    switch (Y) {
      case "number":
        return Number.isNaN(_) ? "NaN" : "number";
      case "object": {
        if (Array.isArray(_)) return "array";
        if (_ === null) return "null";
        if (Object.getPrototypeOf(_) !== Object.prototype && _.constructor) return _.constructor.name;
      }
    }
    return Y;
  }, "K"), P = { regex: "input", email: "alamat email", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "tanggal dan waktu format ISO", date: "tanggal format ISO", time: "jam format ISO", duration: "durasi format ISO", ipv4: "alamat IPv4", ipv6: "alamat IPv6", cidrv4: "rentang alamat IPv4", cidrv6: "rentang alamat IPv6", base64: "string dengan enkode base64", base64url: "string dengan enkode base64url", json_string: "string JSON", e164: "angka E.164", jwt: "JWT", template_literal: "input" };
  return (_) => {
    switch (_.code) {
      case "invalid_type":
        return `Input tidak valid: diharapkan ${_.expected}, diterima ${K(_.input)}`;
      case "invalid_value":
        if (_.values.length === 1) return `Input tidak valid: diharapkan ${m$(_.values[0])}`;
        return `Pilihan tidak valid: diharapkan salah satu dari ${T$(_.values, "|")}`;
      case "too_big": {
        let Y = _.inclusive ? "<=" : "<", O = q(_.origin);
        if (O) return `Terlalu besar: diharapkan ${_.origin ?? "value"} memiliki ${Y}${_.maximum.toString()} ${O.unit ?? "elemen"}`;
        return `Terlalu besar: diharapkan ${_.origin ?? "value"} menjadi ${Y}${_.maximum.toString()}`;
      }
      case "too_small": {
        let Y = _.inclusive ? ">=" : ">", O = q(_.origin);
        if (O) return `Terlalu kecil: diharapkan ${_.origin} memiliki ${Y}${_.minimum.toString()} ${O.unit}`;
        return `Terlalu kecil: diharapkan ${_.origin} menjadi ${Y}${_.minimum.toString()}`;
      }
      case "invalid_format": {
        let Y = _;
        if (Y.format === "starts_with") return `String tidak valid: harus dimulai dengan "${Y.prefix}"`;
        if (Y.format === "ends_with") return `String tidak valid: harus berakhir dengan "${Y.suffix}"`;
        if (Y.format === "includes") return `String tidak valid: harus menyertakan "${Y.includes}"`;
        if (Y.format === "regex") return `String tidak valid: harus sesuai pola ${Y.pattern}`;
        return `${P[Y.format] ?? _.format} tidak valid`;
      }
      case "not_multiple_of":
        return `Angka tidak valid: harus kelipatan dari ${_.divisor}`;
      case "unrecognized_keys":
        return `Kunci tidak dikenali ${_.keys.length > 1 ? "s" : ""}: ${T$(_.keys, ", ")}`;
      case "invalid_key":
        return `Kunci tidak valid di ${_.origin}`;
      case "invalid_union":
        return "Input tidak valid";
      case "invalid_element":
        return `Nilai tidak valid di ${_.origin}`;
      default:
        return "Input tidak valid";
    }
  };
}, "LD");
function A3() {
  return { localeError: LD() };
}
__name(A3, "A3");
var gD = /* @__PURE__ */ __name(($) => {
  let q = typeof $;
  switch (q) {
    case "number":
      return Number.isNaN($) ? "NaN" : "nmer";
    case "object": {
      if (Array.isArray($)) return "fylki";
      if ($ === null) return "null";
      if (Object.getPrototypeOf($) !== Object.prototype && $.constructor) return $.constructor.name;
    }
  }
  return q;
}, "gD");
var bD = /* @__PURE__ */ __name(() => {
  let $ = { string: { unit: "stafi", verb: "a hafa" }, file: { unit: "bti", verb: "a hafa" }, array: { unit: "hluti", verb: "a hafa" }, set: { unit: "hluti", verb: "a hafa" } };
  function q(P) {
    return $[P] ?? null;
  }
  __name(q, "q");
  let K = { regex: "gildi", email: "netfang", url: "vefsl", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO dagsetning og tmi", date: "ISO dagsetning", time: "ISO tmi", duration: "ISO tmalengd", ipv4: "IPv4 address", ipv6: "IPv6 address", cidrv4: "IPv4 range", cidrv6: "IPv6 range", base64: "base64-encoded strengur", base64url: "base64url-encoded strengur", json_string: "JSON strengur", e164: "E.164 tlugildi", jwt: "JWT", template_literal: "gildi" };
  return (P) => {
    switch (P.code) {
      case "invalid_type":
        return `Rangt gildi:  slst inn ${gD(P.input)} ar sem  a vera ${P.expected}`;
      case "invalid_value":
        if (P.values.length === 1) return `Rangt gildi: gert r fyrir ${m$(P.values[0])}`;
        return `gilt val: m vera eitt af eftirfarandi ${T$(P.values, "|")}`;
      case "too_big": {
        let _ = P.inclusive ? "<=" : "<", Y = q(P.origin);
        if (Y) return `Of strt: gert er r fyrir a ${P.origin ?? "gildi"} hafi ${_}${P.maximum.toString()} ${Y.unit ?? "hluti"}`;
        return `Of strt: gert er r fyrir a ${P.origin ?? "gildi"} s ${_}${P.maximum.toString()}`;
      }
      case "too_small": {
        let _ = P.inclusive ? ">=" : ">", Y = q(P.origin);
        if (Y) return `Of lti: gert er r fyrir a ${P.origin} hafi ${_}${P.minimum.toString()} ${Y.unit}`;
        return `Of lti: gert er r fyrir a ${P.origin} s ${_}${P.minimum.toString()}`;
      }
      case "invalid_format": {
        let _ = P;
        if (_.format === "starts_with") return `gildur strengur: verur a byrja  "${_.prefix}"`;
        if (_.format === "ends_with") return `gildur strengur: verur a enda  "${_.suffix}"`;
        if (_.format === "includes") return `gildur strengur: verur a innihalda "${_.includes}"`;
        if (_.format === "regex") return `gildur strengur: verur a fylgja mynstri ${_.pattern}`;
        return `Rangt ${K[_.format] ?? P.format}`;
      }
      case "not_multiple_of":
        return `Rng tala: verur a vera margfeldi af ${P.divisor}`;
      case "unrecognized_keys":
        return `ekkt ${P.keys.length > 1 ? "ir lyklar" : "ur lykill"}: ${T$(P.keys, ", ")}`;
      case "invalid_key":
        return `Rangur lykill  ${P.origin}`;
      case "invalid_union":
        return "Rangt gildi";
      case "invalid_element":
        return `Rangt gildi  ${P.origin}`;
      default:
        return "Rangt gildi";
    }
  };
}, "bD");
function k3() {
  return { localeError: bD() };
}
__name(k3, "k3");
var yD = /* @__PURE__ */ __name(() => {
  let $ = { string: { unit: "caratteri", verb: "avere" }, file: { unit: "byte", verb: "avere" }, array: { unit: "elementi", verb: "avere" }, set: { unit: "elementi", verb: "avere" } };
  function q(_) {
    return $[_] ?? null;
  }
  __name(q, "q");
  let K = /* @__PURE__ */ __name((_) => {
    let Y = typeof _;
    switch (Y) {
      case "number":
        return Number.isNaN(_) ? "NaN" : "numero";
      case "object": {
        if (Array.isArray(_)) return "vettore";
        if (_ === null) return "null";
        if (Object.getPrototypeOf(_) !== Object.prototype && _.constructor) return _.constructor.name;
      }
    }
    return Y;
  }, "K"), P = { regex: "input", email: "indirizzo email", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "data e ora ISO", date: "data ISO", time: "ora ISO", duration: "durata ISO", ipv4: "indirizzo IPv4", ipv6: "indirizzo IPv6", cidrv4: "intervallo IPv4", cidrv6: "intervallo IPv6", base64: "stringa codificata in base64", base64url: "URL codificata in base64", json_string: "stringa JSON", e164: "numero E.164", jwt: "JWT", template_literal: "input" };
  return (_) => {
    switch (_.code) {
      case "invalid_type":
        return `Input non valido: atteso ${_.expected}, ricevuto ${K(_.input)}`;
      case "invalid_value":
        if (_.values.length === 1) return `Input non valido: atteso ${m$(_.values[0])}`;
        return `Opzione non valida: atteso uno tra ${T$(_.values, "|")}`;
      case "too_big": {
        let Y = _.inclusive ? "<=" : "<", O = q(_.origin);
        if (O) return `Troppo grande: ${_.origin ?? "valore"} deve avere ${Y}${_.maximum.toString()} ${O.unit ?? "elementi"}`;
        return `Troppo grande: ${_.origin ?? "valore"} deve essere ${Y}${_.maximum.toString()}`;
      }
      case "too_small": {
        let Y = _.inclusive ? ">=" : ">", O = q(_.origin);
        if (O) return `Troppo piccolo: ${_.origin} deve avere ${Y}${_.minimum.toString()} ${O.unit}`;
        return `Troppo piccolo: ${_.origin} deve essere ${Y}${_.minimum.toString()}`;
      }
      case "invalid_format": {
        let Y = _;
        if (Y.format === "starts_with") return `Stringa non valida: deve iniziare con "${Y.prefix}"`;
        if (Y.format === "ends_with") return `Stringa non valida: deve terminare con "${Y.suffix}"`;
        if (Y.format === "includes") return `Stringa non valida: deve includere "${Y.includes}"`;
        if (Y.format === "regex") return `Stringa non valida: deve corrispondere al pattern ${Y.pattern}`;
        return `Invalid ${P[Y.format] ?? _.format}`;
      }
      case "not_multiple_of":
        return `Numero non valido: deve essere un multiplo di ${_.divisor}`;
      case "unrecognized_keys":
        return `Chiav${_.keys.length > 1 ? "i" : "e"} non riconosciut${_.keys.length > 1 ? "e" : "a"}: ${T$(_.keys, ", ")}`;
      case "invalid_key":
        return `Chiave non valida in ${_.origin}`;
      case "invalid_union":
        return "Input non valido";
      case "invalid_element":
        return `Valore non valido in ${_.origin}`;
      default:
        return "Input non valido";
    }
  };
}, "yD");
function G3() {
  return { localeError: yD() };
}
__name(G3, "G3");
var uD = /* @__PURE__ */ __name(() => {
  let $ = { string: { unit: "", verb: "" }, file: { unit: "", verb: "" }, array: { unit: "", verb: "" }, set: { unit: "", verb: "" } };
  function q(_) {
    return $[_] ?? null;
  }
  __name(q, "q");
  let K = /* @__PURE__ */ __name((_) => {
    let Y = typeof _;
    switch (Y) {
      case "number":
        return Number.isNaN(_) ? "NaN" : "";
      case "object": {
        if (Array.isArray(_)) return "";
        if (_ === null) return "null";
        if (Object.getPrototypeOf(_) !== Object.prototype && _.constructor) return _.constructor.name;
      }
    }
    return Y;
  }, "K"), P = { regex: "", email: "", url: "URL", emoji: "", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO", date: "ISO", time: "ISO", duration: "ISO", ipv4: "IPv4", ipv6: "IPv6", cidrv4: "IPv4", cidrv6: "IPv6", base64: "base64", base64url: "base64url", json_string: "JSON", e164: "E.164", jwt: "JWT", template_literal: "" };
  return (_) => {
    switch (_.code) {
      case "invalid_type":
        return `: ${_.expected}${K(_.input)}`;
      case "invalid_value":
        if (_.values.length === 1) return `: ${m$(_.values[0])}`;
        return `: ${T$(_.values, "")}`;
      case "too_big": {
        let Y = _.inclusive ? "" : "", O = q(_.origin);
        if (O) return `: ${_.origin ?? ""}${_.maximum.toString()}${O.unit ?? ""}${Y}`;
        return `: ${_.origin ?? ""}${_.maximum.toString()}${Y}`;
      }
      case "too_small": {
        let Y = _.inclusive ? "" : "", O = q(_.origin);
        if (O) return `: ${_.origin}${_.minimum.toString()}${O.unit}${Y}`;
        return `: ${_.origin}${_.minimum.toString()}${Y}`;
      }
      case "invalid_format": {
        let Y = _;
        if (Y.format === "starts_with") return `: "${Y.prefix}"`;
        if (Y.format === "ends_with") return `: "${Y.suffix}"`;
        if (Y.format === "includes") return `: "${Y.includes}"`;
        if (Y.format === "regex") return `: ${Y.pattern}`;
        return `${P[Y.format] ?? _.format}`;
      }
      case "not_multiple_of":
        return `: ${_.divisor}`;
      case "unrecognized_keys":
        return `${_.keys.length > 1 ? "" : ""}: ${T$(_.keys, "")}`;
      case "invalid_key":
        return `${_.origin}`;
      case "invalid_union":
        return "";
      case "invalid_element":
        return `${_.origin}`;
      default:
        return "";
    }
  };
}, "uD");
function V3() {
  return { localeError: uD() };
}
__name(V3, "V3");
var xD = /* @__PURE__ */ __name(($) => {
  let q = typeof $;
  switch (q) {
    case "number":
      return Number.isNaN($) ? "NaN" : "";
    case "object": {
      if (Array.isArray($)) return "";
      if ($ === null) return "null";
      if (Object.getPrototypeOf($) !== Object.prototype && $.constructor) return $.constructor.name;
    }
  }
  return { string: "", boolean: "", undefined: "undefined", bigint: "bigint", symbol: "symbol", function: "" }[q] ?? q;
}, "xD");
var pD = /* @__PURE__ */ __name(() => {
  let $ = { string: { unit: "", verb: " " }, file: { unit: "", verb: " " }, array: { unit: "", verb: " " }, set: { unit: "", verb: " " } };
  function q(P) {
    return $[P] ?? null;
  }
  __name(q, "q");
  let K = { regex: "", email: "- ", url: "URL", emoji: "", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "-", date: "", time: "", duration: "", ipv4: "IPv4 ", ipv6: "IPv6 ", cidrv4: "IPv4 ", cidrv6: "IPv6 ", base64: "base64- ", base64url: "base64url- ", json_string: "JSON ", e164: "E.164 ", jwt: "JWT", template_literal: "" };
  return (P) => {
    switch (P.code) {
      case "invalid_type":
        return ` :  ${P.expected},  ${xD(P.input)}`;
      case "invalid_value":
        if (P.values.length === 1) return ` :  ${m$(P.values[0])}`;
        return ` :  - ${T$(P.values, "|")}-`;
      case "too_big": {
        let _ = P.inclusive ? "<=" : "<", Y = q(P.origin);
        if (Y) return ` :  ${P.origin ?? ""} ${Y.verb} ${_}${P.maximum.toString()} ${Y.unit}`;
        return ` :  ${P.origin ?? ""}  ${_}${P.maximum.toString()}`;
      }
      case "too_small": {
        let _ = P.inclusive ? ">=" : ">", Y = q(P.origin);
        if (Y) return ` :  ${P.origin} ${Y.verb} ${_}${P.minimum.toString()} ${Y.unit}`;
        return ` :  ${P.origin}  ${_}${P.minimum.toString()}`;
      }
      case "invalid_format": {
        let _ = P;
        if (_.format === "starts_with") return ` :   "${_.prefix}"-`;
        if (_.format === "ends_with") return ` :   "${_.suffix}"-`;
        if (_.format === "includes") return ` :   "${_.includes}"-`;
        if (_.format === "regex") return ` :    ${_.pattern}`;
        return ` ${K[_.format] ?? P.format}`;
      }
      case "not_multiple_of":
        return ` :   ${P.divisor}- `;
      case "unrecognized_keys":
        return ` ${P.keys.length > 1 ? "" : ""}: ${T$(P.keys, ", ")}`;
      case "invalid_key":
        return `  ${P.origin}-`;
      case "invalid_union":
        return " ";
      case "invalid_element":
        return `  ${P.origin}-`;
      default:
        return " ";
    }
  };
}, "pD");
function S3() {
  return { localeError: pD() };
}
__name(S3, "S3");
var cD = /* @__PURE__ */ __name(() => {
  let $ = { string: { unit: "", verb: "" }, file: { unit: "", verb: "" }, array: { unit: "", verb: "" }, set: { unit: "", verb: "" } };
  function q(_) {
    return $[_] ?? null;
  }
  __name(q, "q");
  let K = /* @__PURE__ */ __name((_) => {
    let Y = typeof _;
    switch (Y) {
      case "number":
        return Number.isNaN(_) ? " (NaN)" : "";
      case "object": {
        if (Array.isArray(_)) return " (Array)";
        if (_ === null) return " (null)";
        if (Object.getPrototypeOf(_) !== Object.prototype && _.constructor) return _.constructor.name;
      }
    }
    return Y;
  }, "K"), P = { regex: "", email: "", url: "URL", emoji: "", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "  ISO", date: " ISO", time: " ISO", duration: " ISO", ipv4: " IPv4", ipv6: " IPv6", cidrv4: " IPv4", cidrv6: " IPv6", base64: " base64", base64url: " base64url", json_string: " JSON", e164: " E.164", jwt: "JWT", template_literal: "" };
  return (_) => {
    switch (_.code) {
      case "invalid_type":
        return `  ${_.expected}  ${K(_.input)}`;
      case "invalid_value":
        if (_.values.length === 1) return `  ${m$(_.values[0])}`;
        return `  ${T$(_.values, "|")}`;
      case "too_big": {
        let Y = _.inclusive ? "<=" : "<", O = q(_.origin);
        if (O) return `  ${_.origin ?? ""} ${Y} ${_.maximum.toString()} ${O.unit ?? ""}`;
        return `  ${_.origin ?? ""} ${Y} ${_.maximum.toString()}`;
      }
      case "too_small": {
        let Y = _.inclusive ? ">=" : ">", O = q(_.origin);
        if (O) return `  ${_.origin} ${Y} ${_.minimum.toString()} ${O.unit}`;
        return `  ${_.origin} ${Y} ${_.minimum.toString()}`;
      }
      case "invalid_format": {
        let Y = _;
        if (Y.format === "starts_with") return `  "${Y.prefix}"`;
        if (Y.format === "ends_with") return `  "${Y.suffix}"`;
        if (Y.format === "includes") return `  "${Y.includes}"`;
        if (Y.format === "regex") return `  ${Y.pattern}`;
        return ` ${P[Y.format] ?? _.format}`;
      }
      case "not_multiple_of":
        return `  ${_.divisor}`;
      case "unrecognized_keys":
        return ` ${T$(_.keys, ", ")}`;
      case "invalid_key":
        return ` ${_.origin}`;
      case "invalid_union":
        return "";
      case "invalid_element":
        return ` ${_.origin}`;
      default:
        return "";
    }
  };
}, "cD");
function nP() {
  return { localeError: cD() };
}
__name(nP, "nP");
function M3() {
  return nP();
}
__name(M3, "M3");
var mD = /* @__PURE__ */ __name(() => {
  let $ = { string: { unit: "", verb: "to have" }, file: { unit: "", verb: "to have" }, array: { unit: "", verb: "to have" }, set: { unit: "", verb: "to have" } };
  function q(_) {
    return $[_] ?? null;
  }
  __name(q, "q");
  let K = /* @__PURE__ */ __name((_) => {
    let Y = typeof _;
    switch (Y) {
      case "number":
        return Number.isNaN(_) ? "NaN" : "number";
      case "object": {
        if (Array.isArray(_)) return "array";
        if (_ === null) return "null";
        if (Object.getPrototypeOf(_) !== Object.prototype && _.constructor) return _.constructor.name;
      }
    }
    return Y;
  }, "K"), P = { regex: "", email: " ", url: "URL", emoji: "", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO ", date: "ISO ", time: "ISO ", duration: "ISO ", ipv4: "IPv4 ", ipv6: "IPv6 ", cidrv4: "IPv4 ", cidrv6: "IPv6 ", base64: "base64  ", base64url: "base64url  ", json_string: "JSON ", e164: "E.164 ", jwt: "JWT", template_literal: "" };
  return (_) => {
    switch (_.code) {
      case "invalid_type":
        return ` :   ${_.expected},   ${K(_.input)}`;
      case "invalid_value":
        if (_.values.length === 1) return ` :  ${m$(_.values[0])}  `;
        return ` : ${T$(_.values, " ")}   `;
      case "too_big": {
        let Y = _.inclusive ? "" : "", O = Y === "" ? " " : " ", z = q(_.origin), J = z?.unit ?? "";
        if (z) return `${_.origin ?? ""}  : ${_.maximum.toString()}${J} ${Y}${O}`;
        return `${_.origin ?? ""}  : ${_.maximum.toString()} ${Y}${O}`;
      }
      case "too_small": {
        let Y = _.inclusive ? "" : "", O = Y === "" ? " " : " ", z = q(_.origin), J = z?.unit ?? "";
        if (z) return `${_.origin ?? ""}  : ${_.minimum.toString()}${J} ${Y}${O}`;
        return `${_.origin ?? ""}  : ${_.minimum.toString()} ${Y}${O}`;
      }
      case "invalid_format": {
        let Y = _;
        if (Y.format === "starts_with") return ` : "${Y.prefix}"()  `;
        if (Y.format === "ends_with") return ` : "${Y.suffix}"()  `;
        if (Y.format === "includes") return ` : "${Y.includes}"()  `;
        if (Y.format === "regex") return ` :  ${Y.pattern}   `;
        return ` ${P[Y.format] ?? _.format}`;
      }
      case "not_multiple_of":
        return ` : ${_.divisor}  `;
      case "unrecognized_keys":
        return `   : ${T$(_.keys, ", ")}`;
      case "invalid_key":
        return ` : ${_.origin}`;
      case "invalid_union":
        return " ";
      case "invalid_element":
        return ` : ${_.origin}`;
      default:
        return " ";
    }
  };
}, "mD");
function N3() {
  return { localeError: mD() };
}
__name(N3, "N3");
var dD = /* @__PURE__ */ __name(($) => {
  return tP(typeof $, $);
}, "dD");
var tP = /* @__PURE__ */ __name(($, q = void 0) => {
  switch ($) {
    case "number":
      return Number.isNaN(q) ? "NaN" : "skaiius";
    case "bigint":
      return "sveikasis skaiius";
    case "string":
      return "eilut";
    case "boolean":
      return "login reikm";
    case "undefined":
    case "void":
      return "neapibrta reikm";
    case "function":
      return "funkcija";
    case "symbol":
      return "simbolis";
    case "object": {
      if (q === void 0) return "neinomas objektas";
      if (q === null) return "nulin reikm";
      if (Array.isArray(q)) return "masyvas";
      if (Object.getPrototypeOf(q) !== Object.prototype && q.constructor) return q.constructor.name;
      return "objektas";
    }
    case "null":
      return "nulin reikm";
  }
  return $;
}, "tP");
var iP = /* @__PURE__ */ __name(($) => {
  return $.charAt(0).toUpperCase() + $.slice(1);
}, "iP");
function PA($) {
  let q = Math.abs($), K = q % 10, P = q % 100;
  if (P >= 11 && P <= 19 || K === 0) return "many";
  if (K === 1) return "one";
  return "few";
}
__name(PA, "PA");
var lD = /* @__PURE__ */ __name(() => {
  let $ = { string: { unit: { one: "simbolis", few: "simboliai", many: "simboli" }, verb: { smaller: { inclusive: "turi bti ne ilgesn kaip", notInclusive: "turi bti trumpesn kaip" }, bigger: { inclusive: "turi bti ne trumpesn kaip", notInclusive: "turi bti ilgesn kaip" } } }, file: { unit: { one: "baitas", few: "baitai", many: "bait" }, verb: { smaller: { inclusive: "turi bti ne didesnis kaip", notInclusive: "turi bti maesnis kaip" }, bigger: { inclusive: "turi bti ne maesnis kaip", notInclusive: "turi bti didesnis kaip" } } }, array: { unit: { one: "element", few: "elementus", many: "element" }, verb: { smaller: { inclusive: "turi turti ne daugiau kaip", notInclusive: "turi turti maiau kaip" }, bigger: { inclusive: "turi turti ne maiau kaip", notInclusive: "turi turti daugiau kaip" } } }, set: { unit: { one: "element", few: "elementus", many: "element" }, verb: { smaller: { inclusive: "turi turti ne daugiau kaip", notInclusive: "turi turti maiau kaip" }, bigger: { inclusive: "turi turti ne maiau kaip", notInclusive: "turi turti daugiau kaip" } } } };
  function q(P, _, Y, O) {
    let z = $[P] ?? null;
    if (z === null) return z;
    return { unit: z.unit[_], verb: z.verb[O][Y ? "inclusive" : "notInclusive"] };
  }
  __name(q, "q");
  let K = { regex: "vestis", email: "el. pato adresas", url: "URL", emoji: "jaustukas", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO data ir laikas", date: "ISO data", time: "ISO laikas", duration: "ISO trukm", ipv4: "IPv4 adresas", ipv6: "IPv6 adresas", cidrv4: "IPv4 tinklo prefiksas (CIDR)", cidrv6: "IPv6 tinklo prefiksas (CIDR)", base64: "base64 ukoduota eilut", base64url: "base64url ukoduota eilut", json_string: "JSON eilut", e164: "E.164 numeris", jwt: "JWT", template_literal: "vestis" };
  return (P) => {
    switch (P.code) {
      case "invalid_type":
        return `Gautas tipas ${dD(P.input)}, o tiktasi - ${tP(P.expected)}`;
      case "invalid_value":
        if (P.values.length === 1) return `Privalo bti ${m$(P.values[0])}`;
        return `Privalo bti vienas i ${T$(P.values, "|")} pasirinkim`;
      case "too_big": {
        let _ = tP(P.origin), Y = q(P.origin, PA(Number(P.maximum)), P.inclusive ?? false, "smaller");
        if (Y?.verb) return `${iP(_ ?? P.origin ?? "reikm")} ${Y.verb} ${P.maximum.toString()} ${Y.unit ?? "element"}`;
        let O = P.inclusive ? "ne didesnis kaip" : "maesnis kaip";
        return `${iP(_ ?? P.origin ?? "reikm")} turi bti ${O} ${P.maximum.toString()} ${Y?.unit}`;
      }
      case "too_small": {
        let _ = tP(P.origin), Y = q(P.origin, PA(Number(P.minimum)), P.inclusive ?? false, "bigger");
        if (Y?.verb) return `${iP(_ ?? P.origin ?? "reikm")} ${Y.verb} ${P.minimum.toString()} ${Y.unit ?? "element"}`;
        let O = P.inclusive ? "ne maesnis kaip" : "didesnis kaip";
        return `${iP(_ ?? P.origin ?? "reikm")} turi bti ${O} ${P.minimum.toString()} ${Y?.unit}`;
      }
      case "invalid_format": {
        let _ = P;
        if (_.format === "starts_with") return `Eilut privalo prasidti "${_.prefix}"`;
        if (_.format === "ends_with") return `Eilut privalo pasibaigti "${_.suffix}"`;
        if (_.format === "includes") return `Eilut privalo traukti "${_.includes}"`;
        if (_.format === "regex") return `Eilut privalo atitikti ${_.pattern}`;
        return `Neteisingas ${K[_.format] ?? P.format}`;
      }
      case "not_multiple_of":
        return `Skaiius privalo bti ${P.divisor} kartotinis.`;
      case "unrecognized_keys":
        return `Neatpaint${P.keys.length > 1 ? "i" : "as"} rakt${P.keys.length > 1 ? "ai" : "as"}: ${T$(P.keys, ", ")}`;
      case "invalid_key":
        return "Rastas klaidingas raktas";
      case "invalid_union":
        return "Klaidinga vestis";
      case "invalid_element": {
        let _ = tP(P.origin);
        return `${iP(_ ?? P.origin ?? "reikm")} turi klaiding vest`;
      }
      default:
        return "Klaidinga vestis";
    }
  };
}, "lD");
function C3() {
  return { localeError: lD() };
}
__name(C3, "C3");
var rD = /* @__PURE__ */ __name(() => {
  let $ = { string: { unit: "", verb: " " }, file: { unit: "", verb: " " }, array: { unit: "", verb: " " }, set: { unit: "", verb: " " } };
  function q(_) {
    return $[_] ?? null;
  }
  __name(q, "q");
  let K = /* @__PURE__ */ __name((_) => {
    let Y = typeof _;
    switch (Y) {
      case "number":
        return Number.isNaN(_) ? "NaN" : "";
      case "object": {
        if (Array.isArray(_)) return "";
        if (_ === null) return "null";
        if (Object.getPrototypeOf(_) !== Object.prototype && _.constructor) return _.constructor.name;
      }
    }
    return Y;
  }, "K"), P = { regex: "", email: "  -", url: "URL", emoji: "", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO   ", date: "ISO ", time: "ISO ", duration: "ISO ", ipv4: "IPv4 ", ipv6: "IPv6 ", cidrv4: "IPv4 ", cidrv6: "IPv6 ", base64: "base64- ", base64url: "base64url- ", json_string: "JSON ", e164: "E.164 ", jwt: "JWT", template_literal: "" };
  return (_) => {
    switch (_.code) {
      case "invalid_type":
        return ` :   ${_.expected},  ${K(_.input)}`;
      case "invalid_value":
        if (_.values.length === 1) return `Invalid input: expected ${m$(_.values[0])}`;
        return ` :    ${T$(_.values, "|")}`;
      case "too_big": {
        let Y = _.inclusive ? "<=" : "<", O = q(_.origin);
        if (O) return ` :   ${_.origin ?? ""}   ${Y}${_.maximum.toString()} ${O.unit ?? ""}`;
        return ` :   ${_.origin ?? ""}   ${Y}${_.maximum.toString()}`;
      }
      case "too_small": {
        let Y = _.inclusive ? ">=" : ">", O = q(_.origin);
        if (O) return ` :   ${_.origin}   ${Y}${_.minimum.toString()} ${O.unit}`;
        return ` :   ${_.origin}   ${Y}${_.minimum.toString()}`;
      }
      case "invalid_format": {
        let Y = _;
        if (Y.format === "starts_with") return ` :     "${Y.prefix}"`;
        if (Y.format === "ends_with") return ` :     "${Y.suffix}"`;
        if (Y.format === "includes") return ` :    "${Y.includes}"`;
        if (Y.format === "regex") return ` :      ${Y.pattern}`;
        return `Invalid ${P[Y.format] ?? _.format}`;
      }
      case "not_multiple_of":
        return ` :      ${_.divisor}`;
      case "unrecognized_keys":
        return `${_.keys.length > 1 ? " " : " "}: ${T$(_.keys, ", ")}`;
      case "invalid_key":
        return `   ${_.origin}`;
      case "invalid_union":
        return " ";
      case "invalid_element":
        return `   ${_.origin}`;
      default:
        return " ";
    }
  };
}, "rD");
function h3() {
  return { localeError: rD() };
}
__name(h3, "h3");
var oD = /* @__PURE__ */ __name(() => {
  let $ = { string: { unit: "aksara", verb: "mempunyai" }, file: { unit: "bait", verb: "mempunyai" }, array: { unit: "elemen", verb: "mempunyai" }, set: { unit: "elemen", verb: "mempunyai" } };
  function q(_) {
    return $[_] ?? null;
  }
  __name(q, "q");
  let K = /* @__PURE__ */ __name((_) => {
    let Y = typeof _;
    switch (Y) {
      case "number":
        return Number.isNaN(_) ? "NaN" : "nombor";
      case "object": {
        if (Array.isArray(_)) return "array";
        if (_ === null) return "null";
        if (Object.getPrototypeOf(_) !== Object.prototype && _.constructor) return _.constructor.name;
      }
    }
    return Y;
  }, "K"), P = { regex: "input", email: "alamat e-mel", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "tarikh masa ISO", date: "tarikh ISO", time: "masa ISO", duration: "tempoh ISO", ipv4: "alamat IPv4", ipv6: "alamat IPv6", cidrv4: "julat IPv4", cidrv6: "julat IPv6", base64: "string dikodkan base64", base64url: "string dikodkan base64url", json_string: "string JSON", e164: "nombor E.164", jwt: "JWT", template_literal: "input" };
  return (_) => {
    switch (_.code) {
      case "invalid_type":
        return `Input tidak sah: dijangka ${_.expected}, diterima ${K(_.input)}`;
      case "invalid_value":
        if (_.values.length === 1) return `Input tidak sah: dijangka ${m$(_.values[0])}`;
        return `Pilihan tidak sah: dijangka salah satu daripada ${T$(_.values, "|")}`;
      case "too_big": {
        let Y = _.inclusive ? "<=" : "<", O = q(_.origin);
        if (O) return `Terlalu besar: dijangka ${_.origin ?? "nilai"} ${O.verb} ${Y}${_.maximum.toString()} ${O.unit ?? "elemen"}`;
        return `Terlalu besar: dijangka ${_.origin ?? "nilai"} adalah ${Y}${_.maximum.toString()}`;
      }
      case "too_small": {
        let Y = _.inclusive ? ">=" : ">", O = q(_.origin);
        if (O) return `Terlalu kecil: dijangka ${_.origin} ${O.verb} ${Y}${_.minimum.toString()} ${O.unit}`;
        return `Terlalu kecil: dijangka ${_.origin} adalah ${Y}${_.minimum.toString()}`;
      }
      case "invalid_format": {
        let Y = _;
        if (Y.format === "starts_with") return `String tidak sah: mesti bermula dengan "${Y.prefix}"`;
        if (Y.format === "ends_with") return `String tidak sah: mesti berakhir dengan "${Y.suffix}"`;
        if (Y.format === "includes") return `String tidak sah: mesti mengandungi "${Y.includes}"`;
        if (Y.format === "regex") return `String tidak sah: mesti sepadan dengan corak ${Y.pattern}`;
        return `${P[Y.format] ?? _.format} tidak sah`;
      }
      case "not_multiple_of":
        return `Nombor tidak sah: perlu gandaan ${_.divisor}`;
      case "unrecognized_keys":
        return `Kunci tidak dikenali: ${T$(_.keys, ", ")}`;
      case "invalid_key":
        return `Kunci tidak sah dalam ${_.origin}`;
      case "invalid_union":
        return "Input tidak sah";
      case "invalid_element":
        return `Nilai tidak sah dalam ${_.origin}`;
      default:
        return "Input tidak sah";
    }
  };
}, "oD");
function E3() {
  return { localeError: oD() };
}
__name(E3, "E3");
var nD = /* @__PURE__ */ __name(() => {
  let $ = { string: { unit: "tekens" }, file: { unit: "bytes" }, array: { unit: "elementen" }, set: { unit: "elementen" } };
  function q(_) {
    return $[_] ?? null;
  }
  __name(q, "q");
  let K = /* @__PURE__ */ __name((_) => {
    let Y = typeof _;
    switch (Y) {
      case "number":
        return Number.isNaN(_) ? "NaN" : "getal";
      case "object": {
        if (Array.isArray(_)) return "array";
        if (_ === null) return "null";
        if (Object.getPrototypeOf(_) !== Object.prototype && _.constructor) return _.constructor.name;
      }
    }
    return Y;
  }, "K"), P = { regex: "invoer", email: "emailadres", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO datum en tijd", date: "ISO datum", time: "ISO tijd", duration: "ISO duur", ipv4: "IPv4-adres", ipv6: "IPv6-adres", cidrv4: "IPv4-bereik", cidrv6: "IPv6-bereik", base64: "base64-gecodeerde tekst", base64url: "base64 URL-gecodeerde tekst", json_string: "JSON string", e164: "E.164-nummer", jwt: "JWT", template_literal: "invoer" };
  return (_) => {
    switch (_.code) {
      case "invalid_type":
        return `Ongeldige invoer: verwacht ${_.expected}, ontving ${K(_.input)}`;
      case "invalid_value":
        if (_.values.length === 1) return `Ongeldige invoer: verwacht ${m$(_.values[0])}`;
        return `Ongeldige optie: verwacht n van ${T$(_.values, "|")}`;
      case "too_big": {
        let Y = _.inclusive ? "<=" : "<", O = q(_.origin);
        if (O) return `Te lang: verwacht dat ${_.origin ?? "waarde"} ${Y}${_.maximum.toString()} ${O.unit ?? "elementen"} bevat`;
        return `Te lang: verwacht dat ${_.origin ?? "waarde"} ${Y}${_.maximum.toString()} is`;
      }
      case "too_small": {
        let Y = _.inclusive ? ">=" : ">", O = q(_.origin);
        if (O) return `Te kort: verwacht dat ${_.origin} ${Y}${_.minimum.toString()} ${O.unit} bevat`;
        return `Te kort: verwacht dat ${_.origin} ${Y}${_.minimum.toString()} is`;
      }
      case "invalid_format": {
        let Y = _;
        if (Y.format === "starts_with") return `Ongeldige tekst: moet met "${Y.prefix}" beginnen`;
        if (Y.format === "ends_with") return `Ongeldige tekst: moet op "${Y.suffix}" eindigen`;
        if (Y.format === "includes") return `Ongeldige tekst: moet "${Y.includes}" bevatten`;
        if (Y.format === "regex") return `Ongeldige tekst: moet overeenkomen met patroon ${Y.pattern}`;
        return `Ongeldig: ${P[Y.format] ?? _.format}`;
      }
      case "not_multiple_of":
        return `Ongeldig getal: moet een veelvoud van ${_.divisor} zijn`;
      case "unrecognized_keys":
        return `Onbekende key${_.keys.length > 1 ? "s" : ""}: ${T$(_.keys, ", ")}`;
      case "invalid_key":
        return `Ongeldige key in ${_.origin}`;
      case "invalid_union":
        return "Ongeldige invoer";
      case "invalid_element":
        return `Ongeldige waarde in ${_.origin}`;
      default:
        return "Ongeldige invoer";
    }
  };
}, "nD");
function R3() {
  return { localeError: nD() };
}
__name(R3, "R3");
var iD = /* @__PURE__ */ __name(() => {
  let $ = { string: { unit: "tegn", verb: " ha" }, file: { unit: "bytes", verb: " ha" }, array: { unit: "elementer", verb: " inneholde" }, set: { unit: "elementer", verb: " inneholde" } };
  function q(_) {
    return $[_] ?? null;
  }
  __name(q, "q");
  let K = /* @__PURE__ */ __name((_) => {
    let Y = typeof _;
    switch (Y) {
      case "number":
        return Number.isNaN(_) ? "NaN" : "tall";
      case "object": {
        if (Array.isArray(_)) return "liste";
        if (_ === null) return "null";
        if (Object.getPrototypeOf(_) !== Object.prototype && _.constructor) return _.constructor.name;
      }
    }
    return Y;
  }, "K"), P = { regex: "input", email: "e-postadresse", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO dato- og klokkeslett", date: "ISO-dato", time: "ISO-klokkeslett", duration: "ISO-varighet", ipv4: "IPv4-omrde", ipv6: "IPv6-omrde", cidrv4: "IPv4-spekter", cidrv6: "IPv6-spekter", base64: "base64-enkodet streng", base64url: "base64url-enkodet streng", json_string: "JSON-streng", e164: "E.164-nummer", jwt: "JWT", template_literal: "input" };
  return (_) => {
    switch (_.code) {
      case "invalid_type":
        return `Ugyldig input: forventet ${_.expected}, fikk ${K(_.input)}`;
      case "invalid_value":
        if (_.values.length === 1) return `Ugyldig verdi: forventet ${m$(_.values[0])}`;
        return `Ugyldig valg: forventet en av ${T$(_.values, "|")}`;
      case "too_big": {
        let Y = _.inclusive ? "<=" : "<", O = q(_.origin);
        if (O) return `For stor(t): forventet ${_.origin ?? "value"} til  ha ${Y}${_.maximum.toString()} ${O.unit ?? "elementer"}`;
        return `For stor(t): forventet ${_.origin ?? "value"} til  ha ${Y}${_.maximum.toString()}`;
      }
      case "too_small": {
        let Y = _.inclusive ? ">=" : ">", O = q(_.origin);
        if (O) return `For lite(n): forventet ${_.origin} til  ha ${Y}${_.minimum.toString()} ${O.unit}`;
        return `For lite(n): forventet ${_.origin} til  ha ${Y}${_.minimum.toString()}`;
      }
      case "invalid_format": {
        let Y = _;
        if (Y.format === "starts_with") return `Ugyldig streng: m starte med "${Y.prefix}"`;
        if (Y.format === "ends_with") return `Ugyldig streng: m ende med "${Y.suffix}"`;
        if (Y.format === "includes") return `Ugyldig streng: m inneholde "${Y.includes}"`;
        if (Y.format === "regex") return `Ugyldig streng: m matche mnsteret ${Y.pattern}`;
        return `Ugyldig ${P[Y.format] ?? _.format}`;
      }
      case "not_multiple_of":
        return `Ugyldig tall: m vre et multiplum av ${_.divisor}`;
      case "unrecognized_keys":
        return `${_.keys.length > 1 ? "Ukjente nkler" : "Ukjent nkkel"}: ${T$(_.keys, ", ")}`;
      case "invalid_key":
        return `Ugyldig nkkel i ${_.origin}`;
      case "invalid_union":
        return "Ugyldig input";
      case "invalid_element":
        return `Ugyldig verdi i ${_.origin}`;
      default:
        return "Ugyldig input";
    }
  };
}, "iD");
function I3() {
  return { localeError: iD() };
}
__name(I3, "I3");
var tD = /* @__PURE__ */ __name(() => {
  let $ = { string: { unit: "harf", verb: "olmaldr" }, file: { unit: "bayt", verb: "olmaldr" }, array: { unit: "unsur", verb: "olmaldr" }, set: { unit: "unsur", verb: "olmaldr" } };
  function q(_) {
    return $[_] ?? null;
  }
  __name(q, "q");
  let K = /* @__PURE__ */ __name((_) => {
    let Y = typeof _;
    switch (Y) {
      case "number":
        return Number.isNaN(_) ? "NaN" : "numara";
      case "object": {
        if (Array.isArray(_)) return "saf";
        if (_ === null) return "gayb";
        if (Object.getPrototypeOf(_) !== Object.prototype && _.constructor) return _.constructor.name;
      }
    }
    return Y;
  }, "K"), P = { regex: "giren", email: "epostagh", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO hengm", date: "ISO tarihi", time: "ISO zaman", duration: "ISO mddeti", ipv4: "IPv4 nin", ipv6: "IPv6 nin", cidrv4: "IPv4 menzili", cidrv6: "IPv6 menzili", base64: "base64-ifreli metin", base64url: "base64url-ifreli metin", json_string: "JSON metin", e164: "E.164 says", jwt: "JWT", template_literal: "giren" };
  return (_) => {
    switch (_.code) {
      case "invalid_type":
        return `Fsit giren: umulan ${_.expected}, alnan ${K(_.input)}`;
      case "invalid_value":
        if (_.values.length === 1) return `Fsit giren: umulan ${m$(_.values[0])}`;
        return `Fsit tercih: mteberler ${T$(_.values, "|")}`;
      case "too_big": {
        let Y = _.inclusive ? "<=" : "<", O = q(_.origin);
        if (O) return `Fazla byk: ${_.origin ?? "value"}, ${Y}${_.maximum.toString()} ${O.unit ?? "elements"} sahip olmalyd.`;
        return `Fazla byk: ${_.origin ?? "value"}, ${Y}${_.maximum.toString()} olmalyd.`;
      }
      case "too_small": {
        let Y = _.inclusive ? ">=" : ">", O = q(_.origin);
        if (O) return `Fazla kk: ${_.origin}, ${Y}${_.minimum.toString()} ${O.unit} sahip olmalyd.`;
        return `Fazla kk: ${_.origin}, ${Y}${_.minimum.toString()} olmalyd.`;
      }
      case "invalid_format": {
        let Y = _;
        if (Y.format === "starts_with") return `Fsit metin: "${Y.prefix}" ile balamal.`;
        if (Y.format === "ends_with") return `Fsit metin: "${Y.suffix}" ile bitmeli.`;
        if (Y.format === "includes") return `Fsit metin: "${Y.includes}" ihtiv etmeli.`;
        if (Y.format === "regex") return `Fsit metin: ${Y.pattern} nakna uymal.`;
        return `Fsit ${P[Y.format] ?? _.format}`;
      }
      case "not_multiple_of":
        return `Fsit say: ${_.divisor} kat olmalyd.`;
      case "unrecognized_keys":
        return `Tannmayan anahtar ${_.keys.length > 1 ? "s" : ""}: ${T$(_.keys, ", ")}`;
      case "invalid_key":
        return `${_.origin} iin tannmayan anahtar var.`;
      case "invalid_union":
        return "Giren tannamad.";
      case "invalid_element":
        return `${_.origin} iin tannmayan kymet var.`;
      default:
        return "Kymet tannamad.";
    }
  };
}, "tD");
function D3() {
  return { localeError: tD() };
}
__name(D3, "D3");
var BD = /* @__PURE__ */ __name(() => {
  let $ = { string: { unit: "", verb: "" }, file: { unit: "", verb: "" }, array: { unit: "", verb: "" }, set: { unit: "", verb: "" } };
  function q(_) {
    return $[_] ?? null;
  }
  __name(q, "q");
  let K = /* @__PURE__ */ __name((_) => {
    let Y = typeof _;
    switch (Y) {
      case "number":
        return Number.isNaN(_) ? "NaN" : "";
      case "object": {
        if (Array.isArray(_)) return "";
        if (_ === null) return "null";
        if (Object.getPrototypeOf(_) !== Object.prototype && _.constructor) return _.constructor.name;
      }
    }
    return Y;
  }, "K"), P = { regex: "", email: "", url: "  ", emoji: "", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "  ", date: "", time: "", duration: "", ipv4: " IPv4 ", ipv6: " IPv6 ", cidrv4: " IPv4 ", cidrv6: " IPv6 ", base64: "base64-encoded ", base64url: "base64url-encoded ", json_string: "JSON ", e164: " E.164 ", jwt: "JWT", template_literal: "" };
  return (_) => {
    switch (_.code) {
      case "invalid_type":
        return ` :  ${_.expected} ,  ${K(_.input)}  `;
      case "invalid_value":
        if (_.values.length === 1) return ` :  ${m$(_.values[0])} `;
        return ` :    ${T$(_.values, "|")}  `;
      case "too_big": {
        let Y = _.inclusive ? "<=" : "<", O = q(_.origin);
        if (O) return ` : ${_.origin ?? ""}  ${Y}${_.maximum.toString()} ${O.unit ?? ""} `;
        return ` : ${_.origin ?? ""}  ${Y}${_.maximum.toString()} `;
      }
      case "too_small": {
        let Y = _.inclusive ? ">=" : ">", O = q(_.origin);
        if (O) return ` : ${_.origin}  ${Y}${_.minimum.toString()} ${O.unit} `;
        return ` : ${_.origin}  ${Y}${_.minimum.toString()} `;
      }
      case "invalid_format": {
        let Y = _;
        if (Y.format === "starts_with") return ` :   "${Y.prefix}"   `;
        if (Y.format === "ends_with") return ` :   "${Y.suffix}"    `;
        if (Y.format === "includes") return ` :  "${Y.includes}" `;
        if (Y.format === "regex") return ` :   ${Y.pattern}   `;
        return `${P[Y.format] ?? _.format}  `;
      }
      case "not_multiple_of":
        return ` :   ${_.divisor}  `;
      case "unrecognized_keys":
        return ` ${_.keys.length > 1 ? "" : ""}: ${T$(_.keys, ", ")}`;
      case "invalid_key":
        return `   ${_.origin} `;
      case "invalid_union":
        return " ";
      case "invalid_element":
        return `   ${_.origin} `;
      default:
        return " ";
    }
  };
}, "BD");
function L3() {
  return { localeError: BD() };
}
__name(L3, "L3");
var UD = /* @__PURE__ */ __name(() => {
  let $ = { string: { unit: "znakw", verb: "mie" }, file: { unit: "bajtw", verb: "mie" }, array: { unit: "elementw", verb: "mie" }, set: { unit: "elementw", verb: "mie" } };
  function q(_) {
    return $[_] ?? null;
  }
  __name(q, "q");
  let K = /* @__PURE__ */ __name((_) => {
    let Y = typeof _;
    switch (Y) {
      case "number":
        return Number.isNaN(_) ? "NaN" : "liczba";
      case "object": {
        if (Array.isArray(_)) return "tablica";
        if (_ === null) return "null";
        if (Object.getPrototypeOf(_) !== Object.prototype && _.constructor) return _.constructor.name;
      }
    }
    return Y;
  }, "K"), P = { regex: "wyraenie", email: "adres email", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "data i godzina w formacie ISO", date: "data w formacie ISO", time: "godzina w formacie ISO", duration: "czas trwania ISO", ipv4: "adres IPv4", ipv6: "adres IPv6", cidrv4: "zakres IPv4", cidrv6: "zakres IPv6", base64: "cig znakw zakodowany w formacie base64", base64url: "cig znakw zakodowany w formacie base64url", json_string: "cig znakw w formacie JSON", e164: "liczba E.164", jwt: "JWT", template_literal: "wejcie" };
  return (_) => {
    switch (_.code) {
      case "invalid_type":
        return `Nieprawidowe dane wejciowe: oczekiwano ${_.expected}, otrzymano ${K(_.input)}`;
      case "invalid_value":
        if (_.values.length === 1) return `Nieprawidowe dane wejciowe: oczekiwano ${m$(_.values[0])}`;
        return `Nieprawidowa opcja: oczekiwano jednej z wartoci ${T$(_.values, "|")}`;
      case "too_big": {
        let Y = _.inclusive ? "<=" : "<", O = q(_.origin);
        if (O) return `Za dua warto: oczekiwano, e ${_.origin ?? "warto"} bdzie mie ${Y}${_.maximum.toString()} ${O.unit ?? "elementw"}`;
        return `Zbyt du(y/a/e): oczekiwano, e ${_.origin ?? "warto"} bdzie wynosi ${Y}${_.maximum.toString()}`;
      }
      case "too_small": {
        let Y = _.inclusive ? ">=" : ">", O = q(_.origin);
        if (O) return `Za maa warto: oczekiwano, e ${_.origin ?? "warto"} bdzie mie ${Y}${_.minimum.toString()} ${O.unit ?? "elementw"}`;
        return `Zbyt ma(y/a/e): oczekiwano, e ${_.origin ?? "warto"} bdzie wynosi ${Y}${_.minimum.toString()}`;
      }
      case "invalid_format": {
        let Y = _;
        if (Y.format === "starts_with") return `Nieprawidowy cig znakw: musi zaczyna si od "${Y.prefix}"`;
        if (Y.format === "ends_with") return `Nieprawidowy cig znakw: musi koczy si na "${Y.suffix}"`;
        if (Y.format === "includes") return `Nieprawidowy cig znakw: musi zawiera "${Y.includes}"`;
        if (Y.format === "regex") return `Nieprawidowy cig znakw: musi odpowiada wzorcowi ${Y.pattern}`;
        return `Nieprawidow(y/a/e) ${P[Y.format] ?? _.format}`;
      }
      case "not_multiple_of":
        return `Nieprawidowa liczba: musi by wielokrotnoci ${_.divisor}`;
      case "unrecognized_keys":
        return `Nierozpoznane klucze${_.keys.length > 1 ? "s" : ""}: ${T$(_.keys, ", ")}`;
      case "invalid_key":
        return `Nieprawidowy klucz w ${_.origin}`;
      case "invalid_union":
        return "Nieprawidowe dane wejciowe";
      case "invalid_element":
        return `Nieprawidowa warto w ${_.origin}`;
      default:
        return "Nieprawidowe dane wejciowe";
    }
  };
}, "UD");
function g3() {
  return { localeError: UD() };
}
__name(g3, "g3");
var FD = /* @__PURE__ */ __name(() => {
  let $ = { string: { unit: "caracteres", verb: "ter" }, file: { unit: "bytes", verb: "ter" }, array: { unit: "itens", verb: "ter" }, set: { unit: "itens", verb: "ter" } };
  function q(_) {
    return $[_] ?? null;
  }
  __name(q, "q");
  let K = /* @__PURE__ */ __name((_) => {
    let Y = typeof _;
    switch (Y) {
      case "number":
        return Number.isNaN(_) ? "NaN" : "nmero";
      case "object": {
        if (Array.isArray(_)) return "array";
        if (_ === null) return "nulo";
        if (Object.getPrototypeOf(_) !== Object.prototype && _.constructor) return _.constructor.name;
      }
    }
    return Y;
  }, "K"), P = { regex: "padro", email: "endereo de e-mail", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "data e hora ISO", date: "data ISO", time: "hora ISO", duration: "durao ISO", ipv4: "endereo IPv4", ipv6: "endereo IPv6", cidrv4: "faixa de IPv4", cidrv6: "faixa de IPv6", base64: "texto codificado em base64", base64url: "URL codificada em base64", json_string: "texto JSON", e164: "nmero E.164", jwt: "JWT", template_literal: "entrada" };
  return (_) => {
    switch (_.code) {
      case "invalid_type":
        return `Tipo invlido: esperado ${_.expected}, recebido ${K(_.input)}`;
      case "invalid_value":
        if (_.values.length === 1) return `Entrada invlida: esperado ${m$(_.values[0])}`;
        return `Opo invlida: esperada uma das ${T$(_.values, "|")}`;
      case "too_big": {
        let Y = _.inclusive ? "<=" : "<", O = q(_.origin);
        if (O) return `Muito grande: esperado que ${_.origin ?? "valor"} tivesse ${Y}${_.maximum.toString()} ${O.unit ?? "elementos"}`;
        return `Muito grande: esperado que ${_.origin ?? "valor"} fosse ${Y}${_.maximum.toString()}`;
      }
      case "too_small": {
        let Y = _.inclusive ? ">=" : ">", O = q(_.origin);
        if (O) return `Muito pequeno: esperado que ${_.origin} tivesse ${Y}${_.minimum.toString()} ${O.unit}`;
        return `Muito pequeno: esperado que ${_.origin} fosse ${Y}${_.minimum.toString()}`;
      }
      case "invalid_format": {
        let Y = _;
        if (Y.format === "starts_with") return `Texto invlido: deve comear com "${Y.prefix}"`;
        if (Y.format === "ends_with") return `Texto invlido: deve terminar com "${Y.suffix}"`;
        if (Y.format === "includes") return `Texto invlido: deve incluir "${Y.includes}"`;
        if (Y.format === "regex") return `Texto invlido: deve corresponder ao padro ${Y.pattern}`;
        return `${P[Y.format] ?? _.format} invlido`;
      }
      case "not_multiple_of":
        return `Nmero invlido: deve ser mltiplo de ${_.divisor}`;
      case "unrecognized_keys":
        return `Chave${_.keys.length > 1 ? "s" : ""} desconhecida${_.keys.length > 1 ? "s" : ""}: ${T$(_.keys, ", ")}`;
      case "invalid_key":
        return `Chave invlida em ${_.origin}`;
      case "invalid_union":
        return "Entrada invlida";
      case "invalid_element":
        return `Valor invlido em ${_.origin}`;
      default:
        return "Campo invlido";
    }
  };
}, "FD");
function b3() {
  return { localeError: FD() };
}
__name(b3, "b3");
function OA($, q, K, P) {
  let _ = Math.abs($), Y = _ % 10, O = _ % 100;
  if (O >= 11 && O <= 19) return P;
  if (Y === 1) return q;
  if (Y >= 2 && Y <= 4) return K;
  return P;
}
__name(OA, "OA");
var aD = /* @__PURE__ */ __name(() => {
  let $ = { string: { unit: { one: "", few: "", many: "" }, verb: "" }, file: { unit: { one: "", few: "", many: "" }, verb: "" }, array: { unit: { one: "", few: "", many: "" }, verb: "" }, set: { unit: { one: "", few: "", many: "" }, verb: "" } };
  function q(_) {
    return $[_] ?? null;
  }
  __name(q, "q");
  let K = /* @__PURE__ */ __name((_) => {
    let Y = typeof _;
    switch (Y) {
      case "number":
        return Number.isNaN(_) ? "NaN" : "";
      case "object": {
        if (Array.isArray(_)) return "";
        if (_ === null) return "null";
        if (Object.getPrototypeOf(_) !== Object.prototype && _.constructor) return _.constructor.name;
      }
    }
    return Y;
  }, "K"), P = { regex: "", email: "email ", url: "URL", emoji: "", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO   ", date: "ISO ", time: "ISO ", duration: "ISO ", ipv4: "IPv4 ", ipv6: "IPv6 ", cidrv4: "IPv4 ", cidrv6: "IPv6 ", base64: "   base64", base64url: "   base64url", json_string: "JSON ", e164: " E.164", jwt: "JWT", template_literal: "" };
  return (_) => {
    switch (_.code) {
      case "invalid_type":
        return ` :  ${_.expected},  ${K(_.input)}`;
      case "invalid_value":
        if (_.values.length === 1) return ` :  ${m$(_.values[0])}`;
        return ` :    ${T$(_.values, "|")}`;
      case "too_big": {
        let Y = _.inclusive ? "<=" : "<", O = q(_.origin);
        if (O) {
          let z = Number(_.maximum), J = OA(z, O.unit.one, O.unit.few, O.unit.many);
          return `  : ,  ${_.origin ?? ""}   ${Y}${_.maximum.toString()} ${J}`;
        }
        return `  : ,  ${_.origin ?? ""}  ${Y}${_.maximum.toString()}`;
      }
      case "too_small": {
        let Y = _.inclusive ? ">=" : ">", O = q(_.origin);
        if (O) {
          let z = Number(_.minimum), J = OA(z, O.unit.one, O.unit.few, O.unit.many);
          return `  : ,  ${_.origin}   ${Y}${_.minimum.toString()} ${J}`;
        }
        return `  : ,  ${_.origin}  ${Y}${_.minimum.toString()}`;
      }
      case "invalid_format": {
        let Y = _;
        if (Y.format === "starts_with") return ` :    "${Y.prefix}"`;
        if (Y.format === "ends_with") return ` :    "${Y.suffix}"`;
        if (Y.format === "includes") return ` :   "${Y.includes}"`;
        if (Y.format === "regex") return ` :    ${Y.pattern}`;
        return ` ${P[Y.format] ?? _.format}`;
      }
      case "not_multiple_of":
        return ` :    ${_.divisor}`;
      case "unrecognized_keys":
        return `${_.keys.length > 1 ? "" : ""} ${_.keys.length > 1 ? "" : ""}: ${T$(_.keys, ", ")}`;
      case "invalid_key":
        return `   ${_.origin}`;
      case "invalid_union":
        return "  ";
      case "invalid_element":
        return `   ${_.origin}`;
      default:
        return "  ";
    }
  };
}, "aD");
function y3() {
  return { localeError: aD() };
}
__name(y3, "y3");
var QD = /* @__PURE__ */ __name(() => {
  let $ = { string: { unit: "znakov", verb: "imeti" }, file: { unit: "bajtov", verb: "imeti" }, array: { unit: "elementov", verb: "imeti" }, set: { unit: "elementov", verb: "imeti" } };
  function q(_) {
    return $[_] ?? null;
  }
  __name(q, "q");
  let K = /* @__PURE__ */ __name((_) => {
    let Y = typeof _;
    switch (Y) {
      case "number":
        return Number.isNaN(_) ? "NaN" : "tevilo";
      case "object": {
        if (Array.isArray(_)) return "tabela";
        if (_ === null) return "null";
        if (Object.getPrototypeOf(_) !== Object.prototype && _.constructor) return _.constructor.name;
      }
    }
    return Y;
  }, "K"), P = { regex: "vnos", email: "e-potni naslov", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO datum in as", date: "ISO datum", time: "ISO as", duration: "ISO trajanje", ipv4: "IPv4 naslov", ipv6: "IPv6 naslov", cidrv4: "obseg IPv4", cidrv6: "obseg IPv6", base64: "base64 kodiran niz", base64url: "base64url kodiran niz", json_string: "JSON niz", e164: "E.164 tevilka", jwt: "JWT", template_literal: "vnos" };
  return (_) => {
    switch (_.code) {
      case "invalid_type":
        return `Neveljaven vnos: priakovano ${_.expected}, prejeto ${K(_.input)}`;
      case "invalid_value":
        if (_.values.length === 1) return `Neveljaven vnos: priakovano ${m$(_.values[0])}`;
        return `Neveljavna monost: priakovano eno izmed ${T$(_.values, "|")}`;
      case "too_big": {
        let Y = _.inclusive ? "<=" : "<", O = q(_.origin);
        if (O) return `Preveliko: priakovano, da bo ${_.origin ?? "vrednost"} imelo ${Y}${_.maximum.toString()} ${O.unit ?? "elementov"}`;
        return `Preveliko: priakovano, da bo ${_.origin ?? "vrednost"} ${Y}${_.maximum.toString()}`;
      }
      case "too_small": {
        let Y = _.inclusive ? ">=" : ">", O = q(_.origin);
        if (O) return `Premajhno: priakovano, da bo ${_.origin} imelo ${Y}${_.minimum.toString()} ${O.unit}`;
        return `Premajhno: priakovano, da bo ${_.origin} ${Y}${_.minimum.toString()}`;
      }
      case "invalid_format": {
        let Y = _;
        if (Y.format === "starts_with") return `Neveljaven niz: mora se zaeti z "${Y.prefix}"`;
        if (Y.format === "ends_with") return `Neveljaven niz: mora se konati z "${Y.suffix}"`;
        if (Y.format === "includes") return `Neveljaven niz: mora vsebovati "${Y.includes}"`;
        if (Y.format === "regex") return `Neveljaven niz: mora ustrezati vzorcu ${Y.pattern}`;
        return `Neveljaven ${P[Y.format] ?? _.format}`;
      }
      case "not_multiple_of":
        return `Neveljavno tevilo: mora biti vekratnik ${_.divisor}`;
      case "unrecognized_keys":
        return `Neprepoznan${_.keys.length > 1 ? "i kljui" : " klju"}: ${T$(_.keys, ", ")}`;
      case "invalid_key":
        return `Neveljaven klju v ${_.origin}`;
      case "invalid_union":
        return "Neveljaven vnos";
      case "invalid_element":
        return `Neveljavna vrednost v ${_.origin}`;
      default:
        return "Neveljaven vnos";
    }
  };
}, "QD");
function u3() {
  return { localeError: QD() };
}
__name(u3, "u3");
var eD = /* @__PURE__ */ __name(() => {
  let $ = { string: { unit: "tecken", verb: "att ha" }, file: { unit: "bytes", verb: "att ha" }, array: { unit: "objekt", verb: "att innehlla" }, set: { unit: "objekt", verb: "att innehlla" } };
  function q(_) {
    return $[_] ?? null;
  }
  __name(q, "q");
  let K = /* @__PURE__ */ __name((_) => {
    let Y = typeof _;
    switch (Y) {
      case "number":
        return Number.isNaN(_) ? "NaN" : "antal";
      case "object": {
        if (Array.isArray(_)) return "lista";
        if (_ === null) return "null";
        if (Object.getPrototypeOf(_) !== Object.prototype && _.constructor) return _.constructor.name;
      }
    }
    return Y;
  }, "K"), P = { regex: "reguljrt uttryck", email: "e-postadress", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO-datum och tid", date: "ISO-datum", time: "ISO-tid", duration: "ISO-varaktighet", ipv4: "IPv4-intervall", ipv6: "IPv6-intervall", cidrv4: "IPv4-spektrum", cidrv6: "IPv6-spektrum", base64: "base64-kodad strng", base64url: "base64url-kodad strng", json_string: "JSON-strng", e164: "E.164-nummer", jwt: "JWT", template_literal: "mall-literal" };
  return (_) => {
    switch (_.code) {
      case "invalid_type":
        return `Ogiltig inmatning: frvntat ${_.expected}, fick ${K(_.input)}`;
      case "invalid_value":
        if (_.values.length === 1) return `Ogiltig inmatning: frvntat ${m$(_.values[0])}`;
        return `Ogiltigt val: frvntade en av ${T$(_.values, "|")}`;
      case "too_big": {
        let Y = _.inclusive ? "<=" : "<", O = q(_.origin);
        if (O) return `Fr stor(t): frvntade ${_.origin ?? "vrdet"} att ha ${Y}${_.maximum.toString()} ${O.unit ?? "element"}`;
        return `Fr stor(t): frvntat ${_.origin ?? "vrdet"} att ha ${Y}${_.maximum.toString()}`;
      }
      case "too_small": {
        let Y = _.inclusive ? ">=" : ">", O = q(_.origin);
        if (O) return `Fr lite(t): frvntade ${_.origin ?? "vrdet"} att ha ${Y}${_.minimum.toString()} ${O.unit}`;
        return `Fr lite(t): frvntade ${_.origin ?? "vrdet"} att ha ${Y}${_.minimum.toString()}`;
      }
      case "invalid_format": {
        let Y = _;
        if (Y.format === "starts_with") return `Ogiltig strng: mste brja med "${Y.prefix}"`;
        if (Y.format === "ends_with") return `Ogiltig strng: mste sluta med "${Y.suffix}"`;
        if (Y.format === "includes") return `Ogiltig strng: mste innehlla "${Y.includes}"`;
        if (Y.format === "regex") return `Ogiltig strng: mste matcha mnstret "${Y.pattern}"`;
        return `Ogiltig(t) ${P[Y.format] ?? _.format}`;
      }
      case "not_multiple_of":
        return `Ogiltigt tal: mste vara en multipel av ${_.divisor}`;
      case "unrecognized_keys":
        return `${_.keys.length > 1 ? "Oknda nycklar" : "Oknd nyckel"}: ${T$(_.keys, ", ")}`;
      case "invalid_key":
        return `Ogiltig nyckel i ${_.origin ?? "vrdet"}`;
      case "invalid_union":
        return "Ogiltig input";
      case "invalid_element":
        return `Ogiltigt vrde i ${_.origin ?? "vrdet"}`;
      default:
        return "Ogiltig input";
    }
  };
}, "eD");
function x3() {
  return { localeError: eD() };
}
__name(x3, "x3");
var sD = /* @__PURE__ */ __name(() => {
  let $ = { string: { unit: "", verb: " " }, file: { unit: "", verb: " " }, array: { unit: "", verb: " " }, set: { unit: "", verb: " " } };
  function q(_) {
    return $[_] ?? null;
  }
  __name(q, "q");
  let K = /* @__PURE__ */ __name((_) => {
    let Y = typeof _;
    switch (Y) {
      case "number":
        return Number.isNaN(_) ? " " : "";
      case "object": {
        if (Array.isArray(_)) return "";
        if (_ === null) return "";
        if (Object.getPrototypeOf(_) !== Object.prototype && _.constructor) return _.constructor.name;
      }
    }
    return Y;
  }, "K"), P = { regex: "", email: " ", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO  ", date: "ISO ", time: "ISO ", duration: "ISO  ", ipv4: "IPv4 ", ipv6: "IPv6 ", cidrv4: "IPv4 ", cidrv6: "IPv6 ", base64: "base64-encoded ", base64url: "base64url-encoded ", json_string: "JSON ", e164: "E.164 ", jwt: "JWT", template_literal: "input" };
  return (_) => {
    switch (_.code) {
      case "invalid_type":
        return ` :  ${_.expected},  ${K(_.input)}`;
      case "invalid_value":
        if (_.values.length === 1) return ` :  ${m$(_.values[0])}`;
        return ` :  ${T$(_.values, "|")}  `;
      case "too_big": {
        let Y = _.inclusive ? "<=" : "<", O = q(_.origin);
        if (O) return ` :  ${_.origin ?? ""} ${Y}${_.maximum.toString()} ${O.unit ?? ""}   `;
        return ` :  ${_.origin ?? ""} ${Y}${_.maximum.toString()}   `;
      }
      case "too_small": {
        let Y = _.inclusive ? ">=" : ">", O = q(_.origin);
        if (O) return ` :  ${_.origin} ${Y}${_.minimum.toString()} ${O.unit}   `;
        return ` :  ${_.origin} ${Y}${_.minimum.toString()}   `;
      }
      case "invalid_format": {
        let Y = _;
        if (Y.format === "starts_with") return ` : "${Y.prefix}"   `;
        if (Y.format === "ends_with") return ` : "${Y.suffix}"   `;
        if (Y.format === "includes") return ` : "${Y.includes}"   `;
        if (Y.format === "regex") return ` : ${Y.pattern}   `;
        return ` ${P[Y.format] ?? _.format}`;
      }
      case "not_multiple_of":
        return ` : ${_.divisor}    `;
      case "unrecognized_keys":
        return `  ${_.keys.length > 1 ? "" : ""}: ${T$(_.keys, ", ")}`;
      case "invalid_key":
        return `${_.origin}   `;
      case "invalid_union":
        return " ";
      case "invalid_element":
        return `${_.origin}   `;
      default:
        return " ";
    }
  };
}, "sD");
function p3() {
  return { localeError: sD() };
}
__name(p3, "p3");
var $L = /* @__PURE__ */ __name(() => {
  let $ = { string: { unit: "", verb: "" }, file: { unit: "", verb: "" }, array: { unit: "", verb: "" }, set: { unit: "", verb: "" } };
  function q(_) {
    return $[_] ?? null;
  }
  __name(q, "q");
  let K = /* @__PURE__ */ __name((_) => {
    let Y = typeof _;
    switch (Y) {
      case "number":
        return Number.isNaN(_) ? " (NaN)" : "";
      case "object": {
        if (Array.isArray(_)) return " (Array)";
        if (_ === null) return " (null)";
        if (Object.getPrototypeOf(_) !== Object.prototype && _.constructor) return _.constructor.name;
      }
    }
    return Y;
  }, "K"), P = { regex: "", email: "", url: "URL", emoji: "", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: " ISO", date: " ISO", time: " ISO", duration: " ISO", ipv4: " IPv4", ipv6: " IPv6", cidrv4: " IP  IPv4", cidrv6: " IP  IPv6", base64: " Base64", base64url: " Base64  URL", json_string: " JSON", e164: " (E.164)", jwt: " JWT", template_literal: "" };
  return (_) => {
    switch (_.code) {
      case "invalid_type":
        return `:  ${_.expected}  ${K(_.input)}`;
      case "invalid_value":
        if (_.values.length === 1) return `:  ${m$(_.values[0])}`;
        return `:  ${T$(_.values, "|")}`;
      case "too_big": {
        let Y = _.inclusive ? "" : "", O = q(_.origin);
        if (O) return `: ${_.origin ?? ""} ${Y} ${_.maximum.toString()} ${O.unit ?? ""}`;
        return `: ${_.origin ?? ""} ${Y} ${_.maximum.toString()}`;
      }
      case "too_small": {
        let Y = _.inclusive ? "" : "", O = q(_.origin);
        if (O) return `: ${_.origin} ${Y} ${_.minimum.toString()} ${O.unit}`;
        return `: ${_.origin} ${Y} ${_.minimum.toString()}`;
      }
      case "invalid_format": {
        let Y = _;
        if (Y.format === "starts_with") return `:  "${Y.prefix}"`;
        if (Y.format === "ends_with") return `:  "${Y.suffix}"`;
        if (Y.format === "includes") return `:  "${Y.includes}" `;
        if (Y.format === "regex") return `:  ${Y.pattern}`;
        return `: ${P[Y.format] ?? _.format}`;
      }
      case "not_multiple_of":
        return `:  ${_.divisor} `;
      case "unrecognized_keys":
        return `: ${T$(_.keys, ", ")}`;
      case "invalid_key":
        return ` ${_.origin}`;
      case "invalid_union":
        return ": ";
      case "invalid_element":
        return ` ${_.origin}`;
      default:
        return "";
    }
  };
}, "$L");
function c3() {
  return { localeError: $L() };
}
__name(c3, "c3");
var qL = /* @__PURE__ */ __name(($) => {
  let q = typeof $;
  switch (q) {
    case "number":
      return Number.isNaN($) ? "NaN" : "number";
    case "object": {
      if (Array.isArray($)) return "array";
      if ($ === null) return "null";
      if (Object.getPrototypeOf($) !== Object.prototype && $.constructor) return $.constructor.name;
    }
  }
  return q;
}, "qL");
var KL = /* @__PURE__ */ __name(() => {
  let $ = { string: { unit: "karakter", verb: "olmal" }, file: { unit: "bayt", verb: "olmal" }, array: { unit: "e", verb: "olmal" }, set: { unit: "e", verb: "olmal" } };
  function q(P) {
    return $[P] ?? null;
  }
  __name(q, "q");
  let K = { regex: "girdi", email: "e-posta adresi", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO tarih ve saat", date: "ISO tarih", time: "ISO saat", duration: "ISO sre", ipv4: "IPv4 adresi", ipv6: "IPv6 adresi", cidrv4: "IPv4 aral", cidrv6: "IPv6 aral", base64: "base64 ile ifrelenmi metin", base64url: "base64url ile ifrelenmi metin", json_string: "JSON dizesi", e164: "E.164 says", jwt: "JWT", template_literal: "ablon dizesi" };
  return (P) => {
    switch (P.code) {
      case "invalid_type":
        return `Geersiz deer: beklenen ${P.expected}, alnan ${qL(P.input)}`;
      case "invalid_value":
        if (P.values.length === 1) return `Geersiz deer: beklenen ${m$(P.values[0])}`;
        return `Geersiz seenek: aadakilerden biri olmal: ${T$(P.values, "|")}`;
      case "too_big": {
        let _ = P.inclusive ? "<=" : "<", Y = q(P.origin);
        if (Y) return `ok byk: beklenen ${P.origin ?? "deer"} ${_}${P.maximum.toString()} ${Y.unit ?? "e"}`;
        return `ok byk: beklenen ${P.origin ?? "deer"} ${_}${P.maximum.toString()}`;
      }
      case "too_small": {
        let _ = P.inclusive ? ">=" : ">", Y = q(P.origin);
        if (Y) return `ok kk: beklenen ${P.origin} ${_}${P.minimum.toString()} ${Y.unit}`;
        return `ok kk: beklenen ${P.origin} ${_}${P.minimum.toString()}`;
      }
      case "invalid_format": {
        let _ = P;
        if (_.format === "starts_with") return `Geersiz metin: "${_.prefix}" ile balamal`;
        if (_.format === "ends_with") return `Geersiz metin: "${_.suffix}" ile bitmeli`;
        if (_.format === "includes") return `Geersiz metin: "${_.includes}" iermeli`;
        if (_.format === "regex") return `Geersiz metin: ${_.pattern} desenine uymal`;
        return `Geersiz ${K[_.format] ?? P.format}`;
      }
      case "not_multiple_of":
        return `Geersiz say: ${P.divisor} ile tam blnebilmeli`;
      case "unrecognized_keys":
        return `Tannmayan anahtar${P.keys.length > 1 ? "lar" : ""}: ${T$(P.keys, ", ")}`;
      case "invalid_key":
        return `${P.origin} iinde geersiz anahtar`;
      case "invalid_union":
        return "Geersiz deer";
      case "invalid_element":
        return `${P.origin} iinde geersiz deer`;
      default:
        return "Geersiz deer";
    }
  };
}, "KL");
function m3() {
  return { localeError: KL() };
}
__name(m3, "m3");
var _L = /* @__PURE__ */ __name(() => {
  let $ = { string: { unit: "", verb: "" }, file: { unit: "", verb: "" }, array: { unit: "", verb: "" }, set: { unit: "", verb: "" } };
  function q(_) {
    return $[_] ?? null;
  }
  __name(q, "q");
  let K = /* @__PURE__ */ __name((_) => {
    let Y = typeof _;
    switch (Y) {
      case "number":
        return Number.isNaN(_) ? "NaN" : "";
      case "object": {
        if (Array.isArray(_)) return "";
        if (_ === null) return "null";
        if (Object.getPrototypeOf(_) !== Object.prototype && _.constructor) return _.constructor.name;
      }
    }
    return Y;
  }, "K"), P = { regex: " ", email: "  ", url: "URL", emoji: "", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "   ISO", date: " ISO", time: " ISO", duration: " ISO", ipv4: " IPv4", ipv6: " IPv6", cidrv4: " IPv4", cidrv6: " IPv6", base64: "   base64", base64url: "   base64url", json_string: " JSON", e164: " E.164", jwt: "JWT", template_literal: " " };
  return (_) => {
    switch (_.code) {
      case "invalid_type":
        return `  :  ${_.expected},  ${K(_.input)}`;
      case "invalid_value":
        if (_.values.length === 1) return `  :  ${m$(_.values[0])}`;
        return ` :    ${T$(_.values, "|")}`;
      case "too_big": {
        let Y = _.inclusive ? "<=" : "<", O = q(_.origin);
        if (O) return ` : ,  ${_.origin ?? ""} ${O.verb} ${Y}${_.maximum.toString()} ${O.unit ?? ""}`;
        return ` : ,  ${_.origin ?? ""}  ${Y}${_.maximum.toString()}`;
      }
      case "too_small": {
        let Y = _.inclusive ? ">=" : ">", O = q(_.origin);
        if (O) return ` : ,  ${_.origin} ${O.verb} ${Y}${_.minimum.toString()} ${O.unit}`;
        return ` : ,  ${_.origin}  ${Y}${_.minimum.toString()}`;
      }
      case "invalid_format": {
        let Y = _;
        if (Y.format === "starts_with") return ` :    "${Y.prefix}"`;
        if (Y.format === "ends_with") return ` :    "${Y.suffix}"`;
        if (Y.format === "includes") return ` :   "${Y.includes}"`;
        if (Y.format === "regex") return ` :    ${Y.pattern}`;
        return ` ${P[Y.format] ?? _.format}`;
      }
      case "not_multiple_of":
        return ` :    ${_.divisor}`;
      case "unrecognized_keys":
        return ` ${_.keys.length > 1 ? "" : ""}: ${T$(_.keys, ", ")}`;
      case "invalid_key":
        return `   ${_.origin}`;
      case "invalid_union":
        return "  ";
      case "invalid_element":
        return `   ${_.origin}`;
      default:
        return "  ";
    }
  };
}, "_L");
function BP() {
  return { localeError: _L() };
}
__name(BP, "BP");
function d3() {
  return BP();
}
__name(d3, "d3");
var PL = /* @__PURE__ */ __name(() => {
  let $ = { string: { unit: "", verb: "" }, file: { unit: "", verb: "" }, array: { unit: "", verb: "" }, set: { unit: "", verb: "" } };
  function q(_) {
    return $[_] ?? null;
  }
  __name(q, "q");
  let K = /* @__PURE__ */ __name((_) => {
    let Y = typeof _;
    switch (Y) {
      case "number":
        return Number.isNaN(_) ? "NaN" : "";
      case "object": {
        if (Array.isArray(_)) return "";
        if (_ === null) return "";
        if (Object.getPrototypeOf(_) !== Object.prototype && _.constructor) return _.constructor.name;
      }
    }
    return Y;
  }, "K"), P = { regex: " ", email: "  ", url: "  ", emoji: "", uuid: "   ", uuidv4: "     4", uuidv6: "     6", nanoid: "  ", guid: "   ", cuid: "   ", cuid2: "    2", ulid: "   ", xid: "  ", ksuid: "    ", datetime: "    ", date: "   ", time: "   ", duration: "   ", ipv4: "   4 ", ipv6: "   6 ", cidrv4: "   4 ", cidrv6: "   6 ", base64: " 64   ", base64url: " 64      ", json_string: "    ", e164: " 164 ", jwt: "  ", template_literal: " " };
  return (_) => {
    switch (_.code) {
      case "invalid_type":
        return `  : ${_.expected}   ${K(_.input)}  `;
      case "invalid_value":
        if (_.values.length === 1) return `  : ${m$(_.values[0])}  `;
        return ` : ${T$(_.values, "|")}     `;
      case "too_big": {
        let Y = _.inclusive ? "<=" : "<", O = q(_.origin);
        if (O) return ` : ${_.origin ?? ""}  ${Y}${_.maximum.toString()} ${O.unit ?? ""}   `;
        return ` : ${_.origin ?? ""}  ${Y}${_.maximum.toString()}   `;
      }
      case "too_small": {
        let Y = _.inclusive ? ">=" : ">", O = q(_.origin);
        if (O) return ` : ${_.origin}  ${Y}${_.minimum.toString()} ${O.unit}   `;
        return ` : ${_.origin}  ${Y}${_.minimum.toString()}   `;
      }
      case "invalid_format": {
        let Y = _;
        if (Y.format === "starts_with") return ` : "${Y.prefix}"    `;
        if (Y.format === "ends_with") return ` : "${Y.suffix}"    `;
        if (Y.format === "includes") return ` : "${Y.includes}"   `;
        if (Y.format === "regex") return ` :  ${Y.pattern}    `;
        return ` ${P[Y.format] ?? _.format}`;
      }
      case "not_multiple_of":
        return ` : ${_.divisor}    `;
      case "unrecognized_keys":
        return `   ${_.keys.length > 1 ? "" : ""}: ${T$(_.keys, " ")}`;
      case "invalid_key":
        return `${_.origin}   `;
      case "invalid_union":
        return "  ";
      case "invalid_element":
        return `${_.origin}   `;
      default:
        return "  ";
    }
  };
}, "PL");
function l3() {
  return { localeError: PL() };
}
__name(l3, "l3");
var OL = /* @__PURE__ */ __name(() => {
  let $ = { string: { unit: "k t", verb: "c" }, file: { unit: "byte", verb: "c" }, array: { unit: "phn t", verb: "c" }, set: { unit: "phn t", verb: "c" } };
  function q(_) {
    return $[_] ?? null;
  }
  __name(q, "q");
  let K = /* @__PURE__ */ __name((_) => {
    let Y = typeof _;
    switch (Y) {
      case "number":
        return Number.isNaN(_) ? "NaN" : "s";
      case "object": {
        if (Array.isArray(_)) return "mng";
        if (_ === null) return "null";
        if (Object.getPrototypeOf(_) !== Object.prototype && _.constructor) return _.constructor.name;
      }
    }
    return Y;
  }, "K"), P = { regex: "u vo", email: "a ch email", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ngy gi ISO", date: "ngy ISO", time: "gi ISO", duration: "khong thi gian ISO", ipv4: "a ch IPv4", ipv6: "a ch IPv6", cidrv4: "di IPv4", cidrv6: "di IPv6", base64: "chui m ha base64", base64url: "chui m ha base64url", json_string: "chui JSON", e164: "s E.164", jwt: "JWT", template_literal: "u vo" };
  return (_) => {
    switch (_.code) {
      case "invalid_type":
        return `u vo khng hp l: mong i ${_.expected}, nhn c ${K(_.input)}`;
      case "invalid_value":
        if (_.values.length === 1) return `u vo khng hp l: mong i ${m$(_.values[0])}`;
        return `Ty chn khng hp l: mong i mt trong cc gi tr ${T$(_.values, "|")}`;
      case "too_big": {
        let Y = _.inclusive ? "<=" : "<", O = q(_.origin);
        if (O) return `Qu ln: mong i ${_.origin ?? "gi tr"} ${O.verb} ${Y}${_.maximum.toString()} ${O.unit ?? "phn t"}`;
        return `Qu ln: mong i ${_.origin ?? "gi tr"} ${Y}${_.maximum.toString()}`;
      }
      case "too_small": {
        let Y = _.inclusive ? ">=" : ">", O = q(_.origin);
        if (O) return `Qu nh: mong i ${_.origin} ${O.verb} ${Y}${_.minimum.toString()} ${O.unit}`;
        return `Qu nh: mong i ${_.origin} ${Y}${_.minimum.toString()}`;
      }
      case "invalid_format": {
        let Y = _;
        if (Y.format === "starts_with") return `Chui khng hp l: phi bt u bng "${Y.prefix}"`;
        if (Y.format === "ends_with") return `Chui khng hp l: phi kt thc bng "${Y.suffix}"`;
        if (Y.format === "includes") return `Chui khng hp l: phi bao gm "${Y.includes}"`;
        if (Y.format === "regex") return `Chui khng hp l: phi khp vi mu ${Y.pattern}`;
        return `${P[Y.format] ?? _.format} khng hp l`;
      }
      case "not_multiple_of":
        return `S khng hp l: phi l bi s ca ${_.divisor}`;
      case "unrecognized_keys":
        return `Kha khng c nhn dng: ${T$(_.keys, ", ")}`;
      case "invalid_key":
        return `Kha khng hp l trong ${_.origin}`;
      case "invalid_union":
        return "u vo khng hp l";
      case "invalid_element":
        return `Gi tr khng hp l trong ${_.origin}`;
      default:
        return "u vo khng hp l";
    }
  };
}, "OL");
function r3() {
  return { localeError: OL() };
}
__name(r3, "r3");
var YL = /* @__PURE__ */ __name(() => {
  let $ = { string: { unit: "", verb: "" }, file: { unit: "", verb: "" }, array: { unit: "", verb: "" }, set: { unit: "", verb: "" } };
  function q(_) {
    return $[_] ?? null;
  }
  __name(q, "q");
  let K = /* @__PURE__ */ __name((_) => {
    let Y = typeof _;
    switch (Y) {
      case "number":
        return Number.isNaN(_) ? "(NaN)" : "";
      case "object": {
        if (Array.isArray(_)) return "";
        if (_ === null) return "(null)";
        if (Object.getPrototypeOf(_) !== Object.prototype && _.constructor) return _.constructor.name;
      }
    }
    return Y;
  }, "K"), P = { regex: "", email: "", url: "URL", emoji: "", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO", date: "ISO", time: "ISO", duration: "ISO", ipv4: "IPv4", ipv6: "IPv6", cidrv4: "IPv4", cidrv6: "IPv6", base64: "base64", base64url: "base64url", json_string: "JSON", e164: "E.164", jwt: "JWT", template_literal: "" };
  return (_) => {
    switch (_.code) {
      case "invalid_type":
        return ` ${_.expected} ${K(_.input)}`;
      case "invalid_value":
        if (_.values.length === 1) return ` ${m$(_.values[0])}`;
        return ` ${T$(_.values, "|")}`;
      case "too_big": {
        let Y = _.inclusive ? "<=" : "<", O = q(_.origin);
        if (O) return ` ${_.origin ?? ""} ${Y}${_.maximum.toString()} ${O.unit ?? ""}`;
        return ` ${_.origin ?? ""} ${Y}${_.maximum.toString()}`;
      }
      case "too_small": {
        let Y = _.inclusive ? ">=" : ">", O = q(_.origin);
        if (O) return ` ${_.origin} ${Y}${_.minimum.toString()} ${O.unit}`;
        return ` ${_.origin} ${Y}${_.minimum.toString()}`;
      }
      case "invalid_format": {
        let Y = _;
        if (Y.format === "starts_with") return ` "${Y.prefix}" `;
        if (Y.format === "ends_with") return ` "${Y.suffix}" `;
        if (Y.format === "includes") return ` "${Y.includes}"`;
        if (Y.format === "regex") return ` ${Y.pattern}`;
        return `${P[Y.format] ?? _.format}`;
      }
      case "not_multiple_of":
        return ` ${_.divisor} `;
      case "unrecognized_keys":
        return `(key): ${T$(_.keys, ", ")}`;
      case "invalid_key":
        return `${_.origin} (key)`;
      case "invalid_union":
        return "";
      case "invalid_element":
        return `${_.origin} (value)`;
      default:
        return "";
    }
  };
}, "YL");
function o3() {
  return { localeError: YL() };
}
__name(o3, "o3");
var jL = /* @__PURE__ */ __name(() => {
  let $ = { string: { unit: "", verb: "" }, file: { unit: "", verb: "" }, array: { unit: "", verb: "" }, set: { unit: "", verb: "" } };
  function q(_) {
    return $[_] ?? null;
  }
  __name(q, "q");
  let K = /* @__PURE__ */ __name((_) => {
    let Y = typeof _;
    switch (Y) {
      case "number":
        return Number.isNaN(_) ? "NaN" : "number";
      case "object": {
        if (Array.isArray(_)) return "array";
        if (_ === null) return "null";
        if (Object.getPrototypeOf(_) !== Object.prototype && _.constructor) return _.constructor.name;
      }
    }
    return Y;
  }, "K"), P = { regex: "", email: "", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO ", date: "ISO ", time: "ISO ", duration: "ISO ", ipv4: "IPv4 ", ipv6: "IPv6 ", cidrv4: "IPv4 ", cidrv6: "IPv6 ", base64: "base64 ", base64url: "base64url ", json_string: "JSON ", e164: "E.164 ", jwt: "JWT", template_literal: "" };
  return (_) => {
    switch (_.code) {
      case "invalid_type":
        return ` ${_.expected} ${K(_.input)}`;
      case "invalid_value":
        if (_.values.length === 1) return ` ${m$(_.values[0])}`;
        return ` ${T$(_.values, "|")}`;
      case "too_big": {
        let Y = _.inclusive ? "<=" : "<", O = q(_.origin);
        if (O) return ` ${_.origin ?? ""}  ${Y}${_.maximum.toString()} ${O.unit ?? ""}`;
        return ` ${_.origin ?? ""}  ${Y}${_.maximum.toString()}`;
      }
      case "too_small": {
        let Y = _.inclusive ? ">=" : ">", O = q(_.origin);
        if (O) return ` ${_.origin}  ${Y}${_.minimum.toString()} ${O.unit}`;
        return ` ${_.origin}  ${Y}${_.minimum.toString()}`;
      }
      case "invalid_format": {
        let Y = _;
        if (Y.format === "starts_with") return ` "${Y.prefix}" `;
        if (Y.format === "ends_with") return ` "${Y.suffix}" `;
        if (Y.format === "includes") return ` "${Y.includes}"`;
        if (Y.format === "regex") return ` ${Y.pattern}`;
        return ` ${P[Y.format] ?? _.format}`;
      }
      case "not_multiple_of":
        return ` ${_.divisor} `;
      case "unrecognized_keys":
        return `${_.keys.length > 1 ? "" : ""}${T$(_.keys, "")}`;
      case "invalid_key":
        return `${_.origin} `;
      case "invalid_union":
        return "";
      case "invalid_element":
        return `${_.origin} `;
      default:
        return "";
    }
  };
}, "jL");
function n3() {
  return { localeError: jL() };
}
__name(n3, "n3");
var vL = /* @__PURE__ */ __name(() => {
  let $ = { string: { unit: "mi", verb: "n" }, file: { unit: "bytes", verb: "n" }, array: { unit: "nkan", verb: "n" }, set: { unit: "nkan", verb: "n" } };
  function q(_) {
    return $[_] ?? null;
  }
  __name(q, "q");
  let K = /* @__PURE__ */ __name((_) => {
    let Y = typeof _;
    switch (Y) {
      case "number":
        return Number.isNaN(_) ? "NaN" : "nmb";
      case "object": {
        if (Array.isArray(_)) return "akop";
        if (_ === null) return "null";
        if (Object.getPrototypeOf(_) !== Object.prototype && _.constructor) return _.constructor.name;
      }
    }
    return Y;
  }, "K"), P = { regex: "r bwl", email: "drs ml", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "kk ISO", date: "j ISO", time: "kk ISO", duration: "kk t p ISO", ipv4: "drs IPv4", ipv6: "drs IPv6", cidrv4: "gbgb IPv4", cidrv6: "gbgb IPv6", base64: "r t a k n base64", base64url: "r base64url", json_string: "r JSON", e164: "nmb E.164", jwt: "JWT", template_literal: "r bwl" };
  return (_) => {
    switch (_.code) {
      case "invalid_type":
        return `bwl ae: a n lti fi ${_.expected}, m a r ${K(_.input)}`;
      case "invalid_value":
        if (_.values.length === 1) return `bwl ae: a n lti fi ${m$(_.values[0])}`;
        return `yn ae: yan kan lra ${T$(_.values, "|")}`;
      case "too_big": {
        let Y = _.inclusive ? "<=" : "<", O = q(_.origin);
        if (O) return `T p j: a n lti j p ${_.origin ?? "iye"} ${O.verb} ${Y}${_.maximum} ${O.unit}`;
        return `T p j: a n lti j ${Y}${_.maximum}`;
      }
      case "too_small": {
        let Y = _.inclusive ? ">=" : ">", O = q(_.origin);
        if (O) return `Kr ju: a n lti j p ${_.origin} ${O.verb} ${Y}${_.minimum} ${O.unit}`;
        return `Kr ju: a n lti j ${Y}${_.minimum}`;
      }
      case "invalid_format": {
        let Y = _;
        if (Y.format === "starts_with") return `r ae: gbd br pl "${Y.prefix}"`;
        if (Y.format === "ends_with") return `r ae: gbd par pl "${Y.suffix}"`;
        if (Y.format === "includes") return `r ae: gbd n "${Y.includes}"`;
        if (Y.format === "regex") return `r ae: gbd b pr mu ${Y.pattern}`;
        return `Ae: ${P[Y.format] ?? _.format}`;
      }
      case "not_multiple_of":
        return `Nmb ae: gbd j y ppn ti ${_.divisor}`;
      case "unrecognized_keys":
        return `Btn m: ${T$(_.keys, ", ")}`;
      case "invalid_key":
        return `Btn ae nn ${_.origin}`;
      case "invalid_union":
        return "bwl ae";
      case "invalid_element":
        return `Iye ae nn ${_.origin}`;
      default:
        return "bwl ae";
    }
  };
}, "vL");
function i3() {
  return { localeError: vL() };
}
__name(i3, "i3");
var t3 = Symbol("ZodOutput");
var B3 = Symbol("ZodInput");
var _FP = class _FP {
  constructor() {
    this._map = /* @__PURE__ */ new WeakMap(), this._idmap = /* @__PURE__ */ new Map();
  }
  add($, ...q) {
    let K = q[0];
    if (this._map.set($, K), K && typeof K === "object" && "id" in K) {
      if (this._idmap.has(K.id)) throw Error(`ID ${K.id} already exists in the registry`);
      this._idmap.set(K.id, $);
    }
    return this;
  }
  clear() {
    return this._map = /* @__PURE__ */ new WeakMap(), this._idmap = /* @__PURE__ */ new Map(), this;
  }
  remove($) {
    let q = this._map.get($);
    if (q && typeof q === "object" && "id" in q) this._idmap.delete(q.id);
    return this._map.delete($), this;
  }
  get($) {
    let q = $._zod.parent;
    if (q) {
      let K = { ...this.get(q) ?? {} };
      delete K.id;
      let P = { ...K, ...this._map.get($) };
      return Object.keys(P).length ? P : void 0;
    }
    return this._map.get($);
  }
  has($) {
    return this._map.has($);
  }
};
__name(_FP, "FP");
var FP = _FP;
function p9() {
  return new FP();
}
__name(p9, "p9");
var Hq = p9();
function U3($, q) {
  return new $({ type: "string", ...d$(q) });
}
__name(U3, "U3");
function F3($, q) {
  return new $({ type: "string", coerce: true, ...d$(q) });
}
__name(F3, "F3");
function c9($, q) {
  return new $({ type: "string", format: "email", check: "string_format", abort: false, ...d$(q) });
}
__name(c9, "c9");
function aP($, q) {
  return new $({ type: "string", format: "guid", check: "string_format", abort: false, ...d$(q) });
}
__name(aP, "aP");
function m9($, q) {
  return new $({ type: "string", format: "uuid", check: "string_format", abort: false, ...d$(q) });
}
__name(m9, "m9");
function d9($, q) {
  return new $({ type: "string", format: "uuid", check: "string_format", abort: false, version: "v4", ...d$(q) });
}
__name(d9, "d9");
function l9($, q) {
  return new $({ type: "string", format: "uuid", check: "string_format", abort: false, version: "v6", ...d$(q) });
}
__name(l9, "l9");
function r9($, q) {
  return new $({ type: "string", format: "uuid", check: "string_format", abort: false, version: "v7", ...d$(q) });
}
__name(r9, "r9");
function QP($, q) {
  return new $({ type: "string", format: "url", check: "string_format", abort: false, ...d$(q) });
}
__name(QP, "QP");
function o9($, q) {
  return new $({ type: "string", format: "emoji", check: "string_format", abort: false, ...d$(q) });
}
__name(o9, "o9");
function n9($, q) {
  return new $({ type: "string", format: "nanoid", check: "string_format", abort: false, ...d$(q) });
}
__name(n9, "n9");
function i9($, q) {
  return new $({ type: "string", format: "cuid", check: "string_format", abort: false, ...d$(q) });
}
__name(i9, "i9");
function t9($, q) {
  return new $({ type: "string", format: "cuid2", check: "string_format", abort: false, ...d$(q) });
}
__name(t9, "t9");
function B9($, q) {
  return new $({ type: "string", format: "ulid", check: "string_format", abort: false, ...d$(q) });
}
__name(B9, "B9");
function U9($, q) {
  return new $({ type: "string", format: "xid", check: "string_format", abort: false, ...d$(q) });
}
__name(U9, "U9");
function F9($, q) {
  return new $({ type: "string", format: "ksuid", check: "string_format", abort: false, ...d$(q) });
}
__name(F9, "F9");
function a9($, q) {
  return new $({ type: "string", format: "ipv4", check: "string_format", abort: false, ...d$(q) });
}
__name(a9, "a9");
function Q9($, q) {
  return new $({ type: "string", format: "ipv6", check: "string_format", abort: false, ...d$(q) });
}
__name(Q9, "Q9");
function e9($, q) {
  return new $({ type: "string", format: "cidrv4", check: "string_format", abort: false, ...d$(q) });
}
__name(e9, "e9");
function s9($, q) {
  return new $({ type: "string", format: "cidrv6", check: "string_format", abort: false, ...d$(q) });
}
__name(s9, "s9");
function $5($, q) {
  return new $({ type: "string", format: "base64", check: "string_format", abort: false, ...d$(q) });
}
__name($5, "$5");
function q5($, q) {
  return new $({ type: "string", format: "base64url", check: "string_format", abort: false, ...d$(q) });
}
__name(q5, "q5");
function K5($, q) {
  return new $({ type: "string", format: "e164", check: "string_format", abort: false, ...d$(q) });
}
__name(K5, "K5");
function _5($, q) {
  return new $({ type: "string", format: "jwt", check: "string_format", abort: false, ...d$(q) });
}
__name(_5, "_5");
var a3 = { Any: null, Minute: -1, Second: 0, Millisecond: 3, Microsecond: 6 };
function Q3($, q) {
  return new $({ type: "string", format: "datetime", check: "string_format", offset: false, local: false, precision: null, ...d$(q) });
}
__name(Q3, "Q3");
function e3($, q) {
  return new $({ type: "string", format: "date", check: "string_format", ...d$(q) });
}
__name(e3, "e3");
function s3($, q) {
  return new $({ type: "string", format: "time", check: "string_format", precision: null, ...d$(q) });
}
__name(s3, "s3");
function $v($, q) {
  return new $({ type: "string", format: "duration", check: "string_format", ...d$(q) });
}
__name($v, "$v");
function qv($, q) {
  return new $({ type: "number", checks: [], ...d$(q) });
}
__name(qv, "qv");
function Kv($, q) {
  return new $({ type: "number", coerce: true, checks: [], ...d$(q) });
}
__name(Kv, "Kv");
function _v($, q) {
  return new $({ type: "number", check: "number_format", abort: false, format: "safeint", ...d$(q) });
}
__name(_v, "_v");
function Pv($, q) {
  return new $({ type: "number", check: "number_format", abort: false, format: "float32", ...d$(q) });
}
__name(Pv, "Pv");
function Ov($, q) {
  return new $({ type: "number", check: "number_format", abort: false, format: "float64", ...d$(q) });
}
__name(Ov, "Ov");
function Yv($, q) {
  return new $({ type: "number", check: "number_format", abort: false, format: "int32", ...d$(q) });
}
__name(Yv, "Yv");
function jv($, q) {
  return new $({ type: "number", check: "number_format", abort: false, format: "uint32", ...d$(q) });
}
__name(jv, "jv");
function vv($, q) {
  return new $({ type: "boolean", ...d$(q) });
}
__name(vv, "vv");
function zv($, q) {
  return new $({ type: "boolean", coerce: true, ...d$(q) });
}
__name(zv, "zv");
function Wv($, q) {
  return new $({ type: "bigint", ...d$(q) });
}
__name(Wv, "Wv");
function Hv($, q) {
  return new $({ type: "bigint", coerce: true, ...d$(q) });
}
__name(Hv, "Hv");
function Jv($, q) {
  return new $({ type: "bigint", check: "bigint_format", abort: false, format: "int64", ...d$(q) });
}
__name(Jv, "Jv");
function Tv($, q) {
  return new $({ type: "bigint", check: "bigint_format", abort: false, format: "uint64", ...d$(q) });
}
__name(Tv, "Tv");
function wv($, q) {
  return new $({ type: "symbol", ...d$(q) });
}
__name(wv, "wv");
function fv($, q) {
  return new $({ type: "undefined", ...d$(q) });
}
__name(fv, "fv");
function Zv($, q) {
  return new $({ type: "null", ...d$(q) });
}
__name(Zv, "Zv");
function Xv($) {
  return new $({ type: "any" });
}
__name(Xv, "Xv");
function P5($) {
  return new $({ type: "unknown" });
}
__name(P5, "P5");
function eP($, q) {
  return new $({ type: "never", ...d$(q) });
}
__name(eP, "eP");
function Av($, q) {
  return new $({ type: "void", ...d$(q) });
}
__name(Av, "Av");
function kv($, q) {
  return new $({ type: "date", ...d$(q) });
}
__name(kv, "kv");
function Gv($, q) {
  return new $({ type: "date", coerce: true, ...d$(q) });
}
__name(Gv, "Gv");
function Vv($, q) {
  return new $({ type: "nan", ...d$(q) });
}
__name(Vv, "Vv");
function zK($, q) {
  return new M9({ check: "less_than", ...d$(q), value: $, inclusive: false });
}
__name(zK, "zK");
function X8($, q) {
  return new M9({ check: "less_than", ...d$(q), value: $, inclusive: true });
}
__name(X8, "X8");
function WK($, q) {
  return new N9({ check: "greater_than", ...d$(q), value: $, inclusive: false });
}
__name(WK, "WK");
function aq($, q) {
  return new N9({ check: "greater_than", ...d$(q), value: $, inclusive: true });
}
__name(aq, "aq");
function Sv($) {
  return WK(0, $);
}
__name(Sv, "Sv");
function Mv($) {
  return zK(0, $);
}
__name(Mv, "Mv");
function Nv($) {
  return X8(0, $);
}
__name(Nv, "Nv");
function Cv($) {
  return aq(0, $);
}
__name(Cv, "Cv");
function X_($, q) {
  return new bY({ check: "multiple_of", ...d$(q), value: $ });
}
__name(X_, "X_");
function _4($, q) {
  return new xY({ check: "max_size", ...d$(q), maximum: $ });
}
__name(_4, "_4");
function A_($, q) {
  return new pY({ check: "min_size", ...d$(q), minimum: $ });
}
__name(A_, "A_");
function sP($, q) {
  return new cY({ check: "size_equals", ...d$(q), size: $ });
}
__name(sP, "sP");
function P4($, q) {
  return new mY({ check: "max_length", ...d$(q), maximum: $ });
}
__name(P4, "P4");
function nK($, q) {
  return new dY({ check: "min_length", ...d$(q), minimum: $ });
}
__name(nK, "nK");
function O4($, q) {
  return new lY({ check: "length_equals", ...d$(q), length: $ });
}
__name(O4, "O4");
function $7($, q) {
  return new rY({ check: "string_format", format: "regex", ...d$(q), pattern: $ });
}
__name($7, "$7");
function q7($) {
  return new oY({ check: "string_format", format: "lowercase", ...d$($) });
}
__name(q7, "q7");
function K7($) {
  return new nY({ check: "string_format", format: "uppercase", ...d$($) });
}
__name(K7, "K7");
function _7($, q) {
  return new iY({ check: "string_format", format: "includes", ...d$(q), includes: $ });
}
__name(_7, "_7");
function P7($, q) {
  return new tY({ check: "string_format", format: "starts_with", ...d$(q), prefix: $ });
}
__name(P7, "P7");
function O7($, q) {
  return new BY({ check: "string_format", format: "ends_with", ...d$(q), suffix: $ });
}
__name(O7, "O7");
function hv($, q, K) {
  return new UY({ check: "property", property: $, schema: q, ...d$(K) });
}
__name(hv, "hv");
function Y7($, q) {
  return new FY({ check: "mime_type", mime: $, ...d$(q) });
}
__name(Y7, "Y7");
function HK($) {
  return new aY({ check: "overwrite", tx: $ });
}
__name(HK, "HK");
function j7($) {
  return HK((q) => q.normalize($));
}
__name(j7, "j7");
function v7() {
  return HK(($) => $.trim());
}
__name(v7, "v7");
function z7() {
  return HK(($) => $.toLowerCase());
}
__name(z7, "z7");
function W7() {
  return HK(($) => $.toUpperCase());
}
__name(W7, "W7");
function Ev($, q, K) {
  return new $({ type: "array", element: q, ...d$(K) });
}
__name(Ev, "Ev");
function zL($, q, K) {
  return new $({ type: "union", options: q, ...d$(K) });
}
__name(zL, "zL");
function WL($, q, K, P) {
  return new $({ type: "union", options: K, discriminator: q, ...d$(P) });
}
__name(WL, "WL");
function HL($, q, K) {
  return new $({ type: "intersection", left: q, right: K });
}
__name(HL, "HL");
function JL($, q, K, P) {
  let _ = K instanceof P6;
  return new $({ type: "tuple", items: q, rest: _ ? K : null, ...d$(_ ? P : K) });
}
__name(JL, "JL");
function TL($, q, K, P) {
  return new $({ type: "record", keyType: q, valueType: K, ...d$(P) });
}
__name(TL, "TL");
function wL($, q, K, P) {
  return new $({ type: "map", keyType: q, valueType: K, ...d$(P) });
}
__name(wL, "wL");
function fL($, q, K) {
  return new $({ type: "set", valueType: q, ...d$(K) });
}
__name(fL, "fL");
function ZL($, q, K) {
  let P = Array.isArray(q) ? Object.fromEntries(q.map((_) => [_, _])) : q;
  return new $({ type: "enum", entries: P, ...d$(K) });
}
__name(ZL, "ZL");
function XL($, q, K) {
  return new $({ type: "enum", entries: q, ...d$(K) });
}
__name(XL, "XL");
function AL($, q, K) {
  return new $({ type: "literal", values: Array.isArray(q) ? q : [q], ...d$(K) });
}
__name(AL, "AL");
function Rv($, q) {
  return new $({ type: "file", ...d$(q) });
}
__name(Rv, "Rv");
function kL($, q) {
  return new $({ type: "transform", transform: q });
}
__name(kL, "kL");
function GL($, q) {
  return new $({ type: "optional", innerType: q });
}
__name(GL, "GL");
function VL($, q) {
  return new $({ type: "nullable", innerType: q });
}
__name(VL, "VL");
function SL($, q, K) {
  return new $({ type: "default", innerType: q, get defaultValue() {
    return typeof K === "function" ? K() : F2(K);
  } });
}
__name(SL, "SL");
function ML($, q, K) {
  return new $({ type: "nonoptional", innerType: q, ...d$(K) });
}
__name(ML, "ML");
function NL($, q) {
  return new $({ type: "success", innerType: q });
}
__name(NL, "NL");
function CL($, q, K) {
  return new $({ type: "catch", innerType: q, catchValue: typeof K === "function" ? K : () => K });
}
__name(CL, "CL");
function hL($, q, K) {
  return new $({ type: "pipe", in: q, out: K });
}
__name(hL, "hL");
function EL($, q) {
  return new $({ type: "readonly", innerType: q });
}
__name(EL, "EL");
function RL($, q, K) {
  return new $({ type: "template_literal", parts: q, ...d$(K) });
}
__name(RL, "RL");
function IL($, q) {
  return new $({ type: "lazy", getter: q });
}
__name(IL, "IL");
function DL($, q) {
  return new $({ type: "promise", innerType: q });
}
__name(DL, "DL");
function Iv($, q, K) {
  let P = d$(K);
  return P.abort ?? (P.abort = true), new $({ type: "custom", check: "custom", fn: q, ...P });
}
__name(Iv, "Iv");
function Dv($, q, K) {
  return new $({ type: "custom", check: "custom", fn: q, ...d$(K) });
}
__name(Dv, "Dv");
function Lv($) {
  let q = YA((K) => {
    return K.addIssue = (P) => {
      if (typeof P === "string") K.issues.push(a_(P, K.value, q._zod.def));
      else {
        let _ = P;
        if (_.fatal) _.continue = false;
        _.code ?? (_.code = "custom"), _.input ?? (_.input = K.value), _.inst ?? (_.inst = q), _.continue ?? (_.continue = !q._zod.def.abort), K.issues.push(a_(_));
      }
    }, $(K.value, K);
  });
  return q;
}
__name(Lv, "Lv");
function YA($, q) {
  let K = new I6({ check: "custom", ...d$(q) });
  return K._zod.check = $, K;
}
__name(YA, "YA");
function gv($, q) {
  let K = d$(q), P = K.truthy ?? ["true", "1", "yes", "on", "y", "enabled"], _ = K.falsy ?? ["false", "0", "no", "off", "n", "disabled"];
  if (K.case !== "sensitive") P = P.map((M) => typeof M === "string" ? M.toLowerCase() : M), _ = _.map((M) => typeof M === "string" ? M.toLowerCase() : M);
  let Y = new Set(P), O = new Set(_), z = $.Codec ?? rP, J = $.Boolean ?? dP, X = new ($.String ?? Z_)({ type: "string", error: K.error }), f = new J({ type: "boolean", error: K.error }), V = new z({ type: "pipe", in: X, out: f, transform: /* @__PURE__ */ __name((M, N) => {
    let E = M;
    if (K.case !== "sensitive") E = E.toLowerCase();
    if (Y.has(E)) return true;
    else if (O.has(E)) return false;
    else return N.issues.push({ code: "invalid_value", expected: "stringbool", values: [...Y, ...O], input: N.value, inst: V, continue: false }), {};
  }, "transform"), reverseTransform: /* @__PURE__ */ __name((M, N) => {
    if (M === true) return P[0] || "true";
    else return _[0] || "false";
  }, "reverseTransform"), error: K.error });
  return V;
}
__name(gv, "gv");
function Y4($, q, K, P = {}) {
  let _ = d$(P), Y = { ...d$(P), check: "string_format", type: "string", format: q, fn: typeof K === "function" ? K : (z) => K.test(z), ..._ };
  if (K instanceof RegExp) Y.pattern = K;
  return new $(Y);
}
__name(Y4, "Y4");
var _O5 = class _O5 {
  constructor($) {
    this.counter = 0, this.metadataRegistry = $?.metadata ?? Hq, this.target = $?.target ?? "draft-2020-12", this.unrepresentable = $?.unrepresentable ?? "throw", this.override = $?.override ?? (() => {
    }), this.io = $?.io ?? "output", this.seen = /* @__PURE__ */ new Map();
  }
  process($, q = { path: [], schemaPath: [] }) {
    var K;
    let P = $._zod.def, _ = { guid: "uuid", url: "uri", datetime: "date-time", json_string: "json-string", regex: "" }, Y = this.seen.get($);
    if (Y) {
      if (Y.count++, q.schemaPath.includes($)) Y.cycle = q.path;
      return Y.schema;
    }
    let O = { schema: {}, count: 1, cycle: void 0, path: q.path };
    this.seen.set($, O);
    let z = $._zod.toJSONSchema?.();
    if (z) O.schema = z;
    else {
      let X = { ...q, schemaPath: [...q.schemaPath, $], path: q.path }, f = $._zod.parent;
      if (f) O.ref = f, this.process(f, X), this.seen.get(f).isParent = true;
      else {
        let V = O.schema;
        switch (P.type) {
          case "string": {
            let M = V;
            M.type = "string";
            let { minimum: N, maximum: E, format: h, patterns: I, contentEncoding: D } = $._zod.bag;
            if (typeof N === "number") M.minLength = N;
            if (typeof E === "number") M.maxLength = E;
            if (h) {
              if (M.format = _[h] ?? h, M.format === "") delete M.format;
            }
            if (D) M.contentEncoding = D;
            if (I && I.size > 0) {
              let g = [...I];
              if (g.length === 1) M.pattern = g[0].source;
              else if (g.length > 1) O.schema.allOf = [...g.map((b) => ({ ...this.target === "draft-7" || this.target === "draft-4" || this.target === "openapi-3.0" ? { type: "string" } : {}, pattern: b.source }))];
            }
            break;
          }
          case "number": {
            let M = V, { minimum: N, maximum: E, format: h, multipleOf: I, exclusiveMaximum: D, exclusiveMinimum: g } = $._zod.bag;
            if (typeof h === "string" && h.includes("int")) M.type = "integer";
            else M.type = "number";
            if (typeof g === "number") if (this.target === "draft-4" || this.target === "openapi-3.0") M.minimum = g, M.exclusiveMinimum = true;
            else M.exclusiveMinimum = g;
            if (typeof N === "number") {
              if (M.minimum = N, typeof g === "number" && this.target !== "draft-4") if (g >= N) delete M.minimum;
              else delete M.exclusiveMinimum;
            }
            if (typeof D === "number") if (this.target === "draft-4" || this.target === "openapi-3.0") M.maximum = D, M.exclusiveMaximum = true;
            else M.exclusiveMaximum = D;
            if (typeof E === "number") {
              if (M.maximum = E, typeof D === "number" && this.target !== "draft-4") if (D <= E) delete M.maximum;
              else delete M.exclusiveMaximum;
            }
            if (typeof I === "number") M.multipleOf = I;
            break;
          }
          case "boolean": {
            let M = V;
            M.type = "boolean";
            break;
          }
          case "bigint": {
            if (this.unrepresentable === "throw") throw Error("BigInt cannot be represented in JSON Schema");
            break;
          }
          case "symbol": {
            if (this.unrepresentable === "throw") throw Error("Symbols cannot be represented in JSON Schema");
            break;
          }
          case "null": {
            if (this.target === "openapi-3.0") V.type = "string", V.nullable = true, V.enum = [null];
            else V.type = "null";
            break;
          }
          case "any":
            break;
          case "unknown":
            break;
          case "undefined": {
            if (this.unrepresentable === "throw") throw Error("Undefined cannot be represented in JSON Schema");
            break;
          }
          case "void": {
            if (this.unrepresentable === "throw") throw Error("Void cannot be represented in JSON Schema");
            break;
          }
          case "never": {
            V.not = {};
            break;
          }
          case "date": {
            if (this.unrepresentable === "throw") throw Error("Date cannot be represented in JSON Schema");
            break;
          }
          case "array": {
            let M = V, { minimum: N, maximum: E } = $._zod.bag;
            if (typeof N === "number") M.minItems = N;
            if (typeof E === "number") M.maxItems = E;
            M.type = "array", M.items = this.process(P.element, { ...X, path: [...X.path, "items"] });
            break;
          }
          case "object": {
            let M = V;
            M.type = "object", M.properties = {};
            let N = P.shape;
            for (let I in N) M.properties[I] = this.process(N[I], { ...X, path: [...X.path, "properties", I] });
            let E = new Set(Object.keys(N)), h = new Set([...E].filter((I) => {
              let D = P.shape[I]._zod;
              if (this.io === "input") return D.optin === void 0;
              else return D.optout === void 0;
            }));
            if (h.size > 0) M.required = Array.from(h);
            if (P.catchall?._zod.def.type === "never") M.additionalProperties = false;
            else if (!P.catchall) {
              if (this.io === "output") M.additionalProperties = false;
            } else if (P.catchall) M.additionalProperties = this.process(P.catchall, { ...X, path: [...X.path, "additionalProperties"] });
            break;
          }
          case "union": {
            let M = V, N = P.options.map((E, h) => this.process(E, { ...X, path: [...X.path, "anyOf", h] }));
            M.anyOf = N;
            break;
          }
          case "intersection": {
            let M = V, N = this.process(P.left, { ...X, path: [...X.path, "allOf", 0] }), E = this.process(P.right, { ...X, path: [...X.path, "allOf", 1] }), h = /* @__PURE__ */ __name((D) => "allOf" in D && Object.keys(D).length === 1, "h"), I = [...h(N) ? N.allOf : [N], ...h(E) ? E.allOf : [E]];
            M.allOf = I;
            break;
          }
          case "tuple": {
            let M = V;
            M.type = "array";
            let N = this.target === "draft-2020-12" ? "prefixItems" : "items", E = this.target === "draft-2020-12" ? "items" : this.target === "openapi-3.0" ? "items" : "additionalItems", h = P.items.map((b, y) => this.process(b, { ...X, path: [...X.path, N, y] })), I = P.rest ? this.process(P.rest, { ...X, path: [...X.path, E, ...this.target === "openapi-3.0" ? [P.items.length] : []] }) : null;
            if (this.target === "draft-2020-12") {
              if (M.prefixItems = h, I) M.items = I;
            } else if (this.target === "openapi-3.0") {
              if (M.items = { anyOf: h }, I) M.items.anyOf.push(I);
              if (M.minItems = h.length, !I) M.maxItems = h.length;
            } else if (M.items = h, I) M.additionalItems = I;
            let { minimum: D, maximum: g } = $._zod.bag;
            if (typeof D === "number") M.minItems = D;
            if (typeof g === "number") M.maxItems = g;
            break;
          }
          case "record": {
            let M = V;
            if (M.type = "object", this.target === "draft-7" || this.target === "draft-2020-12") M.propertyNames = this.process(P.keyType, { ...X, path: [...X.path, "propertyNames"] });
            M.additionalProperties = this.process(P.valueType, { ...X, path: [...X.path, "additionalProperties"] });
            break;
          }
          case "map": {
            if (this.unrepresentable === "throw") throw Error("Map cannot be represented in JSON Schema");
            break;
          }
          case "set": {
            if (this.unrepresentable === "throw") throw Error("Set cannot be represented in JSON Schema");
            break;
          }
          case "enum": {
            let M = V, N = IP(P.entries);
            if (N.every((E) => typeof E === "number")) M.type = "number";
            if (N.every((E) => typeof E === "string")) M.type = "string";
            M.enum = N;
            break;
          }
          case "literal": {
            let M = V, N = [];
            for (let E of P.values) if (E === void 0) {
              if (this.unrepresentable === "throw") throw Error("Literal `undefined` cannot be represented in JSON Schema");
            } else if (typeof E === "bigint") if (this.unrepresentable === "throw") throw Error("BigInt literals cannot be represented in JSON Schema");
            else N.push(Number(E));
            else N.push(E);
            if (N.length === 0) ;
            else if (N.length === 1) {
              let E = N[0];
              if (M.type = E === null ? "null" : typeof E, this.target === "draft-4" || this.target === "openapi-3.0") M.enum = [E];
              else M.const = E;
            } else {
              if (N.every((E) => typeof E === "number")) M.type = "number";
              if (N.every((E) => typeof E === "string")) M.type = "string";
              if (N.every((E) => typeof E === "boolean")) M.type = "string";
              if (N.every((E) => E === null)) M.type = "null";
              M.enum = N;
            }
            break;
          }
          case "file": {
            let M = V, N = { type: "string", format: "binary", contentEncoding: "binary" }, { minimum: E, maximum: h, mime: I } = $._zod.bag;
            if (E !== void 0) N.minLength = E;
            if (h !== void 0) N.maxLength = h;
            if (I) if (I.length === 1) N.contentMediaType = I[0], Object.assign(M, N);
            else M.anyOf = I.map((D) => {
              return { ...N, contentMediaType: D };
            });
            else Object.assign(M, N);
            break;
          }
          case "transform": {
            if (this.unrepresentable === "throw") throw Error("Transforms cannot be represented in JSON Schema");
            break;
          }
          case "nullable": {
            let M = this.process(P.innerType, X);
            if (this.target === "openapi-3.0") O.ref = P.innerType, V.nullable = true;
            else V.anyOf = [M, { type: "null" }];
            break;
          }
          case "nonoptional": {
            this.process(P.innerType, X), O.ref = P.innerType;
            break;
          }
          case "success": {
            let M = V;
            M.type = "boolean";
            break;
          }
          case "default": {
            this.process(P.innerType, X), O.ref = P.innerType, V.default = JSON.parse(JSON.stringify(P.defaultValue));
            break;
          }
          case "prefault": {
            if (this.process(P.innerType, X), O.ref = P.innerType, this.io === "input") V._prefault = JSON.parse(JSON.stringify(P.defaultValue));
            break;
          }
          case "catch": {
            this.process(P.innerType, X), O.ref = P.innerType;
            let M;
            try {
              M = P.catchValue(void 0);
            } catch {
              throw Error("Dynamic catch values are not supported in JSON Schema");
            }
            V.default = M;
            break;
          }
          case "nan": {
            if (this.unrepresentable === "throw") throw Error("NaN cannot be represented in JSON Schema");
            break;
          }
          case "template_literal": {
            let M = V, N = $._zod.pattern;
            if (!N) throw Error("Pattern not found in template literal");
            M.type = "string", M.pattern = N.source;
            break;
          }
          case "pipe": {
            let M = this.io === "input" ? P.in._zod.def.type === "transform" ? P.out : P.in : P.out;
            this.process(M, X), O.ref = M;
            break;
          }
          case "readonly": {
            this.process(P.innerType, X), O.ref = P.innerType, V.readOnly = true;
            break;
          }
          case "promise": {
            this.process(P.innerType, X), O.ref = P.innerType;
            break;
          }
          case "optional": {
            this.process(P.innerType, X), O.ref = P.innerType;
            break;
          }
          case "lazy": {
            let M = $._zod.innerType;
            this.process(M, X), O.ref = M;
            break;
          }
          case "custom": {
            if (this.unrepresentable === "throw") throw Error("Custom types cannot be represented in JSON Schema");
            break;
          }
          case "function": {
            if (this.unrepresentable === "throw") throw Error("Function types cannot be represented in JSON Schema");
            break;
          }
          default:
        }
      }
    }
    let J = this.metadataRegistry.get($);
    if (J) Object.assign(O.schema, J);
    if (this.io === "input" && jq($)) delete O.schema.examples, delete O.schema.default;
    if (this.io === "input" && O.schema._prefault) (K = O.schema).default ?? (K.default = O.schema._prefault);
    return delete O.schema._prefault, this.seen.get($).schema;
  }
  emit($, q) {
    let K = { cycles: q?.cycles ?? "ref", reused: q?.reused ?? "inline", external: q?.external ?? void 0 }, P = this.seen.get($);
    if (!P) throw Error("Unprocessed schema. This is a bug in Zod.");
    let _ = /* @__PURE__ */ __name((T) => {
      let X = this.target === "draft-2020-12" ? "$defs" : "definitions";
      if (K.external) {
        let N = K.external.registry.get(T[0])?.id, E = K.external.uri ?? ((I) => I);
        if (N) return { ref: E(N) };
        let h = T[1].defId ?? T[1].schema.id ?? `schema${this.counter++}`;
        return T[1].defId = h, { defId: h, ref: `${E("__shared")}#/${X}/${h}` };
      }
      if (T[1] === P) return { ref: "#" };
      let V = `${"#"}/${X}/`, M = T[1].schema.id ?? `__schema${this.counter++}`;
      return { defId: M, ref: V + M };
    }, "_"), Y = /* @__PURE__ */ __name((T) => {
      if (T[1].schema.$ref) return;
      let X = T[1], { ref: f, defId: V } = _(T);
      if (X.def = { ...X.schema }, V) X.defId = V;
      let M = X.schema;
      for (let N in M) delete M[N];
      M.$ref = f;
    }, "Y");
    if (K.cycles === "throw") for (let T of this.seen.entries()) {
      let X = T[1];
      if (X.cycle) throw Error(`Cycle detected: #/${X.cycle?.join("/")}/<root>

Set the \`cycles\` parameter to \`"ref"\` to resolve cyclical schemas with defs.`);
    }
    for (let T of this.seen.entries()) {
      let X = T[1];
      if ($ === T[0]) {
        Y(T);
        continue;
      }
      if (K.external) {
        let V = K.external.registry.get(T[0])?.id;
        if ($ !== T[0] && V) {
          Y(T);
          continue;
        }
      }
      if (this.metadataRegistry.get(T[0])?.id) {
        Y(T);
        continue;
      }
      if (X.cycle) {
        Y(T);
        continue;
      }
      if (X.count > 1) {
        if (K.reused === "ref") {
          Y(T);
          continue;
        }
      }
    }
    let O = /* @__PURE__ */ __name((T, X) => {
      let f = this.seen.get(T), V = f.def ?? f.schema, M = { ...V };
      if (f.ref === null) return;
      let N = f.ref;
      if (f.ref = null, N) {
        O(N, X);
        let E = this.seen.get(N).schema;
        if (E.$ref && (X.target === "draft-7" || X.target === "draft-4" || X.target === "openapi-3.0")) V.allOf = V.allOf ?? [], V.allOf.push(E);
        else Object.assign(V, E), Object.assign(V, M);
      }
      if (!f.isParent) this.override({ zodSchema: T, jsonSchema: V, path: f.path ?? [] });
    }, "O");
    for (let T of [...this.seen.entries()].reverse()) O(T[0], { target: this.target });
    let z = {};
    if (this.target === "draft-2020-12") z.$schema = "https://json-schema.org/draft/2020-12/schema";
    else if (this.target === "draft-7") z.$schema = "http://json-schema.org/draft-07/schema#";
    else if (this.target === "draft-4") z.$schema = "http://json-schema.org/draft-04/schema#";
    else if (this.target === "openapi-3.0") ;
    else console.warn(`Invalid target: ${this.target}`);
    if (K.external?.uri) {
      let T = K.external.registry.get($)?.id;
      if (!T) throw Error("Schema is missing an `id` property");
      z.$id = K.external.uri(T);
    }
    Object.assign(z, P.def);
    let J = K.external?.defs ?? {};
    for (let T of this.seen.entries()) {
      let X = T[1];
      if (X.def && X.defId) J[X.defId] = X.def;
    }
    if (K.external) ;
    else if (Object.keys(J).length > 0) if (this.target === "draft-2020-12") z.$defs = J;
    else z.definitions = J;
    try {
      return JSON.parse(JSON.stringify(z));
    } catch (T) {
      throw Error("Error converting schema to JSON.");
    }
  }
};
__name(_O5, "O5");
var O5 = _O5;
function j4($, q) {
  if ($ instanceof FP) {
    let P = new O5(q), _ = {};
    for (let z of $._idmap.entries()) {
      let [J, T] = z;
      P.process(T);
    }
    let Y = {}, O = { registry: $, uri: q?.uri, defs: _ };
    for (let z of $._idmap.entries()) {
      let [J, T] = z;
      Y[J] = P.emit(T, { ...q, external: O });
    }
    if (Object.keys(_).length > 0) {
      let z = P.target === "draft-2020-12" ? "$defs" : "definitions";
      Y.__shared = { [z]: _ };
    }
    return { schemas: Y };
  }
  let K = new O5(q);
  return K.process($), K.emit($, q);
}
__name(j4, "j4");
function jq($, q) {
  let K = q ?? { seen: /* @__PURE__ */ new Set() };
  if (K.seen.has($)) return false;
  K.seen.add($);
  let _ = $._zod.def;
  switch (_.type) {
    case "string":
    case "number":
    case "bigint":
    case "boolean":
    case "date":
    case "symbol":
    case "undefined":
    case "null":
    case "any":
    case "unknown":
    case "never":
    case "void":
    case "literal":
    case "enum":
    case "nan":
    case "file":
    case "template_literal":
      return false;
    case "array":
      return jq(_.element, K);
    case "object": {
      for (let Y in _.shape) if (jq(_.shape[Y], K)) return true;
      return false;
    }
    case "union": {
      for (let Y of _.options) if (jq(Y, K)) return true;
      return false;
    }
    case "intersection":
      return jq(_.left, K) || jq(_.right, K);
    case "tuple": {
      for (let Y of _.items) if (jq(Y, K)) return true;
      if (_.rest && jq(_.rest, K)) return true;
      return false;
    }
    case "record":
      return jq(_.keyType, K) || jq(_.valueType, K);
    case "map":
      return jq(_.keyType, K) || jq(_.valueType, K);
    case "set":
      return jq(_.valueType, K);
    case "promise":
    case "optional":
    case "nonoptional":
    case "nullable":
    case "readonly":
      return jq(_.innerType, K);
    case "lazy":
      return jq(_.getter(), K);
    case "default":
      return jq(_.innerType, K);
    case "prefault":
      return jq(_.innerType, K);
    case "custom":
      return false;
    case "transform":
      return true;
    case "pipe":
      return jq(_.in, K) || jq(_.out, K);
    case "success":
      return false;
    case "catch":
      return false;
    case "function":
      return false;
    default:
  }
  throw Error(`Unknown schema type: ${_.type}`);
}
__name(jq, "jq");
var jA = {};
function i8($) {
  if (typeof $ !== "object" || $ === null) return false;
  let q = $;
  if (!("_zod" in q)) return false;
  let K = q._zod;
  return typeof K === "object" && K !== null && "def" in K;
}
__name(i8, "i8");
function TK($) {
  if (typeof $ !== "object" || $ === null) return false;
  let q = $;
  if (!("_def" in q) || "_zod" in q) return false;
  let K = q._def;
  return typeof K === "object" && K != null && "typeName" in K;
}
__name(TK, "TK");
function LL($) {
  if (!$) return false;
  if (typeof $ !== "object") return false;
  if (Array.isArray($)) return false;
  if (i8($) || TK($)) return true;
  return false;
}
__name(LL, "LL");
async function vA($, q) {
  if (i8($)) return await s_($, q);
  if (TK($)) return await $.parseAsync(q);
  throw Error("Schema must be an instance of z3.ZodType or z4.$ZodType");
}
__name(vA, "vA");
function zA($) {
  if (i8($)) return Hq.get($)?.description;
  if (TK($)) return $.description;
  if ("description" in $ && typeof $.description === "string") return $.description;
  return;
}
__name(zA, "zA");
function WA($) {
  if (!LL($)) return false;
  if (TK($)) return $._def.typeName === "ZodString";
  if (i8($)) return $._zod.def.type === "string";
  return false;
}
__name(WA, "WA");
function v4($) {
  if (!i8($)) return false;
  if (typeof $ === "object" && $ !== null && "_zod" in $ && typeof $._zod === "object" && $._zod !== null && "def" in $._zod && typeof $._zod.def === "object" && $._zod.def !== null && "type" in $._zod.def && $._zod.def.type === "object") return true;
  return false;
}
__name(v4, "v4");
function HA($) {
  if (!i8($)) return false;
  if (typeof $ === "object" && $ !== null && "_zod" in $ && typeof $._zod === "object" && $._zod !== null && "def" in $._zod && typeof $._zod.def === "object" && $._zod.def !== null && "type" in $._zod.def && $._zod.def.type === "array") return true;
  return false;
}
__name(HA, "HA");
function Y5($, q = false) {
  if (TK($)) return $.strict();
  if (v4($)) {
    let K = $._zod.def.shape;
    if (q) for (let [Y, O] of Object.entries($._zod.def.shape)) {
      if (v4(O)) {
        let J = Y5(O, q);
        K[Y] = J;
      } else if (HA(O)) {
        let J = O._zod.def.element;
        if (v4(J)) J = Y5(J, q);
        K[Y] = n6(O, { ...O._zod.def, element: J });
      } else K[Y] = O;
      let z = Hq.get(O);
      if (z) Hq.add(K[Y], z);
    }
    let P = n6($, { ...$._zod.def, shape: K, catchall: eP(lP) }), _ = Hq.get($);
    if (_) Hq.add(P, _);
    return P;
  }
  throw Error("Schema must be an instance of z3.ZodObject or z4.$ZodObject");
}
__name(Y5, "Y5");
function gL($) {
  return TK($) && "typeName" in $._def && $._def.typeName === "ZodEffects";
}
__name(gL, "gL");
function bL($) {
  return i8($) && $._zod.def.type === "pipe";
}
__name(bL, "bL");
function H7($, q, K) {
  let P = K.get($);
  if (P !== void 0) return P;
  if (TK($)) {
    if (gL($)) return H7($._def.schema, q, K);
    return $;
  }
  if (i8($)) {
    let _ = $;
    if (bL($)) _ = H7($._zod.def.in, q, K);
    if (q) {
      if (v4(_)) {
        let O = _._zod.def.shape;
        for (let [z, J] of Object.entries(_._zod.def.shape)) O[z] = H7(J, q, K);
        _ = n6(_, { ..._._zod.def, shape: O });
      } else if (HA(_)) {
        let O = H7(_._zod.def.element, q, K);
        _ = n6(_, { ..._._zod.def, element: O });
      }
    }
    let Y = Hq.get($);
    if (Y) Hq.add(_, Y);
    return K.set($, _), _;
  }
  throw Error("Schema must be an instance of z3.ZodType or z4.$ZodType");
}
__name(H7, "H7");
function JA($, q = false) {
  return H7($, q, /* @__PURE__ */ new WeakMap());
}
__name(JA, "JA");
function bv($) {
  return $.replace(/[^a-zA-Z-_0-9]/g, "_");
}
__name(bv, "bv");
var yL = ["*", "_", "`"];
function uL($) {
  let q = "";
  for (let [K, P] of Object.entries($)) q += `	classDef ${K} ${P};
`;
  return q;
}
__name(uL, "uL");
function TA($, q, K) {
  let { firstNode: P, lastNode: _, nodeColors: Y, withStyles: O = true, curveStyle: z = "linear", wrapLabelNWords: J = 9 } = K ?? {}, T = O ? `%%{init: {'flowchart': {'curve': '${z}'}}}%%
graph TD;
` : `graph TD;
`;
  if (O) {
    let N = { ["default"]: "{0}({1})" };
    if (P !== void 0) N[P] = "{0}([{1}]):::first";
    if (_ !== void 0) N[_] = "{0}([{1}]):::last";
    for (let [E, h] of Object.entries($)) {
      let I = h.name.split(":").pop() ?? "", g = yL.some((y) => I.startsWith(y) && I.endsWith(y)) ? `<p>${I}</p>` : I;
      if (Object.keys(h.metadata ?? {}).length) g += `<hr/><small><em>${Object.entries(h.metadata ?? {}).map(([y, p]) => `${y} = ${p}`).join(`
`)}</em></small>`;
      let b = (N[E] ?? N.default).replace("{0}", bv(E)).replace("{1}", g);
      T += `	${b}
`;
    }
  }
  let X = {};
  for (let M of q) {
    let N = M.source.split(":"), E = M.target.split(":"), h = N.filter((I, D) => I === E[D]).join(":");
    if (!X[h]) X[h] = [];
    X[h].push(M);
  }
  let f = /* @__PURE__ */ new Set();
  function V(M, N) {
    let E = M.length === 1 && M[0].source === M[0].target;
    if (N && !E) {
      let h = N.split(":").pop();
      if (f.has(h)) throw Error(`Found duplicate subgraph '${h}' -- this likely means that you're reusing a subgraph node with the same name. Please adjust your graph to have subgraph nodes with unique names.`);
      f.add(h), T += `	subgraph ${h}
`;
    }
    for (let h of M) {
      let { source: I, target: D, data: g, conditional: b } = h, y = "";
      if (g !== void 0) {
        let p = g, n = p.split(" ");
        if (n.length > J) p = Array.from({ length: Math.ceil(n.length / J) }, (s, q$) => n.slice(q$ * J, (q$ + 1) * J).join(" ")).join("&nbsp;<br>&nbsp;");
        y = b ? ` -. &nbsp;${p}&nbsp; .-> ` : ` -- &nbsp;${p}&nbsp; --> `;
      } else y = b ? " -.-> " : " --> ";
      T += `	${bv(I)}${y}${bv(D)};
`;
    }
    for (let h in X) if (h.startsWith(`${N}:`) && h !== N) V(X[h], h);
    if (N && !E) T += `	end
`;
  }
  __name(V, "V");
  V(X[""] ?? [], "");
  for (let M in X) if (!M.includes(":") && M !== "") V(X[M], M);
  if (O) T += uL(Y ?? {});
  return T;
}
__name(TA, "TA");
async function wA($, q) {
  let K = q?.backgroundColor ?? "white", P = q?.imageType ?? "png", _ = btoa($);
  if (K !== void 0) {
    if (!/^#(?:[0-9a-fA-F]{3}){1,2}$/.test(K)) K = `!${K}`;
  }
  let Y = `https://mermaid.ink/img/${_}?bgColor=${K}&type=${P}`, O = await fetch(Y);
  if (!O.ok) throw Error(["Failed to render the graph using the Mermaid.INK API.", `Status code: ${O.status}`, `Status text: ${O.statusText}`].join(`
`));
  return await O.blob();
}
__name(wA, "wA");
var uv = Symbol("Let zodToJsonSchema decide on which parser to use");
var yv = { name: void 0, $refStrategy: "root", basePath: ["#"], effectStrategy: "input", pipeStrategy: "all", dateStrategy: "format:date-time", mapStrategy: "entries", removeAdditionalStrategy: "passthrough", allowedAdditionalProperties: true, rejectedAdditionalProperties: false, definitionPath: "definitions", target: "jsonSchema7", strictUnions: false, definitions: {}, errorMessages: false, markdownDescription: false, patternStrategy: "escape", applyRegexFlags: false, emailStrategy: "format:email", base64Strategy: "contentEncoding:base64", nameStrategy: "ref", openAiAnyTypeName: "OpenAiAnyType" };
var xv = /* @__PURE__ */ __name(($) => typeof $ === "string" ? { ...yv, name: $ } : { ...yv, ...$ }, "xv");
var pv = /* @__PURE__ */ __name(($) => {
  let q = xv($), K = q.name !== void 0 ? [...q.basePath, q.definitionPath, q.name] : q.basePath;
  return { ...q, flags: { hasReferencedOpenAiAnyType: false }, currentPath: K, propertyPath: void 0, seen: new Map(Object.entries(q.definitions).map(([P, _]) => [_._def, { def: _._def, path: [...q.basePath, q.definitionPath, P], jsonSchema: void 0 }])) };
}, "pv");
var J7 = /* @__PURE__ */ __name(($, q) => {
  let K = 0;
  for (; K < $.length && K < q.length; K++) if ($[K] !== q[K]) break;
  return [($.length - K).toString(), ...q.slice(K)].join("/");
}, "J7");
function D6($) {
  if ($.target !== "openAi") return {};
  let q = [...$.basePath, $.definitionPath, $.openAiAnyTypeName];
  return $.flags.hasReferencedOpenAiAnyType = true, { $ref: $.$refStrategy === "relative" ? J7(q, $.currentPath) : q.join("/") };
}
__name(D6, "D6");
function j5($, q, K, P) {
  if (!P?.errorMessages) return;
  if (K) $.errorMessage = { ...$.errorMessage, [q]: K };
}
__name(j5, "j5");
function G6($, q, K, P, _) {
  $[q] = K, j5($, q, P, _);
}
__name(G6, "G6");
var N_ = {};
rq(N_, { void: /* @__PURE__ */ __name(() => kg, "void"), util: /* @__PURE__ */ __name(() => k6, "util"), unknown: /* @__PURE__ */ __name(() => Xg, "unknown"), union: /* @__PURE__ */ __name(() => Mg, "union"), undefined: /* @__PURE__ */ __name(() => wg, "undefined"), tuple: /* @__PURE__ */ __name(() => hg, "tuple"), transformer: /* @__PURE__ */ __name(() => xg, "transformer"), symbol: /* @__PURE__ */ __name(() => Tg, "symbol"), string: /* @__PURE__ */ __name(() => MA, "string"), strictObject: /* @__PURE__ */ __name(() => Sg, "strictObject"), setErrorMap: /* @__PURE__ */ __name(() => cL, "setErrorMap"), set: /* @__PURE__ */ __name(() => Ig, "set"), record: /* @__PURE__ */ __name(() => Eg, "record"), quotelessJson: /* @__PURE__ */ __name(() => xL, "quotelessJson"), promise: /* @__PURE__ */ __name(() => ug, "promise"), preprocess: /* @__PURE__ */ __name(() => mg, "preprocess"), pipeline: /* @__PURE__ */ __name(() => dg, "pipeline"), ostring: /* @__PURE__ */ __name(() => lg, "ostring"), optional: /* @__PURE__ */ __name(() => pg, "optional"), onumber: /* @__PURE__ */ __name(() => rg, "onumber"), oboolean: /* @__PURE__ */ __name(() => og, "oboolean"), objectUtil: /* @__PURE__ */ __name(() => cv, "objectUtil"), object: /* @__PURE__ */ __name(() => Vg, "object"), number: /* @__PURE__ */ __name(() => NA, "number"), nullable: /* @__PURE__ */ __name(() => cg, "nullable"), null: /* @__PURE__ */ __name(() => fg, "null"), never: /* @__PURE__ */ __name(() => Ag, "never"), nativeEnum: /* @__PURE__ */ __name(() => yg, "nativeEnum"), nan: /* @__PURE__ */ __name(() => Wg, "nan"), map: /* @__PURE__ */ __name(() => Rg, "map"), makeIssue: /* @__PURE__ */ __name(() => T7, "makeIssue"), literal: /* @__PURE__ */ __name(() => gg, "literal"), lazy: /* @__PURE__ */ __name(() => Lg, "lazy"), late: /* @__PURE__ */ __name(() => vg, "late"), isValid: /* @__PURE__ */ __name(() => iK, "isValid"), isDirty: /* @__PURE__ */ __name(() => z5, "isDirty"), isAsync: /* @__PURE__ */ __name(() => W4, "isAsync"), isAborted: /* @__PURE__ */ __name(() => v5, "isAborted"), intersection: /* @__PURE__ */ __name(() => Cg, "intersection"), instanceof: /* @__PURE__ */ __name(() => zg, "instanceof"), getParsedType: /* @__PURE__ */ __name(() => t8, "getParsedType"), getErrorMap: /* @__PURE__ */ __name(() => z4, "getErrorMap"), function: /* @__PURE__ */ __name(() => Dg, "function"), enum: /* @__PURE__ */ __name(() => bg, "enum"), effect: /* @__PURE__ */ __name(() => xg, "effect"), discriminatedUnion: /* @__PURE__ */ __name(() => Ng, "discriminatedUnion"), defaultErrorMap: /* @__PURE__ */ __name(() => wK, "defaultErrorMap"), datetimeRegex: /* @__PURE__ */ __name(() => GA, "datetimeRegex"), date: /* @__PURE__ */ __name(() => Jg, "date"), custom: /* @__PURE__ */ __name(() => SA, "custom"), coerce: /* @__PURE__ */ __name(() => ng, "coerce"), boolean: /* @__PURE__ */ __name(() => CA, "boolean"), bigint: /* @__PURE__ */ __name(() => Hg, "bigint"), array: /* @__PURE__ */ __name(() => Gg, "array"), any: /* @__PURE__ */ __name(() => Zg, "any"), addIssueToContext: /* @__PURE__ */ __name(() => t$, "addIssueToContext"), ZodVoid: /* @__PURE__ */ __name(() => f7, "ZodVoid"), ZodUnknown: /* @__PURE__ */ __name(() => tK, "ZodUnknown"), ZodUnion: /* @__PURE__ */ __name(() => Z4, "ZodUnion"), ZodUndefined: /* @__PURE__ */ __name(() => w4, "ZodUndefined"), ZodType: /* @__PURE__ */ __name(() => w6, "ZodType"), ZodTuple: /* @__PURE__ */ __name(() => U8, "ZodTuple"), ZodTransformer: /* @__PURE__ */ __name(() => b8, "ZodTransformer"), ZodSymbol: /* @__PURE__ */ __name(() => w7, "ZodSymbol"), ZodString: /* @__PURE__ */ __name(() => I8, "ZodString"), ZodSet: /* @__PURE__ */ __name(() => S_, "ZodSet"), ZodSchema: /* @__PURE__ */ __name(() => w6, "ZodSchema"), ZodRecord: /* @__PURE__ */ __name(() => Z7, "ZodRecord"), ZodReadonly: /* @__PURE__ */ __name(() => M4, "ZodReadonly"), ZodPromise: /* @__PURE__ */ __name(() => M_, "ZodPromise"), ZodPipeline: /* @__PURE__ */ __name(() => k7, "ZodPipeline"), ZodParsedType: /* @__PURE__ */ __name(() => o$, "ZodParsedType"), ZodOptional: /* @__PURE__ */ __name(() => L8, "ZodOptional"), ZodObject: /* @__PURE__ */ __name(() => y6, "ZodObject"), ZodNumber: /* @__PURE__ */ __name(() => BK, "ZodNumber"), ZodNullable: /* @__PURE__ */ __name(() => ZK, "ZodNullable"), ZodNull: /* @__PURE__ */ __name(() => f4, "ZodNull"), ZodNever: /* @__PURE__ */ __name(() => B8, "ZodNever"), ZodNativeEnum: /* @__PURE__ */ __name(() => G4, "ZodNativeEnum"), ZodNaN: /* @__PURE__ */ __name(() => A7, "ZodNaN"), ZodMap: /* @__PURE__ */ __name(() => X7, "ZodMap"), ZodLiteral: /* @__PURE__ */ __name(() => k4, "ZodLiteral"), ZodLazy: /* @__PURE__ */ __name(() => A4, "ZodLazy"), ZodIssueCode: /* @__PURE__ */ __name(() => p$, "ZodIssueCode"), ZodIntersection: /* @__PURE__ */ __name(() => X4, "ZodIntersection"), ZodFunction: /* @__PURE__ */ __name(() => J4, "ZodFunction"), ZodFirstPartyTypeKind: /* @__PURE__ */ __name(() => c$, "ZodFirstPartyTypeKind"), ZodError: /* @__PURE__ */ __name(() => Qq, "ZodError"), ZodEnum: /* @__PURE__ */ __name(() => FK, "ZodEnum"), ZodEffects: /* @__PURE__ */ __name(() => b8, "ZodEffects"), ZodDiscriminatedUnion: /* @__PURE__ */ __name(() => W5, "ZodDiscriminatedUnion"), ZodDefault: /* @__PURE__ */ __name(() => V4, "ZodDefault"), ZodDate: /* @__PURE__ */ __name(() => G_, "ZodDate"), ZodCatch: /* @__PURE__ */ __name(() => S4, "ZodCatch"), ZodBranded: /* @__PURE__ */ __name(() => H5, "ZodBranded"), ZodBoolean: /* @__PURE__ */ __name(() => T4, "ZodBoolean"), ZodBigInt: /* @__PURE__ */ __name(() => UK, "ZodBigInt"), ZodArray: /* @__PURE__ */ __name(() => D8, "ZodArray"), ZodAny: /* @__PURE__ */ __name(() => V_, "ZodAny"), Schema: /* @__PURE__ */ __name(() => w6, "Schema"), ParseStatus: /* @__PURE__ */ __name(() => Gq, "ParseStatus"), OK: /* @__PURE__ */ __name(() => Iq, "OK"), NEVER: /* @__PURE__ */ __name(() => ig, "NEVER"), INVALID: /* @__PURE__ */ __name(() => q6, "INVALID"), EMPTY_PATH: /* @__PURE__ */ __name(() => mL, "EMPTY_PATH"), DIRTY: /* @__PURE__ */ __name(() => k_, "DIRTY"), BRAND: /* @__PURE__ */ __name(() => jg, "BRAND") });
var k6;
(function($) {
  $.assertEqual = (_) => {
  };
  function q(_) {
  }
  __name(q, "q");
  $.assertIs = q;
  function K(_) {
    throw Error();
  }
  __name(K, "K");
  $.assertNever = K, $.arrayToEnum = (_) => {
    let Y = {};
    for (let O of _) Y[O] = O;
    return Y;
  }, $.getValidEnumValues = (_) => {
    let Y = $.objectKeys(_).filter((z) => typeof _[_[z]] !== "number"), O = {};
    for (let z of Y) O[z] = _[z];
    return $.objectValues(O);
  }, $.objectValues = (_) => {
    return $.objectKeys(_).map(function(Y) {
      return _[Y];
    });
  }, $.objectKeys = typeof Object.keys === "function" ? (_) => Object.keys(_) : (_) => {
    let Y = [];
    for (let O in _) if (Object.prototype.hasOwnProperty.call(_, O)) Y.push(O);
    return Y;
  }, $.find = (_, Y) => {
    for (let O of _) if (Y(O)) return O;
    return;
  }, $.isInteger = typeof Number.isInteger === "function" ? (_) => Number.isInteger(_) : (_) => typeof _ === "number" && Number.isFinite(_) && Math.floor(_) === _;
  function P(_, Y = " | ") {
    return _.map((O) => typeof O === "string" ? `'${O}'` : O).join(Y);
  }
  __name(P, "P");
  $.joinValues = P, $.jsonStringifyReplacer = (_, Y) => {
    if (typeof Y === "bigint") return Y.toString();
    return Y;
  };
})(k6 || (k6 = {}));
var cv;
(function($) {
  $.mergeShapes = (q, K) => {
    return { ...q, ...K };
  };
})(cv || (cv = {}));
var o$ = k6.arrayToEnum(["string", "nan", "number", "integer", "float", "boolean", "date", "bigint", "symbol", "function", "undefined", "null", "array", "object", "unknown", "promise", "void", "never", "map", "set"]);
var t8 = /* @__PURE__ */ __name(($) => {
  switch (typeof $) {
    case "undefined":
      return o$.undefined;
    case "string":
      return o$.string;
    case "number":
      return Number.isNaN($) ? o$.nan : o$.number;
    case "boolean":
      return o$.boolean;
    case "function":
      return o$.function;
    case "bigint":
      return o$.bigint;
    case "symbol":
      return o$.symbol;
    case "object":
      if (Array.isArray($)) return o$.array;
      if ($ === null) return o$.null;
      if ($.then && typeof $.then === "function" && $.catch && typeof $.catch === "function") return o$.promise;
      if (typeof Map < "u" && $ instanceof Map) return o$.map;
      if (typeof Set < "u" && $ instanceof Set) return o$.set;
      if (typeof Date < "u" && $ instanceof Date) return o$.date;
      return o$.object;
    default:
      return o$.unknown;
  }
}, "t8");
var p$ = k6.arrayToEnum(["invalid_type", "invalid_literal", "custom", "invalid_union", "invalid_union_discriminator", "invalid_enum_value", "unrecognized_keys", "invalid_arguments", "invalid_return_type", "invalid_date", "invalid_string", "too_small", "too_big", "invalid_intersection_types", "not_multiple_of", "not_finite"]);
var xL = /* @__PURE__ */ __name(($) => {
  return JSON.stringify($, null, 2).replace(/"([^"]+)":/g, "$1:");
}, "xL");
var _Qq = class _Qq extends Error {
  get errors() {
    return this.issues;
  }
  constructor($) {
    super();
    this.issues = [], this.addIssue = (K) => {
      this.issues = [...this.issues, K];
    }, this.addIssues = (K = []) => {
      this.issues = [...this.issues, ...K];
    };
    let q = new.target.prototype;
    if (Object.setPrototypeOf) Object.setPrototypeOf(this, q);
    else this.__proto__ = q;
    this.name = "ZodError", this.issues = $;
  }
  format($) {
    let q = $ || function(_) {
      return _.message;
    }, K = { _errors: [] }, P = /* @__PURE__ */ __name((_) => {
      for (let Y of _.issues) if (Y.code === "invalid_union") Y.unionErrors.map(P);
      else if (Y.code === "invalid_return_type") P(Y.returnTypeError);
      else if (Y.code === "invalid_arguments") P(Y.argumentsError);
      else if (Y.path.length === 0) K._errors.push(q(Y));
      else {
        let O = K, z = 0;
        while (z < Y.path.length) {
          let J = Y.path[z];
          if (z !== Y.path.length - 1) O[J] = O[J] || { _errors: [] };
          else O[J] = O[J] || { _errors: [] }, O[J]._errors.push(q(Y));
          O = O[J], z++;
        }
      }
    }, "P");
    return P(this), K;
  }
  static assert($) {
    if (!($ instanceof _Qq)) throw Error(`Not a ZodError: ${$}`);
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, k6.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten($ = (q) => q.message) {
    let q = {}, K = [];
    for (let P of this.issues) if (P.path.length > 0) {
      let _ = P.path[0];
      q[_] = q[_] || [], q[_].push($(P));
    } else K.push($(P));
    return { formErrors: K, fieldErrors: q };
  }
  get formErrors() {
    return this.flatten();
  }
};
__name(_Qq, "Qq");
var Qq = _Qq;
Qq.create = ($) => {
  return new Qq($);
};
var pL = /* @__PURE__ */ __name(($, q) => {
  let K;
  switch ($.code) {
    case p$.invalid_type:
      if ($.received === o$.undefined) K = "Required";
      else K = `Expected ${$.expected}, received ${$.received}`;
      break;
    case p$.invalid_literal:
      K = `Invalid literal value, expected ${JSON.stringify($.expected, k6.jsonStringifyReplacer)}`;
      break;
    case p$.unrecognized_keys:
      K = `Unrecognized key(s) in object: ${k6.joinValues($.keys, ", ")}`;
      break;
    case p$.invalid_union:
      K = "Invalid input";
      break;
    case p$.invalid_union_discriminator:
      K = `Invalid discriminator value. Expected ${k6.joinValues($.options)}`;
      break;
    case p$.invalid_enum_value:
      K = `Invalid enum value. Expected ${k6.joinValues($.options)}, received '${$.received}'`;
      break;
    case p$.invalid_arguments:
      K = "Invalid function arguments";
      break;
    case p$.invalid_return_type:
      K = "Invalid function return type";
      break;
    case p$.invalid_date:
      K = "Invalid date";
      break;
    case p$.invalid_string:
      if (typeof $.validation === "object") if ("includes" in $.validation) {
        if (K = `Invalid input: must include "${$.validation.includes}"`, typeof $.validation.position === "number") K = `${K} at one or more positions greater than or equal to ${$.validation.position}`;
      } else if ("startsWith" in $.validation) K = `Invalid input: must start with "${$.validation.startsWith}"`;
      else if ("endsWith" in $.validation) K = `Invalid input: must end with "${$.validation.endsWith}"`;
      else k6.assertNever($.validation);
      else if ($.validation !== "regex") K = `Invalid ${$.validation}`;
      else K = "Invalid";
      break;
    case p$.too_small:
      if ($.type === "array") K = `Array must contain ${$.exact ? "exactly" : $.inclusive ? "at least" : "more than"} ${$.minimum} element(s)`;
      else if ($.type === "string") K = `String must contain ${$.exact ? "exactly" : $.inclusive ? "at least" : "over"} ${$.minimum} character(s)`;
      else if ($.type === "number") K = `Number must be ${$.exact ? "exactly equal to " : $.inclusive ? "greater than or equal to " : "greater than "}${$.minimum}`;
      else if ($.type === "bigint") K = `Number must be ${$.exact ? "exactly equal to " : $.inclusive ? "greater than or equal to " : "greater than "}${$.minimum}`;
      else if ($.type === "date") K = `Date must be ${$.exact ? "exactly equal to " : $.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number($.minimum))}`;
      else K = "Invalid input";
      break;
    case p$.too_big:
      if ($.type === "array") K = `Array must contain ${$.exact ? "exactly" : $.inclusive ? "at most" : "less than"} ${$.maximum} element(s)`;
      else if ($.type === "string") K = `String must contain ${$.exact ? "exactly" : $.inclusive ? "at most" : "under"} ${$.maximum} character(s)`;
      else if ($.type === "number") K = `Number must be ${$.exact ? "exactly" : $.inclusive ? "less than or equal to" : "less than"} ${$.maximum}`;
      else if ($.type === "bigint") K = `BigInt must be ${$.exact ? "exactly" : $.inclusive ? "less than or equal to" : "less than"} ${$.maximum}`;
      else if ($.type === "date") K = `Date must be ${$.exact ? "exactly" : $.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number($.maximum))}`;
      else K = "Invalid input";
      break;
    case p$.custom:
      K = "Invalid input";
      break;
    case p$.invalid_intersection_types:
      K = "Intersection results could not be merged";
      break;
    case p$.not_multiple_of:
      K = `Number must be a multiple of ${$.multipleOf}`;
      break;
    case p$.not_finite:
      K = "Number must be finite";
      break;
    default:
      K = q.defaultError, k6.assertNever($);
  }
  return { message: K };
}, "pL");
var wK = pL;
var fA = wK;
function cL($) {
  fA = $;
}
__name(cL, "cL");
function z4() {
  return fA;
}
__name(z4, "z4");
var T7 = /* @__PURE__ */ __name(($) => {
  let { data: q, path: K, errorMaps: P, issueData: _ } = $, Y = [...K, ..._.path || []], O = { ..._, path: Y };
  if (_.message !== void 0) return { ..._, path: Y, message: _.message };
  let z = "", J = P.filter((T) => !!T).slice().reverse();
  for (let T of J) z = T(O, { data: q, defaultError: z }).message;
  return { ..._, path: Y, message: z };
}, "T7");
var mL = [];
function t$($, q) {
  let K = z4(), P = T7({ issueData: q, data: $.data, path: $.path, errorMaps: [$.common.contextualErrorMap, $.schemaErrorMap, K, K === wK ? void 0 : wK].filter((_) => !!_) });
  $.common.issues.push(P);
}
__name(t$, "t$");
var _Gq = class _Gq {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid") this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted") this.value = "aborted";
  }
  static mergeArray($, q) {
    let K = [];
    for (let P of q) {
      if (P.status === "aborted") return q6;
      if (P.status === "dirty") $.dirty();
      K.push(P.value);
    }
    return { status: $.value, value: K };
  }
  static async mergeObjectAsync($, q) {
    let K = [];
    for (let P of q) {
      let _ = await P.key, Y = await P.value;
      K.push({ key: _, value: Y });
    }
    return _Gq.mergeObjectSync($, K);
  }
  static mergeObjectSync($, q) {
    let K = {};
    for (let P of q) {
      let { key: _, value: Y } = P;
      if (_.status === "aborted") return q6;
      if (Y.status === "aborted") return q6;
      if (_.status === "dirty") $.dirty();
      if (Y.status === "dirty") $.dirty();
      if (_.value !== "__proto__" && (typeof Y.value < "u" || P.alwaysSet)) K[_.value] = Y.value;
    }
    return { status: $.value, value: K };
  }
};
__name(_Gq, "Gq");
var Gq = _Gq;
var q6 = Object.freeze({ status: "aborted" });
var k_ = /* @__PURE__ */ __name(($) => ({ status: "dirty", value: $ }), "k_");
var Iq = /* @__PURE__ */ __name(($) => ({ status: "valid", value: $ }), "Iq");
var v5 = /* @__PURE__ */ __name(($) => $.status === "aborted", "v5");
var z5 = /* @__PURE__ */ __name(($) => $.status === "dirty", "z5");
var iK = /* @__PURE__ */ __name(($) => $.status === "valid", "iK");
var W4 = /* @__PURE__ */ __name(($) => typeof Promise < "u" && $ instanceof Promise, "W4");
var s$;
(function($) {
  $.errToObj = (q) => typeof q === "string" ? { message: q } : q || {}, $.toString = (q) => typeof q === "string" ? q : q?.message;
})(s$ || (s$ = {}));
var _g8 = class _g8 {
  constructor($, q, K, P) {
    this._cachedPath = [], this.parent = $, this.data = q, this._path = K, this._key = P;
  }
  get path() {
    if (!this._cachedPath.length) if (Array.isArray(this._key)) this._cachedPath.push(...this._path, ...this._key);
    else this._cachedPath.push(...this._path, this._key);
    return this._cachedPath;
  }
};
__name(_g8, "g8");
var g8 = _g8;
var ZA = /* @__PURE__ */ __name(($, q) => {
  if (iK(q)) return { success: true, data: q.value };
  else {
    if (!$.common.issues.length) throw Error("Validation failed but no issues detected.");
    return { success: false, get error() {
      if (this._error) return this._error;
      let K = new Qq($.common.issues);
      return this._error = K, this._error;
    } };
  }
}, "ZA");
function z6($) {
  if (!$) return {};
  let { errorMap: q, invalid_type_error: K, required_error: P, description: _ } = $;
  if (q && (K || P)) throw Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  if (q) return { errorMap: q, description: _ };
  return { errorMap: /* @__PURE__ */ __name((O, z) => {
    let { message: J } = $;
    if (O.code === "invalid_enum_value") return { message: J ?? z.defaultError };
    if (typeof z.data > "u") return { message: J ?? P ?? z.defaultError };
    if (O.code !== "invalid_type") return { message: z.defaultError };
    return { message: J ?? K ?? z.defaultError };
  }, "errorMap"), description: _ };
}
__name(z6, "z6");
var _w6 = class _w6 {
  get description() {
    return this._def.description;
  }
  _getType($) {
    return t8($.data);
  }
  _getOrReturnCtx($, q) {
    return q || { common: $.parent.common, data: $.data, parsedType: t8($.data), schemaErrorMap: this._def.errorMap, path: $.path, parent: $.parent };
  }
  _processInputParams($) {
    return { status: new Gq(), ctx: { common: $.parent.common, data: $.data, parsedType: t8($.data), schemaErrorMap: this._def.errorMap, path: $.path, parent: $.parent } };
  }
  _parseSync($) {
    let q = this._parse($);
    if (W4(q)) throw Error("Synchronous parse encountered promise.");
    return q;
  }
  _parseAsync($) {
    let q = this._parse($);
    return Promise.resolve(q);
  }
  parse($, q) {
    let K = this.safeParse($, q);
    if (K.success) return K.data;
    throw K.error;
  }
  safeParse($, q) {
    let K = { common: { issues: [], async: q?.async ?? false, contextualErrorMap: q?.errorMap }, path: q?.path || [], schemaErrorMap: this._def.errorMap, parent: null, data: $, parsedType: t8($) }, P = this._parseSync({ data: $, path: K.path, parent: K });
    return ZA(K, P);
  }
  "~validate"($) {
    let q = { common: { issues: [], async: !!this["~standard"].async }, path: [], schemaErrorMap: this._def.errorMap, parent: null, data: $, parsedType: t8($) };
    if (!this["~standard"].async) try {
      let K = this._parseSync({ data: $, path: [], parent: q });
      return iK(K) ? { value: K.value } : { issues: q.common.issues };
    } catch (K) {
      if (K?.message?.toLowerCase()?.includes("encountered")) this["~standard"].async = true;
      q.common = { issues: [], async: true };
    }
    return this._parseAsync({ data: $, path: [], parent: q }).then((K) => iK(K) ? { value: K.value } : { issues: q.common.issues });
  }
  async parseAsync($, q) {
    let K = await this.safeParseAsync($, q);
    if (K.success) return K.data;
    throw K.error;
  }
  async safeParseAsync($, q) {
    let K = { common: { issues: [], contextualErrorMap: q?.errorMap, async: true }, path: q?.path || [], schemaErrorMap: this._def.errorMap, parent: null, data: $, parsedType: t8($) }, P = this._parse({ data: $, path: K.path, parent: K }), _ = await (W4(P) ? P : Promise.resolve(P));
    return ZA(K, _);
  }
  refine($, q) {
    let K = /* @__PURE__ */ __name((P) => {
      if (typeof q === "string" || typeof q > "u") return { message: q };
      else if (typeof q === "function") return q(P);
      else return q;
    }, "K");
    return this._refinement((P, _) => {
      let Y = $(P), O = /* @__PURE__ */ __name(() => _.addIssue({ code: p$.custom, ...K(P) }), "O");
      if (typeof Promise < "u" && Y instanceof Promise) return Y.then((z) => {
        if (!z) return O(), false;
        else return true;
      });
      if (!Y) return O(), false;
      else return true;
    });
  }
  refinement($, q) {
    return this._refinement((K, P) => {
      if (!$(K)) return P.addIssue(typeof q === "function" ? q(K, P) : q), false;
      else return true;
    });
  }
  _refinement($) {
    return new b8({ schema: this, typeName: c$.ZodEffects, effect: { type: "refinement", refinement: $ } });
  }
  superRefine($) {
    return this._refinement($);
  }
  constructor($) {
    this.spa = this.safeParseAsync, this._def = $, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.readonly = this.readonly.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this), this["~standard"] = { version: 1, vendor: "zod", validate: /* @__PURE__ */ __name((q) => this["~validate"](q), "validate") };
  }
  optional() {
    return L8.create(this, this._def);
  }
  nullable() {
    return ZK.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return D8.create(this);
  }
  promise() {
    return M_.create(this, this._def);
  }
  or($) {
    return Z4.create([this, $], this._def);
  }
  and($) {
    return X4.create(this, $, this._def);
  }
  transform($) {
    return new b8({ ...z6(this._def), schema: this, typeName: c$.ZodEffects, effect: { type: "transform", transform: $ } });
  }
  default($) {
    let q = typeof $ === "function" ? $ : () => $;
    return new V4({ ...z6(this._def), innerType: this, defaultValue: q, typeName: c$.ZodDefault });
  }
  brand() {
    return new H5({ typeName: c$.ZodBranded, type: this, ...z6(this._def) });
  }
  catch($) {
    let q = typeof $ === "function" ? $ : () => $;
    return new S4({ ...z6(this._def), innerType: this, catchValue: q, typeName: c$.ZodCatch });
  }
  describe($) {
    return new this.constructor({ ...this._def, description: $ });
  }
  pipe($) {
    return k7.create(this, $);
  }
  readonly() {
    return M4.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
};
__name(_w6, "w6");
var w6 = _w6;
var dL = /^c[^\s-]{8,}$/i;
var lL = /^[0-9a-z]+$/;
var rL = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
var oL = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
var nL = /^[a-z0-9_-]{21}$/i;
var iL = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
var tL = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
var BL = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
var UL = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
var mv;
var FL = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
var aL = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
var QL = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
var eL = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
var sL = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
var $g = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
var AA = "((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))";
var qg = new RegExp(`^${AA}$`);
function kA($) {
  let q = "[0-5]\\d";
  if ($.precision) q = `${q}\\.\\d{${$.precision}}`;
  else if ($.precision == null) q = `${q}(\\.\\d+)?`;
  let K = $.precision ? "+" : "?";
  return `([01]\\d|2[0-3]):[0-5]\\d(:${q})${K}`;
}
__name(kA, "kA");
function Kg($) {
  return new RegExp(`^${kA($)}$`);
}
__name(Kg, "Kg");
function GA($) {
  let q = `${AA}T${kA($)}`, K = [];
  if (K.push($.local ? "Z?" : "Z"), $.offset) K.push("([+-]\\d{2}:?\\d{2})");
  return q = `${q}(${K.join("|")})`, new RegExp(`^${q}$`);
}
__name(GA, "GA");
function _g($, q) {
  if ((q === "v4" || !q) && FL.test($)) return true;
  if ((q === "v6" || !q) && QL.test($)) return true;
  return false;
}
__name(_g, "_g");
function Pg($, q) {
  if (!iL.test($)) return false;
  try {
    let [K] = $.split(".");
    if (!K) return false;
    let P = K.replace(/-/g, "+").replace(/_/g, "/").padEnd(K.length + (4 - K.length % 4) % 4, "="), _ = JSON.parse(atob(P));
    if (typeof _ !== "object" || _ === null) return false;
    if ("typ" in _ && _?.typ !== "JWT") return false;
    if (!_.alg) return false;
    if (q && _.alg !== q) return false;
    return true;
  } catch {
    return false;
  }
}
__name(Pg, "Pg");
function Og($, q) {
  if ((q === "v4" || !q) && aL.test($)) return true;
  if ((q === "v6" || !q) && eL.test($)) return true;
  return false;
}
__name(Og, "Og");
var _I8 = class _I8 extends w6 {
  _parse($) {
    if (this._def.coerce) $.data = String($.data);
    if (this._getType($) !== o$.string) {
      let _ = this._getOrReturnCtx($);
      return t$(_, { code: p$.invalid_type, expected: o$.string, received: _.parsedType }), q6;
    }
    let K = new Gq(), P = void 0;
    for (let _ of this._def.checks) if (_.kind === "min") {
      if ($.data.length < _.value) P = this._getOrReturnCtx($, P), t$(P, { code: p$.too_small, minimum: _.value, type: "string", inclusive: true, exact: false, message: _.message }), K.dirty();
    } else if (_.kind === "max") {
      if ($.data.length > _.value) P = this._getOrReturnCtx($, P), t$(P, { code: p$.too_big, maximum: _.value, type: "string", inclusive: true, exact: false, message: _.message }), K.dirty();
    } else if (_.kind === "length") {
      let Y = $.data.length > _.value, O = $.data.length < _.value;
      if (Y || O) {
        if (P = this._getOrReturnCtx($, P), Y) t$(P, { code: p$.too_big, maximum: _.value, type: "string", inclusive: true, exact: true, message: _.message });
        else if (O) t$(P, { code: p$.too_small, minimum: _.value, type: "string", inclusive: true, exact: true, message: _.message });
        K.dirty();
      }
    } else if (_.kind === "email") {
      if (!BL.test($.data)) P = this._getOrReturnCtx($, P), t$(P, { validation: "email", code: p$.invalid_string, message: _.message }), K.dirty();
    } else if (_.kind === "emoji") {
      if (!mv) mv = new RegExp(UL, "u");
      if (!mv.test($.data)) P = this._getOrReturnCtx($, P), t$(P, { validation: "emoji", code: p$.invalid_string, message: _.message }), K.dirty();
    } else if (_.kind === "uuid") {
      if (!oL.test($.data)) P = this._getOrReturnCtx($, P), t$(P, { validation: "uuid", code: p$.invalid_string, message: _.message }), K.dirty();
    } else if (_.kind === "nanoid") {
      if (!nL.test($.data)) P = this._getOrReturnCtx($, P), t$(P, { validation: "nanoid", code: p$.invalid_string, message: _.message }), K.dirty();
    } else if (_.kind === "cuid") {
      if (!dL.test($.data)) P = this._getOrReturnCtx($, P), t$(P, { validation: "cuid", code: p$.invalid_string, message: _.message }), K.dirty();
    } else if (_.kind === "cuid2") {
      if (!lL.test($.data)) P = this._getOrReturnCtx($, P), t$(P, { validation: "cuid2", code: p$.invalid_string, message: _.message }), K.dirty();
    } else if (_.kind === "ulid") {
      if (!rL.test($.data)) P = this._getOrReturnCtx($, P), t$(P, { validation: "ulid", code: p$.invalid_string, message: _.message }), K.dirty();
    } else if (_.kind === "url") try {
      new URL($.data);
    } catch {
      P = this._getOrReturnCtx($, P), t$(P, { validation: "url", code: p$.invalid_string, message: _.message }), K.dirty();
    }
    else if (_.kind === "regex") {
      if (_.regex.lastIndex = 0, !_.regex.test($.data)) P = this._getOrReturnCtx($, P), t$(P, { validation: "regex", code: p$.invalid_string, message: _.message }), K.dirty();
    } else if (_.kind === "trim") $.data = $.data.trim();
    else if (_.kind === "includes") {
      if (!$.data.includes(_.value, _.position)) P = this._getOrReturnCtx($, P), t$(P, { code: p$.invalid_string, validation: { includes: _.value, position: _.position }, message: _.message }), K.dirty();
    } else if (_.kind === "toLowerCase") $.data = $.data.toLowerCase();
    else if (_.kind === "toUpperCase") $.data = $.data.toUpperCase();
    else if (_.kind === "startsWith") {
      if (!$.data.startsWith(_.value)) P = this._getOrReturnCtx($, P), t$(P, { code: p$.invalid_string, validation: { startsWith: _.value }, message: _.message }), K.dirty();
    } else if (_.kind === "endsWith") {
      if (!$.data.endsWith(_.value)) P = this._getOrReturnCtx($, P), t$(P, { code: p$.invalid_string, validation: { endsWith: _.value }, message: _.message }), K.dirty();
    } else if (_.kind === "datetime") {
      if (!GA(_).test($.data)) P = this._getOrReturnCtx($, P), t$(P, { code: p$.invalid_string, validation: "datetime", message: _.message }), K.dirty();
    } else if (_.kind === "date") {
      if (!qg.test($.data)) P = this._getOrReturnCtx($, P), t$(P, { code: p$.invalid_string, validation: "date", message: _.message }), K.dirty();
    } else if (_.kind === "time") {
      if (!Kg(_).test($.data)) P = this._getOrReturnCtx($, P), t$(P, { code: p$.invalid_string, validation: "time", message: _.message }), K.dirty();
    } else if (_.kind === "duration") {
      if (!tL.test($.data)) P = this._getOrReturnCtx($, P), t$(P, { validation: "duration", code: p$.invalid_string, message: _.message }), K.dirty();
    } else if (_.kind === "ip") {
      if (!_g($.data, _.version)) P = this._getOrReturnCtx($, P), t$(P, { validation: "ip", code: p$.invalid_string, message: _.message }), K.dirty();
    } else if (_.kind === "jwt") {
      if (!Pg($.data, _.alg)) P = this._getOrReturnCtx($, P), t$(P, { validation: "jwt", code: p$.invalid_string, message: _.message }), K.dirty();
    } else if (_.kind === "cidr") {
      if (!Og($.data, _.version)) P = this._getOrReturnCtx($, P), t$(P, { validation: "cidr", code: p$.invalid_string, message: _.message }), K.dirty();
    } else if (_.kind === "base64") {
      if (!sL.test($.data)) P = this._getOrReturnCtx($, P), t$(P, { validation: "base64", code: p$.invalid_string, message: _.message }), K.dirty();
    } else if (_.kind === "base64url") {
      if (!$g.test($.data)) P = this._getOrReturnCtx($, P), t$(P, { validation: "base64url", code: p$.invalid_string, message: _.message }), K.dirty();
    } else k6.assertNever(_);
    return { status: K.value, value: $.data };
  }
  _regex($, q, K) {
    return this.refinement((P) => $.test(P), { validation: q, code: p$.invalid_string, ...s$.errToObj(K) });
  }
  _addCheck($) {
    return new _I8({ ...this._def, checks: [...this._def.checks, $] });
  }
  email($) {
    return this._addCheck({ kind: "email", ...s$.errToObj($) });
  }
  url($) {
    return this._addCheck({ kind: "url", ...s$.errToObj($) });
  }
  emoji($) {
    return this._addCheck({ kind: "emoji", ...s$.errToObj($) });
  }
  uuid($) {
    return this._addCheck({ kind: "uuid", ...s$.errToObj($) });
  }
  nanoid($) {
    return this._addCheck({ kind: "nanoid", ...s$.errToObj($) });
  }
  cuid($) {
    return this._addCheck({ kind: "cuid", ...s$.errToObj($) });
  }
  cuid2($) {
    return this._addCheck({ kind: "cuid2", ...s$.errToObj($) });
  }
  ulid($) {
    return this._addCheck({ kind: "ulid", ...s$.errToObj($) });
  }
  base64($) {
    return this._addCheck({ kind: "base64", ...s$.errToObj($) });
  }
  base64url($) {
    return this._addCheck({ kind: "base64url", ...s$.errToObj($) });
  }
  jwt($) {
    return this._addCheck({ kind: "jwt", ...s$.errToObj($) });
  }
  ip($) {
    return this._addCheck({ kind: "ip", ...s$.errToObj($) });
  }
  cidr($) {
    return this._addCheck({ kind: "cidr", ...s$.errToObj($) });
  }
  datetime($) {
    if (typeof $ === "string") return this._addCheck({ kind: "datetime", precision: null, offset: false, local: false, message: $ });
    return this._addCheck({ kind: "datetime", precision: typeof $?.precision > "u" ? null : $?.precision, offset: $?.offset ?? false, local: $?.local ?? false, ...s$.errToObj($?.message) });
  }
  date($) {
    return this._addCheck({ kind: "date", message: $ });
  }
  time($) {
    if (typeof $ === "string") return this._addCheck({ kind: "time", precision: null, message: $ });
    return this._addCheck({ kind: "time", precision: typeof $?.precision > "u" ? null : $?.precision, ...s$.errToObj($?.message) });
  }
  duration($) {
    return this._addCheck({ kind: "duration", ...s$.errToObj($) });
  }
  regex($, q) {
    return this._addCheck({ kind: "regex", regex: $, ...s$.errToObj(q) });
  }
  includes($, q) {
    return this._addCheck({ kind: "includes", value: $, position: q?.position, ...s$.errToObj(q?.message) });
  }
  startsWith($, q) {
    return this._addCheck({ kind: "startsWith", value: $, ...s$.errToObj(q) });
  }
  endsWith($, q) {
    return this._addCheck({ kind: "endsWith", value: $, ...s$.errToObj(q) });
  }
  min($, q) {
    return this._addCheck({ kind: "min", value: $, ...s$.errToObj(q) });
  }
  max($, q) {
    return this._addCheck({ kind: "max", value: $, ...s$.errToObj(q) });
  }
  length($, q) {
    return this._addCheck({ kind: "length", value: $, ...s$.errToObj(q) });
  }
  nonempty($) {
    return this.min(1, s$.errToObj($));
  }
  trim() {
    return new _I8({ ...this._def, checks: [...this._def.checks, { kind: "trim" }] });
  }
  toLowerCase() {
    return new _I8({ ...this._def, checks: [...this._def.checks, { kind: "toLowerCase" }] });
  }
  toUpperCase() {
    return new _I8({ ...this._def, checks: [...this._def.checks, { kind: "toUpperCase" }] });
  }
  get isDatetime() {
    return !!this._def.checks.find(($) => $.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find(($) => $.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find(($) => $.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find(($) => $.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find(($) => $.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find(($) => $.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find(($) => $.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find(($) => $.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find(($) => $.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find(($) => $.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find(($) => $.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find(($) => $.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find(($) => $.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find(($) => $.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find(($) => $.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find(($) => $.kind === "base64url");
  }
  get minLength() {
    let $ = null;
    for (let q of this._def.checks) if (q.kind === "min") {
      if ($ === null || q.value > $) $ = q.value;
    }
    return $;
  }
  get maxLength() {
    let $ = null;
    for (let q of this._def.checks) if (q.kind === "max") {
      if ($ === null || q.value < $) $ = q.value;
    }
    return $;
  }
};
__name(_I8, "I8");
var I8 = _I8;
I8.create = ($) => {
  return new I8({ checks: [], typeName: c$.ZodString, coerce: $?.coerce ?? false, ...z6($) });
};
function Yg($, q) {
  let K = ($.toString().split(".")[1] || "").length, P = (q.toString().split(".")[1] || "").length, _ = K > P ? K : P, Y = Number.parseInt($.toFixed(_).replace(".", "")), O = Number.parseInt(q.toFixed(_).replace(".", ""));
  return Y % O / 10 ** _;
}
__name(Yg, "Yg");
var _BK = class _BK extends w6 {
  constructor() {
    super(...arguments);
    this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
  }
  _parse($) {
    if (this._def.coerce) $.data = Number($.data);
    if (this._getType($) !== o$.number) {
      let _ = this._getOrReturnCtx($);
      return t$(_, { code: p$.invalid_type, expected: o$.number, received: _.parsedType }), q6;
    }
    let K = void 0, P = new Gq();
    for (let _ of this._def.checks) if (_.kind === "int") {
      if (!k6.isInteger($.data)) K = this._getOrReturnCtx($, K), t$(K, { code: p$.invalid_type, expected: "integer", received: "float", message: _.message }), P.dirty();
    } else if (_.kind === "min") {
      if (_.inclusive ? $.data < _.value : $.data <= _.value) K = this._getOrReturnCtx($, K), t$(K, { code: p$.too_small, minimum: _.value, type: "number", inclusive: _.inclusive, exact: false, message: _.message }), P.dirty();
    } else if (_.kind === "max") {
      if (_.inclusive ? $.data > _.value : $.data >= _.value) K = this._getOrReturnCtx($, K), t$(K, { code: p$.too_big, maximum: _.value, type: "number", inclusive: _.inclusive, exact: false, message: _.message }), P.dirty();
    } else if (_.kind === "multipleOf") {
      if (Yg($.data, _.value) !== 0) K = this._getOrReturnCtx($, K), t$(K, { code: p$.not_multiple_of, multipleOf: _.value, message: _.message }), P.dirty();
    } else if (_.kind === "finite") {
      if (!Number.isFinite($.data)) K = this._getOrReturnCtx($, K), t$(K, { code: p$.not_finite, message: _.message }), P.dirty();
    } else k6.assertNever(_);
    return { status: P.value, value: $.data };
  }
  gte($, q) {
    return this.setLimit("min", $, true, s$.toString(q));
  }
  gt($, q) {
    return this.setLimit("min", $, false, s$.toString(q));
  }
  lte($, q) {
    return this.setLimit("max", $, true, s$.toString(q));
  }
  lt($, q) {
    return this.setLimit("max", $, false, s$.toString(q));
  }
  setLimit($, q, K, P) {
    return new _BK({ ...this._def, checks: [...this._def.checks, { kind: $, value: q, inclusive: K, message: s$.toString(P) }] });
  }
  _addCheck($) {
    return new _BK({ ...this._def, checks: [...this._def.checks, $] });
  }
  int($) {
    return this._addCheck({ kind: "int", message: s$.toString($) });
  }
  positive($) {
    return this._addCheck({ kind: "min", value: 0, inclusive: false, message: s$.toString($) });
  }
  negative($) {
    return this._addCheck({ kind: "max", value: 0, inclusive: false, message: s$.toString($) });
  }
  nonpositive($) {
    return this._addCheck({ kind: "max", value: 0, inclusive: true, message: s$.toString($) });
  }
  nonnegative($) {
    return this._addCheck({ kind: "min", value: 0, inclusive: true, message: s$.toString($) });
  }
  multipleOf($, q) {
    return this._addCheck({ kind: "multipleOf", value: $, message: s$.toString(q) });
  }
  finite($) {
    return this._addCheck({ kind: "finite", message: s$.toString($) });
  }
  safe($) {
    return this._addCheck({ kind: "min", inclusive: true, value: Number.MIN_SAFE_INTEGER, message: s$.toString($) })._addCheck({ kind: "max", inclusive: true, value: Number.MAX_SAFE_INTEGER, message: s$.toString($) });
  }
  get minValue() {
    let $ = null;
    for (let q of this._def.checks) if (q.kind === "min") {
      if ($ === null || q.value > $) $ = q.value;
    }
    return $;
  }
  get maxValue() {
    let $ = null;
    for (let q of this._def.checks) if (q.kind === "max") {
      if ($ === null || q.value < $) $ = q.value;
    }
    return $;
  }
  get isInt() {
    return !!this._def.checks.find(($) => $.kind === "int" || $.kind === "multipleOf" && k6.isInteger($.value));
  }
  get isFinite() {
    let $ = null, q = null;
    for (let K of this._def.checks) if (K.kind === "finite" || K.kind === "int" || K.kind === "multipleOf") return true;
    else if (K.kind === "min") {
      if (q === null || K.value > q) q = K.value;
    } else if (K.kind === "max") {
      if ($ === null || K.value < $) $ = K.value;
    }
    return Number.isFinite(q) && Number.isFinite($);
  }
};
__name(_BK, "BK");
var BK = _BK;
BK.create = ($) => {
  return new BK({ checks: [], typeName: c$.ZodNumber, coerce: $?.coerce || false, ...z6($) });
};
var _UK = class _UK extends w6 {
  constructor() {
    super(...arguments);
    this.min = this.gte, this.max = this.lte;
  }
  _parse($) {
    if (this._def.coerce) try {
      $.data = BigInt($.data);
    } catch {
      return this._getInvalidInput($);
    }
    if (this._getType($) !== o$.bigint) return this._getInvalidInput($);
    let K = void 0, P = new Gq();
    for (let _ of this._def.checks) if (_.kind === "min") {
      if (_.inclusive ? $.data < _.value : $.data <= _.value) K = this._getOrReturnCtx($, K), t$(K, { code: p$.too_small, type: "bigint", minimum: _.value, inclusive: _.inclusive, message: _.message }), P.dirty();
    } else if (_.kind === "max") {
      if (_.inclusive ? $.data > _.value : $.data >= _.value) K = this._getOrReturnCtx($, K), t$(K, { code: p$.too_big, type: "bigint", maximum: _.value, inclusive: _.inclusive, message: _.message }), P.dirty();
    } else if (_.kind === "multipleOf") {
      if ($.data % _.value !== BigInt(0)) K = this._getOrReturnCtx($, K), t$(K, { code: p$.not_multiple_of, multipleOf: _.value, message: _.message }), P.dirty();
    } else k6.assertNever(_);
    return { status: P.value, value: $.data };
  }
  _getInvalidInput($) {
    let q = this._getOrReturnCtx($);
    return t$(q, { code: p$.invalid_type, expected: o$.bigint, received: q.parsedType }), q6;
  }
  gte($, q) {
    return this.setLimit("min", $, true, s$.toString(q));
  }
  gt($, q) {
    return this.setLimit("min", $, false, s$.toString(q));
  }
  lte($, q) {
    return this.setLimit("max", $, true, s$.toString(q));
  }
  lt($, q) {
    return this.setLimit("max", $, false, s$.toString(q));
  }
  setLimit($, q, K, P) {
    return new _UK({ ...this._def, checks: [...this._def.checks, { kind: $, value: q, inclusive: K, message: s$.toString(P) }] });
  }
  _addCheck($) {
    return new _UK({ ...this._def, checks: [...this._def.checks, $] });
  }
  positive($) {
    return this._addCheck({ kind: "min", value: BigInt(0), inclusive: false, message: s$.toString($) });
  }
  negative($) {
    return this._addCheck({ kind: "max", value: BigInt(0), inclusive: false, message: s$.toString($) });
  }
  nonpositive($) {
    return this._addCheck({ kind: "max", value: BigInt(0), inclusive: true, message: s$.toString($) });
  }
  nonnegative($) {
    return this._addCheck({ kind: "min", value: BigInt(0), inclusive: true, message: s$.toString($) });
  }
  multipleOf($, q) {
    return this._addCheck({ kind: "multipleOf", value: $, message: s$.toString(q) });
  }
  get minValue() {
    let $ = null;
    for (let q of this._def.checks) if (q.kind === "min") {
      if ($ === null || q.value > $) $ = q.value;
    }
    return $;
  }
  get maxValue() {
    let $ = null;
    for (let q of this._def.checks) if (q.kind === "max") {
      if ($ === null || q.value < $) $ = q.value;
    }
    return $;
  }
};
__name(_UK, "UK");
var UK = _UK;
UK.create = ($) => {
  return new UK({ checks: [], typeName: c$.ZodBigInt, coerce: $?.coerce ?? false, ...z6($) });
};
var _T4 = class _T4 extends w6 {
  _parse($) {
    if (this._def.coerce) $.data = Boolean($.data);
    if (this._getType($) !== o$.boolean) {
      let K = this._getOrReturnCtx($);
      return t$(K, { code: p$.invalid_type, expected: o$.boolean, received: K.parsedType }), q6;
    }
    return Iq($.data);
  }
};
__name(_T4, "T4");
var T4 = _T4;
T4.create = ($) => {
  return new T4({ typeName: c$.ZodBoolean, coerce: $?.coerce || false, ...z6($) });
};
var _G_ = class _G_ extends w6 {
  _parse($) {
    if (this._def.coerce) $.data = new Date($.data);
    if (this._getType($) !== o$.date) {
      let _ = this._getOrReturnCtx($);
      return t$(_, { code: p$.invalid_type, expected: o$.date, received: _.parsedType }), q6;
    }
    if (Number.isNaN($.data.getTime())) {
      let _ = this._getOrReturnCtx($);
      return t$(_, { code: p$.invalid_date }), q6;
    }
    let K = new Gq(), P = void 0;
    for (let _ of this._def.checks) if (_.kind === "min") {
      if ($.data.getTime() < _.value) P = this._getOrReturnCtx($, P), t$(P, { code: p$.too_small, message: _.message, inclusive: true, exact: false, minimum: _.value, type: "date" }), K.dirty();
    } else if (_.kind === "max") {
      if ($.data.getTime() > _.value) P = this._getOrReturnCtx($, P), t$(P, { code: p$.too_big, message: _.message, inclusive: true, exact: false, maximum: _.value, type: "date" }), K.dirty();
    } else k6.assertNever(_);
    return { status: K.value, value: new Date($.data.getTime()) };
  }
  _addCheck($) {
    return new _G_({ ...this._def, checks: [...this._def.checks, $] });
  }
  min($, q) {
    return this._addCheck({ kind: "min", value: $.getTime(), message: s$.toString(q) });
  }
  max($, q) {
    return this._addCheck({ kind: "max", value: $.getTime(), message: s$.toString(q) });
  }
  get minDate() {
    let $ = null;
    for (let q of this._def.checks) if (q.kind === "min") {
      if ($ === null || q.value > $) $ = q.value;
    }
    return $ != null ? new Date($) : null;
  }
  get maxDate() {
    let $ = null;
    for (let q of this._def.checks) if (q.kind === "max") {
      if ($ === null || q.value < $) $ = q.value;
    }
    return $ != null ? new Date($) : null;
  }
};
__name(_G_, "G_");
var G_ = _G_;
G_.create = ($) => {
  return new G_({ checks: [], coerce: $?.coerce || false, typeName: c$.ZodDate, ...z6($) });
};
var _w7 = class _w7 extends w6 {
  _parse($) {
    if (this._getType($) !== o$.symbol) {
      let K = this._getOrReturnCtx($);
      return t$(K, { code: p$.invalid_type, expected: o$.symbol, received: K.parsedType }), q6;
    }
    return Iq($.data);
  }
};
__name(_w7, "w7");
var w7 = _w7;
w7.create = ($) => {
  return new w7({ typeName: c$.ZodSymbol, ...z6($) });
};
var _w4 = class _w4 extends w6 {
  _parse($) {
    if (this._getType($) !== o$.undefined) {
      let K = this._getOrReturnCtx($);
      return t$(K, { code: p$.invalid_type, expected: o$.undefined, received: K.parsedType }), q6;
    }
    return Iq($.data);
  }
};
__name(_w4, "w4");
var w4 = _w4;
w4.create = ($) => {
  return new w4({ typeName: c$.ZodUndefined, ...z6($) });
};
var _f4 = class _f4 extends w6 {
  _parse($) {
    if (this._getType($) !== o$.null) {
      let K = this._getOrReturnCtx($);
      return t$(K, { code: p$.invalid_type, expected: o$.null, received: K.parsedType }), q6;
    }
    return Iq($.data);
  }
};
__name(_f4, "f4");
var f4 = _f4;
f4.create = ($) => {
  return new f4({ typeName: c$.ZodNull, ...z6($) });
};
var _V_ = class _V_ extends w6 {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse($) {
    return Iq($.data);
  }
};
__name(_V_, "V_");
var V_ = _V_;
V_.create = ($) => {
  return new V_({ typeName: c$.ZodAny, ...z6($) });
};
var _tK = class _tK extends w6 {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse($) {
    return Iq($.data);
  }
};
__name(_tK, "tK");
var tK = _tK;
tK.create = ($) => {
  return new tK({ typeName: c$.ZodUnknown, ...z6($) });
};
var _B8 = class _B8 extends w6 {
  _parse($) {
    let q = this._getOrReturnCtx($);
    return t$(q, { code: p$.invalid_type, expected: o$.never, received: q.parsedType }), q6;
  }
};
__name(_B8, "B8");
var B8 = _B8;
B8.create = ($) => {
  return new B8({ typeName: c$.ZodNever, ...z6($) });
};
var _f7 = class _f7 extends w6 {
  _parse($) {
    if (this._getType($) !== o$.undefined) {
      let K = this._getOrReturnCtx($);
      return t$(K, { code: p$.invalid_type, expected: o$.void, received: K.parsedType }), q6;
    }
    return Iq($.data);
  }
};
__name(_f7, "f7");
var f7 = _f7;
f7.create = ($) => {
  return new f7({ typeName: c$.ZodVoid, ...z6($) });
};
var _D8 = class _D8 extends w6 {
  _parse($) {
    let { ctx: q, status: K } = this._processInputParams($), P = this._def;
    if (q.parsedType !== o$.array) return t$(q, { code: p$.invalid_type, expected: o$.array, received: q.parsedType }), q6;
    if (P.exactLength !== null) {
      let Y = q.data.length > P.exactLength.value, O = q.data.length < P.exactLength.value;
      if (Y || O) t$(q, { code: Y ? p$.too_big : p$.too_small, minimum: O ? P.exactLength.value : void 0, maximum: Y ? P.exactLength.value : void 0, type: "array", inclusive: true, exact: true, message: P.exactLength.message }), K.dirty();
    }
    if (P.minLength !== null) {
      if (q.data.length < P.minLength.value) t$(q, { code: p$.too_small, minimum: P.minLength.value, type: "array", inclusive: true, exact: false, message: P.minLength.message }), K.dirty();
    }
    if (P.maxLength !== null) {
      if (q.data.length > P.maxLength.value) t$(q, { code: p$.too_big, maximum: P.maxLength.value, type: "array", inclusive: true, exact: false, message: P.maxLength.message }), K.dirty();
    }
    if (q.common.async) return Promise.all([...q.data].map((Y, O) => {
      return P.type._parseAsync(new g8(q, Y, q.path, O));
    })).then((Y) => {
      return Gq.mergeArray(K, Y);
    });
    let _ = [...q.data].map((Y, O) => {
      return P.type._parseSync(new g8(q, Y, q.path, O));
    });
    return Gq.mergeArray(K, _);
  }
  get element() {
    return this._def.type;
  }
  min($, q) {
    return new _D8({ ...this._def, minLength: { value: $, message: s$.toString(q) } });
  }
  max($, q) {
    return new _D8({ ...this._def, maxLength: { value: $, message: s$.toString(q) } });
  }
  length($, q) {
    return new _D8({ ...this._def, exactLength: { value: $, message: s$.toString(q) } });
  }
  nonempty($) {
    return this.min(1, $);
  }
};
__name(_D8, "D8");
var D8 = _D8;
D8.create = ($, q) => {
  return new D8({ type: $, minLength: null, maxLength: null, exactLength: null, typeName: c$.ZodArray, ...z6(q) });
};
function H4($) {
  if ($ instanceof y6) {
    let q = {};
    for (let K in $.shape) {
      let P = $.shape[K];
      q[K] = L8.create(H4(P));
    }
    return new y6({ ...$._def, shape: /* @__PURE__ */ __name(() => q, "shape") });
  } else if ($ instanceof D8) return new D8({ ...$._def, type: H4($.element) });
  else if ($ instanceof L8) return L8.create(H4($.unwrap()));
  else if ($ instanceof ZK) return ZK.create(H4($.unwrap()));
  else if ($ instanceof U8) return U8.create($.items.map((q) => H4(q)));
  else return $;
}
__name(H4, "H4");
var _y6 = class _y6 extends w6 {
  constructor() {
    super(...arguments);
    this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null) return this._cached;
    let $ = this._def.shape(), q = k6.objectKeys($);
    return this._cached = { shape: $, keys: q }, this._cached;
  }
  _parse($) {
    if (this._getType($) !== o$.object) {
      let J = this._getOrReturnCtx($);
      return t$(J, { code: p$.invalid_type, expected: o$.object, received: J.parsedType }), q6;
    }
    let { status: K, ctx: P } = this._processInputParams($), { shape: _, keys: Y } = this._getCached(), O = [];
    if (!(this._def.catchall instanceof B8 && this._def.unknownKeys === "strip")) {
      for (let J in P.data) if (!Y.includes(J)) O.push(J);
    }
    let z = [];
    for (let J of Y) {
      let T = _[J], X = P.data[J];
      z.push({ key: { status: "valid", value: J }, value: T._parse(new g8(P, X, P.path, J)), alwaysSet: J in P.data });
    }
    if (this._def.catchall instanceof B8) {
      let J = this._def.unknownKeys;
      if (J === "passthrough") for (let T of O) z.push({ key: { status: "valid", value: T }, value: { status: "valid", value: P.data[T] } });
      else if (J === "strict") {
        if (O.length > 0) t$(P, { code: p$.unrecognized_keys, keys: O }), K.dirty();
      } else if (J === "strip") ;
      else throw Error("Internal ZodObject error: invalid unknownKeys value.");
    } else {
      let J = this._def.catchall;
      for (let T of O) {
        let X = P.data[T];
        z.push({ key: { status: "valid", value: T }, value: J._parse(new g8(P, X, P.path, T)), alwaysSet: T in P.data });
      }
    }
    if (P.common.async) return Promise.resolve().then(async () => {
      let J = [];
      for (let T of z) {
        let X = await T.key, f = await T.value;
        J.push({ key: X, value: f, alwaysSet: T.alwaysSet });
      }
      return J;
    }).then((J) => {
      return Gq.mergeObjectSync(K, J);
    });
    else return Gq.mergeObjectSync(K, z);
  }
  get shape() {
    return this._def.shape();
  }
  strict($) {
    return s$.errToObj, new _y6({ ...this._def, unknownKeys: "strict", ...$ !== void 0 ? { errorMap: /* @__PURE__ */ __name((q, K) => {
      let P = this._def.errorMap?.(q, K).message ?? K.defaultError;
      if (q.code === "unrecognized_keys") return { message: s$.errToObj($).message ?? P };
      return { message: P };
    }, "errorMap") } : {} });
  }
  strip() {
    return new _y6({ ...this._def, unknownKeys: "strip" });
  }
  passthrough() {
    return new _y6({ ...this._def, unknownKeys: "passthrough" });
  }
  extend($) {
    return new _y6({ ...this._def, shape: /* @__PURE__ */ __name(() => ({ ...this._def.shape(), ...$ }), "shape") });
  }
  merge($) {
    return new _y6({ unknownKeys: $._def.unknownKeys, catchall: $._def.catchall, shape: /* @__PURE__ */ __name(() => ({ ...this._def.shape(), ...$._def.shape() }), "shape"), typeName: c$.ZodObject });
  }
  setKey($, q) {
    return this.augment({ [$]: q });
  }
  catchall($) {
    return new _y6({ ...this._def, catchall: $ });
  }
  pick($) {
    let q = {};
    for (let K of k6.objectKeys($)) if ($[K] && this.shape[K]) q[K] = this.shape[K];
    return new _y6({ ...this._def, shape: /* @__PURE__ */ __name(() => q, "shape") });
  }
  omit($) {
    let q = {};
    for (let K of k6.objectKeys(this.shape)) if (!$[K]) q[K] = this.shape[K];
    return new _y6({ ...this._def, shape: /* @__PURE__ */ __name(() => q, "shape") });
  }
  deepPartial() {
    return H4(this);
  }
  partial($) {
    let q = {};
    for (let K of k6.objectKeys(this.shape)) {
      let P = this.shape[K];
      if ($ && !$[K]) q[K] = P;
      else q[K] = P.optional();
    }
    return new _y6({ ...this._def, shape: /* @__PURE__ */ __name(() => q, "shape") });
  }
  required($) {
    let q = {};
    for (let K of k6.objectKeys(this.shape)) if ($ && !$[K]) q[K] = this.shape[K];
    else {
      let _ = this.shape[K];
      while (_ instanceof L8) _ = _._def.innerType;
      q[K] = _;
    }
    return new _y6({ ...this._def, shape: /* @__PURE__ */ __name(() => q, "shape") });
  }
  keyof() {
    return VA(k6.objectKeys(this.shape));
  }
};
__name(_y6, "y6");
var y6 = _y6;
y6.create = ($, q) => {
  return new y6({ shape: /* @__PURE__ */ __name(() => $, "shape"), unknownKeys: "strip", catchall: B8.create(), typeName: c$.ZodObject, ...z6(q) });
};
y6.strictCreate = ($, q) => {
  return new y6({ shape: /* @__PURE__ */ __name(() => $, "shape"), unknownKeys: "strict", catchall: B8.create(), typeName: c$.ZodObject, ...z6(q) });
};
y6.lazycreate = ($, q) => {
  return new y6({ shape: $, unknownKeys: "strip", catchall: B8.create(), typeName: c$.ZodObject, ...z6(q) });
};
var _Z4 = class _Z4 extends w6 {
  _parse($) {
    let { ctx: q } = this._processInputParams($), K = this._def.options;
    function P(_) {
      for (let O of _) if (O.result.status === "valid") return O.result;
      for (let O of _) if (O.result.status === "dirty") return q.common.issues.push(...O.ctx.common.issues), O.result;
      let Y = _.map((O) => new Qq(O.ctx.common.issues));
      return t$(q, { code: p$.invalid_union, unionErrors: Y }), q6;
    }
    __name(P, "P");
    if (q.common.async) return Promise.all(K.map(async (_) => {
      let Y = { ...q, common: { ...q.common, issues: [] }, parent: null };
      return { result: await _._parseAsync({ data: q.data, path: q.path, parent: Y }), ctx: Y };
    })).then(P);
    else {
      let _ = void 0, Y = [];
      for (let z of K) {
        let J = { ...q, common: { ...q.common, issues: [] }, parent: null }, T = z._parseSync({ data: q.data, path: q.path, parent: J });
        if (T.status === "valid") return T;
        else if (T.status === "dirty" && !_) _ = { result: T, ctx: J };
        if (J.common.issues.length) Y.push(J.common.issues);
      }
      if (_) return q.common.issues.push(..._.ctx.common.issues), _.result;
      let O = Y.map((z) => new Qq(z));
      return t$(q, { code: p$.invalid_union, unionErrors: O }), q6;
    }
  }
  get options() {
    return this._def.options;
  }
};
__name(_Z4, "Z4");
var Z4 = _Z4;
Z4.create = ($, q) => {
  return new Z4({ options: $, typeName: c$.ZodUnion, ...z6(q) });
};
var fK = /* @__PURE__ */ __name(($) => {
  if ($ instanceof A4) return fK($.schema);
  else if ($ instanceof b8) return fK($.innerType());
  else if ($ instanceof k4) return [$.value];
  else if ($ instanceof FK) return $.options;
  else if ($ instanceof G4) return k6.objectValues($.enum);
  else if ($ instanceof V4) return fK($._def.innerType);
  else if ($ instanceof w4) return [void 0];
  else if ($ instanceof f4) return [null];
  else if ($ instanceof L8) return [void 0, ...fK($.unwrap())];
  else if ($ instanceof ZK) return [null, ...fK($.unwrap())];
  else if ($ instanceof H5) return fK($.unwrap());
  else if ($ instanceof M4) return fK($.unwrap());
  else if ($ instanceof S4) return fK($._def.innerType);
  else return [];
}, "fK");
var _W5 = class _W5 extends w6 {
  _parse($) {
    let { ctx: q } = this._processInputParams($);
    if (q.parsedType !== o$.object) return t$(q, { code: p$.invalid_type, expected: o$.object, received: q.parsedType }), q6;
    let K = this.discriminator, P = q.data[K], _ = this.optionsMap.get(P);
    if (!_) return t$(q, { code: p$.invalid_union_discriminator, options: Array.from(this.optionsMap.keys()), path: [K] }), q6;
    if (q.common.async) return _._parseAsync({ data: q.data, path: q.path, parent: q });
    else return _._parseSync({ data: q.data, path: q.path, parent: q });
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  static create($, q, K) {
    let P = /* @__PURE__ */ new Map();
    for (let _ of q) {
      let Y = fK(_.shape[$]);
      if (!Y.length) throw Error(`A discriminator value for key \`${$}\` could not be extracted from all schema options`);
      for (let O of Y) {
        if (P.has(O)) throw Error(`Discriminator property ${String($)} has duplicate value ${String(O)}`);
        P.set(O, _);
      }
    }
    return new _W5({ typeName: c$.ZodDiscriminatedUnion, discriminator: $, options: q, optionsMap: P, ...z6(K) });
  }
};
__name(_W5, "W5");
var W5 = _W5;
function dv($, q) {
  let K = t8($), P = t8(q);
  if ($ === q) return { valid: true, data: $ };
  else if (K === o$.object && P === o$.object) {
    let _ = k6.objectKeys(q), Y = k6.objectKeys($).filter((z) => _.indexOf(z) !== -1), O = { ...$, ...q };
    for (let z of Y) {
      let J = dv($[z], q[z]);
      if (!J.valid) return { valid: false };
      O[z] = J.data;
    }
    return { valid: true, data: O };
  } else if (K === o$.array && P === o$.array) {
    if ($.length !== q.length) return { valid: false };
    let _ = [];
    for (let Y = 0; Y < $.length; Y++) {
      let O = $[Y], z = q[Y], J = dv(O, z);
      if (!J.valid) return { valid: false };
      _.push(J.data);
    }
    return { valid: true, data: _ };
  } else if (K === o$.date && P === o$.date && +$ === +q) return { valid: true, data: $ };
  else return { valid: false };
}
__name(dv, "dv");
var _X4 = class _X4 extends w6 {
  _parse($) {
    let { status: q, ctx: K } = this._processInputParams($), P = /* @__PURE__ */ __name((_, Y) => {
      if (v5(_) || v5(Y)) return q6;
      let O = dv(_.value, Y.value);
      if (!O.valid) return t$(K, { code: p$.invalid_intersection_types }), q6;
      if (z5(_) || z5(Y)) q.dirty();
      return { status: q.value, value: O.data };
    }, "P");
    if (K.common.async) return Promise.all([this._def.left._parseAsync({ data: K.data, path: K.path, parent: K }), this._def.right._parseAsync({ data: K.data, path: K.path, parent: K })]).then(([_, Y]) => P(_, Y));
    else return P(this._def.left._parseSync({ data: K.data, path: K.path, parent: K }), this._def.right._parseSync({ data: K.data, path: K.path, parent: K }));
  }
};
__name(_X4, "X4");
var X4 = _X4;
X4.create = ($, q, K) => {
  return new X4({ left: $, right: q, typeName: c$.ZodIntersection, ...z6(K) });
};
var _U8 = class _U8 extends w6 {
  _parse($) {
    let { status: q, ctx: K } = this._processInputParams($);
    if (K.parsedType !== o$.array) return t$(K, { code: p$.invalid_type, expected: o$.array, received: K.parsedType }), q6;
    if (K.data.length < this._def.items.length) return t$(K, { code: p$.too_small, minimum: this._def.items.length, inclusive: true, exact: false, type: "array" }), q6;
    if (!this._def.rest && K.data.length > this._def.items.length) t$(K, { code: p$.too_big, maximum: this._def.items.length, inclusive: true, exact: false, type: "array" }), q.dirty();
    let _ = [...K.data].map((Y, O) => {
      let z = this._def.items[O] || this._def.rest;
      if (!z) return null;
      return z._parse(new g8(K, Y, K.path, O));
    }).filter((Y) => !!Y);
    if (K.common.async) return Promise.all(_).then((Y) => {
      return Gq.mergeArray(q, Y);
    });
    else return Gq.mergeArray(q, _);
  }
  get items() {
    return this._def.items;
  }
  rest($) {
    return new _U8({ ...this._def, rest: $ });
  }
};
__name(_U8, "U8");
var U8 = _U8;
U8.create = ($, q) => {
  if (!Array.isArray($)) throw Error("You must pass an array of schemas to z.tuple([ ... ])");
  return new U8({ items: $, typeName: c$.ZodTuple, rest: null, ...z6(q) });
};
var _Z7 = class _Z7 extends w6 {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse($) {
    let { status: q, ctx: K } = this._processInputParams($);
    if (K.parsedType !== o$.object) return t$(K, { code: p$.invalid_type, expected: o$.object, received: K.parsedType }), q6;
    let P = [], _ = this._def.keyType, Y = this._def.valueType;
    for (let O in K.data) P.push({ key: _._parse(new g8(K, O, K.path, O)), value: Y._parse(new g8(K, K.data[O], K.path, O)), alwaysSet: O in K.data });
    if (K.common.async) return Gq.mergeObjectAsync(q, P);
    else return Gq.mergeObjectSync(q, P);
  }
  get element() {
    return this._def.valueType;
  }
  static create($, q, K) {
    if (q instanceof w6) return new _Z7({ keyType: $, valueType: q, typeName: c$.ZodRecord, ...z6(K) });
    return new _Z7({ keyType: I8.create(), valueType: $, typeName: c$.ZodRecord, ...z6(q) });
  }
};
__name(_Z7, "Z7");
var Z7 = _Z7;
var _X7 = class _X7 extends w6 {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse($) {
    let { status: q, ctx: K } = this._processInputParams($);
    if (K.parsedType !== o$.map) return t$(K, { code: p$.invalid_type, expected: o$.map, received: K.parsedType }), q6;
    let P = this._def.keyType, _ = this._def.valueType, Y = [...K.data.entries()].map(([O, z], J) => {
      return { key: P._parse(new g8(K, O, K.path, [J, "key"])), value: _._parse(new g8(K, z, K.path, [J, "value"])) };
    });
    if (K.common.async) {
      let O = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (let z of Y) {
          let J = await z.key, T = await z.value;
          if (J.status === "aborted" || T.status === "aborted") return q6;
          if (J.status === "dirty" || T.status === "dirty") q.dirty();
          O.set(J.value, T.value);
        }
        return { status: q.value, value: O };
      });
    } else {
      let O = /* @__PURE__ */ new Map();
      for (let z of Y) {
        let { key: J, value: T } = z;
        if (J.status === "aborted" || T.status === "aborted") return q6;
        if (J.status === "dirty" || T.status === "dirty") q.dirty();
        O.set(J.value, T.value);
      }
      return { status: q.value, value: O };
    }
  }
};
__name(_X7, "X7");
var X7 = _X7;
X7.create = ($, q, K) => {
  return new X7({ valueType: q, keyType: $, typeName: c$.ZodMap, ...z6(K) });
};
var _S_ = class _S_ extends w6 {
  _parse($) {
    let { status: q, ctx: K } = this._processInputParams($);
    if (K.parsedType !== o$.set) return t$(K, { code: p$.invalid_type, expected: o$.set, received: K.parsedType }), q6;
    let P = this._def;
    if (P.minSize !== null) {
      if (K.data.size < P.minSize.value) t$(K, { code: p$.too_small, minimum: P.minSize.value, type: "set", inclusive: true, exact: false, message: P.minSize.message }), q.dirty();
    }
    if (P.maxSize !== null) {
      if (K.data.size > P.maxSize.value) t$(K, { code: p$.too_big, maximum: P.maxSize.value, type: "set", inclusive: true, exact: false, message: P.maxSize.message }), q.dirty();
    }
    let _ = this._def.valueType;
    function Y(z) {
      let J = /* @__PURE__ */ new Set();
      for (let T of z) {
        if (T.status === "aborted") return q6;
        if (T.status === "dirty") q.dirty();
        J.add(T.value);
      }
      return { status: q.value, value: J };
    }
    __name(Y, "Y");
    let O = [...K.data.values()].map((z, J) => _._parse(new g8(K, z, K.path, J)));
    if (K.common.async) return Promise.all(O).then((z) => Y(z));
    else return Y(O);
  }
  min($, q) {
    return new _S_({ ...this._def, minSize: { value: $, message: s$.toString(q) } });
  }
  max($, q) {
    return new _S_({ ...this._def, maxSize: { value: $, message: s$.toString(q) } });
  }
  size($, q) {
    return this.min($, q).max($, q);
  }
  nonempty($) {
    return this.min(1, $);
  }
};
__name(_S_, "S_");
var S_ = _S_;
S_.create = ($, q) => {
  return new S_({ valueType: $, minSize: null, maxSize: null, typeName: c$.ZodSet, ...z6(q) });
};
var _J4 = class _J4 extends w6 {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse($) {
    let { ctx: q } = this._processInputParams($);
    if (q.parsedType !== o$.function) return t$(q, { code: p$.invalid_type, expected: o$.function, received: q.parsedType }), q6;
    function K(O, z) {
      return T7({ data: O, path: q.path, errorMaps: [q.common.contextualErrorMap, q.schemaErrorMap, z4(), wK].filter((J) => !!J), issueData: { code: p$.invalid_arguments, argumentsError: z } });
    }
    __name(K, "K");
    function P(O, z) {
      return T7({ data: O, path: q.path, errorMaps: [q.common.contextualErrorMap, q.schemaErrorMap, z4(), wK].filter((J) => !!J), issueData: { code: p$.invalid_return_type, returnTypeError: z } });
    }
    __name(P, "P");
    let _ = { errorMap: q.common.contextualErrorMap }, Y = q.data;
    if (this._def.returns instanceof M_) {
      let O = this;
      return Iq(async function(...z) {
        let J = new Qq([]), T = await O._def.args.parseAsync(z, _).catch((V) => {
          throw J.addIssue(K(z, V)), J;
        }), X = await Reflect.apply(Y, this, T);
        return await O._def.returns._def.type.parseAsync(X, _).catch((V) => {
          throw J.addIssue(P(X, V)), J;
        });
      });
    } else {
      let O = this;
      return Iq(function(...z) {
        let J = O._def.args.safeParse(z, _);
        if (!J.success) throw new Qq([K(z, J.error)]);
        let T = Reflect.apply(Y, this, J.data), X = O._def.returns.safeParse(T, _);
        if (!X.success) throw new Qq([P(T, X.error)]);
        return X.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...$) {
    return new _J4({ ...this._def, args: U8.create($).rest(tK.create()) });
  }
  returns($) {
    return new _J4({ ...this._def, returns: $ });
  }
  implement($) {
    return this.parse($);
  }
  strictImplement($) {
    return this.parse($);
  }
  static create($, q, K) {
    return new _J4({ args: $ ? $ : U8.create([]).rest(tK.create()), returns: q || tK.create(), typeName: c$.ZodFunction, ...z6(K) });
  }
};
__name(_J4, "J4");
var J4 = _J4;
var _A4 = class _A4 extends w6 {
  get schema() {
    return this._def.getter();
  }
  _parse($) {
    let { ctx: q } = this._processInputParams($);
    return this._def.getter()._parse({ data: q.data, path: q.path, parent: q });
  }
};
__name(_A4, "A4");
var A4 = _A4;
A4.create = ($, q) => {
  return new A4({ getter: $, typeName: c$.ZodLazy, ...z6(q) });
};
var _k4 = class _k4 extends w6 {
  _parse($) {
    if ($.data !== this._def.value) {
      let q = this._getOrReturnCtx($);
      return t$(q, { received: q.data, code: p$.invalid_literal, expected: this._def.value }), q6;
    }
    return { status: "valid", value: $.data };
  }
  get value() {
    return this._def.value;
  }
};
__name(_k4, "k4");
var k4 = _k4;
k4.create = ($, q) => {
  return new k4({ value: $, typeName: c$.ZodLiteral, ...z6(q) });
};
function VA($, q) {
  return new FK({ values: $, typeName: c$.ZodEnum, ...z6(q) });
}
__name(VA, "VA");
var _FK = class _FK extends w6 {
  _parse($) {
    if (typeof $.data !== "string") {
      let q = this._getOrReturnCtx($), K = this._def.values;
      return t$(q, { expected: k6.joinValues(K), received: q.parsedType, code: p$.invalid_type }), q6;
    }
    if (!this._cache) this._cache = new Set(this._def.values);
    if (!this._cache.has($.data)) {
      let q = this._getOrReturnCtx($), K = this._def.values;
      return t$(q, { received: q.data, code: p$.invalid_enum_value, options: K }), q6;
    }
    return Iq($.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    let $ = {};
    for (let q of this._def.values) $[q] = q;
    return $;
  }
  get Values() {
    let $ = {};
    for (let q of this._def.values) $[q] = q;
    return $;
  }
  get Enum() {
    let $ = {};
    for (let q of this._def.values) $[q] = q;
    return $;
  }
  extract($, q = this._def) {
    return _FK.create($, { ...this._def, ...q });
  }
  exclude($, q = this._def) {
    return _FK.create(this.options.filter((K) => !$.includes(K)), { ...this._def, ...q });
  }
};
__name(_FK, "FK");
var FK = _FK;
FK.create = VA;
var _G4 = class _G4 extends w6 {
  _parse($) {
    let q = k6.getValidEnumValues(this._def.values), K = this._getOrReturnCtx($);
    if (K.parsedType !== o$.string && K.parsedType !== o$.number) {
      let P = k6.objectValues(q);
      return t$(K, { expected: k6.joinValues(P), received: K.parsedType, code: p$.invalid_type }), q6;
    }
    if (!this._cache) this._cache = new Set(k6.getValidEnumValues(this._def.values));
    if (!this._cache.has($.data)) {
      let P = k6.objectValues(q);
      return t$(K, { received: K.data, code: p$.invalid_enum_value, options: P }), q6;
    }
    return Iq($.data);
  }
  get enum() {
    return this._def.values;
  }
};
__name(_G4, "G4");
var G4 = _G4;
G4.create = ($, q) => {
  return new G4({ values: $, typeName: c$.ZodNativeEnum, ...z6(q) });
};
var _M_ = class _M_ extends w6 {
  unwrap() {
    return this._def.type;
  }
  _parse($) {
    let { ctx: q } = this._processInputParams($);
    if (q.parsedType !== o$.promise && q.common.async === false) return t$(q, { code: p$.invalid_type, expected: o$.promise, received: q.parsedType }), q6;
    let K = q.parsedType === o$.promise ? q.data : Promise.resolve(q.data);
    return Iq(K.then((P) => {
      return this._def.type.parseAsync(P, { path: q.path, errorMap: q.common.contextualErrorMap });
    }));
  }
};
__name(_M_, "M_");
var M_ = _M_;
M_.create = ($, q) => {
  return new M_({ type: $, typeName: c$.ZodPromise, ...z6(q) });
};
var _b8 = class _b8 extends w6 {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === c$.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse($) {
    let { status: q, ctx: K } = this._processInputParams($), P = this._def.effect || null, _ = { addIssue: /* @__PURE__ */ __name((Y) => {
      if (t$(K, Y), Y.fatal) q.abort();
      else q.dirty();
    }, "addIssue"), get path() {
      return K.path;
    } };
    if (_.addIssue = _.addIssue.bind(_), P.type === "preprocess") {
      let Y = P.transform(K.data, _);
      if (K.common.async) return Promise.resolve(Y).then(async (O) => {
        if (q.value === "aborted") return q6;
        let z = await this._def.schema._parseAsync({ data: O, path: K.path, parent: K });
        if (z.status === "aborted") return q6;
        if (z.status === "dirty") return k_(z.value);
        if (q.value === "dirty") return k_(z.value);
        return z;
      });
      else {
        if (q.value === "aborted") return q6;
        let O = this._def.schema._parseSync({ data: Y, path: K.path, parent: K });
        if (O.status === "aborted") return q6;
        if (O.status === "dirty") return k_(O.value);
        if (q.value === "dirty") return k_(O.value);
        return O;
      }
    }
    if (P.type === "refinement") {
      let Y = /* @__PURE__ */ __name((O) => {
        let z = P.refinement(O, _);
        if (K.common.async) return Promise.resolve(z);
        if (z instanceof Promise) throw Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        return O;
      }, "Y");
      if (K.common.async === false) {
        let O = this._def.schema._parseSync({ data: K.data, path: K.path, parent: K });
        if (O.status === "aborted") return q6;
        if (O.status === "dirty") q.dirty();
        return Y(O.value), { status: q.value, value: O.value };
      } else return this._def.schema._parseAsync({ data: K.data, path: K.path, parent: K }).then((O) => {
        if (O.status === "aborted") return q6;
        if (O.status === "dirty") q.dirty();
        return Y(O.value).then(() => {
          return { status: q.value, value: O.value };
        });
      });
    }
    if (P.type === "transform") if (K.common.async === false) {
      let Y = this._def.schema._parseSync({ data: K.data, path: K.path, parent: K });
      if (!iK(Y)) return q6;
      let O = P.transform(Y.value, _);
      if (O instanceof Promise) throw Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
      return { status: q.value, value: O };
    } else return this._def.schema._parseAsync({ data: K.data, path: K.path, parent: K }).then((Y) => {
      if (!iK(Y)) return q6;
      return Promise.resolve(P.transform(Y.value, _)).then((O) => ({ status: q.value, value: O }));
    });
    k6.assertNever(P);
  }
};
__name(_b8, "b8");
var b8 = _b8;
b8.create = ($, q, K) => {
  return new b8({ schema: $, typeName: c$.ZodEffects, effect: q, ...z6(K) });
};
b8.createWithPreprocess = ($, q, K) => {
  return new b8({ schema: q, effect: { type: "preprocess", transform: $ }, typeName: c$.ZodEffects, ...z6(K) });
};
var _L8 = class _L8 extends w6 {
  _parse($) {
    if (this._getType($) === o$.undefined) return Iq(void 0);
    return this._def.innerType._parse($);
  }
  unwrap() {
    return this._def.innerType;
  }
};
__name(_L8, "L8");
var L8 = _L8;
L8.create = ($, q) => {
  return new L8({ innerType: $, typeName: c$.ZodOptional, ...z6(q) });
};
var _ZK = class _ZK extends w6 {
  _parse($) {
    if (this._getType($) === o$.null) return Iq(null);
    return this._def.innerType._parse($);
  }
  unwrap() {
    return this._def.innerType;
  }
};
__name(_ZK, "ZK");
var ZK = _ZK;
ZK.create = ($, q) => {
  return new ZK({ innerType: $, typeName: c$.ZodNullable, ...z6(q) });
};
var _V4 = class _V4 extends w6 {
  _parse($) {
    let { ctx: q } = this._processInputParams($), K = q.data;
    if (q.parsedType === o$.undefined) K = this._def.defaultValue();
    return this._def.innerType._parse({ data: K, path: q.path, parent: q });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
__name(_V4, "V4");
var V4 = _V4;
V4.create = ($, q) => {
  return new V4({ innerType: $, typeName: c$.ZodDefault, defaultValue: typeof q.default === "function" ? q.default : () => q.default, ...z6(q) });
};
var _S4 = class _S4 extends w6 {
  _parse($) {
    let { ctx: q } = this._processInputParams($), K = { ...q, common: { ...q.common, issues: [] } }, P = this._def.innerType._parse({ data: K.data, path: K.path, parent: { ...K } });
    if (W4(P)) return P.then((_) => {
      return { status: "valid", value: _.status === "valid" ? _.value : this._def.catchValue({ get error() {
        return new Qq(K.common.issues);
      }, input: K.data }) };
    });
    else return { status: "valid", value: P.status === "valid" ? P.value : this._def.catchValue({ get error() {
      return new Qq(K.common.issues);
    }, input: K.data }) };
  }
  removeCatch() {
    return this._def.innerType;
  }
};
__name(_S4, "S4");
var S4 = _S4;
S4.create = ($, q) => {
  return new S4({ innerType: $, typeName: c$.ZodCatch, catchValue: typeof q.catch === "function" ? q.catch : () => q.catch, ...z6(q) });
};
var _A7 = class _A7 extends w6 {
  _parse($) {
    if (this._getType($) !== o$.nan) {
      let K = this._getOrReturnCtx($);
      return t$(K, { code: p$.invalid_type, expected: o$.nan, received: K.parsedType }), q6;
    }
    return { status: "valid", value: $.data };
  }
};
__name(_A7, "A7");
var A7 = _A7;
A7.create = ($) => {
  return new A7({ typeName: c$.ZodNaN, ...z6($) });
};
var jg = Symbol("zod_brand");
var _H5 = class _H5 extends w6 {
  _parse($) {
    let { ctx: q } = this._processInputParams($), K = q.data;
    return this._def.type._parse({ data: K, path: q.path, parent: q });
  }
  unwrap() {
    return this._def.type;
  }
};
__name(_H5, "H5");
var H5 = _H5;
var _k7 = class _k7 extends w6 {
  _parse($) {
    let { status: q, ctx: K } = this._processInputParams($);
    if (K.common.async) return (async () => {
      let _ = await this._def.in._parseAsync({ data: K.data, path: K.path, parent: K });
      if (_.status === "aborted") return q6;
      if (_.status === "dirty") return q.dirty(), k_(_.value);
      else return this._def.out._parseAsync({ data: _.value, path: K.path, parent: K });
    })();
    else {
      let P = this._def.in._parseSync({ data: K.data, path: K.path, parent: K });
      if (P.status === "aborted") return q6;
      if (P.status === "dirty") return q.dirty(), { status: "dirty", value: P.value };
      else return this._def.out._parseSync({ data: P.value, path: K.path, parent: K });
    }
  }
  static create($, q) {
    return new _k7({ in: $, out: q, typeName: c$.ZodPipeline });
  }
};
__name(_k7, "k7");
var k7 = _k7;
var _M4 = class _M4 extends w6 {
  _parse($) {
    let q = this._def.innerType._parse($), K = /* @__PURE__ */ __name((P) => {
      if (iK(P)) P.value = Object.freeze(P.value);
      return P;
    }, "K");
    return W4(q) ? q.then((P) => K(P)) : K(q);
  }
  unwrap() {
    return this._def.innerType;
  }
};
__name(_M4, "M4");
var M4 = _M4;
M4.create = ($, q) => {
  return new M4({ innerType: $, typeName: c$.ZodReadonly, ...z6(q) });
};
function XA($, q) {
  let K = typeof $ === "function" ? $(q) : typeof $ === "string" ? { message: $ } : $;
  return typeof K === "string" ? { message: K } : K;
}
__name(XA, "XA");
function SA($, q = {}, K) {
  if ($) return V_.create().superRefine((P, _) => {
    let Y = $(P);
    if (Y instanceof Promise) return Y.then((O) => {
      if (!O) {
        let z = XA(q, P), J = z.fatal ?? K ?? true;
        _.addIssue({ code: "custom", ...z, fatal: J });
      }
    });
    if (!Y) {
      let O = XA(q, P), z = O.fatal ?? K ?? true;
      _.addIssue({ code: "custom", ...O, fatal: z });
    }
    return;
  });
  return V_.create();
}
__name(SA, "SA");
var vg = { object: y6.lazycreate };
var c$;
(function($) {
  $.ZodString = "ZodString", $.ZodNumber = "ZodNumber", $.ZodNaN = "ZodNaN", $.ZodBigInt = "ZodBigInt", $.ZodBoolean = "ZodBoolean", $.ZodDate = "ZodDate", $.ZodSymbol = "ZodSymbol", $.ZodUndefined = "ZodUndefined", $.ZodNull = "ZodNull", $.ZodAny = "ZodAny", $.ZodUnknown = "ZodUnknown", $.ZodNever = "ZodNever", $.ZodVoid = "ZodVoid", $.ZodArray = "ZodArray", $.ZodObject = "ZodObject", $.ZodUnion = "ZodUnion", $.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", $.ZodIntersection = "ZodIntersection", $.ZodTuple = "ZodTuple", $.ZodRecord = "ZodRecord", $.ZodMap = "ZodMap", $.ZodSet = "ZodSet", $.ZodFunction = "ZodFunction", $.ZodLazy = "ZodLazy", $.ZodLiteral = "ZodLiteral", $.ZodEnum = "ZodEnum", $.ZodEffects = "ZodEffects", $.ZodNativeEnum = "ZodNativeEnum", $.ZodOptional = "ZodOptional", $.ZodNullable = "ZodNullable", $.ZodDefault = "ZodDefault", $.ZodCatch = "ZodCatch", $.ZodPromise = "ZodPromise", $.ZodBranded = "ZodBranded", $.ZodPipeline = "ZodPipeline", $.ZodReadonly = "ZodReadonly";
})(c$ || (c$ = {}));
var zg = /* @__PURE__ */ __name(($, q = { message: `Input not instance of ${$.name}` }) => SA((K) => K instanceof $, q), "zg");
var MA = I8.create;
var NA = BK.create;
var Wg = A7.create;
var Hg = UK.create;
var CA = T4.create;
var Jg = G_.create;
var Tg = w7.create;
var wg = w4.create;
var fg = f4.create;
var Zg = V_.create;
var Xg = tK.create;
var Ag = B8.create;
var kg = f7.create;
var Gg = D8.create;
var Vg = y6.create;
var Sg = y6.strictCreate;
var Mg = Z4.create;
var Ng = W5.create;
var Cg = X4.create;
var hg = U8.create;
var Eg = Z7.create;
var Rg = X7.create;
var Ig = S_.create;
var Dg = J4.create;
var Lg = A4.create;
var gg = k4.create;
var bg = FK.create;
var yg = G4.create;
var ug = M_.create;
var xg = b8.create;
var pg = L8.create;
var cg = ZK.create;
var mg = b8.createWithPreprocess;
var dg = k7.create;
var lg = /* @__PURE__ */ __name(() => MA().optional(), "lg");
var rg = /* @__PURE__ */ __name(() => NA().optional(), "rg");
var og = /* @__PURE__ */ __name(() => CA().optional(), "og");
var ng = { string: /* @__PURE__ */ __name(($) => I8.create({ ...$, coerce: true }), "string"), number: /* @__PURE__ */ __name(($) => BK.create({ ...$, coerce: true }), "number"), boolean: /* @__PURE__ */ __name(($) => T4.create({ ...$, coerce: true }), "boolean"), bigint: /* @__PURE__ */ __name(($) => UK.create({ ...$, coerce: true }), "bigint"), date: /* @__PURE__ */ __name(($) => G_.create({ ...$, coerce: true }), "date") };
var ig = q6;
function lv($, q) {
  let K = { type: "array" };
  if ($.type?._def && $.type?._def?.typeName !== c$.ZodAny) K.items = K6($.type._def, { ...q, currentPath: [...q.currentPath, "items"] });
  if ($.minLength) G6(K, "minItems", $.minLength.value, $.minLength.message, q);
  if ($.maxLength) G6(K, "maxItems", $.maxLength.value, $.maxLength.message, q);
  if ($.exactLength) G6(K, "minItems", $.exactLength.value, $.exactLength.message, q), G6(K, "maxItems", $.exactLength.value, $.exactLength.message, q);
  return K;
}
__name(lv, "lv");
function rv($, q) {
  let K = { type: "integer", format: "int64" };
  if (!$.checks) return K;
  for (let P of $.checks) switch (P.kind) {
    case "min":
      if (q.target === "jsonSchema7") if (P.inclusive) G6(K, "minimum", P.value, P.message, q);
      else G6(K, "exclusiveMinimum", P.value, P.message, q);
      else {
        if (!P.inclusive) K.exclusiveMinimum = true;
        G6(K, "minimum", P.value, P.message, q);
      }
      break;
    case "max":
      if (q.target === "jsonSchema7") if (P.inclusive) G6(K, "maximum", P.value, P.message, q);
      else G6(K, "exclusiveMaximum", P.value, P.message, q);
      else {
        if (!P.inclusive) K.exclusiveMaximum = true;
        G6(K, "maximum", P.value, P.message, q);
      }
      break;
    case "multipleOf":
      G6(K, "multipleOf", P.value, P.message, q);
      break;
  }
  return K;
}
__name(rv, "rv");
function ov() {
  return { type: "boolean" };
}
__name(ov, "ov");
function G7($, q) {
  return K6($.type._def, q);
}
__name(G7, "G7");
var nv = /* @__PURE__ */ __name(($, q) => {
  return K6($.innerType._def, q);
}, "nv");
function J5($, q, K) {
  let P = K ?? q.dateStrategy;
  if (Array.isArray(P)) return { anyOf: P.map((_) => J5($, q, _)) };
  switch (P) {
    case "string":
    case "format:date-time":
      return { type: "string", format: "date-time" };
    case "format:date":
      return { type: "string", format: "date" };
    case "integer":
      return tg($, q);
  }
}
__name(J5, "J5");
var tg = /* @__PURE__ */ __name(($, q) => {
  let K = { type: "integer", format: "unix-time" };
  if (q.target === "openApi3") return K;
  for (let P of $.checks) switch (P.kind) {
    case "min":
      G6(K, "minimum", P.value, P.message, q);
      break;
    case "max":
      G6(K, "maximum", P.value, P.message, q);
      break;
  }
  return K;
}, "tg");
function iv($, q) {
  return { ...K6($.innerType._def, q), default: $.defaultValue() };
}
__name(iv, "iv");
function tv($, q) {
  return q.effectStrategy === "input" ? K6($.schema._def, q) : D6(q);
}
__name(tv, "tv");
function Bv($) {
  return { type: "string", enum: Array.from($.values) };
}
__name(Bv, "Bv");
var Bg = /* @__PURE__ */ __name(($) => {
  if ("type" in $ && $.type === "string") return false;
  return "allOf" in $;
}, "Bg");
function Uv($, q) {
  let K = [K6($.left._def, { ...q, currentPath: [...q.currentPath, "allOf", "0"] }), K6($.right._def, { ...q, currentPath: [...q.currentPath, "allOf", "1"] })].filter((Y) => !!Y), P = q.target === "jsonSchema2019-09" ? { unevaluatedProperties: false } : void 0, _ = [];
  return K.forEach((Y) => {
    if (Bg(Y)) {
      if (_.push(...Y.allOf), Y.unevaluatedProperties === void 0) P = void 0;
    } else {
      let O = Y;
      if ("additionalProperties" in Y && Y.additionalProperties === false) {
        let { additionalProperties: z, ...J } = Y;
        O = J;
      } else P = void 0;
      _.push(O);
    }
  }), _.length ? { allOf: _, ...P } : void 0;
}
__name(Uv, "Uv");
function Fv($, q) {
  let K = typeof $.value;
  if (K !== "bigint" && K !== "number" && K !== "boolean" && K !== "string") return { type: Array.isArray($.value) ? "array" : "object" };
  if (q.target === "openApi3") return { type: K === "bigint" ? "integer" : K, enum: [$.value] };
  return { type: K === "bigint" ? "integer" : K, const: $.value };
}
__name(Fv, "Fv");
var av = void 0;
var A8 = { cuid: /^[cC][^\s-]{8,}$/, cuid2: /^[0-9a-z]+$/, ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/, email: /^(?!\.)(?!.*\.\.)([a-zA-Z0-9_'+\-\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\-]*\.)+[a-zA-Z]{2,}$/, emoji: /* @__PURE__ */ __name(() => {
  if (av === void 0) av = RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", "u");
  return av;
}, "emoji"), uuid: /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/, ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/, ipv4Cidr: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/, ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/, ipv6Cidr: /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/, base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/, base64url: /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/, nanoid: /^[a-zA-Z0-9_-]{21}$/, jwt: /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/ };
function V7($, q) {
  let K = { type: "string" };
  if ($.checks) for (let P of $.checks) switch (P.kind) {
    case "min":
      G6(K, "minLength", typeof K.minLength === "number" ? Math.max(K.minLength, P.value) : P.value, P.message, q);
      break;
    case "max":
      G6(K, "maxLength", typeof K.maxLength === "number" ? Math.min(K.maxLength, P.value) : P.value, P.message, q);
      break;
    case "email":
      switch (q.emailStrategy) {
        case "format:email":
          y8(K, "email", P.message, q);
          break;
        case "format:idn-email":
          y8(K, "idn-email", P.message, q);
          break;
        case "pattern:zod":
          xq(K, A8.email, P.message, q);
          break;
      }
      break;
    case "url":
      y8(K, "uri", P.message, q);
      break;
    case "uuid":
      y8(K, "uuid", P.message, q);
      break;
    case "regex":
      xq(K, P.regex, P.message, q);
      break;
    case "cuid":
      xq(K, A8.cuid, P.message, q);
      break;
    case "cuid2":
      xq(K, A8.cuid2, P.message, q);
      break;
    case "startsWith":
      xq(K, RegExp(`^${Qv(P.value, q)}`), P.message, q);
      break;
    case "endsWith":
      xq(K, RegExp(`${Qv(P.value, q)}$`), P.message, q);
      break;
    case "datetime":
      y8(K, "date-time", P.message, q);
      break;
    case "date":
      y8(K, "date", P.message, q);
      break;
    case "time":
      y8(K, "time", P.message, q);
      break;
    case "duration":
      y8(K, "duration", P.message, q);
      break;
    case "length":
      G6(K, "minLength", typeof K.minLength === "number" ? Math.max(K.minLength, P.value) : P.value, P.message, q), G6(K, "maxLength", typeof K.maxLength === "number" ? Math.min(K.maxLength, P.value) : P.value, P.message, q);
      break;
    case "includes":
      xq(K, RegExp(Qv(P.value, q)), P.message, q);
      break;
    case "ip":
      if (P.version !== "v6") y8(K, "ipv4", P.message, q);
      if (P.version !== "v4") y8(K, "ipv6", P.message, q);
      break;
    case "base64url":
      xq(K, A8.base64url, P.message, q);
      break;
    case "jwt":
      xq(K, A8.jwt, P.message, q);
      break;
    case "cidr":
      if (P.version !== "v6") xq(K, A8.ipv4Cidr, P.message, q);
      if (P.version !== "v4") xq(K, A8.ipv6Cidr, P.message, q);
      break;
    case "emoji":
      xq(K, A8.emoji(), P.message, q);
      break;
    case "ulid":
      xq(K, A8.ulid, P.message, q);
      break;
    case "base64":
      switch (q.base64Strategy) {
        case "format:binary":
          y8(K, "binary", P.message, q);
          break;
        case "contentEncoding:base64":
          G6(K, "contentEncoding", "base64", P.message, q);
          break;
        case "pattern:zod":
          xq(K, A8.base64, P.message, q);
          break;
      }
      break;
    case "nanoid":
      xq(K, A8.nanoid, P.message, q);
      break;
    case "toLowerCase":
    case "toUpperCase":
    case "trim":
      break;
    default:
      /* @__PURE__ */ ((_) => {
      })(P);
  }
  return K;
}
__name(V7, "V7");
function Qv($, q) {
  return q.patternStrategy === "escape" ? Fg($) : $;
}
__name(Qv, "Qv");
var Ug = new Set("ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789");
function Fg($) {
  let q = "";
  for (let K = 0; K < $.length; K++) {
    if (!Ug.has($[K])) q += "\\";
    q += $[K];
  }
  return q;
}
__name(Fg, "Fg");
function y8($, q, K, P) {
  if ($.format || $.anyOf?.some((_) => _.format)) {
    if (!$.anyOf) $.anyOf = [];
    if ($.format) {
      if ($.anyOf.push({ format: $.format, ...$.errorMessage && P.errorMessages && { errorMessage: { format: $.errorMessage.format } } }), delete $.format, $.errorMessage) {
        if (delete $.errorMessage.format, Object.keys($.errorMessage).length === 0) delete $.errorMessage;
      }
    }
    $.anyOf.push({ format: q, ...K && P.errorMessages && { errorMessage: { format: K } } });
  } else G6($, "format", q, K, P);
}
__name(y8, "y8");
function xq($, q, K, P) {
  if ($.pattern || $.allOf?.some((_) => _.pattern)) {
    if (!$.allOf) $.allOf = [];
    if ($.pattern) {
      if ($.allOf.push({ pattern: $.pattern, ...$.errorMessage && P.errorMessages && { errorMessage: { pattern: $.errorMessage.pattern } } }), delete $.pattern, $.errorMessage) {
        if (delete $.errorMessage.pattern, Object.keys($.errorMessage).length === 0) delete $.errorMessage;
      }
    }
    $.allOf.push({ pattern: hA(q, P), ...K && P.errorMessages && { errorMessage: { pattern: K } } });
  } else G6($, "pattern", hA(q, P), K, P);
}
__name(xq, "xq");
function hA($, q) {
  if (!q.applyRegexFlags || !$.flags) return $.source;
  let K = { i: $.flags.includes("i"), m: $.flags.includes("m"), s: $.flags.includes("s") }, P = K.i ? $.source.toLowerCase() : $.source, _ = "", Y = false, O = false, z = false;
  for (let J = 0; J < P.length; J++) {
    if (Y) {
      _ += P[J], Y = false;
      continue;
    }
    if (K.i) {
      if (O) {
        if (P[J].match(/[a-z]/)) {
          if (z) _ += P[J], _ += `${P[J - 2]}-${P[J]}`.toUpperCase(), z = false;
          else if (P[J + 1] === "-" && P[J + 2]?.match(/[a-z]/)) _ += P[J], z = true;
          else _ += `${P[J]}${P[J].toUpperCase()}`;
          continue;
        }
      } else if (P[J].match(/[a-z]/)) {
        _ += `[${P[J]}${P[J].toUpperCase()}]`;
        continue;
      }
    }
    if (K.m) {
      if (P[J] === "^") {
        _ += `(^|(?<=[\r
]))`;
        continue;
      } else if (P[J] === "$") {
        _ += `($|(?=[\r
]))`;
        continue;
      }
    }
    if (K.s && P[J] === ".") {
      _ += O ? `${P[J]}\r
` : `[${P[J]}\r
]`;
      continue;
    }
    if (_ += P[J], P[J] === "\\") Y = true;
    else if (O && P[J] === "]") O = false;
    else if (!O && P[J] === "[") O = true;
  }
  try {
    new RegExp(_);
  } catch {
    return console.warn(`Could not convert regex pattern at ${q.currentPath.join("/")} to a flag-independent form! Falling back to the flag-ignorant source`), $.source;
  }
  return _;
}
__name(hA, "hA");
function S7($, q) {
  if (q.target === "openAi") console.warn("Warning: OpenAI may not support records in schemas! Try an array of key-value pairs instead.");
  if (q.target === "openApi3" && $.keyType?._def.typeName === c$.ZodEnum) return { type: "object", required: $.keyType._def.values, properties: $.keyType._def.values.reduce((P, _) => ({ ...P, [_]: K6($.valueType._def, { ...q, currentPath: [...q.currentPath, "properties", _] }) ?? D6(q) }), {}), additionalProperties: q.rejectedAdditionalProperties };
  let K = { type: "object", additionalProperties: K6($.valueType._def, { ...q, currentPath: [...q.currentPath, "additionalProperties"] }) ?? q.allowedAdditionalProperties };
  if (q.target === "openApi3") return K;
  if ($.keyType?._def.typeName === c$.ZodString && $.keyType._def.checks?.length) {
    let { type: P, ..._ } = V7($.keyType._def, q);
    return { ...K, propertyNames: _ };
  } else if ($.keyType?._def.typeName === c$.ZodEnum) return { ...K, propertyNames: { enum: $.keyType._def.values } };
  else if ($.keyType?._def.typeName === c$.ZodBranded && $.keyType._def.type._def.typeName === c$.ZodString && $.keyType._def.type._def.checks?.length) {
    let { type: P, ..._ } = G7($.keyType._def, q);
    return { ...K, propertyNames: _ };
  }
  return K;
}
__name(S7, "S7");
function ev($, q) {
  if (q.mapStrategy === "record") return S7($, q);
  let K = K6($.keyType._def, { ...q, currentPath: [...q.currentPath, "items", "items", "0"] }) || D6(q), P = K6($.valueType._def, { ...q, currentPath: [...q.currentPath, "items", "items", "1"] }) || D6(q);
  return { type: "array", maxItems: 125, items: { type: "array", items: [K, P], minItems: 2, maxItems: 2 } };
}
__name(ev, "ev");
function sv($) {
  let q = $.values, P = Object.keys($.values).filter((Y) => {
    return typeof q[q[Y]] !== "number";
  }).map((Y) => q[Y]), _ = Array.from(new Set(P.map((Y) => typeof Y)));
  return { type: _.length === 1 ? _[0] === "string" ? "string" : "number" : ["string", "number"], enum: P };
}
__name(sv, "sv");
function $z($) {
  return $.target === "openAi" ? void 0 : { not: D6({ ...$, currentPath: [...$.currentPath, "not"] }) };
}
__name($z, "$z");
function qz($) {
  return $.target === "openApi3" ? { enum: ["null"], nullable: true } : { type: "null" };
}
__name(qz, "qz");
var N4 = { ZodString: "string", ZodNumber: "number", ZodBigInt: "integer", ZodBoolean: "boolean", ZodNull: "null" };
function Kz($, q) {
  if (q.target === "openApi3") return EA($, q);
  let K = $.options instanceof Map ? Array.from($.options.values()) : $.options;
  if (K.every((P) => P._def.typeName in N4 && (!P._def.checks || !P._def.checks.length))) {
    let P = K.reduce((_, Y) => {
      let O = N4[Y._def.typeName];
      return O && !_.includes(O) ? [..._, O] : _;
    }, []);
    return { type: P.length > 1 ? P : P[0] };
  } else if (K.every((P) => P._def.typeName === "ZodLiteral" && !P.description)) {
    let P = K.reduce((_, Y) => {
      let O = typeof Y._def.value;
      switch (O) {
        case "string":
        case "number":
        case "boolean":
          return [..._, O];
        case "bigint":
          return [..._, "integer"];
        case "object":
          if (Y._def.value === null) return [..._, "null"];
          return _;
        case "symbol":
        case "undefined":
        case "function":
        default:
          return _;
      }
    }, []);
    if (P.length === K.length) {
      let _ = P.filter((Y, O, z) => z.indexOf(Y) === O);
      return { type: _.length > 1 ? _ : _[0], enum: K.reduce((Y, O) => {
        return Y.includes(O._def.value) ? Y : [...Y, O._def.value];
      }, []) };
    }
  } else if (K.every((P) => P._def.typeName === "ZodEnum")) return { type: "string", enum: K.reduce((P, _) => [...P, ..._._def.values.filter((Y) => !P.includes(Y))], []) };
  return EA($, q);
}
__name(Kz, "Kz");
var EA = /* @__PURE__ */ __name(($, q) => {
  let K = ($.options instanceof Map ? Array.from($.options.values()) : $.options).map((P, _) => K6(P._def, { ...q, currentPath: [...q.currentPath, "anyOf", `${_}`] })).filter((P) => !!P && (!q.strictUnions || typeof P === "object" && Object.keys(P).length > 0));
  return K.length ? { anyOf: K } : void 0;
}, "EA");
function _z($, q) {
  if (["ZodString", "ZodNumber", "ZodBigInt", "ZodBoolean", "ZodNull"].includes($.innerType._def.typeName) && (!$.innerType._def.checks || !$.innerType._def.checks.length)) {
    if (q.target === "openApi3") return { type: N4[$.innerType._def.typeName], nullable: true };
    return { type: [N4[$.innerType._def.typeName], "null"] };
  }
  if (q.target === "openApi3") {
    let P = K6($.innerType._def, { ...q, currentPath: [...q.currentPath] });
    if (P && "$ref" in P) return { allOf: [P], nullable: true };
    return P && { ...P, nullable: true };
  }
  let K = K6($.innerType._def, { ...q, currentPath: [...q.currentPath, "anyOf", "0"] });
  return K && { anyOf: [K, { type: "null" }] };
}
__name(_z, "_z");
function Pz($, q) {
  let K = { type: "number" };
  if (!$.checks) return K;
  for (let P of $.checks) switch (P.kind) {
    case "int":
      K.type = "integer", j5(K, "type", P.message, q);
      break;
    case "min":
      if (q.target === "jsonSchema7") if (P.inclusive) G6(K, "minimum", P.value, P.message, q);
      else G6(K, "exclusiveMinimum", P.value, P.message, q);
      else {
        if (!P.inclusive) K.exclusiveMinimum = true;
        G6(K, "minimum", P.value, P.message, q);
      }
      break;
    case "max":
      if (q.target === "jsonSchema7") if (P.inclusive) G6(K, "maximum", P.value, P.message, q);
      else G6(K, "exclusiveMaximum", P.value, P.message, q);
      else {
        if (!P.inclusive) K.exclusiveMaximum = true;
        G6(K, "maximum", P.value, P.message, q);
      }
      break;
    case "multipleOf":
      G6(K, "multipleOf", P.value, P.message, q);
      break;
  }
  return K;
}
__name(Pz, "Pz");
function Oz($, q) {
  let K = q.target === "openAi", P = { type: "object", properties: {} }, _ = [], Y = $.shape();
  for (let z in Y) {
    let J = Y[z];
    if (J === void 0 || J._def === void 0) continue;
    let T = Qg(J);
    if (T && K) {
      if (J._def.typeName === "ZodOptional") J = J._def.innerType;
      if (!J.isNullable()) J = J.nullable();
      T = false;
    }
    let X = K6(J._def, { ...q, currentPath: [...q.currentPath, "properties", z], propertyPath: [...q.currentPath, "properties", z] });
    if (X === void 0) continue;
    if (P.properties[z] = X, !T) _.push(z);
  }
  if (_.length) P.required = _;
  let O = ag($, q);
  if (O !== void 0) P.additionalProperties = O;
  return P;
}
__name(Oz, "Oz");
function ag($, q) {
  if ($.catchall._def.typeName !== "ZodNever") return K6($.catchall._def, { ...q, currentPath: [...q.currentPath, "additionalProperties"] });
  switch ($.unknownKeys) {
    case "passthrough":
      return q.allowedAdditionalProperties;
    case "strict":
      return q.rejectedAdditionalProperties;
    case "strip":
      return q.removeAdditionalStrategy === "strict" ? q.allowedAdditionalProperties : q.rejectedAdditionalProperties;
  }
}
__name(ag, "ag");
function Qg($) {
  try {
    return $.isOptional();
  } catch {
    return true;
  }
}
__name(Qg, "Qg");
var Yz = /* @__PURE__ */ __name(($, q) => {
  if (q.currentPath.toString() === q.propertyPath?.toString()) return K6($.innerType._def, q);
  let K = K6($.innerType._def, { ...q, currentPath: [...q.currentPath, "anyOf", "1"] });
  return K ? { anyOf: [{ not: D6(q) }, K] } : D6(q);
}, "Yz");
var jz = /* @__PURE__ */ __name(($, q) => {
  if (q.pipeStrategy === "input") return K6($.in._def, q);
  else if (q.pipeStrategy === "output") return K6($.out._def, q);
  let K = K6($.in._def, { ...q, currentPath: [...q.currentPath, "allOf", "0"] }), P = K6($.out._def, { ...q, currentPath: [...q.currentPath, "allOf", K ? "1" : "0"] });
  return { allOf: [K, P].filter((_) => _ !== void 0) };
}, "jz");
function vz($, q) {
  return K6($.type._def, q);
}
__name(vz, "vz");
function zz($, q) {
  let P = { type: "array", uniqueItems: true, items: K6($.valueType._def, { ...q, currentPath: [...q.currentPath, "items"] }) };
  if ($.minSize) G6(P, "minItems", $.minSize.value, $.minSize.message, q);
  if ($.maxSize) G6(P, "maxItems", $.maxSize.value, $.maxSize.message, q);
  return P;
}
__name(zz, "zz");
function Wz($, q) {
  if ($.rest) return { type: "array", minItems: $.items.length, items: $.items.map((K, P) => K6(K._def, { ...q, currentPath: [...q.currentPath, "items", `${P}`] })).reduce((K, P) => P === void 0 ? K : [...K, P], []), additionalItems: K6($.rest._def, { ...q, currentPath: [...q.currentPath, "additionalItems"] }) };
  else return { type: "array", minItems: $.items.length, maxItems: $.items.length, items: $.items.map((K, P) => K6(K._def, { ...q, currentPath: [...q.currentPath, "items", `${P}`] })).reduce((K, P) => P === void 0 ? K : [...K, P], []) };
}
__name(Wz, "Wz");
function Hz($) {
  return { not: D6($) };
}
__name(Hz, "Hz");
function Jz($) {
  return D6($);
}
__name(Jz, "Jz");
var Tz = /* @__PURE__ */ __name(($, q) => {
  return K6($.innerType._def, q);
}, "Tz");
var wz = /* @__PURE__ */ __name(($, q, K) => {
  switch (q) {
    case c$.ZodString:
      return V7($, K);
    case c$.ZodNumber:
      return Pz($, K);
    case c$.ZodObject:
      return Oz($, K);
    case c$.ZodBigInt:
      return rv($, K);
    case c$.ZodBoolean:
      return ov();
    case c$.ZodDate:
      return J5($, K);
    case c$.ZodUndefined:
      return Hz(K);
    case c$.ZodNull:
      return qz(K);
    case c$.ZodArray:
      return lv($, K);
    case c$.ZodUnion:
    case c$.ZodDiscriminatedUnion:
      return Kz($, K);
    case c$.ZodIntersection:
      return Uv($, K);
    case c$.ZodTuple:
      return Wz($, K);
    case c$.ZodRecord:
      return S7($, K);
    case c$.ZodLiteral:
      return Fv($, K);
    case c$.ZodEnum:
      return Bv($);
    case c$.ZodNativeEnum:
      return sv($);
    case c$.ZodNullable:
      return _z($, K);
    case c$.ZodOptional:
      return Yz($, K);
    case c$.ZodMap:
      return ev($, K);
    case c$.ZodSet:
      return zz($, K);
    case c$.ZodLazy:
      return () => $.getter()._def;
    case c$.ZodPromise:
      return vz($, K);
    case c$.ZodNaN:
    case c$.ZodNever:
      return $z(K);
    case c$.ZodEffects:
      return tv($, K);
    case c$.ZodAny:
      return D6(K);
    case c$.ZodUnknown:
      return Jz(K);
    case c$.ZodDefault:
      return iv($, K);
    case c$.ZodBranded:
      return G7($, K);
    case c$.ZodReadonly:
      return Tz($, K);
    case c$.ZodCatch:
      return nv($, K);
    case c$.ZodPipeline:
      return jz($, K);
    case c$.ZodFunction:
    case c$.ZodVoid:
    case c$.ZodSymbol:
      return;
    default:
      return /* @__PURE__ */ ((P) => {
        return;
      })(q);
  }
}, "wz");
function K6($, q, K = false) {
  let P = q.seen.get($);
  if (q.override) {
    let z = q.override?.($, q, P, K);
    if (z !== uv) return z;
  }
  if (P && !K) {
    let z = eg(P, q);
    if (z !== void 0) return z;
  }
  let _ = { def: $, path: q.currentPath, jsonSchema: void 0 };
  q.seen.set($, _);
  let Y = wz($, $.typeName, q), O = typeof Y === "function" ? K6(Y(), q) : Y;
  if (O) sg($, q, O);
  if (q.postProcess) {
    let z = q.postProcess(O, $, q);
    return _.jsonSchema = O, z;
  }
  return _.jsonSchema = O, O;
}
__name(K6, "K6");
var eg = /* @__PURE__ */ __name(($, q) => {
  switch (q.$refStrategy) {
    case "root":
      return { $ref: $.path.join("/") };
    case "relative":
      return { $ref: J7(q.currentPath, $.path) };
    case "none":
    case "seen":
      if ($.path.length < q.currentPath.length && $.path.every((K, P) => q.currentPath[P] === K)) return console.warn(`Recursive reference detected at ${q.currentPath.join("/")}! Defaulting to any`), D6(q);
      return q.$refStrategy === "seen" ? D6(q) : void 0;
  }
}, "eg");
var sg = /* @__PURE__ */ __name(($, q, K) => {
  if ($.description) {
    if (K.description = $.description, q.markdownDescription) K.markdownDescription = $.description;
  }
  return K;
}, "sg");
var fz = /* @__PURE__ */ __name(($, q) => {
  let K = pv(q), P = typeof q === "object" && q.definitions ? Object.entries(q.definitions).reduce((J, [T, X]) => ({ ...J, [T]: K6(X._def, { ...K, currentPath: [...K.basePath, K.definitionPath, T] }, true) ?? D6(K) }), {}) : void 0, _ = typeof q === "string" ? q : q?.nameStrategy === "title" ? void 0 : q?.name, Y = K6($._def, _ === void 0 ? K : { ...K, currentPath: [...K.basePath, K.definitionPath, _] }, false) ?? D6(K), O = typeof q === "object" && q.name !== void 0 && q.nameStrategy === "title" ? q.name : void 0;
  if (O !== void 0) Y.title = O;
  if (K.flags.hasReferencedOpenAiAnyType) {
    if (!P) P = {};
    if (!P[K.openAiAnyTypeName]) P[K.openAiAnyTypeName] = { type: ["string", "number", "integer", "boolean", "array", "null"], items: { $ref: K.$refStrategy === "relative" ? "1" : [...K.basePath, K.definitionPath, K.openAiAnyTypeName].join("/") } };
  }
  let z = _ === void 0 ? P ? { ...Y, [K.definitionPath]: P } : Y : { $ref: [...K.$refStrategy === "relative" ? [] : K.basePath, K.definitionPath, _].join("/"), [K.definitionPath]: { ...P, [_]: Y } };
  if (K.target === "jsonSchema7") z.$schema = "http://json-schema.org/draft-07/schema#";
  else if (K.target === "jsonSchema2019-09" || K.target === "openAi") z.$schema = "https://json-schema.org/draft/2019-09/schema#";
  if (K.target === "openAi" && ("anyOf" in z || "oneOf" in z || "allOf" in z || "type" in z && Array.isArray(z.type))) console.warn("Warning: OpenAI may not support schemas with unions as roots! Try wrapping it in an object property.");
  return z;
}, "fz");
function aK($, q) {
  let K = typeof $;
  if (K !== typeof q) return false;
  if (Array.isArray($)) {
    if (!Array.isArray(q)) return false;
    let P = $.length;
    if (P !== q.length) return false;
    for (let _ = 0; _ < P; _++) if (!aK($[_], q[_])) return false;
    return true;
  }
  if (K === "object") {
    if (!$ || !q) return $ === q;
    let P = Object.keys($), _ = Object.keys(q);
    if (P.length !== _.length) return false;
    for (let O of P) if (!aK($[O], q[O])) return false;
    return true;
  }
  return $ === q;
}
__name(aK, "aK");
function j8($) {
  return encodeURI($b($));
}
__name(j8, "j8");
function $b($) {
  return $.replace(/~/g, "~0").replace(/\//g, "~1");
}
__name($b, "$b");
var qb = { prefixItems: true, items: true, allOf: true, anyOf: true, oneOf: true };
var Kb = { $defs: true, definitions: true, properties: true, patternProperties: true, dependentSchemas: true };
var _b = { id: true, $id: true, $ref: true, $schema: true, $anchor: true, $vocabulary: true, $comment: true, default: true, enum: true, const: true, required: true, type: true, maximum: true, minimum: true, exclusiveMaximum: true, exclusiveMinimum: true, multipleOf: true, maxLength: true, minLength: true, pattern: true, format: true, maxItems: true, minItems: true, uniqueItems: true, maxProperties: true, minProperties: true };
var Pb = typeof self < "u" && self.location && self.location.origin !== "null" ? new URL(self.location.origin + self.location.pathname + location.search) : new URL("https://github.com/cfworker");
function u8($, q = /* @__PURE__ */ Object.create(null), K = Pb, P = "") {
  if ($ && typeof $ === "object" && !Array.isArray($)) {
    let Y = $.$id || $.id;
    if (Y) {
      let O = new URL(Y, K.href);
      if (O.hash.length > 1) q[O.href] = $;
      else if (O.hash = "", P === "") K = O;
      else u8($, q, K);
    }
  } else if ($ !== true && $ !== false) return q;
  let _ = K.href + (P ? "#" + P : "");
  if (q[_] !== void 0) throw Error(`Duplicate schema URI "${_}".`);
  if (q[_] = $, $ === true || $ === false) return q;
  if ($.__absolute_uri__ === void 0) Object.defineProperty($, "__absolute_uri__", { enumerable: false, value: _ });
  if ($.$ref && $.__absolute_ref__ === void 0) {
    let Y = new URL($.$ref, K.href);
    Y.hash = Y.hash, Object.defineProperty($, "__absolute_ref__", { enumerable: false, value: Y.href });
  }
  if ($.$recursiveRef && $.__absolute_recursive_ref__ === void 0) {
    let Y = new URL($.$recursiveRef, K.href);
    Y.hash = Y.hash, Object.defineProperty($, "__absolute_recursive_ref__", { enumerable: false, value: Y.href });
  }
  if ($.$anchor) {
    let Y = new URL("#" + $.$anchor, K.href);
    q[Y.href] = $;
  }
  for (let Y in $) {
    if (_b[Y]) continue;
    let O = `${P}/${j8(Y)}`, z = $[Y];
    if (Array.isArray(z)) {
      if (qb[Y]) {
        let J = z.length;
        for (let T = 0; T < J; T++) u8(z[T], q, K, `${O}/${T}`);
      }
    } else if (Kb[Y]) for (let J in z) u8(z[J], q, K, `${O}/${j8(J)}`);
    else u8(z, q, K, O);
  }
  return q;
}
__name(u8, "u8");
var Ob = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
var Yb = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
var jb = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d(?::?\d\d)?)?$/i;
var vb = /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i;
var zb = /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
var Wb = /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i;
var Hb = /^(?:(?:https?|ftp):\/\/)(?:\S+(?::\S*)?@)?(?:(?!10(?:\.\d{1,3}){3})(?!127(?:\.\d{1,3}){3})(?!169\.254(?:\.\d{1,3}){2})(?!192\.168(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z\u{00a1}-\u{ffff}0-9]+-?)*[a-z\u{00a1}-\u{ffff}0-9]+)(?:\.(?:[a-z\u{00a1}-\u{ffff}0-9]+-?)*[a-z\u{00a1}-\u{ffff}0-9]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu;
var Jb = /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i;
var Tb = /^(?:\/(?:[^~/]|~0|~1)*)*$/;
var wb = /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i;
var fb = /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/;
var Zb = /* @__PURE__ */ __name(($) => {
  if ($[0] === '"') return false;
  let [q, K, ...P] = $.split("@");
  if (!q || !K || P.length !== 0 || q.length > 64 || K.length > 253) return false;
  if (q[0] === "." || q.endsWith(".") || q.includes("..")) return false;
  if (!/^[a-z0-9.-]+$/i.test(K) || !/^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+$/i.test(q)) return false;
  return K.split(".").every((_) => /^[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?$/i.test(_));
}, "Zb");
var Xb = /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/;
var Ab = /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i;
var kb = /* @__PURE__ */ __name(($) => $.length > 1 && $.length < 80 && (/^P\d+([.,]\d+)?W$/.test($) || /^P[\dYMDTHS]*(\d[.,]\d+)?[YMDHS]$/.test($) && /^P([.,\d]+Y)?([.,\d]+M)?([.,\d]+D)?(T([.,\d]+H)?([.,\d]+M)?([.,\d]+S)?)?$/.test($)), "kb");
function F8($) {
  return $.test.bind($);
}
__name(F8, "F8");
var Zz = { date: RA, time: IA.bind(void 0, false), "date-time": Sb, duration: kb, uri: Cb, "uri-reference": F8(zb), "uri-template": F8(Wb), url: F8(Hb), email: Zb, hostname: F8(vb), ipv4: F8(Xb), ipv6: F8(Ab), regex: Eb, uuid: F8(Jb), "json-pointer": F8(Tb), "json-pointer-uri-fragment": F8(wb), "relative-json-pointer": F8(fb) };
function Gb($) {
  return $ % 4 === 0 && ($ % 100 !== 0 || $ % 400 === 0);
}
__name(Gb, "Gb");
function RA($) {
  let q = $.match(Ob);
  if (!q) return false;
  let K = +q[1], P = +q[2], _ = +q[3];
  return P >= 1 && P <= 12 && _ >= 1 && _ <= (P == 2 && Gb(K) ? 29 : Yb[P]);
}
__name(RA, "RA");
function IA($, q) {
  let K = q.match(jb);
  if (!K) return false;
  let P = +K[1], _ = +K[2], Y = +K[3], O = !!K[5];
  return (P <= 23 && _ <= 59 && Y <= 59 || P == 23 && _ == 59 && Y == 60) && (!$ || O);
}
__name(IA, "IA");
var Vb = /t|\s/i;
function Sb($) {
  let q = $.split(Vb);
  return q.length == 2 && RA(q[0]) && IA(true, q[1]);
}
__name(Sb, "Sb");
var Mb = /\/|:/;
var Nb = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
function Cb($) {
  return Mb.test($) && Nb.test($);
}
__name(Cb, "Cb");
var hb = /[^\\]\\Z/;
function Eb($) {
  if (hb.test($)) return false;
  try {
    return new RegExp($, "u"), true;
  } catch (q) {
    return false;
  }
}
__name(Eb, "Eb");
function DA($) {
  let q = 0, K = $.length, P = 0, _;
  while (P < K) if (q++, _ = $.charCodeAt(P++), _ >= 55296 && _ <= 56319 && P < K) {
    if (_ = $.charCodeAt(P), (_ & 64512) == 56320) P++;
  }
  return q;
}
__name(DA, "DA");
function b6($, q, K = "2019-09", P = u8(q), _ = true, Y = null, O = "#", z = "#", J = /* @__PURE__ */ Object.create(null)) {
  if (q === true) return { valid: true, errors: [] };
  if (q === false) return { valid: false, errors: [{ instanceLocation: O, keyword: "false", keywordLocation: O, error: "False boolean schema." }] };
  let T = typeof $, X;
  switch (T) {
    case "boolean":
    case "number":
    case "string":
      X = T;
      break;
    case "object":
      if ($ === null) X = "null";
      else if (Array.isArray($)) X = "array";
      else X = "object";
      break;
    default:
      throw Error(`Instances of "${T}" type are not supported.`);
  }
  let { $ref: f, $recursiveRef: V, $recursiveAnchor: M, type: N, const: E, enum: h, required: I, not: D, anyOf: g, allOf: b, oneOf: y, if: p, then: n, else: s, format: q$, properties: c, patternProperties: U, additionalProperties: j, unevaluatedProperties: H, minProperties: Z, maxProperties: W, propertyNames: w, dependentRequired: G, dependentSchemas: S, dependencies: A, prefixItems: v, items: k, additionalItems: R, unevaluatedItems: C, contains: L, minContains: x, maxContains: l, minItems: a, maxItems: f$, uniqueItems: $$, minimum: t, maximum: H$, exclusiveMinimum: Q, exclusiveMaximum: v$, multipleOf: B$, minLength: m, maxLength: r, pattern: J$, __absolute_ref__: e, __absolute_recursive_ref__: _$2 } = q, Y$ = [];
  if (M === true && Y === null) Y = q;
  if (V === "#") {
    let o = Y === null ? P[_$2] : Y, W$ = `${z}/$recursiveRef`, B = b6($, Y === null ? q : Y, K, P, _, o, O, W$, J);
    if (!B.valid) Y$.push({ instanceLocation: O, keyword: "$recursiveRef", keywordLocation: W$, error: "A subschema had errors." }, ...B.errors);
  }
  if (f !== void 0) {
    let W$ = P[e || f];
    if (W$ === void 0) {
      let X$ = `Unresolved $ref "${f}".`;
      if (e && e !== f) X$ += `  Absolute URI "${e}".`;
      throw X$ += `
Known schemas:
- ${Object.keys(P).join(`
- `)}`, Error(X$);
    }
    let B = `${z}/$ref`, F = b6($, W$, K, P, _, Y, O, B, J);
    if (!F.valid) Y$.push({ instanceLocation: O, keyword: "$ref", keywordLocation: B, error: "A subschema had errors." }, ...F.errors);
    if (K === "4" || K === "7") return { valid: Y$.length === 0, errors: Y$ };
  }
  if (Array.isArray(N)) {
    let o = N.length, W$ = false;
    for (let B = 0; B < o; B++) if (X === N[B] || N[B] === "integer" && X === "number" && $ % 1 === 0 && $ === $) {
      W$ = true;
      break;
    }
    if (!W$) Y$.push({ instanceLocation: O, keyword: "type", keywordLocation: `${z}/type`, error: `Instance type "${X}" is invalid. Expected "${N.join('", "')}".` });
  } else if (N === "integer") {
    if (X !== "number" || $ % 1 || $ !== $) Y$.push({ instanceLocation: O, keyword: "type", keywordLocation: `${z}/type`, error: `Instance type "${X}" is invalid. Expected "${N}".` });
  } else if (N !== void 0 && X !== N) Y$.push({ instanceLocation: O, keyword: "type", keywordLocation: `${z}/type`, error: `Instance type "${X}" is invalid. Expected "${N}".` });
  if (E !== void 0) {
    if (X === "object" || X === "array") {
      if (!aK($, E)) Y$.push({ instanceLocation: O, keyword: "const", keywordLocation: `${z}/const`, error: `Instance does not match ${JSON.stringify(E)}.` });
    } else if ($ !== E) Y$.push({ instanceLocation: O, keyword: "const", keywordLocation: `${z}/const`, error: `Instance does not match ${JSON.stringify(E)}.` });
  }
  if (h !== void 0) {
    if (X === "object" || X === "array") {
      if (!h.some((o) => aK($, o))) Y$.push({ instanceLocation: O, keyword: "enum", keywordLocation: `${z}/enum`, error: `Instance does not match any of ${JSON.stringify(h)}.` });
    } else if (!h.some((o) => $ === o)) Y$.push({ instanceLocation: O, keyword: "enum", keywordLocation: `${z}/enum`, error: `Instance does not match any of ${JSON.stringify(h)}.` });
  }
  if (D !== void 0) {
    let o = `${z}/not`;
    if (b6($, D, K, P, _, Y, O, o).valid) Y$.push({ instanceLocation: O, keyword: "not", keywordLocation: o, error: 'Instance matched "not" schema.' });
  }
  let d = [];
  if (g !== void 0) {
    let o = `${z}/anyOf`, W$ = Y$.length, B = false;
    for (let F = 0; F < g.length; F++) {
      let X$ = g[F], z$ = Object.create(J), j$ = b6($, X$, K, P, _, M === true ? Y : null, O, `${o}/${F}`, z$);
      if (Y$.push(...j$.errors), B = B || j$.valid, j$.valid) d.push(z$);
    }
    if (B) Y$.length = W$;
    else Y$.splice(W$, 0, { instanceLocation: O, keyword: "anyOf", keywordLocation: o, error: "Instance does not match any subschemas." });
  }
  if (b !== void 0) {
    let o = `${z}/allOf`, W$ = Y$.length, B = true;
    for (let F = 0; F < b.length; F++) {
      let X$ = b[F], z$ = Object.create(J), j$ = b6($, X$, K, P, _, M === true ? Y : null, O, `${o}/${F}`, z$);
      if (Y$.push(...j$.errors), B = B && j$.valid, j$.valid) d.push(z$);
    }
    if (B) Y$.length = W$;
    else Y$.splice(W$, 0, { instanceLocation: O, keyword: "allOf", keywordLocation: o, error: "Instance does not match every subschema." });
  }
  if (y !== void 0) {
    let o = `${z}/oneOf`, W$ = Y$.length, B = y.filter((F, X$) => {
      let z$ = Object.create(J), j$ = b6($, F, K, P, _, M === true ? Y : null, O, `${o}/${X$}`, z$);
      if (Y$.push(...j$.errors), j$.valid) d.push(z$);
      return j$.valid;
    }).length;
    if (B === 1) Y$.length = W$;
    else Y$.splice(W$, 0, { instanceLocation: O, keyword: "oneOf", keywordLocation: o, error: `Instance does not match exactly one subschema (${B} matches).` });
  }
  if (X === "object" || X === "array") Object.assign(J, ...d);
  if (p !== void 0) {
    let o = `${z}/if`;
    if (b6($, p, K, P, _, Y, O, o, J).valid) {
      if (n !== void 0) {
        let B = b6($, n, K, P, _, Y, O, `${z}/then`, J);
        if (!B.valid) Y$.push({ instanceLocation: O, keyword: "if", keywordLocation: o, error: 'Instance does not match "then" schema.' }, ...B.errors);
      }
    } else if (s !== void 0) {
      let B = b6($, s, K, P, _, Y, O, `${z}/else`, J);
      if (!B.valid) Y$.push({ instanceLocation: O, keyword: "if", keywordLocation: o, error: 'Instance does not match "else" schema.' }, ...B.errors);
    }
  }
  if (X === "object") {
    if (I !== void 0) {
      for (let F of I) if (!(F in $)) Y$.push({ instanceLocation: O, keyword: "required", keywordLocation: `${z}/required`, error: `Instance does not have required property "${F}".` });
    }
    let o = Object.keys($);
    if (Z !== void 0 && o.length < Z) Y$.push({ instanceLocation: O, keyword: "minProperties", keywordLocation: `${z}/minProperties`, error: `Instance does not have at least ${Z} properties.` });
    if (W !== void 0 && o.length > W) Y$.push({ instanceLocation: O, keyword: "maxProperties", keywordLocation: `${z}/maxProperties`, error: `Instance does not have at least ${W} properties.` });
    if (w !== void 0) {
      let F = `${z}/propertyNames`;
      for (let X$ in $) {
        let z$ = `${O}/${j8(X$)}`, j$ = b6(X$, w, K, P, _, Y, z$, F);
        if (!j$.valid) Y$.push({ instanceLocation: O, keyword: "propertyNames", keywordLocation: F, error: `Property name "${X$}" does not match schema.` }, ...j$.errors);
      }
    }
    if (G !== void 0) {
      let F = `${z}/dependantRequired`;
      for (let X$ in G) if (X$ in $) {
        let z$ = G[X$];
        for (let j$ of z$) if (!(j$ in $)) Y$.push({ instanceLocation: O, keyword: "dependentRequired", keywordLocation: F, error: `Instance has "${X$}" but does not have "${j$}".` });
      }
    }
    if (S !== void 0) for (let F in S) {
      let X$ = `${z}/dependentSchemas`;
      if (F in $) {
        let z$ = b6($, S[F], K, P, _, Y, O, `${X$}/${j8(F)}`, J);
        if (!z$.valid) Y$.push({ instanceLocation: O, keyword: "dependentSchemas", keywordLocation: X$, error: `Instance has "${F}" but does not match dependant schema.` }, ...z$.errors);
      }
    }
    if (A !== void 0) {
      let F = `${z}/dependencies`;
      for (let X$ in A) if (X$ in $) {
        let z$ = A[X$];
        if (Array.isArray(z$)) {
          for (let j$ of z$) if (!(j$ in $)) Y$.push({ instanceLocation: O, keyword: "dependencies", keywordLocation: F, error: `Instance has "${X$}" but does not have "${j$}".` });
        } else {
          let j$ = b6($, z$, K, P, _, Y, O, `${F}/${j8(X$)}`);
          if (!j$.valid) Y$.push({ instanceLocation: O, keyword: "dependencies", keywordLocation: F, error: `Instance has "${X$}" but does not match dependant schema.` }, ...j$.errors);
        }
      }
    }
    let W$ = /* @__PURE__ */ Object.create(null), B = false;
    if (c !== void 0) {
      let F = `${z}/properties`;
      for (let X$ in c) {
        if (!(X$ in $)) continue;
        let z$ = `${O}/${j8(X$)}`, j$ = b6($[X$], c[X$], K, P, _, Y, z$, `${F}/${j8(X$)}`);
        if (j$.valid) J[X$] = W$[X$] = true;
        else if (B = _, Y$.push({ instanceLocation: O, keyword: "properties", keywordLocation: F, error: `Property "${X$}" does not match schema.` }, ...j$.errors), B) break;
      }
    }
    if (!B && U !== void 0) {
      let F = `${z}/patternProperties`;
      for (let X$ in U) {
        let z$ = new RegExp(X$, "u"), j$ = U[X$];
        for (let X6 in $) {
          if (!z$.test(X6)) continue;
          let Z$ = `${O}/${j8(X6)}`, A$ = b6($[X6], j$, K, P, _, Y, Z$, `${F}/${j8(X$)}`);
          if (A$.valid) J[X6] = W$[X6] = true;
          else B = _, Y$.push({ instanceLocation: O, keyword: "patternProperties", keywordLocation: F, error: `Property "${X6}" matches pattern "${X$}" but does not match associated schema.` }, ...A$.errors);
        }
      }
    }
    if (!B && j !== void 0) {
      let F = `${z}/additionalProperties`;
      for (let X$ in $) {
        if (W$[X$]) continue;
        let z$ = `${O}/${j8(X$)}`, j$ = b6($[X$], j, K, P, _, Y, z$, F);
        if (j$.valid) J[X$] = true;
        else B = _, Y$.push({ instanceLocation: O, keyword: "additionalProperties", keywordLocation: F, error: `Property "${X$}" does not match additional properties schema.` }, ...j$.errors);
      }
    } else if (!B && H !== void 0) {
      let F = `${z}/unevaluatedProperties`;
      for (let X$ in $) if (!J[X$]) {
        let z$ = `${O}/${j8(X$)}`, j$ = b6($[X$], H, K, P, _, Y, z$, F);
        if (j$.valid) J[X$] = true;
        else Y$.push({ instanceLocation: O, keyword: "unevaluatedProperties", keywordLocation: F, error: `Property "${X$}" does not match unevaluated properties schema.` }, ...j$.errors);
      }
    }
  } else if (X === "array") {
    if (f$ !== void 0 && $.length > f$) Y$.push({ instanceLocation: O, keyword: "maxItems", keywordLocation: `${z}/maxItems`, error: `Array has too many items (${$.length} > ${f$}).` });
    if (a !== void 0 && $.length < a) Y$.push({ instanceLocation: O, keyword: "minItems", keywordLocation: `${z}/minItems`, error: `Array has too few items (${$.length} < ${a}).` });
    let o = $.length, W$ = 0, B = false;
    if (v !== void 0) {
      let F = `${z}/prefixItems`, X$ = Math.min(v.length, o);
      for (; W$ < X$; W$++) {
        let z$ = b6($[W$], v[W$], K, P, _, Y, `${O}/${W$}`, `${F}/${W$}`);
        if (J[W$] = true, !z$.valid) {
          if (B = _, Y$.push({ instanceLocation: O, keyword: "prefixItems", keywordLocation: F, error: "Items did not match schema." }, ...z$.errors), B) break;
        }
      }
    }
    if (k !== void 0) {
      let F = `${z}/items`;
      if (Array.isArray(k)) {
        let X$ = Math.min(k.length, o);
        for (; W$ < X$; W$++) {
          let z$ = b6($[W$], k[W$], K, P, _, Y, `${O}/${W$}`, `${F}/${W$}`);
          if (J[W$] = true, !z$.valid) {
            if (B = _, Y$.push({ instanceLocation: O, keyword: "items", keywordLocation: F, error: "Items did not match schema." }, ...z$.errors), B) break;
          }
        }
      } else for (; W$ < o; W$++) {
        let X$ = b6($[W$], k, K, P, _, Y, `${O}/${W$}`, F);
        if (J[W$] = true, !X$.valid) {
          if (B = _, Y$.push({ instanceLocation: O, keyword: "items", keywordLocation: F, error: "Items did not match schema." }, ...X$.errors), B) break;
        }
      }
      if (!B && R !== void 0) {
        let X$ = `${z}/additionalItems`;
        for (; W$ < o; W$++) {
          let z$ = b6($[W$], R, K, P, _, Y, `${O}/${W$}`, X$);
          if (J[W$] = true, !z$.valid) B = _, Y$.push({ instanceLocation: O, keyword: "additionalItems", keywordLocation: X$, error: "Items did not match additional items schema." }, ...z$.errors);
        }
      }
    }
    if (L !== void 0) if (o === 0 && x === void 0) Y$.push({ instanceLocation: O, keyword: "contains", keywordLocation: `${z}/contains`, error: "Array is empty. It must contain at least one item matching the schema." });
    else if (x !== void 0 && o < x) Y$.push({ instanceLocation: O, keyword: "minContains", keywordLocation: `${z}/minContains`, error: `Array has less items (${o}) than minContains (${x}).` });
    else {
      let F = `${z}/contains`, X$ = Y$.length, z$ = 0;
      for (let j$ = 0; j$ < o; j$++) {
        let X6 = b6($[j$], L, K, P, _, Y, `${O}/${j$}`, F);
        if (X6.valid) J[j$] = true, z$++;
        else Y$.push(...X6.errors);
      }
      if (z$ >= (x || 0)) Y$.length = X$;
      if (x === void 0 && l === void 0 && z$ === 0) Y$.splice(X$, 0, { instanceLocation: O, keyword: "contains", keywordLocation: F, error: "Array does not contain item matching schema." });
      else if (x !== void 0 && z$ < x) Y$.push({ instanceLocation: O, keyword: "minContains", keywordLocation: `${z}/minContains`, error: `Array must contain at least ${x} items matching schema. Only ${z$} items were found.` });
      else if (l !== void 0 && z$ > l) Y$.push({ instanceLocation: O, keyword: "maxContains", keywordLocation: `${z}/maxContains`, error: `Array may contain at most ${l} items matching schema. ${z$} items were found.` });
    }
    if (!B && C !== void 0) {
      let F = `${z}/unevaluatedItems`;
      for (W$; W$ < o; W$++) {
        if (J[W$]) continue;
        let X$ = b6($[W$], C, K, P, _, Y, `${O}/${W$}`, F);
        if (J[W$] = true, !X$.valid) Y$.push({ instanceLocation: O, keyword: "unevaluatedItems", keywordLocation: F, error: "Items did not match unevaluated items schema." }, ...X$.errors);
      }
    }
    if ($$) for (let F = 0; F < o; F++) {
      let X$ = $[F], z$ = typeof X$ === "object" && X$ !== null;
      for (let j$ = 0; j$ < o; j$++) {
        if (F === j$) continue;
        let X6 = $[j$];
        if (X$ === X6 || z$ && (typeof X6 === "object" && X6 !== null) && aK(X$, X6)) Y$.push({ instanceLocation: O, keyword: "uniqueItems", keywordLocation: `${z}/uniqueItems`, error: `Duplicate items at indexes ${F} and ${j$}.` }), F = Number.MAX_SAFE_INTEGER, j$ = Number.MAX_SAFE_INTEGER;
      }
    }
  } else if (X === "number") {
    if (K === "4") {
      if (t !== void 0 && (Q === true && $ <= t || $ < t)) Y$.push({ instanceLocation: O, keyword: "minimum", keywordLocation: `${z}/minimum`, error: `${$} is less than ${Q ? "or equal to " : ""} ${t}.` });
      if (H$ !== void 0 && (v$ === true && $ >= H$ || $ > H$)) Y$.push({ instanceLocation: O, keyword: "maximum", keywordLocation: `${z}/maximum`, error: `${$} is greater than ${v$ ? "or equal to " : ""} ${H$}.` });
    } else {
      if (t !== void 0 && $ < t) Y$.push({ instanceLocation: O, keyword: "minimum", keywordLocation: `${z}/minimum`, error: `${$} is less than ${t}.` });
      if (H$ !== void 0 && $ > H$) Y$.push({ instanceLocation: O, keyword: "maximum", keywordLocation: `${z}/maximum`, error: `${$} is greater than ${H$}.` });
      if (Q !== void 0 && $ <= Q) Y$.push({ instanceLocation: O, keyword: "exclusiveMinimum", keywordLocation: `${z}/exclusiveMinimum`, error: `${$} is less than ${Q}.` });
      if (v$ !== void 0 && $ >= v$) Y$.push({ instanceLocation: O, keyword: "exclusiveMaximum", keywordLocation: `${z}/exclusiveMaximum`, error: `${$} is greater than or equal to ${v$}.` });
    }
    if (B$ !== void 0) {
      let o = $ % B$;
      if (Math.abs(0 - o) >= 11920929e-14 && Math.abs(B$ - o) >= 11920929e-14) Y$.push({ instanceLocation: O, keyword: "multipleOf", keywordLocation: `${z}/multipleOf`, error: `${$} is not a multiple of ${B$}.` });
    }
  } else if (X === "string") {
    let o = m === void 0 && r === void 0 ? 0 : DA($);
    if (m !== void 0 && o < m) Y$.push({ instanceLocation: O, keyword: "minLength", keywordLocation: `${z}/minLength`, error: `String is too short (${o} < ${m}).` });
    if (r !== void 0 && o > r) Y$.push({ instanceLocation: O, keyword: "maxLength", keywordLocation: `${z}/maxLength`, error: `String is too long (${o} > ${r}).` });
    if (J$ !== void 0 && !new RegExp(J$, "u").test($)) Y$.push({ instanceLocation: O, keyword: "pattern", keywordLocation: `${z}/pattern`, error: "String does not match pattern." });
    if (q$ !== void 0 && Zz[q$] && !Zz[q$]($)) Y$.push({ instanceLocation: O, keyword: "format", keywordLocation: `${z}/format`, error: `String does not match format "${q$}".` });
  }
  return { valid: Y$.length === 0, errors: Y$ };
}
__name(b6, "b6");
var _Xz = class _Xz {
  schema;
  draft;
  shortCircuit;
  lookup;
  constructor($, q = "2019-09", K = true) {
    this.schema = $, this.draft = q, this.shortCircuit = K, this.lookup = u8($);
  }
  validate($) {
    return b6($, this.schema, this.draft, this.lookup, this.shortCircuit);
  }
  addSchema($, q) {
    if (q) $ = { ...$, $id: q };
    u8($, this.lookup);
  }
};
__name(_Xz, "Xz");
var Xz = _Xz;
var Rb = {};
Z6(Rb, { Validator: /* @__PURE__ */ __name(() => Xz, "Validator"), deepCompareStrict: /* @__PURE__ */ __name(() => aK, "deepCompareStrict"), toJsonSchema: /* @__PURE__ */ __name(() => Az, "toJsonSchema"), validatesOnlyStrings: /* @__PURE__ */ __name(() => T5, "validatesOnlyStrings") });
function Az($) {
  if (i8($)) {
    let q = JA($, true);
    if (v4(q)) {
      let K = Y5(q, true);
      return j4(K);
    } else return j4($);
  }
  if (TK($)) return fz($);
  return $;
}
__name(Az, "Az");
function T5($) {
  if (!$ || typeof $ !== "object" || Object.keys($).length === 0 || Array.isArray($)) return false;
  if ("type" in $) {
    if (typeof $.type === "string") return $.type === "string";
    if (Array.isArray($.type)) return $.type.every((q) => q === "string");
    return false;
  }
  if ("enum" in $) return Array.isArray($.enum) && $.enum.length > 0 && $.enum.every((q) => typeof q === "string");
  if ("const" in $) return typeof $.const === "string";
  if ("allOf" in $ && Array.isArray($.allOf)) return $.allOf.some((q) => T5(q));
  if ("anyOf" in $ && Array.isArray($.anyOf) || "oneOf" in $ && Array.isArray($.oneOf)) {
    let q = "anyOf" in $ ? $.anyOf : $.oneOf;
    return q.length > 0 && q.every((K) => T5(K));
  }
  if ("not" in $) return false;
  if ("$ref" in $ && typeof $.$ref === "string") {
    let q = $.$ref, K = u8($);
    if (K[q]) return T5(K[q]);
    return false;
  }
  return false;
}
__name(T5, "T5");
var Ib = {};
Z6(Ib, { Graph: /* @__PURE__ */ __name(() => w5, "Graph") });
function Db($, q) {
  if ($ !== void 0 && !l_($)) return $;
  else if (hP(q)) try {
    let K = q.getName();
    return K = K.startsWith("Runnable") ? K.slice(8) : K, K;
  } catch {
    return q.getName();
  }
  else return q.name ?? "UnknownSchema";
}
__name(Db, "Db");
function Lb($) {
  if (hP($.data)) return { type: "runnable", data: { id: $.data.lc_id, name: $.data.getName() } };
  else return { type: "schema", data: { ...Az($.data.schema), title: $.data.name } };
}
__name(Lb, "Lb");
var _a35;
var w5 = (_a35 = class {
  nodes = {};
  edges = [];
  constructor(q) {
    this.nodes = q?.nodes ?? this.nodes, this.edges = q?.edges ?? this.edges;
  }
  toJSON() {
    let q = {};
    return Object.values(this.nodes).forEach((K, P) => {
      q[K.id] = l_(K.id) ? P : K.id;
    }), { nodes: Object.values(this.nodes).map((K) => ({ id: q[K.id], ...Lb(K) })), edges: this.edges.map((K) => {
      let P = { source: q[K.source], target: q[K.target] };
      if (typeof K.data < "u") P.data = K.data;
      if (typeof K.conditional < "u") P.conditional = K.conditional;
      return P;
    }) };
  }
  addNode(q, K, P) {
    if (K !== void 0 && this.nodes[K] !== void 0) throw Error(`Node with id ${K} already exists`);
    let _ = K ?? iq(), Y = { id: _, data: q, name: Db(K, q), metadata: P };
    return this.nodes[_] = Y, Y;
  }
  removeNode(q) {
    delete this.nodes[q.id], this.edges = this.edges.filter((K) => K.source !== q.id && K.target !== q.id);
  }
  addEdge(q, K, P, _) {
    if (this.nodes[q.id] === void 0) throw Error(`Source node ${q.id} not in graph`);
    if (this.nodes[K.id] === void 0) throw Error(`Target node ${K.id} not in graph`);
    let Y = { source: q.id, target: K.id, data: P, conditional: _ };
    return this.edges.push(Y), Y;
  }
  firstNode() {
    return LA(this);
  }
  lastNode() {
    return gA(this);
  }
  extend(q, K = "") {
    let P = K;
    if (Object.values(q.nodes).map((T) => T.id).every(l_)) P = "";
    let Y = /* @__PURE__ */ __name((T) => {
      return P ? `${P}:${T}` : T;
    }, "Y");
    Object.entries(q.nodes).forEach(([T, X]) => {
      this.nodes[Y(T)] = { ...X, id: Y(T) };
    });
    let O = q.edges.map((T) => {
      return { ...T, source: Y(T.source), target: Y(T.target) };
    });
    this.edges = [...this.edges, ...O];
    let z = q.firstNode(), J = q.lastNode();
    return [z ? { id: Y(z.id), data: z.data } : void 0, J ? { id: Y(J.id), data: J.data } : void 0];
  }
  trimFirstNode() {
    let q = this.firstNode();
    if (q && LA(this, [q.id])) this.removeNode(q);
  }
  trimLastNode() {
    let q = this.lastNode();
    if (q && gA(this, [q.id])) this.removeNode(q);
  }
  reid() {
    let q = Object.fromEntries(Object.values(this.nodes).map((_) => [_.id, _.name])), K = /* @__PURE__ */ new Map();
    Object.values(q).forEach((_) => {
      K.set(_, (K.get(_) || 0) + 1);
    });
    let P = /* @__PURE__ */ __name((_) => {
      let Y = q[_];
      if (l_(_) && K.get(Y) === 1) return Y;
      else return _;
    }, "P");
    return new _a35({ nodes: Object.fromEntries(Object.entries(this.nodes).map(([_, Y]) => [P(_), { ...Y, id: P(_) }])), edges: this.edges.map((_) => ({ ..._, source: P(_.source), target: P(_.target) })) });
  }
  drawMermaid(q) {
    let { withStyles: K, curveStyle: P, nodeColors: _ = { default: "fill:#f2f0ff,line-height:1.2", first: "fill-opacity:0", last: "fill:#bfb6fc" }, wrapLabelNWords: Y } = q ?? {}, O = this.reid(), z = O.firstNode(), J = O.lastNode();
    return TA(O.nodes, O.edges, { firstNode: z?.id, lastNode: J?.id, withStyles: K, curveStyle: P, nodeColors: _, wrapLabelNWords: Y });
  }
  async drawMermaidPng(q) {
    let K = this.drawMermaid(q);
    return wA(K, { backgroundColor: q?.backgroundColor });
  }
}, __name(_a35, "$"), _a35);
function LA($, q = []) {
  let K = new Set($.edges.filter((_) => !q.includes(_.source)).map((_) => _.target)), P = [];
  for (let _ of Object.values($.nodes)) if (!q.includes(_.id) && !K.has(_.id)) P.push(_);
  return P.length === 1 ? P[0] : void 0;
}
__name(LA, "LA");
function gA($, q = []) {
  let K = new Set($.edges.filter((_) => !q.includes(_.target)).map((_) => _.source)), P = [];
  for (let _ of Object.values($.nodes)) if (!q.includes(_.id) && !K.has(_.id)) P.push(_);
  return P.length === 1 ? P[0] : void 0;
}
__name(gA, "gA");
function bA($) {
  let q = new TextEncoder(), K = new ReadableStream({ async start(P) {
    for await (let _ of $) P.enqueue(q.encode(`event: data
data: ${JSON.stringify(_)}

`));
    P.enqueue(q.encode(`event: end

`)), P.close();
  } });
  return uq.fromReadableStream(K);
}
__name(bA, "bA");
function kz($) {
  return typeof $ === "object" && $ !== null && typeof $[Symbol.iterator] === "function" && typeof $.next === "function";
}
__name(kz, "kz");
var yA = /* @__PURE__ */ __name(($) => $ != null && typeof $ === "object" && "next" in $ && typeof $.next === "function", "yA");
function f5($) {
  return typeof $ === "object" && $ !== null && typeof $[Symbol.asyncIterator] === "function";
}
__name(f5, "f5");
function* Gz($, q) {
  while (true) {
    let { value: K, done: P } = Uq.runWithConfig(vK($), q.next.bind(q), true);
    if (P) break;
    else yield K;
  }
}
__name(Gz, "Gz");
async function* Z5($, q) {
  let K = q[Symbol.asyncIterator]();
  while (true) {
    let { value: P, done: _ } = await Uq.runWithConfig(vK($), K.next.bind(q), true);
    if (_) break;
    else yield P;
  }
}
__name(Z5, "Z5");
var Vz = K8(h1(), 1);
function Jq($, q) {
  return $ && !Array.isArray($) && !($ instanceof Date) && typeof $ === "object" ? $ : { [q]: $ };
}
__name(Jq, "Jq");
var _a36;
var pq = (_a36 = class extends DK {
  lc_runnable = true;
  name;
  getName($) {
    let q = this.name ?? this.constructor.lc_name() ?? this.constructor.name;
    return $ ? `${q}${$}` : q;
  }
  withRetry($) {
    return new xA({ bound: this, kwargs: {}, config: {}, maxAttemptNumber: $?.stopAfterAttempt, ...$ });
  }
  withConfig($) {
    return new X5({ bound: this, config: $, kwargs: {} });
  }
  withFallbacks($) {
    let q = Array.isArray($) ? $ : $.fallbacks;
    return new yb({ runnable: this, fallbacks: q });
  }
  _getOptionsList($, q = 0) {
    if (Array.isArray($) && $.length !== q) throw Error(`Passed "options" must be an array with the same length as the inputs, but got ${$.length} options for ${q} inputs`);
    if (Array.isArray($)) return $.map(N6);
    if (q > 1 && !Array.isArray($) && $.runId) {
      console.warn("Provided runId will be used only for the first element of the batch.");
      let K = Object.fromEntries(Object.entries($).filter(([P]) => P !== "runId"));
      return Array.from({ length: q }, (P, _) => N6(_ === 0 ? $ : K));
    }
    return Array.from({ length: q }, () => N6($));
  }
  async batch($, q, K) {
    let P = this._getOptionsList(q ?? {}, $.length), _ = P[0]?.maxConcurrency ?? K?.maxConcurrency, Y = new CP({ maxConcurrency: _, onFailedAttempt: /* @__PURE__ */ __name((z) => {
      throw z;
    }, "onFailedAttempt") }), O = $.map((z, J) => Y.call(async () => {
      try {
        return await this.invoke(z, P[J]);
      } catch (T) {
        if (K?.returnExceptions) return T;
        throw T;
      }
    }));
    return Promise.all(O);
  }
  async *_streamIterator($, q) {
    yield this.invoke($, q);
  }
  async stream($, q) {
    let K = N6(q), P = new pK({ generator: this._streamIterator($, K), config: K });
    return await P.setup, uq.fromAsyncGenerator(P);
  }
  _separateRunnableConfigFromCallOptions($) {
    let q;
    if ($ === void 0) q = N6($);
    else q = N6({ callbacks: $.callbacks, tags: $.tags, metadata: $.metadata, runName: $.runName, configurable: $.configurable, recursionLimit: $.recursionLimit, maxConcurrency: $.maxConcurrency, runId: $.runId, timeout: $.timeout, signal: $.signal });
    let K = { ...$ };
    return delete K.callbacks, delete K.tags, delete K.metadata, delete K.runName, delete K.configurable, delete K.recursionLimit, delete K.maxConcurrency, delete K.runId, delete K.timeout, delete K.signal, [q, K];
  }
  async _callWithConfig($, q, K) {
    let P = N6(K), Y = await (await f8(P))?.handleChainStart(this.toJSON(), Jq(q, "input"), P.runId, P?.runType, void 0, void 0, P?.runName ?? this.getName());
    delete P.runId;
    let O;
    try {
      let z = $.call(this, q, P, Y);
      O = await l8(z, K?.signal);
    } catch (z) {
      throw await Y?.handleChainError(z), z;
    }
    return await Y?.handleChainEnd(Jq(O, "output")), O;
  }
  async _batchWithConfig($, q, K, P) {
    let _ = this._getOptionsList(K ?? {}, q.length), Y = await Promise.all(_.map(f8)), O = await Promise.all(Y.map(async (J, T) => {
      let X = await J?.handleChainStart(this.toJSON(), Jq(q[T], "input"), _[T].runId, _[T].runType, void 0, void 0, _[T].runName ?? this.getName());
      return delete _[T].runId, X;
    })), z;
    try {
      let J = $.call(this, q, _, O, P);
      z = await l8(J, _?.[0]?.signal);
    } catch (J) {
      throw await Promise.all(O.map((T) => T?.handleChainError(J))), J;
    }
    return await Promise.all(O.map((J) => J?.handleChainEnd(Jq(z, "output")))), z;
  }
  _concatOutputChunks($, q) {
    return _9($, q);
  }
  async *_transformStreamWithConfig($, q, K) {
    let P, _ = true, Y, O = true, z = N6(K), J = await f8(z), T = this;
    async function* X() {
      for await (let V of $) {
        if (_) if (P === void 0) P = V;
        else try {
          P = T._concatOutputChunks(P, V);
        } catch {
          P = void 0, _ = false;
        }
        yield V;
      }
    }
    __name(X, "X");
    let f;
    try {
      let V = await c2(q.bind(this), X(), async () => J?.handleChainStart(this.toJSON(), { input: "" }, z.runId, z.runType, void 0, void 0, z.runName ?? this.getName()), K?.signal, z);
      delete z.runId, f = V.setup;
      let M = f?.handlers.find(hX), N = V.output;
      if (M !== void 0 && f !== void 0) N = M.tapOutputIterable(f.runId, N);
      let E = f?.handlers.find(r2);
      if (E !== void 0 && f !== void 0) N = E.tapOutputIterable(f.runId, N);
      for await (let h of N) if (yield h, O) if (Y === void 0) Y = h;
      else try {
        Y = this._concatOutputChunks(Y, h);
      } catch {
        Y = void 0, O = false;
      }
    } catch (V) {
      throw await f?.handleChainError(V, void 0, void 0, void 0, { inputs: Jq(P, "input") }), V;
    }
    await f?.handleChainEnd(Y ?? {}, void 0, void 0, void 0, { inputs: Jq(P, "input") });
  }
  getGraph($) {
    let q = new w5(), K = q.addNode({ name: `${this.getName()}Input`, schema: N_.any() }), P = q.addNode(this), _ = q.addNode({ name: `${this.getName()}Output`, schema: N_.any() });
    return q.addEdge(K, P), q.addEdge(P, _), q;
  }
  pipe($) {
    return new pA({ first: this, last: C_($) });
  }
  pick($) {
    return this.pipe(new xb($));
  }
  assign($) {
    return this.pipe(new ub(new Sz({ steps: $ })));
  }
  async *transform($, q) {
    let K;
    for await (let P of $) if (K === void 0) K = P;
    else K = this._concatOutputChunks(K, P);
    yield* this._streamIterator(K, N6(q));
  }
  async *streamLog($, q, K) {
    let P = new z9({ ...K, autoClose: false, _schemaFormat: "original" }), _ = N6(q);
    yield* this._streamLog($, P, _);
  }
  async *_streamLog($, q, K) {
    let { callbacks: P } = K;
    if (P === void 0) K.callbacks = [q];
    else if (Array.isArray(P)) K.callbacks = P.concat([q]);
    else {
      let z = P.copy();
      z.addHandler(q, true), K.callbacks = z;
    }
    let _ = this.stream($, K);
    async function Y() {
      try {
        let z = await _;
        for await (let J of z) {
          let T = new r8({ ops: [{ op: "add", path: "/streamed_output/-", value: J }] });
          await q.writer.write(T);
        }
      } finally {
        await q.writer.close();
      }
    }
    __name(Y, "Y");
    let O = Y();
    try {
      for await (let z of q) yield z;
    } finally {
      await O;
    }
  }
  streamEvents($, q, K) {
    let P;
    if (q.version === "v1") P = this._streamEventsV1($, q, K);
    else if (q.version === "v2") P = this._streamEventsV2($, q, K);
    else throw Error('Only versions "v1" and "v2" of the schema are currently supported.');
    if (q.encoding === "text/event-stream") return bA(P);
    else return uq.fromAsyncGenerator(P);
  }
  async *_streamEventsV2($, q, K) {
    let P = new EX({ ...K, autoClose: false }), _ = N6(q), Y = _.runId ?? iq();
    _.runId = Y;
    let O = _.callbacks;
    if (O === void 0) _.callbacks = [P];
    else if (Array.isArray(O)) _.callbacks = O.concat(P);
    else {
      let M = O.copy();
      M.addHandler(P, true), _.callbacks = M;
    }
    let z = new AbortController(), J = this;
    async function T() {
      let M, N = null;
      try {
        if (q?.signal) if ("any" in AbortSignal) M = AbortSignal.any([z.signal, q.signal]);
        else M = q.signal, N = /* @__PURE__ */ __name(() => {
          z.abort();
        }, "N"), q.signal.addEventListener("abort", N, { once: true });
        else M = z.signal;
        let E = await J.stream($, { ..._, signal: M }), h = P.tapOutputIterable(Y, E);
        for await (let I of h) if (z.signal.aborted) break;
      } finally {
        if (await P.finish(), M && N) M.removeEventListener("abort", N);
      }
    }
    __name(T, "T");
    let X = T(), f = false, V;
    try {
      for await (let M of P) {
        if (!f) {
          M.data.input = $, f = true, V = M.run_id, yield M;
          continue;
        }
        if (M.run_id === V && M.event.endsWith("_end")) {
          if (M.data?.input) delete M.data.input;
        }
        yield M;
      }
    } finally {
      z.abort(), await X;
    }
  }
  async *_streamEventsV1($, q, K) {
    let P, _ = false, Y = N6(q), O = Y.tags ?? [], z = Y.metadata ?? {}, J = Y.runName ?? this.getName(), T = new z9({ ...K, autoClose: false, _schemaFormat: "streaming_events" }), X = new IX({ ...K }), f = this._streamLog($, T, Y);
    for await (let M of f) {
      if (!P) P = v9.fromRunLogPatch(M);
      else P = P.concat(M);
      if (P.state === void 0) throw Error('Internal error: "streamEvents" state is missing. Please open a bug report.');
      if (!_) {
        _ = true;
        let I = { ...P.state }, D = { run_id: I.id, event: `on_${I.type}_start`, name: J, tags: O, metadata: z, data: { input: $ } };
        if (X.includeEvent(D, I.type)) yield D;
      }
      let N = M.ops.filter((I) => I.path.startsWith("/logs/")).map((I) => I.path.split("/")[2]), E = [...new Set(N)];
      for (let I of E) {
        let D, g = {}, b = P.state.logs[I];
        if (b.end_time === void 0) if (b.streamed_output.length > 0) D = "stream";
        else D = "start";
        else D = "end";
        if (D === "start") {
          if (b.inputs !== void 0) g.input = b.inputs;
        } else if (D === "end") {
          if (b.inputs !== void 0) g.input = b.inputs;
          g.output = b.final_output;
        } else if (D === "stream") {
          let y = b.streamed_output.length;
          if (y !== 1) throw Error(`Expected exactly one chunk of streamed output, got ${y} instead. Encountered in: "${b.name}"`);
          g = { chunk: b.streamed_output[0] }, b.streamed_output = [];
        }
        yield { event: `on_${b.type}_${D}`, name: b.name, run_id: b.id, tags: b.tags, metadata: b.metadata, data: g };
      }
      let { state: h } = P;
      if (h.streamed_output.length > 0) {
        let I = h.streamed_output.length;
        if (I !== 1) throw Error(`Expected exactly one chunk of streamed output, got ${I} instead. Encountered in: "${h.name}"`);
        let D = { chunk: h.streamed_output[0] };
        h.streamed_output = [];
        let g = { event: `on_${h.type}_stream`, run_id: h.id, tags: O, metadata: z, name: J, data: D };
        if (X.includeEvent(g, h.type)) yield g;
      }
    }
    let V = P?.state;
    if (V !== void 0) {
      let M = { event: `on_${V.type}_end`, name: J, run_id: V.id, tags: O, metadata: z, data: { output: V.final_output } };
      if (X.includeEvent(M, V.type)) yield M;
    }
  }
  static isRunnable($) {
    return hP($);
  }
  withListeners({ onStart: $, onEnd: q, onError: K }) {
    return new X5({ bound: this, config: {}, configFactories: [(P) => ({ callbacks: [new o2({ config: P, onStart: $, onEnd: q, onError: K })] })] });
  }
  asTool($) {
    return pb(this, $);
  }
}, __name(_a36, "pq"), _a36);
var _a37;
var X5 = (_a37 = class extends pq {
  static lc_name() {
    return "RunnableBinding";
  }
  lc_namespace = ["langchain_core", "runnables"];
  lc_serializable = true;
  bound;
  config;
  kwargs;
  configFactories;
  constructor(q) {
    super(q);
    this.bound = q.bound, this.kwargs = q.kwargs, this.config = q.config, this.configFactories = q.configFactories;
  }
  getName(q) {
    return this.bound.getName(q);
  }
  async _mergeConfig(...q) {
    let K = p2(this.config, ...q);
    return p2(K, ...this.configFactories ? await Promise.all(this.configFactories.map(async (P) => await P(K))) : []);
  }
  withConfig(q) {
    return new this.constructor({ bound: this.bound, kwargs: this.kwargs, config: { ...this.config, ...q } });
  }
  withRetry(q) {
    return new xA({ bound: this.bound, kwargs: this.kwargs, config: this.config, maxAttemptNumber: q?.stopAfterAttempt, ...q });
  }
  async invoke(q, K) {
    return this.bound.invoke(q, await this._mergeConfig(K, this.kwargs));
  }
  async batch(q, K, P) {
    let _ = Array.isArray(K) ? await Promise.all(K.map(async (Y) => this._mergeConfig(N6(Y), this.kwargs))) : await this._mergeConfig(N6(K), this.kwargs);
    return this.bound.batch(q, _, P);
  }
  _concatOutputChunks(q, K) {
    return this.bound._concatOutputChunks(q, K);
  }
  async *_streamIterator(q, K) {
    yield* this.bound._streamIterator(q, await this._mergeConfig(N6(K), this.kwargs));
  }
  async stream(q, K) {
    return this.bound.stream(q, await this._mergeConfig(N6(K), this.kwargs));
  }
  async *transform(q, K) {
    yield* this.bound.transform(q, await this._mergeConfig(N6(K), this.kwargs));
  }
  streamEvents(q, K, P) {
    let _ = this, Y = /* @__PURE__ */ __name(async function* () {
      yield* _.bound.streamEvents(q, { ...await _._mergeConfig(N6(K), _.kwargs), version: K.version }, P);
    }, "Y");
    return uq.fromAsyncGenerator(Y());
  }
  static isRunnableBinding(q) {
    return q.bound && pq.isRunnable(q.bound);
  }
  withListeners({ onStart: q, onEnd: K, onError: P }) {
    return new _a37({ bound: this.bound, kwargs: this.kwargs, config: this.config, configFactories: [(_) => ({ callbacks: [new o2({ config: _, onStart: q, onEnd: K, onError: P })] })] });
  }
}, __name(_a37, "$"), _a37);
var _a38;
var xA = (_a38 = class extends X5 {
  static lc_name() {
    return "RunnableRetry";
  }
  lc_namespace = ["langchain_core", "runnables"];
  maxAttemptNumber = 3;
  onFailedAttempt = /* @__PURE__ */ __name(() => {
  }, "onFailedAttempt");
  constructor($) {
    super($);
    this.maxAttemptNumber = $.maxAttemptNumber ?? this.maxAttemptNumber, this.onFailedAttempt = $.onFailedAttempt ?? this.onFailedAttempt;
  }
  _patchConfigForRetry($, q, K) {
    let P = $ > 1 ? `retry:attempt:${$}` : void 0;
    return Rq(q, { callbacks: K?.getChild(P) });
  }
  async _invoke($, q, K) {
    return Vz.default((P) => super.invoke($, this._patchConfigForRetry(P, q, K)), { onFailedAttempt: /* @__PURE__ */ __name((P) => this.onFailedAttempt(P, $), "onFailedAttempt"), retries: Math.max(this.maxAttemptNumber - 1, 0), randomize: true });
  }
  async invoke($, q) {
    return this._callWithConfig(this._invoke.bind(this), $, q);
  }
  async _batch($, q, K, P) {
    let _ = {};
    try {
      await Vz.default(async (Y) => {
        let O = $.map((f, V) => V).filter((f) => _[f.toString()] === void 0 || _[f.toString()] instanceof Error), z = O.map((f) => $[f]), J = O.map((f) => this._patchConfigForRetry(Y, q?.[f], K?.[f])), T = await super.batch(z, J, { ...P, returnExceptions: true }), X;
        for (let f = 0; f < T.length; f += 1) {
          let V = T[f], M = O[f];
          if (V instanceof Error) {
            if (X === void 0) X = V, X.input = z[f];
          }
          _[M.toString()] = V;
        }
        if (X) throw X;
        return T;
      }, { onFailedAttempt: /* @__PURE__ */ __name((Y) => this.onFailedAttempt(Y, Y.input), "onFailedAttempt"), retries: Math.max(this.maxAttemptNumber - 1, 0), randomize: true });
    } catch (Y) {
      if (P?.returnExceptions !== true) throw Y;
    }
    return Object.keys(_).sort((Y, O) => parseInt(Y, 10) - parseInt(O, 10)).map((Y) => _[parseInt(Y, 10)]);
  }
  async batch($, q, K) {
    return this._batchWithConfig(this._batch.bind(this), $, q, K);
  }
}, __name(_a38, "xA"), _a38);
var _a39;
var pA = (_a39 = class extends pq {
  static lc_name() {
    return "RunnableSequence";
  }
  first;
  middle = [];
  last;
  omitSequenceTags = false;
  lc_serializable = true;
  lc_namespace = ["langchain_core", "runnables"];
  constructor(q) {
    super(q);
    this.first = q.first, this.middle = q.middle ?? this.middle, this.last = q.last, this.name = q.name, this.omitSequenceTags = q.omitSequenceTags ?? this.omitSequenceTags;
  }
  get steps() {
    return [this.first, ...this.middle, this.last];
  }
  async invoke(q, K) {
    let P = N6(K), Y = await (await f8(P))?.handleChainStart(this.toJSON(), Jq(q, "input"), P.runId, void 0, void 0, void 0, P?.runName);
    delete P.runId;
    let O = q, z;
    try {
      let J = [this.first, ...this.middle];
      for (let T = 0; T < J.length; T += 1) {
        let f = J[T].invoke(O, Rq(P, { callbacks: Y?.getChild(this.omitSequenceTags ? void 0 : `seq:step:${T + 1}`) }));
        O = await l8(f, K?.signal);
      }
      if (K?.signal?.aborted) throw i_(K.signal);
      z = await this.last.invoke(O, Rq(P, { callbacks: Y?.getChild(this.omitSequenceTags ? void 0 : `seq:step:${this.steps.length}`) }));
    } catch (J) {
      throw await Y?.handleChainError(J), J;
    }
    return await Y?.handleChainEnd(Jq(z, "output")), z;
  }
  async batch(q, K, P) {
    let _ = this._getOptionsList(K ?? {}, q.length), Y = await Promise.all(_.map(f8)), O = await Promise.all(Y.map(async (J, T) => {
      let X = await J?.handleChainStart(this.toJSON(), Jq(q[T], "input"), _[T].runId, void 0, void 0, void 0, _[T].runName);
      return delete _[T].runId, X;
    })), z = q;
    try {
      for (let J = 0; J < this.steps.length; J += 1) {
        let X = this.steps[J].batch(z, O.map((f, V) => {
          let M = f?.getChild(this.omitSequenceTags ? void 0 : `seq:step:${J + 1}`);
          return Rq(_[V], { callbacks: M });
        }), P);
        z = await l8(X, _[0]?.signal);
      }
    } catch (J) {
      throw await Promise.all(O.map((T) => T?.handleChainError(J))), J;
    }
    return await Promise.all(O.map((J) => J?.handleChainEnd(Jq(z, "output")))), z;
  }
  _concatOutputChunks(q, K) {
    return this.last._concatOutputChunks(q, K);
  }
  async *_streamIterator(q, K) {
    let P = await f8(K), { runId: _, ...Y } = K ?? {}, O = await P?.handleChainStart(this.toJSON(), Jq(q, "input"), _, void 0, void 0, void 0, Y?.runName), z = [this.first, ...this.middle, this.last], J = true, T;
    async function* X() {
      yield q;
    }
    __name(X, "X");
    try {
      let f = z[0].transform(X(), Rq(Y, { callbacks: O?.getChild(this.omitSequenceTags ? void 0 : "seq:step:1") }));
      for (let V = 1; V < z.length; V += 1) f = await z[V].transform(f, Rq(Y, { callbacks: O?.getChild(this.omitSequenceTags ? void 0 : `seq:step:${V + 1}`) }));
      for await (let V of f) if (K?.signal?.throwIfAborted(), yield V, J) if (T === void 0) T = V;
      else try {
        T = this._concatOutputChunks(T, V);
      } catch {
        T = void 0, J = false;
      }
    } catch (f) {
      throw await O?.handleChainError(f), f;
    }
    await O?.handleChainEnd(Jq(T, "output"));
  }
  getGraph(q) {
    let K = new w5(), P = null;
    return this.steps.forEach((_, Y) => {
      let O = _.getGraph(q);
      if (Y !== 0) O.trimFirstNode();
      if (Y !== this.steps.length - 1) O.trimLastNode();
      K.extend(O);
      let z = O.firstNode();
      if (!z) throw Error(`Runnable ${_} has no first node`);
      if (P) K.addEdge(P, z);
      P = O.lastNode();
    }), K;
  }
  pipe(q) {
    if (_a39.isRunnableSequence(q)) return new _a39({ first: this.first, middle: this.middle.concat([this.last, q.first, ...q.middle]), last: q.last, name: this.name ?? q.name });
    else return new _a39({ first: this.first, middle: [...this.middle, this.last], last: C_(q), name: this.name });
  }
  static isRunnableSequence(q) {
    return Array.isArray(q.middle) && pq.isRunnable(q);
  }
  static from([q, ...K], P) {
    let _ = {};
    if (typeof P === "string") _.name = P;
    else if (P !== void 0) _ = P;
    return new _a39({ ..._, first: C_(q), middle: K.slice(0, -1).map(C_), last: C_(K[K.length - 1]) });
  }
}, __name(_a39, "$"), _a39);
var _a40;
var Sz = (_a40 = class extends pq {
  static lc_name() {
    return "RunnableMap";
  }
  lc_namespace = ["langchain_core", "runnables"];
  lc_serializable = true;
  steps;
  getStepsKeys() {
    return Object.keys(this.steps);
  }
  constructor(q) {
    super(q);
    this.steps = {};
    for (let [K, P] of Object.entries(q.steps)) this.steps[K] = C_(P);
  }
  static from(q) {
    return new _a40({ steps: q });
  }
  async invoke(q, K) {
    let P = N6(K), Y = await (await f8(P))?.handleChainStart(this.toJSON(), { input: q }, P.runId, void 0, void 0, void 0, P?.runName);
    delete P.runId;
    let O = {};
    try {
      let z = Object.entries(this.steps).map(async ([J, T]) => {
        O[J] = await T.invoke(q, Rq(P, { callbacks: Y?.getChild(`map:key:${J}`) }));
      });
      await l8(Promise.all(z), K?.signal);
    } catch (z) {
      throw await Y?.handleChainError(z), z;
    }
    return await Y?.handleChainEnd(O), O;
  }
  async *_transform(q, K, P) {
    let _ = { ...this.steps }, Y = K9(q, Object.keys(_).length), O = new Map(Object.entries(_).map(([z, J], T) => {
      let X = J.transform(Y[T], Rq(P, { callbacks: K?.getChild(`map:key:${z}`) }));
      return [z, X.next().then((f) => ({ key: z, gen: X, result: f }))];
    }));
    while (O.size) {
      let z = Promise.race(O.values()), { key: J, result: T, gen: X } = await l8(z, P?.signal);
      if (O.delete(J), !T.done) yield { [J]: T.value }, O.set(J, X.next().then((f) => ({ key: J, gen: X, result: f })));
    }
  }
  transform(q, K) {
    return this._transformStreamWithConfig(q, this._transform.bind(this), K);
  }
  async stream(q, K) {
    async function* P() {
      yield q;
    }
    __name(P, "P");
    let _ = N6(K), Y = new pK({ generator: this.transform(P(), _), config: _ });
    return await Y.setup, uq.fromAsyncGenerator(Y);
  }
}, __name(_a40, "$"), _a40);
var _a41;
var gb = (_a41 = class extends pq {
  lc_serializable = false;
  lc_namespace = ["langchain_core", "runnables"];
  func;
  constructor(q) {
    super(q);
    if (!s1(q.func)) throw Error("RunnableTraceable requires a function that is wrapped in traceable higher-order function");
    this.func = q.func;
  }
  async invoke(q, K) {
    let [P] = this._getOptionsList(K ?? {}, 1), _ = await f8(P), Y = this.func(Rq(P, { callbacks: _ }), q);
    return l8(Y, P?.signal);
  }
  async *_streamIterator(q, K) {
    let [P] = this._getOptionsList(K ?? {}, 1), _ = await this.invoke(q, K);
    if (f5(_)) {
      for await (let Y of _) P?.signal?.throwIfAborted(), yield Y;
      return;
    }
    if (yA(_)) {
      while (true) {
        P?.signal?.throwIfAborted();
        let Y = _.next();
        if (Y.done) break;
        yield Y.value;
      }
      return;
    }
    yield _;
  }
  static from(q) {
    return new _a41({ func: q });
  }
}, __name(_a41, "$"), _a41);
function bb($) {
  if (s1($)) throw Error("RunnableLambda requires a function that is not wrapped in traceable higher-order function. This shouldn't happen.");
}
__name(bb, "bb");
var _a42;
var cA = (_a42 = class extends pq {
  static lc_name() {
    return "RunnableLambda";
  }
  lc_namespace = ["langchain_core", "runnables"];
  func;
  constructor(q) {
    if (s1(q.func)) return gb.from(q.func);
    super(q);
    bb(q.func), this.func = q.func;
  }
  static from(q) {
    return new _a42({ func: q });
  }
  async _invoke(q, K, P) {
    return new Promise((_, Y) => {
      let O = Rq(K, { callbacks: P?.getChild(), recursionLimit: (K?.recursionLimit ?? q9) - 1 });
      Uq.runWithConfig(vK(O), async () => {
        try {
          let z = await this.func(q, { ...O });
          if (z && pq.isRunnable(z)) {
            if (K?.recursionLimit === 0) throw Error("Recursion limit reached.");
            z = await z.invoke(q, { ...O, recursionLimit: (O.recursionLimit ?? q9) - 1 });
          } else if (f5(z)) {
            let J;
            for await (let T of Z5(O, z)) if (K?.signal?.throwIfAborted(), J === void 0) J = T;
            else try {
              J = this._concatOutputChunks(J, T);
            } catch {
              J = T;
            }
            z = J;
          } else if (kz(z)) {
            let J;
            for (let T of Gz(O, z)) if (K?.signal?.throwIfAborted(), J === void 0) J = T;
            else try {
              J = this._concatOutputChunks(J, T);
            } catch {
              J = T;
            }
            z = J;
          }
          _(z);
        } catch (z) {
          Y(z);
        }
      });
    });
  }
  async invoke(q, K) {
    return this._callWithConfig(this._invoke.bind(this), q, K);
  }
  async *_transform(q, K, P) {
    let _;
    for await (let z of q) if (_ === void 0) _ = z;
    else try {
      _ = this._concatOutputChunks(_, z);
    } catch {
      _ = z;
    }
    let Y = Rq(P, { callbacks: K?.getChild(), recursionLimit: (P?.recursionLimit ?? q9) - 1 }), O = await new Promise((z, J) => {
      Uq.runWithConfig(vK(Y), async () => {
        try {
          let T = await this.func(_, { ...Y, config: Y });
          z(T);
        } catch (T) {
          J(T);
        }
      });
    });
    if (O && pq.isRunnable(O)) {
      if (P?.recursionLimit === 0) throw Error("Recursion limit reached.");
      let z = await O.stream(_, Y);
      for await (let J of z) yield J;
    } else if (f5(O)) for await (let z of Z5(Y, O)) P?.signal?.throwIfAborted(), yield z;
    else if (kz(O)) for (let z of Gz(Y, O)) P?.signal?.throwIfAborted(), yield z;
    else yield O;
  }
  transform(q, K) {
    return this._transformStreamWithConfig(q, this._transform.bind(this), K);
  }
  async stream(q, K) {
    async function* P() {
      yield q;
    }
    __name(P, "P");
    let _ = N6(K), Y = new pK({ generator: this.transform(P(), _), config: _ });
    return await Y.setup, uq.fromAsyncGenerator(Y);
  }
}, __name(_a42, "$"), _a42);
var _a43;
var yb = (_a43 = class extends pq {
  static lc_name() {
    return "RunnableWithFallbacks";
  }
  lc_namespace = ["langchain_core", "runnables"];
  lc_serializable = true;
  runnable;
  fallbacks;
  constructor($) {
    super($);
    this.runnable = $.runnable, this.fallbacks = $.fallbacks;
  }
  *runnables() {
    yield this.runnable;
    for (let $ of this.fallbacks) yield $;
  }
  async invoke($, q) {
    let K = N6(q), P = await f8(K), { runId: _, ...Y } = K, O = await P?.handleChainStart(this.toJSON(), Jq($, "input"), _, void 0, void 0, void 0, Y?.runName), z = Rq(Y, { callbacks: O?.getChild() });
    return await Uq.runWithConfig(z, async () => {
      let T;
      for (let X of this.runnables()) {
        K?.signal?.throwIfAborted();
        try {
          let f = await X.invoke($, z);
          return await O?.handleChainEnd(Jq(f, "output")), f;
        } catch (f) {
          if (T === void 0) T = f;
        }
      }
      if (T === void 0) throw Error("No error stored at end of fallback.");
      throw await O?.handleChainError(T), T;
    });
  }
  async *_streamIterator($, q) {
    let K = N6(q), P = await f8(K), { runId: _, ...Y } = K, O = await P?.handleChainStart(this.toJSON(), Jq($, "input"), _, void 0, void 0, void 0, Y?.runName), z, J;
    for (let X of this.runnables()) {
      K?.signal?.throwIfAborted();
      let f = Rq(Y, { callbacks: O?.getChild() });
      try {
        let V = await X.stream($, f);
        J = Z5(f, V);
        break;
      } catch (V) {
        if (z === void 0) z = V;
      }
    }
    if (J === void 0) {
      let X = z ?? Error("No error stored at end of fallback.");
      throw await O?.handleChainError(X), X;
    }
    let T;
    try {
      for await (let X of J) {
        yield X;
        try {
          T = T === void 0 ? T : this._concatOutputChunks(T, X);
        } catch {
          T = void 0;
        }
      }
    } catch (X) {
      throw await O?.handleChainError(X), X;
    }
    await O?.handleChainEnd(Jq(T, "output"));
  }
  async batch($, q, K) {
    if (K?.returnExceptions) throw Error("Not implemented.");
    let P = this._getOptionsList(q ?? {}, $.length), _ = await Promise.all(P.map((z) => f8(z))), Y = await Promise.all(_.map(async (z, J) => {
      let T = await z?.handleChainStart(this.toJSON(), Jq($[J], "input"), P[J].runId, void 0, void 0, void 0, P[J].runName);
      return delete P[J].runId, T;
    })), O;
    for (let z of this.runnables()) {
      P[0].signal?.throwIfAborted();
      try {
        let J = await z.batch($, Y.map((T, X) => Rq(P[X], { callbacks: T?.getChild() })), K);
        return await Promise.all(Y.map((T, X) => T?.handleChainEnd(Jq(J[X], "output")))), J;
      } catch (J) {
        if (O === void 0) O = J;
      }
    }
    if (!O) throw Error("No error stored at end of fallbacks.");
    throw await Promise.all(Y.map((z) => z?.handleChainError(O))), O;
  }
}, __name(_a43, "yb"), _a43);
function C_($) {
  if (typeof $ === "function") return new cA({ func: $ });
  else if (pq.isRunnable($)) return $;
  else if (!Array.isArray($) && typeof $ === "object") {
    let q = {};
    for (let [K, P] of Object.entries($)) q[K] = C_(P);
    return new Sz({ steps: q });
  } else throw Error(`Expected a Runnable, function or object.
Instead got an unsupported type.`);
}
__name(C_, "C_");
var _a44;
var ub = (_a44 = class extends pq {
  static lc_name() {
    return "RunnableAssign";
  }
  lc_namespace = ["langchain_core", "runnables"];
  lc_serializable = true;
  mapper;
  constructor($) {
    if ($ instanceof Sz) $ = { mapper: $ };
    super($);
    this.mapper = $.mapper;
  }
  async invoke($, q) {
    let K = await this.mapper.invoke($, q);
    return { ...$, ...K };
  }
  async *_transform($, q, K) {
    let P = this.mapper.getStepsKeys(), [_, Y] = K9($), O = this.mapper.transform(Y, Rq(K, { callbacks: q?.getChild() })), z = O.next();
    for await (let J of _) {
      if (typeof J !== "object" || Array.isArray(J)) throw Error(`RunnableAssign can only be used with objects as input, got ${typeof J}`);
      let T = Object.fromEntries(Object.entries(J).filter(([X]) => !P.includes(X)));
      if (Object.keys(T).length > 0) yield T;
    }
    yield (await z).value;
    for await (let J of O) yield J;
  }
  transform($, q) {
    return this._transformStreamWithConfig($, this._transform.bind(this), q);
  }
  async stream($, q) {
    async function* K() {
      yield $;
    }
    __name(K, "K");
    let P = N6(q), _ = new pK({ generator: this.transform(K(), P), config: P });
    return await _.setup, uq.fromAsyncGenerator(_);
  }
}, __name(_a44, "ub"), _a44);
var _a45;
var xb = (_a45 = class extends pq {
  static lc_name() {
    return "RunnablePick";
  }
  lc_namespace = ["langchain_core", "runnables"];
  lc_serializable = true;
  keys;
  constructor($) {
    if (typeof $ === "string" || Array.isArray($)) $ = { keys: $ };
    super($);
    this.keys = $.keys;
  }
  async _pick($) {
    if (typeof this.keys === "string") return $[this.keys];
    else {
      let q = this.keys.map((K) => [K, $[K]]).filter((K) => K[1] !== void 0);
      return q.length === 0 ? void 0 : Object.fromEntries(q);
    }
  }
  async invoke($, q) {
    return this._callWithConfig(this._pick.bind(this), $, q);
  }
  async *_transform($) {
    for await (let q of $) {
      let K = await this._pick(q);
      if (K !== void 0) yield K;
    }
  }
  transform($, q) {
    return this._transformStreamWithConfig($, this._transform.bind(this), q);
  }
  async stream($, q) {
    async function* K() {
      yield $;
    }
    __name(K, "K");
    let P = N6(q), _ = new pK({ generator: this.transform(K(), P), config: P });
    return await _.setup, uq.fromAsyncGenerator(_);
  }
}, __name(_a45, "xb"), _a45);
var _a46;
var uA = (_a46 = class extends X5 {
  name;
  description;
  schema;
  constructor($) {
    let q = pA.from([cA.from(async (K) => {
      let P;
      if (yO(K)) try {
        P = await vA(this.schema, K.args);
      } catch {
        throw new qT("Received tool input did not match expected schema", JSON.stringify(K.args));
      }
      else P = K;
      return P;
    }).withConfig({ runName: `${$.name}:parse_input` }), $.bound]).withConfig({ runName: $.name });
    super({ bound: q, config: $.config ?? {} });
    this.name = $.name, this.description = $.description, this.schema = $.schema;
  }
  static lc_name() {
    return "RunnableToolLike";
  }
}, __name(_a46, "uA"), _a46);
function pb($, q) {
  let K = q.name ?? $.getName(), P = q.description ?? zA(q.schema);
  if (WA(q.schema)) return new uA({ name: K, description: P, schema: N_.object({ input: N_.string() }).transform((_) => _.input), bound: $ });
  return new uA({ name: K, description: P, schema: q.schema, bound: $ });
}
__name(pb, "pb");
var _a47;
var M7 = (_a47 = class extends pq {
  lc_namespace = ["langchain_core", "documents", "transformers"];
  invoke($, q) {
    return this.transformDocuments($);
  }
}, __name(_a47, "M7"), _a47);
var _a48;
var mA = (_a48 = class extends M7 {
  async transformDocuments($) {
    let q = [];
    for (let K of $) {
      let P = await this._transformDocument(K);
      q.push(P);
    }
    return q;
  }
}, __name(_a48, "mA"), _a48);
var cb = {};
Z6(cb, { BaseDocumentTransformer: /* @__PURE__ */ __name(() => M7, "BaseDocumentTransformer"), Document: /* @__PURE__ */ __name(() => H1, "Document"), MappingDocumentTransformer: /* @__PURE__ */ __name(() => mA, "MappingDocumentTransformer") });
var rA = K8(lA(), 1);
var ab = Object.defineProperty;
var Qb = /* @__PURE__ */ __name(($, q, K) => q in $ ? ab($, q, { enumerable: true, configurable: true, writable: true, value: K }) : $[q] = K, "Qb");
var eb = /* @__PURE__ */ __name(($, q, K) => {
  return Qb($, typeof q !== "symbol" ? q + "" : q, K), K;
}, "eb");
function sb($, q) {
  let K = Array.from({ length: $.length }, (P, _) => ({ start: _, end: _ + 1 }));
  while (K.length > 1) {
    let P = null;
    for (let _ = 0; _ < K.length - 1; _++) {
      let Y = $.slice(K[_].start, K[_ + 1].end), O = q.get(Y.join(","));
      if (O == null) continue;
      if (P == null || O < P[0]) P = [O, _];
    }
    if (P != null) {
      let _ = P[1];
      K[_] = { start: K[_].start, end: K[_ + 1].end }, K.splice(_ + 1, 1);
    } else break;
  }
  return K;
}
__name(sb, "sb");
function $y($, q) {
  if ($.length === 1) return [q.get($.join(","))];
  return sb($, q).map((K) => q.get($.slice(K.start, K.end).join(","))).filter((K) => K != null);
}
__name($y, "$y");
function qy($) {
  return $.replace(/[\\^$*+?.()|[\]{}]/g, "\\$&");
}
__name(qy, "qy");
var _a49;
var Cz = (_a49 = class {
  specialTokens;
  inverseSpecialTokens;
  patStr;
  textEncoder = new TextEncoder();
  textDecoder = new TextDecoder("utf-8");
  rankMap = /* @__PURE__ */ new Map();
  textMap = /* @__PURE__ */ new Map();
  constructor($, q) {
    this.patStr = $.pat_str;
    let K = $.bpe_ranks.split(`
`).filter(Boolean).reduce((P, _) => {
      let [Y, O, ...z] = _.split(" "), J = Number.parseInt(O, 10);
      return z.forEach((T, X) => P[T] = J + X), P;
    }, {});
    for (let [P, _] of Object.entries(K)) {
      let Y = rA.default.toByteArray(P);
      this.rankMap.set(Y.join(","), _), this.textMap.set(_, Y);
    }
    this.specialTokens = { ...$.special_tokens, ...q }, this.inverseSpecialTokens = Object.entries(this.specialTokens).reduce((P, [_, Y]) => {
      return P[Y] = this.textEncoder.encode(_), P;
    }, {});
  }
  encode($, q = [], K = "all") {
    let P = new RegExp(this.patStr, "ug"), _ = Cz.specialTokenRegex(Object.keys(this.specialTokens)), Y = [], O = new Set(q === "all" ? Object.keys(this.specialTokens) : q), z = new Set(K === "all" ? Object.keys(this.specialTokens).filter((T) => !O.has(T)) : K);
    if (z.size > 0) {
      let T = Cz.specialTokenRegex([...z]), X = $.match(T);
      if (X != null) throw Error(`The text contains a special token that is not allowed: ${X[0]}`);
    }
    let J = 0;
    while (true) {
      let T = null, X = J;
      while (true) {
        if (_.lastIndex = X, T = _.exec($), T == null || O.has(T[0])) break;
        X = T.index + 1;
      }
      let f = T?.index ?? $.length;
      for (let M of $.substring(J, f).matchAll(P)) {
        let N = this.textEncoder.encode(M[0]), E = this.rankMap.get(N.join(","));
        if (E != null) {
          Y.push(E);
          continue;
        }
        Y.push(...$y(N, this.rankMap));
      }
      if (T == null) break;
      let V = this.specialTokens[T[0]];
      Y.push(V), J = T.index + T[0].length;
    }
    return Y;
  }
  decode($) {
    let q = [], K = 0;
    for (let Y = 0; Y < $.length; ++Y) {
      let O = $[Y], z = this.textMap.get(O) ?? this.inverseSpecialTokens[O];
      if (z != null) q.push(z), K += z.length;
    }
    let P = new Uint8Array(K), _ = 0;
    for (let Y of q) P.set(Y, _), _ += Y.length;
    return this.textDecoder.decode(P);
  }
}, __name(_a49, "Cz"), _a49);
var A5 = Cz;
eb(A5, "specialTokenRegex", ($) => {
  return new RegExp($.map((q) => qy(q)).join("|"), "g");
});
function hz($) {
  switch ($) {
    case "gpt2":
      return "gpt2";
    case "code-cushman-001":
    case "code-cushman-002":
    case "code-davinci-001":
    case "code-davinci-002":
    case "cushman-codex":
    case "davinci-codex":
    case "davinci-002":
    case "text-davinci-002":
    case "text-davinci-003":
      return "p50k_base";
    case "code-davinci-edit-001":
    case "text-davinci-edit-001":
      return "p50k_edit";
    case "ada":
    case "babbage":
    case "babbage-002":
    case "code-search-ada-code-001":
    case "code-search-babbage-code-001":
    case "curie":
    case "davinci":
    case "text-ada-001":
    case "text-babbage-001":
    case "text-curie-001":
    case "text-davinci-001":
    case "text-search-ada-doc-001":
    case "text-search-babbage-doc-001":
    case "text-search-curie-doc-001":
    case "text-search-davinci-doc-001":
    case "text-similarity-ada-001":
    case "text-similarity-babbage-001":
    case "text-similarity-curie-001":
    case "text-similarity-davinci-001":
      return "r50k_base";
    case "gpt-3.5-turbo-instruct-0914":
    case "gpt-3.5-turbo-instruct":
    case "gpt-3.5-turbo-16k-0613":
    case "gpt-3.5-turbo-16k":
    case "gpt-3.5-turbo-0613":
    case "gpt-3.5-turbo-0301":
    case "gpt-3.5-turbo":
    case "gpt-4-32k-0613":
    case "gpt-4-32k-0314":
    case "gpt-4-32k":
    case "gpt-4-0613":
    case "gpt-4-0314":
    case "gpt-4":
    case "gpt-3.5-turbo-1106":
    case "gpt-35-turbo":
    case "gpt-4-1106-preview":
    case "gpt-4-vision-preview":
    case "gpt-3.5-turbo-0125":
    case "gpt-4-turbo":
    case "gpt-4-turbo-2024-04-09":
    case "gpt-4-turbo-preview":
    case "gpt-4-0125-preview":
    case "text-embedding-ada-002":
    case "text-embedding-3-small":
    case "text-embedding-3-large":
      return "cl100k_base";
    case "gpt-4o":
    case "gpt-4o-2024-05-13":
    case "gpt-4o-2024-08-06":
    case "gpt-4o-2024-11-20":
    case "gpt-4o-mini-2024-07-18":
    case "gpt-4o-mini":
    case "gpt-4o-search-preview":
    case "gpt-4o-search-preview-2025-03-11":
    case "gpt-4o-mini-search-preview":
    case "gpt-4o-mini-search-preview-2025-03-11":
    case "gpt-4o-audio-preview":
    case "gpt-4o-audio-preview-2024-12-17":
    case "gpt-4o-audio-preview-2024-10-01":
    case "gpt-4o-mini-audio-preview":
    case "gpt-4o-mini-audio-preview-2024-12-17":
    case "o1":
    case "o1-2024-12-17":
    case "o1-mini":
    case "o1-mini-2024-09-12":
    case "o1-preview":
    case "o1-preview-2024-09-12":
    case "o1-pro":
    case "o1-pro-2025-03-19":
    case "o3":
    case "o3-2025-04-16":
    case "o3-mini":
    case "o3-mini-2025-01-31":
    case "o4-mini":
    case "o4-mini-2025-04-16":
    case "chatgpt-4o-latest":
    case "gpt-4o-realtime":
    case "gpt-4o-realtime-preview-2024-10-01":
    case "gpt-4o-realtime-preview-2024-12-17":
    case "gpt-4o-mini-realtime-preview":
    case "gpt-4o-mini-realtime-preview-2024-12-17":
    case "gpt-4.1":
    case "gpt-4.1-2025-04-14":
    case "gpt-4.1-mini":
    case "gpt-4.1-mini-2025-04-14":
    case "gpt-4.1-nano":
    case "gpt-4.1-nano-2025-04-14":
    case "gpt-4.5-preview":
    case "gpt-4.5-preview-2025-02-27":
    case "gpt-5":
    case "gpt-5-2025-08-07":
    case "gpt-5-nano":
    case "gpt-5-nano-2025-08-07":
    case "gpt-5-mini":
    case "gpt-5-mini-2025-08-07":
    case "gpt-5-chat-latest":
      return "o200k_base";
    default:
      throw Error("Unknown model");
  }
}
__name(hz, "hz");
var Ky = {};
Z6(Ky, { encodingForModel: /* @__PURE__ */ __name(() => Py, "encodingForModel"), getEncoding: /* @__PURE__ */ __name(() => Ez, "getEncoding") });
var k5 = {};
var _y = new CP({});
async function Ez($) {
  if (!($ in k5)) k5[$] = _y.fetch(`https://tiktoken.pages.dev/js/${$}.json`).then((q) => q.json()).then((q) => new A5(q)).catch((q) => {
    throw delete k5[$], q;
  });
  return await k5[$];
}
__name(Ez, "Ez");
async function Py($) {
  return Ez(hz($));
}
__name(Py, "Py");
var _a50;
var oA = (_a50 = class extends M7 {
  lc_namespace = ["langchain", "document_transformers", "text_splitters"];
  chunkSize = 1e3;
  chunkOverlap = 200;
  keepSeparator = false;
  lengthFunction;
  constructor($) {
    super($);
    if (this.chunkSize = $?.chunkSize ?? this.chunkSize, this.chunkOverlap = $?.chunkOverlap ?? this.chunkOverlap, this.keepSeparator = $?.keepSeparator ?? this.keepSeparator, this.lengthFunction = $?.lengthFunction ?? ((q) => q.length), this.chunkOverlap >= this.chunkSize) throw Error("Cannot have chunkOverlap >= chunkSize");
  }
  async transformDocuments($, q = {}) {
    return this.splitDocuments($, q);
  }
  splitOnSeparator($, q) {
    let K;
    if (q) if (this.keepSeparator) {
      let P = q.replace(/[/\-\\^$*+?.()|[\]{}]/g, "\\$&");
      K = $.split(new RegExp(`(?=${P})`));
    } else K = $.split(q);
    else K = $.split("");
    return K.filter((P) => P !== "");
  }
  async createDocuments($, q = [], K = {}) {
    let P = q.length > 0 ? q : [...Array($.length)].map(() => ({})), { chunkHeader: _ = "", chunkOverlapHeader: Y = "(cont'd) ", appendChunkOverlapHeader: O = false } = K, z = [];
    for (let J = 0; J < $.length; J += 1) {
      let T = $[J], X = 1, f = null, V = -1;
      for (let M of await this.splitText(T)) {
        let N = _, E = T.indexOf(M, V + 1);
        if (f === null) {
          let g = this.numberOfNewLines(T, 0, E);
          X += g;
        } else {
          let g = V + await this.lengthFunction(f);
          if (g < E) {
            let b = this.numberOfNewLines(T, g, E);
            X += b;
          } else if (g > E) {
            let b = this.numberOfNewLines(T, E, g);
            X -= b;
          }
          if (O) N += Y;
        }
        let h = this.numberOfNewLines(M), I = P[J].loc && typeof P[J].loc === "object" ? { ...P[J].loc } : {};
        I.lines = { from: X, to: X + h };
        let D = { ...P[J], loc: I };
        N += M, z.push(new H1({ pageContent: N, metadata: D })), X += h, f = M, V = E;
      }
    }
    return z;
  }
  numberOfNewLines($, q, K) {
    return ($.slice(q, K).match(/\n/g) || []).length;
  }
  async splitDocuments($, q = {}) {
    let K = $.filter((Y) => Y.pageContent !== void 0), P = K.map((Y) => Y.pageContent), _ = K.map((Y) => Y.metadata);
    return this.createDocuments(P, _, q);
  }
  joinDocs($, q) {
    let K = $.join(q).trim();
    return K === "" ? null : K;
  }
  async mergeSplits($, q) {
    let K = [], P = [], _ = 0;
    for (let O of $) {
      let z = await this.lengthFunction(O);
      if (_ + z + P.length * q.length > this.chunkSize) {
        if (_ > this.chunkSize) console.warn(`Created a chunk of size ${_}, +
which is longer than the specified ${this.chunkSize}`);
        if (P.length > 0) {
          let J = this.joinDocs(P, q);
          if (J !== null) K.push(J);
          while (_ > this.chunkOverlap || _ + z + P.length * q.length > this.chunkSize && _ > 0) _ -= await this.lengthFunction(P[0]), P.shift();
        }
      }
      P.push(O), _ += z;
    }
    let Y = this.joinDocs(P, q);
    if (Y !== null) K.push(Y);
    return K;
  }
}, __name(_a50, "oA"), _a50);
var _a51;
var Rz = (_a51 = class extends oA {
  static lc_name() {
    return "RecursiveCharacterTextSplitter";
  }
  separators = [`

`, `
`, " ", ""];
  constructor(q) {
    super(q);
    this.separators = q?.separators ?? this.separators, this.keepSeparator = q?.keepSeparator ?? true;
  }
  async _splitText(q, K) {
    let P = [], _ = K[K.length - 1], Y;
    for (let T = 0; T < K.length; T += 1) {
      let X = K[T];
      if (X === "") {
        _ = X;
        break;
      }
      if (q.includes(X)) {
        _ = X, Y = K.slice(T + 1);
        break;
      }
    }
    let O = this.splitOnSeparator(q, _), z = [], J = this.keepSeparator ? "" : _;
    for (let T of O) if (await this.lengthFunction(T) < this.chunkSize) z.push(T);
    else {
      if (z.length) {
        let X = await this.mergeSplits(z, J);
        P.push(...X), z = [];
      }
      if (!Y) P.push(T);
      else {
        let X = await this._splitText(T, Y);
        P.push(...X);
      }
    }
    if (z.length) {
      let T = await this.mergeSplits(z, J);
      P.push(...T);
    }
    return P;
  }
  async splitText(q) {
    return this._splitText(q, this.separators);
  }
  static fromLanguage(q, K) {
    return new _a51({ ...K, separators: _a51.getSeparatorsForLanguage(q) });
  }
  static getSeparatorsForLanguage(q) {
    if (q === "cpp") return [`
class `, `
void `, `
int `, `
float `, `
double `, `
if `, `
for `, `
while `, `
switch `, `
case `, `

`, `
`, " ", ""];
    else if (q === "go") return [`
func `, `
var `, `
const `, `
type `, `
if `, `
for `, `
switch `, `
case `, `

`, `
`, " ", ""];
    else if (q === "java") return [`
class `, `
public `, `
protected `, `
private `, `
static `, `
if `, `
for `, `
while `, `
switch `, `
case `, `

`, `
`, " ", ""];
    else if (q === "js") return [`
function `, `
const `, `
let `, `
var `, `
class `, `
if `, `
for `, `
while `, `
switch `, `
case `, `
default `, `

`, `
`, " ", ""];
    else if (q === "php") return [`
function `, `
class `, `
if `, `
foreach `, `
while `, `
do `, `
switch `, `
case `, `

`, `
`, " ", ""];
    else if (q === "proto") return [`
message `, `
service `, `
enum `, `
option `, `
import `, `
syntax `, `

`, `
`, " ", ""];
    else if (q === "python") return [`
class `, `
def `, `
	def `, `

`, `
`, " ", ""];
    else if (q === "rst") return [`
===
`, `
---
`, `
***
`, `
.. `, `

`, `
`, " ", ""];
    else if (q === "ruby") return [`
def `, `
class `, `
if `, `
unless `, `
while `, `
for `, `
do `, `
begin `, `
rescue `, `

`, `
`, " ", ""];
    else if (q === "rust") return [`
fn `, `
const `, `
let `, `
if `, `
while `, `
for `, `
loop `, `
match `, `
const `, `

`, `
`, " ", ""];
    else if (q === "scala") return [`
class `, `
object `, `
def `, `
val `, `
var `, `
if `, `
for `, `
while `, `
match `, `
case `, `

`, `
`, " ", ""];
    else if (q === "swift") return [`
func `, `
class `, `
struct `, `
enum `, `
if `, `
for `, `
while `, `
do `, `
switch `, `
case `, `

`, `
`, " ", ""];
    else if (q === "markdown") return [`
## `, `
### `, `
#### `, `
##### `, `
###### `, "```\n\n", `

***

`, `

---

`, `

___

`, `

`, `
`, " ", ""];
    else if (q === "latex") return [`
\\chapter{`, `
\\section{`, `
\\subsection{`, `
\\subsubsection{`, `
\\begin{enumerate}`, `
\\begin{itemize}`, `
\\begin{description}`, `
\\begin{list}`, `
\\begin{quote}`, `
\\begin{quotation}`, `
\\begin{verse}`, `
\\begin{verbatim}`, `
\\begin{align}`, "$$", "$", `

`, `
`, " ", ""];
    else if (q === "html") return ["<body>", "<div>", "<p>", "<br>", "<li>", "<h1>", "<h2>", "<h3>", "<h4>", "<h5>", "<h6>", "<span>", "<table>", "<tr>", "<td>", "<th>", "<ul>", "<ol>", "<header>", "<footer>", "<nav>", "<head>", "<style>", "<script>", "<meta>", "<title>", " ", ""];
    else if (q === "sol") return [`
pragma `, `
using `, `
contract `, `
interface `, `
library `, `
constructor `, `
type `, `
function `, `
event `, `
modifier `, `
error `, `
struct `, `
enum `, `
if `, `
for `, `
while `, `
do while `, `
assembly `, `

`, `
`, " ", ""];
    else throw Error(`Language ${q} is not supported.`);
  }
}, __name(_a51, "$"), _a51);
var hJ = K8(FG(), 1);
var aG = /* @__PURE__ */ __name(($) => {
  $ = 1831565813 + ($ |= 0) | 0;
  let q = Math.imul($ ^ $ >>> 15, 1 | $);
  return q = q + Math.imul(q ^ q >>> 7, 61 | q) ^ q, ((q ^ q >>> 14) >>> 0) / 4294967296;
}, "aG");
var _eG = class _eG {
  constructor($) {
    this.dictionaries = void 0, this.length = void 0, this.separator = void 0, this.style = void 0, this.seed = void 0;
    let { length: q, separator: K, dictionaries: P, style: _, seed: Y } = $;
    this.dictionaries = P, this.separator = K, this.length = q, this.style = _, this.seed = Y;
  }
  generate() {
    if (!this.dictionaries) throw Error('Cannot find any dictionary. Please provide at least one, or leave the "dictionary" field empty in the config object');
    if (this.length <= 0) throw Error("Invalid length provided");
    if (this.length > this.dictionaries.length) throw Error(`The length cannot be bigger than the number of dictionaries.
Length provided: ${this.length}. Number of dictionaries provided: ${this.dictionaries.length}`);
    let $ = this.seed;
    return this.dictionaries.slice(0, this.length).reduce((q, K) => {
      let P;
      $ ? (P = ((Y) => {
        if (typeof Y == "string") {
          let O = Y.split("").map((J) => J.charCodeAt(0)).reduce((J, T) => J + T, 1), z = Math.floor(Number(O));
          return aG(z);
        }
        return aG(Y);
      })($), $ = 4294967296 * P) : P = Math.random();
      let _ = K[Math.floor(P * K.length)] || "";
      if (this.style === "lowerCase") _ = _.toLowerCase();
      else if (this.style === "capital") {
        let [Y, ...O] = _.split("");
        _ = Y.toUpperCase() + O.join("");
      } else this.style === "upperCase" && (_ = _.toUpperCase());
      return q ? `${q}${this.separator}${_}` : `${_}`;
    }, "");
  }
};
__name(_eG, "eG");
var eG = _eG;
var QG = { separator: "_", dictionaries: [] };
var g5 = /* @__PURE__ */ __name(($) => {
  let q = [...$ && $.dictionaries || QG.dictionaries], K = { ...QG, ...$, length: $ && $.length || q.length, dictionaries: q };
  if (!$ || !$.dictionaries || !$.dictionaries.length) throw Error('A "dictionaries" array must be provided. This is a breaking change introduced starting from Unique Name Generator v4. Read more about the breaking change here: https://github.com/andreasonny83/unique-names-generator#migration-guide');
  return new eG(K).generate();
}, "g5");
var b5 = ["Aaren", "Aarika", "Abagael", "Abagail", "Abbe", "Abbey", "Abbi", "Abbie", "Abby", "Abbye", "Abigael", "Abigail", "Abigale", "Abra", "Ada", "Adah", "Adaline", "Adan", "Adara", "Adda", "Addi", "Addia", "Addie", "Addy", "Adel", "Adela", "Adelaida", "Adelaide", "Adele", "Adelheid", "Adelice", "Adelina", "Adelind", "Adeline", "Adella", "Adelle", "Adena", "Adey", "Adi", "Adiana", "Adina", "Adora", "Adore", "Adoree", "Adorne", "Adrea", "Adria", "Adriaens", "Adrian", "Adriana", "Adriane", "Adrianna", "Adrianne", "Adriena", "Adrienne", "Aeriel", "Aeriela", "Aeriell", "Afton", "Ag", "Agace", "Agata", "Agatha", "Agathe", "Aggi", "Aggie", "Aggy", "Agna", "Agnella", "Agnes", "Agnese", "Agnesse", "Agneta", "Agnola", "Agretha", "Aida", "Aidan", "Aigneis", "Aila", "Aile", "Ailee", "Aileen", "Ailene", "Ailey", "Aili", "Ailina", "Ailis", "Ailsun", "Ailyn", "Aime", "Aimee", "Aimil", "Aindrea", "Ainslee", "Ainsley", "Ainslie", "Ajay", "Alaine", "Alameda", "Alana", "Alanah", "Alane", "Alanna", "Alayne", "Alberta", "Albertina", "Albertine", "Albina", "Alecia", "Aleda", "Aleece", "Aleen", "Alejandra", "Alejandrina", "Alena", "Alene", "Alessandra", "Aleta", "Alethea", "Alex", "Alexa", "Alexandra", "Alexandrina", "Alexi", "Alexia", "Alexina", "Alexine", "Alexis", "Alfi", "Alfie", "Alfreda", "Alfy", "Ali", "Alia", "Alica", "Alice", "Alicea", "Alicia", "Alida", "Alidia", "Alie", "Alika", "Alikee", "Alina", "Aline", "Alis", "Alisa", "Alisha", "Alison", "Alissa", "Alisun", "Alix", "Aliza", "Alla", "Alleen", "Allegra", "Allene", "Alli", "Allianora", "Allie", "Allina", "Allis", "Allison", "Allissa", "Allix", "Allsun", "Allx", "Ally", "Allyce", "Allyn", "Allys", "Allyson", "Alma", "Almeda", "Almeria", "Almeta", "Almira", "Almire", "Aloise", "Aloisia", "Aloysia", "Alta", "Althea", "Alvera", "Alverta", "Alvina", "Alvinia", "Alvira", "Alyce", "Alyda", "Alys", "Alysa", "Alyse", "Alysia", "Alyson", "Alyss", "Alyssa", "Amabel", "Amabelle", "Amalea", "Amalee", "Amaleta", "Amalia", "Amalie", "Amalita", "Amalle", "Amanda", "Amandi", "Amandie", "Amandy", "Amara", "Amargo", "Amata", "Amber", "Amberly", "Ambur", "Ame", "Amelia", "Amelie", "Amelina", "Ameline", "Amelita", "Ami", "Amie", "Amii", "Amil", "Amitie", "Amity", "Ammamaria", "Amy", "Amye", "Ana", "Anabal", "Anabel", "Anabella", "Anabelle", "Analiese", "Analise", "Anallese", "Anallise", "Anastasia", "Anastasie", "Anastassia", "Anatola", "Andee", "Andeee", "Anderea", "Andi", "Andie", "Andra", "Andrea", "Andreana", "Andree", "Andrei", "Andria", "Andriana", "Andriette", "Andromache", "Andy", "Anestassia", "Anet", "Anett", "Anetta", "Anette", "Ange", "Angel", "Angela", "Angele", "Angelia", "Angelica", "Angelika", "Angelina", "Angeline", "Angelique", "Angelita", "Angelle", "Angie", "Angil", "Angy", "Ania", "Anica", "Anissa", "Anita", "Anitra", "Anjanette", "Anjela", "Ann", "Ann-marie", "Anna", "Anna-diana", "Anna-diane", "Anna-maria", "Annabal", "Annabel", "Annabela", "Annabell", "Annabella", "Annabelle", "Annadiana", "Annadiane", "Annalee", "Annaliese", "Annalise", "Annamaria", "Annamarie", "Anne", "Anne-corinne", "Anne-marie", "Annecorinne", "Anneliese", "Annelise", "Annemarie", "Annetta", "Annette", "Anni", "Annice", "Annie", "Annis", "Annissa", "Annmaria", "Annmarie", "Annnora", "Annora", "Anny", "Anselma", "Ansley", "Anstice", "Anthe", "Anthea", "Anthia", "Anthiathia", "Antoinette", "Antonella", "Antonetta", "Antonia", "Antonie", "Antonietta", "Antonina", "Anya", "Appolonia", "April", "Aprilette", "Ara", "Arabel", "Arabela", "Arabele", "Arabella", "Arabelle", "Arda", "Ardath", "Ardeen", "Ardelia", "Ardelis", "Ardella", "Ardelle", "Arden", "Ardene", "Ardenia", "Ardine", "Ardis", "Ardisj", "Ardith", "Ardra", "Ardyce", "Ardys", "Ardyth", "Aretha", "Ariadne", "Ariana", "Aridatha", "Ariel", "Ariela", "Ariella", "Arielle", "Arlana", "Arlee", "Arleen", "Arlen", "Arlena", "Arlene", "Arleta", "Arlette", "Arleyne", "Arlie", "Arliene", "Arlina", "Arlinda", "Arline", "Arluene", "Arly", "Arlyn", "Arlyne", "Aryn", "Ashely", "Ashia", "Ashien", "Ashil", "Ashla", "Ashlan", "Ashlee", "Ashleigh", "Ashlen", "Ashley", "Ashli", "Ashlie", "Ashly", "Asia", "Astra", "Astrid", "Astrix", "Atalanta", "Athena", "Athene", "Atlanta", "Atlante", "Auberta", "Aubine", "Aubree", "Aubrette", "Aubrey", "Aubrie", "Aubry", "Audi", "Audie", "Audra", "Audre", "Audrey", "Audrie", "Audry", "Audrye", "Audy", "Augusta", "Auguste", "Augustina", "Augustine", "Aundrea", "Aura", "Aurea", "Aurel", "Aurelea", "Aurelia", "Aurelie", "Auria", "Aurie", "Aurilia", "Aurlie", "Auroora", "Aurora", "Aurore", "Austin", "Austina", "Austine", "Ava", "Aveline", "Averil", "Averyl", "Avie", "Avis", "Aviva", "Avivah", "Avril", "Avrit", "Ayn", "Bab", "Babara", "Babb", "Babbette", "Babbie", "Babette", "Babita", "Babs", "Bambi", "Bambie", "Bamby", "Barb", "Barbabra", "Barbara", "Barbara-anne", "Barbaraanne", "Barbe", "Barbee", "Barbette", "Barbey", "Barbi", "Barbie", "Barbra", "Barby", "Bari", "Barrie", "Barry", "Basia", "Bathsheba", "Batsheva", "Bea", "Beatrice", "Beatrisa", "Beatrix", "Beatriz", "Bebe", "Becca", "Becka", "Becki", "Beckie", "Becky", "Bee", "Beilul", "Beitris", "Bekki", "Bel", "Belia", "Belicia", "Belinda", "Belita", "Bell", "Bella", "Bellanca", "Belle", "Bellina", "Belva", "Belvia", "Bendite", "Benedetta", "Benedicta", "Benedikta", "Benetta", "Benita", "Benni", "Bennie", "Benny", "Benoite", "Berenice", "Beret", "Berget", "Berna", "Bernadene", "Bernadette", "Bernadina", "Bernadine", "Bernardina", "Bernardine", "Bernelle", "Bernete", "Bernetta", "Bernette", "Berni", "Bernice", "Bernie", "Bernita", "Berny", "Berri", "Berrie", "Berry", "Bert", "Berta", "Berte", "Bertha", "Berthe", "Berti", "Bertie", "Bertina", "Bertine", "Berty", "Beryl", "Beryle", "Bess", "Bessie", "Bessy", "Beth", "Bethanne", "Bethany", "Bethena", "Bethina", "Betsey", "Betsy", "Betta", "Bette", "Bette-ann", "Betteann", "Betteanne", "Betti", "Bettina", "Bettine", "Betty", "Bettye", "Beulah", "Bev", "Beverie", "Beverlee", "Beverley", "Beverlie", "Beverly", "Bevvy", "Bianca", "Bianka", "Bibbie", "Bibby", "Bibbye", "Bibi", "Biddie", "Biddy", "Bidget", "Bili", "Bill", "Billi", "Billie", "Billy", "Billye", "Binni", "Binnie", "Binny", "Bird", "Birdie", "Birgit", "Birgitta", "Blair", "Blaire", "Blake", "Blakelee", "Blakeley", "Blanca", "Blanch", "Blancha", "Blanche", "Blinni", "Blinnie", "Blinny", "Bliss", "Blisse", "Blithe", "Blondell", "Blondelle", "Blondie", "Blondy", "Blythe", "Bobbe", "Bobbee", "Bobbette", "Bobbi", "Bobbie", "Bobby", "Bobbye", "Bobette", "Bobina", "Bobine", "Bobinette", "Bonita", "Bonnee", "Bonni", "Bonnibelle", "Bonnie", "Bonny", "Brana", "Brandais", "Brande", "Brandea", "Brandi", "Brandice", "Brandie", "Brandise", "Brandy", "Breanne", "Brear", "Bree", "Breena", "Bren", "Brena", "Brenda", "Brenn", "Brenna", "Brett", "Bria", "Briana", "Brianna", "Brianne", "Bride", "Bridget", "Bridgette", "Bridie", "Brier", "Brietta", "Brigid", "Brigida", "Brigit", "Brigitta", "Brigitte", "Brina", "Briney", "Brinn", "Brinna", "Briny", "Brit", "Brita", "Britney", "Britni", "Britt", "Britta", "Brittan", "Brittaney", "Brittani", "Brittany", "Britte", "Britteny", "Brittne", "Brittney", "Brittni", "Brook", "Brooke", "Brooks", "Brunhilda", "Brunhilde", "Bryana", "Bryn", "Bryna", "Brynn", "Brynna", "Brynne", "Buffy", "Bunni", "Bunnie", "Bunny", "Cacilia", "Cacilie", "Cahra", "Cairistiona", "Caitlin", "Caitrin", "Cal", "Calida", "Calla", "Calley", "Calli", "Callida", "Callie", "Cally", "Calypso", "Cam", "Camala", "Camel", "Camella", "Camellia", "Cami", "Camila", "Camile", "Camilla", "Camille", "Cammi", "Cammie", "Cammy", "Candace", "Candi", "Candice", "Candida", "Candide", "Candie", "Candis", "Candra", "Candy", "Caprice", "Cara", "Caralie", "Caren", "Carena", "Caresa", "Caressa", "Caresse", "Carey", "Cari", "Caria", "Carie", "Caril", "Carilyn", "Carin", "Carina", "Carine", "Cariotta", "Carissa", "Carita", "Caritta", "Carla", "Carlee", "Carleen", "Carlen", "Carlene", "Carley", "Carlie", "Carlin", "Carlina", "Carline", "Carlita", "Carlota", "Carlotta", "Carly", "Carlye", "Carlyn", "Carlynn", "Carlynne", "Carma", "Carmel", "Carmela", "Carmelia", "Carmelina", "Carmelita", "Carmella", "Carmelle", "Carmen", "Carmencita", "Carmina", "Carmine", "Carmita", "Carmon", "Caro", "Carol", "Carol-jean", "Carola", "Carolan", "Carolann", "Carole", "Carolee", "Carolin", "Carolina", "Caroline", "Caroljean", "Carolyn", "Carolyne", "Carolynn", "Caron", "Carree", "Carri", "Carrie", "Carrissa", "Carroll", "Carry", "Cary", "Caryl", "Caryn", "Casandra", "Casey", "Casi", "Casie", "Cass", "Cassandra", "Cassandre", "Cassandry", "Cassaundra", "Cassey", "Cassi", "Cassie", "Cassondra", "Cassy", "Catarina", "Cate", "Caterina", "Catha", "Catharina", "Catharine", "Cathe", "Cathee", "Catherin", "Catherina", "Catherine", "Cathi", "Cathie", "Cathleen", "Cathlene", "Cathrin", "Cathrine", "Cathryn", "Cathy", "Cathyleen", "Cati", "Catie", "Catina", "Catlaina", "Catlee", "Catlin", "Catrina", "Catriona", "Caty", "Caye", "Cayla", "Cecelia", "Cecil", "Cecile", "Ceciley", "Cecilia", "Cecilla", "Cecily", "Ceil", "Cele", "Celene", "Celesta", "Celeste", "Celestia", "Celestina", "Celestine", "Celestyn", "Celestyna", "Celia", "Celie", "Celina", "Celinda", "Celine", "Celinka", "Celisse", "Celka", "Celle", "Cesya", "Chad", "Chanda", "Chandal", "Chandra", "Channa", "Chantal", "Chantalle", "Charil", "Charin", "Charis", "Charissa", "Charisse", "Charita", "Charity", "Charla", "Charlean", "Charleen", "Charlena", "Charlene", "Charline", "Charlot", "Charlotta", "Charlotte", "Charmain", "Charmaine", "Charmane", "Charmian", "Charmine", "Charmion", "Charo", "Charyl", "Chastity", "Chelsae", "Chelsea", "Chelsey", "Chelsie", "Chelsy", "Cher", "Chere", "Cherey", "Cheri", "Cherianne", "Cherice", "Cherida", "Cherie", "Cherilyn", "Cherilynn", "Cherin", "Cherise", "Cherish", "Cherlyn", "Cherri", "Cherrita", "Cherry", "Chery", "Cherye", "Cheryl", "Cheslie", "Chiarra", "Chickie", "Chicky", "Chiquia", "Chiquita", "Chlo", "Chloe", "Chloette", "Chloris", "Chris", "Chrissie", "Chrissy", "Christa", "Christabel", "Christabella", "Christal", "Christalle", "Christan", "Christean", "Christel", "Christen", "Christi", "Christian", "Christiana", "Christiane", "Christie", "Christin", "Christina", "Christine", "Christy", "Christye", "Christyna", "Chrysa", "Chrysler", "Chrystal", "Chryste", "Chrystel", "Cicely", "Cicily", "Ciel", "Cilka", "Cinda", "Cindee", "Cindelyn", "Cinderella", "Cindi", "Cindie", "Cindra", "Cindy", "Cinnamon", "Cissiee", "Cissy", "Clair", "Claire", "Clara", "Clarabelle", "Clare", "Claresta", "Clareta", "Claretta", "Clarette", "Clarey", "Clari", "Claribel", "Clarice", "Clarie", "Clarinda", "Clarine", "Clarissa", "Clarisse", "Clarita", "Clary", "Claude", "Claudelle", "Claudetta", "Claudette", "Claudia", "Claudie", "Claudina", "Claudine", "Clea", "Clem", "Clemence", "Clementia", "Clementina", "Clementine", "Clemmie", "Clemmy", "Cleo", "Cleopatra", "Clerissa", "Clio", "Clo", "Cloe", "Cloris", "Clotilda", "Clovis", "Codee", "Codi", "Codie", "Cody", "Coleen", "Colene", "Coletta", "Colette", "Colleen", "Collen", "Collete", "Collette", "Collie", "Colline", "Colly", "Con", "Concettina", "Conchita", "Concordia", "Conni", "Connie", "Conny", "Consolata", "Constance", "Constancia", "Constancy", "Constanta", "Constantia", "Constantina", "Constantine", "Consuela", "Consuelo", "Cookie", "Cora", "Corabel", "Corabella", "Corabelle", "Coral", "Coralie", "Coraline", "Coralyn", "Cordelia", "Cordelie", "Cordey", "Cordi", "Cordie", "Cordula", "Cordy", "Coreen", "Corella", "Corenda", "Corene", "Coretta", "Corette", "Corey", "Cori", "Corie", "Corilla", "Corina", "Corine", "Corinna", "Corinne", "Coriss", "Corissa", "Corliss", "Corly", "Cornela", "Cornelia", "Cornelle", "Cornie", "Corny", "Correna", "Correy", "Corri", "Corrianne", "Corrie", "Corrina", "Corrine", "Corrinne", "Corry", "Cortney", "Cory", "Cosetta", "Cosette", "Costanza", "Courtenay", "Courtnay", "Courtney", "Crin", "Cris", "Crissie", "Crissy", "Crista", "Cristabel", "Cristal", "Cristen", "Cristi", "Cristie", "Cristin", "Cristina", "Cristine", "Cristionna", "Cristy", "Crysta", "Crystal", "Crystie", "Cthrine", "Cyb", "Cybil", "Cybill", "Cymbre", "Cynde", "Cyndi", "Cyndia", "Cyndie", "Cyndy", "Cynthea", "Cynthia", "Cynthie", "Cynthy", "Dacey", "Dacia", "Dacie", "Dacy", "Dael", "Daffi", "Daffie", "Daffy", "Dagmar", "Dahlia", "Daile", "Daisey", "Daisi", "Daisie", "Daisy", "Dale", "Dalenna", "Dalia", "Dalila", "Dallas", "Daloris", "Damara", "Damaris", "Damita", "Dana", "Danell", "Danella", "Danette", "Dani", "Dania", "Danica", "Danice", "Daniela", "Daniele", "Daniella", "Danielle", "Danika", "Danila", "Danit", "Danita", "Danna", "Danni", "Dannie", "Danny", "Dannye", "Danya", "Danyelle", "Danyette", "Daphene", "Daphna", "Daphne", "Dara", "Darb", "Darbie", "Darby", "Darcee", "Darcey", "Darci", "Darcie", "Darcy", "Darda", "Dareen", "Darell", "Darelle", "Dari", "Daria", "Darice", "Darla", "Darleen", "Darlene", "Darline", "Darlleen", "Daron", "Darrelle", "Darryl", "Darsey", "Darsie", "Darya", "Daryl", "Daryn", "Dasha", "Dasi", "Dasie", "Dasya", "Datha", "Daune", "Daveen", "Daveta", "Davida", "Davina", "Davine", "Davita", "Dawn", "Dawna", "Dayle", "Dayna", "Ddene", "De", "Deana", "Deane", "Deanna", "Deanne", "Deb", "Debbi", "Debbie", "Debby", "Debee", "Debera", "Debi", "Debor", "Debora", "Deborah", "Debra", "Dede", "Dedie", "Dedra", "Dee", "Deeann", "Deeanne", "Deedee", "Deena", "Deerdre", "Deeyn", "Dehlia", "Deidre", "Deina", "Deirdre", "Del", "Dela", "Delcina", "Delcine", "Delia", "Delila", "Delilah", "Delinda", "Dell", "Della", "Delly", "Delora", "Delores", "Deloria", "Deloris", "Delphine", "Delphinia", "Demeter", "Demetra", "Demetria", "Demetris", "Dena", "Deni", "Denice", "Denise", "Denna", "Denni", "Dennie", "Denny", "Deny", "Denys", "Denyse", "Deonne", "Desdemona", "Desirae", "Desiree", "Desiri", "Deva", "Devan", "Devi", "Devin", "Devina", "Devinne", "Devon", "Devondra", "Devonna", "Devonne", "Devora", "Di", "Diahann", "Dian", "Diana", "Diandra", "Diane", "Diane-marie", "Dianemarie", "Diann", "Dianna", "Dianne", "Diannne", "Didi", "Dido", "Diena", "Dierdre", "Dina", "Dinah", "Dinnie", "Dinny", "Dion", "Dione", "Dionis", "Dionne", "Dita", "Dix", "Dixie", "Dniren", "Dode", "Dodi", "Dodie", "Dody", "Doe", "Doll", "Dolley", "Dolli", "Dollie", "Dolly", "Dolores", "Dolorita", "Doloritas", "Domeniga", "Dominga", "Domini", "Dominica", "Dominique", "Dona", "Donella", "Donelle", "Donetta", "Donia", "Donica", "Donielle", "Donna", "Donnamarie", "Donni", "Donnie", "Donny", "Dora", "Doralia", "Doralin", "Doralyn", "Doralynn", "Doralynne", "Dore", "Doreen", "Dorelia", "Dorella", "Dorelle", "Dorena", "Dorene", "Doretta", "Dorette", "Dorey", "Dori", "Doria", "Dorian", "Dorice", "Dorie", "Dorine", "Doris", "Dorisa", "Dorise", "Dorita", "Doro", "Dorolice", "Dorolisa", "Dorotea", "Doroteya", "Dorothea", "Dorothee", "Dorothy", "Dorree", "Dorri", "Dorrie", "Dorris", "Dorry", "Dorthea", "Dorthy", "Dory", "Dosi", "Dot", "Doti", "Dotti", "Dottie", "Dotty", "Dre", "Dreddy", "Dredi", "Drona", "Dru", "Druci", "Drucie", "Drucill", "Drucy", "Drusi", "Drusie", "Drusilla", "Drusy", "Dulce", "Dulcea", "Dulci", "Dulcia", "Dulciana", "Dulcie", "Dulcine", "Dulcinea", "Dulcy", "Dulsea", "Dusty", "Dyan", "Dyana", "Dyane", "Dyann", "Dyanna", "Dyanne", "Dyna", "Dynah", "Eachelle", "Eada", "Eadie", "Eadith", "Ealasaid", "Eartha", "Easter", "Eba", "Ebba", "Ebonee", "Ebony", "Eda", "Eddi", "Eddie", "Eddy", "Ede", "Edee", "Edeline", "Eden", "Edi", "Edie", "Edin", "Edita", "Edith", "Editha", "Edithe", "Ediva", "Edna", "Edwina", "Edy", "Edyth", "Edythe", "Effie", "Eileen", "Eilis", "Eimile", "Eirena", "Ekaterina", "Elaina", "Elaine", "Elana", "Elane", "Elayne", "Elberta", "Elbertina", "Elbertine", "Eleanor", "Eleanora", "Eleanore", "Electra", "Eleen", "Elena", "Elene", "Eleni", "Elenore", "Eleonora", "Eleonore", "Elfie", "Elfreda", "Elfrida", "Elfrieda", "Elga", "Elianora", "Elianore", "Elicia", "Elie", "Elinor", "Elinore", "Elisa", "Elisabet", "Elisabeth", "Elisabetta", "Elise", "Elisha", "Elissa", "Elita", "Eliza", "Elizabet", "Elizabeth", "Elka", "Elke", "Ella", "Elladine", "Elle", "Ellen", "Ellene", "Ellette", "Elli", "Ellie", "Ellissa", "Elly", "Ellyn", "Ellynn", "Elmira", "Elna", "Elnora", "Elnore", "Eloisa", "Eloise", "Elonore", "Elora", "Elsa", "Elsbeth", "Else", "Elset", "Elsey", "Elsi", "Elsie", "Elsinore", "Elspeth", "Elsy", "Elva", "Elvera", "Elvina", "Elvira", "Elwira", "Elyn", "Elyse", "Elysee", "Elysha", "Elysia", "Elyssa", "Em", "Ema", "Emalee", "Emalia", "Emelda", "Emelia", "Emelina", "Emeline", "Emelita", "Emelyne", "Emera", "Emilee", "Emili", "Emilia", "Emilie", "Emiline", "Emily", "Emlyn", "Emlynn", "Emlynne", "Emma", "Emmalee", "Emmaline", "Emmalyn", "Emmalynn", "Emmalynne", "Emmeline", "Emmey", "Emmi", "Emmie", "Emmy", "Emmye", "Emogene", "Emyle", "Emylee", "Engracia", "Enid", "Enrica", "Enrichetta", "Enrika", "Enriqueta", "Eolanda", "Eolande", "Eran", "Erda", "Erena", "Erica", "Ericha", "Ericka", "Erika", "Erin", "Erina", "Erinn", "Erinna", "Erma", "Ermengarde", "Ermentrude", "Ermina", "Erminia", "Erminie", "Erna", "Ernaline", "Ernesta", "Ernestine", "Ertha", "Eryn", "Esma", "Esmaria", "Esme", "Esmeralda", "Essa", "Essie", "Essy", "Esta", "Estel", "Estele", "Estell", "Estella", "Estelle", "Ester", "Esther", "Estrella", "Estrellita", "Ethel", "Ethelda", "Ethelin", "Ethelind", "Etheline", "Ethelyn", "Ethyl", "Etta", "Etti", "Ettie", "Etty", "Eudora", "Eugenia", "Eugenie", "Eugine", "Eula", "Eulalie", "Eunice", "Euphemia", "Eustacia", "Eva", "Evaleen", "Evangelia", "Evangelin", "Evangelina", "Evangeline", "Evania", "Evanne", "Eve", "Eveleen", "Evelina", "Eveline", "Evelyn", "Evey", "Evie", "Evita", "Evonne", "Evvie", "Evvy", "Evy", "Eyde", "Eydie", "Ezmeralda", "Fae", "Faina", "Faith", "Fallon", "Fan", "Fanchette", "Fanchon", "Fancie", "Fancy", "Fanechka", "Fania", "Fanni", "Fannie", "Fanny", "Fanya", "Fara", "Farah", "Farand", "Farica", "Farra", "Farrah", "Farrand", "Faun", "Faunie", "Faustina", "Faustine", "Fawn", "Fawne", "Fawnia", "Fay", "Faydra", "Faye", "Fayette", "Fayina", "Fayre", "Fayth", "Faythe", "Federica", "Fedora", "Felecia", "Felicdad", "Felice", "Felicia", "Felicity", "Felicle", "Felipa", "Felisha", "Felita", "Feliza", "Fenelia", "Feodora", "Ferdinanda", "Ferdinande", "Fern", "Fernanda", "Fernande", "Fernandina", "Ferne", "Fey", "Fiann", "Fianna", "Fidela", "Fidelia", "Fidelity", "Fifi", "Fifine", "Filia", "Filide", "Filippa", "Fina", "Fiona", "Fionna", "Fionnula", "Fiorenze", "Fleur", "Fleurette", "Flo", "Flor", "Flora", "Florance", "Flore", "Florella", "Florence", "Florencia", "Florentia", "Florenza", "Florette", "Flori", "Floria", "Florida", "Florie", "Florina", "Florinda", "Floris", "Florri", "Florrie", "Florry", "Flory", "Flossi", "Flossie", "Flossy", "Flss", "Fran", "Francene", "Frances", "Francesca", "Francine", "Francisca", "Franciska", "Francoise", "Francyne", "Frank", "Frankie", "Franky", "Franni", "Frannie", "Franny", "Frayda", "Fred", "Freda", "Freddi", "Freddie", "Freddy", "Fredelia", "Frederica", "Fredericka", "Frederique", "Fredi", "Fredia", "Fredra", "Fredrika", "Freida", "Frieda", "Friederike", "Fulvia", "Gabbey", "Gabbi", "Gabbie", "Gabey", "Gabi", "Gabie", "Gabriel", "Gabriela", "Gabriell", "Gabriella", "Gabrielle", "Gabriellia", "Gabrila", "Gaby", "Gae", "Gael", "Gail", "Gale", "Galina", "Garland", "Garnet", "Garnette", "Gates", "Gavra", "Gavrielle", "Gay", "Gaye", "Gayel", "Gayla", "Gayle", "Gayleen", "Gaylene", "Gaynor", "Gelya", "Gena", "Gene", "Geneva", "Genevieve", "Genevra", "Genia", "Genna", "Genni", "Gennie", "Gennifer", "Genny", "Genovera", "Genvieve", "George", "Georgeanna", "Georgeanne", "Georgena", "Georgeta", "Georgetta", "Georgette", "Georgia", "Georgiana", "Georgianna", "Georgianne", "Georgie", "Georgina", "Georgine", "Geralda", "Geraldine", "Gerda", "Gerhardine", "Geri", "Gerianna", "Gerianne", "Gerladina", "Germain", "Germaine", "Germana", "Gerri", "Gerrie", "Gerrilee", "Gerry", "Gert", "Gerta", "Gerti", "Gertie", "Gertrud", "Gertruda", "Gertrude", "Gertrudis", "Gerty", "Giacinta", "Giana", "Gianina", "Gianna", "Gigi", "Gilberta", "Gilberte", "Gilbertina", "Gilbertine", "Gilda", "Gilemette", "Gill", "Gillan", "Gilli", "Gillian", "Gillie", "Gilligan", "Gilly", "Gina", "Ginelle", "Ginevra", "Ginger", "Ginni", "Ginnie", "Ginnifer", "Ginny", "Giorgia", "Giovanna", "Gipsy", "Giralda", "Gisela", "Gisele", "Gisella", "Giselle", "Giuditta", "Giulia", "Giulietta", "Giustina", "Gizela", "Glad", "Gladi", "Gladys", "Gleda", "Glen", "Glenda", "Glenine", "Glenn", "Glenna", "Glennie", "Glennis", "Glori", "Gloria", "Gloriana", "Gloriane", "Glory", "Glyn", "Glynda", "Glynis", "Glynnis", "Gnni", "Godiva", "Golda", "Goldarina", "Goldi", "Goldia", "Goldie", "Goldina", "Goldy", "Grace", "Gracia", "Gracie", "Grata", "Gratia", "Gratiana", "Gray", "Grayce", "Grazia", "Greer", "Greta", "Gretal", "Gretchen", "Grete", "Gretel", "Grethel", "Gretna", "Gretta", "Grier", "Griselda", "Grissel", "Guendolen", "Guenevere", "Guenna", "Guglielma", "Gui", "Guillema", "Guillemette", "Guinevere", "Guinna", "Gunilla", "Gus", "Gusella", "Gussi", "Gussie", "Gussy", "Gusta", "Gusti", "Gustie", "Gusty", "Gwen", "Gwendolen", "Gwendolin", "Gwendolyn", "Gweneth", "Gwenette", "Gwenneth", "Gwenni", "Gwennie", "Gwenny", "Gwenora", "Gwenore", "Gwyn", "Gwyneth", "Gwynne", "Gypsy", "Hadria", "Hailee", "Haily", "Haleigh", "Halette", "Haley", "Hali", "Halie", "Halimeda", "Halley", "Halli", "Hallie", "Hally", "Hana", "Hanna", "Hannah", "Hanni", "Hannie", "Hannis", "Hanny", "Happy", "Harlene", "Harley", "Harli", "Harlie", "Harmonia", "Harmonie", "Harmony", "Harri", "Harrie", "Harriet", "Harriett", "Harrietta", "Harriette", "Harriot", "Harriott", "Hatti", "Hattie", "Hatty", "Hayley", "Hazel", "Heath", "Heather", "Heda", "Hedda", "Heddi", "Heddie", "Hedi", "Hedvig", "Hedvige", "Hedwig", "Hedwiga", "Hedy", "Heida", "Heidi", "Heidie", "Helaina", "Helaine", "Helen", "Helen-elizabeth", "Helena", "Helene", "Helenka", "Helga", "Helge", "Helli", "Heloise", "Helsa", "Helyn", "Hendrika", "Henka", "Henrie", "Henrieta", "Henrietta", "Henriette", "Henryetta", "Hephzibah", "Hermia", "Hermina", "Hermine", "Herminia", "Hermione", "Herta", "Hertha", "Hester", "Hesther", "Hestia", "Hetti", "Hettie", "Hetty", "Hilary", "Hilda", "Hildagard", "Hildagarde", "Hilde", "Hildegaard", "Hildegarde", "Hildy", "Hillary", "Hilliary", "Hinda", "Holli", "Hollie", "Holly", "Holly-anne", "Hollyanne", "Honey", "Honor", "Honoria", "Hope", "Horatia", "Hortense", "Hortensia", "Hulda", "Hyacinth", "Hyacintha", "Hyacinthe", "Hyacinthia", "Hyacinthie", "Hynda", "Ianthe", "Ibbie", "Ibby", "Ida", "Idalia", "Idalina", "Idaline", "Idell", "Idelle", "Idette", "Ileana", "Ileane", "Ilene", "Ilise", "Ilka", "Illa", "Ilsa", "Ilse", "Ilysa", "Ilyse", "Ilyssa", "Imelda", "Imogen", "Imogene", "Imojean", "Ina", "Indira", "Ines", "Inesita", "Inessa", "Inez", "Inga", "Ingaberg", "Ingaborg", "Inge", "Ingeberg", "Ingeborg", "Inger", "Ingrid", "Ingunna", "Inna", "Iolande", "Iolanthe", "Iona", "Iormina", "Ira", "Irena", "Irene", "Irina", "Iris", "Irita", "Irma", "Isa", "Isabel", "Isabelita", "Isabella", "Isabelle", "Isadora", "Isahella", "Iseabal", "Isidora", "Isis", "Isobel", "Issi", "Issie", "Issy", "Ivett", "Ivette", "Ivie", "Ivonne", "Ivory", "Ivy", "Izabel", "Jacenta", "Jacinda", "Jacinta", "Jacintha", "Jacinthe", "Jackelyn", "Jacki", "Jackie", "Jacklin", "Jacklyn", "Jackquelin", "Jackqueline", "Jacky", "Jaclin", "Jaclyn", "Jacquelin", "Jacqueline", "Jacquelyn", "Jacquelynn", "Jacquenetta", "Jacquenette", "Jacquetta", "Jacquette", "Jacqui", "Jacquie", "Jacynth", "Jada", "Jade", "Jaime", "Jaimie", "Jaine", "Jami", "Jamie", "Jamima", "Jammie", "Jan", "Jana", "Janaya", "Janaye", "Jandy", "Jane", "Janean", "Janeczka", "Janeen", "Janel", "Janela", "Janella", "Janelle", "Janene", "Janenna", "Janessa", "Janet", "Janeta", "Janetta", "Janette", "Janeva", "Janey", "Jania", "Janice", "Janie", "Janifer", "Janina", "Janine", "Janis", "Janith", "Janka", "Janna", "Jannel", "Jannelle", "Janot", "Jany", "Jaquelin", "Jaquelyn", "Jaquenetta", "Jaquenette", "Jaquith", "Jasmin", "Jasmina", "Jasmine", "Jayme", "Jaymee", "Jayne", "Jaynell", "Jazmin", "Jean", "Jeana", "Jeane", "Jeanelle", "Jeanette", "Jeanie", "Jeanine", "Jeanna", "Jeanne", "Jeannette", "Jeannie", "Jeannine", "Jehanna", "Jelene", "Jemie", "Jemima", "Jemimah", "Jemmie", "Jemmy", "Jen", "Jena", "Jenda", "Jenelle", "Jeni", "Jenica", "Jeniece", "Jenifer", "Jeniffer", "Jenilee", "Jenine", "Jenn", "Jenna", "Jennee", "Jennette", "Jenni", "Jennica", "Jennie", "Jennifer", "Jennilee", "Jennine", "Jenny", "Jeralee", "Jere", "Jeri", "Jermaine", "Jerrie", "Jerrilee", "Jerrilyn", "Jerrine", "Jerry", "Jerrylee", "Jess", "Jessa", "Jessalin", "Jessalyn", "Jessamine", "Jessamyn", "Jesse", "Jesselyn", "Jessi", "Jessica", "Jessie", "Jessika", "Jessy", "Jewel", "Jewell", "Jewelle", "Jill", "Jillana", "Jillane", "Jillayne", "Jilleen", "Jillene", "Jilli", "Jillian", "Jillie", "Jilly", "Jinny", "Jo", "Jo-ann", "Jo-anne", "Joan", "Joana", "Joane", "Joanie", "Joann", "Joanna", "Joanne", "Joannes", "Jobey", "Jobi", "Jobie", "Jobina", "Joby", "Jobye", "Jobyna", "Jocelin", "Joceline", "Jocelyn", "Jocelyne", "Jodee", "Jodi", "Jodie", "Jody", "Joeann", "Joela", "Joelie", "Joell", "Joella", "Joelle", "Joellen", "Joelly", "Joellyn", "Joelynn", "Joete", "Joey", "Johanna", "Johannah", "Johna", "Johnath", "Johnette", "Johnna", "Joice", "Jojo", "Jolee", "Joleen", "Jolene", "Joletta", "Joli", "Jolie", "Joline", "Joly", "Jolyn", "Jolynn", "Jonell", "Joni", "Jonie", "Jonis", "Jordain", "Jordan", "Jordana", "Jordanna", "Jorey", "Jori", "Jorie", "Jorrie", "Jorry", "Joscelin", "Josee", "Josefa", "Josefina", "Josepha", "Josephina", "Josephine", "Josey", "Josi", "Josie", "Josselyn", "Josy", "Jourdan", "Joy", "Joya", "Joyan", "Joyann", "Joyce", "Joycelin", "Joye", "Jsandye", "Juana", "Juanita", "Judi", "Judie", "Judith", "Juditha", "Judy", "Judye", "Juieta", "Julee", "Juli", "Julia", "Juliana", "Juliane", "Juliann", "Julianna", "Julianne", "Julie", "Julienne", "Juliet", "Julieta", "Julietta", "Juliette", "Julina", "Juline", "Julissa", "Julita", "June", "Junette", "Junia", "Junie", "Junina", "Justina", "Justine", "Justinn", "Jyoti", "Kacey", "Kacie", "Kacy", "Kaela", "Kai", "Kaia", "Kaila", "Kaile", "Kailey", "Kaitlin", "Kaitlyn", "Kaitlynn", "Kaja", "Kakalina", "Kala", "Kaleena", "Kali", "Kalie", "Kalila", "Kalina", "Kalinda", "Kalindi", "Kalli", "Kally", "Kameko", "Kamila", "Kamilah", "Kamillah", "Kandace", "Kandy", "Kania", "Kanya", "Kara", "Kara-lynn", "Karalee", "Karalynn", "Kare", "Karee", "Karel", "Karen", "Karena", "Kari", "Karia", "Karie", "Karil", "Karilynn", "Karin", "Karina", "Karine", "Kariotta", "Karisa", "Karissa", "Karita", "Karla", "Karlee", "Karleen", "Karlen", "Karlene", "Karlie", "Karlotta", "Karlotte", "Karly", "Karlyn", "Karmen", "Karna", "Karol", "Karola", "Karole", "Karolina", "Karoline", "Karoly", "Karon", "Karrah", "Karrie", "Karry", "Kary", "Karyl", "Karylin", "Karyn", "Kasey", "Kass", "Kassandra", "Kassey", "Kassi", "Kassia", "Kassie", "Kat", "Kata", "Katalin", "Kate", "Katee", "Katerina", "Katerine", "Katey", "Kath", "Katha", "Katharina", "Katharine", "Katharyn", "Kathe", "Katherina", "Katherine", "Katheryn", "Kathi", "Kathie", "Kathleen", "Kathlin", "Kathrine", "Kathryn", "Kathryne", "Kathy", "Kathye", "Kati", "Katie", "Katina", "Katine", "Katinka", "Katleen", "Katlin", "Katrina", "Katrine", "Katrinka", "Katti", "Kattie", "Katuscha", "Katusha", "Katy", "Katya", "Kay", "Kaycee", "Kaye", "Kayla", "Kayle", "Kaylee", "Kayley", "Kaylil", "Kaylyn", "Keeley", "Keelia", "Keely", "Kelcey", "Kelci", "Kelcie", "Kelcy", "Kelila", "Kellen", "Kelley", "Kelli", "Kellia", "Kellie", "Kellina", "Kellsie", "Kelly", "Kellyann", "Kelsey", "Kelsi", "Kelsy", "Kendra", "Kendre", "Kenna", "Keri", "Keriann", "Kerianne", "Kerri", "Kerrie", "Kerrill", "Kerrin", "Kerry", "Kerstin", "Kesley", "Keslie", "Kessia", "Kessiah", "Ketti", "Kettie", "Ketty", "Kevina", "Kevyn", "Ki", "Kiah", "Kial", "Kiele", "Kiersten", "Kikelia", "Kiley", "Kim", "Kimberlee", "Kimberley", "Kimberli", "Kimberly", "Kimberlyn", "Kimbra", "Kimmi", "Kimmie", "Kimmy", "Kinna", "Kip", "Kipp", "Kippie", "Kippy", "Kira", "Kirbee", "Kirbie", "Kirby", "Kiri", "Kirsten", "Kirsteni", "Kirsti", "Kirstin", "Kirstyn", "Kissee", "Kissiah", "Kissie", "Kit", "Kitti", "Kittie", "Kitty", "Kizzee", "Kizzie", "Klara", "Klarika", "Klarrisa", "Konstance", "Konstanze", "Koo", "Kora", "Koral", "Koralle", "Kordula", "Kore", "Korella", "Koren", "Koressa", "Kori", "Korie", "Korney", "Korrie", "Korry", "Kris", "Krissie", "Krissy", "Krista", "Kristal", "Kristan", "Kriste", "Kristel", "Kristen", "Kristi", "Kristien", "Kristin", "Kristina", "Kristine", "Kristy", "Kristyn", "Krysta", "Krystal", "Krystalle", "Krystle", "Krystyna", "Kyla", "Kyle", "Kylen", "Kylie", "Kylila", "Kylynn", "Kym", "Kynthia", "Kyrstin", "Lacee", "Lacey", "Lacie", "Lacy", "Ladonna", "Laetitia", "Laina", "Lainey", "Lana", "Lanae", "Lane", "Lanette", "Laney", "Lani", "Lanie", "Lanita", "Lanna", "Lanni", "Lanny", "Lara", "Laraine", "Lari", "Larina", "Larine", "Larisa", "Larissa", "Lark", "Laryssa", "Latashia", "Latia", "Latisha", "Latrena", "Latrina", "Laura", "Lauraine", "Laural", "Lauralee", "Laure", "Lauree", "Laureen", "Laurel", "Laurella", "Lauren", "Laurena", "Laurene", "Lauretta", "Laurette", "Lauri", "Laurianne", "Laurice", "Laurie", "Lauryn", "Lavena", "Laverna", "Laverne", "Lavina", "Lavinia", "Lavinie", "Layla", "Layne", "Layney", "Lea", "Leah", "Leandra", "Leann", "Leanna", "Leanor", "Leanora", "Lebbie", "Leda", "Lee", "Leeann", "Leeanne", "Leela", "Leelah", "Leena", "Leesa", "Leese", "Legra", "Leia", "Leigh", "Leigha", "Leila", "Leilah", "Leisha", "Lela", "Lelah", "Leland", "Lelia", "Lena", "Lenee", "Lenette", "Lenka", "Lenna", "Lenora", "Lenore", "Leodora", "Leoine", "Leola", "Leoline", "Leona", "Leonanie", "Leone", "Leonelle", "Leonie", "Leonora", "Leonore", "Leontine", "Leontyne", "Leora", "Leshia", "Lesley", "Lesli", "Leslie", "Lesly", "Lesya", "Leta", "Lethia", "Leticia", "Letisha", "Letitia", "Letizia", "Letta", "Letti", "Lettie", "Letty", "Lexi", "Lexie", "Lexine", "Lexis", "Lexy", "Leyla", "Lezlie", "Lia", "Lian", "Liana", "Liane", "Lianna", "Lianne", "Lib", "Libbey", "Libbi", "Libbie", "Libby", "Licha", "Lida", "Lidia", "Liesa", "Lil", "Lila", "Lilah", "Lilas", "Lilia", "Lilian", "Liliane", "Lilias", "Lilith", "Lilla", "Lilli", "Lillian", "Lillis", "Lilllie", "Lilly", "Lily", "Lilyan", "Lin", "Lina", "Lind", "Linda", "Lindi", "Lindie", "Lindsay", "Lindsey", "Lindsy", "Lindy", "Linea", "Linell", "Linet", "Linette", "Linn", "Linnea", "Linnell", "Linnet", "Linnie", "Linzy", "Lira", "Lisa", "Lisabeth", "Lisbeth", "Lise", "Lisetta", "Lisette", "Lisha", "Lishe", "Lissa", "Lissi", "Lissie", "Lissy", "Lita", "Liuka", "Liv", "Liva", "Livia", "Livvie", "Livvy", "Livvyy", "Livy", "Liz", "Liza", "Lizabeth", "Lizbeth", "Lizette", "Lizzie", "Lizzy", "Loella", "Lois", "Loise", "Lola", "Loleta", "Lolita", "Lolly", "Lona", "Lonee", "Loni", "Lonna", "Lonni", "Lonnie", "Lora", "Lorain", "Loraine", "Loralee", "Loralie", "Loralyn", "Loree", "Loreen", "Lorelei", "Lorelle", "Loren", "Lorena", "Lorene", "Lorenza", "Loretta", "Lorette", "Lori", "Loria", "Lorianna", "Lorianne", "Lorie", "Lorilee", "Lorilyn", "Lorinda", "Lorine", "Lorita", "Lorna", "Lorne", "Lorraine", "Lorrayne", "Lorri", "Lorrie", "Lorrin", "Lorry", "Lory", "Lotta", "Lotte", "Lotti", "Lottie", "Lotty", "Lou", "Louella", "Louisa", "Louise", "Louisette", "Loutitia", "Lu", "Luce", "Luci", "Lucia", "Luciana", "Lucie", "Lucienne", "Lucila", "Lucilia", "Lucille", "Lucina", "Lucinda", "Lucine", "Lucita", "Lucky", "Lucretia", "Lucy", "Ludovika", "Luella", "Luelle", "Luisa", "Luise", "Lula", "Lulita", "Lulu", "Lura", "Lurette", "Lurleen", "Lurlene", "Lurline", "Lusa", "Luz", "Lyda", "Lydia", "Lydie", "Lyn", "Lynda", "Lynde", "Lyndel", "Lyndell", "Lyndsay", "Lyndsey", "Lyndsie", "Lyndy", "Lynea", "Lynelle", "Lynett", "Lynette", "Lynn", "Lynna", "Lynne", "Lynnea", "Lynnell", "Lynnelle", "Lynnet", "Lynnett", "Lynnette", "Lynsey", "Lyssa", "Mab", "Mabel", "Mabelle", "Mable", "Mada", "Madalena", "Madalyn", "Maddalena", "Maddi", "Maddie", "Maddy", "Madel", "Madelaine", "Madeleine", "Madelena", "Madelene", "Madelin", "Madelina", "Madeline", "Madella", "Madelle", "Madelon", "Madelyn", "Madge", "Madlen", "Madlin", "Madonna", "Mady", "Mae", "Maegan", "Mag", "Magda", "Magdaia", "Magdalen", "Magdalena", "Magdalene", "Maggee", "Maggi", "Maggie", "Maggy", "Mahala", "Mahalia", "Maia", "Maible", "Maiga", "Maighdiln", "Mair", "Maire", "Maisey", "Maisie", "Maitilde", "Mala", "Malanie", "Malena", "Malia", "Malina", "Malinda", "Malinde", "Malissa", "Malissia", "Mallissa", "Mallorie", "Mallory", "Malorie", "Malory", "Malva", "Malvina", "Malynda", "Mame", "Mamie", "Manda", "Mandi", "Mandie", "Mandy", "Manon", "Manya", "Mara", "Marabel", "Marcela", "Marcelia", "Marcella", "Marcelle", "Marcellina", "Marcelline", "Marchelle", "Marci", "Marcia", "Marcie", "Marcile", "Marcille", "Marcy", "Mareah", "Maren", "Marena", "Maressa", "Marga", "Margalit", "Margalo", "Margaret", "Margareta", "Margarete", "Margaretha", "Margarethe", "Margaretta", "Margarette", "Margarita", "Margaux", "Marge", "Margeaux", "Margery", "Marget", "Margette", "Margi", "Margie", "Margit", "Margo", "Margot", "Margret", "Marguerite", "Margy", "Mari", "Maria", "Mariam", "Marian", "Mariana", "Mariann", "Marianna", "Marianne", "Maribel", "Maribelle", "Maribeth", "Marice", "Maridel", "Marie", "Marie-ann", "Marie-jeanne", "Marieann", "Mariejeanne", "Mariel", "Mariele", "Marielle", "Mariellen", "Marietta", "Mariette", "Marigold", "Marijo", "Marika", "Marilee", "Marilin", "Marillin", "Marilyn", "Marin", "Marina", "Marinna", "Marion", "Mariquilla", "Maris", "Marisa", "Mariska", "Marissa", "Marita", "Maritsa", "Mariya", "Marj", "Marja", "Marje", "Marji", "Marjie", "Marjorie", "Marjory", "Marjy", "Marketa", "Marla", "Marlane", "Marleah", "Marlee", "Marleen", "Marlena", "Marlene", "Marley", "Marlie", "Marline", "Marlo", "Marlyn", "Marna", "Marne", "Marney", "Marni", "Marnia", "Marnie", "Marquita", "Marrilee", "Marris", "Marrissa", "Marsha", "Marsiella", "Marta", "Martelle", "Martguerita", "Martha", "Marthe", "Marthena", "Marti", "Martica", "Martie", "Martina", "Martita", "Marty", "Martynne", "Mary", "Marya", "Maryann", "Maryanna", "Maryanne", "Marybelle", "Marybeth", "Maryellen", "Maryjane", "Maryjo", "Maryl", "Marylee", "Marylin", "Marylinda", "Marylou", "Marylynne", "Maryrose", "Marys", "Marysa", "Masha", "Matelda", "Mathilda", "Mathilde", "Matilda", "Matilde", "Matti", "Mattie", "Matty", "Maud", "Maude", "Maudie", "Maura", "Maure", "Maureen", "Maureene", "Maurene", "Maurine", "Maurise", "Maurita", "Maurizia", "Mavis", "Mavra", "Max", "Maxi", "Maxie", "Maxine", "Maxy", "May", "Maybelle", "Maye", "Mead", "Meade", "Meagan", "Meaghan", "Meara", "Mechelle", "Meg", "Megan", "Megen", "Meggi", "Meggie", "Meggy", "Meghan", "Meghann", "Mehetabel", "Mei", "Mel", "Mela", "Melamie", "Melania", "Melanie", "Melantha", "Melany", "Melba", "Melesa", "Melessa", "Melicent", "Melina", "Melinda", "Melinde", "Melisa", "Melisande", "Melisandra", "Melisenda", "Melisent", "Melissa", "Melisse", "Melita", "Melitta", "Mella", "Melli", "Mellicent", "Mellie", "Mellisa", "Mellisent", "Melloney", "Melly", "Melodee", "Melodie", "Melody", "Melonie", "Melony", "Melosa", "Melva", "Mercedes", "Merci", "Mercie", "Mercy", "Meredith", "Meredithe", "Meridel", "Meridith", "Meriel", "Merilee", "Merilyn", "Meris", "Merissa", "Merl", "Merla", "Merle", "Merlina", "Merline", "Merna", "Merola", "Merralee", "Merridie", "Merrie", "Merrielle", "Merrile", "Merrilee", "Merrili", "Merrill", "Merrily", "Merry", "Mersey", "Meryl", "Meta", "Mia", "Micaela", "Michaela", "Michaelina", "Michaeline", "Michaella", "Michal", "Michel", "Michele", "Michelina", "Micheline", "Michell", "Michelle", "Micki", "Mickie", "Micky", "Midge", "Mignon", "Mignonne", "Miguela", "Miguelita", "Mikaela", "Mil", "Mildred", "Mildrid", "Milena", "Milicent", "Milissent", "Milka", "Milli", "Millicent", "Millie", "Millisent", "Milly", "Milzie", "Mimi", "Min", "Mina", "Minda", "Mindy", "Minerva", "Minetta", "Minette", "Minna", "Minnaminnie", "Minne", "Minni", "Minnie", "Minnnie", "Minny", "Minta", "Miquela", "Mira", "Mirabel", "Mirabella", "Mirabelle", "Miran", "Miranda", "Mireielle", "Mireille", "Mirella", "Mirelle", "Miriam", "Mirilla", "Mirna", "Misha", "Missie", "Missy", "Misti", "Misty", "Mitzi", "Modesta", "Modestia", "Modestine", "Modesty", "Moina", "Moira", "Moll", "Mollee", "Molli", "Mollie", "Molly", "Mommy", "Mona", "Monah", "Monica", "Monika", "Monique", "Mora", "Moreen", "Morena", "Morgan", "Morgana", "Morganica", "Morganne", "Morgen", "Moria", "Morissa", "Morna", "Moselle", "Moyna", "Moyra", "Mozelle", "Muffin", "Mufi", "Mufinella", "Muire", "Mureil", "Murial", "Muriel", "Murielle", "Myra", "Myrah", "Myranda", "Myriam", "Myrilla", "Myrle", "Myrlene", "Myrna", "Myrta", "Myrtia", "Myrtice", "Myrtie", "Myrtle", "Nada", "Nadean", "Nadeen", "Nadia", "Nadine", "Nadiya", "Nady", "Nadya", "Nalani", "Nan", "Nana", "Nananne", "Nance", "Nancee", "Nancey", "Nanci", "Nancie", "Nancy", "Nanete", "Nanette", "Nani", "Nanice", "Nanine", "Nannette", "Nanni", "Nannie", "Nanny", "Nanon", "Naoma", "Naomi", "Nara", "Nari", "Nariko", "Nat", "Nata", "Natala", "Natalee", "Natalie", "Natalina", "Nataline", "Natalya", "Natasha", "Natassia", "Nathalia", "Nathalie", "Natividad", "Natka", "Natty", "Neala", "Neda", "Nedda", "Nedi", "Neely", "Neila", "Neile", "Neilla", "Neille", "Nelia", "Nelie", "Nell", "Nelle", "Nelli", "Nellie", "Nelly", "Nerissa", "Nerita", "Nert", "Nerta", "Nerte", "Nerti", "Nertie", "Nerty", "Nessa", "Nessi", "Nessie", "Nessy", "Nesta", "Netta", "Netti", "Nettie", "Nettle", "Netty", "Nevsa", "Neysa", "Nichol", "Nichole", "Nicholle", "Nicki", "Nickie", "Nicky", "Nicol", "Nicola", "Nicole", "Nicolea", "Nicolette", "Nicoli", "Nicolina", "Nicoline", "Nicolle", "Nikaniki", "Nike", "Niki", "Nikki", "Nikkie", "Nikoletta", "Nikolia", "Nina", "Ninetta", "Ninette", "Ninnetta", "Ninnette", "Ninon", "Nissa", "Nisse", "Nissie", "Nissy", "Nita", "Nixie", "Noami", "Noel", "Noelani", "Noell", "Noella", "Noelle", "Noellyn", "Noelyn", "Noemi", "Nola", "Nolana", "Nolie", "Nollie", "Nomi", "Nona", "Nonah", "Noni", "Nonie", "Nonna", "Nonnah", "Nora", "Norah", "Norean", "Noreen", "Norene", "Norina", "Norine", "Norma", "Norri", "Norrie", "Norry", "Novelia", "Nydia", "Nyssa", "Octavia", "Odele", "Odelia", "Odelinda", "Odella", "Odelle", "Odessa", "Odetta", "Odette", "Odilia", "Odille", "Ofelia", "Ofella", "Ofilia", "Ola", "Olenka", "Olga", "Olia", "Olimpia", "Olive", "Olivette", "Olivia", "Olivie", "Oliy", "Ollie", "Olly", "Olva", "Olwen", "Olympe", "Olympia", "Olympie", "Ondrea", "Oneida", "Onida", "Oona", "Opal", "Opalina", "Opaline", "Ophelia", "Ophelie", "Ora", "Oralee", "Oralia", "Oralie", "Oralla", "Oralle", "Orel", "Orelee", "Orelia", "Orelie", "Orella", "Orelle", "Oriana", "Orly", "Orsa", "Orsola", "Ortensia", "Otha", "Othelia", "Othella", "Othilia", "Othilie", "Ottilie", "Page", "Paige", "Paloma", "Pam", "Pamela", "Pamelina", "Pamella", "Pammi", "Pammie", "Pammy", "Pandora", "Pansie", "Pansy", "Paola", "Paolina", "Papagena", "Pat", "Patience", "Patrica", "Patrice", "Patricia", "Patrizia", "Patsy", "Patti", "Pattie", "Patty", "Paula", "Paule", "Pauletta", "Paulette", "Pauli", "Paulie", "Paulina", "Pauline", "Paulita", "Pauly", "Pavia", "Pavla", "Pearl", "Pearla", "Pearle", "Pearline", "Peg", "Pegeen", "Peggi", "Peggie", "Peggy", "Pen", "Penelopa", "Penelope", "Penni", "Pennie", "Penny", "Pepi", "Pepita", "Peri", "Peria", "Perl", "Perla", "Perle", "Perri", "Perrine", "Perry", "Persis", "Pet", "Peta", "Petra", "Petrina", "Petronella", "Petronia", "Petronilla", "Petronille", "Petunia", "Phaedra", "Phaidra", "Phebe", "Phedra", "Phelia", "Phil", "Philipa", "Philippa", "Philippe", "Philippine", "Philis", "Phillida", "Phillie", "Phillis", "Philly", "Philomena", "Phoebe", "Phylis", "Phyllida", "Phyllis", "Phyllys", "Phylys", "Pia", "Pier", "Pierette", "Pierrette", "Pietra", "Piper", "Pippa", "Pippy", "Polly", "Pollyanna", "Pooh", "Poppy", "Portia", "Pris", "Prisca", "Priscella", "Priscilla", "Prissie", "Pru", "Prudence", "Prudi", "Prudy", "Prue", "Queenie", "Quentin", "Querida", "Quinn", "Quinta", "Quintana", "Quintilla", "Quintina", "Rachael", "Rachel", "Rachele", "Rachelle", "Rae", "Raeann", "Raf", "Rafa", "Rafaela", "Rafaelia", "Rafaelita", "Rahal", "Rahel", "Raina", "Raine", "Rakel", "Ralina", "Ramona", "Ramonda", "Rana", "Randa", "Randee", "Randene", "Randi", "Randie", "Randy", "Ranee", "Rani", "Rania", "Ranice", "Ranique", "Ranna", "Raphaela", "Raquel", "Raquela", "Rasia", "Rasla", "Raven", "Ray", "Raychel", "Raye", "Rayna", "Raynell", "Rayshell", "Rea", "Reba", "Rebbecca", "Rebe", "Rebeca", "Rebecca", "Rebecka", "Rebeka", "Rebekah", "Rebekkah", "Ree", "Reeba", "Reena", "Reeta", "Reeva", "Regan", "Reggi", "Reggie", "Regina", "Regine", "Reiko", "Reina", "Reine", "Remy", "Rena", "Renae", "Renata", "Renate", "Rene", "Renee", "Renell", "Renelle", "Renie", "Rennie", "Reta", "Retha", "Revkah", "Rey", "Reyna", "Rhea", "Rheba", "Rheta", "Rhetta", "Rhiamon", "Rhianna", "Rhianon", "Rhoda", "Rhodia", "Rhodie", "Rhody", "Rhona", "Rhonda", "Riane", "Riannon", "Rianon", "Rica", "Ricca", "Rici", "Ricki", "Rickie", "Ricky", "Riki", "Rikki", "Rina", "Risa", "Rita", "Riva", "Rivalee", "Rivi", "Rivkah", "Rivy", "Roana", "Roanna", "Roanne", "Robbi", "Robbie", "Robbin", "Robby", "Robbyn", "Robena", "Robenia", "Roberta", "Robin", "Robina", "Robinet", "Robinett", "Robinetta", "Robinette", "Robinia", "Roby", "Robyn", "Roch", "Rochell", "Rochella", "Rochelle", "Rochette", "Roda", "Rodi", "Rodie", "Rodina", "Rois", "Romola", "Romona", "Romonda", "Romy", "Rona", "Ronalda", "Ronda", "Ronica", "Ronna", "Ronni", "Ronnica", "Ronnie", "Ronny", "Roobbie", "Rora", "Rori", "Rorie", "Rory", "Ros", "Rosa", "Rosabel", "Rosabella", "Rosabelle", "Rosaleen", "Rosalia", "Rosalie", "Rosalind", "Rosalinda", "Rosalinde", "Rosaline", "Rosalyn", "Rosalynd", "Rosamond", "Rosamund", "Rosana", "Rosanna", "Rosanne", "Rose", "Roseann", "Roseanna", "Roseanne", "Roselia", "Roselin", "Roseline", "Rosella", "Roselle", "Rosemaria", "Rosemarie", "Rosemary", "Rosemonde", "Rosene", "Rosetta", "Rosette", "Roshelle", "Rosie", "Rosina", "Rosita", "Roslyn", "Rosmunda", "Rosy", "Row", "Rowe", "Rowena", "Roxana", "Roxane", "Roxanna", "Roxanne", "Roxi", "Roxie", "Roxine", "Roxy", "Roz", "Rozalie", "Rozalin", "Rozamond", "Rozanna", "Rozanne", "Roze", "Rozele", "Rozella", "Rozelle", "Rozina", "Rubetta", "Rubi", "Rubia", "Rubie", "Rubina", "Ruby", "Ruperta", "Ruth", "Ruthann", "Ruthanne", "Ruthe", "Ruthi", "Ruthie", "Ruthy", "Ryann", "Rycca", "Saba", "Sabina", "Sabine", "Sabra", "Sabrina", "Sacha", "Sada", "Sadella", "Sadie", "Sadye", "Saidee", "Sal", "Salaidh", "Sallee", "Salli", "Sallie", "Sally", "Sallyann", "Sallyanne", "Saloma", "Salome", "Salomi", "Sam", "Samantha", "Samara", "Samaria", "Sammy", "Sande", "Sandi", "Sandie", "Sandra", "Sandy", "Sandye", "Sapphira", "Sapphire", "Sara", "Sara-ann", "Saraann", "Sarah", "Sarajane", "Saree", "Sarena", "Sarene", "Sarette", "Sari", "Sarina", "Sarine", "Sarita", "Sascha", "Sasha", "Sashenka", "Saudra", "Saundra", "Savina", "Sayre", "Scarlet", "Scarlett", "Sean", "Seana", "Seka", "Sela", "Selena", "Selene", "Selestina", "Selia", "Selie", "Selina", "Selinda", "Seline", "Sella", "Selle", "Selma", "Sena", "Sephira", "Serena", "Serene", "Shae", "Shaina", "Shaine", "Shalna", "Shalne", "Shana", "Shanda", "Shandee", "Shandeigh", "Shandie", "Shandra", "Shandy", "Shane", "Shani", "Shanie", "Shanna", "Shannah", "Shannen", "Shannon", "Shanon", "Shanta", "Shantee", "Shara", "Sharai", "Shari", "Sharia", "Sharity", "Sharl", "Sharla", "Sharleen", "Sharlene", "Sharline", "Sharon", "Sharona", "Sharron", "Sharyl", "Shaun", "Shauna", "Shawn", "Shawna", "Shawnee", "Shay", "Shayla", "Shaylah", "Shaylyn", "Shaylynn", "Shayna", "Shayne", "Shea", "Sheba", "Sheela", "Sheelagh", "Sheelah", "Sheena", "Sheeree", "Sheila", "Sheila-kathryn", "Sheilah", "Shel", "Shela", "Shelagh", "Shelba", "Shelbi", "Shelby", "Shelia", "Shell", "Shelley", "Shelli", "Shellie", "Shelly", "Shena", "Sher", "Sheree", "Sheri", "Sherie", "Sherill", "Sherilyn", "Sherline", "Sherri", "Sherrie", "Sherry", "Sherye", "Sheryl", "Shina", "Shir", "Shirl", "Shirlee", "Shirleen", "Shirlene", "Shirley", "Shirline", "Shoshana", "Shoshanna", "Siana", "Sianna", "Sib", "Sibbie", "Sibby", "Sibeal", "Sibel", "Sibella", "Sibelle", "Sibilla", "Sibley", "Sibyl", "Sibylla", "Sibylle", "Sidoney", "Sidonia", "Sidonnie", "Sigrid", "Sile", "Sileas", "Silva", "Silvana", "Silvia", "Silvie", "Simona", "Simone", "Simonette", "Simonne", "Sindee", "Siobhan", "Sioux", "Siouxie", "Sisely", "Sisile", "Sissie", "Sissy", "Siusan", "Sofia", "Sofie", "Sondra", "Sonia", "Sonja", "Sonni", "Sonnie", "Sonnnie", "Sonny", "Sonya", "Sophey", "Sophi", "Sophia", "Sophie", "Sophronia", "Sorcha", "Sosanna", "Stace", "Stacee", "Stacey", "Staci", "Stacia", "Stacie", "Stacy", "Stafani", "Star", "Starla", "Starlene", "Starlin", "Starr", "Stefa", "Stefania", "Stefanie", "Steffane", "Steffi", "Steffie", "Stella", "Stepha", "Stephana", "Stephani", "Stephanie", "Stephannie", "Stephenie", "Stephi", "Stephie", "Stephine", "Stesha", "Stevana", "Stevena", "Stoddard", "Storm", "Stormi", "Stormie", "Stormy", "Sue", "Suellen", "Sukey", "Suki", "Sula", "Sunny", "Sunshine", "Susan", "Susana", "Susanetta", "Susann", "Susanna", "Susannah", "Susanne", "Susette", "Susi", "Susie", "Susy", "Suzann", "Suzanna", "Suzanne", "Suzette", "Suzi", "Suzie", "Suzy", "Sybil", "Sybila", "Sybilla", "Sybille", "Sybyl", "Sydel", "Sydelle", "Sydney", "Sylvia", "Tabatha", "Tabbatha", "Tabbi", "Tabbie", "Tabbitha", "Tabby", "Tabina", "Tabitha", "Taffy", "Talia", "Tallia", "Tallie", "Tallou", "Tallulah", "Tally", "Talya", "Talyah", "Tamar", "Tamara", "Tamarah", "Tamarra", "Tamera", "Tami", "Tamiko", "Tamma", "Tammara", "Tammi", "Tammie", "Tammy", "Tamqrah", "Tamra", "Tana", "Tandi", "Tandie", "Tandy", "Tanhya", "Tani", "Tania", "Tanitansy", "Tansy", "Tanya", "Tara", "Tarah", "Tarra", "Tarrah", "Taryn", "Tasha", "Tasia", "Tate", "Tatiana", "Tatiania", "Tatum", "Tawnya", "Tawsha", "Ted", "Tedda", "Teddi", "Teddie", "Teddy", "Tedi", "Tedra", "Teena", "Teirtza", "Teodora", "Tera", "Teresa", "Terese", "Teresina", "Teresita", "Teressa", "Teri", "Teriann", "Terra", "Terri", "Terrie", "Terrijo", "Terry", "Terrye", "Tersina", "Terza", "Tess", "Tessa", "Tessi", "Tessie", "Tessy", "Thalia", "Thea", "Theadora", "Theda", "Thekla", "Thelma", "Theo", "Theodora", "Theodosia", "Theresa", "Therese", "Theresina", "Theresita", "Theressa", "Therine", "Thia", "Thomasa", "Thomasin", "Thomasina", "Thomasine", "Tiena", "Tierney", "Tiertza", "Tiff", "Tiffani", "Tiffanie", "Tiffany", "Tiffi", "Tiffie", "Tiffy", "Tilda", "Tildi", "Tildie", "Tildy", "Tillie", "Tilly", "Tim", "Timi", "Timmi", "Timmie", "Timmy", "Timothea", "Tina", "Tine", "Tiphani", "Tiphanie", "Tiphany", "Tish", "Tisha", "Tobe", "Tobey", "Tobi", "Toby", "Tobye", "Toinette", "Toma", "Tomasina", "Tomasine", "Tomi", "Tommi", "Tommie", "Tommy", "Toni", "Tonia", "Tonie", "Tony", "Tonya", "Tonye", "Tootsie", "Torey", "Tori", "Torie", "Torrie", "Tory", "Tova", "Tove", "Tracee", "Tracey", "Traci", "Tracie", "Tracy", "Trenna", "Tresa", "Trescha", "Tressa", "Tricia", "Trina", "Trish", "Trisha", "Trista", "Trix", "Trixi", "Trixie", "Trixy", "Truda", "Trude", "Trudey", "Trudi", "Trudie", "Trudy", "Trula", "Tuesday", "Twila", "Twyla", "Tybi", "Tybie", "Tyne", "Ula", "Ulla", "Ulrica", "Ulrika", "Ulrikaumeko", "Ulrike", "Umeko", "Una", "Ursa", "Ursala", "Ursola", "Ursula", "Ursulina", "Ursuline", "Uta", "Val", "Valaree", "Valaria", "Vale", "Valeda", "Valencia", "Valene", "Valenka", "Valentia", "Valentina", "Valentine", "Valera", "Valeria", "Valerie", "Valery", "Valerye", "Valida", "Valina", "Valli", "Vallie", "Vally", "Valma", "Valry", "Van", "Vanda", "Vanessa", "Vania", "Vanna", "Vanni", "Vannie", "Vanny", "Vanya", "Veda", "Velma", "Velvet", "Venita", "Venus", "Vera", "Veradis", "Vere", "Verena", "Verene", "Veriee", "Verile", "Verina", "Verine", "Verla", "Verna", "Vernice", "Veronica", "Veronika", "Veronike", "Veronique", "Vevay", "Vi", "Vicki", "Vickie", "Vicky", "Victoria", "Vida", "Viki", "Vikki", "Vikky", "Vilhelmina", "Vilma", "Vin", "Vina", "Vinita", "Vinni", "Vinnie", "Vinny", "Viola", "Violante", "Viole", "Violet", "Violetta", "Violette", "Virgie", "Virgina", "Virginia", "Virginie", "Vita", "Vitia", "Vitoria", "Vittoria", "Viv", "Viva", "Vivi", "Vivia", "Vivian", "Viviana", "Vivianna", "Vivianne", "Vivie", "Vivien", "Viviene", "Vivienne", "Viviyan", "Vivyan", "Vivyanne", "Vonni", "Vonnie", "Vonny", "Vyky", "Wallie", "Wallis", "Walliw", "Wally", "Waly", "Wanda", "Wandie", "Wandis", "Waneta", "Wanids", "Wenda", "Wendeline", "Wendi", "Wendie", "Wendy", "Wendye", "Wenona", "Wenonah", "Whitney", "Wileen", "Wilhelmina", "Wilhelmine", "Wilie", "Willa", "Willabella", "Willamina", "Willetta", "Willette", "Willi", "Willie", "Willow", "Willy", "Willyt", "Wilma", "Wilmette", "Wilona", "Wilone", "Wilow", "Windy", "Wini", "Winifred", "Winna", "Winnah", "Winne", "Winni", "Winnie", "Winnifred", "Winny", "Winona", "Winonah", "Wren", "Wrennie", "Wylma", "Wynn", "Wynne", "Wynnie", "Wynny", "Xaviera", "Xena", "Xenia", "Xylia", "Xylina", "Yalonda", "Yasmeen", "Yasmin", "Yelena", "Yetta", "Yettie", "Yetty", "Yevette", "Ynes", "Ynez", "Yoko", "Yolanda", "Yolande", "Yolane", "Yolanthe", "Yoshi", "Yoshiko", "Yovonnda", "Ysabel", "Yvette", "Yvonne", "Zabrina", "Zahara", "Zandra", "Zaneta", "Zara", "Zarah", "Zaria", "Zarla", "Zea", "Zelda", "Zelma", "Zena", "Zenia", "Zia", "Zilvia", "Zita", "Zitella", "Zoe", "Zola", "Zonda", "Zondra", "Zonnya", "Zora", "Zorah", "Zorana", "Zorina", "Zorine", "Zsazsa", "Zulema", "Zuzana"];
var n$ = {};
rq(n$, { xid: /* @__PURE__ */ __name(() => Od, "xid"), void: /* @__PURE__ */ __name(() => Id, "void"), uuidv7: /* @__PURE__ */ __name(() => Qm, "uuidv7"), uuidv6: /* @__PURE__ */ __name(() => am, "uuidv6"), uuidv4: /* @__PURE__ */ __name(() => Fm, "uuidv4"), uuid: /* @__PURE__ */ __name(() => Um, "uuid"), util: /* @__PURE__ */ __name(() => l$, "util"), url: /* @__PURE__ */ __name(() => em, "url"), uppercase: /* @__PURE__ */ __name(() => K7, "uppercase"), unknown: /* @__PURE__ */ __name(() => y4, "unknown"), union: /* @__PURE__ */ __name(() => qH, "union"), undefined: /* @__PURE__ */ __name(() => Ed, "undefined"), ulid: /* @__PURE__ */ __name(() => Pd, "ulid"), uint64: /* @__PURE__ */ __name(() => Cd, "uint64"), uint32: /* @__PURE__ */ __name(() => Sd, "uint32"), tuple: /* @__PURE__ */ __name(() => ZV, "tuple"), trim: /* @__PURE__ */ __name(() => v7, "trim"), treeifyError: /* @__PURE__ */ __name(() => $Y, "treeifyError"), transform: /* @__PURE__ */ __name(() => PH, "transform"), toUpperCase: /* @__PURE__ */ __name(() => W7, "toUpperCase"), toLowerCase: /* @__PURE__ */ __name(() => z7, "toLowerCase"), toJSONSchema: /* @__PURE__ */ __name(() => j4, "toJSONSchema"), templateLiteral: /* @__PURE__ */ __name(() => td, "templateLiteral"), symbol: /* @__PURE__ */ __name(() => hd, "symbol"), superRefine: /* @__PURE__ */ __name(() => lV, "superRefine"), success: /* @__PURE__ */ __name(() => od, "success"), stringbool: /* @__PURE__ */ __name(() => ed, "stringbool"), stringFormat: /* @__PURE__ */ __name(() => fd, "stringFormat"), string: /* @__PURE__ */ __name(() => bW, "string"), strictObject: /* @__PURE__ */ __name(() => bd, "strictObject"), startsWith: /* @__PURE__ */ __name(() => P7, "startsWith"), size: /* @__PURE__ */ __name(() => sP, "size"), setErrorMap: /* @__PURE__ */ __name(() => Kl, "setErrorMap"), set: /* @__PURE__ */ __name(() => cd, "set"), safeParseAsync: /* @__PURE__ */ __name(() => NW, "safeParseAsync"), safeParse: /* @__PURE__ */ __name(() => MW, "safeParse"), safeEncodeAsync: /* @__PURE__ */ __name(() => LW, "safeEncodeAsync"), safeEncode: /* @__PURE__ */ __name(() => IW, "safeEncode"), safeDecodeAsync: /* @__PURE__ */ __name(() => gW, "safeDecodeAsync"), safeDecode: /* @__PURE__ */ __name(() => DW, "safeDecode"), registry: /* @__PURE__ */ __name(() => p9, "registry"), regexes: /* @__PURE__ */ __name(() => Z8, "regexes"), regex: /* @__PURE__ */ __name(() => $7, "regex"), refine: /* @__PURE__ */ __name(() => dV, "refine"), record: /* @__PURE__ */ __name(() => XV, "record"), readonly: /* @__PURE__ */ __name(() => yV, "readonly"), property: /* @__PURE__ */ __name(() => hv, "property"), promise: /* @__PURE__ */ __name(() => Bd, "promise"), prettifyError: /* @__PURE__ */ __name(() => qY, "prettifyError"), preprocess: /* @__PURE__ */ __name(() => $l, "preprocess"), prefault: /* @__PURE__ */ __name(() => EV, "prefault"), positive: /* @__PURE__ */ __name(() => Sv, "positive"), pipe: /* @__PURE__ */ __name(() => r5, "pipe"), partialRecord: /* @__PURE__ */ __name(() => xd, "partialRecord"), parseAsync: /* @__PURE__ */ __name(() => SW, "parseAsync"), parse: /* @__PURE__ */ __name(() => VW, "parse"), overwrite: /* @__PURE__ */ __name(() => HK, "overwrite"), optional: /* @__PURE__ */ __name(() => d5, "optional"), object: /* @__PURE__ */ __name(() => gd, "object"), number: /* @__PURE__ */ __name(() => qV, "number"), nullish: /* @__PURE__ */ __name(() => rd, "nullish"), nullable: /* @__PURE__ */ __name(() => l5, "nullable"), null: /* @__PURE__ */ __name(() => YV, "null"), normalize: /* @__PURE__ */ __name(() => j7, "normalize"), nonpositive: /* @__PURE__ */ __name(() => Nv, "nonpositive"), nonoptional: /* @__PURE__ */ __name(() => RV, "nonoptional"), nonnegative: /* @__PURE__ */ __name(() => Cv, "nonnegative"), never: /* @__PURE__ */ __name(() => sW, "never"), negative: /* @__PURE__ */ __name(() => Mv, "negative"), nativeEnum: /* @__PURE__ */ __name(() => md, "nativeEnum"), nanoid: /* @__PURE__ */ __name(() => qd, "nanoid"), nan: /* @__PURE__ */ __name(() => nd, "nan"), multipleOf: /* @__PURE__ */ __name(() => X_, "multipleOf"), minSize: /* @__PURE__ */ __name(() => A_, "minSize"), minLength: /* @__PURE__ */ __name(() => nK, "minLength"), mime: /* @__PURE__ */ __name(() => Y7, "mime"), maxSize: /* @__PURE__ */ __name(() => _4, "maxSize"), maxLength: /* @__PURE__ */ __name(() => P4, "maxLength"), map: /* @__PURE__ */ __name(() => pd, "map"), lte: /* @__PURE__ */ __name(() => X8, "lte"), lt: /* @__PURE__ */ __name(() => zK, "lt"), lowercase: /* @__PURE__ */ __name(() => q7, "lowercase"), looseObject: /* @__PURE__ */ __name(() => yd, "looseObject"), locales: /* @__PURE__ */ __name(() => UP, "locales"), literal: /* @__PURE__ */ __name(() => dd, "literal"), length: /* @__PURE__ */ __name(() => O4, "length"), lazy: /* @__PURE__ */ __name(() => pV, "lazy"), ksuid: /* @__PURE__ */ __name(() => Yd, "ksuid"), keyof: /* @__PURE__ */ __name(() => Ld, "keyof"), jwt: /* @__PURE__ */ __name(() => wd, "jwt"), json: /* @__PURE__ */ __name(() => sd, "json"), iso: /* @__PURE__ */ __name(() => c5, "iso"), ipv6: /* @__PURE__ */ __name(() => vd, "ipv6"), ipv4: /* @__PURE__ */ __name(() => jd, "ipv4"), intersection: /* @__PURE__ */ __name(() => wV, "intersection"), int64: /* @__PURE__ */ __name(() => Nd, "int64"), int32: /* @__PURE__ */ __name(() => Vd, "int32"), int: /* @__PURE__ */ __name(() => yW, "int"), instanceof: /* @__PURE__ */ __name(() => Qd, "instanceof"), includes: /* @__PURE__ */ __name(() => _7, "includes"), httpUrl: /* @__PURE__ */ __name(() => sm, "httpUrl"), hostname: /* @__PURE__ */ __name(() => Zd, "hostname"), hex: /* @__PURE__ */ __name(() => Xd, "hex"), hash: /* @__PURE__ */ __name(() => Ad, "hash"), guid: /* @__PURE__ */ __name(() => Bm, "guid"), gte: /* @__PURE__ */ __name(() => aq, "gte"), gt: /* @__PURE__ */ __name(() => WK, "gt"), globalRegistry: /* @__PURE__ */ __name(() => Hq, "globalRegistry"), getErrorMap: /* @__PURE__ */ __name(() => _l, "getErrorMap"), function: /* @__PURE__ */ __name(() => Ud, "function"), formatError: /* @__PURE__ */ __name(() => xP, "formatError"), float64: /* @__PURE__ */ __name(() => Gd, "float64"), float32: /* @__PURE__ */ __name(() => kd, "float32"), flattenError: /* @__PURE__ */ __name(() => uP, "flattenError"), file: /* @__PURE__ */ __name(() => ld, "file"), enum: /* @__PURE__ */ __name(() => _H, "enum"), endsWith: /* @__PURE__ */ __name(() => O7, "endsWith"), encodeAsync: /* @__PURE__ */ __name(() => EW, "encodeAsync"), encode: /* @__PURE__ */ __name(() => CW, "encode"), emoji: /* @__PURE__ */ __name(() => $d, "emoji"), email: /* @__PURE__ */ __name(() => tm, "email"), e164: /* @__PURE__ */ __name(() => Td, "e164"), discriminatedUnion: /* @__PURE__ */ __name(() => ud, "discriminatedUnion"), decodeAsync: /* @__PURE__ */ __name(() => RW, "decodeAsync"), decode: /* @__PURE__ */ __name(() => hW, "decode"), date: /* @__PURE__ */ __name(() => Dd, "date"), custom: /* @__PURE__ */ __name(() => ad, "custom"), cuid2: /* @__PURE__ */ __name(() => _d, "cuid2"), cuid: /* @__PURE__ */ __name(() => Kd, "cuid"), core: /* @__PURE__ */ __name(() => JK, "core"), config: /* @__PURE__ */ __name(() => o6, "config"), coerce: /* @__PURE__ */ __name(() => WH, "coerce"), codec: /* @__PURE__ */ __name(() => id, "codec"), clone: /* @__PURE__ */ __name(() => n6, "clone"), cidrv6: /* @__PURE__ */ __name(() => Wd, "cidrv6"), cidrv4: /* @__PURE__ */ __name(() => zd, "cidrv4"), check: /* @__PURE__ */ __name(() => Fd, "check"), catch: /* @__PURE__ */ __name(() => LV, "catch"), boolean: /* @__PURE__ */ __name(() => KV, "boolean"), bigint: /* @__PURE__ */ __name(() => Md, "bigint"), base64url: /* @__PURE__ */ __name(() => Jd, "base64url"), base64: /* @__PURE__ */ __name(() => Hd, "base64"), array: /* @__PURE__ */ __name(() => i5, "array"), any: /* @__PURE__ */ __name(() => Rd, "any"), _function: /* @__PURE__ */ __name(() => Ud, "_function"), _default: /* @__PURE__ */ __name(() => CV, "_default"), _ZodString: /* @__PURE__ */ __name(() => uW, "_ZodString"), ZodXID: /* @__PURE__ */ __name(() => rW, "ZodXID"), ZodVoid: /* @__PURE__ */ __name(() => WV, "ZodVoid"), ZodUnknown: /* @__PURE__ */ __name(() => vV, "ZodUnknown"), ZodUnion: /* @__PURE__ */ __name(() => $H, "ZodUnion"), ZodUndefined: /* @__PURE__ */ __name(() => PV, "ZodUndefined"), ZodUUID: /* @__PURE__ */ __name(() => VK, "ZodUUID"), ZodURL: /* @__PURE__ */ __name(() => o5, "ZodURL"), ZodULID: /* @__PURE__ */ __name(() => lW, "ZodULID"), ZodType: /* @__PURE__ */ __name(() => T6, "ZodType"), ZodTuple: /* @__PURE__ */ __name(() => fV, "ZodTuple"), ZodTransform: /* @__PURE__ */ __name(() => SV, "ZodTransform"), ZodTemplateLiteral: /* @__PURE__ */ __name(() => uV, "ZodTemplateLiteral"), ZodSymbol: /* @__PURE__ */ __name(() => _V, "ZodSymbol"), ZodSuccess: /* @__PURE__ */ __name(() => IV, "ZodSuccess"), ZodStringFormat: /* @__PURE__ */ __name(() => E6, "ZodStringFormat"), ZodString: /* @__PURE__ */ __name(() => u7, "ZodString"), ZodSet: /* @__PURE__ */ __name(() => kV, "ZodSet"), ZodRecord: /* @__PURE__ */ __name(() => KH, "ZodRecord"), ZodRealError: /* @__PURE__ */ __name(() => eq, "ZodRealError"), ZodReadonly: /* @__PURE__ */ __name(() => bV, "ZodReadonly"), ZodPromise: /* @__PURE__ */ __name(() => cV, "ZodPromise"), ZodPrefault: /* @__PURE__ */ __name(() => hV, "ZodPrefault"), ZodPipe: /* @__PURE__ */ __name(() => jH, "ZodPipe"), ZodOptional: /* @__PURE__ */ __name(() => OH, "ZodOptional"), ZodObject: /* @__PURE__ */ __name(() => t5, "ZodObject"), ZodNumberFormat: /* @__PURE__ */ __name(() => u4, "ZodNumberFormat"), ZodNumber: /* @__PURE__ */ __name(() => p7, "ZodNumber"), ZodNullable: /* @__PURE__ */ __name(() => MV, "ZodNullable"), ZodNull: /* @__PURE__ */ __name(() => OV, "ZodNull"), ZodNonOptional: /* @__PURE__ */ __name(() => YH, "ZodNonOptional"), ZodNever: /* @__PURE__ */ __name(() => zV, "ZodNever"), ZodNanoID: /* @__PURE__ */ __name(() => cW, "ZodNanoID"), ZodNaN: /* @__PURE__ */ __name(() => gV, "ZodNaN"), ZodMap: /* @__PURE__ */ __name(() => AV, "ZodMap"), ZodLiteral: /* @__PURE__ */ __name(() => GV, "ZodLiteral"), ZodLazy: /* @__PURE__ */ __name(() => xV, "ZodLazy"), ZodKSUID: /* @__PURE__ */ __name(() => oW, "ZodKSUID"), ZodJWT: /* @__PURE__ */ __name(() => QW, "ZodJWT"), ZodIssueCode: /* @__PURE__ */ __name(() => ql, "ZodIssueCode"), ZodIntersection: /* @__PURE__ */ __name(() => TV, "ZodIntersection"), ZodISOTime: /* @__PURE__ */ __name(() => x5, "ZodISOTime"), ZodISODuration: /* @__PURE__ */ __name(() => p5, "ZodISODuration"), ZodISODateTime: /* @__PURE__ */ __name(() => y5, "ZodISODateTime"), ZodISODate: /* @__PURE__ */ __name(() => u5, "ZodISODate"), ZodIPv6: /* @__PURE__ */ __name(() => iW, "ZodIPv6"), ZodIPv4: /* @__PURE__ */ __name(() => nW, "ZodIPv4"), ZodGUID: /* @__PURE__ */ __name(() => m5, "ZodGUID"), ZodFunction: /* @__PURE__ */ __name(() => mV, "ZodFunction"), ZodFirstPartyTypeKind: /* @__PURE__ */ __name(() => zH, "ZodFirstPartyTypeKind"), ZodFile: /* @__PURE__ */ __name(() => VV, "ZodFile"), ZodError: /* @__PURE__ */ __name(() => nm, "ZodError"), ZodEnum: /* @__PURE__ */ __name(() => y7, "ZodEnum"), ZodEmoji: /* @__PURE__ */ __name(() => pW, "ZodEmoji"), ZodEmail: /* @__PURE__ */ __name(() => xW, "ZodEmail"), ZodE164: /* @__PURE__ */ __name(() => aW, "ZodE164"), ZodDiscriminatedUnion: /* @__PURE__ */ __name(() => JV, "ZodDiscriminatedUnion"), ZodDefault: /* @__PURE__ */ __name(() => NV, "ZodDefault"), ZodDate: /* @__PURE__ */ __name(() => n5, "ZodDate"), ZodCustomStringFormat: /* @__PURE__ */ __name(() => x7, "ZodCustomStringFormat"), ZodCustom: /* @__PURE__ */ __name(() => B5, "ZodCustom"), ZodCodec: /* @__PURE__ */ __name(() => vH, "ZodCodec"), ZodCatch: /* @__PURE__ */ __name(() => DV, "ZodCatch"), ZodCUID2: /* @__PURE__ */ __name(() => dW, "ZodCUID2"), ZodCUID: /* @__PURE__ */ __name(() => mW, "ZodCUID"), ZodCIDRv6: /* @__PURE__ */ __name(() => BW, "ZodCIDRv6"), ZodCIDRv4: /* @__PURE__ */ __name(() => tW, "ZodCIDRv4"), ZodBoolean: /* @__PURE__ */ __name(() => c7, "ZodBoolean"), ZodBigIntFormat: /* @__PURE__ */ __name(() => eW, "ZodBigIntFormat"), ZodBigInt: /* @__PURE__ */ __name(() => m7, "ZodBigInt"), ZodBase64URL: /* @__PURE__ */ __name(() => FW, "ZodBase64URL"), ZodBase64: /* @__PURE__ */ __name(() => UW, "ZodBase64"), ZodArray: /* @__PURE__ */ __name(() => HV, "ZodArray"), ZodAny: /* @__PURE__ */ __name(() => jV, "ZodAny"), TimePrecision: /* @__PURE__ */ __name(() => a3, "TimePrecision"), NEVER: /* @__PURE__ */ __name(() => n2, "NEVER"), $output: /* @__PURE__ */ __name(() => t3, "$output"), $input: /* @__PURE__ */ __name(() => B3, "$input"), $brand: /* @__PURE__ */ __name(() => i2, "$brand") });
var c5 = {};
rq(c5, { time: /* @__PURE__ */ __name(() => kW, "time"), duration: /* @__PURE__ */ __name(() => GW, "duration"), datetime: /* @__PURE__ */ __name(() => XW, "datetime"), date: /* @__PURE__ */ __name(() => AW, "date"), ZodISOTime: /* @__PURE__ */ __name(() => x5, "ZodISOTime"), ZodISODuration: /* @__PURE__ */ __name(() => p5, "ZodISODuration"), ZodISODateTime: /* @__PURE__ */ __name(() => y5, "ZodISODateTime"), ZodISODate: /* @__PURE__ */ __name(() => u5, "ZodISODate") });
var y5 = O$("ZodISODateTime", ($, q) => {
  Wj.init($, q), E6.init($, q);
});
function XW($) {
  return Q3(y5, $);
}
__name(XW, "XW");
var u5 = O$("ZodISODate", ($, q) => {
  Hj.init($, q), E6.init($, q);
});
function AW($) {
  return e3(u5, $);
}
__name(AW, "AW");
var x5 = O$("ZodISOTime", ($, q) => {
  Jj.init($, q), E6.init($, q);
});
function kW($) {
  return s3(x5, $);
}
__name(kW, "kW");
var p5 = O$("ZodISODuration", ($, q) => {
  Tj.init($, q), E6.init($, q);
});
function GW($) {
  return $v(p5, $);
}
__name(GW, "GW");
var $V = /* @__PURE__ */ __name(($, q) => {
  yP.init($, q), $.name = "ZodError", Object.defineProperties($, { format: { value: /* @__PURE__ */ __name((K) => xP($, K), "value") }, flatten: { value: /* @__PURE__ */ __name((K) => uP($, K), "value") }, addIssue: { value: /* @__PURE__ */ __name((K) => {
    $.issues.push(K), $.message = JSON.stringify($.issues, U_, 2);
  }, "value") }, addIssues: { value: /* @__PURE__ */ __name((K) => {
    $.issues.push(...K), $.message = JSON.stringify($.issues, U_, 2);
  }, "value") }, isEmpty: { get() {
    return $.issues.length === 0;
  } } });
}, "$V");
var nm = O$("ZodError", $V);
var eq = O$("ZodError", $V, { Parent: Error });
var VW = Q_(eq);
var SW = e_(eq);
var MW = $4(eq);
var NW = q4(eq);
var CW = w9(eq);
var hW = f9(eq);
var EW = Z9(eq);
var RW = X9(eq);
var IW = A9(eq);
var DW = k9(eq);
var LW = G9(eq);
var gW = V9(eq);
var T6 = O$("ZodType", ($, q) => {
  return P6.init($, q), $.def = q, $.type = q.type, Object.defineProperty($, "_def", { value: q }), $.check = (...K) => {
    return $.clone(l$.mergeDefs(q, { checks: [...q.checks ?? [], ...K.map((P) => typeof P === "function" ? { _zod: { check: P, def: { check: "custom" }, onattach: [] } } : P)] }));
  }, $.clone = (K, P) => n6($, K, P), $.brand = () => $, $.register = (K, P) => {
    return K.add($, P), $;
  }, $.parse = (K, P) => VW($, K, P, { callee: $.parse }), $.safeParse = (K, P) => MW($, K, P), $.parseAsync = async (K, P) => SW($, K, P, { callee: $.parseAsync }), $.safeParseAsync = async (K, P) => NW($, K, P), $.spa = $.safeParseAsync, $.encode = (K, P) => CW($, K, P), $.decode = (K, P) => hW($, K, P), $.encodeAsync = async (K, P) => EW($, K, P), $.decodeAsync = async (K, P) => RW($, K, P), $.safeEncode = (K, P) => IW($, K, P), $.safeDecode = (K, P) => DW($, K, P), $.safeEncodeAsync = async (K, P) => LW($, K, P), $.safeDecodeAsync = async (K, P) => gW($, K, P), $.refine = (K, P) => $.check(dV(K, P)), $.superRefine = (K) => $.check(lV(K)), $.overwrite = (K) => $.check(HK(K)), $.optional = () => d5($), $.nullable = () => l5($), $.nullish = () => d5(l5($)), $.nonoptional = (K) => RV($, K), $.array = () => i5($), $.or = (K) => qH([$, K]), $.and = (K) => wV($, K), $.transform = (K) => r5($, PH(K)), $.default = (K) => CV($, K), $.prefault = (K) => EV($, K), $.catch = (K) => LV($, K), $.pipe = (K) => r5($, K), $.readonly = () => yV($), $.describe = (K) => {
    let P = $.clone();
    return Hq.add(P, { description: K }), P;
  }, Object.defineProperty($, "description", { get() {
    return Hq.get($)?.description;
  }, configurable: true }), $.meta = (...K) => {
    if (K.length === 0) return Hq.get($);
    let P = $.clone();
    return Hq.add(P, K[0]), P;
  }, $.isOptional = () => $.safeParse(void 0).success, $.isNullable = () => $.safeParse(null).success, $;
});
var uW = O$("_ZodString", ($, q) => {
  Z_.init($, q), T6.init($, q);
  let K = $._zod.bag;
  $.format = K.format ?? null, $.minLength = K.minimum ?? null, $.maxLength = K.maximum ?? null, $.regex = (...P) => $.check($7(...P)), $.includes = (...P) => $.check(_7(...P)), $.startsWith = (...P) => $.check(P7(...P)), $.endsWith = (...P) => $.check(O7(...P)), $.min = (...P) => $.check(nK(...P)), $.max = (...P) => $.check(P4(...P)), $.length = (...P) => $.check(O4(...P)), $.nonempty = (...P) => $.check(nK(1, ...P)), $.lowercase = (P) => $.check(q7(P)), $.uppercase = (P) => $.check(K7(P)), $.trim = () => $.check(v7()), $.normalize = (...P) => $.check(j7(...P)), $.toLowerCase = () => $.check(z7()), $.toUpperCase = () => $.check(W7());
});
var u7 = O$("ZodString", ($, q) => {
  Z_.init($, q), uW.init($, q), $.email = (K) => $.check(c9(xW, K)), $.url = (K) => $.check(QP(o5, K)), $.jwt = (K) => $.check(_5(QW, K)), $.emoji = (K) => $.check(o9(pW, K)), $.guid = (K) => $.check(aP(m5, K)), $.uuid = (K) => $.check(m9(VK, K)), $.uuidv4 = (K) => $.check(d9(VK, K)), $.uuidv6 = (K) => $.check(l9(VK, K)), $.uuidv7 = (K) => $.check(r9(VK, K)), $.nanoid = (K) => $.check(n9(cW, K)), $.guid = (K) => $.check(aP(m5, K)), $.cuid = (K) => $.check(i9(mW, K)), $.cuid2 = (K) => $.check(t9(dW, K)), $.ulid = (K) => $.check(B9(lW, K)), $.base64 = (K) => $.check($5(UW, K)), $.base64url = (K) => $.check(q5(FW, K)), $.xid = (K) => $.check(U9(rW, K)), $.ksuid = (K) => $.check(F9(oW, K)), $.ipv4 = (K) => $.check(a9(nW, K)), $.ipv6 = (K) => $.check(Q9(iW, K)), $.cidrv4 = (K) => $.check(e9(tW, K)), $.cidrv6 = (K) => $.check(s9(BW, K)), $.e164 = (K) => $.check(K5(aW, K)), $.datetime = (K) => $.check(XW(K)), $.date = (K) => $.check(AW(K)), $.time = (K) => $.check(kW(K)), $.duration = (K) => $.check(GW(K));
});
function bW($) {
  return U3(u7, $);
}
__name(bW, "bW");
var E6 = O$("ZodStringFormat", ($, q) => {
  h6.init($, q), uW.init($, q);
});
var xW = O$("ZodEmail", ($, q) => {
  qj.init($, q), E6.init($, q);
});
function tm($) {
  return c9(xW, $);
}
__name(tm, "tm");
var m5 = O$("ZodGUID", ($, q) => {
  sY.init($, q), E6.init($, q);
});
function Bm($) {
  return aP(m5, $);
}
__name(Bm, "Bm");
var VK = O$("ZodUUID", ($, q) => {
  $j.init($, q), E6.init($, q);
});
function Um($) {
  return m9(VK, $);
}
__name(Um, "Um");
function Fm($) {
  return d9(VK, $);
}
__name(Fm, "Fm");
function am($) {
  return l9(VK, $);
}
__name(am, "am");
function Qm($) {
  return r9(VK, $);
}
__name(Qm, "Qm");
var o5 = O$("ZodURL", ($, q) => {
  Kj.init($, q), E6.init($, q);
});
function em($) {
  return QP(o5, $);
}
__name(em, "em");
function sm($) {
  return QP(o5, { protocol: /^https?$/, hostname: Z8.domain, ...l$.normalizeParams($) });
}
__name(sm, "sm");
var pW = O$("ZodEmoji", ($, q) => {
  _j.init($, q), E6.init($, q);
});
function $d($) {
  return o9(pW, $);
}
__name($d, "$d");
var cW = O$("ZodNanoID", ($, q) => {
  Pj.init($, q), E6.init($, q);
});
function qd($) {
  return n9(cW, $);
}
__name(qd, "qd");
var mW = O$("ZodCUID", ($, q) => {
  Oj.init($, q), E6.init($, q);
});
function Kd($) {
  return i9(mW, $);
}
__name(Kd, "Kd");
var dW = O$("ZodCUID2", ($, q) => {
  Yj.init($, q), E6.init($, q);
});
function _d($) {
  return t9(dW, $);
}
__name(_d, "_d");
var lW = O$("ZodULID", ($, q) => {
  jj.init($, q), E6.init($, q);
});
function Pd($) {
  return B9(lW, $);
}
__name(Pd, "Pd");
var rW = O$("ZodXID", ($, q) => {
  vj.init($, q), E6.init($, q);
});
function Od($) {
  return U9(rW, $);
}
__name(Od, "Od");
var oW = O$("ZodKSUID", ($, q) => {
  zj.init($, q), E6.init($, q);
});
function Yd($) {
  return F9(oW, $);
}
__name(Yd, "Yd");
var nW = O$("ZodIPv4", ($, q) => {
  wj.init($, q), E6.init($, q);
});
function jd($) {
  return a9(nW, $);
}
__name(jd, "jd");
var iW = O$("ZodIPv6", ($, q) => {
  fj.init($, q), E6.init($, q);
});
function vd($) {
  return Q9(iW, $);
}
__name(vd, "vd");
var tW = O$("ZodCIDRv4", ($, q) => {
  Zj.init($, q), E6.init($, q);
});
function zd($) {
  return e9(tW, $);
}
__name(zd, "zd");
var BW = O$("ZodCIDRv6", ($, q) => {
  Xj.init($, q), E6.init($, q);
});
function Wd($) {
  return s9(BW, $);
}
__name(Wd, "Wd");
var UW = O$("ZodBase64", ($, q) => {
  kj.init($, q), E6.init($, q);
});
function Hd($) {
  return $5(UW, $);
}
__name(Hd, "Hd");
var FW = O$("ZodBase64URL", ($, q) => {
  Gj.init($, q), E6.init($, q);
});
function Jd($) {
  return q5(FW, $);
}
__name(Jd, "Jd");
var aW = O$("ZodE164", ($, q) => {
  Vj.init($, q), E6.init($, q);
});
function Td($) {
  return K5(aW, $);
}
__name(Td, "Td");
var QW = O$("ZodJWT", ($, q) => {
  Sj.init($, q), E6.init($, q);
});
function wd($) {
  return _5(QW, $);
}
__name(wd, "wd");
var x7 = O$("ZodCustomStringFormat", ($, q) => {
  Mj.init($, q), E6.init($, q);
});
function fd($, q, K = {}) {
  return Y4(x7, $, q, K);
}
__name(fd, "fd");
function Zd($) {
  return Y4(x7, "hostname", Z8.hostname, $);
}
__name(Zd, "Zd");
function Xd($) {
  return Y4(x7, "hex", Z8.hex, $);
}
__name(Xd, "Xd");
function Ad($, q) {
  let K = q?.enc ?? "hex", P = `${$}_${K}`, _ = Z8[P];
  if (!_) throw Error(`Unrecognized hash format: ${P}`);
  return Y4(x7, P, _, q);
}
__name(Ad, "Ad");
var p7 = O$("ZodNumber", ($, q) => {
  L9.init($, q), T6.init($, q), $.gt = (P, _) => $.check(WK(P, _)), $.gte = (P, _) => $.check(aq(P, _)), $.min = (P, _) => $.check(aq(P, _)), $.lt = (P, _) => $.check(zK(P, _)), $.lte = (P, _) => $.check(X8(P, _)), $.max = (P, _) => $.check(X8(P, _)), $.int = (P) => $.check(yW(P)), $.safe = (P) => $.check(yW(P)), $.positive = (P) => $.check(WK(0, P)), $.nonnegative = (P) => $.check(aq(0, P)), $.negative = (P) => $.check(zK(0, P)), $.nonpositive = (P) => $.check(X8(0, P)), $.multipleOf = (P, _) => $.check(X_(P, _)), $.step = (P, _) => $.check(X_(P, _)), $.finite = () => $;
  let K = $._zod.bag;
  $.minValue = Math.max(K.minimum ?? Number.NEGATIVE_INFINITY, K.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null, $.maxValue = Math.min(K.maximum ?? Number.POSITIVE_INFINITY, K.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null, $.isInt = (K.format ?? "").includes("int") || Number.isSafeInteger(K.multipleOf ?? 0.5), $.isFinite = true, $.format = K.format ?? null;
});
function qV($) {
  return qv(p7, $);
}
__name(qV, "qV");
var u4 = O$("ZodNumberFormat", ($, q) => {
  Nj.init($, q), p7.init($, q);
});
function yW($) {
  return _v(u4, $);
}
__name(yW, "yW");
function kd($) {
  return Pv(u4, $);
}
__name(kd, "kd");
function Gd($) {
  return Ov(u4, $);
}
__name(Gd, "Gd");
function Vd($) {
  return Yv(u4, $);
}
__name(Vd, "Vd");
function Sd($) {
  return jv(u4, $);
}
__name(Sd, "Sd");
var c7 = O$("ZodBoolean", ($, q) => {
  dP.init($, q), T6.init($, q);
});
function KV($) {
  return vv(c7, $);
}
__name(KV, "KV");
var m7 = O$("ZodBigInt", ($, q) => {
  g9.init($, q), T6.init($, q), $.gte = (P, _) => $.check(aq(P, _)), $.min = (P, _) => $.check(aq(P, _)), $.gt = (P, _) => $.check(WK(P, _)), $.gte = (P, _) => $.check(aq(P, _)), $.min = (P, _) => $.check(aq(P, _)), $.lt = (P, _) => $.check(zK(P, _)), $.lte = (P, _) => $.check(X8(P, _)), $.max = (P, _) => $.check(X8(P, _)), $.positive = (P) => $.check(WK(BigInt(0), P)), $.negative = (P) => $.check(zK(BigInt(0), P)), $.nonpositive = (P) => $.check(X8(BigInt(0), P)), $.nonnegative = (P) => $.check(aq(BigInt(0), P)), $.multipleOf = (P, _) => $.check(X_(P, _));
  let K = $._zod.bag;
  $.minValue = K.minimum ?? null, $.maxValue = K.maximum ?? null, $.format = K.format ?? null;
});
function Md($) {
  return Wv(m7, $);
}
__name(Md, "Md");
var eW = O$("ZodBigIntFormat", ($, q) => {
  Cj.init($, q), m7.init($, q);
});
function Nd($) {
  return Jv(eW, $);
}
__name(Nd, "Nd");
function Cd($) {
  return Tv(eW, $);
}
__name(Cd, "Cd");
var _V = O$("ZodSymbol", ($, q) => {
  hj.init($, q), T6.init($, q);
});
function hd($) {
  return wv(_V, $);
}
__name(hd, "hd");
var PV = O$("ZodUndefined", ($, q) => {
  Ej.init($, q), T6.init($, q);
});
function Ed($) {
  return fv(PV, $);
}
__name(Ed, "Ed");
var OV = O$("ZodNull", ($, q) => {
  Rj.init($, q), T6.init($, q);
});
function YV($) {
  return Zv(OV, $);
}
__name(YV, "YV");
var jV = O$("ZodAny", ($, q) => {
  Ij.init($, q), T6.init($, q);
});
function Rd() {
  return Xv(jV);
}
__name(Rd, "Rd");
var vV = O$("ZodUnknown", ($, q) => {
  b9.init($, q), T6.init($, q);
});
function y4() {
  return P5(vV);
}
__name(y4, "y4");
var zV = O$("ZodNever", ($, q) => {
  lP.init($, q), T6.init($, q);
});
function sW($) {
  return eP(zV, $);
}
__name(sW, "sW");
var WV = O$("ZodVoid", ($, q) => {
  Dj.init($, q), T6.init($, q);
});
function Id($) {
  return Av(WV, $);
}
__name(Id, "Id");
var n5 = O$("ZodDate", ($, q) => {
  Lj.init($, q), T6.init($, q), $.min = (P, _) => $.check(aq(P, _)), $.max = (P, _) => $.check(X8(P, _));
  let K = $._zod.bag;
  $.minDate = K.minimum ? new Date(K.minimum) : null, $.maxDate = K.maximum ? new Date(K.maximum) : null;
});
function Dd($) {
  return kv(n5, $);
}
__name(Dd, "Dd");
var HV = O$("ZodArray", ($, q) => {
  gj.init($, q), T6.init($, q), $.element = q.element, $.min = (K, P) => $.check(nK(K, P)), $.nonempty = (K) => $.check(nK(1, K)), $.max = (K, P) => $.check(P4(K, P)), $.length = (K, P) => $.check(O4(K, P)), $.unwrap = () => $.element;
});
function i5($, q) {
  return Ev(HV, $, q);
}
__name(i5, "i5");
function Ld($) {
  let q = $._zod.def.shape;
  return _H(Object.keys(q));
}
__name(Ld, "Ld");
var t5 = O$("ZodObject", ($, q) => {
  bj.init($, q), T6.init($, q), l$.defineLazy($, "shape", () => {
    return q.shape;
  }), $.keyof = () => _H(Object.keys($._zod.def.shape)), $.catchall = (K) => $.clone({ ...$._zod.def, catchall: K }), $.passthrough = () => $.clone({ ...$._zod.def, catchall: y4() }), $.loose = () => $.clone({ ...$._zod.def, catchall: y4() }), $.strict = () => $.clone({ ...$._zod.def, catchall: sW() }), $.strip = () => $.clone({ ...$._zod.def, catchall: void 0 }), $.extend = (K) => {
    return l$.extend($, K);
  }, $.safeExtend = (K) => {
    return l$.safeExtend($, K);
  }, $.merge = (K) => l$.merge($, K), $.pick = (K) => l$.pick($, K), $.omit = (K) => l$.omit($, K), $.partial = (...K) => l$.partial(OH, $, K[0]), $.required = (...K) => l$.required(YH, $, K[0]);
});
function gd($, q) {
  let K = { type: "object", shape: $ ?? {}, ...l$.normalizeParams(q) };
  return new t5(K);
}
__name(gd, "gd");
function bd($, q) {
  return new t5({ type: "object", shape: $, catchall: sW(), ...l$.normalizeParams(q) });
}
__name(bd, "bd");
function yd($, q) {
  return new t5({ type: "object", shape: $, catchall: y4(), ...l$.normalizeParams(q) });
}
__name(yd, "yd");
var $H = O$("ZodUnion", ($, q) => {
  y9.init($, q), T6.init($, q), $.options = q.options;
});
function qH($, q) {
  return new $H({ type: "union", options: $, ...l$.normalizeParams(q) });
}
__name(qH, "qH");
var JV = O$("ZodDiscriminatedUnion", ($, q) => {
  $H.init($, q), yj.init($, q);
});
function ud($, q, K) {
  return new JV({ type: "union", options: q, discriminator: $, ...l$.normalizeParams(K) });
}
__name(ud, "ud");
var TV = O$("ZodIntersection", ($, q) => {
  uj.init($, q), T6.init($, q);
});
function wV($, q) {
  return new TV({ type: "intersection", left: $, right: q });
}
__name(wV, "wV");
var fV = O$("ZodTuple", ($, q) => {
  u9.init($, q), T6.init($, q), $.rest = (K) => $.clone({ ...$._zod.def, rest: K });
});
function ZV($, q, K) {
  let P = q instanceof P6, _ = P ? K : q;
  return new fV({ type: "tuple", items: $, rest: P ? q : null, ...l$.normalizeParams(_) });
}
__name(ZV, "ZV");
var KH = O$("ZodRecord", ($, q) => {
  xj.init($, q), T6.init($, q), $.keyType = q.keyType, $.valueType = q.valueType;
});
function XV($, q, K) {
  return new KH({ type: "record", keyType: $, valueType: q, ...l$.normalizeParams(K) });
}
__name(XV, "XV");
function xd($, q, K) {
  let P = n6($);
  return P._zod.values = void 0, new KH({ type: "record", keyType: P, valueType: q, ...l$.normalizeParams(K) });
}
__name(xd, "xd");
var AV = O$("ZodMap", ($, q) => {
  pj.init($, q), T6.init($, q), $.keyType = q.keyType, $.valueType = q.valueType;
});
function pd($, q, K) {
  return new AV({ type: "map", keyType: $, valueType: q, ...l$.normalizeParams(K) });
}
__name(pd, "pd");
var kV = O$("ZodSet", ($, q) => {
  cj.init($, q), T6.init($, q), $.min = (...K) => $.check(A_(...K)), $.nonempty = (K) => $.check(A_(1, K)), $.max = (...K) => $.check(_4(...K)), $.size = (...K) => $.check(sP(...K));
});
function cd($, q) {
  return new kV({ type: "set", valueType: $, ...l$.normalizeParams(q) });
}
__name(cd, "cd");
var y7 = O$("ZodEnum", ($, q) => {
  mj.init($, q), T6.init($, q), $.enum = q.entries, $.options = Object.values(q.entries);
  let K = new Set(Object.keys(q.entries));
  $.extract = (P, _) => {
    let Y = {};
    for (let O of P) if (K.has(O)) Y[O] = q.entries[O];
    else throw Error(`Key ${O} not found in enum`);
    return new y7({ ...q, checks: [], ...l$.normalizeParams(_), entries: Y });
  }, $.exclude = (P, _) => {
    let Y = { ...q.entries };
    for (let O of P) if (K.has(O)) delete Y[O];
    else throw Error(`Key ${O} not found in enum`);
    return new y7({ ...q, checks: [], ...l$.normalizeParams(_), entries: Y });
  };
});
function _H($, q) {
  let K = Array.isArray($) ? Object.fromEntries($.map((P) => [P, P])) : $;
  return new y7({ type: "enum", entries: K, ...l$.normalizeParams(q) });
}
__name(_H, "_H");
function md($, q) {
  return new y7({ type: "enum", entries: $, ...l$.normalizeParams(q) });
}
__name(md, "md");
var GV = O$("ZodLiteral", ($, q) => {
  dj.init($, q), T6.init($, q), $.values = new Set(q.values), Object.defineProperty($, "value", { get() {
    if (q.values.length > 1) throw Error("This schema contains multiple valid literal values. Use `.values` instead.");
    return q.values[0];
  } });
});
function dd($, q) {
  return new GV({ type: "literal", values: Array.isArray($) ? $ : [$], ...l$.normalizeParams(q) });
}
__name(dd, "dd");
var VV = O$("ZodFile", ($, q) => {
  lj.init($, q), T6.init($, q), $.min = (K, P) => $.check(A_(K, P)), $.max = (K, P) => $.check(_4(K, P)), $.mime = (K, P) => $.check(Y7(Array.isArray(K) ? K : [K], P));
});
function ld($) {
  return Rv(VV, $);
}
__name(ld, "ld");
var SV = O$("ZodTransform", ($, q) => {
  rj.init($, q), T6.init($, q), $._zod.parse = (K, P) => {
    if (P.direction === "backward") throw new T_($.constructor.name);
    K.addIssue = (Y) => {
      if (typeof Y === "string") K.issues.push(l$.issue(Y, K.value, q));
      else {
        let O = Y;
        if (O.fatal) O.continue = false;
        O.code ?? (O.code = "custom"), O.input ?? (O.input = K.value), O.inst ?? (O.inst = $), K.issues.push(l$.issue(O));
      }
    };
    let _ = q.transform(K.value, K);
    if (_ instanceof Promise) return _.then((Y) => {
      return K.value = Y, K;
    });
    return K.value = _, K;
  };
});
function PH($) {
  return new SV({ type: "transform", transform: $ });
}
__name(PH, "PH");
var OH = O$("ZodOptional", ($, q) => {
  x9.init($, q), T6.init($, q), $.unwrap = () => $._zod.def.innerType;
});
function d5($) {
  return new OH({ type: "optional", innerType: $ });
}
__name(d5, "d5");
var MV = O$("ZodNullable", ($, q) => {
  oj.init($, q), T6.init($, q), $.unwrap = () => $._zod.def.innerType;
});
function l5($) {
  return new MV({ type: "nullable", innerType: $ });
}
__name(l5, "l5");
function rd($) {
  return d5(l5($));
}
__name(rd, "rd");
var NV = O$("ZodDefault", ($, q) => {
  nj.init($, q), T6.init($, q), $.unwrap = () => $._zod.def.innerType, $.removeDefault = $.unwrap;
});
function CV($, q) {
  return new NV({ type: "default", innerType: $, get defaultValue() {
    return typeof q === "function" ? q() : l$.shallowClone(q);
  } });
}
__name(CV, "CV");
var hV = O$("ZodPrefault", ($, q) => {
  ij.init($, q), T6.init($, q), $.unwrap = () => $._zod.def.innerType;
});
function EV($, q) {
  return new hV({ type: "prefault", innerType: $, get defaultValue() {
    return typeof q === "function" ? q() : l$.shallowClone(q);
  } });
}
__name(EV, "EV");
var YH = O$("ZodNonOptional", ($, q) => {
  tj.init($, q), T6.init($, q), $.unwrap = () => $._zod.def.innerType;
});
function RV($, q) {
  return new YH({ type: "nonoptional", innerType: $, ...l$.normalizeParams(q) });
}
__name(RV, "RV");
var IV = O$("ZodSuccess", ($, q) => {
  Bj.init($, q), T6.init($, q), $.unwrap = () => $._zod.def.innerType;
});
function od($) {
  return new IV({ type: "success", innerType: $ });
}
__name(od, "od");
var DV = O$("ZodCatch", ($, q) => {
  Uj.init($, q), T6.init($, q), $.unwrap = () => $._zod.def.innerType, $.removeCatch = $.unwrap;
});
function LV($, q) {
  return new DV({ type: "catch", innerType: $, catchValue: typeof q === "function" ? q : () => q });
}
__name(LV, "LV");
var gV = O$("ZodNaN", ($, q) => {
  Fj.init($, q), T6.init($, q);
});
function nd($) {
  return Vv(gV, $);
}
__name(nd, "nd");
var jH = O$("ZodPipe", ($, q) => {
  aj.init($, q), T6.init($, q), $.in = q.in, $.out = q.out;
});
function r5($, q) {
  return new jH({ type: "pipe", in: $, out: q });
}
__name(r5, "r5");
var vH = O$("ZodCodec", ($, q) => {
  jH.init($, q), rP.init($, q);
});
function id($, q, K) {
  return new vH({ type: "pipe", in: $, out: q, transform: K.decode, reverseTransform: K.encode });
}
__name(id, "id");
var bV = O$("ZodReadonly", ($, q) => {
  Qj.init($, q), T6.init($, q), $.unwrap = () => $._zod.def.innerType;
});
function yV($) {
  return new bV({ type: "readonly", innerType: $ });
}
__name(yV, "yV");
var uV = O$("ZodTemplateLiteral", ($, q) => {
  ej.init($, q), T6.init($, q);
});
function td($, q) {
  return new uV({ type: "template_literal", parts: $, ...l$.normalizeParams(q) });
}
__name(td, "td");
var xV = O$("ZodLazy", ($, q) => {
  q3.init($, q), T6.init($, q), $.unwrap = () => $._zod.def.getter();
});
function pV($) {
  return new xV({ type: "lazy", getter: $ });
}
__name(pV, "pV");
var cV = O$("ZodPromise", ($, q) => {
  $3.init($, q), T6.init($, q), $.unwrap = () => $._zod.def.innerType;
});
function Bd($) {
  return new cV({ type: "promise", innerType: $ });
}
__name(Bd, "Bd");
var mV = O$("ZodFunction", ($, q) => {
  sj.init($, q), T6.init($, q);
});
function Ud($) {
  return new mV({ type: "function", input: Array.isArray($?.input) ? ZV($?.input) : $?.input ?? i5(y4()), output: $?.output ?? y4() });
}
__name(Ud, "Ud");
var B5 = O$("ZodCustom", ($, q) => {
  K3.init($, q), T6.init($, q);
});
function Fd($) {
  let q = new I6({ check: "custom" });
  return q._zod.check = $, q;
}
__name(Fd, "Fd");
function ad($, q) {
  return Iv(B5, $ ?? (() => true), q);
}
__name(ad, "ad");
function dV($, q = {}) {
  return Dv(B5, $, q);
}
__name(dV, "dV");
function lV($) {
  return Lv($);
}
__name(lV, "lV");
function Qd($, q = { error: `Input not instance of ${$.name}` }) {
  let K = new B5({ type: "custom", check: "custom", fn: /* @__PURE__ */ __name((P) => P instanceof $, "fn"), abort: true, ...l$.normalizeParams(q) });
  return K._zod.bag.Class = $, K;
}
__name(Qd, "Qd");
var ed = /* @__PURE__ */ __name((...$) => gv({ Codec: vH, Boolean: c7, String: u7 }, ...$), "ed");
function sd($) {
  let q = pV(() => {
    return qH([bW($), qV(), KV(), YV(), i5(q), XV(bW(), q)]);
  });
  return q;
}
__name(sd, "sd");
function $l($, q) {
  return r5(PH($), q);
}
__name($l, "$l");
var ql = { invalid_type: "invalid_type", too_big: "too_big", too_small: "too_small", invalid_format: "invalid_format", not_multiple_of: "not_multiple_of", unrecognized_keys: "unrecognized_keys", invalid_union: "invalid_union", invalid_key: "invalid_key", invalid_element: "invalid_element", invalid_value: "invalid_value", custom: "custom" };
function Kl($) {
  o6({ customError: $ });
}
__name(Kl, "Kl");
function _l() {
  return o6().customError;
}
__name(_l, "_l");
var zH;
/* @__PURE__ */ (function($) {
})(zH || (zH = {}));
var WH = {};
rq(WH, { string: /* @__PURE__ */ __name(() => Pl, "string"), number: /* @__PURE__ */ __name(() => Ol, "number"), date: /* @__PURE__ */ __name(() => vl, "date"), boolean: /* @__PURE__ */ __name(() => Yl, "boolean"), bigint: /* @__PURE__ */ __name(() => jl, "bigint") });
function Pl($) {
  return F3(u7, $);
}
__name(Pl, "Pl");
function Ol($) {
  return Kv(p7, $);
}
__name(Ol, "Ol");
function Yl($) {
  return zv(c7, $);
}
__name(Yl, "Yl");
function jl($) {
  return Hv(m7, $);
}
__name(jl, "jl");
function vl($) {
  return Gv(n5, $);
}
__name(vl, "vl");
o6(oP());
function r4() {
  if (typeof process < "u" && process.versions && process.versions.node) return "node";
  if (typeof globalThis < "u" && typeof globalThis.window < "u" && typeof globalThis.window.document < "u") return "browser";
  return "unknown";
}
__name(r4, "r4");
var _L0 = class _L0 {
  store = {};
  constructor() {
    if (typeof globalThis < "u" && globalThis.window && globalThis.window.ENV) this.store = { ...globalThis.window.ENV };
    if (typeof globalThis < "u" && globalThis.__ENV__) this.store = { ...this.store, ...globalThis.__ENV__ };
  }
  get($) {
    let q = this.store[$];
    return q !== void 0 ? String(q) : void 0;
  }
  set($, q) {
    this.store[$] = q;
  }
  has($) {
    return $ in this.store;
  }
  getAll() {
    return { ...this.store };
  }
};
__name(_L0, "L0");
var L0 = _L0;
var _g0 = class _g0 {
  runtime;
  browserStore;
  cache = /* @__PURE__ */ new Map();
  constructor() {
    if (this.runtime = r4(), this.runtime === "browser") this.browserStore = new L0();
  }
  getRuntime() {
    return this.runtime;
  }
  isNode() {
    return this.runtime === "node";
  }
  isBrowser() {
    return this.runtime === "browser";
  }
  get($, q) {
    if (this.cache.has($)) {
      let P = this.cache.get($);
      return P === void 0 && q !== void 0 ? q : P;
    }
    let K;
    switch (this.runtime) {
      case "node":
        if (typeof process < "u" && process.env) K = process.env[$];
        break;
      case "browser":
        if (this.browserStore) K = this.browserStore.get($);
        break;
      default:
        K = void 0;
    }
    return this.cache.set($, K), K === void 0 && q !== void 0 ? q : K;
  }
  set($, q) {
    let K = String(q);
    switch (this.cache.delete($), this.runtime) {
      case "node":
        if (typeof process < "u" && process.env) process.env[$] = K;
        break;
      case "browser":
        if (this.browserStore) this.browserStore.set($, q);
        break;
    }
  }
  has($) {
    return this.get($) !== void 0;
  }
  getAll() {
    switch (this.runtime) {
      case "node":
        if (typeof process < "u" && process.env) return { ...process.env };
        break;
      case "browser":
        if (this.browserStore) return this.browserStore.getAll();
        break;
    }
    return {};
  }
  getBoolean($, q = false) {
    let K = this.get($);
    if (K === void 0) return q;
    return ["true", "1", "yes", "on"].includes(K.toLowerCase());
  }
  getNumber($, q) {
    let K = this.get($);
    if (K === void 0) return q;
    let P = Number(K);
    return isNaN(P) ? q : P;
  }
  clearCache() {
    this.cache.clear();
  }
};
__name(_g0, "g0");
var g0 = _g0;
var aH = null;
function o4() {
  if (!aH) aH = new g0();
  return aH;
}
__name(o4, "o4");
function __($, q) {
  return o4().get($, q);
}
__name(__, "__");
function yP$($, q) {
  o4().set($, q);
}
__name(yP$, "yP$");
function uP$($) {
  return o4().has($);
}
__name(uP$, "uP$");
function xP$($, q = false) {
  return o4().getBoolean($, q);
}
__name(xP$, "xP$");
function b0($, q) {
  return o4().getNumber($, q);
}
__name(b0, "b0");
function pP$($) {
  let q = o4();
  if (q.isBrowser()) Object.entries($).forEach(([K, P]) => {
    if (P !== void 0) q.set(K, P);
  });
}
__name(pP$, "pP$");
var cP$ = r4();
function Hi($, q = [".env", ".env.local"]) {
  if (typeof process > "u" || !process.cwd) return null;
  let K = /* @__PURE__ */ __name((() => ({})), "K"), P = (TH(), J6(JH)), _ = $ || process.cwd();
  while (true) {
    for (let O of q) {
      let z = P.join(_, O);
      if (K.existsSync(z)) return z;
    }
    let Y = P.dirname(_);
    if (Y === _) break;
    _ = Y;
  }
  return null;
}
__name(Hi, "Hi");
function mP$($) {
  if (typeof process > "u" || !process.cwd) return false;
  try {
    let q = D0(), K = $ || Hi();
    if (!K) return false;
    let P = q.config({ path: K });
    if (P.error) {
      if (typeof console < "u" && console.warn) console.warn(`Failed to parse .env file at ${K}:`, P.error);
      return false;
    }
    return true;
  } catch (q) {
    if (typeof console < "u" && console.warn) console.warn("Failed to load .env file:", q);
    return false;
  }
}
__name(mP$, "mP$");
var _HO = class _HO {
  globalStore;
  constructor($) {
    this.globalStore = $;
  }
  clear() {
    console.clear();
  }
  filterByLabel($) {
    y0($, this.globalStore.cache).forEach((K) => {
      Q7(K);
    });
  }
  filterByNamespace(...$) {
    u0($, this.globalStore.cache).forEach((K) => {
      Q7(K);
    });
  }
  filterByLevel($) {
    x0($, this.globalStore.cache).forEach((K) => {
      Q7(K);
    });
  }
  renderAll() {
    this.globalStore.cache.forEach(($) => {
      Q7($);
    });
  }
};
__name(_HO, "HO");
var HO = _HO;
var _n4 = class _n4 {
  config;
  pidCounter = 1;
  labels = /* @__PURE__ */ new Map();
  _listenerCounter = 0;
  _levelsToListeners = /* @__PURE__ */ new Map();
  _cache = [];
  constructor($ = {}) {
    this.config = $;
  }
  get cache() {
    return this._cache;
  }
  get configuration() {
    return this.config;
  }
  get pid() {
    let $ = this.pidCounter;
    return this.pidCounter++, $;
  }
  get tools() {
    return new HO(this);
  }
  addLogToCache($) {
    if (this._cache.length < (this.config.cacheSize ?? 300)) this._cache.push($);
  }
  clearCache() {
    this._cache = [];
  }
  getLabel($) {
    return this.labels.get($);
  }
  setLabel($, q) {
    this.labels.set($, q);
  }
  addListener($, q) {
    let K = this._listenerCounter += 1;
    return e7({ ...W8.levels, ...this.config.levels ?? {} }, $).forEach((_) => {
      if (this._levelsToListeners.has(_)) this._levelsToListeners.get(_).set(K, q);
      else this._levelsToListeners.set(_, /* @__PURE__ */ new Map([[K, q]]));
    }), K;
  }
  removeListener($) {
    this._levelsToListeners.forEach((q) => {
      q.delete($);
    });
  }
  getListeners($) {
    return Array.from(this._levelsToListeners.get($)?.values() ?? []);
  }
};
__name(_n4, "n4");
var n4 = _n4;
function QH($) {
  return globalThis.$adzeGlobal = new n4($), globalThis.$adzeGlobal;
}
__name(QH, "QH");
function JO($) {
  let q = globalThis.$adzeGlobal;
  if (Ji(q)) return q;
  let K = new n4($);
  return globalThis.$adzeGlobal = K, K;
}
__name(JO, "JO");
function Ji($) {
  return $ instanceof n4;
}
__name(Ji, "Ji");
function EK() {
  return typeof window < "u" && typeof window.location < "u" && typeof window.navigator.userAgent < "u" && !Ti();
}
__name(EK, "EK");
function Ti() {
  return typeof Deno < "u";
}
__name(Ti, "Ti");
function p0($) {
  return EK();
}
__name(p0, "p0");
function c0() {
  let $ = false;
  if (EK()) $ = new URLSearchParams(globalThis.location.search).get("ADZE_ENV") === "test";
  return globalThis.$ADZE_ENV === "test" || $;
}
__name(c0, "c0");
function m0() {
  let $ = globalThis;
  if (p0($)) return $.navigator.userAgent.includes("Firefox");
  return false;
}
__name(m0, "m0");
function i4($) {
  return Object.prototype.toString.call($) === "[object String]";
}
__name(i4, "i4");
function t4($) {
  return $ !== null && typeof $ === "number" && !isNaN(Number($));
}
__name(t4, "t4");
function TO($) {
  return $J.includes($);
}
__name(TO, "TO");
function d0($) {
  return o0.includes($);
}
__name(d0, "d0");
function l0($) {
  return sH.includes($);
}
__name(l0, "l0");
function eH($) {
  return $.every((q) => i4(q));
}
__name(eH, "eH");
function r0($) {
  return Array.isArray($) && $.length === 3 && $[1] === "-";
}
__name(r0, "r0");
function n0() {
  return Error().stack?.replace(/^Error\n/, `
`);
}
__name(n0, "n0");
function i0($) {
  if (t4($.activeLevel)) return $.activeLevel;
  return $.levels[$.activeLevel].level;
}
__name(i0, "i0");
var _J = K8(B0(), 1);
var U0 = _J.default ?? _J;
function PJ($) {
  return $.charAt(0).toUpperCase() + $.slice(1);
}
__name(PJ, "PJ");
function OJ($) {
  return Object.values($).map((q) => q.level);
}
__name(OJ, "OJ");
function YJ($, q, K) {
  return $.filter((P) => P >= q && P <= K);
}
__name(YJ, "YJ");
function jJ($, q = false, K) {
  let _ = (q && K ? 9 + K.length : 9) - $.length, Y = $;
  for (let O = 0; O <= _; O += 1) Y += " ";
  return Y;
}
__name(jJ, "jJ");
function vJ($, q) {
  return q.reduce((K, P) => {
    return U0[P](K);
  }, $);
}
__name(vJ, "vJ");
function Q7($) {
  if ($.data) console[$.data.method](...$.data.message);
}
__name(Q7, "Q7");
function F0($) {
  return $.filter((q) => q !== "");
}
__name(F0, "F0");
function a0($) {
  return typeof $ === "object" && $ !== null;
}
__name(a0, "a0");
function e7($, q) {
  if (q === "*") return Object.values($).map((K) => K.level);
  if (i4(q)) return [$[q].level];
  if (t4(q)) return [q];
  if (r0(q)) {
    if (eH(q)) {
      let K = $[q[0]].level, P = $[q[2]].level;
      return YJ(OJ($), K, P);
    }
    return YJ(OJ($), q[0], q[2]);
  }
  if (Array.isArray(q) && eH(q)) return q.map((K) => $[K].level);
  return q;
}
__name(e7, "e7");
function zJ($, q, K) {
  if (q.length === 0) return false;
  return $ === "include" ? !q.includes(K) : q.includes(K);
}
__name(zJ, "zJ");
function WJ($, q) {
  if ($.length === 0) return false;
  if ($.length > 0 && q.length === 0) return true;
  return !q.map((K) => $.includes(K)).includes(true);
}
__name(WJ, "WJ");
function HJ($, q) {
  if ($.length === 0) return false;
  if ($.length > 0 && q.length === 0) return true;
  return q.map((K) => $.includes(K)).includes(true);
}
__name(HJ, "HJ");
function y0($, q) {
  return q.filter((K) => K.data?.label?.name === $);
}
__name(y0, "y0");
function u0($, q) {
  return q.filter((K) => {
    if (K.data?.namespace) return K.data.namespace.map((_) => $.includes(_)).includes(true);
    return false;
  });
}
__name(u0, "u0");
function x0($, q) {
  return q.filter((K) => {
    let P = e7(K.configuration.levels, $);
    if (K.data?.level === void 0) return false;
    return zJ("exclude", P, K.data.level);
  });
}
__name(x0, "x0");
function JJ($) {
  if ($ && $.length > 0) return $.reduce((q, K) => `${q}#${K} `, "");
  return "";
}
__name(JJ, "JJ");
function TJ($) {
  return $ ? `[${$.name}] ` : "";
}
__name(TJ, "TJ");
function wJ($) {
  return $ !== void 0 ? `(Count: ${$}) ` : "";
}
__name(wJ, "wJ");
function fJ($, q) {
  return $ !== void 0 && !$ ? `${q ? " " : ""}Assertion failed:` : "";
}
__name(fJ, "fJ");
function ZJ($, q) {
  return $ !== void 0 && $ ? `${q ? " " : ""}Expression passed:` : "";
}
__name(ZJ, "ZJ");
var wO = -1;
var B4 = 0;
var U4 = 1;
var F4 = 2;
var s7 = 3;
var $1 = 4;
var q1 = 5;
var K1 = 6;
var fO = 7;
var ZO = 8;
var Q0 = typeof self === "object" ? self : globalThis;
var wi = /* @__PURE__ */ __name(($, q) => {
  let K = /* @__PURE__ */ __name((_, Y) => {
    return $.set(Y, _), _;
  }, "K"), P = /* @__PURE__ */ __name((_) => {
    if ($.has(_)) return $.get(_);
    let [Y, O] = q[_];
    switch (Y) {
      case B4:
      case wO:
        return K(O, _);
      case U4: {
        let z = K([], _);
        for (let J of O) z.push(P(J));
        return z;
      }
      case F4: {
        let z = K({}, _);
        for (let [J, T] of O) z[P(J)] = P(T);
        return z;
      }
      case s7:
        return K(new Date(O), _);
      case $1: {
        let { source: z, flags: J } = O;
        return K(new RegExp(z, J), _);
      }
      case q1: {
        let z = K(/* @__PURE__ */ new Map(), _);
        for (let [J, T] of O) z.set(P(J), P(T));
        return z;
      }
      case K1: {
        let z = K(/* @__PURE__ */ new Set(), _);
        for (let J of O) z.add(P(J));
        return z;
      }
      case fO: {
        let { name: z, message: J } = O;
        return K(new Q0[z](J), _);
      }
      case ZO:
        return K(BigInt(O), _);
      case "BigInt":
        return K(Object(BigInt(O)), _);
    }
    return K(new Q0[Y](O), _);
  }, "P");
  return P;
}, "wi");
var XJ = /* @__PURE__ */ __name(($) => wi(/* @__PURE__ */ new Map(), $)(0), "XJ");
var a4 = "";
var { toString: fi } = {};
var { keys: Zi } = Object;
var _1 = /* @__PURE__ */ __name(($) => {
  let q = typeof $;
  if (q !== "object" || !$) return [B4, q];
  let K = fi.call($).slice(8, -1);
  switch (K) {
    case "Array":
      return [U4, a4];
    case "Object":
      return [F4, a4];
    case "Date":
      return [s7, a4];
    case "RegExp":
      return [$1, a4];
    case "Map":
      return [q1, a4];
    case "Set":
      return [K1, a4];
  }
  if (K.includes("Array")) return [U4, K];
  if (K.includes("Error")) return [fO, K];
  return [F4, K];
}, "_1");
var XO = /* @__PURE__ */ __name(([$, q]) => $ === B4 && (q === "function" || q === "symbol"), "XO");
var Xi = /* @__PURE__ */ __name(($, q, K, P) => {
  let _ = /* @__PURE__ */ __name((O, z) => {
    let J = P.push(O) - 1;
    return K.set(z, J), J;
  }, "_"), Y = /* @__PURE__ */ __name((O) => {
    if (K.has(O)) return K.get(O);
    let [z, J] = _1(O);
    switch (z) {
      case B4: {
        let X = O;
        switch (J) {
          case "bigint":
            z = ZO, X = O.toString();
            break;
          case "function":
          case "symbol":
            if ($) throw TypeError("unable to serialize " + J);
            X = null;
            break;
          case "undefined":
            return _([wO], O);
        }
        return _([z, X], O);
      }
      case U4: {
        if (J) return _([J, [...O]], O);
        let X = [], f = _([z, X], O);
        for (let V of O) X.push(Y(V));
        return f;
      }
      case F4: {
        if (J) switch (J) {
          case "BigInt":
            return _([J, O.toString()], O);
          case "Boolean":
          case "Number":
          case "String":
            return _([J, O.valueOf()], O);
        }
        if (q && "toJSON" in O) return Y(O.toJSON());
        let X = [], f = _([z, X], O);
        for (let V of Zi(O)) if ($ || !XO(_1(O[V]))) X.push([Y(V), Y(O[V])]);
        return f;
      }
      case s7:
        return _([z, O.toISOString()], O);
      case $1: {
        let { source: X, flags: f } = O;
        return _([z, { source: X, flags: f }], O);
      }
      case q1: {
        let X = [], f = _([z, X], O);
        for (let [V, M] of O) if ($ || !(XO(_1(V)) || XO(_1(M)))) X.push([Y(V), Y(M)]);
        return f;
      }
      case K1: {
        let X = [], f = _([z, X], O);
        for (let V of O) if ($ || !XO(_1(V))) X.push(Y(V));
        return f;
      }
    }
    let { message: T } = O;
    return _([z, { name: J, message: T }], O);
  }, "Y");
  return Y;
}, "Xi");
var AJ = /* @__PURE__ */ __name(($, { json: q, lossy: K } = {}) => {
  let P = [];
  return Xi(!(q || K), !!q, /* @__PURE__ */ new Map(), P)($), P;
}, "AJ");
var kJ = typeof structuredClone === "function" ? ($, q) => q && ("json" in q || "lossy" in q) ? XJ(AJ($, q)) : structuredClone($) : ($, q) => XJ(AJ($, q));
function GJ($, q, K, P) {
  let { formatters: _, middleware: Y = [], ...O } = q.exportValues();
  return class extends $ {
    _cfg = new Q4({ ...kJ(O), formatters: { ..._ }, middleware: [...Y] });
    _modifierData = kJ(K);
    modifierQueue = [...P];
  };
}
__name(GJ, "GJ");
function VJ([$, q]) {
  return `${$}s ${q / 1e6}ms`;
}
__name(VJ, "VJ");
function e0() {
  return VJ(AO());
}
__name(e0, "e0");
function AO($) {
  let q = performance.now() * 1e-3, K = Math.floor(q), P = Math.floor(q % 1 * 1e9);
  if ($ === void 0) return [K, P];
  let _ = K - $[0], Y = P - $[1];
  if (Y < 0) _ -= 1, Y += 1e9;
  return [_, Y];
}
__name(AO, "AO");
function e4($) {
  let q = /* @__PURE__ */ __name((Y) => `${Math.floor(Math.abs(Y))}`.padStart(2, "0"), "q"), K = -$.getTimezoneOffset(), _ = `${K >= 0 ? "+" : "-"}${q(K / 60)}:${q(K % 60)}`;
  return `${$.getFullYear()}-${q($.getMonth() + 1)}-${q($.getDate())}T${q($.getHours())}:${q($.getMinutes())}:${q($.getSeconds())}${_}`;
}
__name(e4, "e4");
function s0($) {
  let q = /* @__PURE__ */ __name((E, h = 2) => String(E).padStart(h, "0"), "q"), K = q($.getDate()), _ = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"][$.getMonth()], Y = $.getFullYear(), O = q($.getHours()), z = q($.getMinutes()), J = q($.getSeconds()), T = -$.getTimezoneOffset(), X = T >= 0 ? "+" : "-", f = Math.abs(T), V = q(Math.floor(f / 60)), M = q(f % 60), N = `${X}${V}${M}`;
  return `${K}/${_}/${Y}:${O}:${z}:${J} ${N}`;
}
__name(s0, "s0");
var _p8 = class _p8 {
  cfg;
  level;
  timestampFormatFunction = /* @__PURE__ */ __name(($) => e4($), "timestampFormatFunction");
  constructor($, q) {
    this.cfg = $, this.level = q;
  }
  get timestampFormatter() {
    return this.cfg.timestampFormatter ? this.cfg.timestampFormatter : this.timestampFormatFunction;
  }
  print($, q, K) {
    if (this.level.level > i0(this.cfg)) return [];
    if (this.failsFilters($)) return [];
    if ($.assertion === true) return [];
    if ($.if === false) return [];
    if ($.method && !l0($.method)) {
      if (d0($.method) && TO($.method)) return K;
    }
    let P = EK() ? this.formatBrowser($, q, K) : this.formatServer($, q, K);
    if ($.stacktrace) P.push($.stacktrace);
    return P;
  }
  failsFilters($) {
    if (this.failsLevelSelector()) return true;
    if (this.failsNamespacesFilter($)) return true;
    if (this.failsLabelsFilter($)) return true;
    return false;
  }
  failsLevelSelector() {
    if (this.cfg.filters?.levels === void 0) return false;
    let $ = e7(this.cfg.levels, this.cfg.filters.levels.values);
    if (zJ(this.cfg.filters.levels.type, $, this.level.level)) return true;
    return false;
  }
  failsNamespacesFilter($) {
    if (this.cfg.filters?.namespaces === void 0) return false;
    if (this.cfg.filters.namespaces.values.length > 0 && $.namespace === void 0) return true;
    if (this.cfg.filters.namespaces.type === "include") {
      let K = $.namespace ?? [];
      return WJ(this.cfg.filters.namespaces.values, K);
    }
    let q = $.namespace ?? [];
    return HJ(this.cfg.filters.namespaces.values, q);
  }
  failsLabelsFilter($) {
    if (this.cfg.filters?.labels === void 0) return false;
    if (this.cfg.filters.labels.values.length > 0 && $.label === void 0) return true;
    let q = $.label ? [$.label.name] : [];
    if (this.cfg.filters.labels.type === "include") return WJ(this.cfg.filters.labels.values, q);
    return HJ(this.cfg.filters.labels.values, q);
  }
};
__name(_p8, "p8");
var p8 = _p8;
var _kO = class _kO extends p8 {
  timestampFormatFunction = /* @__PURE__ */ __name(($) => s0($), "timestampFormatFunction");
  formatBrowser($, q, K) {
    return this.formatMessage($, q, K);
  }
  formatServer($, q, K) {
    return this.formatMessage($, q, K);
  }
  formatMessage($, q, K) {
    if (this.cfg.meta.hostname === void 0) console.warn(Error("Adze: 'hostname' is required for the common log format. Please provide this value in your log's meta data."));
    let P = this.cfg.meta.hostname, _ = this.cfg.meta.ident ?? "-", Y = this.cfg.meta.user ?? "-", O = K[0];
    return [`${P} ${_} ${Y} [${q}] ${O}`];
  }
};
__name(_kO, "kO");
var kO = _kO;
var $M = kO;
function qM($) {
  return typeof $.name === "string" && typeof $.hostname === "string";
}
__name(qM, "qM");
var _GO = class _GO extends p8 {
  timestampFormatFunction = /* @__PURE__ */ __name(($) => e4($), "timestampFormatFunction");
  formatBrowser($, q, K) {
    return this.formatMessage($, q, K);
  }
  formatServer($, q, K) {
    return this.formatMessage($, q, K);
  }
  formatMessage($, q, K) {
    let P = JO(), _ = [...K], Y = _.shift();
    if (qM(this.cfg.meta)) {
      let { src: O, err: z, req_id: J, req: T, res: X, latency: f, hostname: V, name: M, ...N } = this.cfg.meta, { namespace: E, label: h } = $, I = { v: 1, level: this.level.level, levelName: this.level.levelName, name: M, hostname: V, msg: Y, args: _, pid: P.pid, time: q, meta: Object.keys(N).length > 0 ? N : void 0, namespace: E, label: h?.name, src: O, err: z, req_id: J, req: T, res: X, latency: f };
      return [JSON.stringify(I)];
    }
    return console.warn(Error("Adze: Required fields are missing from the log meta for generating a JSON log.")), [..._];
  }
};
__name(_GO, "GO");
var GO = _GO;
var KM = GO;
var _VO = class _VO extends p8 {
  formatBrowser($, q, K) {
    let P = this.formatLeader(), _ = this.formatMeta($, q);
    if (this.cfg.withEmoji) return [P, "font-size: 12px;", this.level.style, _, ...K];
    return [P, this.level.style, _, ...K];
  }
  formatServer($, q, K) {
    let P = [], Y = `${jJ(this.formatLeader(false), this.cfg.withEmoji, this.level.emoji)} `, O = this.formatMeta($, q), z = vJ(Y, this.level.terminalStyle);
    return P.push(z), O !== "" && P.push(O), [z, O, ...K];
  }
  formatLeader($ = true) {
    let q = $ ? "%c" : "", K = " " + PJ(this.level.levelName);
    if (this.cfg.withEmoji) return `${q}${this.formatEmoji($)}${q}${K}`;
    return `${q}${K}`;
  }
  formatEmoji($) {
    let q = $ ? " " : "";
    return this.level.emoji ? `${this.level.emoji}${q}` : "";
  }
  formatMeta($, q) {
    let K = this.cfg.showTimestamp ? `${q} ` : "", P = JJ($.namespace), _ = TJ($.label), Y = this.formatTime($), O = wJ($.label?.count), z = fJ($.assertion, this.cfg.withEmoji), J = ZJ($.if, this.cfg.withEmoji), T = z !== "" ? z : J !== "" ? J : "";
    return K + P + _ + Y + O + T;
  }
  formatTime($) {
    let q = this.cfg.withEmoji ? " " : "Time elapsed: ";
    if ($.timeNow) return `(${q}${$.timeNow})`;
    return $.label?.timeElapsed ? `(${q}${$.label.timeElapsed})` : "";
  }
};
__name(_VO, "VO");
var VO = _VO;
var SJ = VO;
var _P1 = class _P1 extends p8 {
  timestampFormatFunction = /* @__PURE__ */ __name(($) => e4($), "timestampFormatFunction");
  formatBrowser($, q, K) {
    return this.formatMessage(q, $, K);
  }
  formatServer($, q, K) {
    return this.formatMessage(q, $, K);
  }
  formatMessage($, q, K) {
    let P = "", { appname: _, hostname: Y, port: O } = this.cfg.meta, z = t4(O) ? `/${O}` : "", J = i4(_) ? `${_}${z}` : "", T = i4(Y) ? ` on ${Y}: ` : "", X = this.formatNamespace(q.namespace), f = q.label ? `[${q.label.name}] ` : "";
    return P = `${J}${T}${X}${f}`, [`[${$}] ${this.level.levelName.toUpperCase()}: ${P}${K[0]} `, K.map((V) => a0(V) ? JSON.stringify(V) : V).slice(1).join(" ")];
  }
  formatNamespace($) {
    if ($ && $.length > 0) return `${$.reduce((K, P, _) => {
      return _ === $.length - 1 ? `${K}${P}` : `${K}${P}/`;
    }, "")} `;
    return "";
  }
};
__name(_P1, "P1");
var P1 = _P1;
var sH = ["group", "groupCollapsed"];
var _M = ["dir", "dirxml", "table", ...sH];
var $J = ["error", "warn", "info", "log", "debug", ..._M];
var qJ = ["clear", "groupEnd"];
var o0 = [..._M, ...qJ];
var z1$ = [...$J, ...qJ];
var W8 = { activeLevel: "log", cache: false, cacheSize: 300, dump: false, format: "pretty", meta: {}, middleware: [], showTimestamp: false, silent: false, withEmoji: false, levels: { alert: Ai(), error: ki(), warn: Gi(), info: Vi(), fail: Si(), success: Mi(), log: Ni(), debug: Ci(), verbose: hi() }, formatters: { default: SJ, pretty: SJ, standard: P1, common: $M, json: KM } };
function Ai($ = {}) {
  return { levelName: "alert", level: 0, style: "padding-right: 24px; font-size: 12px; border-radius: 4px; background: linear-gradient(to right, #fc8585, #fc2323); color: #fff; border-color: #b70101;", terminalStyle: ["white", "bold", "bgRed"], method: "error", emoji: "", ...$ };
}
__name(Ai, "Ai");
function ki($ = {}) {
  return { levelName: "error", level: 1, style: "padding-right: 24px; font-size: 12px; border-radius: 4px; background: linear-gradient(to right, #fff, #ffd1d1); color: #a4000f; border-color: #e3bbbb;", terminalStyle: ["white", "bgRed"], method: "error", emoji: "", ...$ };
}
__name(ki, "ki");
function Gi($ = {}) {
  return { levelName: "warn", level: 2, style: `font-size: 12px; border-radius: 4px;  background: linear-gradient(to right, #fff, #fff0a8); color: #715100; border-color: #e3d696; padding-right: ${m0() ? "44px" : "30px"};`, terminalStyle: ["white", "bgYellow"], method: "warn", emoji: "", ...$ };
}
__name(Gi, "Gi");
function Vi($ = {}) {
  return { levelName: "info", level: 3, style: "padding-right: 44px; font-size: 12px; border-radius: 4px; background: linear-gradient(to right, #d8ebff, #b2d7ff); color: #465464; border-color: #96b5d7;", terminalStyle: ["white", "bgBlue"], method: "info", emoji: "", ...$ };
}
__name(Vi, "Vi");
function Si($ = {}) {
  return { levelName: "fail", level: 4, style: "padding-right: 44px; font-size: 12px; border-radius: 4px; background: linear-gradient(to right, #ffe8e8, #ffd1d1); color: #a4000f; border-color: #e3bbbb;", terminalStyle: ["white", "bgRed"], method: "info", emoji: "", ...$ };
}
__name(Si, "Si");
function Mi($ = {}) {
  return { levelName: "success", level: 5, style: "font-size: 12px; border-radius: 4px; padding-right: 22px; background: linear-gradient(to right, #e6f6e4, #ceedc9); color: #4e594d; border-color: #b7d1b3;", terminalStyle: ["white", "bgGreen"], method: "info", emoji: "", ...$ };
}
__name(Mi, "Mi");
function Ni($ = {}) {
  return { levelName: "log", level: 6, style: "font-size: 12px; border-radius: 4px; padding-right: 51px; background: linear-gradient(to right, #ecedef, #d9dce0); color: #333435; border-color: #bfc1c5;", terminalStyle: ["white", "bgBlackBright"], method: "log", emoji: "", ...$ };
}
__name(Ni, "Ni");
function Ci($ = {}) {
  return { levelName: "debug", level: 7, style: "font-size: 12px; padding-right: 36px; border-right: 1px solid #d9dce0; color: #465464; border-color: #999999;", terminalStyle: ["white", "bgBlack"], method: "debug", emoji: "", ...$ };
}
__name(Ci, "Ci");
function hi($ = {}) {
  return { levelName: "verbose", level: 8, style: "font-size: 12px; padding-right: 22px; color: #999999;", terminalStyle: ["black", "italic"], method: "debug", emoji: "", ...$ };
}
__name(hi, "hi");
var _Q4 = class _Q4 {
  logCfg;
  glblCfg;
  constructor($) {
    this.logCfg = $ ?? {}, this.glblCfg = globalThis.$adzeGlobal?.configuration;
  }
  updateConfiguration($) {
    this.logCfg = $;
  }
  get activeLevel() {
    return this.glblCfg?.activeLevel ?? this.logCfg.activeLevel ?? W8.activeLevel;
  }
  set activeLevel($) {
    this.logCfg.activeLevel = $;
  }
  get cache() {
    return this.glblCfg?.cache ?? this.logCfg.cache ?? W8.cache;
  }
  set cache($) {
    this.logCfg.cache = $;
  }
  get cacheSize() {
    return this.glblCfg?.cacheSize ?? this.logCfg.cacheSize ?? W8.cacheSize;
  }
  set cacheSize($) {
    this.logCfg.cacheSize = $;
  }
  get dump() {
    return this.glblCfg?.dump ?? this.logCfg.dump ?? W8.dump;
  }
  set dump($) {
    this.logCfg.dump = $;
  }
  get meta() {
    return { ...this.logCfg.meta, ...this.glblCfg?.meta };
  }
  set meta($) {
    this.logCfg.meta = $;
  }
  get silent() {
    return this.glblCfg?.silent ?? this.logCfg.silent ?? W8.silent;
  }
  set silent($) {
    this.logCfg.silent = $;
  }
  get showTimestamp() {
    return this.glblCfg?.showTimestamp ?? this.logCfg.showTimestamp ?? W8.showTimestamp;
  }
  set showTimestamp($) {
    this.logCfg.showTimestamp = $;
  }
  get withEmoji() {
    return this.glblCfg?.withEmoji ?? this.logCfg.withEmoji ?? W8.withEmoji;
  }
  set withEmoji($) {
    this.logCfg.withEmoji = $;
  }
  get format() {
    return this.glblCfg?.format ?? this.logCfg.format ?? W8.format;
  }
  set format($) {
    this.logCfg.format = $;
  }
  get levels() {
    return { ...W8.levels, ...this.logCfg.levels ?? {}, ...this.glblCfg?.levels ?? {} };
  }
  set levels($) {
    this.logCfg.levels = $;
  }
  get middleware() {
    return [...this.glblCfg?.middleware ?? [], ...this.logCfg.middleware ?? []];
  }
  set middleware($) {
    this.logCfg.middleware = $;
  }
  get filters() {
    return this.glblCfg?.filters ?? this.logCfg.filters;
  }
  set filters($) {
    this.logCfg.filters = $;
  }
  get timestampFormatter() {
    return this.glblCfg?.timestampFormatter ?? this.logCfg.timestampFormatter;
  }
  set timestampFormatter($) {
    this.logCfg.timestampFormatter = $;
  }
  get formatters() {
    return { ...W8.formatters, ...this.logCfg.formatters ?? {}, ...this.glblCfg?.formatters ?? {} };
  }
  set formatters($) {
    this.logCfg.formatters = $;
  }
  exportValues() {
    return { activeLevel: this.logCfg.activeLevel, cache: this.logCfg.cache, cacheSize: this.logCfg.cacheSize, dump: this.logCfg.dump, meta: this.logCfg.meta, silent: this.logCfg.silent, showTimestamp: this.logCfg.showTimestamp, withEmoji: this.logCfg.withEmoji, format: this.logCfg.format, levels: this.logCfg.levels, middleware: this.logCfg.middleware, filters: this.logCfg.filters, timestampFormatter: this.logCfg.timestampFormatter, formatters: this.logCfg.formatters };
  }
};
__name(_Q4, "Q4");
var Q4 = _Q4;
function Ei($) {
  return typeof $ === "function";
}
__name(Ei, "Ei");
var _s4 = class _s4 {
  globalStore;
  _cfg;
  _modifierData;
  _data;
  modifierQueue = [];
  constructor($, q) {
    this.globalStore = JO($), this._modifierData = q ?? {}, this._cfg = new Q4($), this.doHook((K) => {
      if (K.constructed) K.constructed(this);
    });
  }
  get data() {
    return this._data;
  }
  get modifierData() {
    return this._modifierData;
  }
  get configuration() {
    return this._cfg;
  }
  alert(...$) {
    this.terminate("alert", $);
  }
  static alert(...$) {
    new this().alert(...$);
  }
  error(...$) {
    this.terminate("error", $);
  }
  static error(...$) {
    new this().error(...$);
  }
  warn(...$) {
    this.terminate("warn", $);
  }
  static warn(...$) {
    new this().warn(...$);
  }
  info(...$) {
    this.terminate("info", $);
  }
  static info(...$) {
    new this().info(...$);
  }
  fail(...$) {
    this.terminate("fail", $);
  }
  static fail(...$) {
    new this().fail(...$);
  }
  success(...$) {
    this.terminate("success", $);
  }
  static success(...$) {
    new this().success(...$);
  }
  log(...$) {
    this.terminate("log", $);
  }
  static log($, ...q) {
    new this().log(...[$, ...q]);
  }
  debug(...$) {
    this.terminate("debug", $);
  }
  static debug(...$) {
    new this().debug(...$);
  }
  verbose(...$) {
    this.terminate("verbose", $);
  }
  static verbose(...$) {
    new this().verbose(...$);
  }
  clear() {
    console.clear();
  }
  static clear() {
    console.clear();
  }
  clr() {
    console.clear();
  }
  static clr() {
    console.clear();
  }
  custom($, ...q) {
    if (!this._cfg.levels[$]) return console.warn(Error("Custom log level not found in configuration.")), this;
    return this.terminate($, q), this;
  }
  static custom($, ...q) {
    return new this().custom($, ...q);
  }
  seal($) {
    if ($) this._cfg.updateConfiguration($);
    return GJ(_s4, this._cfg, this.modifierData, this.modifierQueue);
  }
  static seal($) {
    return new this().seal($);
  }
  sealTag($, q) {
    return this._cfg = new Q4({ ...this._cfg.exportValues(), ...q }), (K, ...P) => {
      let _ = String.raw({ raw: K }, ...P), Y = GJ(_s4, this._cfg, this.modifierData, this.modifierQueue), O = $;
      if (Ei(Y[O])) Y[O](_);
    };
  }
  static sealTag($, q) {
    return new this().sealTag($, q);
  }
  thread($, q) {
    if (this.runModifierQueue(), this._modifierData.label) {
      if (!this._modifierData.label.context) this._modifierData.label.context = {};
      this._modifierData.label.context = { ...this._modifierData.label.context, [$]: q };
    }
  }
  static thread($, q) {
    new this().thread($, q);
  }
  assert($) {
    return this.modifierQueue.push(["assert", (q) => {
      return q.assertion = $, q;
    }]), this;
  }
  static assert($) {
    return new this().assert($);
  }
  get closeThread() {
    return this.modifierQueue.push(["closeThread", ($) => {
      if ($.label?.context) $.label.context = void 0;
      return $;
    }]), this;
  }
  static get closeThread() {
    return new this().closeThread;
  }
  get count() {
    return this.modifierQueue.push(["count", ($) => {
      if ($.label) $.label.count = $.label.count !== void 0 ? $.label.count + 1 : 1;
      return $;
    }]), this;
  }
  static get count() {
    return new this().count;
  }
  get countClear() {
    return this.modifierQueue.push(["countClear", ($) => {
      if ($.label) delete $.label.count;
      return $;
    }]), this;
  }
  static get countClear() {
    return new this().countClear;
  }
  get countReset() {
    return this.modifierQueue.push(["countReset", ($) => {
      if ($.label) $.label.count = 0;
      return $;
    }]), this;
  }
  static get countReset() {
    return new this().countReset;
  }
  get dir() {
    return this.modifierQueue.push(["dir", ($) => {
      return $.method = "dir", $;
    }]), this;
  }
  static get dir() {
    return new this().dir;
  }
  get dirxml() {
    return this.modifierQueue.push(["dirxml", ($) => {
      return $.method = "dirxml", $;
    }]), this;
  }
  static get dirxml() {
    return new this().dirxml;
  }
  get dump() {
    return this.modifierQueue.push(["dump", ($, q) => {
      return q._cfg.dump = true, $;
    }]), this;
  }
  static get dump() {
    return new this().dump;
  }
  format($) {
    return this.modifierQueue.push(["format", (q, K) => {
      if (Object.keys(K._cfg.formatters).includes($)) return K._cfg.format = $, q;
      return console.warn(Error(`Adze: Formatter "${$}" not found in configuration.`)), q;
    }]), this;
  }
  static format($) {
    return new this().format($);
  }
  get group() {
    return this.modifierQueue.push(["group", ($) => {
      return $.method = "group", $;
    }]), this;
  }
  static get group() {
    return new this().group;
  }
  get groupCollapsed() {
    return this.modifierQueue.push(["groupCollapsed", ($) => {
      return $.method = "groupCollapsed", $;
    }]), this;
  }
  static get groupCollapsed() {
    return new this().groupCollapsed;
  }
  get groupEnd() {
    return this.modifierQueue.push(["groupEnd", ($) => {
      return $.method = "groupEnd", $;
    }]), this;
  }
  static get groupEnd() {
    return new this().groupEnd;
  }
  if($) {
    return this.modifierQueue.push(["if", (q) => {
      return q.if = $, q;
    }]), this;
  }
  static if($) {
    return new this().if($);
  }
  test($) {
    return this.if($);
  }
  static test($) {
    return new this().if($);
  }
  label($) {
    return this.modifierQueue.unshift(["label", (q) => {
      let K = this.globalStore.getLabel($) ?? { name: $ };
      return q.label = K, this.globalStore.setLabel($, K), q;
    }]), this;
  }
  static label($) {
    return new this().label($);
  }
  meta($) {
    return this.modifierQueue.push(["meta", (q, K) => {
      return K._cfg.meta = { ...K._cfg.meta, ...$ }, q;
    }]), this;
  }
  static meta($) {
    return new this().meta($);
  }
  namespace(...$) {
    return this.modifierQueue.push(["namespace", (q) => {
      let K = q.namespace ?? [];
      return q.namespace = K.length > 0 ? [...K, ...$] : $, q;
    }]), this;
  }
  static namespace(...$) {
    return new this().namespace(...$);
  }
  ns(...$) {
    return this.namespace(...$);
  }
  static ns(...$) {
    return new this().namespace(...$);
  }
  get silent() {
    return this.modifierQueue.push(["silent", ($, q) => {
      return q._cfg.silent = true, $;
    }]), this;
  }
  static get silent() {
    return new this().silent;
  }
  get table() {
    return this.modifierQueue.push(["table", ($) => {
      return $.method = "table", $;
    }]), this;
  }
  static get table() {
    return new this().table;
  }
  get time() {
    return this.modifierQueue.push(["time", ($) => {
      let q = AO();
      if ($.label) $.label.timeStart = q;
      return $;
    }]), this;
  }
  static get time() {
    return new this().time;
  }
  get timeEnd() {
    return this.modifierQueue.push(["timeEnd", ($) => {
      if ($.label?.timeStart) $.label.timeElapsed = VJ(AO($.label.timeStart));
      return $;
    }]), this;
  }
  static get timeEnd() {
    return new this().timeEnd;
  }
  get timeNow() {
    return this.modifierQueue.push(["timeNow", ($) => {
      return $.timeNow = e0(), $;
    }]), this;
  }
  static get timeNow() {
    return new this().timeNow;
  }
  get timestamp() {
    return this.modifierQueue.push(["timestamp", ($, q) => {
      return q._cfg.showTimestamp = true, $;
    }]), this;
  }
  static get timestamp() {
    return new this().timestamp;
  }
  get trace() {
    return this.modifierQueue.push(["trace", ($) => {
      return $.stacktrace = n0(), $;
    }]), this;
  }
  static get trace() {
    return new this().trace;
  }
  get withEmoji() {
    return this.modifierQueue.push(["withEmoji", ($, q) => {
      return q._cfg.withEmoji = true, $;
    }]), this;
  }
  static get withEmoji() {
    return new this().withEmoji;
  }
  print($) {
    if (c0()) return;
    if ($.silent) return;
    if ($.message.length < 1) return;
    if (TO($.method)) console[$.method](...$.message);
    else console[$.method]();
  }
  terminate($, q) {
    this.doHook((I) => {
      if (I.beforeTerminated) I.beforeTerminated(this, $, q);
    }), this.runModifierQueue();
    let K = this.getLevelConfig($), _ = new (this.selectFormatter(this._cfg.format))(this._cfg, K), Y = _.timestampFormatter(/* @__PURE__ */ new Date()), O = F0(_.print(this.modifierData, Y, q));
    if (this._cfg.dump && this.modifierData.label?.context) O.push(this.modifierData.label.context);
    this.doHook((I) => {
      if (I.beforeFormatApplied) O = I.beforeFormatApplied(this, this._cfg.format, O);
    });
    let { activeLevel: z, cache: J, cacheSize: T, dump: X, format: f, meta: V, showTimestamp: M, silent: N, withEmoji: E } = this._cfg, h = { activeLevel: z, cache: J, cacheSize: T, dump: X, format: f, meta: V, showTimestamp: M, silent: N, withEmoji: E, ...K, ...this._modifierData, terminator: $, args: q, timestamp: Y, message: O };
    if (this.doHook((I) => {
      if (I.afterFormatApplied) I.afterFormatApplied(this, this._cfg.format, O);
    }), this._data = h, this._cfg.cache) this.globalStore.addLogToCache(this);
    this.doHook((I) => {
      if (I.beforePrint) I.beforePrint(this);
    }), this.print(this._data), this.doHook((I) => {
      if (I.afterTerminated) I.afterTerminated(this, $, q);
    }), this.globalStore.getListeners(K.level).forEach((I) => {
      I(this);
    });
  }
  selectFormatter($) {
    return this._cfg.formatters[$];
  }
  getLevelConfig($) {
    return this._cfg.levels[$];
  }
  runModifierQueue() {
    this.modifierQueue.forEach(([$, q]) => {
      let K = q(this.modifierData, this);
      this.doHook((P) => {
        if (P.beforeModifierApplied) P.beforeModifierApplied(this, $, K);
      }), this._modifierData = K, this.doHook((P) => {
        if (P.afterModifierApplied) P.afterModifierApplied(this, $, K);
      });
    });
  }
  doHook($) {
    this._cfg.middleware?.forEach((q) => {
      $(q);
    });
  }
};
__name(_s4, "s4");
var s4 = _s4;
var Ii = ["black", "red", "green", "yellow", "blue", "magenta", "cyan", "white", "gray", "blackBright", "redBright", "greenBright", "yellowBright", "blueBright", "magentaBright", "cyanBright", "whiteBright", "bgBlack", "bgRed", "bgGreen", "bgYellow", "bgBlue", "bgMagenta", "bgCyan", "bgWhite", "bgBlackBright", "bgRedBright", "bgGreenBright", "bgYellowBright", "bgBlueBright", "bgMagentaBright", "bgCyanBright", "bgWhiteBright", "reset", "bold", "dim", "italic", "underline", "inverse", "hidden", "strikethrough"];
var PM = Object.freeze(Ii);
var OM = s4;
var x1$ = { __noop: /* @__PURE__ */ __name(() => {
}, "__noop") };
var SO = { trace: 10, verbose: 10, debug: 20, success: 27, progress: 28, log: 29, info: 30, warn: 40, error: 50, fatal: 60, alert: 60 };
var Di = { 10: "trace", 20: "debug", 27: "success", 28: "progress", 29: "log", 30: "info", 40: "warn", 50: "error", 60: "fatal" };
function YM($, q) {
  let K = SO[$.toLowerCase()] || 30, P = SO[q.toLowerCase()] || 30;
  return K >= P;
}
__name(YM, "YM");
function MJ($) {
  try {
    let q = /* @__PURE__ */ new WeakSet();
    return JSON.stringify($, (K, P) => {
      if (typeof P === "object" && P !== null) {
        if (q.has(P)) return "[Circular]";
        q.add(P);
      }
      return P;
    });
  } catch {
    return String($);
  }
}
__name(MJ, "MJ");
function jM($) {
  if (!$) return false;
  let q = $.toLowerCase().trim();
  return q === "true" || q === "1" || q === "yes" || q === "on";
}
__name(jM, "jM");
var Li = "info";
var MO = __("LOG_LEVEL") || Li;
var m1$ = { fatal: 60, error: 50, warn: 40, info: 30, log: 29, progress: 28, success: 27, debug: 20, trace: 10 };
var NJ = jM(__("LOG_JSON_FORMAT"));
var CJ = jM(__("LOG_TIMESTAMPS") ?? "true");
function gi($ = 100) {
  let q = [];
  return { write(K) {
    if (q.push(K), q.length > $) q.shift();
  }, clear() {
    q.length = 0;
  }, recentLogs() {
    return q.map((K) => {
      let P = CJ ? new Date(K.time).toISOString() : "", _ = Di[K.level ?? 30] || "info";
      return `${P} ${_} ${K.msg}`.trim();
    }).join(`
`);
  } };
}
__name(gi, "gi");
var O1 = gi();
var vM = /* @__PURE__ */ __name(() => {
  let $ = MO.toLowerCase();
  if ($ === "trace") return "verbose";
  if ($ === "debug") return "debug";
  if ($ === "log") return "log";
  if ($ === "info") return "info";
  if ($ === "warn") return "warn";
  if ($ === "error") return "error";
  if ($ === "fatal") return "alert";
  return "info";
}, "vM");
var bi = vM();
var zM = { alert: { levelName: "alert", level: 0, style: "font-size: 12px; color: #ff0000;", terminalStyle: ["bgRed", "white", "bold"], method: "error", emoji: "" }, error: { levelName: "error", level: 1, style: "font-size: 12px; color: #ff0000;", terminalStyle: ["bgRed", "whiteBright", "bold"], method: "error", emoji: "" }, warn: { levelName: "warn", level: 2, style: "font-size: 12px; color: #ffaa00;", terminalStyle: ["bgYellow", "black", "bold"], method: "warn", emoji: "" }, info: { levelName: "info", level: 3, style: "font-size: 12px; color: #0099ff;", terminalStyle: ["cyan"], method: "info", emoji: "" }, fail: { levelName: "fail", level: 4, style: "font-size: 12px; color: #ff6600;", terminalStyle: ["red", "underline"], method: "error", emoji: "" }, success: { levelName: "success", level: 5, style: "font-size: 12px; color: #00cc00;", terminalStyle: ["green"], method: "log", emoji: "" }, log: { levelName: "log", level: 6, style: "font-size: 12px; color: #888888;", terminalStyle: ["white"], method: "log", emoji: "" }, debug: { levelName: "debug", level: 7, style: "font-size: 12px; color: #9b59b6;", terminalStyle: ["gray", "dim"], method: "debug", emoji: "" }, verbose: { levelName: "verbose", level: 8, style: "font-size: 12px; color: #666666;", terminalStyle: ["gray", "dim", "italic"], method: "debug", emoji: "" } };
var yi = QH({ activeLevel: bi, format: NJ ? "json" : "pretty", timestampFormatter: CJ ? void 0 : () => "", withEmoji: false, levels: zM });
yi.addListener("*", ($) => {
  try {
    let q = $.data, K = Array.isArray(q?.message) ? q.message.map((_) => typeof _ === "string" ? _ : MJ(_)).join(" ") : typeof q?.message === "string" ? q.message : "", P = { time: Date.now(), level: typeof q?.level === "number" ? q.level : void 0, msg: K };
    O1.write(P);
  } catch {
  }
});
function ui($) {
  let q = OM, K = [];
  if (typeof $.namespace === "string") K.push($.namespace);
  if (Array.isArray($.namespaces)) K.push(...$.namespaces);
  if (K.length > 0) q = q.ns(...K);
  let P = { ...$ };
  if (delete P.namespace, delete P.namespaces, NJ) {
    if (!P.name) P.name = "elizaos";
    if (!P.hostname) {
      let Y = "unknown";
      if (typeof process < "u" && process.platform) try {
        Y = (fH(), J6(wH)).hostname();
      } catch {
        Y = "localhost";
      }
      else if (typeof window < "u" && window.location) Y = window.location.hostname || "browser";
      P.hostname = Y;
    }
  }
  let _ = { activeLevel: vM(), format: NJ ? "json" : "pretty", timestampFormatter: CJ ? void 0 : () => "", withEmoji: false, levels: zM };
  return q.meta(P).seal(_);
}
__name(ui, "ui");
function xi($) {
  let q = MO, K = {}, P;
  if (typeof $ === "object" && $ !== null) {
    if ("level" in $) q = $.level;
    if ("maxMemoryLogs" in $ && typeof $.maxMemoryLogs === "number") P = $.maxMemoryLogs;
    let { level: _, maxMemoryLogs: Y, ...O } = $;
    K = O;
  }
  return { level: q, base: K, maxMemoryLogs: P };
}
__name(xi, "xi");
function Y1($ = false) {
  let { level: q, base: K, maxMemoryLogs: P } = xi($);
  if (typeof P === "number" && P > 0) O1.clear();
  if (typeof $ === "object" && $ && "__forceType" in $ && $.__forceType === "browser") {
    let n = (typeof q === "number" ? "info" : q || MO).toLowerCase(), s = /* @__PURE__ */ __name((...U) => {
      return U.map((j) => {
        if (typeof j === "string") return j;
        if (j instanceof Error) return j.message;
        return MJ(j);
      }).join(" ");
    }, "s"), q$ = /* @__PURE__ */ __name((U, ...j) => {
      if (!YM(U, n)) return;
      let H = s(...j), Z = U === "fatal" ? "error" : U === "trace" || U === "verbose" ? "debug" : U === "success" || U === "progress" ? "info" : U === "log" ? "log" : console[U] ? U : "log";
      if (typeof console[Z] === "function") console[Z](H);
    }, "q$"), c = /* @__PURE__ */ __name((U, j, ...H) => {
      if (typeof U === "string") return j !== void 0 ? [U, j, ...H] : [U, ...H];
      if (U instanceof Error) return j !== void 0 ? [U.message, j, ...H] : [U.message, ...H];
      if (j !== void 0) return [j, U, ...H];
      return [U, ...H];
    }, "c");
    return { level: n, trace: /* @__PURE__ */ __name((U, j, ...H) => q$("trace", ...c(U, j, ...H)), "trace"), debug: /* @__PURE__ */ __name((U, j, ...H) => q$("debug", ...c(U, j, ...H)), "debug"), info: /* @__PURE__ */ __name((U, j, ...H) => q$("info", ...c(U, j, ...H)), "info"), warn: /* @__PURE__ */ __name((U, j, ...H) => q$("warn", ...c(U, j, ...H)), "warn"), error: /* @__PURE__ */ __name((U, j, ...H) => q$("error", ...c(U, j, ...H)), "error"), fatal: /* @__PURE__ */ __name((U, j, ...H) => q$("fatal", ...c(U, j, ...H)), "fatal"), success: /* @__PURE__ */ __name((U, j, ...H) => q$("success", ...c(U, j, ...H)), "success"), progress: /* @__PURE__ */ __name((U, j, ...H) => q$("progress", ...c(U, j, ...H)), "progress"), log: /* @__PURE__ */ __name((U, j, ...H) => q$("log", ...c(U, j, ...H)), "log"), clear: /* @__PURE__ */ __name(() => {
      if (typeof console.clear === "function") console.clear();
    }, "clear"), child: /* @__PURE__ */ __name((U) => Y1({ level: n, ...K, ...U, __forceType: "browser" }), "child") };
  }
  let Y = ui(K), z = (typeof q === "number" ? "info" : q || MO).toLowerCase(), J = /* @__PURE__ */ __name((p, n) => {
  }, "J"), T = /* @__PURE__ */ __name((p, ...n) => {
    if (!YM(p, z)) return;
    J(p, n);
    try {
      let c = "";
      if (n.length > 0) c = n.map((j) => {
        if (typeof j === "string") return j;
        if (j instanceof Error) return j.message;
        return MJ(j);
      }).join(" ");
      if (K.namespace) c = `#${K.namespace}  ${c}`;
      let U = { time: Date.now(), level: SO[p.toLowerCase()] || SO.info, msg: c };
      O1.write(U);
    } catch {
    }
    let s = p, q$ = n;
    if (p === "fatal") s = "alert";
    else if (p === "progress") s = "info", q$ = ["[PROGRESS]", ...n];
    else if (p === "success") s = "info", q$ = ["[SUCCESS]", ...n];
    else if (p === "trace") s = "verbose";
    try {
      Y[s](...q$);
    } catch (c) {
      console.log(`[${p.toUpperCase()}]`, ...n);
    }
  }, "T"), X = /* @__PURE__ */ __name((p, n, ...s) => {
    if (typeof p === "string") return n !== void 0 ? [p, n, ...s] : [p, ...s];
    if (p instanceof Error) return n !== void 0 ? [p.message, { error: p }, n, ...s] : [p.message, { error: p }, ...s];
    if (n !== void 0) return [n, p, ...s];
    return [p, ...s];
  }, "X");
  return { level: z, trace: /* @__PURE__ */ __name((p, n, ...s) => T("verbose", ...X(p, n, ...s)), "trace"), debug: /* @__PURE__ */ __name((p, n, ...s) => T("debug", ...X(p, n, ...s)), "debug"), info: /* @__PURE__ */ __name((p, n, ...s) => T("info", ...X(p, n, ...s)), "info"), warn: /* @__PURE__ */ __name((p, n, ...s) => T("warn", ...X(p, n, ...s)), "warn"), error: /* @__PURE__ */ __name((p, n, ...s) => T("error", ...X(p, n, ...s)), "error"), fatal: /* @__PURE__ */ __name((p, n, ...s) => T("fatal", ...X(p, n, ...s)), "fatal"), success: /* @__PURE__ */ __name((p, n, ...s) => T("success", ...X(p, n, ...s)), "success"), progress: /* @__PURE__ */ __name((p, n, ...s) => T("progress", ...X(p, n, ...s)), "progress"), log: /* @__PURE__ */ __name((p, n, ...s) => T("log", ...X(p, n, ...s)), "log"), clear: /* @__PURE__ */ __name(() => {
    try {
      if (typeof console?.clear === "function") console.clear();
    } catch {
    }
    O1.clear();
  }, "clear"), child: /* @__PURE__ */ __name((p) => {
    return Y1({ level: z, ...K, ...p });
  }, "child") };
}
__name(Y1, "Y1");
var j6 = Y1();
var d1$ = j6;
var l1$ = /* @__PURE__ */ __name(() => O1.recentLogs(), "l1$");
var KK = j6;
function HM($) {
  return $.replace(new RegExp("(?<!{){{(?![{#\\/!>])([\\s\\S]*?)}}", "g"), (q, K) => {
    if (K.trim() === "else") return `{{${K}}}`;
    return `{{{${K}}}}`;
  });
}
__name(HM, "HM");
var JM = /* @__PURE__ */ __name(({ state: $, template: q }) => {
  let K = typeof q === "function" ? q({ state: $ }) : q, P = hJ.default.compile(HM(K));
  return TM(P($), 10);
}, "JM");
var j1 = /* @__PURE__ */ __name(({ state: $, template: q }) => {
  let K = typeof q === "function" ? q({ state: $ }) : q, P = hJ.default.compile(HM(K)), O = Object.keys($).filter((J) => !["text", "values", "data"].includes(J)).reduce((J, T) => {
    return J[T] = $[T], J;
  }, {});
  return TM(P({ ...O, ...$.values }), 10);
}, "j1");
var a1$ = /* @__PURE__ */ __name(($, q) => {
  return q.length > 0 ? `${$ ? `${$}
` : $}${q}
` : "";
}, "a1$");
var TM = /* @__PURE__ */ __name(($, q) => {
  let K = Array.from({ length: q }, () => g5({ dictionaries: [b5] })), P = $;
  for (let _ = 0; _ < K.length; _++) P = P.replaceAll(`{{name${_ + 1}}}`, K[_]);
  return P;
}, "TM");
var Q1$ = /* @__PURE__ */ __name(({ messages: $, entities: q, conversationHeader: K = true }) => {
  let P = {};
  return $.forEach((O) => {
    if (O.roomId) {
      if (!P[O.roomId]) P[O.roomId] = [];
      P[O.roomId].push(O);
    }
  }), Object.values(P).forEach((O) => {
    O.sort((z, J) => (z.createdAt || 0) - (J.createdAt || 0));
  }), Object.entries(P).sort(([, O], [, z]) => (z[z.length - 1]?.createdAt || 0) - (O[O.length - 1]?.createdAt || 0)).map(([O, z]) => {
    let J = z.filter((X) => X.entityId).map((X) => {
      let f = q.find((N) => N.id === X.entityId);
      if (!f) KK.warn({ entityId: X.entityId }, "core::prompts:formatPosts - no entity for");
      let V = f?.names[0] || "Unknown User", M = f?.names[0] || "unknown";
      return `Name: ${V} (@${M} EntityID:${X.entityId})
MessageID: ${X.id}${X.content.inReplyTo ? `
In reply to: ${X.content.inReplyTo}` : ""}
Source: ${X.content.source}
Date: ${wM(X.createdAt || 0)}
Text:
${X.content.text}`;
    });
    return `${K ? `Conversation: ${O.slice(-5)}
` : ""}${J.join(`

`)}`;
  }).join(`

`);
}, "Q1$");
var e1$ = /* @__PURE__ */ __name(({ messages: $, entities: q }) => {
  return $.reverse().filter((P) => P.entityId).map((P) => {
    let _ = P.content.text, Y = P.content.actions, O = P.content.thought, z = q.find((b) => b.id === P.entityId)?.names[0] || "Unknown User", J = P.content.attachments, T = J && J.length > 0 ? ` (Attachments: ${J.map((b) => {
      let y = [`[${b.id} - ${b.title} (${b.url})]`];
      if (b.text) y.push(`Text: ${b.text}`);
      if (b.description) y.push(`Description: ${b.description}`);
      return y.join(`
`);
    }).join(J.every((b) => !b.text && !b.description) ? ", " : `
`)})` : null, X = new Date(P.createdAt || 0), f = X.getHours().toString().padStart(2, "0"), V = X.getMinutes().toString().padStart(2, "0"), M = `${f}:${V}`, N = wM(P.createdAt || 0), E = O ? `(${z}'s internal thought: ${O})` : null, h = `${M} (${N}) [${P.entityId}]`, I = _ ? `${h} ${z}: ${_}` : null, D = Y && Y.length > 0 ? `${I ? "" : h} (${z}'s actions: ${Y.join(", ")})` : null;
    return [I, E, D, T].filter(Boolean).join(`
`);
  }).join(`
`);
}, "e1$");
var wM = /* @__PURE__ */ __name(($) => {
  let K = (/* @__PURE__ */ new Date()).getTime() - $, P = Math.abs(K), _ = Math.floor(P / 1e3), Y = Math.floor(_ / 60), O = Math.floor(Y / 60), z = Math.floor(O / 24);
  if (P < 6e4) return "just now";
  if (Y < 60) return `${Y} minute${Y !== 1 ? "s" : ""} ago`;
  if (O < 24) return `${O} hour${O !== 1 ? "s" : ""} ago`;
  return `${z} day${z !== 1 ? "s" : ""} ago`;
}, "wM");
var pi = /```json\n([\s\S]*?)\n```/;
function P_($) {
  if (!$) return null;
  let q = $.match(/<response>([\s\S]*?)<\/response>/), K;
  if (q) K = q[1], KK.debug("Found response XML block");
  else {
    let z = ((J) => {
      let T = 0, X = J.length;
      while (T < X) {
        let f = J.indexOf("<", T);
        if (f === -1) break;
        if (J.startsWith("</", f) || J.startsWith("<!--", f) || J.startsWith("<?", f)) {
          T = f + 1;
          continue;
        }
        let V = f + 1, M = "";
        while (V < X) {
          let g = J[V];
          if (/^[A-Za-z0-9_-]$/.test(g)) {
            M += g, V++;
            continue;
          }
          break;
        }
        if (!M) {
          T = f + 1;
          continue;
        }
        let N = J.indexOf(">", V);
        if (N === -1) break;
        let E = J.slice(f, N + 1);
        if (/\/\s*>$/.test(E)) {
          T = N + 1;
          continue;
        }
        let h = `</${M}>`, I = 1, D = N + 1;
        while (I > 0 && D < X) {
          let g = J.indexOf(`<${M}`, D), b = J.indexOf(h, D);
          if (b === -1) break;
          if (g !== -1 && g < b) {
            let y = J.indexOf(">", g + 1);
            if (y === -1) break;
            let p = J.slice(g, y + 1);
            if (/\/\s*>$/.test(p)) D = y + 1;
            else I++, D = y + 1;
          } else I--, D = b + h.length;
        }
        if (I === 0) {
          let g = D - h.length, b = J.slice(N + 1, g);
          return { tag: M, content: b };
        }
        T = N + 1;
      }
      return null;
    })($);
    if (!z) return KK.warn("Could not find XML block in text"), KK.debug({ textPreview: $.substring(0, 200) + "..." }, "Text content"), null;
    K = z.content, KK.debug(`Found XML block with tag: ${z.tag}`);
  }
  let P = {}, Y = ((O) => {
    let z = [], J = O.length, T = 0;
    while (T < J) {
      let X = O.indexOf("<", T);
      if (X === -1) break;
      if (O.startsWith("</", X) || O.startsWith("<!--", X) || O.startsWith("<?", X)) {
        T = X + 1;
        continue;
      }
      let f = X + 1, V = "";
      while (f < J) {
        let y = O[f];
        if (/^[A-Za-z0-9_-]$/.test(y)) {
          V += y, f++;
          continue;
        }
        break;
      }
      if (!V) {
        T = X + 1;
        continue;
      }
      let M = O.indexOf(">", f);
      if (M === -1) break;
      let N = O.slice(X, M + 1);
      if (/\/\s*>$/.test(N)) {
        T = M + 1;
        continue;
      }
      let E = `</${V}>`, h = 1, I = M + 1;
      while (h > 0 && I < J) {
        let y = O.indexOf(`<${V}`, I), p = O.indexOf(E, I);
        if (p === -1) break;
        if (y !== -1 && y < p) {
          let n = O.indexOf(">", y + 1);
          if (n === -1) break;
          let s = O.slice(y, n + 1);
          if (!/\/\s*>$/.test(s)) h++;
          I = n + 1;
        } else h--, I = p + E.length;
      }
      if (h !== 0) {
        T = M + 1;
        continue;
      }
      let D = I - E.length, b = O.slice(M + 1, D).replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&amp;/g, "&").replace(/&quot;/g, '"').replace(/&apos;/g, "'").trim();
      z.push({ key: V, value: b }), T = I;
    }
    return z;
  })(K);
  for (let { key: O, value: z } of Y) if (O === "actions" || O === "providers" || O === "evaluators") P[O] = z ? z.split(",").map((J) => J.trim()) : [];
  else if (O === "simple") P[O] = z.toLowerCase() === "true";
  else P[O] = z;
  if (Object.keys(P).length === 0) return KK.warn("No key-value pairs extracted from XML content"), KK.debug({ xmlPreview: K.substring(0, 200) + "..." }, "XML content was"), null;
  return P;
}
__name(P_, "P_");
function s1$($) {
  let q = null, K = $.match(pi);
  try {
    if (K) q = JSON.parse(WM(K[1].trim()));
    else q = JSON.parse(WM($.trim()));
  } catch (P) {
    return null;
  }
  if (q && typeof q === "object" && !Array.isArray(q)) return q;
  return null;
}
__name(s1$, "s1$");
var WM = /* @__PURE__ */ __name(($) => {
  return $ = $.replace(/\{\s+/, "{").replace(/\s+\}/, "}").trim(), $ = $.replace(/("[\w\d_-]+")\s*: \s*(?!"|\[)([\s\S]+?)(?=(,\s*"|\}$))/g, '$1: "$2"'), $ = $.replace(/"([^"]+)"\s*:\s*'([^']*)'/g, (q, K, P) => `"${K}": "${P}"`), $ = $.replace(/("[\w\d_-]+")\s*:\s*([A-Za-z_]+)(?!["\w])/g, '$1: "$2"'), $;
}, "WM");
function fM($, q) {
  if ($.length <= q) return $;
  let K = $.lastIndexOf(".", q - 1);
  if (K !== -1) {
    let Y = $.slice(0, K + 1).trim();
    if (Y.length > 0) return Y;
  }
  let P = $.lastIndexOf(" ", q - 1);
  if (P !== -1) {
    let Y = $.slice(0, P).trim();
    if (Y.length > 0) return `${Y}...`;
  }
  return `${$.slice(0, q - 3).trim()}...`;
}
__name(fM, "fM");
async function $9$($, q = 512, K = 20) {
  KK.debug("[splitChunks] Starting text split");
  let P = 3.5, Y = await new Rz({ chunkSize: Number(Math.floor(q * P)), chunkOverlap: Number(Math.floor(K * P)) }).splitText($);
  return KK.debug({ numberOfChunks: Y.length, averageChunkSize: Y.reduce((O, z) => O + z.length, 0) / Y.length }, "[splitChunks] Split complete"), Y;
}
__name($9$, "$9$");
async function q9$($, q, K) {
  if (!$) throw Error("Trim tokens received a null prompt");
  if ($.length < q / 5) return $;
  if (q <= 0) throw Error("maxTokens must be positive");
  let P = await K.useModel(M6.TEXT_TOKENIZER_ENCODE, { prompt: $ });
  if (P.length <= q) return $;
  let _ = P.slice(-q);
  return await K.useModel(M6.TEXT_TOKENIZER_DECODE, { tokens: _ });
}
__name(q9$, "q9$");
function EJ() {
  let $ = /* @__PURE__ */ new WeakSet();
  return function(q, K) {
    if (typeof K === "object" && K !== null) {
      if ($.has(K)) return "[Circular]";
      $.add(K);
    }
    return K;
  };
}
__name(EJ, "EJ");
function CO($) {
  if (!$) return false;
  if (typeof $ === "boolean") return $;
  let q = ["YES", "Y", "TRUE", "T", "1", "ON", "ENABLE"], K = ["NO", "N", "FALSE", "F", "0", "OFF", "DISABLE"], P = $.trim().toUpperCase();
  if (q.includes(P)) return true;
  if (K.includes(P)) return false;
  return false;
}
__name(CO, "CO");
var ci = n$.string().regex(/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i, "Invalid UUID format");
function mi($) {
  let q = ci.safeParse($);
  return q.success ? q.data : null;
}
__name(mi, "mi");
function hO($) {
  if (typeof $ === "number") $ = $.toString();
  if (typeof $ !== "string") throw TypeError("Value must be string");
  let q = mi($);
  if (q) return q;
  let K = encodeURIComponent($), _ = di(K).slice(0, 16);
  return _[8] = _[8] & 63 | 128, _[6] = _[6] & 15 | 0, ri(_);
}
__name(hO, "hO");
async function K9$($) {
  if (!RJ()) return;
  let q = $.map(async (K) => {
    let P = encodeURIComponent(K), _ = await ZM(P);
    p_.set(P, _);
  });
  await Promise.all(q);
}
__name(K9$, "K9$");
var p_ = /* @__PURE__ */ new Map();
var NO = null;
function RJ() {
  if (NO !== null) return NO;
  try {
    if (typeof globalThis < "u" && globalThis.crypto && globalThis.crypto.subtle && typeof globalThis.crypto.subtle.digest === "function") return NO = true, true;
  } catch {
  }
  return NO = false, false;
}
__name(RJ, "RJ");
function di($) {
  let q = p_.get($);
  if (q) return q;
  let K = XM($);
  if (p_.set($, K), RJ()) ZM($).then((P) => {
    p_.set($, P);
  }).catch(() => {
  });
  if (p_.size > 1e4) Array.from(p_.keys()).slice(0, 5e3).forEach((_) => p_.delete(_));
  return K;
}
__name(di, "di");
async function ZM($) {
  if (RJ()) try {
    let K = new TextEncoder().encode($), P = await globalThis.crypto.subtle.digest("SHA-1", K);
    return new Uint8Array(P);
  } catch {
  }
  return XM($);
}
__name(ZM, "ZM");
function XM($) {
  let q = li($), K = q.length, P = new Uint8Array(K + 9 + 63 >>> 6 << 6);
  P.set(q), P[K] = 128;
  let _ = K * 8, Y = new DataView(P.buffer);
  Y.setUint32(P.length - 4, _ >>> 0, false), Y.setUint32(P.length - 8, Math.floor(_ / 4294967296) >>> 0, false);
  let O = 1732584193, z = 4023233417, J = 2562383102, T = 271733878, X = 3285377520, f = new Uint32Array(80);
  for (let N = 0; N < P.length; N += 64) {
    for (let b = 0; b < 16; b++) f[b] = Y.getUint32(N + b * 4, false);
    for (let b = 16; b < 80; b++) {
      let y = f[b - 3] ^ f[b - 8] ^ f[b - 14] ^ f[b - 16];
      f[b] = y << 1 | y >>> 31;
    }
    let E = O, h = z, I = J, D = T, g = X;
    for (let b = 0; b < 80; b++) {
      let y, p;
      if (b < 20) y = h & I | ~h & D, p = 1518500249;
      else if (b < 40) y = h ^ I ^ D, p = 1859775393;
      else if (b < 60) y = h & I | h & D | I & D, p = 2400959708;
      else y = h ^ I ^ D, p = 3395469782;
      let n = (E << 5 | E >>> 27) + y + g + p + f[b] >>> 0;
      g = D, D = I, I = (h << 30 | h >>> 2) >>> 0, h = E, E = n;
    }
    O = O + E >>> 0, z = z + h >>> 0, J = J + I >>> 0, T = T + D >>> 0, X = X + g >>> 0;
  }
  let V = new Uint8Array(20), M = new DataView(V.buffer);
  return M.setUint32(0, O, false), M.setUint32(4, z, false), M.setUint32(8, J, false), M.setUint32(12, T, false), M.setUint32(16, X, false), V;
}
__name(XM, "XM");
function li($) {
  if (typeof TextEncoder < "u") return new TextEncoder().encode($);
  let q = [];
  for (let K = 0; K < $.length; K++) {
    let P = $.charCodeAt(K);
    if (P < 128) q.push(P);
    else if (P < 2048) q.push(192 | P >> 6, 128 | P & 63);
    else if (P < 55296 || P >= 57344) q.push(224 | P >> 12, 128 | P >> 6 & 63, 128 | P & 63);
    else {
      K++;
      let _ = 65536 + ((P & 1023) << 10 | $.charCodeAt(K) & 1023);
      q.push(240 | _ >> 18, 128 | _ >> 12 & 63, 128 | _ >> 6 & 63, 128 | _ & 63);
    }
  }
  return new Uint8Array(q);
}
__name(li, "li");
function ri($) {
  let q = [];
  for (let K = 0; K < $.length; K++) {
    let P = $[K].toString(16).padStart(2, "0");
    q.push(P);
  }
  return q.slice(0, 4).join("") + "-" + q.slice(4, 6).join("") + "-" + q.slice(6, 8).join("") + "-" + q.slice(8, 10).join("") + "-" + q.slice(10, 16).join("");
}
__name(ri, "ri");
var _9$ = /* @__PURE__ */ __name(($) => {
  if ($.startsWith("image/")) return "image";
  if ($.startsWith("video/")) return "video";
  if ($.startsWith("audio/")) return "audio";
  if ($.includes("pdf") || $.includes("document") || $.startsWith("text/")) return "document";
  return;
}, "_9$");
function AM($) {
  return `http://localhost:${__("SERVER_PORT", "3000")}${$}`;
}
__name(AM, "AM");
var kM = n$.string().regex(/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i, "Invalid UUID format").describe("Unique identifier for the character in UUID format");
var oi = n$.object({ id: n$.string().describe("Unique identifier for the media"), url: n$.string().describe("URL of the media file"), title: n$.string().optional().describe("Media title"), source: n$.string().optional().describe("Media source"), description: n$.string().optional().describe("Media description"), text: n$.string().optional().describe("Text content associated with the media"), contentType: n$.nativeEnum(KP).optional().describe("Type of media content") }).loose().describe("Media attachment with URL and metadata");
var ni = n$.object({ text: n$.string().optional().describe("The main text content of the message"), thought: n$.string().optional().describe("Internal thought process or reasoning"), actions: n$.array(n$.string()).optional().describe("Actions to be taken in response"), providers: n$.array(n$.string()).optional().describe("Data providers to use (e.g., KNOWLEDGE)"), source: n$.string().optional().describe("Source of the content"), target: n$.string().optional().describe("Target of the content"), url: n$.string().optional().describe("Related URL"), inReplyTo: kM.optional().describe("UUID of message this is replying to"), attachments: n$.array(oi).optional().describe("Array of media attachments (images, videos, documents, etc.)"), channelType: n$.enum(_P).optional().describe("Type of channel this content is for") }).catchall(n$.unknown()).describe("Content structure for messages in conversation examples");
var ii = n$.object({ name: n$.string().describe("Name of the speaker (can use {{name1}} placeholder for dynamic names)"), content: ni }).describe("A single message in a conversation example");
var ti = n$.object({ directory: n$.string().describe("Path to a directory containing knowledge files"), shared: n$.boolean().optional().describe("Whether this knowledge is shared across characters") }).describe("Directory-based knowledge source");
var Bi = n$.union([n$.string().describe("File path to a knowledge document"), n$.object({ path: n$.string().describe("Path to a knowledge file"), shared: n$.boolean().optional().describe("Whether this knowledge is shared across characters") }), ti]).describe("Knowledge source - can be a file path, file object, or directory");
var Ui = n$.union([n$.string().describe("Template string with placeholders"), n$.function().optional()]).describe("Template for generating text - can be a string template or function");
var Fi = n$.object({ all: n$.array(n$.string()).optional().describe("Style guidelines applied to all types of responses"), chat: n$.array(n$.string()).optional().describe("Style guidelines specific to chat/conversation responses"), post: n$.array(n$.string()).optional().describe("Style guidelines specific to social media posts") }).optional().describe("Style configuration defining how the character communicates across different contexts");
var ai = n$.record(n$.string(), n$.union([n$.string(), n$.boolean(), n$.number(), n$.object({}).loose(), n$.array(n$.any())])).optional().describe("Character-specific settings like avatar URL, preferences, and configuration");
var Qi = n$.record(n$.string(), n$.union([n$.string(), n$.boolean(), n$.number()])).optional().describe("Secret values and API keys (should not be committed to version control)");
var ei = n$.object({ id: kM.optional().describe("Unique identifier for the character"), name: n$.string().min(1, "Character name is required").describe('The name of the character (e.g., "Eliza")'), username: n$.string().optional().describe("Username for the character on various platforms"), system: n$.string().optional().describe("System prompt that defines the character's core behavior and response style"), templates: n$.record(n$.string(), Ui).optional().describe("Custom templates for generating different types of content"), bio: n$.union([n$.string(), n$.array(n$.string())]).describe("Character biography - can be a single string or array of biographical points"), messageExamples: n$.array(n$.array(ii)).optional().describe("Example conversations showing how the character responds in different scenarios"), postExamples: n$.array(n$.string()).optional().describe("Example social media posts demonstrating the character's voice and topics"), topics: n$.array(n$.string()).optional().describe("Topics the character is knowledgeable about and engages with"), adjectives: n$.array(n$.string()).optional().describe("Adjectives that describe the character's personality and traits"), knowledge: n$.array(Bi).optional().describe("Knowledge sources (files, directories) the character can reference"), plugins: n$.array(n$.string()).optional().describe('List of plugin package names to load (e.g., ["@elizaos/plugin-sql", "@elizaos/plugin-bootstrap"] - these are commonly required)'), settings: ai, secrets: Qi, style: Fi }).strict().describe("Complete character definition including personality, behavior, and capabilities");
function GM($) {
  let q = ei.safeParse($);
  if (q.success) return { success: true, data: q.data };
  return { success: false, error: { message: `Character validation failed: ${q.error.message}`, issues: q.error.issues } };
}
__name(GM, "GM");
function v9$($) {
  try {
    let q = JSON.parse($);
    return GM(q);
  } catch (q) {
    return { success: false, error: { message: `Invalid JSON: ${q instanceof Error ? q.message : "Unknown JSON parsing error"}` } };
  }
}
__name(v9$, "v9$");
function z9$($) {
  return GM($).success;
}
__name(z9$, "z9$");
function RK() {
  return typeof Buffer < "u" && typeof Buffer.from === "function";
}
__name(RK, "RK");
function si($) {
  let q = $.replace(/[^0-9a-fA-F]/g, "");
  if (RK()) return Buffer.from(q, "hex");
  let K = new Uint8Array(q.length / 2);
  for (let P = 0; P < K.length; P++) K[P] = parseInt(q.substr(P * 2, 2), 16);
  return K;
}
__name(si, "si");
function $t($, q = "utf8") {
  if (RK()) {
    let P = q === "utf-8" ? "utf8" : q;
    return Buffer.from($, P);
  }
  if (q === "base64") {
    let P = atob($), _ = new Uint8Array(P.length);
    for (let Y = 0; Y < P.length; Y++) _[Y] = P.charCodeAt(Y);
    return _;
  }
  return new TextEncoder().encode($);
}
__name($t, "$t");
function VM($) {
  if (RK() && Buffer.isBuffer($)) return $.toString("hex");
  let q = $ instanceof Uint8Array ? $ : new Uint8Array($), K = "";
  for (let P = 0; P < q.length; P++) {
    let _ = q[P].toString(16);
    K += _.length === 1 ? "0" + _ : _;
  }
  return K;
}
__name(VM, "VM");
function qt($, q = "utf8") {
  if (RK() && Buffer.isBuffer($)) {
    let _ = q === "utf-8" ? "utf8" : q;
    return $.toString(_);
  }
  let K = $ instanceof Uint8Array ? $ : new Uint8Array($);
  if (q === "hex") return VM(K);
  if (q === "base64") {
    let _ = "";
    for (let Y = 0; Y < K.length; Y++) _ += String.fromCharCode(K[Y]);
    return btoa(_);
  }
  return new TextDecoder().decode(K);
}
__name(qt, "qt");
function Kt($) {
  if (!$) return false;
  if (RK() && Buffer.isBuffer($)) return true;
  return $ instanceof Uint8Array || $ instanceof ArrayBuffer || typeof $ === "object" && $.buffer instanceof ArrayBuffer && typeof $.byteLength === "number" && !Array.isArray($);
}
__name(Kt, "Kt");
function _t($) {
  if (RK()) return Buffer.alloc($);
  return new Uint8Array($);
}
__name(_t, "_t");
function Pt($) {
  if (RK()) return Buffer.from($);
  return new Uint8Array($);
}
__name(Pt, "Pt");
function Ot($) {
  if (RK() && $.every((_) => Buffer.isBuffer(_))) return Buffer.concat($);
  let q = 0;
  for (let _ of $) q += _.length;
  let K = new Uint8Array(q), P = 0;
  for (let _ of $) {
    let Y = _ instanceof Uint8Array ? _ : new Uint8Array(_);
    K.set(Y, P), P += Y.length;
  }
  return K;
}
__name(Ot, "Ot");
function Yt($, q, K) {
  if (RK() && Buffer.isBuffer($)) return $.slice(q, K);
  return ($ instanceof Uint8Array ? $ : new Uint8Array($)).slice(q, K);
}
__name(Yt, "Yt");
function jt($, q) {
  if ($.length !== q.length) return false;
  let K = $ instanceof Uint8Array ? $ : new Uint8Array($), P = q instanceof Uint8Array ? q : new Uint8Array(q);
  for (let _ = 0; _ < K.length; _++) if (K[_] !== P[_]) return false;
  return true;
}
__name(jt, "jt");
function vt($) {
  return $.length;
}
__name(vt, "vt");
function zt($) {
  let q = new Uint8Array($), K = typeof globalThis < "u" ? globalThis.crypto || globalThis.webcrypto : void 0;
  if (K && typeof K.getRandomValues === "function") K.getRandomValues(q);
  else for (let P = 0; P < $; P++) q[P] = Math.floor(Math.random() * 256);
  return q;
}
__name(zt, "zt");
var O_ = { fromHex: si, fromString: $t, fromBytes: Pt, toHex: VM, toString: qt, isBuffer: Kt, alloc: _t, concat: Ot, slice: Yt, equals: jt, byteLength: vt, randomBytes: zt };
var T9$ = /* @__PURE__ */ __name(($, q) => {
  if (!$.length || q <= 0) return "";
  let K = $.filter((O) => O.examples && Array.isArray(O.examples) && O.examples.length > 0);
  if (!K.length) return "";
  let P = K.map((O) => [...O.examples || []]), _ = [], Y = P.map((O, z) => O.length > 0 ? z : -1).filter((O) => O !== -1);
  while (_.length < q && Y.length > 0) {
    let O = Math.floor(Math.random() * Y.length), z = Y[O], J = P[z], T = Math.floor(Math.random() * J.length);
    if (_.push(J.splice(T, 1)[0]), J.length === 0) Y.splice(O, 1);
  }
  return Wt(_);
}, "T9$");
var Wt = /* @__PURE__ */ __name(($) => {
  return $.map((K) => {
    let P = Array.from({ length: 5 }, () => g5({ dictionaries: [b5] }));
    return `
${K.map((Y) => {
      let O = `${Y.name}: ${Y.content.text}`;
      for (let z = 0; z < P.length; z++) O = O.replaceAll(`{{name${z + 1}}}`, P[z]);
      return O;
    }).join(`
`)}`;
  }).join(`
`);
}, "Wt");
function w9$($) {
  if (!$?.length) return "";
  return [...$].sort(() => Math.random() - 0.5).map((q) => q.name).join(", ");
}
__name(w9$, "w9$");
function f9$($) {
  if (!$?.length) return "";
  return [...$].sort(() => Math.random() - 0.5).map((q) => `- **${q.name}**: ${q.description || "No description available"}`).join(`
`);
}
__name(f9$, "f9$");
var _Ht = class _Ht {
  db;
};
__name(_Ht, "Ht");
var Ht = _Ht;
function A9$($) {
  return { ...$, createdAt: Date.now(), metadata: { type: "message", timestamp: Date.now(), scope: $.agentId ? "private" : "shared" } };
}
__name(A9$, "A9$");
function k9$($) {
  return $.type === "document";
}
__name(k9$, "k9$");
function G9$($) {
  return $.type === "fragment";
}
__name(G9$, "G9$");
function V9$($) {
  return $.type === "message";
}
__name(V9$, "V9$");
function S9$($) {
  return $.type === "description";
}
__name(S9$, "S9$");
function M9$($) {
  return $.type !== "document" && $.type !== "fragment" && $.type !== "message" && $.type !== "description";
}
__name(M9$, "M9$");
function N9$($) {
  return $.metadata?.type === "document";
}
__name(N9$, "N9$");
function C9$($) {
  return $.metadata?.type === "fragment";
}
__name(C9$, "C9$");
function h9$($, q = "") {
  return $.content.text ?? q;
}
__name(h9$, "h9$");
var SM = `<task>Decide on behalf of {{agentName}} whether they should respond to the message, ignore it or stop the conversation.</task>

<providers>
{{providers}}
</providers>

<instructions>Decide if {{agentName}} should respond to or interact with the conversation.

IMPORTANT RULES FOR RESPONDING:
- If YOUR name ({{agentName}}) is directly mentioned  RESPOND
- If someone uses a DIFFERENT name (not {{agentName}})  IGNORE (they're talking to someone else)
- If you're actively participating in a conversation and the message continues that thread  RESPOND
- If someone tells you to stop or be quiet  STOP
- Otherwise  IGNORE

The key distinction is:
- "Talking TO {{agentName}}" (your name mentioned, replies to you, continuing your conversation)  RESPOND
- "Talking ABOUT {{agentName}}" or to someone else  IGNORE
</instructions>

<output>
Do NOT include any thinking, reasoning, or <think> sections in your response.
Go directly to the XML response format without any preamble or explanation.

Respond using XML format like this:
<response>
  <name>{{agentName}}</name>
  <reasoning>Your reasoning here</reasoning>
  <action>RESPOND | IGNORE | STOP</action>
</response>

IMPORTANT: Your response must ONLY contain the <response></response> XML block above. Do not include any text, thinking, or reasoning before or after this XML block. Start your response immediately with <response> and end with </response>.
</output>`;
var MM = `<task>Generate dialog and actions for the character {{agentName}}.</task>

<providers>
{{providers}}
</providers>

<instructions>
Write a thought and plan for {{agentName}} and decide what actions to take. Also include the providers that {{agentName}} will use to have the right context for responding and acting, if any.

IMPORTANT ACTION ORDERING RULES:
- Actions are executed in the ORDER you list them - the order MATTERS!
- REPLY should come FIRST to acknowledge the user's request before executing other actions
- Common patterns:
  - For requests requiring tool use: REPLY,CALL_MCP_TOOL (acknowledge first, then gather info)
  - For task execution: REPLY,SEND_MESSAGE or REPLY,EVM_SWAP_TOKENS (acknowledge first, then do the task)
  - For multi-step operations: REPLY,ACTION1,ACTION2 (acknowledge first, then complete all steps)
- REPLY is used to acknowledge and inform the user about what you're going to do
- Follow-up actions execute the actual tasks after acknowledgment
- Use IGNORE only when you should not respond at all
- If you use IGNORE, do not include any other actions. IGNORE should be used alone when you should not respond or take any actions.

IMPORTANT PROVIDER SELECTION RULES:
- Only include providers if they are needed to respond accurately.
- If the message mentions images, photos, pictures, attachments, or visual content, OR if you see "(Attachments:" in the conversation, you MUST include "ATTACHMENTS" in your providers list
- If the message asks about or references specific people, include "ENTITIES" in your providers list  
- If the message asks about relationships or connections between people, include "RELATIONSHIPS" in your providers list
- If the message asks about facts or specific information, include "FACTS" in your providers list
- If the message asks about the environment or world context, include "WORLD" in your providers list
- If no additional context is needed, you may leave the providers list empty.

IMPORTANT CODE BLOCK FORMATTING RULES:
- If {{agentName}} includes code examples, snippets, or multi-line code in the response, ALWAYS wrap the code with \`\`\` fenced code blocks (specify the language if known, e.g., \`\`\`python).
- ONLY use fenced code blocks for actual code. Do NOT wrap non-code text, instructions, or single words in fenced code blocks.
- If including inline code (short single words or function names), use single backticks (\`) as appropriate.
- This ensures the user sees clearly formatted and copyable code when relevant.

First, think about what you want to do next and plan your actions. Then, write the next message and include the actions you plan to take.
</instructions>

<keys>
"thought" should be a short description of what the agent is thinking about and planning.
"actions" should be a comma-separated list of the actions {{agentName}} plans to take based on the thought, IN THE ORDER THEY SHOULD BE EXECUTED (if none, use IGNORE, if simply responding with text, use REPLY)
"providers" should be a comma-separated list of the providers that {{agentName}} will use to have the right context for responding and acting (NEVER use "IGNORE" as a provider - use specific provider names like ATTACHMENTS, ENTITIES, FACTS, KNOWLEDGE, etc.)
"text" should be the text of the next message for {{agentName}} which they will send to the conversation.
</keys>

<output>
Do NOT include any thinking, reasoning, or <think> sections in your response. 
Go directly to the XML response format without any preamble or explanation.

Respond using XML format like this:
<response>
    <thought>Your thought here</thought>
    <actions>ACTION1,ACTION2</actions>
    <providers>PROVIDER1,PROVIDER2</providers>
    <text>Your response text here</text>
</response>

IMPORTANT: Your response must ONLY contain the <response></response> XML block above. Do not include any text, thinking, or reasoning before or after this XML block. Start your response immediately with <response> and end with </response>.
</output>`;
var R9$ = `# Task: Create a post in the voice and style and perspective of {{agentName}} @{{twitterUserName}}.

Example task outputs:
1. A post about the importance of AI in our lives
<response>
  <thought>I am thinking about writing a post about the importance of AI in our lives</thought>
  <post>AI is changing the world and it is important to understand how it works</post>
  <imagePrompt>A futuristic cityscape with flying cars and people using AI to do things</imagePrompt>
</response>

2. A post about dogs
<response>
  <thought>I am thinking about writing a post about dogs</thought>
  <post>Dogs are man's best friend and they are loyal and loving</post>
  <imagePrompt>A dog playing with a ball in a park</imagePrompt>
</response>

3. A post about finding a new job
<response>
  <thought>Getting a job is hard, I bet there's a good tweet in that</thought>
  <post>Just keep going!</post>
  <imagePrompt>A person looking at a computer screen with a job search website</imagePrompt>
</response>

{{providers}}

Write a post that is {{adjective}} about {{topic}} (without mentioning {{topic}} directly), from the perspective of {{agentName}}. Do not add commentary or acknowledge this request, just write the post.
Your response should be 1, 2, or 3 sentences (choose the length at random).
Your response should not contain any questions. Brief, concise statements only. The total character count MUST be less than 280. No emojis. Use \\n\\n (double spaces) between statements if there are multiple statements in your response.

Your output should be formatted in XML like this:
<response>
  <thought>Your thought here</thought>
  <post>Your post text here</post>
  <imagePrompt>Optional image prompt here</imagePrompt>
</response>

The "post" field should be the post you want to send. Do not including any thinking or internal reflection in the "post" field.
The "imagePrompt" field is optional and should be a prompt for an image that is relevant to the post. It should be a single sentence that captures the essence of the post. ONLY USE THIS FIELD if it makes sense that the post would benefit from an image.
The "thought" field should be a short description of what the agent is thinking about before responding, including a brief justification for the response. Includate an explanation how the post is relevant to the topic but unique and different than other posts.

Do NOT include any thinking, reasoning, or <think> sections in your response. 
Go directly to the XML response format without any preamble or explanation.

IMPORTANT: Your response must ONLY contain the <response></response> XML block above. Do not include any text, thinking, or reasoning before or after this XML block. Start your response immediately with <response> and end with </response>.`;
var I9$ = "Respond with only a YES or a NO.";
var NM = `<task>Analyze the provided image and generate a comprehensive description with multiple levels of detail.</task>

<instructions>
Carefully examine the image and provide:
1. A concise, descriptive title that captures the main subject or scene
2. A brief summary description (1-2 sentences) highlighting the key elements
3. An extensive, detailed description that covers all visible elements, composition, lighting, colors, mood, and any other relevant details

Be objective and descriptive. Focus on what you can actually see in the image rather than making assumptions about context or meaning.
</instructions>

<output>
Do NOT include any thinking, reasoning, or <think> sections in your response. 
Go directly to the XML response format without any preamble or explanation.

Respond using XML format like this:
<response>
  <title>A concise, descriptive title for the image</title>
  <description>A brief 1-2 sentence summary of the key elements in the image</description>
  <text>An extensive, detailed description covering all visible elements, composition, lighting, colors, mood, setting, objects, people, activities, and any other relevant details you can observe in the image</text>
</response>

IMPORTANT: Your response must ONLY contain the <response></response> XML block above. Do not include any text, thinking, or reasoning before or after this XML block. Start your response immediately with <response> and end with </response>.
</output>`;
var CM = `<task>
Determine the next step the assistant should take in this conversation to help the user reach their goal.
</task>

{{recentMessages}}

# Multi-Step Workflow

In each step, decide:

1. **Which providers (if any)** should be called to gather necessary data.
2. **Which action (if any)** should be executed after providers return.
3. Decide whether the task is complete. If so, set \`isFinish: true\`. Do not select the \`REPLY\` action; replies are handled separately after task completion.

You can select **multiple providers** and at most **one action** per step.

If the task is fully resolved and no further steps are needed, mark the step as \`isFinish: true\`.

---

{{actionsWithDescriptions}}

{{providersWithDescriptions}}

These are the actions or data provider calls that have already been used in this run. Use this to avoid redundancy and guide your next move.

{{actionResults}}

<keys>
"thought" Clearly explain your reasoning for the selected providers and/or action, and how this step contributes to resolving the user's request.
"action"  Name of the action to execute after providers return (can be empty if no action is needed).
"providers" List of provider names to call in this step (can be empty if none are needed).
"isFinish" Set to true only if the task is fully complete.
</keys>

 IMPORTANT: Do **not** mark the task as \`isFinish: true\` immediately after calling an action. Wait for the action to complete before deciding the task is finished.

<output>
<response>
  <thought>Your thought here</thought>
  <action>ACTION</action>
  <providers>PROVIDER1,PROVIDER2</providers>
  <isFinish>true | false</isFinish>
</response>
</output>`;
var hM = `<task>
Summarize what the assistant has done so far and provide a final response to the user based on the completed steps.
</task>

# Context Information
{{bio}}

---

{{system}}

---

{{messageDirections}}

# Conversation Summary
Below is the users original request and conversation so far:
{{recentMessages}}

# Execution Trace
Here are the actions taken by the assistant to fulfill the request:
{{actionResults}}

# Assistants Last Reasoning Step
{{recentMessage}}

# Instructions

 - Review the execution trace and last reasoning step carefully

 - Your final output MUST be in this XML format:
<output>
<response>
  <thought>Your thought here</thought>
  <text>Your final message to the user</text>
</response>
</output>
`;
async function b9$($, q, K) {
  let P = _K($, K), _ = await $.getWorld(P);
  if (!_ || !_.metadata?.roles) return "NONE";
  if (_.metadata.roles[q]) return _.metadata.roles[q];
  if (_.metadata.roles[q]) return _.metadata.roles[q];
  return "NONE";
}
__name(b9$, "b9$");
async function y9$($, q) {
  if (!q) return j6.error("User ID is required to find server"), null;
  let K = await $.getAllWorlds();
  if (!K || K.length === 0) return j6.info("No worlds found for this agent"), null;
  let P = [];
  for (let _ of K) if (_.metadata?.ownership?.ownerId === q) P.push(_);
  return P.length ? P : null;
}
__name(y9$, "y9$");
var Sq = [];
for (let $ = 0; $ < 256; ++$) Sq.push(($ + 256).toString(16).slice(1));
function EM($, q = 0) {
  return (Sq[$[q + 0]] + Sq[$[q + 1]] + Sq[$[q + 2]] + Sq[$[q + 3]] + "-" + Sq[$[q + 4]] + Sq[$[q + 5]] + "-" + Sq[$[q + 6]] + Sq[$[q + 7]] + "-" + Sq[$[q + 8]] + Sq[$[q + 9]] + "-" + Sq[$[q + 10]] + Sq[$[q + 11]] + Sq[$[q + 12]] + Sq[$[q + 13]] + Sq[$[q + 14]] + Sq[$[q + 15]]).toLowerCase();
}
__name(EM, "EM");
var IJ;
var Jt = new Uint8Array(16);
function DJ() {
  if (!IJ) {
    if (typeof crypto > "u" || !crypto.getRandomValues) throw Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    IJ = crypto.getRandomValues.bind(crypto);
  }
  return IJ(Jt);
}
__name(DJ, "DJ");
var Tt = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var LJ = { randomUUID: Tt };
function wt($, q, K) {
  $ = $ || {};
  let P = $.random ?? $.rng?.() ?? DJ();
  if (P.length < 16) throw Error("Random bytes length must be >= 16");
  if (P[6] = P[6] & 15 | 64, P[8] = P[8] & 63 | 128, q) {
    if (K = K || 0, K < 0 || K + 16 > q.length) throw RangeError(`UUID byte range ${K}:${K + 15} is out of buffer bounds`);
    for (let _ = 0; _ < 16; ++_) q[K + _] = P[_];
    return q;
  }
  return EM(P);
}
__name(wt, "wt");
function ft($, q, K) {
  if (LJ.randomUUID && !q && !$) return LJ.randomUUID();
  return wt($, q, K);
}
__name(ft, "ft");
var Dq = ft;
var v1 = /* @__PURE__ */ new Map();
var _gJ = class _gJ {
  async handleMessage($, q, K, P) {
    let _ = { maxRetries: P?.maxRetries ?? 3, timeoutDuration: P?.timeoutDuration ?? 36e5, useMultiStep: P?.useMultiStep ?? CO($.getSetting("USE_MULTI_STEP")), maxMultiStepIterations: P?.maxMultiStepIterations ?? parseInt($.getSetting("MAX_MULTISTEP_ITERATIONS") || "6") }, Y = void 0, O = Dq();
    try {
      if ($.logger.info(`[MessageService] Message received from ${q.entityId} in room ${q.roomId}`), !v1.has($.agentId)) v1.set($.agentId, /* @__PURE__ */ new Map());
      let z = v1.get($.agentId);
      if (!z) throw Error("Agent responses map not found");
      let J = z.get(q.roomId);
      if (J) j6.warn(`[MessageService] Updating response ID for room ${q.roomId} from ${J} to ${O}`);
      z.set(q.roomId, O);
      let T = $.startRun(), X = Date.now();
      await $.emitEvent("RUN_STARTED", { runtime: $, runId: T, messageId: q.id, roomId: q.roomId, entityId: q.entityId, startTime: X, status: "started", source: "messageHandler", metadata: q.content });
      let f = new Promise((N, E) => {
        Y = setTimeout(async () => {
          await $.emitEvent("RUN_TIMEOUT", { runtime: $, runId: T, messageId: q.id, roomId: q.roomId, entityId: q.entityId, startTime: X, status: "timeout", endTime: Date.now(), duration: Date.now() - X, error: "Run exceeded timeout", source: "messageHandler" }), E(Error("Run exceeded timeout"));
        }, _.timeoutDuration);
      }), V = this.processMessage($, q, K, O, T, X, _), M = await Promise.race([V, f]);
      return clearTimeout(Y), M;
    } catch (z) {
      throw clearTimeout(Y), $.logger.error({ error: z }, "[MessageService] Error in handleMessage:"), z;
    }
  }
  async processMessage($, q, K, P, _, Y, O) {
    try {
      let z = v1.get($.agentId);
      if (!z) throw Error("Agent responses map not found");
      if (q.entityId === $.agentId) return $.logger.debug(`[MessageService] Skipping message from self (${$.agentId})`), await this.emitRunEnded($, _, q, Y, "self"), { didRespond: false, responseContent: null, responseMessages: [], state: {}, mode: "none" };
      $.logger.debug(`[MessageService] Processing message: ${fM(q.content.text || "", 50)}...`), $.logger.debug("[MessageService] Saving message to memory and queueing embeddings");
      let J;
      if (q.id) {
        let q$ = await $.getMemoryById(q.id);
        if (q$) $.logger.debug("[MessageService] Memory already exists, skipping creation"), J = q$;
        else {
          let c = await $.createMemory(q, "messages");
          J = { ...q, id: c };
        }
        await $.queueEmbeddingGeneration(J, "high");
      } else {
        let q$ = await $.createMemory(q, "messages");
        q.id = q$, J = { ...q, id: q$ }, await $.queueEmbeddingGeneration(J, "normal");
      }
      let T = await $.getParticipantUserState(q.roomId, $.agentId);
      if (CO($.getSetting("BOOTSTRAP_DEFLLMOFF")) && T === null) return $.logger.debug("[MessageService] LLM is off by default"), await this.emitRunEnded($, _, q, Y, "off"), { didRespond: false, responseContent: null, responseMessages: [], state: {}, mode: "none" };
      if (T === "MUTED" && !q.content.text?.toLowerCase().includes($.character.name.toLowerCase())) return $.logger.debug(`[MessageService] Ignoring muted room ${q.roomId}`), await this.emitRunEnded($, _, q, Y, "muted"), { didRespond: false, responseContent: null, responseMessages: [], state: {}, mode: "none" };
      let f = await $.composeState(q, ["ANXIETY", "ENTITIES", "CHARACTER", "RECENT_MESSAGES", "ACTIONS"], true), V = q.content.mentionContext, M = await $.getRoom(q.roomId);
      if (q.content.attachments && q.content.attachments.length > 0) {
        if (q.content.attachments = await this.processAttachments($, q.content.attachments), q.id) await $.updateMemory({ id: q.id, content: q.content });
      }
      let N = this.shouldRespond($, q, M ?? void 0, V);
      $.logger.debug(`[MessageService] Response decision: ${JSON.stringify(N)}`);
      let E = true;
      if (N.skipEvaluation) $.logger.debug(`[MessageService] Skipping evaluation for ${$.character.name} (${N.reason})`), E = N.shouldRespond;
      else {
        let q$ = j1({ state: f, template: $.character.templates?.shouldRespondTemplate || SM });
        $.logger.debug(`[MessageService] Using LLM evaluation for ${$.character.name} (${N.reason})`);
        let c = await $.useModel(M6.TEXT_SMALL, { prompt: q$ });
        $.logger.debug(`[MessageService] LLM evaluation result:
${c}`);
        let U = P_(c);
        $.logger.debug({ responseObject: U }, "[MessageService] Parsed evaluation result:");
        let j = ["IGNORE", "NONE"];
        E = U?.action && !j.includes(U.action.toUpperCase());
      }
      let h = null, I = [], D = "none";
      if (E) {
        let q$ = O.useMultiStep ? await this.runMultiStepCore($, q, f, K, O) : await this.runSingleShotCore($, q, f, O);
        if (h = q$.responseContent, I = q$.responseMessages, f = q$.state, D = q$.mode, z.get(q.roomId) !== P) return $.logger.info(`Response discarded - newer message being processed for agent: ${$.agentId}, room: ${q.roomId}`), { didRespond: false, responseContent: null, responseMessages: [], state: f, mode: "none" };
        if (h && q.id) h.inReplyTo = _K($, q.id);
        if (h?.providers?.length && h.providers.length > 0) f = await $.composeState(q, h.providers || []);
        if (h) {
          if (D === "simple") {
            if (h.providers && h.providers.length > 0) $.logger.debug({ providers: h.providers }, "[MessageService] Simple response used providers");
            if (K) await K(h);
          } else if (D === "actions") await $.processActions(q, I, f, async (U) => {
            if ($.logger.debug({ content: U }, "action callback"), h.actionCallbacks = U, K) return K(U);
            return [];
          });
        }
      } else {
        $.logger.debug("[MessageService] Agent decided not to respond (shouldRespond is false).");
        let q$ = z.get(q.roomId), c = CO($.getSetting("BOOTSTRAP_KEEP_RESP"));
        if (q$ !== P && !c) return $.logger.info(`Ignore response discarded - newer message being processed for agent: ${$.agentId}, room: ${q.roomId}`), await this.emitRunEnded($, _, q, Y, "replaced"), { didRespond: false, responseContent: null, responseMessages: [], state: f, mode: "none" };
        if (!q.id) return $.logger.error("[MessageService] Message ID is missing, cannot create ignore response."), await this.emitRunEnded($, _, q, Y, "noMessageId"), { didRespond: false, responseContent: null, responseMessages: [], state: f, mode: "none" };
        let U = { thought: "Agent decided not to respond to this message.", actions: ["IGNORE"], simple: true, inReplyTo: _K($, q.id) };
        if (K) await K(U);
        let j = { id: W1(Dq()), entityId: $.agentId, agentId: $.agentId, content: U, roomId: q.roomId, createdAt: Date.now() };
        await $.createMemory(j, "messages"), $.logger.debug("[MessageService] Saved ignore response to memory", `memoryId: ${j.id}`);
      }
      if (z.delete(q.roomId), z.size === 0) v1.delete($.agentId);
      await $.evaluate(q, f, E, async (q$) => {
        if ($.logger.debug({ content: q$ }, "evaluate callback"), h) h.evalCallbacks = q$;
        if (K) return K(q$);
        return [];
      }, I);
      let g = "noname";
      if (q.metadata && "entityName" in q.metadata) g = q.metadata.entityName;
      let b = q.content?.channelType === "DM", y = g;
      if (!b) {
        let q$ = await $.getRoomsByIds([q.roomId]);
        if (q$?.length) {
          let c = q$[0];
          if (c.name) y = c.name;
          if (c.worldId) {
            let U = await $.getWorld(c.worldId);
            if (U) y = U.name + "-" + y;
          }
        }
      }
      let p = /* @__PURE__ */ new Date(), n = f.data?.providers?.ACTIONS?.data?.actionsData?.map((q$) => q$.name) || [-1], s = { at: p.toString(), timestamp: parseInt("" + p.getTime() / 1e3), messageId: q.id, userEntityId: q.entityId, input: q.content.text, thought: h?.thought, simple: h?.simple, availableActions: n, actions: h?.actions, providers: h?.providers, irt: h?.inReplyTo, output: h?.text, entityName: g, source: q.content.source, channelType: q.content.channelType, roomName: y };
      return await $.emitEvent("RUN_ENDED", { runtime: $, runId: _, messageId: q.id, roomId: q.roomId, entityId: q.entityId, startTime: Y, status: "completed", endTime: Date.now(), duration: Date.now() - Y, source: "messageHandler", entityName: g, responseContent: h, metadata: s }), { didRespond: E, responseContent: h, responseMessages: I, state: f, mode: D };
    } catch (z) {
      throw console.error("error is", z), await $.emitEvent("RUN_ENDED", { runtime: $, runId: _, messageId: q.id, roomId: q.roomId, entityId: q.entityId, startTime: Y, status: "error", endTime: Date.now(), duration: Date.now() - Y, error: z.message, source: "messageHandler" }), z;
    }
  }
  shouldRespond($, q, K, P) {
    if (!K) return { shouldRespond: false, skipEvaluation: true, reason: "no room context" };
    function _(N) {
      if (!N || typeof N !== "string") return [];
      return N.trim().replace(/^\[|\]$/g, "").split(",").map((h) => h.trim()).filter(Boolean);
    }
    __name(_, "_");
    let Y = ["DM", "VOICE_DM", "SELF", "API"], O = ["client_chat"], z = _($.getSetting("ALWAYS_RESPOND_CHANNELS") || $.getSetting("SHOULD_RESPOND_BYPASS_TYPES")), J = _($.getSetting("ALWAYS_RESPOND_SOURCES") || $.getSetting("SHOULD_RESPOND_BYPASS_SOURCES")), T = new Set([...Y.map((N) => N.toString()), ...z].map((N) => N.trim().toLowerCase())), X = [...O, ...J].map((N) => N.trim().toLowerCase()), f = K.type?.toString().toLowerCase(), V = q.content.source?.toLowerCase() || "";
    if (T.has(f)) return { shouldRespond: true, skipEvaluation: true, reason: `private channel: ${f}` };
    if (X.some((N) => V.includes(N))) return { shouldRespond: true, skipEvaluation: true, reason: `whitelisted source: ${V}` };
    if (!!(P?.isMention || P?.isReply)) return { shouldRespond: true, skipEvaluation: true, reason: `platform ${P?.isMention ? "mention" : "reply"}` };
    return { shouldRespond: false, skipEvaluation: false, reason: "needs LLM evaluation" };
  }
  async processAttachments($, q) {
    if (!q || q.length === 0) return [];
    $.logger.debug(`[MessageService] Processing ${q.length} attachment(s)`);
    let K = [];
    for (let P of q) try {
      let _ = { ...P }, Y = /^(http|https):\/\//.test(P.url), O = Y ? P.url : AM(P.url);
      if (P.contentType === "image" && !P.description) {
        $.logger.debug(`[MessageService] Generating description for image: ${P.url}`);
        let z = O;
        if (!Y) {
          let J = await fetch(O);
          if (!J.ok) throw Error(`Failed to fetch image: ${J.statusText}`);
          let T = await J.arrayBuffer(), X = Buffer.from(T);
          z = `data:${J.headers.get("content-type") || "application/octet-stream"};base64,${X.toString("base64")}`;
        }
        try {
          let J = await $.useModel(M6.IMAGE_DESCRIPTION, { prompt: NM, imageUrl: z });
          if (typeof J === "string") {
            let T = P_(J);
            if (T && (T.description || T.text)) _.description = T.description || "", _.title = T.title || "Image", _.text = T.text || T.description || "", $.logger.debug(`[MessageService] Generated description: ${_.description?.substring(0, 100)}...`);
            else {
              let X = J, f = X.match(/<title>([^<]+)<\/title>/), V = X.match(/<description>([^<]+)<\/description>/), M = X.match(/<text>([^<]+)<\/text>/);
              if (f || V || M) _.title = f?.[1] || "Image", _.description = V?.[1] || "", _.text = M?.[1] || V?.[1] || "", $.logger.debug(`[MessageService] Used fallback XML parsing - description: ${_.description?.substring(0, 100)}...`);
              else $.logger.warn("[MessageService] Failed to parse XML response for image description");
            }
          } else if (J && typeof J === "object" && "description" in J) _.description = J.description, _.title = J.title || "Image", _.text = J.description, $.logger.debug(`[MessageService] Generated description: ${_.description?.substring(0, 100)}...`);
          else $.logger.warn("[MessageService] Unexpected response format for image description");
        } catch (J) {
          $.logger.error({ error: J }, "[MessageService] Error generating image description:");
        }
      } else if (P.contentType === "document" && !P.text) {
        let z = await fetch(O);
        if (!z.ok) throw Error(`Failed to fetch document: ${z.statusText}`);
        let J = z.headers.get("content-type") || "";
        if (J.startsWith("text/plain")) {
          $.logger.debug(`[MessageService] Processing plain text document: ${P.url}`);
          let X = await z.text();
          _.text = X, _.title = _.title || "Text File", $.logger.debug(`[MessageService] Extracted text content (first 100 chars): ${_.text?.substring(0, 100)}...`);
        } else $.logger.warn(`[MessageService] Skipping non-plain-text document: ${J}`);
      }
      K.push(_);
    } catch (_) {
      $.logger.error({ error: _, attachmentUrl: P.url }, `[MessageService] Failed to process attachment ${P.url}:`), K.push(P);
    }
    return K;
  }
  async runSingleShotCore($, q, K, P) {
    if (K = await $.composeState(q, ["ACTIONS"]), !K.values?.actionNames) $.logger.warn("actionNames data missing from state, even though it was requested");
    let _ = j1({ state: K, template: $.character.templates?.messageHandlerTemplate || MM }), Y = null, O = 0;
    while (O < P.maxRetries && (!Y?.thought || !Y?.actions)) {
      let T = await $.useModel(M6.TEXT_LARGE, { prompt: _ });
      $.logger.debug({ response: T }, "[MessageService] *** Raw LLM Response ***");
      let X = P_(T);
      if ($.logger.debug({ parsedXml: X }, "[MessageService] *** Parsed XML Content ***"), X) Y = { ...X, thought: X.thought || "", actions: X.actions || ["IGNORE"], providers: X.providers || [], text: X.text || "", simple: X.simple || false };
      else Y = null;
      if (O++, !Y?.thought || !Y?.actions) $.logger.warn({ response: T, parsedXml: X, responseContent: Y }, "[MessageService] *** Missing required fields (thought or actions), retrying... ***");
    }
    if (!Y) return { responseContent: null, responseMessages: [], state: K, mode: "none" };
    if (Y.actions && Y.actions.length > 1) {
      let T = /* @__PURE__ */ __name((f) => typeof f === "string" && f.toUpperCase() === "IGNORE", "T");
      if (Y.actions.some(T)) if (!Y.text || Y.text.trim() === "") Y.actions = ["IGNORE"];
      else {
        let f = Y.actions.filter((V) => !T(V));
        Y.actions = f.length ? f : ["REPLY"];
      }
    }
    let z = Y.actions?.length === 1 && typeof Y.actions[0] === "string" && Y.actions[0].toUpperCase() === "REPLY" && (!Y.providers || Y.providers.length === 0);
    Y.simple = z;
    let J = [{ id: W1(Dq()), entityId: $.agentId, agentId: $.agentId, content: Y, roomId: q.roomId, createdAt: Date.now() }];
    return { responseContent: Y, responseMessages: J, state: K, mode: z && Y.text ? "simple" : "actions" };
  }
  async runMultiStepCore($, q, K, P, _) {
    let Y = [], O = K, z = 0;
    while (z < _.maxMultiStepIterations) {
      z++, $.logger.debug(`[MultiStep] Starting iteration ${z}/${_.maxMultiStepIterations}`), O = await $.composeState(q, ["RECENT_MESSAGES", "ACTION_STATE"]), O.data.actionResults = Y;
      let M = j1({ state: O, template: $.character.templates?.multiStepDecisionTemplate || CM }), N = await $.useModel(M6.TEXT_LARGE, { prompt: M }), E = P_(N);
      if (!E) {
        $.logger.warn(`[MultiStep] Failed to parse step result at iteration ${z}`), Y.push({ data: { actionName: "parse_error" }, success: false, error: "Failed to parse step result" });
        break;
      }
      let { thought: h, providers: I = [], action: D, isFinish: g } = E;
      if (g === "true" || g === true) {
        if ($.logger.info(`[MultiStep] Task marked as complete at iteration ${z}`), P) await P({ text: "", thought: h ?? "" });
        break;
      }
      if ((!I || I.length === 0) && !D) {
        $.logger.warn(`[MultiStep] No providers or action specified at iteration ${z}, forcing completion`);
        break;
      }
      try {
        for (let b of I) {
          let y = $.providers.find((s) => s.name === b);
          if (!y) {
            $.logger.warn(`[MultiStep] Provider not found: ${b}`), Y.push({ data: { actionName: b }, success: false, error: `Provider not found: ${b}` });
            continue;
          }
          let p = await y.get($, q, K);
          if (!p) {
            $.logger.warn(`[MultiStep] Provider returned no result: ${b}`), Y.push({ data: { actionName: b }, success: false, error: "Provider returned no result" });
            continue;
          }
          let n = !!p.text;
          if (Y.push({ data: { actionName: b }, success: n, text: n ? p.text : void 0, error: n ? void 0 : "Provider returned no result" }), P) await P({ text: ` Provider executed: ${b}`, actions: [b], thought: h ?? "" });
        }
        if (D) {
          let b = { text: ` Executing action: ${D}`, actions: [D], thought: h ?? "" };
          await $.processActions(q, [{ id: Dq(), entityId: $.agentId, roomId: q.roomId, createdAt: Date.now(), content: b }], K, async () => {
            return [];
          });
          let p = $.stateCache?.get(`${q.id}_action_results`)?.values?.actionResults || [], n = p.length > 0 ? p[0] : null, s = n?.success ?? false;
          Y.push({ data: { actionName: D }, success: s, text: n?.text, values: n?.values, error: s ? void 0 : n?.text });
        }
      } catch (b) {
        $.logger.error({ err: b }, "[MultiStep] Error executing step"), Y.push({ data: { actionName: D || "unknown" }, success: false, error: b instanceof Error ? b.message : String(b) });
      }
    }
    if (z >= _.maxMultiStepIterations) $.logger.warn(`[MultiStep] Reached maximum iterations (${_.maxMultiStepIterations}), forcing completion`);
    O = await $.composeState(q, ["RECENT_MESSAGES", "ACTION_STATE"]);
    let J = j1({ state: O, template: $.character.templates?.multiStepSummaryTemplate || hM }), T = await $.useModel(M6.TEXT_LARGE, { prompt: J }), X = P_(T), f = null;
    if (X?.text) f = { actions: ["MULTI_STEP_SUMMARY"], text: X.text, thought: X.thought || "Final user-facing message after task completion.", simple: true };
    let V = f ? [{ id: W1(Dq()), entityId: $.agentId, agentId: $.agentId, content: f, roomId: q.roomId, createdAt: Date.now() }] : [];
    return { responseContent: f, responseMessages: V, state: O, mode: f ? "simple" : "none" };
  }
  async emitRunEnded($, q, K, P, _) {
    await $.emitEvent("RUN_ENDED", { runtime: $, runId: q, messageId: K.id, roomId: K.roomId, entityId: K.entityId, startTime: P, status: _, endTime: Date.now(), duration: Date.now() - P, source: "messageHandler" });
  }
  async deleteMessage($, q) {
    try {
      if (!q.id) {
        $.logger.error("[MessageService] Cannot delete memory: message ID is missing");
        return;
      }
      $.logger.info("[MessageService] Deleting memory for message", q.id, "from room", q.roomId), await $.deleteMemory(q.id), $.logger.debug({ messageId: q.id }, "[MessageService] Successfully deleted memory for message");
    } catch (K) {
      throw $.logger.error({ error: K }, "[MessageService] Error in deleteMessage:"), K;
    }
  }
  async clearChannel($, q, K) {
    try {
      $.logger.info(`[MessageService] Clearing message memories from channel ${K} -> room ${q}`);
      let P = await $.getMemoriesByRoomIds({ tableName: "messages", roomIds: [q] });
      $.logger.info(`[MessageService] Found ${P.length} message memories to delete from channel ${K}`);
      let _ = 0;
      for (let Y of P) if (Y.id) try {
        await $.deleteMemory(Y.id), _++;
      } catch (O) {
        $.logger.warn({ error: O, memoryId: Y.id }, `[MessageService] Failed to delete message memory ${Y.id}:`);
      }
      $.logger.info(`[MessageService] Successfully cleared ${_}/${P.length} message memories from channel ${K}`);
    } catch (P) {
      throw $.logger.error({ error: P }, "[MessageService] Error in clearChannel:"), P;
    }
  }
};
__name(_gJ, "gJ");
var gJ = _gJ;
var IK = /* @__PURE__ */ __name(($) => {
  switch ($) {
    case 97:
    case 101:
    case 105:
    case 111:
    case 117:
    case 121:
      return true;
    default:
      return false;
  }
}, "IK");
var Zt = /* @__PURE__ */ __name(($) => {
  switch ($) {
    case 97:
    case 101:
    case 105:
    case 111:
    case 117:
    case 121:
    case 119:
    case 120:
    case 89:
      return true;
    default:
      return false;
  }
}, "Zt");
var Xt = /* @__PURE__ */ __name(($) => {
  switch ($) {
    case 99:
    case 100:
    case 101:
    case 103:
    case 104:
    case 107:
    case 109:
    case 110:
    case 114:
    case 116:
      return true;
    default:
      return false;
  }
}, "Xt");
var At = /* @__PURE__ */ __name(($) => {
  switch ($) {
    case 98:
    case 100:
    case 102:
    case 103:
    case 109:
    case 110:
    case 112:
    case 114:
    case 116:
      return true;
    default:
      return false;
  }
}, "At");
var RM = /* @__PURE__ */ __name(($, q) => {
  return q >= 2 && IK($[q - 2]) && (q === 2 && !IK($[q - 1]) || q >= 3 && !IK($[q - 3]) && !Zt($[q - 1]));
}, "RM");
var kt = /* @__PURE__ */ __name(($) => {
  if ($.length < 3) return $;
  if ($.length <= 6) switch ($) {
    case "ski":
      return "ski";
    case "skies":
      return "sky";
    case "dying":
      return "die";
    case "lying":
      return "lie";
    case "tying":
      return "tie";
    case "idly":
      return "idl";
    case "gently":
      return "gentl";
    case "ugly":
      return "ugli";
    case "early":
      return "earli";
    case "only":
      return "onli";
    case "singly":
      return "singl";
    case "sky":
    case "news":
    case "howe":
    case "atlas":
    case "cosmos":
    case "bias":
    case "andes":
      return $;
  }
  let q = $.charCodeAt(0) === 39 ? 1 : 0, K = $.length - q, P = Array(K), _ = false;
  for (let X = 0; X < K; ++X) {
    let f = $.charCodeAt(X + q);
    if (f === 121 && (X === 0 || IK(P[X - 1]))) {
      _ = true, P[X] = 89;
      continue;
    }
    P[X] = f;
  }
  if (P[K - 1] === 39) --K;
  if (K >= 2 && P[K - 2] === 39 && P[K - 1] === 115) K -= 2;
  let Y = 0;
  while (Y < K && !IK(P[Y])) ++Y;
  if (Y < K) ++Y;
  let O = Y;
  if (K >= 5 && (P[0] === 103 && P[1] === 101 && P[2] === 110 && P[3] === 101 && P[4] === 114 || P[0] === 97 && P[1] === 114 && P[2] === 115 && P[3] === 101 && P[4] === 110)) O = 5;
  else if (K >= 6 && P[0] === 99 && P[1] === 111 && P[2] === 109 && P[3] === 109 && P[4] === 117 && P[5] === 110) O = 6;
  else {
    while (O < K && IK(P[O])) ++O;
    if (O < K) ++O;
  }
  let z = O;
  while (z < K && !IK(P[z])) ++z;
  while (z < K && IK(P[z])) ++z;
  if (z < K) ++z;
  if (K >= 3) {
    if (P[K - 1] === 115) {
      if (K >= 4 && P[K - 2] === 101 && P[K - 3] === 115 && P[K - 4] === 115) K -= 2;
      else if (P[K - 2] === 101 && P[K - 3] === 105) K -= K >= 5 ? 2 : 1;
      else if (P[K - 2] !== 117 && P[K - 2] !== 115 && Y < K - 1) K -= 1;
    } else if (P[K - 1] === 100 && P[K - 2] === 101 && P[K - 3] === 105) K -= K >= 5 ? 2 : 1;
  }
  if (K === 6 && (P[0] === 105 && P[1] === 110 && P[2] === 110 && P[3] === 105 && P[4] === 110 && P[5] === 103 || P[0] === 111 && P[1] === 117 && P[2] === 116 && P[3] === 105 && P[4] === 110 && P[5] === 103 || P[0] === 101 && P[1] === 120 && P[2] === 99 && P[3] === 101 && P[4] === 101 && P[5] === 100) || K === 7 && (P[0] === 99 && P[1] === 97 && P[2] === 110 && P[3] === 110 && P[4] === 105 && P[5] === 110 && P[6] === 103 || P[0] === 104 && P[1] === 101 && P[2] === 114 && P[3] === 114 && P[4] === 105 && P[5] === 110 && P[6] === 103 || P[0] === 101 && P[1] === 97 && P[2] === 114 && P[3] === 114 && P[4] === 105 && P[5] === 110 && P[6] === 103 || P[0] === 112 && P[1] === 114 && P[2] === 111 && P[3] === 99 && P[4] === 101 && P[5] === 101 && P[6] === 100 || P[0] === 115 && P[1] === 117 && P[2] === 99 && P[3] === 99 && P[4] === 101 && P[5] === 101 && P[6] === 100)) {
    let X = "";
    for (let f = 0; f < K; ++f) X += String.fromCharCode(P[f]);
    return X;
  }
  let J = K >= 2 && P[K - 1] === 121 && P[K - 2] === 108 ? K - 2 : K;
  if (J >= 3) if (P[J - 3] === 101 && P[J - 2] === 101 && P[J - 1] === 100) {
    if (J >= O + 3) K = J - 1;
  } else {
    if (P[J - 2] === 101 && P[J - 1] === 100) J -= 2;
    else if (P[J - 3] === 105 && P[J - 2] === 110 && P[J - 1] === 103) J -= 3;
    else J = -1;
    if (J >= 0 && Y <= J) {
      if (K = J, K >= 2) {
        if (P[K - 1] === 116 && P[K - 2] === 97 || P[K - 1] === 108 && P[K - 2] === 98 || P[K - 1] === 122 && P[K - 2] === 105) P[K] = 101, ++K;
        else if (P[K - 2] === P[K - 1] && At(P[K - 1])) --K;
        else if (O >= K && RM(P, K)) P[K] = 101, ++K;
      }
    }
  }
  if (K >= 3 && (P[K - 1] === 89 || P[K - 1] === 121) && !IK(P[K - 2])) P[K - 1] = 105;
  if (K >= O + 2) switch (P[K - 1]) {
    case 108:
      if (K >= O + 6 && P[K - 2] === 97 && P[K - 3] === 110 && P[K - 4] === 111 && P[K - 5] === 105 && P[K - 6] === 116) if (K >= 7 && P[K - 7] === 97) {
        if (K >= O + 7) K -= 4, P[K - 1] = 101;
      } else K -= 2;
      break;
    case 110:
      if (K >= O + 5 && P[K - 2] === 111 && P[K - 3] === 105 && P[K - 4] === 116 && P[K - 5] === 97) if (K >= 7 && P[K - 6] === 122 && P[K - 7] === 105) {
        if (K >= O + 7) K -= 4, P[K - 1] = 101;
      } else K -= 2, P[K - 1] = 101;
      break;
    case 114:
      if (K >= O + 4) {
        if (P[K - 2] === 101) {
          if (P[K - 3] === 122 && P[K - 4] === 105) --K;
        } else if (P[K - 2] === 111) {
          if (P[K - 3] === 116 && P[K - 4] === 97) --K, P[K - 1] = 101;
        }
      }
      break;
    case 115:
      if (K >= O + 7 && P[K - 2] === 115 && P[K - 3] === 101 && P[K - 4] === 110 && (P[K - 5] === 108 && P[K - 6] === 117 && P[K - 7] === 102 || P[K - 5] === 115 && P[K - 6] === 117 && P[K - 7] === 111 || P[K - 5] === 101 && P[K - 6] === 118 && P[K - 7] === 105)) K -= 4;
      break;
    case 109:
      if (K >= O + 5 && P[K - 2] === 115 && P[K - 3] === 105 && P[K - 4] === 108 && P[K - 5] === 97) K -= 3;
      break;
    case 105:
      if (P[K - 2] === 99) {
        if (K >= O + 4 && (P[K - 4] === 101 || P[K - 4] === 97) && P[K - 3] === 110) P[K - 1] = 101;
      } else if (P[K - 2] === 103) {
        if (K >= O + 3 && K >= 4 && P[K - 2] === 103 && P[K - 3] === 111 && P[K - 4] === 108) --K;
      } else if (P[K - 2] === 116) {
        if (K >= O + 5 && P[K - 3] === 105) {
          if (P[K - 4] === 108) {
            if (K >= 6 && P[K - 5] === 105 && P[K - 6] === 98) {
              if (K >= O + 6) K -= 3, P[K - 2] = 108, P[K - 1] = 101;
            } else if (P[K - 4] === 108 && P[K - 5] === 97) K -= 3;
          } else if (P[K - 4] === 118 && P[K - 5] === 105) K -= 2, P[K - 1] = 101;
        }
      } else if (P[K - 2] === 108 && K >= 3) {
        if (P[K - 3] === 98) {
          if (K >= 4 && P[K - 4] === 97) {
            if (K >= O + 4) P[K - 1] = 101;
          } else if (K >= O + 3) P[K - 1] = 101;
        } else if (P[K - 3] === 108) {
          if (K >= 5 && P[K - 4] === 117 && P[K - 5] === 102) {
            if (K >= O + 5) K -= 2;
          } else if (K >= O + 4 && P[K - 4] === 97) K -= 2;
        } else if (P[K - 3] === 115) {
          if (K >= 6 && P[K - 4] === 115 && P[K - 5] === 101 && P[K - 6] === 108) {
            if (K >= O + 6) K -= 2;
          } else if (K >= O + 5 && P[K - 4] === 117 && P[K - 5] === 111) K -= 2;
        } else if (K >= 5 && P[K - 3] === 116 && P[K - 4] === 110 && P[K - 5] === 101) {
          if (K >= O + 5) K -= 2;
        } else if (Xt(P[K - 3])) K -= 2;
      }
  }
  if (K >= O + 3) switch (P[K - 1]) {
    case 108:
      if (P[K - 3] === 99) {
        if (K >= O + 4 && P[K - 4] === 105 && P[K - 2] === 97) K -= 2;
      } else if (P[K - 3] === 102) {
        if (P[K - 2] === 117) K -= 3;
      } else if (P[K - 3] === 110) {
        if (K >= O + 6 && P[K - 2] === 97 && P[K - 4] === 111 && P[K - 5] === 105 && P[K - 6] === 116) if (K >= 7 && P[K - 7] === 97) {
          if (K >= O + 7) K -= 4, P[K - 1] = 101;
        } else K -= 2;
      }
      break;
    case 101:
      if (P[K - 2] === 122) {
        if (K >= O + 5 && P[K - 3] === 105 && P[K - 4] === 108 && P[K - 5] === 97) K -= 3;
      } else if (P[K - 2] === 116) {
        if (K >= O + 5 && P[K - 3] === 97 && P[K - 4] === 99 && P[K - 5] === 105) K -= 3;
      } else if (P[K - 2] === 118) {
        if (K >= z + 5 && P[K - 3] === 105 && P[K - 4] === 116 && P[K - 5] === 97) K -= 5;
      }
      break;
    case 105:
      if (K >= O + 5 && P[K - 2] === 116 && P[K - 3] === 105 && P[K - 4] === 99 && P[K - 5] === 105) K -= 3;
      break;
    case 115:
      if (K >= O + 4 && P[K - 2] === 115 && P[K - 3] === 101 && P[K - 4] === 110) K -= 4;
  }
  if (K >= z + 2) switch (P[K - 1]) {
    case 110:
      if (K >= z + 3 && P[K - 2] === 111 && P[K - 3] === 105 && (P[K - 4] === 115 || P[K - 4] === 116)) K -= 3;
      break;
    case 108:
      if (P[K - 2] === 97) K -= 2;
      break;
    case 114:
      if (P[K - 2] === 101) K -= 2;
      break;
    case 99:
      if (P[K - 2] === 105) K -= 2;
      break;
    case 109:
      if (K >= z + 3 && P[K - 2] === 115 && P[K - 3] === 105) K -= 3;
      break;
    case 105:
      if (K >= z + 3 && P[K - 2] === 116 && P[K - 3] === 105) K -= 3;
      break;
    case 115:
      if (K >= z + 3 && P[K - 2] === 117 && P[K - 3] === 111) K -= 3;
      break;
    case 116:
      if (K >= z + 3 && P[K - 2] === 110) {
        if (P[K - 3] === 97) K -= 3;
        else if (P[K - 3] === 101) if (K >= 4 && P[K - 4] === 109) {
          if (K >= 5 && P[K - 5] === 101) {
            if (K >= z + 5) K -= 5;
          } else if (K >= z + 4) K -= 4;
        } else K -= 3;
      }
      break;
    case 101:
      if (P[K - 2] === 99) {
        if (K >= z + 4 && P[K - 3] === 110 && (P[K - 4] === 97 || P[K - 4] === 101)) K -= 4;
      } else if (P[K - 2] === 108) {
        if (K >= z + 4 && P[K - 3] === 98 && (P[K - 4] === 97 || P[K - 4] === 105)) K -= 4;
      } else if (P[K - 2] === 116) {
        if (K >= z + 3 && P[K - 3] === 97) K -= 3;
      } else if (K >= z + 3 && (P[K - 2] === 118 || P[K - 2] === 122) && P[K - 3] === 105) K -= 3;
  }
  if (K >= O + 1 && (K >= z + 1 && P[K - 1] === 108 && P[K - 2] === 108 || P[K - 1] === 101 && (K >= z + 1 || !RM(P, K - 1)))) --K;
  let T = "";
  if (_) for (let X = 0; X < K; ++X) T += String.fromCharCode(P[X] === 89 ? 121 : P[X]);
  else for (let X = 0; X < K; ++X) T += String.fromCharCode(P[X]);
  return T;
}, "kt");
var Gt = { k1: 1.2, b: 0.75, minLength: 2, stopWords: /* @__PURE__ */ new Set(["a", "an", "and", "are", "as", "at", "be", "by", "for", "from", "has", "he", "in", "is", "it", "its", "of", "on", "that", "the", "to", "was", "were", "will", "with"]), stemming: false, stemWords: /* @__PURE__ */ __name(($) => $, "stemWords") };
var _bJ = class _bJ {
  stopWords;
  minLength;
  stemming;
  stemmingRules;
  constructor($ = {}) {
    let q = { ..._bJ.DEFAULT_OPTIONS, ...$ };
    this.stopWords = q.stopWords, this.minLength = q.minLength, this.stemming = q.stemming, this.stemmingRules = q.stemmingRules.map((K) => ({ ...K, pattern: typeof K.pattern === "string" ? new RegExp(K.pattern) : K.pattern }));
  }
  tokenize($, q = false) {
    if (!$) throw Error("Input text cannot be null or empty");
    let K = Date.now(), P = $.split(/\s+/).filter((z) => z.length > 0), Y = this.cleanText($).split(/\s+/).filter((z) => this.isValidToken(z)).map((z) => this.stemming ? this.stemWord(z) : z), O = q ? { originalWordCount: P.length, stopWordsRemoved: P.length - Y.length, stemmedWords: this.stemming ? Y.length : 0, processingTimeMs: Date.now() - K } : { originalWordCount: 0, stopWordsRemoved: 0, stemmedWords: 0, processingTimeMs: 0 };
    return { tokens: Y, stats: O };
  }
  cleanText($) {
    return $.toLowerCase().normalize("NFKD").replace(/[\u0000-\u001F\u007F-\u009F\u200B-\u200D\uFEFF]/g, "").replace(/[\u0300-\u036f]/g, "").replace(/[\p{Emoji_Presentation}\p{Extended_Pictographic}]/gu, "").replace(/[]/g, "").replace(/[\p{P}]/gu, " ").replace(/[^a-z0-9\u3040-\u30FF\u3400-\u4DBF\u4E00-\u9FFF\uAC00-\uD7AF\s]/gu, " ").replace(/\s+/g, " ").trim();
  }
  isValidToken($) {
    let q = /^\d+$/.test($);
    return ($.length >= this.minLength || q) && !this.stopWords.has($);
  }
  stemWord($) {
    if ($.length < 3) return $;
    let q = false, K = $;
    for (let P of this.stemmingRules) {
      let _ = K.match(P.pattern);
      if (_) {
        if (!P.minMeasure || this.measure(K.substring(0, _.index)) >= P.minMeasure) {
          if (typeof P.replacement === "string") K = K.replace(P.pattern, P.replacement);
          else K = K.replace(P.pattern, (...Y) => P.replacement(...Y));
          q = true;
        }
      }
    }
    if (q && K !== $) return K;
    return kt(K);
  }
  isConsonant($, q) {
    let K = $[q];
    if ("aeiou".includes(K)) return false;
    return K !== "y" || (q === 0 ? true : !this.isConsonant($, q - 1));
  }
  measure($) {
    let q = 0, K = false;
    for (let P = 0; P < $.length; P++) if (this.isConsonant($, P)) {
      if (K) q++, K = false;
    } else K = true;
    return q;
  }
};
__name(_bJ, "bJ");
__publicField(_bJ, "DEFAULT_OPTIONS", { stopWords: /* @__PURE__ */ new Set(), minLength: 2, stemming: false, stemmingRules: [] });
var bJ = _bJ;
var _yJ = class _yJ {
  termFrequencySaturation;
  lengthNormalizationFactor;
  tokenizer;
  documentLengths;
  averageDocLength;
  termToIndex;
  documentFrequency;
  termFrequencies;
  fieldBoosts;
  documents;
  constructor($, q = {}) {
    let K = { ...Gt, ...q };
    if (this.termFrequencySaturation = K.k1, this.lengthNormalizationFactor = K.b, this.tokenizer = new bJ(K), this.fieldBoosts = K.fieldBoosts || {}, this.documents = [], this.documentLengths = new Uint32Array(0), this.termToIndex = /* @__PURE__ */ new Map(), this.documentFrequency = new Uint32Array(0), this.averageDocLength = 0, this.termFrequencies = /* @__PURE__ */ new Map(), $ && $.length > 0) {
      this.documents = [...$];
      let { documentLengths: P, termToIndex: _, documentFrequency: Y, averageDocLength: O, termFrequencies: z } = this.processDocuments($);
      this.documentLengths = P, this.termToIndex = _, this.documentFrequency = Y, this.averageDocLength = O, this.termFrequencies = z;
    }
  }
  processDocuments($) {
    let q = $.length, K = new Uint32Array(q), P = /* @__PURE__ */ new Map(), _ = /* @__PURE__ */ new Map(), Y = /* @__PURE__ */ new Map(), O = 0, z = 0;
    $.forEach((T, X) => {
      let f = 0, V = /* @__PURE__ */ new Map();
      Object.entries(T).forEach(([M, N]) => {
        if (typeof N !== "string") return;
        let E = this.fieldBoosts[M] || 1, { tokens: h } = this.tokenizer.tokenize(N), I = h.length * E;
        f += I, h.forEach((D) => {
          if (!P.has(D)) P.set(D, z++);
          let g = P.get(D);
          if (!_.has(D)) _.set(D, /* @__PURE__ */ new Set());
          _.get(D).add(X);
          let b = V.get(g) || 0;
          V.set(g, b + E);
        });
      }), K[X] = f, O += f, V.forEach((M, N) => {
        if (!Y.has(N)) Y.set(N, /* @__PURE__ */ new Map());
        Y.get(N).set(X, M);
      });
    });
    let J = new Uint32Array(P.size);
    return _.forEach((T, X) => {
      let f = P.get(X);
      J[f] = T.size;
    }), { documentLengths: K, termToIndex: P, documentFrequency: J, averageDocLength: q > 0 ? O / q : 0, termFrequencies: Y };
  }
  recalculateAverageLength() {
    if (this.documentLengths.length === 0) {
      this.averageDocLength = 0;
      return;
    }
    let $ = this.documentLengths.reduce((q, K) => q + K, 0);
    this.averageDocLength = $ / this.documentLengths.length;
  }
  search($, q = 10) {
    let { tokens: K } = this.tokenizer.tokenize($), P = new Float32Array(this.documentLengths.length).fill(0);
    return K.forEach((_) => {
      let Y = this.termToIndex.get(_);
      if (Y === void 0) return;
      let O = this.calculateIdf(Y);
      if (O <= 0) return;
      let z = this.termFrequencies.get(Y);
      if (!z) return;
      z.forEach((J, T) => {
        let X = this.documentLengths[T], f = J * (this.termFrequencySaturation + 1), V = J + this.termFrequencySaturation * (1 - this.lengthNormalizationFactor + this.lengthNormalizationFactor * X / this.averageDocLength);
        P[T] += O * (f / V);
      });
    }), Array.from({ length: P.length }, (_, Y) => ({ index: Y, score: P[Y] })).filter((_) => _.score > 0).sort((_, Y) => Y.score - _.score).slice(0, q);
  }
  searchPhrase($, q = 10) {
    let { tokens: K } = this.tokenizer.tokenize($);
    if (K.length === 0) return [];
    let P = null;
    for (let Y of K) {
      let O = this.termToIndex.get(Y);
      if (O === void 0) return [];
      let z = this.termFrequencies.get(O)?.keys();
      if (!z) return [];
      let J = new Set(z);
      if (P === null) P = J;
      else P = new Set([...P].filter((T) => J.has(T)));
      if (P.size === 0) return [];
    }
    if (P === null || P.size === 0) return [];
    let _ = /* @__PURE__ */ new Map();
    return P.forEach((Y) => {
      let O = this.getDocument(Y), z = false;
      Object.entries(O).forEach(([J, T]) => {
        if (typeof T !== "string" || z) return;
        let X = this.fieldBoosts[J] || 1, { tokens: f } = this.tokenizer.tokenize(T);
        for (let V = 0; V <= f.length - K.length; V++) {
          let M = true;
          for (let N = 0; N < K.length; N++) if (f[V + N] !== K[N]) {
            M = false;
            break;
          }
          if (M) {
            let N = this.calculatePhraseScore(K, Y) * X;
            _.set(Y, (_.get(Y) || 0) + N), z = true;
            break;
          }
        }
      });
    }), Array.from(_.entries()).map(([Y, O]) => ({ index: Y, score: O })).sort((Y, O) => O.score - Y.score).slice(0, q);
  }
  calculatePhraseScore($, q) {
    return $.reduce((K, P) => {
      let _ = this.termToIndex.get(P);
      if (_ === void 0) return K;
      let Y = this.calculateIdf(_), O = this.termFrequencies.get(_)?.get(q) || 0, z = this.documentLengths[q], J = O * (this.termFrequencySaturation + 1), T = O + this.termFrequencySaturation * (1 - this.lengthNormalizationFactor + this.lengthNormalizationFactor * z / this.averageDocLength);
      return K + Y * (J / T);
    }, 0);
  }
  async addDocument($) {
    if (!$) throw Error("Document cannot be null");
    let q = this.documentLengths.length;
    this.documents.push($);
    let K = new Uint32Array(q + 1);
    K.set(this.documentLengths, 0), this.documentLengths = K;
    let P = 0, _ = /* @__PURE__ */ new Map();
    Object.entries($).forEach(([Y, O]) => {
      if (typeof O !== "string") return;
      let z = this.fieldBoosts[Y] || 1, { tokens: J } = this.tokenizer.tokenize(O);
      P += J.length * z, J.forEach((T) => {
        let X;
        if (!this.termToIndex.has(T)) {
          if (X = this.termToIndex.size, this.termToIndex.set(T, X), this.documentFrequency.length <= X) {
            let V = this.documentFrequency, M = Math.max(X + 1, V.length * 2 || 1);
            this.documentFrequency = new Uint32Array(M), this.documentFrequency.set(V, 0);
          }
          this.documentFrequency[X] = 0;
        } else X = this.termToIndex.get(T);
        let f = _.get(X) || 0;
        _.set(X, f + z);
      });
    }), this.documentLengths[q] = P, _.forEach((Y, O) => {
      if (!this.termFrequencies.has(O)) this.termFrequencies.set(O, /* @__PURE__ */ new Map());
      if (this.termFrequencies.get(O).set(q, Y), O < this.documentFrequency.length) this.documentFrequency[O]++;
      else console.error(`Error: termIndexVal ${O} is out of bounds for documentFrequency (length ${this.documentFrequency.length}). This indicates an issue with array resizing or term indexing.`);
    }), this.recalculateAverageLength();
  }
  calculateIdf($) {
    if ($ < 0 || $ >= this.documentFrequency.length) return 0;
    let q = this.documentFrequency[$];
    if (q <= 0 || q > this.documentLengths.length) return 0;
    let P = this.documentLengths.length - q + 0.5, _ = q + 0.5;
    return Math.log(1 + P / _);
  }
  getTermFrequency($, q) {
    return this.termFrequencies.get($)?.get(q) || 0;
  }
  getDocument($) {
    if ($ < 0 || $ >= this.documents.length) throw Error(`Document index ${$} out of bounds (0-${this.documents.length - 1})`);
    return this.documents[$];
  }
  clearDocuments() {
    this.documents = [], this.documentLengths = new Uint32Array(0), this.termToIndex.clear(), this.documentFrequency = new Uint32Array(0), this.averageDocLength = 0, this.termFrequencies.clear();
  }
  getDocumentCount() {
    return this.documents.length;
  }
  async addDocuments($) {
    return Promise.all($.map((q) => this.addDocument(q)));
  }
};
__name(_yJ, "yJ");
var yJ = _yJ;
var Vt = {};
var _St = class _St {
  permits;
  waiting = [];
  constructor($) {
    this.permits = $;
  }
  async acquire() {
    if (this.permits > 0) return this.permits -= 1, Promise.resolve();
    return new Promise(($) => {
      this.waiting.push($);
    });
  }
  release() {
    this.permits += 1;
    let $ = this.waiting.shift();
    if ($ && this.permits > 0) this.permits -= 1, $();
  }
};
__name(_St, "St");
var St = _St;
var _$;
var _uJ = class _uJ {
  constructor($) {
    __privateAdd(this, _$, 32);
    __publicField(this, "agentId");
    __publicField(this, "character");
    __publicField(this, "adapter");
    __publicField(this, "actions", []);
    __publicField(this, "evaluators", []);
    __publicField(this, "providers", []);
    __publicField(this, "plugins", []);
    __publicField(this, "events", {});
    __publicField(this, "stateCache", /* @__PURE__ */ new Map());
    __publicField(this, "fetch", fetch);
    __publicField(this, "services", /* @__PURE__ */ new Map());
    __publicField(this, "serviceTypes", /* @__PURE__ */ new Map());
    __publicField(this, "models", /* @__PURE__ */ new Map());
    __publicField(this, "routes", []);
    __publicField(this, "taskWorkers", /* @__PURE__ */ new Map());
    __publicField(this, "sendHandlers", /* @__PURE__ */ new Map());
    __publicField(this, "eventHandlers", /* @__PURE__ */ new Map());
    __publicField(this, "elizaOS");
    __publicField(this, "allAvailablePlugins", /* @__PURE__ */ new Map());
    __publicField(this, "characterPlugins", []);
    __publicField(this, "logger");
    __publicField(this, "settings");
    __publicField(this, "servicePromiseHandlers", /* @__PURE__ */ new Map());
    __publicField(this, "servicePromises", /* @__PURE__ */ new Map());
    __publicField(this, "serviceRegistrationStatus", /* @__PURE__ */ new Map());
    __publicField(this, "initPromise");
    __publicField(this, "initResolver");
    __publicField(this, "initRejecter");
    __publicField(this, "migratedPlugins", /* @__PURE__ */ new Set());
    __publicField(this, "currentRunId");
    __publicField(this, "currentActionContext");
    __publicField(this, "maxWorkingMemoryEntries", 50);
    __publicField(this, "messageService", null);
    if (this.agentId = $.character?.id ?? $?.agentId ?? hO($.character?.name ?? Dq()), this.character = $.character, this.initPromise = new Promise((q, K) => {
      this.initResolver = q, this.initRejecter = K;
    }), this.logger = Y1({ namespace: this.character?.name }), __privateSet(this, _$, $.conversationLength ?? __privateGet(this, _$)), $.adapter) this.registerDatabaseAdapter($.adapter);
    if (this.fetch = $.fetch ?? this.fetch, this.settings = $.settings ?? Vt, this.plugins = [], this.characterPlugins = $?.plugins ?? [], $.allAvailablePlugins) {
      for (let q of $.allAvailablePlugins) if (q?.name) this.allAvailablePlugins.set(q.name, q);
    }
    if (this.logger.debug(`Success: Agent ID: ${this.agentId}`), this.currentRunId = void 0, $.settings?.MAX_WORKING_MEMORY_ENTRIES) this.maxWorkingMemoryEntries = parseInt($.settings.MAX_WORKING_MEMORY_ENTRIES, 10) || 50;
    else this.maxWorkingMemoryEntries = b0("MAX_WORKING_MEMORY_ENTRIES", 50);
  }
  createRunId() {
    return Dq();
  }
  startRun() {
    return this.currentRunId = this.createRunId(), this.currentRunId;
  }
  endRun() {
    this.currentRunId = void 0;
  }
  getCurrentRunId() {
    if (!this.currentRunId) this.currentRunId = this.createRunId();
    return this.currentRunId;
  }
  async registerPlugin($) {
    if (!$?.name) throw this.logger.error("*** registerPlugin: Plugin or plugin name is undefined"), Error("*** registerPlugin: Plugin or plugin name is undefined");
    if (this.plugins.find((K) => K.name === $.name)) {
      this.logger.warn(`${this.character.name}(${this.agentId}) - Plugin ${$.name} is already registered. Skipping re-registration.`);
      return;
    }
    if (this.plugins.push($), this.logger.debug(`Success: Plugin ${$.name} added to active plugins for ${this.character.name}(${this.agentId}).`), $.init) try {
      await $.init($.config || {}, this), this.logger.debug(`Success: Plugin ${$.name} initialized successfully`);
    } catch (K) {
      let P = K instanceof Error ? K.message : String(K);
      if (P.includes("API key") || P.includes("environment variables") || P.includes("Invalid plugin configuration")) console.warn(`Plugin ${$.name} requires configuration. ${P}`), console.warn("Please check your environment variables and ensure all required API keys are set."), console.warn("You can set these in your .env file.");
      else throw K;
    }
    if ($.adapter) this.logger.debug(`Registering database adapter for plugin ${$.name}`), this.registerDatabaseAdapter($.adapter);
    if ($.actions) for (let K of $.actions) this.registerAction(K);
    if ($.evaluators) for (let K of $.evaluators) this.registerEvaluator(K);
    if ($.providers) for (let K of $.providers) this.registerProvider(K);
    if ($.models) for (let [K, P] of Object.entries($.models)) this.registerModel(K, P, $.name, $?.priority);
    if ($.routes) for (let K of $.routes) {
      let P = K.path.startsWith("/") ? K.path : `/${K.path}`;
      this.routes.push({ ...K, path: "/" + $.name + P });
    }
    if ($.events) for (let [K, P] of Object.entries($.events)) for (let _ of P) this.registerEvent(K, _);
    if ($.services) for (let K of $.services) {
      let P = K.serviceType, _ = K.name || "Unknown";
      if (this.logger.debug(`Plugin ${$.name} registering service: ${P}`), !this.servicePromises.has(P)) this._createServiceResolver(P);
      this.serviceRegistrationStatus.set(P, "pending"), this.registerService(K).catch((Y) => {
        this.logger.error(`Plugin ${$.name} failed to register service ${P}: ${Y instanceof Error ? Y.message : String(Y)}`);
        let O = this.servicePromiseHandlers.get(P);
        if (O) {
          let z = Error(`Service ${P} from plugin ${$.name} failed to register: ${Y instanceof Error ? Y.message : String(Y)}`);
          O.reject(z), this.servicePromiseHandlers.delete(P), this.servicePromises.delete(P);
        }
        this.serviceRegistrationStatus.set(P, "failed");
      });
    }
  }
  getAllServices() {
    return this.services;
  }
  async stop() {
    this.logger.debug(`runtime::stop - character ${this.character.name}`);
    for (let [$, q] of this.services) {
      this.logger.debug(`runtime::stop - requesting service stop for ${$}`);
      for (let K of q) await K.stop();
    }
    this.elizaOS = void 0;
  }
  async initialize($) {
    try {
      let q = [], K = this.characterPlugins;
      for (let T of K) if (T) q.push(this.registerPlugin(T));
      if (await Promise.all(q), !this.adapter) throw this.logger.error("Database adapter not initialized. Make sure @elizaos/plugin-sql is included in your plugins."), Error("Database adapter not initialized. The SQL plugin (@elizaos/plugin-sql) is required for agent initialization. Please ensure it is included in your character configuration.");
      if (!await this.adapter.isReady()) await this.adapter.init();
      if (this.messageService = new gJ(), $?.skipMigrations ?? false) this.logger.info("Skipping plugin migrations (skipMigrations=true)");
      else this.logger.info("Running plugin migrations..."), await this.runPluginMigrations(), this.logger.info("Plugin migrations completed.");
      let _ = await this.ensureAgentExists({ ...this.character, id: this.agentId });
      if (!_) {
        let T = `Agent ${this.agentId} does not exist in database after ensureAgentExists call`;
        throw Error(T);
      }
      if (_.settings) {
        this.character.settings = { ..._.settings, ...this.character.settings };
        let T = _.settings.secrets && typeof _.settings.secrets === "object" ? _.settings.secrets : {}, X = this.character.settings.secrets && typeof this.character.settings.secrets === "object" ? this.character.settings.secrets : {}, f = this.character.secrets && typeof this.character.secrets === "object" ? this.character.secrets : {}, V = { ...T, ...f, ...X };
        if (Object.keys(V).length > 0) this.character.secrets = V, this.character.settings.secrets = V;
      }
      try {
        let T = await this.getWorld(this.agentId);
        if (T?.metadata?.settings) {
          let X = T.metadata.settings;
          for (let [f, V] of Object.entries(X)) if (typeof V === "object" && V.value !== null && V.value !== void 0) {
            if (!this.character.settings?.[f]) this.character.settings = { ...this.character.settings, [f]: V.value };
          }
          this.logger.debug(`Loaded ${Object.keys(X).length} settings from world metadata`);
        }
      } catch (T) {
        this.logger.warn("Failed to load settings from world metadata:", T instanceof Error ? T.message : String(T));
      }
      let Y = await this.getEntityById(this.agentId);
      if (!Y) {
        if (!await this.createEntity({ id: this.agentId, names: [this.character.name], metadata: {}, agentId: _.id })) {
          let X = `Failed to create entity for agent ${this.agentId}`;
          throw Error(X);
        }
        if (Y = await this.getEntityById(this.agentId), !Y) throw Error(`Agent entity not found for ${this.agentId}`);
        this.logger.debug(`Success: Agent entity created successfully for ${this.character.name}`);
      }
      if (!await this.getRoom(this.agentId)) await this.createRoom({ id: this.agentId, name: this.character.name, source: "elizaos", type: "SELF", channelId: this.agentId, serverId: this.agentId, worldId: this.agentId });
      if (!(await this.adapter.getParticipantsForRoom(this.agentId)).includes(this.agentId)) {
        if (!await this.addParticipant(this.agentId, this.agentId)) {
          let X = `Failed to add agent ${this.agentId} as participant to its own room`;
          throw Error(X);
        }
        this.logger.debug(`Agent ${this.character.name} linked to its own room successfully`);
      }
      if (!this.getModel(M6.TEXT_EMBEDDING)) this.logger.warn(`[AgentRuntime][${this.character.name}] No TEXT_EMBEDDING model registered. Skipping embedding dimension setup.`);
      else await this.ensureEmbeddingDimension();
      if (this.initResolver) this.initResolver(), this.initResolver = void 0;
    } catch (q) {
      let K = q instanceof Error ? q.message : String(q);
      if (this.logger.error(`Runtime initialization failed: ${K}`), this.initRejecter) this.initRejecter(q), this.initRejecter = void 0;
      for (let [P, _] of this.servicePromises) {
        let Y = this.servicePromiseHandlers.get(P);
        if (Y) {
          let O = Error(`Service ${P} failed to start due to runtime initialization failure: ${K}`);
          Y.reject(O), this.servicePromiseHandlers.delete(P), this.servicePromises.delete(P), this.serviceRegistrationStatus.set(P, "failed");
        }
      }
      throw q;
    }
  }
  async runPluginMigrations() {
    if (!this.adapter) {
      this.logger.warn("Database adapter not found, skipping plugin migrations.");
      return;
    }
    if (typeof this.adapter.runPluginMigrations !== "function") {
      this.logger.warn("Database adapter does not support plugin migrations.");
      return;
    }
    let $ = this.plugins.filter((q) => q.schema).map((q) => ({ name: q.name, schema: q.schema }));
    if ($.length === 0) {
      this.logger.info("No plugins with schemas found, skipping migrations.");
      return;
    }
    this.logger.info(`Found ${$.length} plugins with schemas to migrate.`);
    try {
      let P = { verbose: true, force: process.env.ELIZA_ALLOW_DESTRUCTIVE_MIGRATIONS === "true", dryRun: false };
      await this.adapter.runPluginMigrations($, P), this.logger.info("Plugin migrations completed successfully.");
    } catch (q) {
      throw this.logger.error(q instanceof Error ? q : Error(String(q)), "Failed to run plugin migrations"), q;
    }
  }
  async getConnection() {
    if (!this.adapter) throw Error("Database adapter not registered");
    return this.adapter.getConnection();
  }
  setSetting($, q, K = false) {
    if (K) {
      if (!this.character.secrets) this.character.secrets = {};
      this.character.secrets[$] = q;
    } else {
      if (!this.character.settings) this.character.settings = {};
      this.character.settings[$] = q;
    }
    this.saveSettingsToDatabase().catch((P) => {
      this.logger.error(`Failed to save settings to database: ${P}`);
    });
  }
  async saveSettingsToDatabase() {
    try {
      if (!this.adapter) {
        this.logger.warn("No database adapter available, settings will not be persisted");
        return;
      }
      await this.adapter.updateAgent(this.agentId, { settings: this.character.settings }), this.logger.debug(`Settings saved to database for agent ${this.agentId}`);
    } catch ($) {
      this.logger.error(`Error saving settings to database: ${$}`);
    }
  }
  getSetting($) {
    let q = this.character.secrets?.[$] || this.character.settings?.[$] || typeof this.character.settings === "object" && this.character.settings !== null && "secrets" in this.character.settings && this.character.settings.secrets?.[$] || this.settings[$], K = EO(q, c_());
    if (K === "true") return true;
    if (K === "false") return false;
    return K || null;
  }
  getConversationLength() {
    return __privateGet(this, _$);
  }
  registerDatabaseAdapter($) {
    if (this.adapter) this.logger.warn("Database adapter already registered. Additional adapters will be ignored. This may lead to unexpected behavior.");
    else this.adapter = $, this.logger.debug("Success: Database adapter registered successfully.");
  }
  registerProvider($) {
    this.providers.push($), this.logger.debug(`Success: Provider ${$.name} registered successfully.`);
  }
  registerAction($) {
    if (this.actions.find((q) => q.name === $.name)) this.logger.warn(`${this.character.name}(${this.agentId}) - Action ${$.name} already exists. Skipping registration.`);
    else try {
      this.actions.push($), this.logger.success(`${this.character.name}(${this.agentId}) - Action ${$.name} registered successfully.`);
    } catch (q) {
      console.error("Error registering action", q);
    }
  }
  registerEvaluator($) {
    this.evaluators.push($);
  }
  updateActionPlan($, q) {
    return { ...$, ...q };
  }
  updateActionStep($, q, K) {
    if (!$.steps || q < 0 || q >= $.steps.length) return this.logger.warn(`Invalid step index: ${q} for plan with ${$.steps?.length || 0} steps`), $;
    return { ...$, steps: $.steps.map((P, _) => _ === q ? { ...P, ...K } : P) };
  }
  async processActions($, q, K, P) {
    let _ = [];
    for (let f of q) if (f.content?.actions && f.content.actions.length > 0) _.push(...f.content.actions);
    let Y = _.length > 1, O = this.getCurrentRunId(), z = this.createRunId(), J = null, T = q[0]?.content?.thought || `Executing ${_.length} actions: ${_.join(", ")}`;
    if (Y) J = { runId: z, totalSteps: _.length, currentStep: 0, steps: _.map((f) => ({ action: f, status: "pending" })), thought: T, startTime: Date.now() };
    let X = 0;
    for (let f of q) {
      let E = /* @__PURE__ */ __name(function(h) {
        return h.toLowerCase().replace(/_/g, "");
      }, "E");
      if (!f.content?.actions || f.content.actions.length === 0) {
        this.logger.warn("No action found in the response content.");
        continue;
      }
      let V = f.content.actions, M = [], N = K;
      this.logger.debug(`Found actions: ${this.actions.map((h) => E(h.name))}`);
      for (let h of V) {
        if (J) J = this.updateActionPlan(J, { currentStep: X + 1 });
        if (N = await this.composeState($, ["RECENT_MESSAGES", "ACTION_STATE"]), J && N.data) N.data.actionPlan = J, N.data.actionResults = M;
        this.logger.debug(`Success: Calling action: ${h}`);
        let I = E(h), D = this.actions.find((g) => E(g.name) === I);
        if (!D) D = this.actions.find((g) => E(g.name).includes(I) || I.includes(E(g.name)));
        if (D) this.logger.debug(`Success: Found action: ${D?.name}`);
        else {
          this.logger.debug("Attempting to find action in similes.");
          for (let g of this.actions) {
            if (g.similes?.find((p) => E(p) === I)) {
              D = g, this.logger.debug(`Success: Action found in similes (exact match): ${D.name}`);
              break;
            }
            if (g.similes?.find((p) => E(p).includes(I) || I.includes(E(p)))) {
              D = g, this.logger.debug(`Success: Action found in similes (fuzzy match): ${D.name}`);
              break;
            }
          }
        }
        if (!D) {
          let g = `No action found for: ${h}`;
          if (this.logger.error(g), J && J.steps[X]) J = this.updateActionStep(J, X, { status: "failed", error: g });
          let b = { id: Dq(), entityId: $.entityId, roomId: $.roomId, worldId: $.worldId, content: { thought: g, source: "auto", type: "action_result", actionName: h, actionStatus: "failed", runId: z } };
          await this.createMemory(b, "messages"), X++;
          continue;
        }
        if (!D.handler) {
          if (this.logger.error(`Action ${D.name} has no handler.`), J && J.steps[X]) J = this.updateActionStep(J, X, { status: "failed", error: "No handler" });
          X++;
          continue;
        }
        try {
          this.logger.debug(`Executing handler for action: ${D.name}`);
          let g = Dq();
          this.currentActionContext = { actionName: D.name, actionId: g, prompts: [] };
          let y = { actionContext: { previousResults: M, getPreviousResult: /* @__PURE__ */ __name((j) => {
            return M.find((H) => H.data?.actionName === j);
          }, "getPreviousResult") } };
          if (J) y.actionPlan = { totalSteps: J.totalSteps, currentStep: J.currentStep, steps: J.steps, thought: J.thought };
          try {
            this.logger.debug(`Creating action start message for: ${D.name}`), await this.emitEvent("ACTION_STARTED", { messageId: g, roomId: $.roomId, world: $.worldId, content: { text: `Executing action: ${D.name}`, actions: [D.name], actionStatus: "executing", actionId: g, runId: z, type: "agent_action", thought: T, source: $.content?.source } });
          } catch (j) {
            this.logger.error("Failed to create action start message:", String(j));
          }
          let p = [], n = /* @__PURE__ */ __name(async (j) => {
            return p.push(j), [];
          }, "n"), s = await D.handler(this, $, N, y, n, q), q$ = s === void 0 || s === null || typeof s === "boolean", c = null;
          if (!q$) {
            if (typeof s === "object" && s !== null && ("values" in s || "data" in s || "text" in s)) c = { ...s, success: "success" in s ? s.success : true };
            else c = { success: true, data: { actionName: D.name, legacyResult: s } };
            if (M.push(c), c.values) N = { ...N, values: { ...N.values, ...c.values }, data: { ...N.data || {}, actionResults: [...N.data?.actionResults || [], c], actionPlan: J } };
            if (c && N.data) {
              if (!N.data.workingMemory) N.data.workingMemory = {};
              let j = `action_${h}_${Dq()}`, H = { actionName: D.name, result: c, timestamp: Date.now() };
              N.data.workingMemory[j] = H;
              let Z = Object.entries(N.data.workingMemory);
              if (Z.length > this.maxWorkingMemoryEntries) {
                let W = Z.sort((w, G) => {
                  let S = w[1], A = G[1], v = S?.timestamp ?? 0;
                  return (A?.timestamp ?? 0) - v;
                });
                N.data.workingMemory = Object.fromEntries(W.slice(0, this.maxWorkingMemoryEntries));
              }
            }
            if (J && J.steps[X]) J = this.updateActionStep(J, X, { status: "completed", result: c });
          }
          try {
            let H = c?.success !== false ? "completed" : "failed";
            await this.emitEvent("ACTION_COMPLETED", { messageId: g, roomId: $.roomId, world: $.worldId, content: { text: `Action ${D.name} ${H}`, actions: [D.name], actionStatus: H, actionId: g, type: "agent_action", thought: T, actionResult: c, source: $.content?.source } });
          } catch (j) {
            let H = j instanceof Error ? j.message : String(j);
            this.logger.error(`Failed to emit ACTION_COMPLETED event for action ${D.name} (${g}): ${H}`);
          }
          if (P) for (let j of p) await P(j);
          let U = { id: g, entityId: this.agentId, roomId: $.roomId, worldId: $.worldId, content: { text: c?.text || `Executed action: ${D.name}`, source: "action", type: "action_result", actionName: D.name, actionStatus: c?.success ? "completed" : "failed", actionResult: q$ ? { legacy: s } : c, runId: z, ...J && { planStep: `${J.currentStep}/${J.totalSteps}`, planThought: J.thought } }, metadata: { type: "action_result", actionName: D.name, runId: z, parentRunId: O, actionId: g, ...J && { totalSteps: J.totalSteps, currentStep: J.currentStep } } };
          await this.createMemory(U, "messages"), this.logger.debug(`Action ${D.name} completed`, JSON.stringify({ isLegacyReturn: q$, result: q$ ? s : void 0, hasValues: c ? !!c.values : false, hasData: c ? !!c.data : false, hasText: c ? !!c.text : false })), await this.adapter.log({ entityId: $.entityId, roomId: $.roomId, type: "action", body: { action: D.name, actionId: g, message: $.content.text, messageId: $.id, state: N, responses: q, result: q$ ? { legacy: s } : c, isLegacyReturn: q$, prompts: this.currentActionContext?.prompts || [], promptCount: this.currentActionContext?.prompts.length || 0, runId: z, parentRunId: O, ...J && { planStep: `${J.currentStep}/${J.totalSteps}`, planThought: J.thought } } }), this.currentActionContext = void 0;
        } catch (g) {
          let b = g instanceof Error ? g.message : String(g);
          if (this.logger.error(g), J && J.steps[X]) J = this.updateActionStep(J, X, { status: "failed", error: b });
          this.currentActionContext = void 0;
          let y = { success: false, data: { actionName: D.name, error: b, errorObject: g } };
          M.push(y);
          let p = { id: Dq(), content: { thought: b, source: "auto", type: "action_result", actionName: D.name, actionStatus: "failed", error: b, runId: z, ...J && { planStep: `${J.currentStep}/${J.totalSteps}`, planThought: J.thought } }, entityId: this.agentId, roomId: $.roomId, worldId: $.worldId, metadata: { type: "action_result", actionName: D.name, runId: z, parentRunId: O, error: true, ...J && { totalSteps: J.totalSteps, currentStep: J.currentStep } } };
          if (await this.createMemory(p, "messages"), g?.critical || g?.code === "CRITICAL_ERROR") throw g;
        }
        X++;
      }
      if ($.id) this.stateCache.set(`${$.id}_action_results`, { values: { actionResults: M }, data: { actionResults: M, actionPlan: J }, text: JSON.stringify(M) });
    }
  }
  getActionResults($) {
    return this.stateCache?.get(`${$}_action_results`)?.data?.actionResults || [];
  }
  async evaluate($, q, K, P, _) {
    try {
      let Y = this.evaluators.map(async (z) => {
        try {
          if (!z.handler) return null;
          if (!K && !z.alwaysRun) return null;
          if (await z.validate(this, $, q)) return z;
          return null;
        } catch (J) {
          return this.logger.error({ error: J, evaluatorName: z.name }, `Error validating evaluator ${z.name}`), null;
        }
      }), O = (await Promise.all(Y)).filter(Boolean);
      if (O.length === 0) return [];
      return q = await this.composeState($, ["RECENT_MESSAGES", "EVALUATORS"]), await Promise.all(O.map(async (z) => {
        try {
          if (z.handler) await z.handler(this, $, q, {}, P, _), this.adapter.log({ entityId: $.entityId, roomId: $.roomId, type: "evaluator", body: { evaluator: z.name, messageId: $.id, message: $.content.text, state: q, runId: this.getCurrentRunId() } });
        } catch (J) {
          this.logger.error({ error: J, evaluatorName: z.name }, `Error executing evaluator ${z.name}`);
        }
      })), O;
    } catch (Y) {
      return this.logger.error({ error: Y, messageId: $.id, roomId: $.roomId }, "Error in evaluate method"), [];
    }
  }
  async ensureConnections($, q, K, P) {
    if (!$) {
      console.trace(), this.logger.error("ensureConnections - no entities");
      return;
    }
    if (!q || q.length === 0) {
      console.trace(), this.logger.error("ensureConnections - no rooms");
      return;
    }
    await this.ensureWorldExists({ ...P, agentId: this.agentId });
    let _ = q[0], Y = /* @__PURE__ */ __name((b, y) => b.reduce((p, n, s) => {
      if (s % y === 0) p.push([]);
      return p[p.length - 1].push(n), p;
    }, []), "Y"), O = q.map((b) => b.id), J = (await this.getRoomsByIds(O))?.map((b) => b.id), T = O.filter((b) => !J?.includes(b)), X = { worldId: P.id, serverId: P.serverId, source: K, agentId: this.agentId };
    if (T.length) {
      this.logger.debug("runtime/ensureConnections - create", T.length.toLocaleString(), "rooms");
      let b = q.filter((y) => T.includes(y.id)).map((y) => ({ ...y, ...X }));
      await this.createRooms(b);
    }
    let f = $.map((b) => b.id), M = (await this.adapter.getEntitiesByIds(f))?.map((b) => b.id), N = $.filter((b) => !M?.includes(b.id)), E = { roomId: _.id, channelId: _.channelId, type: _.type }, h = { worldId: P.id, serverId: P.serverId };
    if (N.length) {
      this.logger.debug("runtime/ensureConnections - creating", N.length.toLocaleString(), "entities...");
      let b = { ...E, ...h, source: K, agentId: this.agentId }, y = N.map((n) => ({ ...n, ...b })), p = Y(y, 5e3);
      for (let n of p) await this.createEntities(n);
    }
    await this.ensureParticipantInRoom(this.agentId, _.id);
    let D = (await this.getParticipantsForRoom(_.id)).filter(Boolean), g = f.filter((b) => !D.includes(b));
    if (g.length) {
      this.logger.debug("runtime/ensureConnections - Missing", g.length.toLocaleString(), "connections in", _.id);
      let b = Y(g, 5e3);
      for (let y of b) await this.addParticipantsRoom(y, _.id);
    }
    this.logger.success("Success: Successfully connected world");
  }
  async ensureConnection({ entityId: $, roomId: q, worldId: K, worldName: P, userName: _, name: Y, source: O, type: z, channelId: J, serverId: T, userId: X, metadata: f }) {
    if (!K && T) K = _K(this, T);
    let V = [Y, _].filter(Boolean), M = { [O]: { id: X, name: Y, userName: _ } };
    try {
      let N = await this.getEntityById($);
      if (!N) try {
        if (await this.createEntity({ id: $, names: V, metadata: M, agentId: this.agentId })) this.logger.debug(`Created new entity ${$} for user ${Y || _ || "unknown"}`);
        else throw Error(`Failed to create entity ${$}`);
      } catch (E) {
        if (E.message?.includes("duplicate key") || E.code === "23505") this.logger.debug(`Entity ${$} exists in database but not for this agent. This is normal in multi-agent setups.`);
        else throw E;
      }
      else await this.adapter.updateEntity({ id: $, names: [.../* @__PURE__ */ new Set([...N.names || [], ...V])].filter(Boolean), metadata: { ...N.metadata, [O]: { ...N.metadata?.[O], id: X, name: Y, userName: _ } }, agentId: this.agentId });
      await this.ensureWorldExists({ id: K, name: P || T ? `World for server ${T}` : `World for room ${q}`, agentId: this.agentId, serverId: T || "default", metadata: f }), await this.ensureRoomExists({ id: q, name: Y || "default", source: O || "default", type: z || "DM", channelId: J, serverId: T, worldId: K });
      try {
        await this.ensureParticipantInRoom($, q);
      } catch (E) {
        if (E.message?.includes("not found")) {
          if (!await this.addParticipant($, q)) throw Error(`Failed to add participant ${$} to room ${q}`);
          this.logger.debug(`Added participant ${$} to room ${q} directly`);
        } else throw E;
      }
      await this.ensureParticipantInRoom(this.agentId, q), this.logger.debug(`Success: Successfully connected entity ${$} in room ${q}`);
    } catch (N) {
      throw this.logger.error(`Failed to ensure connection: ${N instanceof Error ? N.message : String(N)}`), N;
    }
  }
  async ensureParticipantInRoom($, q) {
    let K = await this.getEntityById($);
    if (!K && $ !== this.agentId) this.logger.warn(`Entity ${$} not directly accessible to agent ${this.agentId}. Will attempt to add as participant anyway.`);
    else if (!K && $ === this.agentId) throw Error(`Agent entity ${$} not found, cannot add as participant.`);
    else if (!K) throw Error(`User entity ${$} not found, cannot add as participant.`);
    if (!(await this.adapter.getParticipantsForRoom(q)).includes($)) {
      if (!await this.addParticipant($, q)) throw Error(`Failed to add participant ${$} to room ${q}`);
      if ($ === this.agentId) this.logger.debug(`Agent ${this.character.name} linked to room ${q} successfully.`);
      else this.logger.debug(`User ${$} linked to room ${q} successfully.`);
    }
  }
  async removeParticipant($, q) {
    return await this.adapter.removeParticipant($, q);
  }
  async getParticipantsForEntity($) {
    return await this.adapter.getParticipantsForEntity($);
  }
  async getParticipantsForRoom($) {
    return await this.adapter.getParticipantsForRoom($);
  }
  async addParticipant($, q) {
    return await this.adapter.addParticipantsRoom([$], q);
  }
  async addParticipantsRoom($, q) {
    return await this.adapter.addParticipantsRoom($, q);
  }
  async ensureWorldExists({ id: $, name: q, serverId: K, metadata: P }) {
    if (!await this.getWorld($)) this.logger.debug("Creating world:", JSON.stringify({ id: $, name: q, serverId: K, agentId: this.agentId })), await this.adapter.createWorld({ id: $, name: q, agentId: this.agentId, serverId: K || "default", metadata: P }), this.logger.debug(`World ${$} created successfully.`);
  }
  async ensureRoomExists({ id: $, name: q, source: K, type: P, channelId: _, serverId: Y, worldId: O, metadata: z }) {
    if (!O) throw Error("worldId is required");
    if (!await this.getRoom($)) await this.createRoom({ id: $, name: q, agentId: this.agentId, source: K, type: P, channelId: _, serverId: Y, worldId: O, metadata: z }), this.logger.debug(`Room ${$} created successfully.`);
  }
  async composeState($, q = null, K = false, P = false) {
    let _ = K ? q : null, Y = { values: {}, data: {}, text: "" }, O = P || !$.id ? Y : await this.stateCache.get($.id) || Y, z = /* @__PURE__ */ new Set();
    if (_ && _.length > 0) _.forEach((E) => z.add(E));
    else this.providers.filter((E) => !E.private && !E.dynamic).forEach((E) => z.add(E.name));
    if (!_ && q && q.length > 0) q.forEach((E) => z.add(E));
    let J = Array.from(new Set(this.providers.filter((E) => z.has(E.name)))).sort((E, h) => (E.position || 0) - (h.position || 0)), T = await Promise.all(J.map(async (E) => {
      let h = Date.now();
      try {
        let I = await E.get(this, $, O), D = Date.now() - h;
        if (D > 100) this.logger.debug(`${E.name} Provider took ${D}ms to respond`);
        return { ...I, providerName: E.name };
      } catch (I) {
        return console.error("provider error", E.name, I), { values: {}, text: "", data: {}, providerName: E.name };
      }
    })), X = { ...O.data?.providers || {} };
    for (let E of T) X[E.providerName] = E;
    let f = [];
    for (let E of J) {
      let h = X[E.name];
      if (h && h.text && h.text.trim() !== "") f.push(h.text);
    }
    let V = f.join(`
`), M = { ...O.values || {} };
    for (let E of J) {
      let h = X[E.name];
      if (h && h.values && typeof h.values === "object") Object.assign(M, h.values);
    }
    for (let E in X) if (!J.some((h) => h.name === E)) {
      let h = X[E];
      if (h && h.values && typeof h.values === "object") Object.assign(M, h.values);
    }
    let N = { values: { ...M, providers: V }, data: { ...O.data || {}, providers: X }, text: V };
    if ($.id) this.stateCache.set($.id, N);
    return N;
  }
  getService($) {
    let q = this.services.get($);
    if (!q || q.length === 0) return this.logger.debug(`Service ${$} not found`), null;
    return q[0];
  }
  getTypedService($) {
    return this.getService($);
  }
  getServicesByType($) {
    let q = this.services.get($);
    if (!q || q.length === 0) return this.logger.debug(`No services found for type ${$}`), [];
    return q;
  }
  getRegisteredServiceTypes() {
    return Array.from(this.services.keys());
  }
  hasService($) {
    let q = this.services.get($);
    return q !== void 0 && q.length > 0;
  }
  getServiceRegistrationStatus($) {
    return this.serviceRegistrationStatus.get($) || "unknown";
  }
  getServiceHealth() {
    let $ = {};
    for (let [q, K] of this.services) $[q] = { status: this.getServiceRegistrationStatus(q), instances: K.length, hasPromise: this.servicePromises.has(q) };
    for (let [q, K] of this.serviceRegistrationStatus) if (!$[q]) $[q] = { status: K, instances: 0, hasPromise: this.servicePromises.has(q) };
    return $;
  }
  async registerService($) {
    let q = $.serviceType, K = $.name || "Unknown";
    if (!q) {
      this.logger.warn(`Service ${K} is missing serviceType. Please define a static serviceType property.`);
      return;
    }
    this.logger.info(`Registering service: ${q}`), this.serviceRegistrationStatus.set(q, "registering");
    try {
      this.logger.debug(`Service ${q} waiting for initialization...`);
      let P = new Promise((O, z) => {
        setTimeout(() => {
          z(Error(`Service ${q} registration timed out waiting for runtime initialization (30s timeout)`));
        }, 3e4);
      });
      if (await Promise.race([this.initPromise, P]), typeof $.start !== "function") throw Error(`Service ${q} does not have a static start method. All services must implement static async start(runtime: IAgentRuntime): Promise<Service>.`);
      let _ = await $.start(this);
      if (!_) throw Error(`Service ${q}  start() method returned null or undefined. It must return a Service instance.`);
      if (!this.services.has(q)) this.services.set(q, []);
      if (!this.serviceTypes.has(q)) this.serviceTypes.set(q, []);
      this.services.get(q).push(_), this.serviceTypes.get(q).push($);
      let Y = this.servicePromiseHandlers.get(q);
      if (Y) Y.resolve(_), this.servicePromiseHandlers.delete(q);
      else this.logger.debug(`${this.character.name} - Service ${q} has no servicePromiseHandler`);
      if (typeof $.registerSendHandlers === "function") $.registerSendHandlers(this, _);
      this.serviceRegistrationStatus.set(q, "registered"), this.logger.info(`Service ${q} registered successfully`);
    } catch (P) {
      let _ = P instanceof Error ? P.message : String(P), Y = P instanceof Error ? P.stack : void 0;
      if (this.logger.error(`Failed to register service ${q}: ${_}`), P?.message?.includes("timed out waiting for runtime initialization")) this.logger.error(`Service ${q} failed due to runtime initialization timeout. Check if runtime.initialize() is being called and completing successfully.`);
      else if (P?.message?.includes("Not implemented")) {
        if (this.logger.error(`Service ${q} failed because it does not implement the static start() method. All services must override the base Service.start() method. Add: static async start(runtime: IAgentRuntime): Promise<${K}> { return new ${K}(runtime); }`), Y) this.logger.debug(`Stack trace: ${Y}`);
      } else if (P?.message?.includes("Service") && P?.message?.includes("failed to start")) this.logger.error(`Service ${q} (${K}) failed to start. Check service implementation and dependencies.`);
      else if (P?.message?.includes("does not have a static start method")) this.logger.error(`Service ${q} (${K}) is missing required static start() method implementation.`);
      else if (Y) this.logger.debug(`Service ${q} (${K}) error stack: ${Y}`);
      this.serviceRegistrationStatus.set(q, "failed");
      let O = this.servicePromiseHandlers.get(q);
      if (O) O.reject(P), this.servicePromiseHandlers.delete(q), this.servicePromises.delete(q);
      throw P;
    }
  }
  _createServiceResolver($) {
    let q, K;
    if (this.servicePromises.set($, new Promise((P, _) => {
      q = P, K = _;
    })), !q) throw Error(`Failed to create resolver for service ${$}`);
    if (!K) throw Error(`Failed to create rejecter for service ${$}`);
    return this.servicePromiseHandlers.set($, { resolve: q, reject: K }), this.servicePromises.get($);
  }
  getServiceLoadPromise($) {
    let q = this.servicePromises.get($);
    if (!q) q = this._createServiceResolver($);
    return q;
  }
  registerModel($, q, K, P) {
    let _ = typeof $ === "string" ? $ : M6[$];
    if (!this.models.has(_)) this.models.set(_, []);
    let Y = Date.now();
    this.models.get(_)?.push({ handler: q, provider: K, priority: P || 0, registrationOrder: Y }), this.models.get(_)?.sort((O, z) => {
      if ((z.priority || 0) !== (O.priority || 0)) return (z.priority || 0) - (O.priority || 0);
      return (O.registrationOrder || 0) - (z.registrationOrder || 0);
    });
  }
  getModel($, q) {
    let K = typeof $ === "string" ? $ : M6[$], P = this.models.get(K);
    if (!P?.length) return;
    if (q) {
      let _ = P.find((Y) => Y.provider === q);
      if (_) return this.logger.debug(`[AgentRuntime][${this.character.name}] Using model ${K} from provider ${q}`), _.handler;
      else this.logger.warn(`[AgentRuntime][${this.character.name}] No model found for provider ${q}`);
    }
    return this.logger.debug(`[AgentRuntime][${this.character.name}] Using model ${K} from provider ${P[0].provider}`), P[0].handler;
  }
  getModelSettings($) {
    let q = {}, K = /* @__PURE__ */ __name((z, J) => {
      if ($) {
        let V = `${$}_${z}`, M = this.getSetting(V);
        if (M !== null && M !== void 0) {
          let N = Number(M);
          if (!isNaN(N)) return N;
        }
      }
      let T = `DEFAULT_${z}`, X = this.getSetting(T);
      if (X !== null && X !== void 0) {
        let V = Number(X);
        if (!isNaN(V)) return V;
      }
      let f = this.getSetting(J);
      if (f !== null && f !== void 0) {
        let V = Number(f);
        if (!isNaN(V)) return V;
      }
      return null;
    }, "K"), P = K("MAX_TOKENS", PP.MODEL_MAX_TOKEN), _ = K("TEMPERATURE", PP.MODEL_TEMPERATURE), Y = K("FREQUENCY_PENALTY", PP.MODEL_FREQ_PENALTY), O = K("PRESENCE_PENALTY", PP.MODEL_PRESENCE_PENALTY);
    if (P !== null) q.maxTokens = P;
    if (_ !== null) q.temperature = _;
    if (Y !== null) q.frequencyPenalty = Y;
    if (O !== null) q.presencePenalty = O;
    return Object.keys(q).length > 0 ? q : null;
  }
  async useModel($, q, K) {
    let P = typeof $ === "string" ? $ : M6[$], _ = q?.prompt || q?.input || (Array.isArray(q?.messages) ? JSON.stringify(q.messages) : null), Y = this.getModel(P, K);
    if (!Y) {
      let T = `No handler found for delegate type: ${P}`;
      throw Error(T);
    }
    if (![M6.TRANSCRIPTION, M6.IMAGE, M6.AUDIO, M6.VIDEO].includes(P)) this.logger.debug(`[useModel] ${P} input: ` + JSON.stringify(q, EJ(), 2).replace(/\\n/g, `
`));
    else {
      let T = "unknown size";
      if (Buffer.isBuffer(q)) T = `${q.length} bytes`;
      else if (typeof Blob < "u" && q instanceof Blob) T = `${q.size} bytes`;
      else if (typeof q === "object" && q !== null) {
        if ("audio" in q && Buffer.isBuffer(q.audio)) T = `${q.audio.length} bytes`;
        else if ("audio" in q && typeof Blob < "u" && q.audio instanceof Blob) T = `${q.audio.size} bytes`;
      }
      this.logger.debug(`[useModel] ${P} input: <binary data: ${T}>`);
    }
    let z;
    if (q === null || q === void 0 || typeof q !== "object" || Array.isArray(q) || O_.isBuffer(q)) z = q;
    else {
      let T = this.getModelSettings(P);
      if (T) z = { ...T, ...q };
      else z = q;
    }
    let J = typeof performance < "u" && typeof performance.now === "function" ? performance.now() : Date.now();
    try {
      let T = await Y(this, z), X = (typeof performance < "u" && typeof performance.now === "function" ? performance.now() : Date.now()) - J;
      if (this.logger.debug(`[useModel] ${P} output (took ${Number(X.toFixed(2)).toLocaleString()}ms):`, Array.isArray(T) ? `${JSON.stringify(T.slice(0, 5))}...${JSON.stringify(T.slice(-5))} (${T.length} items)` : JSON.stringify(T, EJ(), 2).replace(/\\n/g, `
`)), P !== M6.TEXT_EMBEDDING && _) {
        if (this.currentActionContext) this.currentActionContext.prompts.push({ modelType: P, prompt: _, timestamp: Date.now() });
      }
      return this.adapter.log({ entityId: this.agentId, roomId: this.agentId, body: { modelType: $, modelKey: P, params: { ...typeof q === "object" && !Array.isArray(q) && q ? q : {}, prompt: _ }, prompt: _, runId: this.getCurrentRunId(), timestamp: Date.now(), executionTime: X, provider: K || this.models.get(P)?.[0]?.provider || "unknown", actionContext: this.currentActionContext ? { actionName: this.currentActionContext.actionName, actionId: this.currentActionContext.actionId } : void 0, response: Array.isArray(T) && T.every((f) => typeof f === "number") ? "[array]" : T }, type: `useModel:${P}` }), T;
    } catch (T) {
      throw T;
    }
  }
  async generateText($, q) {
    if (!$?.trim()) throw Error("Input cannot be empty");
    let K = q?.includeCharacter ?? true, P = q?.modelType ?? M6.TEXT_LARGE, _ = $;
    if (K && this.character) {
      let z = this.character, J = [], T = Array.isArray(z.bio) ? z.bio.join(" ") : z.bio;
      if (T) J.push(`# About ${z.name}
${T}`);
      if (z.system) J.push(z.system);
      let X = [...z.style?.all || [], ...z.style?.chat || []];
      if (X.length > 0) J.push(`Style:
${X.map((f) => `- ${f}`).join(`
`)}`);
      if (J.length > 0) _ = `${J.join(`

`)}

${$}`;
    }
    let Y = { prompt: _, maxTokens: q?.maxTokens, temperature: q?.temperature, frequencyPenalty: q?.frequencyPenalty, presencePenalty: q?.presencePenalty, stopSequences: q?.stopSequences };
    return { text: await this.useModel(P, Y) };
  }
  registerEvent($, q) {
    if (!this.events[$]) this.events[$] = [];
    this.events[$].push(q);
  }
  getEvent($) {
    return this.events[$];
  }
  async emitEvent($, q) {
    let K = Array.isArray($) ? $ : [$];
    for (let P of K) {
      let _ = this.events[P];
      if (!_) continue;
      try {
        let Y = { runtime: this };
        if (typeof q === "object" && q) Y = { ...q, ...Y };
        await Promise.all(_.map((O) => O(Y)));
      } catch (Y) {
        this.logger.error(`Error during emitEvent for ${P} (handler execution): ${Y}`);
      }
    }
  }
  async ensureEmbeddingDimension() {
    if (this.logger.debug(`[AgentRuntime][${this.character.name}] Starting ensureEmbeddingDimension`), !this.adapter) throw Error(`[AgentRuntime][${this.character.name}] Database adapter not initialized before ensureEmbeddingDimension`);
    try {
      if (!this.getModel(M6.TEXT_EMBEDDING)) throw Error(`[AgentRuntime][${this.character.name}] No TEXT_EMBEDDING model registered`);
      this.logger.debug(`[AgentRuntime][${this.character.name}] Getting embedding dimensions`);
      let q = await this.useModel(M6.TEXT_EMBEDDING, null);
      if (!q || !q.length) throw Error(`[AgentRuntime][${this.character.name}] Invalid embedding received`);
      this.logger.debug(`[AgentRuntime][${this.character.name}] Setting embedding dimension: ${q.length}`), await this.adapter.ensureEmbeddingDimension(q.length), this.logger.debug(`[AgentRuntime][${this.character.name}] Successfully set embedding dimension`);
    } catch ($) {
      throw this.logger.debug(`[AgentRuntime][${this.character.name}] Error in ensureEmbeddingDimension: ${$}`), $;
    }
  }
  registerTaskWorker($) {
    if (this.taskWorkers.has($.name)) this.logger.warn(`Task definition ${$.name} already registered. Will be overwritten.`);
    this.taskWorkers.set($.name, $);
  }
  getTaskWorker($) {
    return this.taskWorkers.get($);
  }
  get db() {
    return this.adapter.db;
  }
  async init() {
    await this.adapter.init();
  }
  async close() {
    if (this.adapter) await this.adapter.close();
  }
  async getAgent($) {
    return await this.adapter.getAgent($);
  }
  async getAgents() {
    return await this.adapter.getAgents();
  }
  async createAgent($) {
    return await this.adapter.createAgent($);
  }
  async updateAgent($, q) {
    return await this.adapter.updateAgent($, q);
  }
  async deleteAgent($) {
    return await this.adapter.deleteAgent($);
  }
  async ensureAgentExists($) {
    if (!$.id) throw Error("Agent id is required");
    let q = await this.adapter.getAgent($.id);
    if (q) {
      let _ = { ...q.settings, ...$.settings }, Y = typeof q.settings?.secrets === "object" || typeof $.settings?.secrets === "object" ? { ...typeof q.settings?.secrets === "object" ? q.settings.secrets : {}, ...typeof $.settings?.secrets === "object" ? $.settings.secrets : {} } : void 0;
      if (Y) _.secrets = Y;
      let O = { ...q, ...$, settings: _, id: $.id, updatedAt: Date.now() };
      await this.adapter.updateAgent($.id, O);
      let z = await this.adapter.getAgent($.id);
      if (!z) throw Error(`Failed to retrieve agent after update: ${$.id}`);
      return this.logger.debug(`Updated existing agent ${$.id} on restart (merged ${Object.keys(q.settings || {}).length} DB settings with ${Object.keys($.settings || {}).length} character settings)`), z;
    }
    let K = { ...$, id: $.id };
    if (!await this.adapter.createAgent(K)) throw Error(`Failed to create agent: ${$.id}`);
    return this.logger.debug(`Created new agent ${$.id}`), K;
  }
  async getEntityById($) {
    let q = await this.adapter.getEntitiesByIds([$]);
    if (!q?.length) return null;
    return q[0];
  }
  async getEntitiesByIds($) {
    return await this.adapter.getEntitiesByIds($);
  }
  async getEntitiesForRoom($, q) {
    return await this.adapter.getEntitiesForRoom($, q);
  }
  async createEntity($) {
    if (!$.agentId) $.agentId = this.agentId;
    return await this.createEntities([$]);
  }
  async createEntities($) {
    return $.forEach((q) => {
      q.agentId = this.agentId;
    }), await this.adapter.createEntities($);
  }
  async updateEntity($) {
    await this.adapter.updateEntity($);
  }
  async getComponent($, q, K, P) {
    return await this.adapter.getComponent($, q, K, P);
  }
  async getComponents($, q, K) {
    return await this.adapter.getComponents($, q, K);
  }
  async createComponent($) {
    return await this.adapter.createComponent($);
  }
  async updateComponent($) {
    await this.adapter.updateComponent($);
  }
  async deleteComponent($) {
    await this.adapter.deleteComponent($);
  }
  async addEmbeddingToMemory($) {
    if ($.embedding) return $;
    let q = $.content.text;
    if (!q) throw Error("Cannot generate embedding: Memory content is empty");
    try {
      $.embedding = await this.useModel(M6.TEXT_EMBEDDING, { text: q });
    } catch (K) {
      this.logger.error("Failed to generate embedding:", K), $.embedding = await this.useModel(M6.TEXT_EMBEDDING, null);
    }
    return $;
  }
  async queueEmbeddingGeneration($, q) {
    if (q = q || "normal", !$) return;
    if ($.embedding) return;
    if (!$.content?.text) {
      this.logger.debug("Skipping embedding generation for memory without text content");
      return;
    }
    await this.emitEvent("EMBEDDING_GENERATION_REQUESTED", { runtime: this, memory: $, priority: q, source: "runtime", retryCount: 0, maxRetries: 3, runId: this.getCurrentRunId() });
  }
  async getMemories($) {
    return await this.adapter.getMemories($);
  }
  async getAllMemories() {
    let $ = ["memories", "messages", "facts", "documents"], q = [];
    for (let K of $) try {
      let P = await this.adapter.getMemories({ agentId: this.agentId, tableName: K, count: 1e4 });
      q.push(...P);
    } catch (P) {
      this.logger.debug(`Failed to get memories from table ${K}: ${P}`);
    }
    return q;
  }
  async getMemoryById($) {
    return await this.adapter.getMemoryById($);
  }
  async getMemoriesByIds($, q) {
    return await this.adapter.getMemoriesByIds($, q);
  }
  async getMemoriesByRoomIds($) {
    return await this.adapter.getMemoriesByRoomIds($);
  }
  async getCachedEmbeddings($) {
    return await this.adapter.getCachedEmbeddings($);
  }
  async log($) {
    await this.adapter.log($);
  }
  async searchMemories($) {
    let q = await this.adapter.searchMemories($);
    if ($.query) return await this.rerankMemories($.query, q);
    return q;
  }
  async rerankMemories($, q) {
    let K = q.map((Y) => ({ title: Y.id, content: Y.content.text }));
    return new yJ(K).search($, q.length).map((Y) => q[Y.index]);
  }
  async createMemory($, q, K) {
    if (K !== void 0) $.unique = K;
    return await this.adapter.createMemory($, q, K);
  }
  async updateMemory($) {
    return await this.adapter.updateMemory($);
  }
  async deleteMemory($) {
    await this.adapter.deleteMemory($);
  }
  async deleteManyMemories($) {
    await this.adapter.deleteManyMemories($);
  }
  async clearAllAgentMemories() {
    this.logger.info(`Clearing all memories for agent ${this.character.name} (${this.agentId})`);
    let q = (await this.getAllMemories()).map((K) => K.id).filter((K) => K !== void 0);
    if (q.length === 0) {
      this.logger.info("No memories found to delete");
      return;
    }
    this.logger.info(`Found ${q.length} memories to delete`), await this.adapter.deleteManyMemories(q), this.logger.info(`Successfully cleared all ${q.length} memories for agent`);
  }
  async deleteAllMemories($, q) {
    await this.adapter.deleteAllMemories($, q);
  }
  async countMemories($, q, K) {
    return await this.adapter.countMemories($, q, K);
  }
  async getLogs($) {
    return await this.adapter.getLogs($);
  }
  async deleteLog($) {
    await this.adapter.deleteLog($);
  }
  async createWorld($) {
    return await this.adapter.createWorld($);
  }
  async getWorld($) {
    return await this.adapter.getWorld($);
  }
  async removeWorld($) {
    await this.adapter.removeWorld($);
  }
  async getAllWorlds() {
    return await this.adapter.getAllWorlds();
  }
  async updateWorld($) {
    await this.adapter.updateWorld($);
  }
  async getRoom($) {
    let q = await this.adapter.getRoomsByIds([$]);
    if (!q?.length) return null;
    return q[0];
  }
  async getRoomsByIds($) {
    return await this.adapter.getRoomsByIds($);
  }
  async createRoom({ id: $, name: q, source: K, type: P, channelId: _, serverId: Y, worldId: O }) {
    if (!O) throw Error("worldId is required");
    let z = await this.adapter.createRooms([{ id: $, name: q, source: K, type: P, channelId: _, serverId: Y, worldId: O }]);
    if (!z.length) throw Error("Failed to create room");
    return z[0];
  }
  async createRooms($) {
    return await this.adapter.createRooms($);
  }
  async deleteRoom($) {
    await this.adapter.deleteRoom($);
  }
  async deleteRoomsByWorldId($) {
    await this.adapter.deleteRoomsByWorldId($);
  }
  async updateRoom($) {
    await this.adapter.updateRoom($);
  }
  async getRoomsForParticipant($) {
    return await this.adapter.getRoomsForParticipant($);
  }
  async getRoomsForParticipants($) {
    return await this.adapter.getRoomsForParticipants($);
  }
  async getRooms($) {
    return await this.adapter.getRoomsByWorld($);
  }
  async getRoomsByWorld($) {
    return await this.adapter.getRoomsByWorld($);
  }
  async getParticipantUserState($, q) {
    return await this.adapter.getParticipantUserState($, q);
  }
  async setParticipantUserState($, q, K) {
    await this.adapter.setParticipantUserState($, q, K);
  }
  async createRelationship($) {
    return await this.adapter.createRelationship($);
  }
  async updateRelationship($) {
    await this.adapter.updateRelationship($);
  }
  async getRelationship($) {
    return await this.adapter.getRelationship($);
  }
  async getRelationships($) {
    return await this.adapter.getRelationships($);
  }
  async getCache($) {
    return await this.adapter.getCache($);
  }
  async setCache($, q) {
    return await this.adapter.setCache($, q);
  }
  async deleteCache($) {
    return await this.adapter.deleteCache($);
  }
  async createTask($) {
    return await this.adapter.createTask($);
  }
  async getTasks($) {
    return await this.adapter.getTasks($);
  }
  async getTask($) {
    return await this.adapter.getTask($);
  }
  async getTasksByName($) {
    return await this.adapter.getTasksByName($);
  }
  async updateTask($, q) {
    await this.adapter.updateTask($, q);
  }
  async deleteTask($) {
    await this.adapter.deleteTask($);
  }
  on($, q) {
    if (!this.eventHandlers.has($)) this.eventHandlers.set($, []);
    this.eventHandlers.get($)?.push(q);
  }
  off($, q) {
    if (!this.eventHandlers.has($)) return;
    let K = this.eventHandlers.get($), P = K.indexOf(q);
    if (P !== -1) K.splice(P, 1);
  }
  emit($, q) {
    if (!this.eventHandlers.has($)) return;
    for (let K of this.eventHandlers.get($)) K(q);
  }
  async sendControlMessage($) {
    try {
      let { roomId: q, action: K, target: P } = $, _ = { type: "control", payload: { action: K, target: P }, roomId: q };
      await this.emitEvent("CONTROL_MESSAGE", { runtime: this, message: _, source: "agent" }), this.logger.debug(`Sent control message: ${K} to room ${q}`);
    } catch (q) {
      this.logger.error(`Error sending control message: ${q}`);
    }
  }
  registerSendHandler($, q) {
    if (this.sendHandlers.has($)) this.logger.warn(`Send handler for source '${$}' already registered. Overwriting.`);
    this.sendHandlers.set($, q), this.logger.info(`Registered send handler for source: ${$}`);
  }
  async sendMessageToTarget($, q) {
    let K = this.sendHandlers.get($.source);
    if (!K) {
      let P = `No send handler registered for source: ${$.source}`;
      throw this.logger.error(P), Error(P);
    }
    try {
      await K(this, $, q);
    } catch (P) {
      throw this.logger.error(`Error executing send handler for source ${$.source}:`, P), P;
    }
  }
  async getMemoriesByWorldId($) {
    return await this.adapter.getMemoriesByWorldId($);
  }
  async runMigrations($) {
    if (this.adapter && "runMigrations" in this.adapter) await this.adapter.runMigrations($);
    else this.logger.warn("Database adapter does not support migrations.");
  }
  async isReady() {
    if (!this.adapter) throw Error("Database adapter not registered");
    return await this.adapter.isReady();
  }
  hasElizaOS() {
    return this.elizaOS !== void 0;
  }
};
_$ = new WeakMap();
__name(_uJ, "uJ");
var uJ = _uJ;
async function Mt($) {
  let q = {};
  for (let [P, _] of Object.entries(process.env)) if (_ !== void 0) q[P] = _;
  if (!$.settings) $.settings = {};
  let K = $.settings.secrets && typeof $.settings.secrets === "object" ? { ...$.settings.secrets } : {};
  return $.settings.secrets = { ...q, ...K }, true;
}
__name(Mt, "Mt");
async function IM($, q) {
  if (r4() !== "node") return false;
  if (q?.skipEnvMerge) return false;
  return Mt($);
}
__name(IM, "IM");
function Nt() {
  try {
    return typeof process < "u" && (process.versions?.node !== void 0 || process.versions?.bun !== void 0);
  } catch {
    return false;
  }
}
__name(Nt, "Nt");
function xJ() {
  if (Nt()) return lq(), J6(dq);
  return c8("crypto-browserify");
}
__name(xJ, "xJ");
function pJ($) {
  let K = xJ().createHash($);
  return { update(P) {
    return K.update(P), this;
  }, digest() {
    return new Uint8Array(K.digest());
  } };
}
__name(pJ, "pJ");
function DM($, q, K) {
  if ($ !== "aes-256-cbc") throw Error(`Unsupported algorithm: ${$}. Only 'aes-256-cbc' is currently supported.`);
  return xJ().createCipheriv($, q, K);
}
__name(DM, "DM");
function LM($, q, K) {
  if ($ !== "aes-256-cbc") throw Error(`Unsupported algorithm: ${$}. Only 'aes-256-cbc' is currently supported.`);
  return xJ().createDecipheriv($, q, K);
}
__name(LM, "LM");
function ht($) {
  return { name: $.name, description: $.description, usageDescription: $.usageDescription || "", value: null, required: $.required, validation: $.validation || void 0, public: $.public || false, secret: $.secret || false, dependsOn: $.dependsOn || [], onSetAction: $.onSetAction || void 0, visibleIf: $.visibleIf || void 0 };
}
__name(ht, "ht");
var $P = null;
var cJ = false;
var Et = 3e5;
function c_() {
  let $ = __("SECRET_SALT", "secretsalt") || "secretsalt", q = Date.now();
  if ($P !== null) {
    if (q - $P.timestamp < Et && $P.value === $) return $P.value;
  }
  if ($ === "secretsalt" && !cJ) j6.warn("SECRET_SALT is not set or using default value"), cJ = true;
  return $P = { value: $, timestamp: q }, $;
}
__name(c_, "c_");
function f5$() {
  $P = null, cJ = false;
}
__name(f5$, "f5$");
function yM($, q) {
  if ($ === void 0 || $ === null) return j6.debug("Attempted to encrypt undefined or null value"), $;
  if (typeof $ === "boolean" || typeof $ === "number") return j6.debug("Value is a boolean or number, returning as is"), $;
  if (typeof $ !== "string") return j6.debug(`Value is not a string (type: ${typeof $}), returning as is`), $;
  let K = $.split(":");
  if (K.length === 2) try {
    if (O_.fromHex(K[0]).length === 16) return j6.debug("Value appears to be already encrypted, skipping re-encryption"), $;
  } catch (z) {
  }
  let P = pJ("sha256").update(q).digest().slice(0, 32), _ = O_.randomBytes(16), Y = DM("aes-256-cbc", P, _), O = Y.update($, "utf8", "hex");
  return O += Y.final("hex"), `${O_.toHex(_)}:${O}`;
}
__name(yM, "yM");
function EO($, q) {
  try {
    if ($ === void 0 || $ === null) return $;
    if (typeof $ === "boolean" || typeof $ === "number") return $;
    if (typeof $ !== "string") return j6.debug(`Value is not a string (type: ${typeof $}), returning as is`), $;
    let K = $.split(":");
    if (K.length !== 2) return $;
    let P = O_.fromHex(K[0]), _ = K[1];
    if (P.length !== 16) {
      if (P.length) j6.debug(`Invalid IV length (${P.length}) - expected 16 bytes`);
      return $;
    }
    let Y = pJ("sha256").update(q).digest().slice(0, 32), O = LM("aes-256-cbc", Y, P), z = O.update(_, "hex", "utf8");
    return z += O.final("utf8"), z;
  } catch (K) {
    return j6.error(`Error decrypting value: ${K}`), $;
  }
}
__name(EO, "EO");
function Rt($, q) {
  let K = { ...$ };
  if ($.secret === true && typeof $.value === "string" && $.value) K.value = yM($.value, q);
  return K;
}
__name(Rt, "Rt");
function It($, q) {
  let K = { ...$ };
  if ($.secret === true && typeof $.value === "string" && $.value) K.value = EO($.value, q);
  return K;
}
__name(It, "It");
function Dt($, q) {
  let K = {};
  for (let [P, _] of Object.entries($)) K[P] = Rt(_, q);
  return K;
}
__name(Dt, "Dt");
function uM($, q) {
  let K = {};
  for (let [P, _] of Object.entries($)) K[P] = It(_, q);
  return K;
}
__name(uM, "uM");
async function Z5$($, q, K) {
  let P = _K($, q), _ = await $.getWorld(P);
  if (!_) return j6.error(`No world found for server ${q}`), false;
  if (!_.metadata) _.metadata = {};
  let Y = c_(), O = Dt(K, Y);
  return _.metadata.settings = O, await $.updateWorld(_), true;
}
__name(Z5$, "Z5$");
async function X5$($, q) {
  let K = _K($, q), P = await $.getWorld(K);
  if (!P || !P.metadata?.settings) return null;
  let _ = P.metadata.settings, Y = c_();
  return uM(_, Y);
}
__name(X5$, "X5$");
async function A5$($, q, K) {
  if (q.metadata?.settings) {
    j6.info(`Onboarding state already exists for server ${q.serverId}`);
    let _ = q.metadata.settings, Y = c_();
    return uM(_, Y);
  }
  let P = {};
  if (K.settings) for (let [_, Y] of Object.entries(K.settings)) P[_] = ht(Y);
  if (!q.metadata) q.metadata = {};
  return q.metadata.settings = P, await $.updateWorld(q), j6.info(`Initialized settings config for server ${q.serverId}`), P;
}
__name(A5$, "A5$");
function k5$($) {
  let q = JSON.parse(JSON.stringify($)), K = c_();
  if (q.settings?.secrets) q.settings.secrets = gM(q.settings.secrets, K);
  if (q.secrets) q.secrets = gM(q.secrets, K);
  return q;
}
__name(k5$, "k5$");
function G5$($, q) {
  let K = JSON.parse(JSON.stringify($)), P = c_();
  if (K.settings?.secrets) K.settings.secrets = bM(K.settings.secrets, P);
  if (K.secrets) K.secrets = bM(K.secrets, P);
  return K;
}
__name(G5$, "G5$");
function gM($, q) {
  let K = {};
  for (let [P, _] of Object.entries($)) if (typeof _ === "string" && _) K[P] = yM(_, q);
  else K[P] = _;
  return K;
}
__name(gM, "gM");
function bM($, q) {
  let K = {};
  for (let [P, _] of Object.entries($)) if (typeof _ === "string" && _) K[P] = EO(_, q);
  else K[P] = _;
  return K;
}
__name(bM, "bM");
var _xM = class _xM {
  serviceType;
  startFn;
  stopFn;
  description;
  constructor($) {
    this.serviceType = $, this.description = "";
  }
  withDescription($) {
    return this.description = $, this;
  }
  withStart($) {
    return this.startFn = $, this;
  }
  withStop($) {
    return this.stopFn = $, this;
  }
  build() {
    var _a52;
    let $ = this.serviceType, q = this.description, K = this.startFn, P = this.stopFn;
    return _a52 = class extends LO {
      capabilityDescription = q;
      static async start(_) {
        if (!K) throw Error(`Start function not defined for service ${$}`);
        return K(_);
      }
      async stop() {
        if (P) await P();
      }
    }, __publicField(_a52, "serviceType", $), _a52;
  }
};
__name(_xM, "xM");
var xM = _xM;
function Lt($) {
  return new xM($);
}
__name(Lt, "Lt");
function M5$($) {
  return Lt($.serviceType).withDescription($.description).withStart($.start).withStop($.stop || (() => Promise.resolve())).build();
}
__name(M5$, "M5$");
var pM = /* @__PURE__ */ new Set();
function gt() {
  if (process.env.ELIZA_NO_AUTO_INSTALL === "true") return false;
  if (process.env.ELIZA_NO_PLUGIN_AUTO_INSTALL === "true") return false;
  if (process.env.CI === "true") return false;
  if (process.env.ELIZA_TEST_MODE === "true") return false;
  return true;
}
__name(gt, "gt");
async function bt($) {
  try {
    if (!gt()) return j6.debug(`Auto-install disabled or not allowed in this environment. Skipping install for ${$}.`), false;
    if (pM.has($)) return j6.debug(`Auto-install already attempted for ${$}. Skipping.`), false;
    if (pM.add($), typeof Bun > "u" || typeof Bun.spawn !== "function") return j6.warn(`Bun runtime not available. Cannot auto-install ${$}. Please run: bun add ${$}`), false;
    try {
      if (await Bun.spawn(["bun", "--version"], { stdout: "pipe", stderr: "pipe" }).exited !== 0) return j6.warn(`Bun not available on PATH. Cannot auto-install ${$}. Please run: bun add ${$}`), false;
    } catch {
      return j6.warn(`Bun not available on PATH. Cannot auto-install ${$}. Please run: bun add ${$}`), false;
    }
    j6.info(`Attempting to auto-install missing plugin: ${$}`);
    let K = await Bun.spawn(["bun", "add", $], { cwd: process.cwd(), env: process.env, stdout: "inherit", stderr: "inherit" }).exited;
    if (K === 0) return j6.info(`Successfully installed ${$}. Retrying import...`), true;
    return j6.error(`bun add ${$} failed with exit code ${K}. Please install manually.`), false;
  } catch (q) {
    let K = q instanceof Error ? q.message : String(q);
    return j6.error(`Unexpected error during auto-install of ${$}: ${K}`), false;
  }
}
__name(bt, "bt");
function cM($) {
  if (!$ || typeof $ !== "object") return false;
  let q = $;
  if (!q.name) return false;
  return !!(q.init || q.services || q.providers || q.actions || q.evaluators || q.description);
}
__name(cM, "cM");
function yt($) {
  let q = [];
  if (!$) return q.push("Plugin is null or undefined"), { isValid: false, errors: q };
  let K = $;
  if (!K.name) q.push("Plugin must have a name");
  if (K.actions) {
    if (!Array.isArray(K.actions)) q.push("Plugin actions must be an array");
    else if (K.actions.filter((_) => typeof _ !== "object" || !_).length > 0) q.push("Plugin actions must be an array of action objects");
  }
  if (K.services) {
    if (!Array.isArray(K.services)) q.push("Plugin services must be an array");
    else if (K.services.filter((_) => typeof _ !== "function" && (typeof _ !== "object" || !_)).length > 0) q.push("Plugin services must be an array of service classes or objects");
  }
  if (K.providers && !Array.isArray(K.providers)) q.push("Plugin providers must be an array");
  if (K.evaluators && !Array.isArray(K.evaluators)) q.push("Plugin evaluators must be an array");
  return { isValid: q.length === 0, errors: q };
}
__name(yt, "yt");
async function ut($) {
  try {
    let q;
    try {
      q = await import($);
    } catch (Y) {
      if (j6.warn(`Failed to load plugin ${$}: ${Y}`), !await bt($)) return null;
      try {
        q = await import($);
      } catch (z) {
        return j6.error(`Auto-install attempted for ${$} but import still failed: ${z}`), null;
      }
    }
    if (!q) return j6.error(`Failed to load module for plugin ${$}.`), null;
    let K = `${$.replace(/^@elizaos\/plugin-/, "").replace(/^@elizaos\//, "").replace(/-./g, (Y) => Y[1].toUpperCase())}Plugin`, P = q, _ = [P[K], P.default, ...Object.values(P)];
    for (let Y of _) {
      if (cM(Y)) return Y;
      if (typeof Y === "function" && Y.length === 0) try {
        let O = Y();
        if (cM(O)) return O;
      } catch (O) {
        j6.debug(`Factory export threw for ${$}: ${O}`);
      }
    }
    return j6.warn(`Could not find a valid plugin export in ${$}.`), null;
  } catch (q) {
    return j6.error(`Error loading plugin ${$}: ${q}`), null;
  }
}
__name(ut, "ut");
function z1($) {
  let q = $.match(/^@[^/]+\/plugin-(.+)$/);
  if (q) return q[1];
  return $;
}
__name(z1, "z1");
function dM($, q = false) {
  let K = [], P = /* @__PURE__ */ new Set(), _ = /* @__PURE__ */ new Set(), Y = /* @__PURE__ */ new Map();
  for (let [J, T] of $.entries()) {
    if (Y.set(J, T), T.name !== J) Y.set(T.name, T);
    if (!T.name.startsWith("@")) Y.set(`@elizaos/plugin-${T.name}`, T);
    let X = z1(J);
    if (X !== J) Y.set(X, T);
  }
  function O(J) {
    let T = Y.get(J);
    if (!T) {
      let V = z1(J), M = Y.get(V);
      if (!M) {
        j6.warn(`Plugin dependency "${J}" not found and will be skipped.`);
        return;
      }
      return O(M.name);
    }
    let X = T.name;
    if (P.has(X)) return;
    if (_.has(X)) {
      j6.error(`Circular dependency detected involving plugin: ${X}`);
      return;
    }
    _.add(X);
    let f = [...T.dependencies || []];
    if (q) f.push(...T.testDependencies || []);
    for (let V of f) O(V);
    _.delete(X), P.add(X), K.push(X);
  }
  __name(O, "O");
  for (let J of $.values()) if (!P.has(J.name)) O(J.name);
  let z = K.map((J) => {
    for (let T of $.values()) if (T.name === J) return T;
    return null;
  }).filter((J) => Boolean(J));
  return j6.info({ plugins: z.map((J) => J.name) }, "Final plugins being loaded:"), z;
}
__name(dM, "dM");
async function xt($) {
  if (typeof $ === "string") return ut($);
  let q = yt($);
  if (!q.isValid) return j6.error(`Invalid plugin provided: ${q.errors.join(", ")}`), null;
  return $;
}
__name(xt, "xt");
function mM($, q, K, P) {
  let _ = z1($);
  if (!(q.has($) || q.has(_) || Array.from(K.keys()).some((O) => z1(O) === _) || Array.from(K.values()).some((O) => z1(O.name) === _ || O.name === $ || O.name === _))) q.add($), q.add(_), P.push($);
}
__name(mM, "mM");
async function pt($, q = false) {
  let K = /* @__PURE__ */ new Map(), P = [...$], _ = /* @__PURE__ */ new Set();
  while (P.length > 0) {
    let Y = P.shift(), O = await xt(Y);
    if (!O) continue;
    let z = O.name;
    if (!K.has(z)) {
      K.set(z, O);
      for (let J of O.dependencies ?? []) mM(J, _, K, P);
      if (q) for (let J of O.testDependencies ?? []) mM(J, _, K, P);
    }
  }
  return dM(K, q);
}
__name(pt, "pt");
async function lM($, q = false) {
  if (r4() === "node") return pt($, q);
  let P = $.filter((Y) => typeof Y !== "string");
  if ($.some((Y) => typeof Y === "string")) j6.warn("Browser environment: String plugin references are not supported. Only Plugin objects will be used. Skipped plugins: " + $.filter((Y) => typeof Y === "string").join(", "));
  let _ = /* @__PURE__ */ new Map();
  for (let Y of P) _.set(Y.name, Y);
  return dM(_, q);
}
__name(lM, "lM");
var _ct = class _ct extends EventTarget {
  runtimes = /* @__PURE__ */ new Map();
  initFunctions = /* @__PURE__ */ new Map();
  editableMode = false;
  async addAgents($, q) {
    let K = $.map(async (_) => {
      let Y = _.character;
      await IM(Y, { skipEnvMerge: q?.isTestMode });
      let O = _.plugins ? await lM(_.plugins, q?.isTestMode || false) : [], z = new uJ({ character: Y, plugins: O, settings: _.settings || {} });
      if (z.elizaOS = this, this.runtimes.set(z.agentId, z), typeof _.init === "function") this.initFunctions.set(z.agentId, _.init);
      let { settings: J, ...T } = Y, { secrets: X, ...f } = J || {};
      return this.dispatchEvent(new CustomEvent("agent:added", { detail: { agentId: z.agentId, character: { ...T, settings: f } } })), z.agentId;
    }), P = await Promise.all(K);
    return this.dispatchEvent(new CustomEvent("agents:added", { detail: { agentIds: P, count: P.length } })), P;
  }
  registerAgent($) {
    if (this.runtimes.has($.agentId)) throw Error(`Agent ${$.agentId} already registered`);
    $.elizaOS = this, this.runtimes.set($.agentId, $), this.dispatchEvent(new CustomEvent("agent:registered", { detail: { agentId: $.agentId, runtime: $ } }));
  }
  async updateAgent($, q) {
    if (!this.editableMode) throw Error("Editable mode not enabled");
    let K = this.runtimes.get($);
    if (!K) throw Error(`Agent ${$} not found`);
    Object.assign(K.character, q), this.dispatchEvent(new CustomEvent("agent:updated", { detail: { agentId: $, updates: q } }));
  }
  async deleteAgents($) {
    await this.stopAgents($);
    for (let q of $) this.runtimes.delete(q), this.initFunctions.delete(q);
    this.dispatchEvent(new CustomEvent("agents:deleted", { detail: { agentIds: $, count: $.length } }));
  }
  async startAgents($) {
    let q = $ || Array.from(this.runtimes.keys());
    await Promise.all(q.map(async (K) => {
      let P = this.runtimes.get(K);
      if (!P) throw Error(`Agent ${K} not found`);
      await P.initialize(), this.dispatchEvent(new CustomEvent("agent:started", { detail: { agentId: K } }));
    }));
    for (let K of q) {
      let P = this.initFunctions.get(K);
      if (P) {
        let _ = this.runtimes.get(K);
        if (_) await P(_), this.initFunctions.delete(K);
      }
    }
    this.dispatchEvent(new CustomEvent("agents:started", { detail: { agentIds: q, count: q.length } }));
  }
  async stopAgents($) {
    let q = $ || Array.from(this.runtimes.keys());
    await Promise.all(q.map(async (K) => {
      let P = this.runtimes.get(K);
      if (P) await P.stop();
    })), this.dispatchEvent(new CustomEvent("agents:stopped", { detail: { agentIds: q, count: q.length } }));
  }
  getAgent($) {
    return this.runtimes.get($);
  }
  getAgents() {
    return Array.from(this.runtimes.values());
  }
  getAgentsByIds($) {
    return $.map((q) => this.runtimes.get(q)).filter((q) => q !== void 0);
  }
  getAgentsByNames($) {
    let q = new Set($.map((K) => K.toLowerCase()));
    return this.getAgents().filter((K) => q.has(K.character.name.toLowerCase()));
  }
  getAgentById($) {
    return this.getAgent($);
  }
  getAgentByName($) {
    let q = $.toLowerCase();
    return this.getAgents().find((K) => K.character.name.toLowerCase() === q);
  }
  getAgentByCharacterName($) {
    return this.getAgentByName($);
  }
  getAgentByCharacterId($) {
    return this.getAgents().find((q) => q.character.id === $);
  }
  async sendMessage($, q, K) {
    let P = this.runtimes.get($);
    if (!P) throw Error(`Agent ${$} not found`);
    if (!P.messageService) throw Error("messageService is not initialized on runtime");
    let _ = q.id || Dq(), Y = { ...q, id: _, agentId: q.agentId || P.agentId, createdAt: q.createdAt || Date.now(), entityId: q.entityId, roomId: q.roomId, content: q.content };
    await P.ensureConnection({ entityId: Y.entityId, roomId: Y.roomId, worldId: q.worldId || Y.roomId, source: Y.content.source || "unknown", channelId: Y.roomId });
    let O = { maxRetries: K?.maxRetries, timeoutDuration: K?.timeoutDuration, useMultiStep: K?.useMultiStep, maxMultiStepIterations: K?.maxMultiStepIterations };
    if (!!K?.onResponse) {
      let J = /* @__PURE__ */ __name(async (T) => {
        try {
          if (K.onResponse) await K.onResponse(T);
        } catch (X) {
          if (K.onError) await K.onError(X instanceof Error ? X : Error(String(X)));
        }
        return [];
      }, "J");
      return P.messageService.handleMessage(P, Y, J, O).then(() => {
        if (K.onComplete) K.onComplete();
      }).catch((T) => {
        if (K.onError) K.onError(T);
      }), this.dispatchEvent(new CustomEvent("message:sent", { detail: { agentId: $, messageId: _, mode: "async" } })), { messageId: _, userMessage: Y };
    } else {
      let J = await P.messageService.handleMessage(P, Y, void 0, O);
      if (K?.onComplete) await K.onComplete();
      return this.dispatchEvent(new CustomEvent("message:sent", { detail: { agentId: $, messageId: _, mode: "sync", result: J } })), { messageId: _, userMessage: Y, result: J };
    }
  }
  async sendMessages($) {
    let q = await Promise.all($.map(async ({ agentId: K, message: P, options: _ }) => {
      try {
        let Y = await this.sendMessage(K, P, _);
        return { agentId: K, result: Y };
      } catch (Y) {
        return { agentId: K, result: { messageId: P.id || "", userMessage: P }, error: Y instanceof Error ? Y : Error(String(Y)) };
      }
    }));
    return this.dispatchEvent(new CustomEvent("messages:sent", { detail: { results: q, count: $.length } })), q;
  }
  async validateApiKeys($) {
    let q = /* @__PURE__ */ new Map(), K = $ || Array.from(this.runtimes.keys());
    for (let P of K) {
      let _ = this.runtimes.get(P);
      if (_) {
        let Y = !!(_.getSetting("OPENAI_API_KEY") || _.getSetting("ANTHROPIC_API_KEY"));
        q.set(P, Y);
      }
    }
    return q;
  }
  async healthCheck($) {
    let q = /* @__PURE__ */ new Map(), K = $ || Array.from(this.runtimes.keys());
    for (let P of K) {
      let Y = { alive: !!this.runtimes.get(P), responsive: true };
      if (typeof process < "u") Y.memoryUsage = process.memoryUsage().heapUsed, Y.uptime = process.uptime();
      q.set(P, Y);
    }
    return q;
  }
  getRuntimeAccessor() {
    return { getAgent: /* @__PURE__ */ __name(($) => this.getAgent($), "getAgent"), getAgents: /* @__PURE__ */ __name(() => this.getAgents(), "getAgents"), getState: /* @__PURE__ */ __name(($) => {
      let q = this.getAgent($);
      if (!q) return;
      let K = q;
      if (K.stateCache && K.stateCache.size > 0) {
        let P = Array.from(K.stateCache.values());
        return P[P.length - 1];
      }
      return;
    }, "getState") };
  }
  enableEditableMode() {
    this.editableMode = true, this.dispatchEvent(new CustomEvent("mode:editable", { detail: { editable: true } }));
  }
};
__name(_ct, "ct");
var ct = _ct;
var mt = `# Task: Resolve Entity Name
Message Sender: {{senderName}} (ID: {{senderId}})
Agent: {{agentName}} (ID: {{agentId}})

# Entities in Room:
{{#if entitiesInRoom}}
{{entitiesInRoom}}
{{/if}}

{{recentMessages}}

# Instructions:
1. Analyze the context to identify which entity is being referenced
2. Consider special references like "me" (the message sender) or "you" (agent the message is directed to)
3. Look for usernames/handles in standard formats (e.g. @username, user#1234)
4. Consider context from recent messages for pronouns and references
5. If multiple matches exist, use context to disambiguate
6. Consider recent interactions and relationship strength when resolving ambiguity

Do NOT include any thinking, reasoning, or <think> sections in your response. 
Go directly to the XML response format without any preamble or explanation.

Return an XML response with:
<response>
  <entityId>exact-id-if-known-otherwise-null</entityId>
  <type>EXACT_MATCH | USERNAME_MATCH | NAME_MATCH | RELATIONSHIP_MATCH | AMBIGUOUS | UNKNOWN</type>
  <matches>
    <match>
      <name>matched-name</name>
      <reason>why this entity matches</reason>
    </match>
  </matches>
</response>

IMPORTANT: Your response must ONLY contain the <response></response> XML block above. Do not include any text, thinking, or reasoning before or after this XML block. Start your response immediately with <response> and end with </response>.`;
async function dt($, q, K, P, _) {
  let Y = [], O = await $.getMemories({ tableName: "messages", roomId: P, count: 20 });
  for (let z of K) {
    let J = [], T = 0, X = O.filter((M) => M.entityId === q && M.content.inReplyTo === z.id || M.entityId === z.id && M.content.inReplyTo === q);
    J.push(...X);
    let f = _.find((M) => M.sourceEntityId === q && M.targetEntityId === z.id || M.targetEntityId === q && M.sourceEntityId === z.id);
    if (f?.metadata?.interactions) T = f.metadata.interactions;
    T += X.length;
    let V = [...new Set(J)];
    Y.push({ entity: z, interactions: V.slice(-5), count: Math.round(T) });
  }
  return Y.sort((z, J) => J.count - z.count);
}
__name(dt, "dt");
async function c5$($, q, K) {
  let P = K.data.room ?? await $.getRoom(q.roomId);
  if (!P) return j6.warn("Room not found for entity search"), null;
  let _ = P.worldId ? await $.getWorld(P.worldId) : null, Y = await $.getEntitiesForRoom(P.id, true), O = await Promise.all(Y.map(async (E) => {
    if (!E.components) return E;
    let h = _?.metadata?.roles || {};
    return E.components = E.components.filter((I) => {
      if (I.sourceEntityId === q.entityId) return true;
      if (_ && I.sourceEntityId) {
        let D = h[I.sourceEntityId];
        if (D === "OWNER" || D === "ADMIN") return true;
      }
      if (I.sourceEntityId === $.agentId) return true;
      return false;
    }), E;
  })), z = await $.getRelationships({ entityId: q.entityId }), J = await Promise.all(z.map(async (E) => {
    let h = E.sourceEntityId === q.entityId ? E.targetEntityId : E.sourceEntityId;
    return $.getEntityById(h);
  })), T = [...O, ...J.filter((E) => E !== null)], X = await dt($, q.entityId, T, P.id, z), f = JM({ state: { roomName: P.name || P.id, worldName: _?.name || "Unknown", entitiesInRoom: JSON.stringify(O, null, 2), entityId: q.entityId, senderId: q.entityId }, template: mt }), V = await $.useModel(M6.TEXT_SMALL, { prompt: f, stopSequences: [] }), M = P_(V);
  if (!M) return j6.warn("Failed to parse entity resolution result"), null;
  if (M.type === "EXACT_MATCH" && M.entityId) {
    let E = await $.getEntityById(M.entityId);
    if (E) {
      if (E.components) {
        let h = _?.metadata?.roles || {};
        E.components = E.components.filter((I) => {
          if (I.sourceEntityId === q.entityId) return true;
          if (_ && I.sourceEntityId) {
            let D = h[I.sourceEntityId];
            if (D === "OWNER" || D === "ADMIN") return true;
          }
          if (I.sourceEntityId === $.agentId) return true;
          return false;
        });
      }
      return E;
    }
  }
  let N = [];
  if (M.matches?.match) N = Array.isArray(M.matches.match) ? M.matches.match : [M.matches.match];
  if (N.length > 0 && N[0]?.name) {
    let E = N[0].name.toLowerCase(), h = T.find((I) => {
      if (I.names.some((D) => D.toLowerCase() === E)) return true;
      return I.components?.some((D) => D.data.username?.toLowerCase() === E || D.data.handle?.toLowerCase() === E);
    });
    if (h) if (M.type === "RELATIONSHIP_MATCH") {
      let I = X.find((D) => D.entity.id === h.id);
      if (I && I.count > 0) return h;
    } else return h;
  }
  return null;
}
__name(c5$, "c5$");
var _K = /* @__PURE__ */ __name(($, q) => {
  if (q === $.agentId) return $.agentId;
  let K = `${q}:${$.agentId}`;
  return hO(K);
}, "_K");
async function m5$({ runtime: $, roomId: q }) {
  let [K, P] = await Promise.all([$.getRoom(q), $.getEntitiesForRoom(q, true)]), _ = /* @__PURE__ */ new Map();
  for (let Y of P) {
    if (_.has(Y.id)) continue;
    let O = {};
    for (let J of Y.components || []) Object.assign(O, J.data);
    let z = {};
    for (let [J, T] of Object.entries(O)) {
      if (!z[J]) {
        z[J] = T;
        continue;
      }
      if (Array.isArray(z[J]) && Array.isArray(T)) z[J] = [.../* @__PURE__ */ new Set([...z[J], ...T])];
      else if (typeof z[J] === "object" && typeof T === "object") z[J] = { ...z[J], ...T };
    }
    _.set(Y.id, { id: Y.id, name: K?.source ? Y.metadata[K.source]?.name || Y.names[0] : Y.names[0], names: Y.names, data: JSON.stringify({ ...z, ...Y.metadata }) });
  }
  return Array.from(_.values());
}
__name(m5$, "m5$");
function d5$({ entities: $ }) {
  return $.map((K) => {
    return `"${K.names.join('" aka "')}"
ID: ${K.id}${K.metadata && Object.keys(K.metadata).length > 0 ? `
Data: ${JSON.stringify(K.metadata)}
` : `
`}`;
  }).join(`
`);
}
__name(d5$, "d5$");
var r5$ = true;
var o5$ = false;
var n5$ = { check: /* @__PURE__ */ __name(async () => ({ status: "not-applicable", environment: "browser" }), "check"), isHealthy: /* @__PURE__ */ __name(() => true, "isHealthy") };
export {
  uJ as AgentRuntime,
  BM as AgentStatus,
  yJ as BM25,
  O_ as BufferUtils,
  _P as ChannelType,
  KP as ContentType,
  Ht as DatabaseAdapter,
  gJ as DefaultMessageService,
  ct as ElizaOS,
  g0 as Environment,
  gO as EventType,
  PP as MODEL_SETTINGS,
  iM as MemoryType,
  M6 as ModelType,
  UM as PlatformPrefix,
  tM as Role,
  QM as SOCKET_MESSAGE_TYPE,
  St as Semaphore,
  LO as Service,
  xM as ServiceBuilder,
  tt as ServiceType,
  FM as TEEMode,
  aM as TeeType,
  Qt as VECTOR_DIMS,
  x1$ as __loggerTestHooks,
  a1$ as addHeader,
  _t as alloc,
  W1 as asUUID,
  I9$ as booleanFooter,
  vt as byteLength,
  ei as characterSchema,
  f5$ as clearSaltCache,
  T9$ as composeActionExamples,
  JM as composePrompt,
  j1 as composePromptFromState,
  Ot as concat,
  ni as contentSchema,
  Y1 as createLogger,
  A9$ as createMessageMemory,
  Lt as createService,
  Ut as createServiceError,
  ht as createSettingFromConfig,
  _K as createUniqueUuid,
  cP$ as currentRuntime,
  m1$ as customLevels,
  bM as decryptObjectValues,
  EO as decryptSecret,
  EO as decryptStringValue,
  G5$ as decryptedCharacter,
  M5$ as defineService,
  r4 as detectEnvironment,
  ti as directoryItemSchema,
  d1$ as elizaLogger,
  gM as encryptObjectValues,
  yM as encryptStringValue,
  k5$ as encryptedCharacter,
  jt as equals,
  c5$ as findEntityByName,
  Hi as findEnvFile,
  y9$ as findWorldsForOwner,
  w9$ as formatActionNames,
  f9$ as formatActions,
  d5$ as formatEntities,
  e1$ as formatMessages,
  Q1$ as formatPosts,
  wM as formatTimestamp,
  Pt as fromBytes,
  si as fromHex,
  $t as fromString,
  xP$ as getBooleanEnv,
  _9$ as getContentTypeFromMimeType,
  m5$ as getEntityDetails,
  __ as getEnv,
  o4 as getEnvironment,
  AM as getLocalServerUrl,
  h9$ as getMemoryText,
  b0 as getNumberEnv,
  c_ as getSalt,
  Bt as getTypedService,
  b9$ as getUserServerRole,
  X5$ as getWorldSettings,
  uP$ as hasEnv,
  NM as imageDescriptionTemplate,
  pP$ as initBrowserEnvironment,
  A5$ as initializeOnboarding,
  r5$ as isBrowser,
  Kt as isBuffer,
  M9$ as isCustomMetadata,
  S9$ as isDescriptionMetadata,
  N9$ as isDocumentMemory,
  k9$ as isDocumentMetadata,
  C9$ as isFragmentMemory,
  G9$ as isFragmentMetadata,
  V9$ as isMessageMetadata,
  o5$ as isNode,
  z9$ as isValidCharacter,
  Bi as knowledgeItemSchema,
  mP$ as loadEnvFile,
  j6 as logger,
  oi as mediaSchema,
  ii as messageExampleSchema,
  MM as messageHandlerTemplate,
  CM as multiStepDecisionTemplate,
  hM as multiStepSummaryTemplate,
  WM as normalizeJsonString,
  v9$ as parseAndValidateCharacter,
  CO as parseBooleanFromText,
  s1$ as parseJSONObjectFromText,
  P_ as parseKeyValueXml,
  R9$ as postCreationTemplate,
  K9$ as prewarmUuidCache,
  zt as randomBytes,
  l1$ as recentLogs,
  EJ as safeReplacer,
  Rt as saltSettingValue,
  Dt as saltWorldSettings,
  Qi as secretsSchema,
  n5$ as serverHealth,
  yP$ as setEnv,
  ai as settingsSchema,
  SM as shouldRespondTemplate,
  Yt as slice,
  $9$ as splitChunks,
  hO as stringToUuid,
  Fi as styleSchema,
  Ui as templateTypeSchema,
  VM as toHex,
  qt as toString,
  q9$ as trimTokens,
  fM as truncateToCompleteSentence,
  It as unsaltSettingValue,
  uM as unsaltWorldSettings,
  Z5$ as updateWorldSettings,
  kM as uuidSchema,
  GM as validateCharacter,
  mi as validateUuid
};
//# sourceMappingURL=@elizaos_core.js.map
