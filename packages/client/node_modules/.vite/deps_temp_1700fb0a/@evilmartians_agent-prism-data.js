import "./chunk-7DHSKRL2.js";

// ../../node_modules/@evilmartians/agent-prism-data/src/common/get-duration-ms.ts
var getDurationMs = (spanCard) => {
  const startMs = +spanCard.startTime;
  const endMs = +spanCard.endTime;
  return endMs - startMs;
};

// ../../node_modules/@evilmartians/agent-prism-data/src/common/format-duration.ts
var formatDuration = (durationMs) => {
  if (durationMs < 1e3) return `${Math.round(durationMs)}ms`;
  if (durationMs < 6e4) return `${Math.round(durationMs / 1e3)}s`;
  if (durationMs < 36e5) {
    const m2 = Math.floor(durationMs / 6e4);
    const s = Math.floor(durationMs % 6e4 / 1e3);
    return s > 0 ? `${m2}m ${s}s` : `${m2}m`;
  }
  const h = Math.floor(durationMs / 36e5);
  const m = Math.floor(durationMs % 36e5 / 6e4);
  return m > 0 ? `${h}h ${m}m` : `${h}h`;
};

// ../../node_modules/@evilmartians/agent-prism-data/src/common/get-timeline-data.ts
var getTimelineData = ({
  spanCard,
  minStart,
  maxEnd
}) => {
  const startMs = +spanCard.startTime;
  const totalRange = maxEnd - minStart;
  const durationMs = getDurationMs(spanCard);
  const startPercent = (startMs - minStart) / totalRange * 100;
  const widthPercent = durationMs / totalRange * 100;
  return {
    durationMs,
    startPercent,
    widthPercent
  };
};

// ../../node_modules/@evilmartians/agent-prism-data/src/common/flatten-spans.ts
var flattenSpans = (spans) => {
  const result = [];
  const traverse = (items) => {
    items.forEach((item) => {
      var _a;
      result.push(item);
      if ((_a = item.children) == null ? void 0 : _a.length) {
        traverse(item.children);
      }
    });
  };
  traverse(spans);
  return result;
};

// ../../node_modules/@evilmartians/agent-prism-data/src/common/find-time-range.ts
function findTimeRange(cards) {
  return cards.reduce(
    (acc, c) => {
      const start = +new Date(c.startTime);
      const end = +new Date(c.endTime);
      return {
        minStart: Math.min(acc.minStart, start),
        maxEnd: Math.max(acc.maxEnd, end)
      };
    },
    {
      minStart: cards.length > 0 ? +new Date(cards[0].startTime) : Infinity,
      maxEnd: cards.length > 0 ? +new Date(cards[0].endTime) : -Infinity
    }
  );
}

// ../../node_modules/@evilmartians/agent-prism-types/src/constants/span-mappings.ts
var OPENTELEMETRY_GENAI_ATTRIBUTES = {
  OPERATION_NAME: "gen_ai.operation.name",
  SYSTEM: "gen_ai.system",
  MODEL: "gen_ai.request.model",
  AGENT_NAME: "gen_ai.agent.name",
  TOOL_NAME: "gen_ai.tool.name",
  // Usage and cost attributes
  USAGE_INPUT_TOKENS: "gen_ai.usage.input_tokens",
  USAGE_OUTPUT_TOKENS: "gen_ai.usage.output_tokens",
  USAGE_TOTAL_TOKENS: "gen_ai.usage.total_tokens",
  USAGE_COST: "gen_ai.usage.cost",
  USAGE_INPUT_COST: "gen_ai.usage.input_cost",
  USAGE_OUTPUT_COST: "gen_ai.usage.output_cost",
  // Request attributes
  REQUEST_TEMPERATURE: "gen_ai.request.temperature",
  REQUEST_PROMPT: "gen_ai.request.prompt",
  // Response attributes
  RESPONSE_TEXT: "gen_ai.response.text"
};
var OPENINFERENCE_ATTRIBUTES = {
  SPAN_KIND: "openinference.span.kind",
  LLM_MODEL: "llm.model_name",
  INPUT_MESSAGES: "llm.input_messages",
  RETRIEVAL_DOCUMENTS: "retrieval.documents",
  EMBEDDING_MODEL: "embedding.model_name"
};
var STANDARD_OPENTELEMETRY_ATTRIBUTES = {
  HTTP_METHOD: "http.method",
  HTTP_URL: "http.url",
  DB_SYSTEM: "db.system",
  DB_OPERATION: "db.operation.name",
  DB_COLLECTION: "db.collection.name",
  DB_QUERY_TEXT: "db.query.text",
  FUNCTION_NAME: "function.name"
};
var OPENTELEMETRY_GENAI_MAPPINGS = {
  // LLM operations
  chat: "llm_call",
  generate_content: "llm_call",
  text_completion: "llm_call",
  // Tool operations
  execute_tool: "tool_execution",
  // Agent operations
  invoke_agent: "agent_invocation",
  create_agent: "create_agent",
  // Embedding operations
  embeddings: "embedding"
};
var OPENINFERENCE_MAPPINGS = {
  LLM: "llm_call",
  TOOL: "tool_execution",
  CHAIN: "chain_operation",
  AGENT: "agent_invocation",
  RETRIEVER: "retrieval",
  EMBEDDING: "embedding"
};
var STANDARD_OPENTELEMETRY_PATTERNS = {
  HTTP_KEYWORDS: [],
  DATABASE_KEYWORDS: [],
  FUNCTION_KEYWORDS: ["tool", "function"],
  LLM_KEYWORDS: ["openai", "anthropic", "gpt", "claude"],
  CHAIN_KEYWORDS: ["chain", "workflow", "langchain"],
  AGENT_KEYWORDS: ["agent"],
  RETRIEVAL_KEYWORDS: ["pinecone", "chroma", "retrieval", "vector", "search"]
};
var INPUT_OUTPUT_ATTRIBUTES = {
  INPUT_VALUE: "input.value",
  OUTPUT_VALUE: "output.value"
};

// ../../node_modules/@evilmartians/agent-prism-data/src/open-telemetry/utils/get-open-telemetry-attribute-value.ts
function getOpenTelemetryAttributeValue(span, key) {
  const attr = span.attributes.find((a) => a.key === key);
  if (!attr) {
    return void 0;
  }
  const { value } = attr;
  if (value.stringValue !== void 0) {
    return value.stringValue;
  }
  if (value.intValue !== void 0) {
    return parseFloat(value.intValue);
  }
  if (value.boolValue !== void 0) {
    return value.boolValue;
  }
  return void 0;
}

// ../../node_modules/@evilmartians/agent-prism-data/src/open-telemetry/utils/categorize-open-inference.ts
function categorizeOpenInference(span) {
  const spanKind = getOpenTelemetryAttributeValue(
    span,
    OPENINFERENCE_ATTRIBUTES.SPAN_KIND
  );
  if (typeof spanKind === "string") {
    const category = OPENINFERENCE_MAPPINGS[spanKind];
    if (category) return category;
  }
  return "unknown";
}

// ../../node_modules/@evilmartians/agent-prism-data/src/open-telemetry/utils/categorize-open-telemetry-gen-ai.ts
function categorizeOpenTelemetryGenAI(span) {
  const operationName = getOpenTelemetryAttributeValue(
    span,
    OPENTELEMETRY_GENAI_ATTRIBUTES.OPERATION_NAME
  );
  if (typeof operationName === "string") {
    const category = OPENTELEMETRY_GENAI_MAPPINGS[operationName];
    if (category) return category;
  }
  return "unknown";
}

// ../../node_modules/@evilmartians/agent-prism-data/src/open-telemetry/utils/open-telemetry-category-mappers.ts
var openTelemetryCategoryMappers = {
  isHttpCall: (span) => {
    return getOpenTelemetryAttributeValue(
      span,
      STANDARD_OPENTELEMETRY_ATTRIBUTES.HTTP_METHOD
    ) !== void 0;
  },
  isDatabaseCall: (span) => {
    return getOpenTelemetryAttributeValue(
      span,
      STANDARD_OPENTELEMETRY_ATTRIBUTES.DB_SYSTEM
    ) !== void 0;
  },
  isFunctionCall: (span) => {
    const name = span.name.toLowerCase();
    return STANDARD_OPENTELEMETRY_PATTERNS.FUNCTION_KEYWORDS.some(
      (keyword) => name.includes(keyword)
    ) || getOpenTelemetryAttributeValue(
      span,
      STANDARD_OPENTELEMETRY_ATTRIBUTES.FUNCTION_NAME
    ) !== void 0;
  },
  isLLMCall: (span) => {
    const name = span.name.toLowerCase();
    return STANDARD_OPENTELEMETRY_PATTERNS.LLM_KEYWORDS.some(
      (keyword) => name.includes(keyword)
    );
  },
  isChainOperation: (span) => {
    const name = span.name.toLowerCase();
    return STANDARD_OPENTELEMETRY_PATTERNS.CHAIN_KEYWORDS.some(
      (keyword) => name.includes(keyword)
    );
  },
  isAgentOperation: (span) => {
    const name = span.name.toLowerCase();
    return STANDARD_OPENTELEMETRY_PATTERNS.AGENT_KEYWORDS.some(
      (keyword) => name.includes(keyword)
    );
  },
  isRetrievalOperation: (span) => {
    const name = span.name.toLowerCase();
    return STANDARD_OPENTELEMETRY_PATTERNS.RETRIEVAL_KEYWORDS.some(
      (keyword) => name.includes(keyword)
    );
  }
};

// ../../node_modules/@evilmartians/agent-prism-data/src/open-telemetry/utils/categorize-standard-open-telemetry.ts
function categorizeStandardOpenTelemetry(span) {
  if (openTelemetryCategoryMappers.isLLMCall(span)) return "llm_call";
  if (openTelemetryCategoryMappers.isAgentOperation(span))
    return "agent_invocation";
  if (openTelemetryCategoryMappers.isChainOperation(span))
    return "chain_operation";
  if (openTelemetryCategoryMappers.isRetrievalOperation(span))
    return "retrieval";
  if (openTelemetryCategoryMappers.isFunctionCall(span))
    return "tool_execution";
  if (openTelemetryCategoryMappers.isHttpCall(span)) return "tool_execution";
  if (openTelemetryCategoryMappers.isDatabaseCall(span))
    return "tool_execution";
  return "unknown";
}

// ../../node_modules/@evilmartians/agent-prism-data/src/open-telemetry/utils/convert-nano-timestamp-to-date.ts
function convertNanoTimestampToDate(nanoString) {
  const nanoseconds = BigInt(nanoString);
  const milliseconds = Number(nanoseconds / 1000000n);
  return new Date(milliseconds);
}

// ../../node_modules/@evilmartians/agent-prism-data/src/open-telemetry/utils/generate-open-telemetry-span-title.ts
function generateOpenTelemetrySpanTitle(span) {
  const { name } = span;
  const model = getOpenTelemetryAttributeValue(
    span,
    OPENTELEMETRY_GENAI_ATTRIBUTES.MODEL
  );
  if (model) {
    return `${model} - ${name}`;
  }
  const collection = getOpenTelemetryAttributeValue(
    span,
    STANDARD_OPENTELEMETRY_ATTRIBUTES.DB_COLLECTION
  );
  const operation = getOpenTelemetryAttributeValue(
    span,
    STANDARD_OPENTELEMETRY_ATTRIBUTES.DB_OPERATION
  );
  if (collection && operation) {
    return `${collection} - ${operation}`;
  }
  const method = getOpenTelemetryAttributeValue(
    span,
    STANDARD_OPENTELEMETRY_ATTRIBUTES.HTTP_METHOD
  );
  const url = getOpenTelemetryAttributeValue(
    span,
    STANDARD_OPENTELEMETRY_ATTRIBUTES.HTTP_URL
  );
  if (method && url) {
    return `${method} ${url}`;
  }
  return name;
}

// ../../node_modules/@evilmartians/agent-prism-data/src/open-telemetry/utils/get-open-telemetry-span-standard.ts
function getOpenTelemetrySpanStandard(span) {
  if (getOpenTelemetryAttributeValue(
    span,
    OPENTELEMETRY_GENAI_ATTRIBUTES.OPERATION_NAME
  ) || getOpenTelemetryAttributeValue(span, OPENTELEMETRY_GENAI_ATTRIBUTES.SYSTEM)) {
    return "opentelemetry_genai";
  }
  if (getOpenTelemetryAttributeValue(span, OPENINFERENCE_ATTRIBUTES.SPAN_KIND) || getOpenTelemetryAttributeValue(span, OPENINFERENCE_ATTRIBUTES.LLM_MODEL)) {
    return "openinference";
  }
  return "standard";
}

// ../../node_modules/@evilmartians/agent-prism-data/src/open-telemetry/adapter.ts
var openTelemetrySpanAdapter = {
  convertRawDocumentsToSpans(documents) {
    const docArray = Array.isArray(documents) ? documents : [documents];
    const allSpans = [];
    docArray.forEach((document) => {
      document.resourceSpans.forEach((resourceSpan) => {
        resourceSpan.scopeSpans.forEach((scopeSpan) => {
          allSpans.push(...scopeSpan.spans);
        });
      });
    });
    return this.convertRawSpansToSpanTree(allSpans);
  },
  convertRawSpansToSpanTree(spans) {
    const spanMap = /* @__PURE__ */ new Map();
    const rootSpans = [];
    spans.forEach((span) => {
      const convertedSpan = this.convertRawSpanToTraceSpan(span);
      spanMap.set(convertedSpan.id, convertedSpan);
    });
    spans.forEach((span) => {
      const convertedSpan = spanMap.get(span.spanId);
      const parentSpanId = span.parentSpanId;
      if (parentSpanId) {
        const parent = spanMap.get(parentSpanId);
        if (parent) {
          if (!parent.children) {
            parent.children = [];
          }
          parent.children.push(convertedSpan);
        }
      } else {
        rootSpans.push(convertedSpan);
      }
    });
    return rootSpans;
  },
  convertRawSpanToTraceSpan(span, children = []) {
    const duration = this.getSpanDuration(span);
    const status = this.getSpanStatus(span);
    const type = this.getSpanCategory(span);
    const tokensCount = this.getSpanTokensCount(span);
    const cost = this.getSpanCost(span);
    const ioData = this.getSpanInputOutput(span);
    const title = generateOpenTelemetrySpanTitle(span);
    return {
      id: span.spanId,
      title,
      type,
      status,
      attributes: span.attributes,
      duration,
      tokensCount,
      raw: JSON.stringify(span, null, 2),
      cost,
      startTime: convertNanoTimestampToDate(span.startTimeUnixNano),
      endTime: convertNanoTimestampToDate(span.endTimeUnixNano),
      children,
      input: ioData.input,
      output: ioData.output
    };
  },
  getSpanDuration(span) {
    const startNano = BigInt(span.startTimeUnixNano);
    const endNano = BigInt(span.endTimeUnixNano);
    const durationNano = endNano - startNano;
    return Number(durationNano / BigInt(1e6));
  },
  getSpanCost(span) {
    const inputCost = getOpenTelemetryAttributeValue(
      span,
      OPENTELEMETRY_GENAI_ATTRIBUTES.USAGE_INPUT_COST
    );
    const outputCost = getOpenTelemetryAttributeValue(
      span,
      OPENTELEMETRY_GENAI_ATTRIBUTES.USAGE_OUTPUT_COST
    );
    let totalCost = 0;
    if (typeof inputCost === "number") {
      totalCost += inputCost;
    }
    if (typeof outputCost === "number") {
      totalCost += outputCost;
    }
    if (totalCost === 0) {
      const fallbackCost = getOpenTelemetryAttributeValue(
        span,
        "gen_ai.usage.cost"
      );
      if (typeof fallbackCost === "number") {
        totalCost = fallbackCost;
      }
    }
    return totalCost;
  },
  getSpanTokensCount(span) {
    const totalTokens = getOpenTelemetryAttributeValue(
      span,
      OPENTELEMETRY_GENAI_ATTRIBUTES.USAGE_TOTAL_TOKENS
    );
    const inputTokens = getOpenTelemetryAttributeValue(
      span,
      OPENTELEMETRY_GENAI_ATTRIBUTES.USAGE_INPUT_TOKENS
    );
    const outputTokens = getOpenTelemetryAttributeValue(
      span,
      OPENTELEMETRY_GENAI_ATTRIBUTES.USAGE_OUTPUT_TOKENS
    );
    if (typeof totalTokens === "number") {
      return totalTokens;
    }
    const input = typeof inputTokens === "number" ? inputTokens : 0;
    const output = typeof outputTokens === "number" ? outputTokens : 0;
    return input + output;
  },
  getSpanInputOutput(span) {
    const input = getOpenTelemetryAttributeValue(
      span,
      INPUT_OUTPUT_ATTRIBUTES.INPUT_VALUE
    );
    const output = getOpenTelemetryAttributeValue(
      span,
      INPUT_OUTPUT_ATTRIBUTES.OUTPUT_VALUE
    );
    return {
      input: typeof input === "string" ? input : void 0,
      output: typeof output === "string" ? output : void 0
    };
  },
  getSpanStatus(span) {
    switch (span.status.code) {
      case "STATUS_CODE_OK":
        return "success";
      case "STATUS_CODE_ERROR":
        return "error";
      default:
        return "warning";
    }
  },
  getSpanCategory(span) {
    const standard = getOpenTelemetrySpanStandard(span);
    switch (standard) {
      case "opentelemetry_genai": {
        const category = categorizeOpenTelemetryGenAI(span);
        return category !== "unknown" ? category : categorizeStandardOpenTelemetry(span);
      }
      case "openinference": {
        const category = categorizeOpenInference(span);
        return category !== "unknown" ? category : categorizeStandardOpenTelemetry(span);
      }
      case "standard":
      default: {
        return categorizeStandardOpenTelemetry(span);
      }
    }
  }
};

// ../../node_modules/@evilmartians/agent-prism-data/src/langfuse/adapter.ts
var langfuseSpanAdapter = {
  convertRawDocumentsToSpans(documents) {
    const docArray = Array.isArray(documents) ? documents : [documents];
    const allObservations = [];
    docArray.forEach((document) => {
      document.observations.forEach((observation) => {
        allObservations.push(observation);
      });
    });
    return this.convertRawSpansToSpanTree(allObservations);
  },
  convertRawSpansToSpanTree(spans) {
    const spanMap = /* @__PURE__ */ new Map();
    const rootSpans = [];
    spans.forEach((span) => {
      const convertedSpan = this.convertRawSpanToTraceSpan(span);
      spanMap.set(convertedSpan.id, convertedSpan);
    });
    spans.forEach((span) => {
      const convertedSpan = spanMap.get(span.id);
      const parentSpanId = span.parentObservationId;
      if (parentSpanId) {
        const parent = spanMap.get(parentSpanId);
        if (parent) {
          if (!parent.children) {
            parent.children = [];
          }
          parent.children.push(convertedSpan);
        }
      } else {
        rootSpans.push(convertedSpan);
      }
    });
    return rootSpans;
  },
  convertRawSpanToTraceSpan(span, children = []) {
    const duration = this.getSpanDuration(span);
    const status = this.getSpanStatus(span);
    const tokensCount = this.getSpanTokensCount(span);
    const cost = this.getSpanCost(span);
    const ioData = this.getSpanInputOutput(span);
    const type = this.getSpanCategory(span);
    return {
      id: span.id,
      title: span.name,
      type,
      status,
      duration,
      tokensCount,
      raw: JSON.stringify(span, null, 2),
      cost,
      startTime: new Date(span.startTime),
      endTime: new Date(span.endTime),
      children,
      input: ioData.input,
      output: ioData.output
    };
  },
  getSpanDuration(span) {
    if (!span.endTime || !span.startTime) {
      return 0;
    }
    try {
      return new Date(span.endTime).getTime() - new Date(span.startTime).getTime();
    } catch {
      return 0;
    }
  },
  getSpanCost(span) {
    var _a;
    return ((_a = span.costDetails) == null ? void 0 : _a.total) || 0;
  },
  getSpanTokensCount(span) {
    var _a;
    return ((_a = span.usageDetails) == null ? void 0 : _a.total) || 0;
  },
  getSpanInputOutput(span) {
    return {
      input: typeof span.input === "string" ? span.input : void 0,
      output: typeof span.output === "string" ? span.output : void 0
    };
  },
  getSpanStatus() {
    return "success";
  },
  getSpanCategory(span) {
    switch (span.type) {
      case "SPAN":
        return "span";
      case "TOOL":
        return "tool_execution";
      case "GENERATION":
        return "llm_call";
      case "EVENT":
        return "event";
      case "AGENT":
        return "agent_invocation";
      case "CHAIN":
        return "chain_operation";
      case "RETRIEVER":
        return "retrieval";
      case "EMBEDDING":
        return "embedding";
      case "GUARDRAIL":
        return "guardrail";
      case "UNKNOWN":
        return "unknown";
      default:
        return "unknown";
    }
  }
};
export {
  findTimeRange,
  flattenSpans,
  formatDuration,
  getDurationMs,
  getTimelineData,
  langfuseSpanAdapter,
  openTelemetrySpanAdapter
};
//# sourceMappingURL=@evilmartians_agent-prism-data.js.map
