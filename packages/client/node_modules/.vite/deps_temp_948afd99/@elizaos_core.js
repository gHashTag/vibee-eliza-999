import {
  __privateAdd,
  __privateGet,
  __privateSet,
  __publicField,
  __require
} from "./chunk-7DHSKRL2.js";

// ../core/dist/browser/index.browser.js
var uM = Object.create;
var { getPrototypeOf: xM, defineProperty: s4, getOwnPropertyNames: cJ, getOwnPropertyDescriptor: pM } = Object;
var mJ = Object.prototype.hasOwnProperty;
var q8 = ($18, q, K) => {
  K = $18 != null ? uM(xM($18)) : {};
  let P = q || !$18 || !$18.__esModule ? s4(K, "default", { value: $18, enumerable: true }) : K;
  for (let _ of cJ($18)) if (!mJ.call(P, _)) s4(P, _, { get: () => $18[_], enumerable: true });
  return P;
};
var pJ = /* @__PURE__ */ new WeakMap();
var J6 = ($18) => {
  var q = pJ.get($18), K;
  if (q) return q;
  if (q = s4({}, "__esModule", { value: true }), $18 && typeof $18 === "object" || typeof $18 === "function") cJ($18).map((P) => !mJ.call(q, P) && s4(q, P, { get: () => $18[P], enumerable: !(K = pM($18, P)) || K.enumerable }));
  return pJ.set($18, q), q;
};
var x$ = ($18, q) => () => (q || $18((q = { exports: {} }).exports, q), q.exports);
var lq = ($18, q) => {
  for (var K in q) s4($18, K, { get: q[K], enumerable: true, configurable: true, set: (P) => q[K] = () => P });
};
var p_ = ($18, q) => () => ($18 && (q = $18($18 = 0)), q);
var $P = (($18) => typeof __require < "u" ? __require : typeof Proxy < "u" ? new Proxy($18, { get: (q, K) => (typeof __require < "u" ? __require : q)[K] }) : $18)(function($18) {
  if (typeof __require < "u") return __require.apply(this, arguments);
  throw Error('Dynamic require of "' + $18 + '" is not supported');
});
var lJ = x$((oB, dJ) => {
  dJ.exports = function($18, q) {
    if (typeof $18 !== "string") throw TypeError("Expected a string");
    return q = typeof q > "u" ? "_" : q, $18.replace(/([a-z\d])([A-Z])/g, "$1" + q + "$2").replace(/([A-Z]+)([A-Z][a-z\d]+)/g, "$1" + q + "$2").toLowerCase();
  };
});
var UJ = x$((nB, DO) => {
  var BM = /[\p{Lu}]/u, tM = /[\p{Ll}]/u, rJ = /^[\p{Lu}](?![\p{Lu}])/gu, iJ = /([\p{Alpha}\p{N}_]|$)/u, BJ = /[_.\- ]+/, UM = new RegExp("^" + BJ.source), oJ = new RegExp(BJ.source + iJ.source, "gu"), nJ = new RegExp("\\d+" + iJ.source, "gu"), FM = ($18, q, K) => {
    let P = false, _ = false, Y = false;
    for (let O = 0; O < $18.length; O++) {
      let z = $18[O];
      if (P && BM.test(z)) $18 = $18.slice(0, O) + "-" + $18.slice(O), P = false, Y = _, _ = true, O++;
      else if (_ && Y && tM.test(z)) $18 = $18.slice(0, O - 1) + "-" + $18.slice(O - 1), Y = _, _ = false, P = true;
      else P = q(z) === z && K(z) !== z, Y = _, _ = K(z) === z && q(z) !== z;
    }
    return $18;
  }, aM = ($18, q) => {
    return rJ.lastIndex = 0, $18.replace(rJ, (K) => q(K));
  }, QM = ($18, q) => {
    return oJ.lastIndex = 0, nJ.lastIndex = 0, $18.replace(oJ, (K, P) => q(P)).replace(nJ, (K) => q(K));
  }, tJ = ($18, q) => {
    if (!(typeof $18 === "string" || Array.isArray($18))) throw TypeError("Expected the input to be `string | string[]`");
    if (q = { pascalCase: false, preserveConsecutiveUppercase: false, ...q }, Array.isArray($18)) $18 = $18.map((Y) => Y.trim()).filter((Y) => Y.length).join("-");
    else $18 = $18.trim();
    if ($18.length === 0) return "";
    let K = q.locale === false ? (Y) => Y.toLowerCase() : (Y) => Y.toLocaleLowerCase(q.locale), P = q.locale === false ? (Y) => Y.toUpperCase() : (Y) => Y.toLocaleUpperCase(q.locale);
    if ($18.length === 1) return q.pascalCase ? P($18) : K($18);
    if ($18 !== K($18)) $18 = FM($18, K, P);
    if ($18 = $18.replace(UM, ""), q.preserveConsecutiveUppercase) $18 = aM($18, K);
    else $18 = K($18);
    if (q.pascalCase) $18 = P($18.charAt(0)) + $18.slice(1);
    return QM($18, P);
  };
  DO.exports = tJ;
  DO.exports.default = tJ;
});
var Dw = x$((DF, Iw) => {
  function W8($18, q) {
    if (typeof q === "boolean") q = { forever: q };
    if (this._originalTimeouts = JSON.parse(JSON.stringify($18)), this._timeouts = $18, this._options = q || {}, this._maxRetryTime = q && q.maxRetryTime || 1 / 0, this._fn = null, this._errors = [], this._attempts = 1, this._operationTimeout = null, this._operationTimeoutCb = null, this._timeout = null, this._operationStart = null, this._timer = null, this._options.forever) this._cachedTimeouts = this._timeouts.slice(0);
  }
  Iw.exports = W8;
  W8.prototype.reset = function() {
    this._attempts = 1, this._timeouts = this._originalTimeouts.slice(0);
  };
  W8.prototype.stop = function() {
    if (this._timeout) clearTimeout(this._timeout);
    if (this._timer) clearTimeout(this._timer);
    this._timeouts = [], this._cachedTimeouts = null;
  };
  W8.prototype.retry = function($18) {
    if (this._timeout) clearTimeout(this._timeout);
    if (!$18) return false;
    var q = (/* @__PURE__ */ new Date()).getTime();
    if ($18 && q - this._operationStart >= this._maxRetryTime) return this._errors.push($18), this._errors.unshift(Error("RetryOperation timeout occurred")), false;
    this._errors.push($18);
    var K = this._timeouts.shift();
    if (K === void 0) if (this._cachedTimeouts) this._errors.splice(0, this._errors.length - 1), K = this._cachedTimeouts.slice(-1);
    else return false;
    var P = this;
    if (this._timer = setTimeout(function() {
      if (P._attempts++, P._operationTimeoutCb) {
        if (P._timeout = setTimeout(function() {
          P._operationTimeoutCb(P._attempts);
        }, P._operationTimeout), P._options.unref) P._timeout.unref();
      }
      P._fn(P._attempts);
    }, K), this._options.unref) this._timer.unref();
    return true;
  };
  W8.prototype.attempt = function($18, q) {
    if (this._fn = $18, q) {
      if (q.timeout) this._operationTimeout = q.timeout;
      if (q.cb) this._operationTimeoutCb = q.cb;
    }
    var K = this;
    if (this._operationTimeoutCb) this._timeout = setTimeout(function() {
      K._operationTimeoutCb();
    }, K._operationTimeout);
    this._operationStart = (/* @__PURE__ */ new Date()).getTime(), this._fn(this._attempts);
  };
  W8.prototype.try = function($18) {
    console.log("Using RetryOperation.try() is deprecated"), this.attempt($18);
  };
  W8.prototype.start = function($18) {
    console.log("Using RetryOperation.start() is deprecated"), this.attempt($18);
  };
  W8.prototype.start = W8.prototype.try;
  W8.prototype.errors = function() {
    return this._errors;
  };
  W8.prototype.attempts = function() {
    return this._attempts;
  };
  W8.prototype.mainError = function() {
    if (this._errors.length === 0) return null;
    var $18 = {}, q = null, K = 0;
    for (var P = 0; P < this._errors.length; P++) {
      var _ = this._errors[P], Y = _.message, O = ($18[Y] || 0) + 1;
      if ($18[Y] = O, O >= K) q = _, K = O;
    }
    return q;
  };
});
var gw = x$((UN) => {
  var tN = Dw();
  UN.operation = function($18) {
    var q = UN.timeouts($18);
    return new tN(q, { forever: $18 && ($18.forever || $18.retries === 1 / 0), unref: $18 && $18.unref, maxRetryTime: $18 && $18.maxRetryTime });
  };
  UN.timeouts = function($18) {
    if ($18 instanceof Array) return [].concat($18);
    var q = { retries: 10, factor: 2, minTimeout: 1e3, maxTimeout: 1 / 0, randomize: false };
    for (var K in $18) q[K] = $18[K];
    if (q.minTimeout > q.maxTimeout) throw Error("minTimeout is greater than maxTimeout");
    var P = [];
    for (var _ = 0; _ < q.retries; _++) P.push(this.createTimeout(_, q));
    if ($18 && $18.forever && !P.length) P.push(this.createTimeout(_, q));
    return P.sort(function(Y, O) {
      return Y - O;
    }), P;
  };
  UN.createTimeout = function($18, q) {
    var K = q.randomize ? Math.random() + 1 : 1, P = Math.round(K * Math.max(q.minTimeout, 1) * Math.pow(q.factor, $18));
    return P = Math.min(P, q.maxTimeout), P;
  };
  UN.wrap = function($18, q, K) {
    if (q instanceof Array) K = q, q = null;
    if (!K) {
      K = [];
      for (var P in $18) if (typeof $18[P] === "function") K.push(P);
    }
    for (var _ = 0; _ < K.length; _++) {
      var Y = K[_], O = $18[Y];
      $18[Y] = (function(J) {
        var T = UN.operation(q), X = Array.prototype.slice.call(arguments, 1), f = X.pop();
        X.push(function(V) {
          if (T.retry(V)) return;
          if (V) arguments[0] = T.mainError();
          f.apply(this, arguments);
        }), T.attempt(function() {
          J.apply($18, X);
        });
      }).bind($18, O), $18[Y].options = q;
    }
  };
});
var C1 = x$((gF, N1) => {
  var eN = gw(), sN = ["Failed to fetch", "NetworkError when attempting to fetch resource.", "The Internet connection appears to be offline.", "Network request failed"];
  class KY extends Error {
    constructor($18) {
      super();
      if ($18 instanceof Error) this.originalError = $18, { message: $18 } = $18;
      else this.originalError = Error($18), this.originalError.stack = this.stack;
      this.name = "AbortError", this.message = $18;
    }
  }
  var $C = ($18, q, K) => {
    let P = K.retries - (q - 1);
    return $18.attemptNumber = q, $18.retriesLeft = P, $18;
  }, qC = ($18) => sN.includes($18), bw = ($18, q) => new Promise((K, P) => {
    q = { onFailedAttempt: () => {
    }, retries: 10, ...q };
    let _ = eN.operation(q);
    _.attempt(async (Y) => {
      try {
        K(await $18(Y));
      } catch (O) {
        if (!(O instanceof Error)) {
          P(TypeError(`Non-error was thrown: "${O}". You should only throw errors.`));
          return;
        }
        if (O instanceof KY) _.stop(), P(O.originalError);
        else if (O instanceof TypeError && !qC(O.message)) _.stop(), P(O);
        else {
          $C(O, Y, q);
          try {
            await q.onFailedAttempt(O);
          } catch (z) {
            P(z);
            return;
          }
          if (!_.retry(O)) P(_.mainError());
        }
      }
    });
  });
  N1.exports = bw;
  N1.exports.default = bw;
  N1.exports.AbortError = KY;
});
var uw = x$((bF, _Y) => {
  var KC = Object.prototype.hasOwnProperty, Dq = "~";
  function WP() {
  }
  if (Object.create) {
    if (WP.prototype = /* @__PURE__ */ Object.create(null), !new WP().__proto__) Dq = false;
  }
  function _C($18, q, K) {
    this.fn = $18, this.context = q, this.once = K || false;
  }
  function yw($18, q, K, P, _) {
    if (typeof K !== "function") throw TypeError("The listener must be a function");
    var Y = new _C(K, P || $18, _), O = Dq ? Dq + q : q;
    if (!$18._events[O]) $18._events[O] = Y, $18._eventsCount++;
    else if (!$18._events[O].fn) $18._events[O].push(Y);
    else $18._events[O] = [$18._events[O], Y];
    return $18;
  }
  function E1($18, q) {
    if (--$18._eventsCount === 0) $18._events = new WP();
    else delete $18._events[q];
  }
  function Nq() {
    this._events = new WP(), this._eventsCount = 0;
  }
  Nq.prototype.eventNames = function() {
    var q = [], K, P;
    if (this._eventsCount === 0) return q;
    for (P in K = this._events) if (KC.call(K, P)) q.push(Dq ? P.slice(1) : P);
    if (Object.getOwnPropertySymbols) return q.concat(Object.getOwnPropertySymbols(K));
    return q;
  };
  Nq.prototype.listeners = function(q) {
    var K = Dq ? Dq + q : q, P = this._events[K];
    if (!P) return [];
    if (P.fn) return [P.fn];
    for (var _ = 0, Y = P.length, O = Array(Y); _ < Y; _++) O[_] = P[_].fn;
    return O;
  };
  Nq.prototype.listenerCount = function(q) {
    var K = Dq ? Dq + q : q, P = this._events[K];
    if (!P) return 0;
    if (P.fn) return 1;
    return P.length;
  };
  Nq.prototype.emit = function(q, K, P, _, Y, O) {
    var z = Dq ? Dq + q : q;
    if (!this._events[z]) return false;
    var J = this._events[z], T = arguments.length, X, f;
    if (J.fn) {
      if (J.once) this.removeListener(q, J.fn, void 0, true);
      switch (T) {
        case 1:
          return J.fn.call(J.context), true;
        case 2:
          return J.fn.call(J.context, K), true;
        case 3:
          return J.fn.call(J.context, K, P), true;
        case 4:
          return J.fn.call(J.context, K, P, _), true;
        case 5:
          return J.fn.call(J.context, K, P, _, Y), true;
        case 6:
          return J.fn.call(J.context, K, P, _, Y, O), true;
      }
      for (f = 1, X = Array(T - 1); f < T; f++) X[f - 1] = arguments[f];
      J.fn.apply(J.context, X);
    } else {
      var V = J.length, M;
      for (f = 0; f < V; f++) {
        if (J[f].once) this.removeListener(q, J[f].fn, void 0, true);
        switch (T) {
          case 1:
            J[f].fn.call(J[f].context);
            break;
          case 2:
            J[f].fn.call(J[f].context, K);
            break;
          case 3:
            J[f].fn.call(J[f].context, K, P);
            break;
          case 4:
            J[f].fn.call(J[f].context, K, P, _);
            break;
          default:
            if (!X) for (M = 1, X = Array(T - 1); M < T; M++) X[M - 1] = arguments[M];
            J[f].fn.apply(J[f].context, X);
        }
      }
    }
    return true;
  };
  Nq.prototype.on = function(q, K, P) {
    return yw(this, q, K, P, false);
  };
  Nq.prototype.once = function(q, K, P) {
    return yw(this, q, K, P, true);
  };
  Nq.prototype.removeListener = function(q, K, P, _) {
    var Y = Dq ? Dq + q : q;
    if (!this._events[Y]) return this;
    if (!K) return E1(this, Y), this;
    var O = this._events[Y];
    if (O.fn) {
      if (O.fn === K && (!_ || O.once) && (!P || O.context === P)) E1(this, Y);
    } else {
      for (var z = 0, J = [], T = O.length; z < T; z++) if (O[z].fn !== K || _ && !O[z].once || P && O[z].context !== P) J.push(O[z]);
      if (J.length) this._events[Y] = J.length === 1 ? J[0] : J;
      else E1(this, Y);
    }
    return this;
  };
  Nq.prototype.removeAllListeners = function(q) {
    var K;
    if (q) {
      if (K = Dq ? Dq + q : q, this._events[K]) E1(this, K);
    } else this._events = new WP(), this._eventsCount = 0;
    return this;
  };
  Nq.prototype.off = Nq.prototype.removeListener;
  Nq.prototype.addListener = Nq.prototype.on;
  Nq.prefixed = Dq;
  Nq.EventEmitter = Nq;
  if (typeof _Y < "u") _Y.exports = Nq;
});
var pw = x$((yF, xw) => {
  xw.exports = ($18, q) => {
    return q = q || (() => {
    }), $18.then((K) => new Promise((P) => {
      P(q());
    }).then(() => K), (K) => new Promise((P) => {
      P(q());
    }).then(() => {
      throw K;
    }));
  };
});
var mw = x$((uF, h1) => {
  var PC = pw();
  class PY extends Error {
    constructor($18) {
      super($18);
      this.name = "TimeoutError";
    }
  }
  var cw = ($18, q, K) => new Promise((P, _) => {
    if (typeof q !== "number" || q < 0) throw TypeError("Expected `milliseconds` to be a positive number");
    if (q === 1 / 0) {
      P($18);
      return;
    }
    let Y = setTimeout(() => {
      if (typeof K === "function") {
        try {
          P(K());
        } catch (J) {
          _(J);
        }
        return;
      }
      let O = typeof K === "string" ? K : `Promise timed out after ${q} milliseconds`, z = K instanceof Error ? K : new PY(O);
      if (typeof $18.cancel === "function") $18.cancel();
      _(z);
    }, q);
    PC($18.then(P, _), () => {
      clearTimeout(Y);
    });
  });
  h1.exports = cw;
  h1.exports.default = cw;
  h1.exports.TimeoutError = PY;
});
var lw = x$((dw) => {
  Object.defineProperty(dw, "__esModule", { value: true });
  function OC($18, q, K) {
    let P = 0, _ = $18.length;
    while (_ > 0) {
      let Y = _ / 2 | 0, O = P + Y;
      if (K($18[O], q) <= 0) P = ++O, _ -= Y + 1;
      else _ = Y;
    }
    return P;
  }
  dw.default = OC;
});
var nw = x$((ow) => {
  Object.defineProperty(ow, "__esModule", { value: true });
  var jC = lw();
  class rw {
    constructor() {
      this._queue = [];
    }
    enqueue($18, q) {
      q = Object.assign({ priority: 0 }, q);
      let K = { priority: q.priority, run: $18 };
      if (this.size && this._queue[this.size - 1].priority >= q.priority) {
        this._queue.push(K);
        return;
      }
      let P = jC.default(this._queue, K, (_, Y) => Y.priority - _.priority);
      this._queue.splice(P, 0, K);
    }
    dequeue() {
      let $18 = this._queue.shift();
      return $18 === null || $18 === void 0 ? void 0 : $18.run;
    }
    filter($18) {
      return this._queue.filter((q) => q.priority === $18.priority).map((q) => q.run);
    }
    get size() {
      return this._queue.length;
    }
  }
  ow.default = rw;
});
var I1 = x$((tw) => {
  Object.defineProperty(tw, "__esModule", { value: true });
  var zC = uw(), iw = mw(), WC = nw(), R1 = () => {
  }, HC = new iw.TimeoutError();
  class Bw extends zC {
    constructor($18) {
      var q, K, P, _;
      super();
      if (this._intervalCount = 0, this._intervalEnd = 0, this._pendingCount = 0, this._resolveEmpty = R1, this._resolveIdle = R1, $18 = Object.assign({ carryoverConcurrencyCount: false, intervalCap: 1 / 0, interval: 0, concurrency: 1 / 0, autoStart: true, queueClass: WC.default }, $18), !(typeof $18.intervalCap === "number" && $18.intervalCap >= 1)) throw TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${(K = (q = $18.intervalCap) === null || q === void 0 ? void 0 : q.toString()) !== null && K !== void 0 ? K : ""}\` (${typeof $18.intervalCap})`);
      if ($18.interval === void 0 || !(Number.isFinite($18.interval) && $18.interval >= 0)) throw TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${(_ = (P = $18.interval) === null || P === void 0 ? void 0 : P.toString()) !== null && _ !== void 0 ? _ : ""}\` (${typeof $18.interval})`);
      this._carryoverConcurrencyCount = $18.carryoverConcurrencyCount, this._isIntervalIgnored = $18.intervalCap === 1 / 0 || $18.interval === 0, this._intervalCap = $18.intervalCap, this._interval = $18.interval, this._queue = new $18.queueClass(), this._queueClass = $18.queueClass, this.concurrency = $18.concurrency, this._timeout = $18.timeout, this._throwOnTimeout = $18.throwOnTimeout === true, this._isPaused = $18.autoStart === false;
    }
    get _doesIntervalAllowAnother() {
      return this._isIntervalIgnored || this._intervalCount < this._intervalCap;
    }
    get _doesConcurrentAllowAnother() {
      return this._pendingCount < this._concurrency;
    }
    _next() {
      this._pendingCount--, this._tryToStartAnother(), this.emit("next");
    }
    _resolvePromises() {
      if (this._resolveEmpty(), this._resolveEmpty = R1, this._pendingCount === 0) this._resolveIdle(), this._resolveIdle = R1, this.emit("idle");
    }
    _onResumeInterval() {
      this._onInterval(), this._initializeIntervalIfNeeded(), this._timeoutId = void 0;
    }
    _isIntervalPaused() {
      let $18 = Date.now();
      if (this._intervalId === void 0) {
        let q = this._intervalEnd - $18;
        if (q < 0) this._intervalCount = this._carryoverConcurrencyCount ? this._pendingCount : 0;
        else {
          if (this._timeoutId === void 0) this._timeoutId = setTimeout(() => {
            this._onResumeInterval();
          }, q);
          return true;
        }
      }
      return false;
    }
    _tryToStartAnother() {
      if (this._queue.size === 0) {
        if (this._intervalId) clearInterval(this._intervalId);
        return this._intervalId = void 0, this._resolvePromises(), false;
      }
      if (!this._isPaused) {
        let $18 = !this._isIntervalPaused();
        if (this._doesIntervalAllowAnother && this._doesConcurrentAllowAnother) {
          let q = this._queue.dequeue();
          if (!q) return false;
          if (this.emit("active"), q(), $18) this._initializeIntervalIfNeeded();
          return true;
        }
      }
      return false;
    }
    _initializeIntervalIfNeeded() {
      if (this._isIntervalIgnored || this._intervalId !== void 0) return;
      this._intervalId = setInterval(() => {
        this._onInterval();
      }, this._interval), this._intervalEnd = Date.now() + this._interval;
    }
    _onInterval() {
      if (this._intervalCount === 0 && this._pendingCount === 0 && this._intervalId) clearInterval(this._intervalId), this._intervalId = void 0;
      this._intervalCount = this._carryoverConcurrencyCount ? this._pendingCount : 0, this._processQueue();
    }
    _processQueue() {
      while (this._tryToStartAnother()) ;
    }
    get concurrency() {
      return this._concurrency;
    }
    set concurrency($18) {
      if (!(typeof $18 === "number" && $18 >= 1)) throw TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${$18}\` (${typeof $18})`);
      this._concurrency = $18, this._processQueue();
    }
    async add($18, q = {}) {
      return new Promise((K, P) => {
        let _ = async () => {
          this._pendingCount++, this._intervalCount++;
          try {
            let Y = this._timeout === void 0 && q.timeout === void 0 ? $18() : iw.default(Promise.resolve($18()), q.timeout === void 0 ? this._timeout : q.timeout, () => {
              if (q.throwOnTimeout === void 0 ? this._throwOnTimeout : q.throwOnTimeout) P(HC);
              return;
            });
            K(await Y);
          } catch (Y) {
            P(Y);
          }
          this._next();
        };
        this._queue.enqueue(_, q), this._tryToStartAnother(), this.emit("add");
      });
    }
    async addAll($18, q) {
      return Promise.all($18.map(async (K) => this.add(K, q)));
    }
    start() {
      if (!this._isPaused) return this;
      return this._isPaused = false, this._processQueue(), this;
    }
    pause() {
      this._isPaused = true;
    }
    clear() {
      this._queue = new this._queueClass();
    }
    async onEmpty() {
      if (this._queue.size === 0) return;
      return new Promise(($18) => {
        let q = this._resolveEmpty;
        this._resolveEmpty = () => {
          q(), $18();
        };
      });
    }
    async onIdle() {
      if (this._pendingCount === 0 && this._queue.size === 0) return;
      return new Promise(($18) => {
        let q = this._resolveIdle;
        this._resolveIdle = () => {
          q(), $18();
        };
      });
    }
    get size() {
      return this._queue.size;
    }
    sizeBy($18) {
      return this._queue.filter($18).length;
    }
    get pending() {
      return this._pendingCount;
    }
    get isPaused() {
      return this._isPaused;
    }
    get timeout() {
      return this._timeout;
    }
    set timeout($18) {
      this._timeout = $18;
    }
  }
  tw.default = Bw;
});
var HP = x$((lF, Fw) => {
  var wC = Number.MAX_SAFE_INTEGER || 9007199254740991, fC = ["major", "premajor", "minor", "preminor", "patch", "prepatch", "prerelease"];
  Fw.exports = { MAX_LENGTH: 256, MAX_SAFE_COMPONENT_LENGTH: 16, MAX_SAFE_BUILD_LENGTH: 250, MAX_SAFE_INTEGER: wC, RELEASE_TYPES: fC, SEMVER_SPEC_VERSION: "2.0.0", FLAG_INCLUDE_PRERELEASE: 1, FLAG_LOOSE: 2 };
});
var JP = x$((rF, aw) => {
  var ZC = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...$18) => console.error("SEMVER", ...$18) : () => {
  };
  aw.exports = ZC;
});
var d_ = x$((c8, Qw) => {
  var { MAX_SAFE_COMPONENT_LENGTH: jY, MAX_SAFE_BUILD_LENGTH: XC, MAX_LENGTH: AC } = HP(), kC = JP();
  c8 = Qw.exports = {};
  var GC = c8.re = [], VC = c8.safeRe = [], F$ = c8.src = [], SC = c8.safeSrc = [], a$ = c8.t = {}, MC = 0, vY = "[a-zA-Z0-9-]", NC = [["\\s", 1], ["\\d", AC], [vY, XC]], CC = ($18) => {
    for (let [q, K] of NC) $18 = $18.split(`${q}*`).join(`${q}{0,${K}}`).split(`${q}+`).join(`${q}{1,${K}}`);
    return $18;
  }, Y6 = ($18, q, K) => {
    let P = CC(q), _ = MC++;
    kC($18, _, q), a$[$18] = _, F$[_] = q, SC[_] = P, GC[_] = new RegExp(q, K ? "g" : void 0), VC[_] = new RegExp(P, K ? "g" : void 0);
  };
  Y6("NUMERICIDENTIFIER", "0|[1-9]\\d*");
  Y6("NUMERICIDENTIFIERLOOSE", "\\d+");
  Y6("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${vY}*`);
  Y6("MAINVERSION", `(${F$[a$.NUMERICIDENTIFIER]})\\.(${F$[a$.NUMERICIDENTIFIER]})\\.(${F$[a$.NUMERICIDENTIFIER]})`);
  Y6("MAINVERSIONLOOSE", `(${F$[a$.NUMERICIDENTIFIERLOOSE]})\\.(${F$[a$.NUMERICIDENTIFIERLOOSE]})\\.(${F$[a$.NUMERICIDENTIFIERLOOSE]})`);
  Y6("PRERELEASEIDENTIFIER", `(?:${F$[a$.NONNUMERICIDENTIFIER]}|${F$[a$.NUMERICIDENTIFIER]})`);
  Y6("PRERELEASEIDENTIFIERLOOSE", `(?:${F$[a$.NONNUMERICIDENTIFIER]}|${F$[a$.NUMERICIDENTIFIERLOOSE]})`);
  Y6("PRERELEASE", `(?:-(${F$[a$.PRERELEASEIDENTIFIER]}(?:\\.${F$[a$.PRERELEASEIDENTIFIER]})*))`);
  Y6("PRERELEASELOOSE", `(?:-?(${F$[a$.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${F$[a$.PRERELEASEIDENTIFIERLOOSE]})*))`);
  Y6("BUILDIDENTIFIER", `${vY}+`);
  Y6("BUILD", `(?:\\+(${F$[a$.BUILDIDENTIFIER]}(?:\\.${F$[a$.BUILDIDENTIFIER]})*))`);
  Y6("FULLPLAIN", `v?${F$[a$.MAINVERSION]}${F$[a$.PRERELEASE]}?${F$[a$.BUILD]}?`);
  Y6("FULL", `^${F$[a$.FULLPLAIN]}$`);
  Y6("LOOSEPLAIN", `[v=\\s]*${F$[a$.MAINVERSIONLOOSE]}${F$[a$.PRERELEASELOOSE]}?${F$[a$.BUILD]}?`);
  Y6("LOOSE", `^${F$[a$.LOOSEPLAIN]}$`);
  Y6("GTLT", "((?:<|>)?=?)");
  Y6("XRANGEIDENTIFIERLOOSE", `${F$[a$.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
  Y6("XRANGEIDENTIFIER", `${F$[a$.NUMERICIDENTIFIER]}|x|X|\\*`);
  Y6("XRANGEPLAIN", `[v=\\s]*(${F$[a$.XRANGEIDENTIFIER]})(?:\\.(${F$[a$.XRANGEIDENTIFIER]})(?:\\.(${F$[a$.XRANGEIDENTIFIER]})(?:${F$[a$.PRERELEASE]})?${F$[a$.BUILD]}?)?)?`);
  Y6("XRANGEPLAINLOOSE", `[v=\\s]*(${F$[a$.XRANGEIDENTIFIERLOOSE]})(?:\\.(${F$[a$.XRANGEIDENTIFIERLOOSE]})(?:\\.(${F$[a$.XRANGEIDENTIFIERLOOSE]})(?:${F$[a$.PRERELEASELOOSE]})?${F$[a$.BUILD]}?)?)?`);
  Y6("XRANGE", `^${F$[a$.GTLT]}\\s*${F$[a$.XRANGEPLAIN]}$`);
  Y6("XRANGELOOSE", `^${F$[a$.GTLT]}\\s*${F$[a$.XRANGEPLAINLOOSE]}$`);
  Y6("COERCEPLAIN", `(^|[^\\d])(\\d{1,${jY}})(?:\\.(\\d{1,${jY}}))?(?:\\.(\\d{1,${jY}}))?`);
  Y6("COERCE", `${F$[a$.COERCEPLAIN]}(?:$|[^\\d])`);
  Y6("COERCEFULL", F$[a$.COERCEPLAIN] + `(?:${F$[a$.PRERELEASE]})?(?:${F$[a$.BUILD]})?(?:$|[^\\d])`);
  Y6("COERCERTL", F$[a$.COERCE], true);
  Y6("COERCERTLFULL", F$[a$.COERCEFULL], true);
  Y6("LONETILDE", "(?:~>?)");
  Y6("TILDETRIM", `(\\s*)${F$[a$.LONETILDE]}\\s+`, true);
  c8.tildeTrimReplace = "$1~";
  Y6("TILDE", `^${F$[a$.LONETILDE]}${F$[a$.XRANGEPLAIN]}$`);
  Y6("TILDELOOSE", `^${F$[a$.LONETILDE]}${F$[a$.XRANGEPLAINLOOSE]}$`);
  Y6("LONECARET", "(?:\\^)");
  Y6("CARETTRIM", `(\\s*)${F$[a$.LONECARET]}\\s+`, true);
  c8.caretTrimReplace = "$1^";
  Y6("CARET", `^${F$[a$.LONECARET]}${F$[a$.XRANGEPLAIN]}$`);
  Y6("CARETLOOSE", `^${F$[a$.LONECARET]}${F$[a$.XRANGEPLAINLOOSE]}$`);
  Y6("COMPARATORLOOSE", `^${F$[a$.GTLT]}\\s*(${F$[a$.LOOSEPLAIN]})$|^$`);
  Y6("COMPARATOR", `^${F$[a$.GTLT]}\\s*(${F$[a$.FULLPLAIN]})$|^$`);
  Y6("COMPARATORTRIM", `(\\s*)${F$[a$.GTLT]}\\s*(${F$[a$.LOOSEPLAIN]}|${F$[a$.XRANGEPLAIN]})`, true);
  c8.comparatorTrimReplace = "$1$2$3";
  Y6("HYPHENRANGE", `^\\s*(${F$[a$.XRANGEPLAIN]})\\s+-\\s+(${F$[a$.XRANGEPLAIN]})\\s*$`);
  Y6("HYPHENRANGELOOSE", `^\\s*(${F$[a$.XRANGEPLAINLOOSE]})\\s+-\\s+(${F$[a$.XRANGEPLAINLOOSE]})\\s*$`);
  Y6("STAR", "(<|>)?=?\\s*\\*");
  Y6("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
  Y6("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
});
var g1 = x$((oF, ew) => {
  var EC = Object.freeze({ loose: true }), hC = Object.freeze({}), RC = ($18) => {
    if (!$18) return hC;
    if (typeof $18 !== "object") return EC;
    return $18;
  };
  ew.exports = RC;
});
var zY = x$((nF, qf) => {
  var sw = /^[0-9]+$/, $f = ($18, q) => {
    if (typeof $18 === "number" && typeof q === "number") return $18 === q ? 0 : $18 < q ? -1 : 1;
    let K = sw.test($18), P = sw.test(q);
    if (K && P) $18 = +$18, q = +q;
    return $18 === q ? 0 : K && !P ? -1 : P && !K ? 1 : $18 < q ? -1 : 1;
  }, IC = ($18, q) => $f(q, $18);
  qf.exports = { compareIdentifiers: $f, rcompareIdentifiers: IC };
});
var Cq = x$((iF, _f) => {
  var b1 = JP(), { MAX_LENGTH: Kf, MAX_SAFE_INTEGER: y1 } = HP(), { safeRe: u1, t: x1 } = d_(), DC = g1(), { compareIdentifiers: WY } = zY();
  class C8 {
    constructor($18, q) {
      if (q = DC(q), $18 instanceof C8) if ($18.loose === !!q.loose && $18.includePrerelease === !!q.includePrerelease) return $18;
      else $18 = $18.version;
      else if (typeof $18 !== "string") throw TypeError(`Invalid version. Must be a string. Got type "${typeof $18}".`);
      if ($18.length > Kf) throw TypeError(`version is longer than ${Kf} characters`);
      b1("SemVer", $18, q), this.options = q, this.loose = !!q.loose, this.includePrerelease = !!q.includePrerelease;
      let K = $18.trim().match(q.loose ? u1[x1.LOOSE] : u1[x1.FULL]);
      if (!K) throw TypeError(`Invalid Version: ${$18}`);
      if (this.raw = $18, this.major = +K[1], this.minor = +K[2], this.patch = +K[3], this.major > y1 || this.major < 0) throw TypeError("Invalid major version");
      if (this.minor > y1 || this.minor < 0) throw TypeError("Invalid minor version");
      if (this.patch > y1 || this.patch < 0) throw TypeError("Invalid patch version");
      if (!K[4]) this.prerelease = [];
      else this.prerelease = K[4].split(".").map((P) => {
        if (/^[0-9]+$/.test(P)) {
          let _ = +P;
          if (_ >= 0 && _ < y1) return _;
        }
        return P;
      });
      this.build = K[5] ? K[5].split(".") : [], this.format();
    }
    format() {
      if (this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length) this.version += `-${this.prerelease.join(".")}`;
      return this.version;
    }
    toString() {
      return this.version;
    }
    compare($18) {
      if (b1("SemVer.compare", this.version, this.options, $18), !($18 instanceof C8)) {
        if (typeof $18 === "string" && $18 === this.version) return 0;
        $18 = new C8($18, this.options);
      }
      if ($18.version === this.version) return 0;
      return this.compareMain($18) || this.comparePre($18);
    }
    compareMain($18) {
      if (!($18 instanceof C8)) $18 = new C8($18, this.options);
      if (this.major < $18.major) return -1;
      if (this.major > $18.major) return 1;
      if (this.minor < $18.minor) return -1;
      if (this.minor > $18.minor) return 1;
      if (this.patch < $18.patch) return -1;
      if (this.patch > $18.patch) return 1;
      return 0;
    }
    comparePre($18) {
      if (!($18 instanceof C8)) $18 = new C8($18, this.options);
      if (this.prerelease.length && !$18.prerelease.length) return -1;
      else if (!this.prerelease.length && $18.prerelease.length) return 1;
      else if (!this.prerelease.length && !$18.prerelease.length) return 0;
      let q = 0;
      do {
        let K = this.prerelease[q], P = $18.prerelease[q];
        if (b1("prerelease compare", q, K, P), K === void 0 && P === void 0) return 0;
        else if (P === void 0) return 1;
        else if (K === void 0) return -1;
        else if (K === P) continue;
        else return WY(K, P);
      } while (++q);
    }
    compareBuild($18) {
      if (!($18 instanceof C8)) $18 = new C8($18, this.options);
      let q = 0;
      do {
        let K = this.build[q], P = $18.build[q];
        if (b1("build compare", q, K, P), K === void 0 && P === void 0) return 0;
        else if (P === void 0) return 1;
        else if (K === void 0) return -1;
        else if (K === P) continue;
        else return WY(K, P);
      } while (++q);
    }
    inc($18, q, K) {
      if ($18.startsWith("pre")) {
        if (!q && K === false) throw Error("invalid increment argument: identifier is empty");
        if (q) {
          let P = `-${q}`.match(this.options.loose ? u1[x1.PRERELEASELOOSE] : u1[x1.PRERELEASE]);
          if (!P || P[1] !== q) throw Error(`invalid identifier: ${q}`);
        }
      }
      switch ($18) {
        case "premajor":
          this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", q, K);
          break;
        case "preminor":
          this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", q, K);
          break;
        case "prepatch":
          this.prerelease.length = 0, this.inc("patch", q, K), this.inc("pre", q, K);
          break;
        case "prerelease":
          if (this.prerelease.length === 0) this.inc("patch", q, K);
          this.inc("pre", q, K);
          break;
        case "release":
          if (this.prerelease.length === 0) throw Error(`version ${this.raw} is not a prerelease`);
          this.prerelease.length = 0;
          break;
        case "major":
          if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) this.major++;
          this.minor = 0, this.patch = 0, this.prerelease = [];
          break;
        case "minor":
          if (this.patch !== 0 || this.prerelease.length === 0) this.minor++;
          this.patch = 0, this.prerelease = [];
          break;
        case "patch":
          if (this.prerelease.length === 0) this.patch++;
          this.prerelease = [];
          break;
        case "pre": {
          let P = Number(K) ? 1 : 0;
          if (this.prerelease.length === 0) this.prerelease = [P];
          else {
            let _ = this.prerelease.length;
            while (--_ >= 0) if (typeof this.prerelease[_] === "number") this.prerelease[_]++, _ = -2;
            if (_ === -1) {
              if (q === this.prerelease.join(".") && K === false) throw Error("invalid increment argument: identifier already exists");
              this.prerelease.push(P);
            }
          }
          if (q) {
            let _ = [q, P];
            if (K === false) _ = [q];
            if (WY(this.prerelease[0], q) === 0) {
              if (isNaN(this.prerelease[1])) this.prerelease = _;
            } else this.prerelease = _;
          }
          break;
        }
        default:
          throw Error(`invalid increment argument: ${$18}`);
      }
      if (this.raw = this.format(), this.build.length) this.raw += `+${this.build.join(".")}`;
      return this;
    }
  }
  _f.exports = C8;
});
var j_ = x$((BF, Of) => {
  var Pf = Cq(), LC = ($18, q, K = false) => {
    if ($18 instanceof Pf) return $18;
    try {
      return new Pf($18, q);
    } catch (P) {
      if (!K) return null;
      throw P;
    }
  };
  Of.exports = LC;
});
var jf = x$((tF, Yf) => {
  var gC = j_(), bC = ($18, q) => {
    let K = gC($18, q);
    return K ? K.version : null;
  };
  Yf.exports = bC;
});
var zf = x$((UF, vf) => {
  var yC = j_(), uC = ($18, q) => {
    let K = yC($18.trim().replace(/^[=v]+/, ""), q);
    return K ? K.version : null;
  };
  vf.exports = uC;
});
var Jf = x$((FF, Hf) => {
  var Wf = Cq(), xC = ($18, q, K, P, _) => {
    if (typeof K === "string") _ = P, P = K, K = void 0;
    try {
      return new Wf($18 instanceof Wf ? $18.version : $18, K).inc(q, P, _).version;
    } catch (Y) {
      return null;
    }
  };
  Hf.exports = xC;
});
var ff = x$((aF, wf) => {
  var Tf = j_(), pC = ($18, q) => {
    let K = Tf($18, null, true), P = Tf(q, null, true), _ = K.compare(P);
    if (_ === 0) return null;
    let Y = _ > 0, O = Y ? K : P, z = Y ? P : K, J = !!O.prerelease.length;
    if (!!z.prerelease.length && !J) {
      if (!z.patch && !z.minor) return "major";
      if (z.compareMain(O) === 0) {
        if (z.minor && !z.patch) return "minor";
        return "patch";
      }
    }
    let X = J ? "pre" : "";
    if (K.major !== P.major) return X + "major";
    if (K.minor !== P.minor) return X + "minor";
    if (K.patch !== P.patch) return X + "patch";
    return "prerelease";
  };
  wf.exports = pC;
});
var Xf = x$((QF, Zf) => {
  var cC = Cq(), mC = ($18, q) => new cC($18, q).major;
  Zf.exports = mC;
});
var kf = x$((eF, Af) => {
  var dC = Cq(), lC = ($18, q) => new dC($18, q).minor;
  Af.exports = lC;
});
var Vf = x$((sF, Gf) => {
  var rC = Cq(), oC = ($18, q) => new rC($18, q).patch;
  Gf.exports = oC;
});
var Mf = x$(($a, Sf) => {
  var nC = j_(), iC = ($18, q) => {
    let K = nC($18, q);
    return K && K.prerelease.length ? K.prerelease : null;
  };
  Sf.exports = iC;
});
var H8 = x$((qa, Cf) => {
  var Nf = Cq(), BC = ($18, q, K) => new Nf($18, K).compare(new Nf(q, K));
  Cf.exports = BC;
});
var hf = x$((Ka, Ef) => {
  var tC = H8(), UC = ($18, q, K) => tC(q, $18, K);
  Ef.exports = UC;
});
var If = x$((_a2, Rf) => {
  var FC = H8(), aC = ($18, q) => FC($18, q, true);
  Rf.exports = aC;
});
var p1 = x$((Pa, Lf) => {
  var Df = Cq(), QC = ($18, q, K) => {
    let P = new Df($18, K), _ = new Df(q, K);
    return P.compare(_) || P.compareBuild(_);
  };
  Lf.exports = QC;
});
var bf = x$((Oa, gf) => {
  var eC = p1(), sC = ($18, q) => $18.sort((K, P) => eC(K, P, q));
  gf.exports = sC;
});
var uf = x$((Ya, yf) => {
  var $E = p1(), qE = ($18, q) => $18.sort((K, P) => $E(P, K, q));
  yf.exports = qE;
});
var TP = x$((ja, xf) => {
  var KE = H8(), _E = ($18, q, K) => KE($18, q, K) > 0;
  xf.exports = _E;
});
var c1 = x$((va, pf) => {
  var PE = H8(), OE = ($18, q, K) => PE($18, q, K) < 0;
  pf.exports = OE;
});
var HY = x$((za, cf) => {
  var YE = H8(), jE = ($18, q, K) => YE($18, q, K) === 0;
  cf.exports = jE;
});
var JY = x$((Wa, mf) => {
  var vE = H8(), zE = ($18, q, K) => vE($18, q, K) !== 0;
  mf.exports = zE;
});
var m1 = x$((Ha, df) => {
  var WE = H8(), HE = ($18, q, K) => WE($18, q, K) >= 0;
  df.exports = HE;
});
var d1 = x$((Ja, lf) => {
  var JE = H8(), TE = ($18, q, K) => JE($18, q, K) <= 0;
  lf.exports = TE;
});
var TY = x$((Ta, rf) => {
  var wE = HY(), fE = JY(), ZE = TP(), XE = m1(), AE = c1(), kE = d1(), GE = ($18, q, K, P) => {
    switch (q) {
      case "===":
        if (typeof $18 === "object") $18 = $18.version;
        if (typeof K === "object") K = K.version;
        return $18 === K;
      case "!==":
        if (typeof $18 === "object") $18 = $18.version;
        if (typeof K === "object") K = K.version;
        return $18 !== K;
      case "":
      case "=":
      case "==":
        return wE($18, K, P);
      case "!=":
        return fE($18, K, P);
      case ">":
        return ZE($18, K, P);
      case ">=":
        return XE($18, K, P);
      case "<":
        return AE($18, K, P);
      case "<=":
        return kE($18, K, P);
      default:
        throw TypeError(`Invalid operator: ${q}`);
    }
  };
  rf.exports = GE;
});
var nf = x$((wa, of) => {
  var VE = Cq(), SE = j_(), { safeRe: l1, t: r1 } = d_(), ME = ($18, q) => {
    if ($18 instanceof VE) return $18;
    if (typeof $18 === "number") $18 = String($18);
    if (typeof $18 !== "string") return null;
    q = q || {};
    let K = null;
    if (!q.rtl) K = $18.match(q.includePrerelease ? l1[r1.COERCEFULL] : l1[r1.COERCE]);
    else {
      let J = q.includePrerelease ? l1[r1.COERCERTLFULL] : l1[r1.COERCERTL], T;
      while ((T = J.exec($18)) && (!K || K.index + K[0].length !== $18.length)) {
        if (!K || T.index + T[0].length !== K.index + K[0].length) K = T;
        J.lastIndex = T.index + T[1].length + T[2].length;
      }
      J.lastIndex = -1;
    }
    if (K === null) return null;
    let P = K[2], _ = K[3] || "0", Y = K[4] || "0", O = q.includePrerelease && K[5] ? `-${K[5]}` : "", z = q.includePrerelease && K[6] ? `+${K[6]}` : "";
    return SE(`${P}.${_}.${Y}${O}${z}`, q);
  };
  of.exports = ME;
});
var Uf = x$((fa, tf) => {
  class Bf {
    constructor() {
      this.max = 1e3, this.map = /* @__PURE__ */ new Map();
    }
    get($18) {
      let q = this.map.get($18);
      if (q === void 0) return;
      else return this.map.delete($18), this.map.set($18, q), q;
    }
    delete($18) {
      return this.map.delete($18);
    }
    set($18, q) {
      if (!this.delete($18) && q !== void 0) {
        if (this.map.size >= this.max) {
          let P = this.map.keys().next().value;
          this.delete(P);
        }
        this.map.set($18, q);
      }
      return this;
    }
  }
  tf.exports = Bf;
});
var J8 = x$((Za, ef) => {
  var NE = /\s+/g;
  class wP {
    constructor($18, q) {
      if (q = EE(q), $18 instanceof wP) if ($18.loose === !!q.loose && $18.includePrerelease === !!q.includePrerelease) return $18;
      else return new wP($18.raw, q);
      if ($18 instanceof wY) return this.raw = $18.value, this.set = [[$18]], this.formatted = void 0, this;
      if (this.options = q, this.loose = !!q.loose, this.includePrerelease = !!q.includePrerelease, this.raw = $18.trim().replace(NE, " "), this.set = this.raw.split("||").map((K) => this.parseRange(K.trim())).filter((K) => K.length), !this.set.length) throw TypeError(`Invalid SemVer Range: ${this.raw}`);
      if (this.set.length > 1) {
        let K = this.set[0];
        if (this.set = this.set.filter((P) => !af(P[0])), this.set.length === 0) this.set = [K];
        else if (this.set.length > 1) {
          for (let P of this.set) if (P.length === 1 && bE(P[0])) {
            this.set = [P];
            break;
          }
        }
      }
      this.formatted = void 0;
    }
    get range() {
      if (this.formatted === void 0) {
        this.formatted = "";
        for (let $18 = 0; $18 < this.set.length; $18++) {
          if ($18 > 0) this.formatted += "||";
          let q = this.set[$18];
          for (let K = 0; K < q.length; K++) {
            if (K > 0) this.formatted += " ";
            this.formatted += q[K].toString().trim();
          }
        }
      }
      return this.formatted;
    }
    format() {
      return this.range;
    }
    toString() {
      return this.range;
    }
    parseRange($18) {
      let K = ((this.options.includePrerelease && LE) | (this.options.loose && gE)) + ":" + $18, P = Ff.get(K);
      if (P) return P;
      let _ = this.options.loose, Y = _ ? Lq[Eq.HYPHENRANGELOOSE] : Lq[Eq.HYPHENRANGE];
      $18 = $18.replace(Y, oE(this.options.includePrerelease)), R6("hyphen replace", $18), $18 = $18.replace(Lq[Eq.COMPARATORTRIM], RE), R6("comparator trim", $18), $18 = $18.replace(Lq[Eq.TILDETRIM], IE), R6("tilde trim", $18), $18 = $18.replace(Lq[Eq.CARETTRIM], DE), R6("caret trim", $18);
      let O = $18.split(" ").map((X) => yE(X, this.options)).join(" ").split(/\s+/).map((X) => rE(X, this.options));
      if (_) O = O.filter((X) => {
        return R6("loose invalid filter", X, this.options), !!X.match(Lq[Eq.COMPARATORLOOSE]);
      });
      R6("range list", O);
      let z = /* @__PURE__ */ new Map(), J = O.map((X) => new wY(X, this.options));
      for (let X of J) {
        if (af(X)) return [X];
        z.set(X.value, X);
      }
      if (z.size > 1 && z.has("")) z.delete("");
      let T = [...z.values()];
      return Ff.set(K, T), T;
    }
    intersects($18, q) {
      if (!($18 instanceof wP)) throw TypeError("a Range is required");
      return this.set.some((K) => {
        return Qf(K, q) && $18.set.some((P) => {
          return Qf(P, q) && K.every((_) => {
            return P.every((Y) => {
              return _.intersects(Y, q);
            });
          });
        });
      });
    }
    test($18) {
      if (!$18) return false;
      if (typeof $18 === "string") try {
        $18 = new hE($18, this.options);
      } catch (q) {
        return false;
      }
      for (let q = 0; q < this.set.length; q++) if (nE(this.set[q], $18, this.options)) return true;
      return false;
    }
  }
  ef.exports = wP;
  var CE = Uf(), Ff = new CE(), EE = g1(), wY = fP(), R6 = JP(), hE = Cq(), { safeRe: Lq, t: Eq, comparatorTrimReplace: RE, tildeTrimReplace: IE, caretTrimReplace: DE } = d_(), { FLAG_INCLUDE_PRERELEASE: LE, FLAG_LOOSE: gE } = HP(), af = ($18) => $18.value === "<0.0.0-0", bE = ($18) => $18.value === "", Qf = ($18, q) => {
    let K = true, P = $18.slice(), _ = P.pop();
    while (K && P.length) K = P.every((Y) => {
      return _.intersects(Y, q);
    }), _ = P.pop();
    return K;
  }, yE = ($18, q) => {
    return $18 = $18.replace(Lq[Eq.BUILD], ""), R6("comp", $18, q), $18 = pE($18, q), R6("caret", $18), $18 = uE($18, q), R6("tildes", $18), $18 = mE($18, q), R6("xrange", $18), $18 = lE($18, q), R6("stars", $18), $18;
  }, gq = ($18) => !$18 || $18.toLowerCase() === "x" || $18 === "*", uE = ($18, q) => {
    return $18.trim().split(/\s+/).map((K) => xE(K, q)).join(" ");
  }, xE = ($18, q) => {
    let K = q.loose ? Lq[Eq.TILDELOOSE] : Lq[Eq.TILDE];
    return $18.replace(K, (P, _, Y, O, z) => {
      R6("tilde", $18, P, _, Y, O, z);
      let J;
      if (gq(_)) J = "";
      else if (gq(Y)) J = `>=${_}.0.0 <${+_ + 1}.0.0-0`;
      else if (gq(O)) J = `>=${_}.${Y}.0 <${_}.${+Y + 1}.0-0`;
      else if (z) R6("replaceTilde pr", z), J = `>=${_}.${Y}.${O}-${z} <${_}.${+Y + 1}.0-0`;
      else J = `>=${_}.${Y}.${O} <${_}.${+Y + 1}.0-0`;
      return R6("tilde return", J), J;
    });
  }, pE = ($18, q) => {
    return $18.trim().split(/\s+/).map((K) => cE(K, q)).join(" ");
  }, cE = ($18, q) => {
    R6("caret", $18, q);
    let K = q.loose ? Lq[Eq.CARETLOOSE] : Lq[Eq.CARET], P = q.includePrerelease ? "-0" : "";
    return $18.replace(K, (_, Y, O, z, J) => {
      R6("caret", $18, _, Y, O, z, J);
      let T;
      if (gq(Y)) T = "";
      else if (gq(O)) T = `>=${Y}.0.0${P} <${+Y + 1}.0.0-0`;
      else if (gq(z)) if (Y === "0") T = `>=${Y}.${O}.0${P} <${Y}.${+O + 1}.0-0`;
      else T = `>=${Y}.${O}.0${P} <${+Y + 1}.0.0-0`;
      else if (J) if (R6("replaceCaret pr", J), Y === "0") if (O === "0") T = `>=${Y}.${O}.${z}-${J} <${Y}.${O}.${+z + 1}-0`;
      else T = `>=${Y}.${O}.${z}-${J} <${Y}.${+O + 1}.0-0`;
      else T = `>=${Y}.${O}.${z}-${J} <${+Y + 1}.0.0-0`;
      else if (R6("no pr"), Y === "0") if (O === "0") T = `>=${Y}.${O}.${z}${P} <${Y}.${O}.${+z + 1}-0`;
      else T = `>=${Y}.${O}.${z}${P} <${Y}.${+O + 1}.0-0`;
      else T = `>=${Y}.${O}.${z} <${+Y + 1}.0.0-0`;
      return R6("caret return", T), T;
    });
  }, mE = ($18, q) => {
    return R6("replaceXRanges", $18, q), $18.split(/\s+/).map((K) => dE(K, q)).join(" ");
  }, dE = ($18, q) => {
    $18 = $18.trim();
    let K = q.loose ? Lq[Eq.XRANGELOOSE] : Lq[Eq.XRANGE];
    return $18.replace(K, (P, _, Y, O, z, J) => {
      R6("xRange", $18, P, _, Y, O, z, J);
      let T = gq(Y), X = T || gq(O), f = X || gq(z), V = f;
      if (_ === "=" && V) _ = "";
      if (J = q.includePrerelease ? "-0" : "", T) if (_ === ">" || _ === "<") P = "<0.0.0-0";
      else P = "*";
      else if (_ && V) {
        if (X) O = 0;
        if (z = 0, _ === ">") if (_ = ">=", X) Y = +Y + 1, O = 0, z = 0;
        else O = +O + 1, z = 0;
        else if (_ === "<=") if (_ = "<", X) Y = +Y + 1;
        else O = +O + 1;
        if (_ === "<") J = "-0";
        P = `${_ + Y}.${O}.${z}${J}`;
      } else if (X) P = `>=${Y}.0.0${J} <${+Y + 1}.0.0-0`;
      else if (f) P = `>=${Y}.${O}.0${J} <${Y}.${+O + 1}.0-0`;
      return R6("xRange return", P), P;
    });
  }, lE = ($18, q) => {
    return R6("replaceStars", $18, q), $18.trim().replace(Lq[Eq.STAR], "");
  }, rE = ($18, q) => {
    return R6("replaceGTE0", $18, q), $18.trim().replace(Lq[q.includePrerelease ? Eq.GTE0PRE : Eq.GTE0], "");
  }, oE = ($18) => (q, K, P, _, Y, O, z, J, T, X, f, V) => {
    if (gq(P)) K = "";
    else if (gq(_)) K = `>=${P}.0.0${$18 ? "-0" : ""}`;
    else if (gq(Y)) K = `>=${P}.${_}.0${$18 ? "-0" : ""}`;
    else if (O) K = `>=${K}`;
    else K = `>=${K}${$18 ? "-0" : ""}`;
    if (gq(T)) J = "";
    else if (gq(X)) J = `<${+T + 1}.0.0-0`;
    else if (gq(f)) J = `<${T}.${+X + 1}.0-0`;
    else if (V) J = `<=${T}.${X}.${f}-${V}`;
    else if ($18) J = `<${T}.${X}.${+f + 1}-0`;
    else J = `<=${J}`;
    return `${K} ${J}`.trim();
  }, nE = ($18, q, K) => {
    for (let P = 0; P < $18.length; P++) if (!$18[P].test(q)) return false;
    if (q.prerelease.length && !K.includePrerelease) {
      for (let P = 0; P < $18.length; P++) {
        if (R6($18[P].semver), $18[P].semver === wY.ANY) continue;
        if ($18[P].semver.prerelease.length > 0) {
          let _ = $18[P].semver;
          if (_.major === q.major && _.minor === q.minor && _.patch === q.patch) return true;
        }
      }
      return false;
    }
    return true;
  };
});
var fP = x$((Xa, PZ) => {
  var ZP = Symbol("SemVer ANY");
  class o1 {
    static get ANY() {
      return ZP;
    }
    constructor($18, q) {
      if (q = sf(q), $18 instanceof o1) if ($18.loose === !!q.loose) return $18;
      else $18 = $18.value;
      if ($18 = $18.trim().split(/\s+/).join(" "), ZY("comparator", $18, q), this.options = q, this.loose = !!q.loose, this.parse($18), this.semver === ZP) this.value = "";
      else this.value = this.operator + this.semver.version;
      ZY("comp", this);
    }
    parse($18) {
      let q = this.options.loose ? $Z[qZ.COMPARATORLOOSE] : $Z[qZ.COMPARATOR], K = $18.match(q);
      if (!K) throw TypeError(`Invalid comparator: ${$18}`);
      if (this.operator = K[1] !== void 0 ? K[1] : "", this.operator === "=") this.operator = "";
      if (!K[2]) this.semver = ZP;
      else this.semver = new KZ(K[2], this.options.loose);
    }
    toString() {
      return this.value;
    }
    test($18) {
      if (ZY("Comparator.test", $18, this.options.loose), this.semver === ZP || $18 === ZP) return true;
      if (typeof $18 === "string") try {
        $18 = new KZ($18, this.options);
      } catch (q) {
        return false;
      }
      return fY($18, this.operator, this.semver, this.options);
    }
    intersects($18, q) {
      if (!($18 instanceof o1)) throw TypeError("a Comparator is required");
      if (this.operator === "") {
        if (this.value === "") return true;
        return new _Z($18.value, q).test(this.value);
      } else if ($18.operator === "") {
        if ($18.value === "") return true;
        return new _Z(this.value, q).test($18.semver);
      }
      if (q = sf(q), q.includePrerelease && (this.value === "<0.0.0-0" || $18.value === "<0.0.0-0")) return false;
      if (!q.includePrerelease && (this.value.startsWith("<0.0.0") || $18.value.startsWith("<0.0.0"))) return false;
      if (this.operator.startsWith(">") && $18.operator.startsWith(">")) return true;
      if (this.operator.startsWith("<") && $18.operator.startsWith("<")) return true;
      if (this.semver.version === $18.semver.version && this.operator.includes("=") && $18.operator.includes("=")) return true;
      if (fY(this.semver, "<", $18.semver, q) && this.operator.startsWith(">") && $18.operator.startsWith("<")) return true;
      if (fY(this.semver, ">", $18.semver, q) && this.operator.startsWith("<") && $18.operator.startsWith(">")) return true;
      return false;
    }
  }
  PZ.exports = o1;
  var sf = g1(), { safeRe: $Z, t: qZ } = d_(), fY = TY(), ZY = JP(), KZ = Cq(), _Z = J8();
});
var XP = x$((Aa, OZ) => {
  var iE = J8(), BE = ($18, q, K) => {
    try {
      q = new iE(q, K);
    } catch (P) {
      return false;
    }
    return q.test($18);
  };
  OZ.exports = BE;
});
var jZ = x$((ka, YZ) => {
  var tE = J8(), UE = ($18, q) => new tE($18, q).set.map((K) => K.map((P) => P.value).join(" ").trim().split(" "));
  YZ.exports = UE;
});
var zZ = x$((Ga, vZ) => {
  var FE = Cq(), aE = J8(), QE = ($18, q, K) => {
    let P = null, _ = null, Y = null;
    try {
      Y = new aE(q, K);
    } catch (O) {
      return null;
    }
    return $18.forEach((O) => {
      if (Y.test(O)) {
        if (!P || _.compare(O) === -1) P = O, _ = new FE(P, K);
      }
    }), P;
  };
  vZ.exports = QE;
});
var HZ = x$((Va, WZ) => {
  var eE = Cq(), sE = J8(), $h = ($18, q, K) => {
    let P = null, _ = null, Y = null;
    try {
      Y = new sE(q, K);
    } catch (O) {
      return null;
    }
    return $18.forEach((O) => {
      if (Y.test(O)) {
        if (!P || _.compare(O) === 1) P = O, _ = new eE(P, K);
      }
    }), P;
  };
  WZ.exports = $h;
});
var wZ = x$((Sa, TZ) => {
  var XY = Cq(), qh = J8(), JZ = TP(), Kh = ($18, q) => {
    $18 = new qh($18, q);
    let K = new XY("0.0.0");
    if ($18.test(K)) return K;
    if (K = new XY("0.0.0-0"), $18.test(K)) return K;
    K = null;
    for (let P = 0; P < $18.set.length; ++P) {
      let _ = $18.set[P], Y = null;
      if (_.forEach((O) => {
        let z = new XY(O.semver.version);
        switch (O.operator) {
          case ">":
            if (z.prerelease.length === 0) z.patch++;
            else z.prerelease.push(0);
            z.raw = z.format();
          case "":
          case ">=":
            if (!Y || JZ(z, Y)) Y = z;
            break;
          case "<":
          case "<=":
            break;
          default:
            throw Error(`Unexpected operation: ${O.operator}`);
        }
      }), Y && (!K || JZ(K, Y))) K = Y;
    }
    if (K && $18.test(K)) return K;
    return null;
  };
  TZ.exports = Kh;
});
var ZZ = x$((Ma, fZ) => {
  var _h = J8(), Ph = ($18, q) => {
    try {
      return new _h($18, q).range || "*";
    } catch (K) {
      return null;
    }
  };
  fZ.exports = Ph;
});
var n1 = x$((Na, GZ) => {
  var Oh = Cq(), kZ = fP(), { ANY: Yh } = kZ, jh = J8(), vh = XP(), XZ = TP(), AZ = c1(), zh = d1(), Wh = m1(), Hh = ($18, q, K, P) => {
    $18 = new Oh($18, P), q = new jh(q, P);
    let _, Y, O, z, J;
    switch (K) {
      case ">":
        _ = XZ, Y = zh, O = AZ, z = ">", J = ">=";
        break;
      case "<":
        _ = AZ, Y = Wh, O = XZ, z = "<", J = "<=";
        break;
      default:
        throw TypeError('Must provide a hilo val of "<" or ">"');
    }
    if (vh($18, q, P)) return false;
    for (let T = 0; T < q.set.length; ++T) {
      let X = q.set[T], f = null, V = null;
      if (X.forEach((M) => {
        if (M.semver === Yh) M = new kZ(">=0.0.0");
        if (f = f || M, V = V || M, _(M.semver, f.semver, P)) f = M;
        else if (O(M.semver, V.semver, P)) V = M;
      }), f.operator === z || f.operator === J) return false;
      if ((!V.operator || V.operator === z) && Y($18, V.semver)) return false;
      else if (V.operator === J && O($18, V.semver)) return false;
    }
    return true;
  };
  GZ.exports = Hh;
});
var SZ = x$((Ca, VZ) => {
  var Jh = n1(), Th = ($18, q, K) => Jh($18, q, ">", K);
  VZ.exports = Th;
});
var NZ = x$((Ea, MZ) => {
  var wh = n1(), fh = ($18, q, K) => wh($18, q, "<", K);
  MZ.exports = fh;
});
var hZ = x$((ha, EZ) => {
  var CZ = J8(), Zh = ($18, q, K) => {
    return $18 = new CZ($18, K), q = new CZ(q, K), $18.intersects(q, K);
  };
  EZ.exports = Zh;
});
var IZ = x$((Ra, RZ) => {
  var Xh = XP(), Ah = H8();
  RZ.exports = ($18, q, K) => {
    let P = [], _ = null, Y = null, O = $18.sort((X, f) => Ah(X, f, K));
    for (let X of O) if (Xh(X, q, K)) {
      if (Y = X, !_) _ = X;
    } else {
      if (Y) P.push([_, Y]);
      Y = null, _ = null;
    }
    if (_) P.push([_, null]);
    let z = [];
    for (let [X, f] of P) if (X === f) z.push(X);
    else if (!f && X === O[0]) z.push("*");
    else if (!f) z.push(`>=${X}`);
    else if (X === O[0]) z.push(`<=${f}`);
    else z.push(`${X} - ${f}`);
    let J = z.join(" || "), T = typeof q.raw === "string" ? q.raw : String(q);
    return J.length < T.length ? J : q;
  };
});
var uZ = x$((Ia, yZ) => {
  var DZ = J8(), kY = fP(), { ANY: AY } = kY, AP = XP(), GY = H8(), kh = ($18, q, K = {}) => {
    if ($18 === q) return true;
    $18 = new DZ($18, K), q = new DZ(q, K);
    let P = false;
    $: for (let _ of $18.set) {
      for (let Y of q.set) {
        let O = Vh(_, Y, K);
        if (P = P || O !== null, O) continue $;
      }
      if (P) return false;
    }
    return true;
  }, Gh = [new kY(">=0.0.0-0")], LZ = [new kY(">=0.0.0")], Vh = ($18, q, K) => {
    if ($18 === q) return true;
    if ($18.length === 1 && $18[0].semver === AY) if (q.length === 1 && q[0].semver === AY) return true;
    else if (K.includePrerelease) $18 = Gh;
    else $18 = LZ;
    if (q.length === 1 && q[0].semver === AY) if (K.includePrerelease) return true;
    else q = LZ;
    let P = /* @__PURE__ */ new Set(), _, Y;
    for (let M of $18) if (M.operator === ">" || M.operator === ">=") _ = gZ(_, M, K);
    else if (M.operator === "<" || M.operator === "<=") Y = bZ(Y, M, K);
    else P.add(M.semver);
    if (P.size > 1) return null;
    let O;
    if (_ && Y) {
      if (O = GY(_.semver, Y.semver, K), O > 0) return null;
      else if (O === 0 && (_.operator !== ">=" || Y.operator !== "<=")) return null;
    }
    for (let M of P) {
      if (_ && !AP(M, String(_), K)) return null;
      if (Y && !AP(M, String(Y), K)) return null;
      for (let N of q) if (!AP(M, String(N), K)) return false;
      return true;
    }
    let z, J, T, X, f = Y && !K.includePrerelease && Y.semver.prerelease.length ? Y.semver : false, V = _ && !K.includePrerelease && _.semver.prerelease.length ? _.semver : false;
    if (f && f.prerelease.length === 1 && Y.operator === "<" && f.prerelease[0] === 0) f = false;
    for (let M of q) {
      if (X = X || M.operator === ">" || M.operator === ">=", T = T || M.operator === "<" || M.operator === "<=", _) {
        if (V) {
          if (M.semver.prerelease && M.semver.prerelease.length && M.semver.major === V.major && M.semver.minor === V.minor && M.semver.patch === V.patch) V = false;
        }
        if (M.operator === ">" || M.operator === ">=") {
          if (z = gZ(_, M, K), z === M && z !== _) return false;
        } else if (_.operator === ">=" && !AP(_.semver, String(M), K)) return false;
      }
      if (Y) {
        if (f) {
          if (M.semver.prerelease && M.semver.prerelease.length && M.semver.major === f.major && M.semver.minor === f.minor && M.semver.patch === f.patch) f = false;
        }
        if (M.operator === "<" || M.operator === "<=") {
          if (J = bZ(Y, M, K), J === M && J !== Y) return false;
        } else if (Y.operator === "<=" && !AP(Y.semver, String(M), K)) return false;
      }
      if (!M.operator && (Y || _) && O !== 0) return false;
    }
    if (_ && T && !Y && O !== 0) return false;
    if (Y && X && !_ && O !== 0) return false;
    if (V || f) return false;
    return true;
  }, gZ = ($18, q, K) => {
    if (!$18) return q;
    let P = GY($18.semver, q.semver, K);
    return P > 0 ? $18 : P < 0 ? q : q.operator === ">" && $18.operator === ">=" ? q : $18;
  }, bZ = ($18, q, K) => {
    if (!$18) return q;
    let P = GY($18.semver, q.semver, K);
    return P < 0 ? $18 : P > 0 ? q : q.operator === "<" && $18.operator === "<=" ? q : $18;
  };
  yZ.exports = kh;
});
var mZ = x$((Da, cZ) => {
  var VY = d_(), xZ = HP(), Sh = Cq(), pZ = zY(), Mh = j_(), Nh = jf(), Ch = zf(), Eh = Jf(), hh = ff(), Rh = Xf(), Ih = kf(), Dh = Vf(), Lh = Mf(), gh = H8(), bh = hf(), yh = If(), uh = p1(), xh = bf(), ph = uf(), ch = TP(), mh = c1(), dh = HY(), lh = JY(), rh = m1(), oh = d1(), nh = TY(), ih = nf(), Bh = fP(), th = J8(), Uh = XP(), Fh = jZ(), ah = zZ(), Qh = HZ(), eh = wZ(), sh = ZZ(), $R = n1(), qR = SZ(), KR = NZ(), _R = hZ(), PR = IZ(), OR = uZ();
  cZ.exports = { parse: Mh, valid: Nh, clean: Ch, inc: Eh, diff: hh, major: Rh, minor: Ih, patch: Dh, prerelease: Lh, compare: gh, rcompare: bh, compareLoose: yh, compareBuild: uh, sort: xh, rsort: ph, gt: ch, lt: mh, eq: dh, neq: lh, gte: rh, lte: oh, cmp: nh, coerce: ih, Comparator: Bh, Range: th, satisfies: Uh, toComparators: Fh, maxSatisfying: ah, minSatisfying: Qh, minVersion: eh, validRange: sh, outside: $R, gtr: qR, ltr: KR, intersects: _R, simplifyRange: PR, subset: OR, SemVer: Sh, re: VY.re, src: VY.src, tokens: VY.t, SEMVER_SPEC_VERSION: xZ.SEMVER_SPEC_VERSION, RELEASE_TYPES: xZ.RELEASE_TYPES, compareIdentifiers: pZ.compareIdentifiers, rcompareIdentifiers: pZ.rcompareIdentifiers };
});
var OX = x$((fQ, PX) => {
  var KX = ($18 = 0) => (q) => `\x1B[${38 + $18};5;${q}m`, _X = ($18 = 0) => (q, K, P) => `\x1B[${38 + $18};2;${q};${K};${P}m`;
  function hR() {
    let $18 = /* @__PURE__ */ new Map(), q = { modifier: { reset: [0, 0], bold: [1, 22], dim: [2, 22], italic: [3, 23], underline: [4, 24], overline: [53, 55], inverse: [7, 27], hidden: [8, 28], strikethrough: [9, 29] }, color: { black: [30, 39], red: [31, 39], green: [32, 39], yellow: [33, 39], blue: [34, 39], magenta: [35, 39], cyan: [36, 39], white: [37, 39], blackBright: [90, 39], redBright: [91, 39], greenBright: [92, 39], yellowBright: [93, 39], blueBright: [94, 39], magentaBright: [95, 39], cyanBright: [96, 39], whiteBright: [97, 39] }, bgColor: { bgBlack: [40, 49], bgRed: [41, 49], bgGreen: [42, 49], bgYellow: [43, 49], bgBlue: [44, 49], bgMagenta: [45, 49], bgCyan: [46, 49], bgWhite: [47, 49], bgBlackBright: [100, 49], bgRedBright: [101, 49], bgGreenBright: [102, 49], bgYellowBright: [103, 49], bgBlueBright: [104, 49], bgMagentaBright: [105, 49], bgCyanBright: [106, 49], bgWhiteBright: [107, 49] } };
    q.color.gray = q.color.blackBright, q.bgColor.bgGray = q.bgColor.bgBlackBright, q.color.grey = q.color.blackBright, q.bgColor.bgGrey = q.bgColor.bgBlackBright;
    for (let [K, P] of Object.entries(q)) {
      for (let [_, Y] of Object.entries(P)) q[_] = { open: `\x1B[${Y[0]}m`, close: `\x1B[${Y[1]}m` }, P[_] = q[_], $18.set(Y[0], Y[1]);
      Object.defineProperty(q, K, { value: P, enumerable: false });
    }
    return Object.defineProperty(q, "codes", { value: $18, enumerable: false }), q.color.close = "\x1B[39m", q.bgColor.close = "\x1B[49m", q.color.ansi256 = KX(), q.color.ansi16m = _X(), q.bgColor.ansi256 = KX(10), q.bgColor.ansi16m = _X(10), Object.defineProperties(q, { rgbToAnsi256: { value: (K, P, _) => {
      if (K === P && P === _) {
        if (K < 8) return 16;
        if (K > 248) return 231;
        return Math.round((K - 8) / 247 * 24) + 232;
      }
      return 16 + 36 * Math.round(K / 255 * 5) + 6 * Math.round(P / 255 * 5) + Math.round(_ / 255 * 5);
    }, enumerable: false }, hexToRgb: { value: (K) => {
      let P = /(?<colorString>[a-f\d]{6}|[a-f\d]{3})/i.exec(K.toString(16));
      if (!P) return [0, 0, 0];
      let { colorString: _ } = P.groups;
      if (_.length === 3) _ = _.split("").map((O) => O + O).join("");
      let Y = Number.parseInt(_, 16);
      return [Y >> 16 & 255, Y >> 8 & 255, Y & 255];
    }, enumerable: false }, hexToAnsi256: { value: (K) => q.rgbToAnsi256(...q.hexToRgb(K)), enumerable: false } }), q;
  }
  Object.defineProperty(PX, "exports", { enumerable: true, get: hR });
});
var mA = x$((mb) => {
  mb.byteLength = bb;
  mb.toByteArray = ub;
  mb.fromByteArray = cb;
  var U8 = [], A8 = [], gb = typeof Uint8Array < "u" ? Uint8Array : Array, Gz = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (FK = 0, Vz = Gz.length; FK < Vz; ++FK) U8[FK] = Gz[FK], A8[Gz.charCodeAt(FK)] = FK;
  var FK, Vz;
  A8[45] = 62;
  A8[95] = 63;
  function cA($18) {
    var q = $18.length;
    if (q % 4 > 0) throw Error("Invalid string. Length must be a multiple of 4");
    var K = $18.indexOf("=");
    if (K === -1) K = q;
    var P = K === q ? 0 : 4 - K % 4;
    return [K, P];
  }
  function bb($18) {
    var q = cA($18), K = q[0], P = q[1];
    return (K + P) * 3 / 4 - P;
  }
  function yb($18, q, K) {
    return (q + K) * 3 / 4 - K;
  }
  function ub($18) {
    var q, K = cA($18), P = K[0], _ = K[1], Y = new gb(yb($18, P, _)), O = 0, z = _ > 0 ? P - 4 : P, J;
    for (J = 0; J < z; J += 4) q = A8[$18.charCodeAt(J)] << 18 | A8[$18.charCodeAt(J + 1)] << 12 | A8[$18.charCodeAt(J + 2)] << 6 | A8[$18.charCodeAt(J + 3)], Y[O++] = q >> 16 & 255, Y[O++] = q >> 8 & 255, Y[O++] = q & 255;
    if (_ === 2) q = A8[$18.charCodeAt(J)] << 2 | A8[$18.charCodeAt(J + 1)] >> 4, Y[O++] = q & 255;
    if (_ === 1) q = A8[$18.charCodeAt(J)] << 10 | A8[$18.charCodeAt(J + 1)] << 4 | A8[$18.charCodeAt(J + 2)] >> 2, Y[O++] = q >> 8 & 255, Y[O++] = q & 255;
    return Y;
  }
  function xb($18) {
    return U8[$18 >> 18 & 63] + U8[$18 >> 12 & 63] + U8[$18 >> 6 & 63] + U8[$18 & 63];
  }
  function pb($18, q, K) {
    var P, _ = [];
    for (var Y = q; Y < K; Y += 3) P = ($18[Y] << 16 & 16711680) + ($18[Y + 1] << 8 & 65280) + ($18[Y + 2] & 255), _.push(xb(P));
    return _.join("");
  }
  function cb($18) {
    var q, K = $18.length, P = K % 3, _ = [], Y = 16383;
    for (var O = 0, z = K - P; O < z; O += Y) _.push(pb($18, O, O + Y > z ? z : O + Y));
    if (P === 1) q = $18[K - 1], _.push(U8[q >> 2] + U8[q << 4 & 63] + "==");
    else if (P === 2) q = ($18[K - 2] << 8) + $18[K - 1], _.push(U8[q >> 10] + U8[q >> 4 & 63] + U8[q << 2 & 63] + "=");
    return _.join("");
  }
});
var pq = x$((vy) => {
  vy.__esModule = true;
  vy.extend = rA;
  vy.indexOf = Ky;
  vy.escapeExpression = _y;
  vy.isEmpty = Py;
  vy.createFrame = Oy;
  vy.blockParams = Yy;
  vy.appendContextPath = jy;
  var eb = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#x27;", "`": "&#x60;", "=": "&#x3D;" }, sb = /[&<>"'`=]/g, $y = /[&<>"'`=]/;
  function qy($18) {
    return eb[$18];
  }
  function rA($18) {
    for (var q = 1; q < arguments.length; q++) for (var K in arguments[q]) if (Object.prototype.hasOwnProperty.call(arguments[q], K)) $18[K] = arguments[q][K];
    return $18;
  }
  var hz = Object.prototype.toString;
  vy.toString = hz;
  var Ez = function(q) {
    return typeof q === "function";
  };
  if (Ez(/x/)) vy.isFunction = Ez = function($18) {
    return typeof $18 === "function" && hz.call($18) === "[object Function]";
  };
  vy.isFunction = Ez;
  var oA = Array.isArray || function($18) {
    return $18 && typeof $18 === "object" ? hz.call($18) === "[object Array]" : false;
  };
  vy.isArray = oA;
  function Ky($18, q) {
    for (var K = 0, P = $18.length; K < P; K++) if ($18[K] === q) return K;
    return -1;
  }
  function _y($18) {
    if (typeof $18 !== "string") {
      if ($18 && $18.toHTML) return $18.toHTML();
      else if ($18 == null) return "";
      else if (!$18) return $18 + "";
      $18 = "" + $18;
    }
    if (!$y.test($18)) return $18;
    return $18.replace(sb, qy);
  }
  function Py($18) {
    if (!$18 && $18 !== 0) return true;
    else if (oA($18) && $18.length === 0) return true;
    else return false;
  }
  function Oy($18) {
    var q = rA({}, $18);
    return q._parent = $18, q;
  }
  function Yy($18, q) {
    return $18.path = q, $18;
  }
  function jy($18, q) {
    return ($18 ? $18 + "." : "") + q;
  }
});
var k8 = x$((nA, iA) => {
  nA.__esModule = true;
  var Rz = ["description", "fileName", "lineNumber", "endLineNumber", "message", "name", "number", "stack"];
  function Iz($18, q) {
    var K = q && q.loc, P = void 0, _ = void 0, Y = void 0, O = void 0;
    if (K) P = K.start.line, _ = K.end.line, Y = K.start.column, O = K.end.column, $18 += " - " + P + ":" + Y;
    var z = Error.prototype.constructor.call(this, $18);
    for (var J = 0; J < Rz.length; J++) this[Rz[J]] = z[Rz[J]];
    if (Error.captureStackTrace) Error.captureStackTrace(this, Iz);
    try {
      if (K) if (this.lineNumber = P, this.endLineNumber = _, Object.defineProperty) Object.defineProperty(this, "column", { value: Y, enumerable: true }), Object.defineProperty(this, "endColumn", { value: O, enumerable: true });
      else this.column = Y, this.endColumn = O;
    } catch (T) {
    }
  }
  Iz.prototype = Error();
  nA.default = Iz;
  iA.exports = nA.default;
});
var UA = x$((BA, tA) => {
  BA.__esModule = true;
  var Dz = pq();
  BA.default = function($18) {
    $18.registerHelper("blockHelperMissing", function(q, K) {
      var { inverse: P, fn: _ } = K;
      if (q === true) return _(this);
      else if (q === false || q == null) return P(this);
      else if (Dz.isArray(q)) if (q.length > 0) {
        if (K.ids) K.ids = [K.name];
        return $18.helpers.each(q, K);
      } else return P(this);
      else {
        if (K.data && K.ids) {
          var Y = Dz.createFrame(K.data);
          Y.contextPath = Dz.appendContextPath(K.data.contextPath, K.name), K = { data: Y };
        }
        return _(q, K);
      }
    });
  };
  tA.exports = BA.default;
});
var QA = x$((FA, aA) => {
  FA.__esModule = true;
  function Ny($18) {
    return $18 && $18.__esModule ? $18 : { default: $18 };
  }
  var M7 = pq(), Cy = k8(), Ey = Ny(Cy);
  FA.default = function($18) {
    $18.registerHelper("each", function(q, K) {
      if (!K) throw new Ey.default("Must pass iterator to #each");
      var { fn: P, inverse: _ } = K, Y = 0, O = "", z = void 0, J = void 0;
      if (K.data && K.ids) J = M7.appendContextPath(K.data.contextPath, K.ids[0]) + ".";
      if (M7.isFunction(q)) q = q.call(this);
      if (K.data) z = M7.createFrame(K.data);
      function T(N, h, E) {
        if (z) {
          if (z.key = N, z.index = h, z.first = h === 0, z.last = !!E, J) z.contextPath = J + N;
        }
        O = O + P(q[N], { data: z, blockParams: M7.blockParams([q[N], N], [J + N, null]) });
      }
      if (q && typeof q === "object") if (M7.isArray(q)) {
        for (var X = q.length; Y < X; Y++) if (Y in q) T(Y, Y, Y === q.length - 1);
      } else if (typeof Symbol === "function" && q[Symbol.iterator]) {
        var f = [], V = q[Symbol.iterator]();
        for (var M = V.next(); !M.done; M = V.next()) f.push(M.value);
        q = f;
        for (var X = q.length; Y < X; Y++) T(Y, Y, Y === q.length - 1);
      } else (function() {
        var N = void 0;
        if (Object.keys(q).forEach(function(h) {
          if (N !== void 0) T(N, Y - 1);
          N = h, Y++;
        }), N !== void 0) T(N, Y - 1, true);
      })();
      if (Y === 0) O = _(this);
      return O;
    });
  };
  aA.exports = FA.default;
});
var $k = x$((eA, sA) => {
  eA.__esModule = true;
  function Iy($18) {
    return $18 && $18.__esModule ? $18 : { default: $18 };
  }
  var Dy = k8(), Ly = Iy(Dy);
  eA.default = function($18) {
    $18.registerHelper("helperMissing", function() {
      if (arguments.length === 1) return;
      else throw new Ly.default('Missing helper: "' + arguments[arguments.length - 1].name + '"');
    });
  };
  sA.exports = eA.default;
});
var Ok = x$((_k, Pk) => {
  _k.__esModule = true;
  function yy($18) {
    return $18 && $18.__esModule ? $18 : { default: $18 };
  }
  var qk = pq(), uy = k8(), Kk = yy(uy);
  _k.default = function($18) {
    $18.registerHelper("if", function(q, K) {
      if (arguments.length != 2) throw new Kk.default("#if requires exactly one argument");
      if (qk.isFunction(q)) q = q.call(this);
      if (!K.hash.includeZero && !q || qk.isEmpty(q)) return K.inverse(this);
      else return K.fn(this);
    }), $18.registerHelper("unless", function(q, K) {
      if (arguments.length != 2) throw new Kk.default("#unless requires exactly one argument");
      return $18.helpers.if.call(this, q, { fn: K.inverse, inverse: K.fn, hash: K.hash });
    });
  };
  Pk.exports = _k.default;
});
var vk = x$((Yk, jk) => {
  Yk.__esModule = true;
  Yk.default = function($18) {
    $18.registerHelper("log", function() {
      var q = [void 0], K = arguments[arguments.length - 1];
      for (var P = 0; P < arguments.length - 1; P++) q.push(arguments[P]);
      var _ = 1;
      if (K.hash.level != null) _ = K.hash.level;
      else if (K.data && K.data.level != null) _ = K.data.level;
      q[0] = _, $18.log.apply($18, q);
    });
  };
  jk.exports = Yk.default;
});
var Hk = x$((zk, Wk) => {
  zk.__esModule = true;
  zk.default = function($18) {
    $18.registerHelper("lookup", function(q, K, P) {
      if (!q) return q;
      return P.lookupProperty(q, K);
    });
  };
  Wk.exports = zk.default;
});
var wk = x$((Jk, Tk) => {
  Jk.__esModule = true;
  function ry($18) {
    return $18 && $18.__esModule ? $18 : { default: $18 };
  }
  var N7 = pq(), oy = k8(), ny = ry(oy);
  Jk.default = function($18) {
    $18.registerHelper("with", function(q, K) {
      if (arguments.length != 2) throw new ny.default("#with requires exactly one argument");
      if (N7.isFunction(q)) q = q.call(this);
      var P = K.fn;
      if (!N7.isEmpty(q)) {
        var _ = K.data;
        if (K.data && K.ids) _ = N7.createFrame(K.data), _.contextPath = N7.appendContextPath(K.data.contextPath, K.ids[0]);
        return P(q, { data: _, blockParams: N7.blockParams([q], [_ && _.contextPath]) });
      } else return K.inverse(this);
    });
  };
  Tk.exports = Jk.default;
});
var Lz = x$((zu) => {
  zu.__esModule = true;
  zu.registerDefaultHelpers = ju;
  zu.moveHelperToHooks = vu;
  function N_($18) {
    return $18 && $18.__esModule ? $18 : { default: $18 };
  }
  var ty = UA(), Uy = N_(ty), Fy = QA(), ay = N_(Fy), Qy = $k(), ey = N_(Qy), sy = Ok(), $u = N_(sy), qu = vk(), Ku = N_(qu), _u = Hk(), Pu = N_(_u), Ou = wk(), Yu = N_(Ou);
  function ju($18) {
    Uy.default($18), ay.default($18), ey.default($18), $u.default($18), Ku.default($18), Pu.default($18), Yu.default($18);
  }
  function vu($18, q, K) {
    if ($18.helpers[q]) {
      if ($18.hooks[q] = $18.helpers[q], !K) delete $18.helpers[q];
    }
  }
});
var Xk = x$((fk, Zk) => {
  fk.__esModule = true;
  var Tu = pq();
  fk.default = function($18) {
    $18.registerDecorator("inline", function(q, K, P, _) {
      var Y = q;
      if (!K.partials) K.partials = {}, Y = function(O, z) {
        var J = P.partials;
        P.partials = Tu.extend({}, J, K.partials);
        var T = q(O, z);
        return P.partials = J, T;
      };
      return K.partials[_.args[0]] = _.fn, Y;
    });
  };
  Zk.exports = fk.default;
});
var Ak = x$((Gu) => {
  Gu.__esModule = true;
  Gu.registerDefaultDecorators = ku;
  function Zu($18) {
    return $18 && $18.__esModule ? $18 : { default: $18 };
  }
  var Xu = Xk(), Au = Zu(Xu);
  function ku($18) {
    Au.default($18);
  }
});
var gz = x$((kk, Gk) => {
  kk.__esModule = true;
  var Mu = pq(), M4 = { methodMap: ["debug", "info", "warn", "error"], level: "info", lookupLevel: function(q) {
    if (typeof q === "string") {
      var K = Mu.indexOf(M4.methodMap, q.toLowerCase());
      if (K >= 0) q = K;
      else q = parseInt(q, 10);
    }
    return q;
  }, log: function(q) {
    if (q = M4.lookupLevel(q), typeof console < "u" && M4.lookupLevel(M4.level) <= q) {
      var K = M4.methodMap[q];
      if (!console[K]) K = "log";
      for (var P = arguments.length, _ = Array(P > 1 ? P - 1 : 0), Y = 1; Y < P; Y++) _[Y - 1] = arguments[Y];
      console[K].apply(console, _);
    }
  } };
  kk.default = M4;
  Gk.exports = kk.default;
});
var Vk = x$((Ru) => {
  Ru.__esModule = true;
  Ru.createNewLookupObject = hu;
  var Eu = pq();
  function hu() {
    for (var $18 = arguments.length, q = Array($18), K = 0; K < $18; K++) q[K] = arguments[K];
    return Eu.extend.apply(void 0, [/* @__PURE__ */ Object.create(null)].concat(q));
  }
});
var bz = x$((cu) => {
  cu.__esModule = true;
  cu.createProtoAccessControl = yu;
  cu.resultIsAllowed = uu;
  cu.resetLoggedProperties = pu;
  function Lu($18) {
    return $18 && $18.__esModule ? $18 : { default: $18 };
  }
  var Sk = Vk(), gu = gz(), bu = Lu(gu), k5 = /* @__PURE__ */ Object.create(null);
  function yu($18) {
    var q = /* @__PURE__ */ Object.create(null);
    q.constructor = false, q.__defineGetter__ = false, q.__defineSetter__ = false, q.__lookupGetter__ = false;
    var K = /* @__PURE__ */ Object.create(null);
    return K.__proto__ = false, { properties: { whitelist: Sk.createNewLookupObject(K, $18.allowedProtoProperties), defaultValue: $18.allowProtoPropertiesByDefault }, methods: { whitelist: Sk.createNewLookupObject(q, $18.allowedProtoMethods), defaultValue: $18.allowProtoMethodsByDefault } };
  }
  function uu($18, q, K) {
    if (typeof $18 === "function") return Mk(q.methods, K);
    else return Mk(q.properties, K);
  }
  function Mk($18, q) {
    if ($18.whitelist[q] !== void 0) return $18.whitelist[q] === true;
    if ($18.defaultValue !== void 0) return $18.defaultValue;
    return xu(q), false;
  }
  function xu($18) {
    if (k5[$18] !== true) k5[$18] = true, bu.default.log("error", 'Handlebars: Access has been denied to resolve the property "' + $18 + `" because it is not an "own property" of its parent.
You can add a runtime option to disable the check or this warning:
See https://handlebarsjs.com/api-reference/runtime-options.html#options-to-control-prototype-access for details`);
  }
  function pu() {
    Object.keys(k5).forEach(function($18) {
      delete k5[$18];
    });
  }
});
var V5 = x$((su) => {
  su.__esModule = true;
  su.HandlebarsEnvironment = xz;
  function Nk($18) {
    return $18 && $18.__esModule ? $18 : { default: $18 };
  }
  var C_ = pq(), ou = k8(), yz = Nk(ou), nu = Lz(), iu = Ak(), Bu = gz(), G5 = Nk(Bu), tu = bz(), Uu = "4.7.8";
  su.VERSION = Uu;
  var Fu = 8;
  su.COMPILER_REVISION = Fu;
  var au = 7;
  su.LAST_COMPATIBLE_COMPILER_REVISION = au;
  var Qu = { 1: "<= 1.0.rc.2", 2: "== 1.0.0-rc.3", 3: "== 1.0.0-rc.4", 4: "== 1.x.x", 5: "== 2.0.0-alpha.x", 6: ">= 2.0.0-beta.1", 7: ">= 4.0.0 <4.3.0", 8: ">= 4.3.0" };
  su.REVISION_CHANGES = Qu;
  var uz = "[object Object]";
  function xz($18, q, K) {
    this.helpers = $18 || {}, this.partials = q || {}, this.decorators = K || {}, nu.registerDefaultHelpers(this), iu.registerDefaultDecorators(this);
  }
  xz.prototype = { constructor: xz, logger: G5.default, log: G5.default.log, registerHelper: function(q, K) {
    if (C_.toString.call(q) === uz) {
      if (K) throw new yz.default("Arg not supported with multiple helpers");
      C_.extend(this.helpers, q);
    } else this.helpers[q] = K;
  }, unregisterHelper: function(q) {
    delete this.helpers[q];
  }, registerPartial: function(q, K) {
    if (C_.toString.call(q) === uz) C_.extend(this.partials, q);
    else {
      if (typeof K > "u") throw new yz.default('Attempting to register a partial called "' + q + '" as undefined');
      this.partials[q] = K;
    }
  }, unregisterPartial: function(q) {
    delete this.partials[q];
  }, registerDecorator: function(q, K) {
    if (C_.toString.call(q) === uz) {
      if (K) throw new yz.default("Arg not supported with multiple decorators");
      C_.extend(this.decorators, q);
    } else this.decorators[q] = K;
  }, unregisterDecorator: function(q) {
    delete this.decorators[q];
  }, resetLoggedPropertyAccesses: function() {
    tu.resetLoggedProperties();
  } };
  var eu = G5.default.log;
  su.log = eu;
  su.createFrame = C_.createFrame;
  su.logger = G5.default;
});
var hk = x$((Ck, Ek) => {
  Ck.__esModule = true;
  function pz($18) {
    this.string = $18;
  }
  pz.prototype.toString = pz.prototype.toHTML = function() {
    return "" + this.string;
  };
  Ck.default = pz;
  Ek.exports = Ck.default;
});
var Rk = x$((Jx) => {
  Jx.__esModule = true;
  Jx.wrapHelper = Hx;
  function Hx($18, q) {
    if (typeof $18 !== "function") return $18;
    var K = function() {
      var _ = arguments[arguments.length - 1];
      return arguments[arguments.length - 1] = q(_), $18.apply(this, arguments);
    };
    return K;
  }
});
var bk = x$((hx) => {
  hx.__esModule = true;
  hx.checkRevision = Gx;
  hx.template = Vx;
  hx.wrapProgram = S5;
  hx.resolvePartial = Sx;
  hx.invokePartial = Mx;
  hx.noop = Lk;
  function fx($18) {
    return $18 && $18.__esModule ? $18 : { default: $18 };
  }
  function Zx($18) {
    if ($18 && $18.__esModule) return $18;
    else {
      var q = {};
      if ($18 != null) {
        for (var K in $18) if (Object.prototype.hasOwnProperty.call($18, K)) q[K] = $18[K];
      }
      return q.default = $18, q;
    }
  }
  var Xx = pq(), fK = Zx(Xx), Ax = k8(), ZK = fx(Ax), XK = V5(), Ik = Lz(), kx = Rk(), Dk = bz();
  function Gx($18) {
    var q = $18 && $18[0] || 1, K = XK.COMPILER_REVISION;
    if (q >= XK.LAST_COMPATIBLE_COMPILER_REVISION && q <= XK.COMPILER_REVISION) return;
    if (q < XK.LAST_COMPATIBLE_COMPILER_REVISION) {
      var P = XK.REVISION_CHANGES[K], _ = XK.REVISION_CHANGES[q];
      throw new ZK.default("Template was precompiled with an older version of Handlebars than the current runtime. Please update your precompiler to a newer version (" + P + ") or downgrade your runtime to an older version (" + _ + ").");
    } else throw new ZK.default("Template was precompiled with a newer version of Handlebars than the current runtime. Please update your runtime to a newer version (" + $18[1] + ").");
  }
  function Vx($18, q) {
    if (!q) throw new ZK.default("No environment passed to template");
    if (!$18 || !$18.main) throw new ZK.default("Unknown template object: " + typeof $18);
    $18.main.decorator = $18.main_d, q.VM.checkRevision($18.compiler);
    var K = $18.compiler && $18.compiler[0] === 7;
    function P(O, z, J) {
      if (J.hash) {
        if (z = fK.extend({}, z, J.hash), J.ids) J.ids[0] = true;
      }
      O = q.VM.resolvePartial.call(this, O, z, J);
      var T = fK.extend({}, J, { hooks: this.hooks, protoAccessControl: this.protoAccessControl }), X = q.VM.invokePartial.call(this, O, z, T);
      if (X == null && q.compile) J.partials[J.name] = q.compile(O, $18.compilerOptions, q), X = J.partials[J.name](z, T);
      if (X != null) {
        if (J.indent) {
          var f = X.split(`
`);
          for (var V = 0, M = f.length; V < M; V++) {
            if (!f[V] && V + 1 === M) break;
            f[V] = J.indent + f[V];
          }
          X = f.join(`
`);
        }
        return X;
      } else throw new ZK.default("The partial " + J.name + " could not be compiled when running in runtime-only mode");
    }
    var _ = { strict: function(z, J, T) {
      if (!z || !(J in z)) throw new ZK.default('"' + J + '" not defined in ' + z, { loc: T });
      return _.lookupProperty(z, J);
    }, lookupProperty: function(z, J) {
      var T = z[J];
      if (T == null) return T;
      if (Object.prototype.hasOwnProperty.call(z, J)) return T;
      if (Dk.resultIsAllowed(T, _.protoAccessControl, J)) return T;
      return;
    }, lookup: function(z, J) {
      var T = z.length;
      for (var X = 0; X < T; X++) {
        var f = z[X] && _.lookupProperty(z[X], J);
        if (f != null) return z[X][J];
      }
    }, lambda: function(z, J) {
      return typeof z === "function" ? z.call(J) : z;
    }, escapeExpression: fK.escapeExpression, invokePartial: P, fn: function(z) {
      var J = $18[z];
      return J.decorator = $18[z + "_d"], J;
    }, programs: [], program: function(z, J, T, X, f) {
      var V = this.programs[z], M = this.fn(z);
      if (J || f || X || T) V = S5(this, z, M, J, T, X, f);
      else if (!V) V = this.programs[z] = S5(this, z, M);
      return V;
    }, data: function(z, J) {
      while (z && J--) z = z._parent;
      return z;
    }, mergeIfNeeded: function(z, J) {
      var T = z || J;
      if (z && J && z !== J) T = fK.extend({}, J, z);
      return T;
    }, nullContext: Object.seal({}), noop: q.VM.noop, compilerInfo: $18.compiler };
    function Y(O) {
      var z = arguments.length <= 1 || arguments[1] === void 0 ? {} : arguments[1], J = z.data;
      if (Y._setup(z), !z.partial && $18.useData) J = Nx(O, J);
      var T = void 0, X = $18.useBlockParams ? [] : void 0;
      if ($18.useDepths) if (z.depths) T = O != z.depths[0] ? [O].concat(z.depths) : z.depths;
      else T = [O];
      function f(V) {
        return "" + $18.main(_, V, _.helpers, _.partials, J, X, T);
      }
      return f = gk($18.main, f, _, z.depths || [], J, X), f(O, z);
    }
    return Y.isTop = true, Y._setup = function(O) {
      if (!O.partial) {
        var z = fK.extend({}, q.helpers, O.helpers);
        if (Cx(z, _), _.helpers = z, $18.usePartial) _.partials = _.mergeIfNeeded(O.partials, q.partials);
        if ($18.usePartial || $18.useDecorators) _.decorators = fK.extend({}, q.decorators, O.decorators);
        _.hooks = {}, _.protoAccessControl = Dk.createProtoAccessControl(O);
        var J = O.allowCallsToHelperMissing || K;
        Ik.moveHelperToHooks(_, "helperMissing", J), Ik.moveHelperToHooks(_, "blockHelperMissing", J);
      } else _.protoAccessControl = O.protoAccessControl, _.helpers = O.helpers, _.partials = O.partials, _.decorators = O.decorators, _.hooks = O.hooks;
    }, Y._child = function(O, z, J, T) {
      if ($18.useBlockParams && !J) throw new ZK.default("must pass block params");
      if ($18.useDepths && !T) throw new ZK.default("must pass parent depths");
      return S5(_, O, $18[O], z, 0, J, T);
    }, Y;
  }
  function S5($18, q, K, P, _, Y, O) {
    function z(J) {
      var T = arguments.length <= 1 || arguments[1] === void 0 ? {} : arguments[1], X = O;
      if (O && J != O[0] && !(J === $18.nullContext && O[0] === null)) X = [J].concat(O);
      return K($18, J, $18.helpers, $18.partials, T.data || P, Y && [T.blockParams].concat(Y), X);
    }
    return z = gk(K, z, $18, O, P, Y), z.program = q, z.depth = O ? O.length : 0, z.blockParams = _ || 0, z;
  }
  function Sx($18, q, K) {
    if (!$18) if (K.name === "@partial-block") $18 = K.data["partial-block"];
    else $18 = K.partials[K.name];
    else if (!$18.call && !K.name) K.name = $18, $18 = K.partials[$18];
    return $18;
  }
  function Mx($18, q, K) {
    var P = K.data && K.data["partial-block"];
    if (K.partial = true, K.ids) K.data.contextPath = K.ids[0] || K.data.contextPath;
    var _ = void 0;
    if (K.fn && K.fn !== Lk) (function() {
      K.data = XK.createFrame(K.data);
      var Y = K.fn;
      if (_ = K.data["partial-block"] = function(z) {
        var J = arguments.length <= 1 || arguments[1] === void 0 ? {} : arguments[1];
        return J.data = XK.createFrame(J.data), J.data["partial-block"] = P, Y(z, J);
      }, Y.partials) K.partials = fK.extend({}, K.partials, Y.partials);
    })();
    if ($18 === void 0 && _) $18 = _;
    if ($18 === void 0) throw new ZK.default("The partial " + K.name + " could not be found");
    else if ($18 instanceof Function) return $18(q, K);
  }
  function Lk() {
    return "";
  }
  function Nx($18, q) {
    if (!q || !("root" in q)) q = q ? XK.createFrame(q) : {}, q.root = $18;
    return q;
  }
  function gk($18, q, K, P, _, Y) {
    if ($18.decorator) {
      var O = {};
      q = $18.decorator(q, O, K, P && P[0], _, Y, P), fK.extend(q, O);
    }
    return q;
  }
  function Cx($18, q) {
    Object.keys($18).forEach(function(K) {
      var P = $18[K];
      $18[K] = Ex(P, q);
    });
  }
  function Ex($18, q) {
    var K = q.lookupProperty;
    return kx.wrapHelper($18, function(P) {
      return fK.extend({ lookupProperty: K }, P);
    });
  }
});
var cz = x$((yk, uk) => {
  yk.__esModule = true;
  yk.default = function($18) {
    (function() {
      if (typeof globalThis === "object") return;
      Object.prototype.__defineGetter__("__magic__", function() {
        return this;
      }), __magic__.globalThis = __magic__, delete Object.prototype.__magic__;
    })();
    var q = globalThis.Handlebars;
    $18.noConflict = function() {
      if (globalThis.Handlebars === $18) globalThis.Handlebars = q;
      return $18;
    };
  };
  uk.exports = yk.default;
});
var lk = x$((mk, dk) => {
  mk.__esModule = true;
  function dz($18) {
    return $18 && $18.__esModule ? $18 : { default: $18 };
  }
  function lz($18) {
    if ($18 && $18.__esModule) return $18;
    else {
      var q = {};
      if ($18 != null) {
        for (var K in $18) if (Object.prototype.hasOwnProperty.call($18, K)) q[K] = $18[K];
      }
      return q.default = $18, q;
    }
  }
  var px = V5(), xk = lz(px), cx = hk(), mx = dz(cx), dx = k8(), lx = dz(dx), rx = pq(), mz = lz(rx), ox = bk(), pk = lz(ox), nx = cz(), ix = dz(nx);
  function ck() {
    var $18 = new xk.HandlebarsEnvironment();
    return mz.extend($18, xk), $18.SafeString = mx.default, $18.Exception = lx.default, $18.Utils = mz, $18.escapeExpression = mz.escapeExpression, $18.VM = pk, $18.template = function(q) {
      return pk.template(q, $18);
    }, $18;
  }
  var C7 = ck();
  C7.create = ck;
  ix.default(C7);
  C7.default = C7;
  mk.default = C7;
  dk.exports = mk.default;
});
var rz = x$((ok, nk) => {
  ok.__esModule = true;
  var rk = { helpers: { helperExpression: function(q) {
    return q.type === "SubExpression" || (q.type === "MustacheStatement" || q.type === "BlockStatement") && !!(q.params && q.params.length || q.hash);
  }, scopedId: function(q) {
    return /^\.|this\b/.test(q.original);
  }, simpleId: function(q) {
    return q.parts.length === 1 && !rk.helpers.scopedId(q) && !q.depth;
  } } };
  ok.default = rk;
  nk.exports = ok.default;
});
var tk = x$((ik, Bk) => {
  ik.__esModule = true;
  var ax = function() {
    var $18 = { trace: function() {
    }, yy: {}, symbols_: { error: 2, root: 3, program: 4, EOF: 5, program_repetition0: 6, statement: 7, mustache: 8, block: 9, rawBlock: 10, partial: 11, partialBlock: 12, content: 13, COMMENT: 14, CONTENT: 15, openRawBlock: 16, rawBlock_repetition0: 17, END_RAW_BLOCK: 18, OPEN_RAW_BLOCK: 19, helperName: 20, openRawBlock_repetition0: 21, openRawBlock_option0: 22, CLOSE_RAW_BLOCK: 23, openBlock: 24, block_option0: 25, closeBlock: 26, openInverse: 27, block_option1: 28, OPEN_BLOCK: 29, openBlock_repetition0: 30, openBlock_option0: 31, openBlock_option1: 32, CLOSE: 33, OPEN_INVERSE: 34, openInverse_repetition0: 35, openInverse_option0: 36, openInverse_option1: 37, openInverseChain: 38, OPEN_INVERSE_CHAIN: 39, openInverseChain_repetition0: 40, openInverseChain_option0: 41, openInverseChain_option1: 42, inverseAndProgram: 43, INVERSE: 44, inverseChain: 45, inverseChain_option0: 46, OPEN_ENDBLOCK: 47, OPEN: 48, mustache_repetition0: 49, mustache_option0: 50, OPEN_UNESCAPED: 51, mustache_repetition1: 52, mustache_option1: 53, CLOSE_UNESCAPED: 54, OPEN_PARTIAL: 55, partialName: 56, partial_repetition0: 57, partial_option0: 58, openPartialBlock: 59, OPEN_PARTIAL_BLOCK: 60, openPartialBlock_repetition0: 61, openPartialBlock_option0: 62, param: 63, sexpr: 64, OPEN_SEXPR: 65, sexpr_repetition0: 66, sexpr_option0: 67, CLOSE_SEXPR: 68, hash: 69, hash_repetition_plus0: 70, hashSegment: 71, ID: 72, EQUALS: 73, blockParams: 74, OPEN_BLOCK_PARAMS: 75, blockParams_repetition_plus0: 76, CLOSE_BLOCK_PARAMS: 77, path: 78, dataName: 79, STRING: 80, NUMBER: 81, BOOLEAN: 82, UNDEFINED: 83, NULL: 84, DATA: 85, pathSegments: 86, SEP: 87, $accept: 0, $end: 1 }, terminals_: { 2: "error", 5: "EOF", 14: "COMMENT", 15: "CONTENT", 18: "END_RAW_BLOCK", 19: "OPEN_RAW_BLOCK", 23: "CLOSE_RAW_BLOCK", 29: "OPEN_BLOCK", 33: "CLOSE", 34: "OPEN_INVERSE", 39: "OPEN_INVERSE_CHAIN", 44: "INVERSE", 47: "OPEN_ENDBLOCK", 48: "OPEN", 51: "OPEN_UNESCAPED", 54: "CLOSE_UNESCAPED", 55: "OPEN_PARTIAL", 60: "OPEN_PARTIAL_BLOCK", 65: "OPEN_SEXPR", 68: "CLOSE_SEXPR", 72: "ID", 73: "EQUALS", 75: "OPEN_BLOCK_PARAMS", 77: "CLOSE_BLOCK_PARAMS", 80: "STRING", 81: "NUMBER", 82: "BOOLEAN", 83: "UNDEFINED", 84: "NULL", 85: "DATA", 87: "SEP" }, productions_: [0, [3, 2], [4, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [13, 1], [10, 3], [16, 5], [9, 4], [9, 4], [24, 6], [27, 6], [38, 6], [43, 2], [45, 3], [45, 1], [26, 3], [8, 5], [8, 5], [11, 5], [12, 3], [59, 5], [63, 1], [63, 1], [64, 5], [69, 1], [71, 3], [74, 3], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [56, 1], [56, 1], [79, 2], [78, 1], [86, 3], [86, 1], [6, 0], [6, 2], [17, 0], [17, 2], [21, 0], [21, 2], [22, 0], [22, 1], [25, 0], [25, 1], [28, 0], [28, 1], [30, 0], [30, 2], [31, 0], [31, 1], [32, 0], [32, 1], [35, 0], [35, 2], [36, 0], [36, 1], [37, 0], [37, 1], [40, 0], [40, 2], [41, 0], [41, 1], [42, 0], [42, 1], [46, 0], [46, 1], [49, 0], [49, 2], [50, 0], [50, 1], [52, 0], [52, 2], [53, 0], [53, 1], [57, 0], [57, 2], [58, 0], [58, 1], [61, 0], [61, 2], [62, 0], [62, 1], [66, 0], [66, 2], [67, 0], [67, 1], [70, 1], [70, 2], [76, 1], [76, 2]], performAction: function(_, Y, O, z, J, T, X) {
      var f = T.length - 1;
      switch (J) {
        case 1:
          return T[f - 1];
        case 2:
          this.$ = z.prepareProgram(T[f]);
          break;
        case 3:
          this.$ = T[f];
          break;
        case 4:
          this.$ = T[f];
          break;
        case 5:
          this.$ = T[f];
          break;
        case 6:
          this.$ = T[f];
          break;
        case 7:
          this.$ = T[f];
          break;
        case 8:
          this.$ = T[f];
          break;
        case 9:
          this.$ = { type: "CommentStatement", value: z.stripComment(T[f]), strip: z.stripFlags(T[f], T[f]), loc: z.locInfo(this._$) };
          break;
        case 10:
          this.$ = { type: "ContentStatement", original: T[f], value: T[f], loc: z.locInfo(this._$) };
          break;
        case 11:
          this.$ = z.prepareRawBlock(T[f - 2], T[f - 1], T[f], this._$);
          break;
        case 12:
          this.$ = { path: T[f - 3], params: T[f - 2], hash: T[f - 1] };
          break;
        case 13:
          this.$ = z.prepareBlock(T[f - 3], T[f - 2], T[f - 1], T[f], false, this._$);
          break;
        case 14:
          this.$ = z.prepareBlock(T[f - 3], T[f - 2], T[f - 1], T[f], true, this._$);
          break;
        case 15:
          this.$ = { open: T[f - 5], path: T[f - 4], params: T[f - 3], hash: T[f - 2], blockParams: T[f - 1], strip: z.stripFlags(T[f - 5], T[f]) };
          break;
        case 16:
          this.$ = { path: T[f - 4], params: T[f - 3], hash: T[f - 2], blockParams: T[f - 1], strip: z.stripFlags(T[f - 5], T[f]) };
          break;
        case 17:
          this.$ = { path: T[f - 4], params: T[f - 3], hash: T[f - 2], blockParams: T[f - 1], strip: z.stripFlags(T[f - 5], T[f]) };
          break;
        case 18:
          this.$ = { strip: z.stripFlags(T[f - 1], T[f - 1]), program: T[f] };
          break;
        case 19:
          var V = z.prepareBlock(T[f - 2], T[f - 1], T[f], T[f], false, this._$), M = z.prepareProgram([V], T[f - 1].loc);
          M.chained = true, this.$ = { strip: T[f - 2].strip, program: M, chain: true };
          break;
        case 20:
          this.$ = T[f];
          break;
        case 21:
          this.$ = { path: T[f - 1], strip: z.stripFlags(T[f - 2], T[f]) };
          break;
        case 22:
          this.$ = z.prepareMustache(T[f - 3], T[f - 2], T[f - 1], T[f - 4], z.stripFlags(T[f - 4], T[f]), this._$);
          break;
        case 23:
          this.$ = z.prepareMustache(T[f - 3], T[f - 2], T[f - 1], T[f - 4], z.stripFlags(T[f - 4], T[f]), this._$);
          break;
        case 24:
          this.$ = { type: "PartialStatement", name: T[f - 3], params: T[f - 2], hash: T[f - 1], indent: "", strip: z.stripFlags(T[f - 4], T[f]), loc: z.locInfo(this._$) };
          break;
        case 25:
          this.$ = z.preparePartialBlock(T[f - 2], T[f - 1], T[f], this._$);
          break;
        case 26:
          this.$ = { path: T[f - 3], params: T[f - 2], hash: T[f - 1], strip: z.stripFlags(T[f - 4], T[f]) };
          break;
        case 27:
          this.$ = T[f];
          break;
        case 28:
          this.$ = T[f];
          break;
        case 29:
          this.$ = { type: "SubExpression", path: T[f - 3], params: T[f - 2], hash: T[f - 1], loc: z.locInfo(this._$) };
          break;
        case 30:
          this.$ = { type: "Hash", pairs: T[f], loc: z.locInfo(this._$) };
          break;
        case 31:
          this.$ = { type: "HashPair", key: z.id(T[f - 2]), value: T[f], loc: z.locInfo(this._$) };
          break;
        case 32:
          this.$ = z.id(T[f - 1]);
          break;
        case 33:
          this.$ = T[f];
          break;
        case 34:
          this.$ = T[f];
          break;
        case 35:
          this.$ = { type: "StringLiteral", value: T[f], original: T[f], loc: z.locInfo(this._$) };
          break;
        case 36:
          this.$ = { type: "NumberLiteral", value: Number(T[f]), original: Number(T[f]), loc: z.locInfo(this._$) };
          break;
        case 37:
          this.$ = { type: "BooleanLiteral", value: T[f] === "true", original: T[f] === "true", loc: z.locInfo(this._$) };
          break;
        case 38:
          this.$ = { type: "UndefinedLiteral", original: void 0, value: void 0, loc: z.locInfo(this._$) };
          break;
        case 39:
          this.$ = { type: "NullLiteral", original: null, value: null, loc: z.locInfo(this._$) };
          break;
        case 40:
          this.$ = T[f];
          break;
        case 41:
          this.$ = T[f];
          break;
        case 42:
          this.$ = z.preparePath(true, T[f], this._$);
          break;
        case 43:
          this.$ = z.preparePath(false, T[f], this._$);
          break;
        case 44:
          T[f - 2].push({ part: z.id(T[f]), original: T[f], separator: T[f - 1] }), this.$ = T[f - 2];
          break;
        case 45:
          this.$ = [{ part: z.id(T[f]), original: T[f] }];
          break;
        case 46:
          this.$ = [];
          break;
        case 47:
          T[f - 1].push(T[f]);
          break;
        case 48:
          this.$ = [];
          break;
        case 49:
          T[f - 1].push(T[f]);
          break;
        case 50:
          this.$ = [];
          break;
        case 51:
          T[f - 1].push(T[f]);
          break;
        case 58:
          this.$ = [];
          break;
        case 59:
          T[f - 1].push(T[f]);
          break;
        case 64:
          this.$ = [];
          break;
        case 65:
          T[f - 1].push(T[f]);
          break;
        case 70:
          this.$ = [];
          break;
        case 71:
          T[f - 1].push(T[f]);
          break;
        case 78:
          this.$ = [];
          break;
        case 79:
          T[f - 1].push(T[f]);
          break;
        case 82:
          this.$ = [];
          break;
        case 83:
          T[f - 1].push(T[f]);
          break;
        case 86:
          this.$ = [];
          break;
        case 87:
          T[f - 1].push(T[f]);
          break;
        case 90:
          this.$ = [];
          break;
        case 91:
          T[f - 1].push(T[f]);
          break;
        case 94:
          this.$ = [];
          break;
        case 95:
          T[f - 1].push(T[f]);
          break;
        case 98:
          this.$ = [T[f]];
          break;
        case 99:
          T[f - 1].push(T[f]);
          break;
        case 100:
          this.$ = [T[f]];
          break;
        case 101:
          T[f - 1].push(T[f]);
          break;
      }
    }, table: [{ 3: 1, 4: 2, 5: [2, 46], 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 1: [3] }, { 5: [1, 4] }, { 5: [2, 2], 7: 5, 8: 6, 9: 7, 10: 8, 11: 9, 12: 10, 13: 11, 14: [1, 12], 15: [1, 20], 16: 17, 19: [1, 23], 24: 15, 27: 16, 29: [1, 21], 34: [1, 22], 39: [2, 2], 44: [2, 2], 47: [2, 2], 48: [1, 13], 51: [1, 14], 55: [1, 18], 59: 19, 60: [1, 24] }, { 1: [2, 1] }, { 5: [2, 47], 14: [2, 47], 15: [2, 47], 19: [2, 47], 29: [2, 47], 34: [2, 47], 39: [2, 47], 44: [2, 47], 47: [2, 47], 48: [2, 47], 51: [2, 47], 55: [2, 47], 60: [2, 47] }, { 5: [2, 3], 14: [2, 3], 15: [2, 3], 19: [2, 3], 29: [2, 3], 34: [2, 3], 39: [2, 3], 44: [2, 3], 47: [2, 3], 48: [2, 3], 51: [2, 3], 55: [2, 3], 60: [2, 3] }, { 5: [2, 4], 14: [2, 4], 15: [2, 4], 19: [2, 4], 29: [2, 4], 34: [2, 4], 39: [2, 4], 44: [2, 4], 47: [2, 4], 48: [2, 4], 51: [2, 4], 55: [2, 4], 60: [2, 4] }, { 5: [2, 5], 14: [2, 5], 15: [2, 5], 19: [2, 5], 29: [2, 5], 34: [2, 5], 39: [2, 5], 44: [2, 5], 47: [2, 5], 48: [2, 5], 51: [2, 5], 55: [2, 5], 60: [2, 5] }, { 5: [2, 6], 14: [2, 6], 15: [2, 6], 19: [2, 6], 29: [2, 6], 34: [2, 6], 39: [2, 6], 44: [2, 6], 47: [2, 6], 48: [2, 6], 51: [2, 6], 55: [2, 6], 60: [2, 6] }, { 5: [2, 7], 14: [2, 7], 15: [2, 7], 19: [2, 7], 29: [2, 7], 34: [2, 7], 39: [2, 7], 44: [2, 7], 47: [2, 7], 48: [2, 7], 51: [2, 7], 55: [2, 7], 60: [2, 7] }, { 5: [2, 8], 14: [2, 8], 15: [2, 8], 19: [2, 8], 29: [2, 8], 34: [2, 8], 39: [2, 8], 44: [2, 8], 47: [2, 8], 48: [2, 8], 51: [2, 8], 55: [2, 8], 60: [2, 8] }, { 5: [2, 9], 14: [2, 9], 15: [2, 9], 19: [2, 9], 29: [2, 9], 34: [2, 9], 39: [2, 9], 44: [2, 9], 47: [2, 9], 48: [2, 9], 51: [2, 9], 55: [2, 9], 60: [2, 9] }, { 20: 25, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 36, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 4: 37, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 39: [2, 46], 44: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 4: 38, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 44: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 15: [2, 48], 17: 39, 18: [2, 48] }, { 20: 41, 56: 40, 64: 42, 65: [1, 43], 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 4: 44, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 5: [2, 10], 14: [2, 10], 15: [2, 10], 18: [2, 10], 19: [2, 10], 29: [2, 10], 34: [2, 10], 39: [2, 10], 44: [2, 10], 47: [2, 10], 48: [2, 10], 51: [2, 10], 55: [2, 10], 60: [2, 10] }, { 20: 45, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 46, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 47, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 41, 56: 48, 64: 42, 65: [1, 43], 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 33: [2, 78], 49: 49, 65: [2, 78], 72: [2, 78], 80: [2, 78], 81: [2, 78], 82: [2, 78], 83: [2, 78], 84: [2, 78], 85: [2, 78] }, { 23: [2, 33], 33: [2, 33], 54: [2, 33], 65: [2, 33], 68: [2, 33], 72: [2, 33], 75: [2, 33], 80: [2, 33], 81: [2, 33], 82: [2, 33], 83: [2, 33], 84: [2, 33], 85: [2, 33] }, { 23: [2, 34], 33: [2, 34], 54: [2, 34], 65: [2, 34], 68: [2, 34], 72: [2, 34], 75: [2, 34], 80: [2, 34], 81: [2, 34], 82: [2, 34], 83: [2, 34], 84: [2, 34], 85: [2, 34] }, { 23: [2, 35], 33: [2, 35], 54: [2, 35], 65: [2, 35], 68: [2, 35], 72: [2, 35], 75: [2, 35], 80: [2, 35], 81: [2, 35], 82: [2, 35], 83: [2, 35], 84: [2, 35], 85: [2, 35] }, { 23: [2, 36], 33: [2, 36], 54: [2, 36], 65: [2, 36], 68: [2, 36], 72: [2, 36], 75: [2, 36], 80: [2, 36], 81: [2, 36], 82: [2, 36], 83: [2, 36], 84: [2, 36], 85: [2, 36] }, { 23: [2, 37], 33: [2, 37], 54: [2, 37], 65: [2, 37], 68: [2, 37], 72: [2, 37], 75: [2, 37], 80: [2, 37], 81: [2, 37], 82: [2, 37], 83: [2, 37], 84: [2, 37], 85: [2, 37] }, { 23: [2, 38], 33: [2, 38], 54: [2, 38], 65: [2, 38], 68: [2, 38], 72: [2, 38], 75: [2, 38], 80: [2, 38], 81: [2, 38], 82: [2, 38], 83: [2, 38], 84: [2, 38], 85: [2, 38] }, { 23: [2, 39], 33: [2, 39], 54: [2, 39], 65: [2, 39], 68: [2, 39], 72: [2, 39], 75: [2, 39], 80: [2, 39], 81: [2, 39], 82: [2, 39], 83: [2, 39], 84: [2, 39], 85: [2, 39] }, { 23: [2, 43], 33: [2, 43], 54: [2, 43], 65: [2, 43], 68: [2, 43], 72: [2, 43], 75: [2, 43], 80: [2, 43], 81: [2, 43], 82: [2, 43], 83: [2, 43], 84: [2, 43], 85: [2, 43], 87: [1, 50] }, { 72: [1, 35], 86: 51 }, { 23: [2, 45], 33: [2, 45], 54: [2, 45], 65: [2, 45], 68: [2, 45], 72: [2, 45], 75: [2, 45], 80: [2, 45], 81: [2, 45], 82: [2, 45], 83: [2, 45], 84: [2, 45], 85: [2, 45], 87: [2, 45] }, { 52: 52, 54: [2, 82], 65: [2, 82], 72: [2, 82], 80: [2, 82], 81: [2, 82], 82: [2, 82], 83: [2, 82], 84: [2, 82], 85: [2, 82] }, { 25: 53, 38: 55, 39: [1, 57], 43: 56, 44: [1, 58], 45: 54, 47: [2, 54] }, { 28: 59, 43: 60, 44: [1, 58], 47: [2, 56] }, { 13: 62, 15: [1, 20], 18: [1, 61] }, { 33: [2, 86], 57: 63, 65: [2, 86], 72: [2, 86], 80: [2, 86], 81: [2, 86], 82: [2, 86], 83: [2, 86], 84: [2, 86], 85: [2, 86] }, { 33: [2, 40], 65: [2, 40], 72: [2, 40], 80: [2, 40], 81: [2, 40], 82: [2, 40], 83: [2, 40], 84: [2, 40], 85: [2, 40] }, { 33: [2, 41], 65: [2, 41], 72: [2, 41], 80: [2, 41], 81: [2, 41], 82: [2, 41], 83: [2, 41], 84: [2, 41], 85: [2, 41] }, { 20: 64, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 26: 65, 47: [1, 66] }, { 30: 67, 33: [2, 58], 65: [2, 58], 72: [2, 58], 75: [2, 58], 80: [2, 58], 81: [2, 58], 82: [2, 58], 83: [2, 58], 84: [2, 58], 85: [2, 58] }, { 33: [2, 64], 35: 68, 65: [2, 64], 72: [2, 64], 75: [2, 64], 80: [2, 64], 81: [2, 64], 82: [2, 64], 83: [2, 64], 84: [2, 64], 85: [2, 64] }, { 21: 69, 23: [2, 50], 65: [2, 50], 72: [2, 50], 80: [2, 50], 81: [2, 50], 82: [2, 50], 83: [2, 50], 84: [2, 50], 85: [2, 50] }, { 33: [2, 90], 61: 70, 65: [2, 90], 72: [2, 90], 80: [2, 90], 81: [2, 90], 82: [2, 90], 83: [2, 90], 84: [2, 90], 85: [2, 90] }, { 20: 74, 33: [2, 80], 50: 71, 63: 72, 64: 75, 65: [1, 43], 69: 73, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 72: [1, 79] }, { 23: [2, 42], 33: [2, 42], 54: [2, 42], 65: [2, 42], 68: [2, 42], 72: [2, 42], 75: [2, 42], 80: [2, 42], 81: [2, 42], 82: [2, 42], 83: [2, 42], 84: [2, 42], 85: [2, 42], 87: [1, 50] }, { 20: 74, 53: 80, 54: [2, 84], 63: 81, 64: 75, 65: [1, 43], 69: 82, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 26: 83, 47: [1, 66] }, { 47: [2, 55] }, { 4: 84, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 39: [2, 46], 44: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 47: [2, 20] }, { 20: 85, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 4: 86, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 26: 87, 47: [1, 66] }, { 47: [2, 57] }, { 5: [2, 11], 14: [2, 11], 15: [2, 11], 19: [2, 11], 29: [2, 11], 34: [2, 11], 39: [2, 11], 44: [2, 11], 47: [2, 11], 48: [2, 11], 51: [2, 11], 55: [2, 11], 60: [2, 11] }, { 15: [2, 49], 18: [2, 49] }, { 20: 74, 33: [2, 88], 58: 88, 63: 89, 64: 75, 65: [1, 43], 69: 90, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 65: [2, 94], 66: 91, 68: [2, 94], 72: [2, 94], 80: [2, 94], 81: [2, 94], 82: [2, 94], 83: [2, 94], 84: [2, 94], 85: [2, 94] }, { 5: [2, 25], 14: [2, 25], 15: [2, 25], 19: [2, 25], 29: [2, 25], 34: [2, 25], 39: [2, 25], 44: [2, 25], 47: [2, 25], 48: [2, 25], 51: [2, 25], 55: [2, 25], 60: [2, 25] }, { 20: 92, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 74, 31: 93, 33: [2, 60], 63: 94, 64: 75, 65: [1, 43], 69: 95, 70: 76, 71: 77, 72: [1, 78], 75: [2, 60], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 74, 33: [2, 66], 36: 96, 63: 97, 64: 75, 65: [1, 43], 69: 98, 70: 76, 71: 77, 72: [1, 78], 75: [2, 66], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 74, 22: 99, 23: [2, 52], 63: 100, 64: 75, 65: [1, 43], 69: 101, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 74, 33: [2, 92], 62: 102, 63: 103, 64: 75, 65: [1, 43], 69: 104, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 33: [1, 105] }, { 33: [2, 79], 65: [2, 79], 72: [2, 79], 80: [2, 79], 81: [2, 79], 82: [2, 79], 83: [2, 79], 84: [2, 79], 85: [2, 79] }, { 33: [2, 81] }, { 23: [2, 27], 33: [2, 27], 54: [2, 27], 65: [2, 27], 68: [2, 27], 72: [2, 27], 75: [2, 27], 80: [2, 27], 81: [2, 27], 82: [2, 27], 83: [2, 27], 84: [2, 27], 85: [2, 27] }, { 23: [2, 28], 33: [2, 28], 54: [2, 28], 65: [2, 28], 68: [2, 28], 72: [2, 28], 75: [2, 28], 80: [2, 28], 81: [2, 28], 82: [2, 28], 83: [2, 28], 84: [2, 28], 85: [2, 28] }, { 23: [2, 30], 33: [2, 30], 54: [2, 30], 68: [2, 30], 71: 106, 72: [1, 107], 75: [2, 30] }, { 23: [2, 98], 33: [2, 98], 54: [2, 98], 68: [2, 98], 72: [2, 98], 75: [2, 98] }, { 23: [2, 45], 33: [2, 45], 54: [2, 45], 65: [2, 45], 68: [2, 45], 72: [2, 45], 73: [1, 108], 75: [2, 45], 80: [2, 45], 81: [2, 45], 82: [2, 45], 83: [2, 45], 84: [2, 45], 85: [2, 45], 87: [2, 45] }, { 23: [2, 44], 33: [2, 44], 54: [2, 44], 65: [2, 44], 68: [2, 44], 72: [2, 44], 75: [2, 44], 80: [2, 44], 81: [2, 44], 82: [2, 44], 83: [2, 44], 84: [2, 44], 85: [2, 44], 87: [2, 44] }, { 54: [1, 109] }, { 54: [2, 83], 65: [2, 83], 72: [2, 83], 80: [2, 83], 81: [2, 83], 82: [2, 83], 83: [2, 83], 84: [2, 83], 85: [2, 83] }, { 54: [2, 85] }, { 5: [2, 13], 14: [2, 13], 15: [2, 13], 19: [2, 13], 29: [2, 13], 34: [2, 13], 39: [2, 13], 44: [2, 13], 47: [2, 13], 48: [2, 13], 51: [2, 13], 55: [2, 13], 60: [2, 13] }, { 38: 55, 39: [1, 57], 43: 56, 44: [1, 58], 45: 111, 46: 110, 47: [2, 76] }, { 33: [2, 70], 40: 112, 65: [2, 70], 72: [2, 70], 75: [2, 70], 80: [2, 70], 81: [2, 70], 82: [2, 70], 83: [2, 70], 84: [2, 70], 85: [2, 70] }, { 47: [2, 18] }, { 5: [2, 14], 14: [2, 14], 15: [2, 14], 19: [2, 14], 29: [2, 14], 34: [2, 14], 39: [2, 14], 44: [2, 14], 47: [2, 14], 48: [2, 14], 51: [2, 14], 55: [2, 14], 60: [2, 14] }, { 33: [1, 113] }, { 33: [2, 87], 65: [2, 87], 72: [2, 87], 80: [2, 87], 81: [2, 87], 82: [2, 87], 83: [2, 87], 84: [2, 87], 85: [2, 87] }, { 33: [2, 89] }, { 20: 74, 63: 115, 64: 75, 65: [1, 43], 67: 114, 68: [2, 96], 69: 116, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 33: [1, 117] }, { 32: 118, 33: [2, 62], 74: 119, 75: [1, 120] }, { 33: [2, 59], 65: [2, 59], 72: [2, 59], 75: [2, 59], 80: [2, 59], 81: [2, 59], 82: [2, 59], 83: [2, 59], 84: [2, 59], 85: [2, 59] }, { 33: [2, 61], 75: [2, 61] }, { 33: [2, 68], 37: 121, 74: 122, 75: [1, 120] }, { 33: [2, 65], 65: [2, 65], 72: [2, 65], 75: [2, 65], 80: [2, 65], 81: [2, 65], 82: [2, 65], 83: [2, 65], 84: [2, 65], 85: [2, 65] }, { 33: [2, 67], 75: [2, 67] }, { 23: [1, 123] }, { 23: [2, 51], 65: [2, 51], 72: [2, 51], 80: [2, 51], 81: [2, 51], 82: [2, 51], 83: [2, 51], 84: [2, 51], 85: [2, 51] }, { 23: [2, 53] }, { 33: [1, 124] }, { 33: [2, 91], 65: [2, 91], 72: [2, 91], 80: [2, 91], 81: [2, 91], 82: [2, 91], 83: [2, 91], 84: [2, 91], 85: [2, 91] }, { 33: [2, 93] }, { 5: [2, 22], 14: [2, 22], 15: [2, 22], 19: [2, 22], 29: [2, 22], 34: [2, 22], 39: [2, 22], 44: [2, 22], 47: [2, 22], 48: [2, 22], 51: [2, 22], 55: [2, 22], 60: [2, 22] }, { 23: [2, 99], 33: [2, 99], 54: [2, 99], 68: [2, 99], 72: [2, 99], 75: [2, 99] }, { 73: [1, 108] }, { 20: 74, 63: 125, 64: 75, 65: [1, 43], 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 5: [2, 23], 14: [2, 23], 15: [2, 23], 19: [2, 23], 29: [2, 23], 34: [2, 23], 39: [2, 23], 44: [2, 23], 47: [2, 23], 48: [2, 23], 51: [2, 23], 55: [2, 23], 60: [2, 23] }, { 47: [2, 19] }, { 47: [2, 77] }, { 20: 74, 33: [2, 72], 41: 126, 63: 127, 64: 75, 65: [1, 43], 69: 128, 70: 76, 71: 77, 72: [1, 78], 75: [2, 72], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 5: [2, 24], 14: [2, 24], 15: [2, 24], 19: [2, 24], 29: [2, 24], 34: [2, 24], 39: [2, 24], 44: [2, 24], 47: [2, 24], 48: [2, 24], 51: [2, 24], 55: [2, 24], 60: [2, 24] }, { 68: [1, 129] }, { 65: [2, 95], 68: [2, 95], 72: [2, 95], 80: [2, 95], 81: [2, 95], 82: [2, 95], 83: [2, 95], 84: [2, 95], 85: [2, 95] }, { 68: [2, 97] }, { 5: [2, 21], 14: [2, 21], 15: [2, 21], 19: [2, 21], 29: [2, 21], 34: [2, 21], 39: [2, 21], 44: [2, 21], 47: [2, 21], 48: [2, 21], 51: [2, 21], 55: [2, 21], 60: [2, 21] }, { 33: [1, 130] }, { 33: [2, 63] }, { 72: [1, 132], 76: 131 }, { 33: [1, 133] }, { 33: [2, 69] }, { 15: [2, 12], 18: [2, 12] }, { 14: [2, 26], 15: [2, 26], 19: [2, 26], 29: [2, 26], 34: [2, 26], 47: [2, 26], 48: [2, 26], 51: [2, 26], 55: [2, 26], 60: [2, 26] }, { 23: [2, 31], 33: [2, 31], 54: [2, 31], 68: [2, 31], 72: [2, 31], 75: [2, 31] }, { 33: [2, 74], 42: 134, 74: 135, 75: [1, 120] }, { 33: [2, 71], 65: [2, 71], 72: [2, 71], 75: [2, 71], 80: [2, 71], 81: [2, 71], 82: [2, 71], 83: [2, 71], 84: [2, 71], 85: [2, 71] }, { 33: [2, 73], 75: [2, 73] }, { 23: [2, 29], 33: [2, 29], 54: [2, 29], 65: [2, 29], 68: [2, 29], 72: [2, 29], 75: [2, 29], 80: [2, 29], 81: [2, 29], 82: [2, 29], 83: [2, 29], 84: [2, 29], 85: [2, 29] }, { 14: [2, 15], 15: [2, 15], 19: [2, 15], 29: [2, 15], 34: [2, 15], 39: [2, 15], 44: [2, 15], 47: [2, 15], 48: [2, 15], 51: [2, 15], 55: [2, 15], 60: [2, 15] }, { 72: [1, 137], 77: [1, 136] }, { 72: [2, 100], 77: [2, 100] }, { 14: [2, 16], 15: [2, 16], 19: [2, 16], 29: [2, 16], 34: [2, 16], 44: [2, 16], 47: [2, 16], 48: [2, 16], 51: [2, 16], 55: [2, 16], 60: [2, 16] }, { 33: [1, 138] }, { 33: [2, 75] }, { 33: [2, 32] }, { 72: [2, 101], 77: [2, 101] }, { 14: [2, 17], 15: [2, 17], 19: [2, 17], 29: [2, 17], 34: [2, 17], 39: [2, 17], 44: [2, 17], 47: [2, 17], 48: [2, 17], 51: [2, 17], 55: [2, 17], 60: [2, 17] }], defaultActions: { 4: [2, 1], 54: [2, 55], 56: [2, 20], 60: [2, 57], 73: [2, 81], 82: [2, 85], 86: [2, 18], 90: [2, 89], 101: [2, 53], 104: [2, 93], 110: [2, 19], 111: [2, 77], 116: [2, 97], 119: [2, 63], 122: [2, 69], 135: [2, 75], 136: [2, 32] }, parseError: function(_, Y) {
      throw Error(_);
    }, parse: function(_) {
      var Y = this, O = [0], z = [null], J = [], T = this.table, X = "", f = 0, V = 0, M = 0, N = 2, h = 1;
      if (this.lexer.setInput(_), this.lexer.yy = this.yy, this.yy.lexer = this.lexer, this.yy.parser = this, typeof this.lexer.yylloc > "u") this.lexer.yylloc = {};
      var E = this.lexer.yylloc;
      J.push(E);
      var I = this.lexer.options && this.lexer.options.ranges;
      if (typeof this.yy.parseError === "function") this.parseError = this.yy.parseError;
      function D(w) {
        O.length = O.length - 2 * w, z.length = z.length - w, J.length = J.length - w;
      }
      function g() {
        var w = Y.lexer.lex() || 1;
        if (typeof w !== "number") w = Y.symbols_[w] || w;
        return w;
      }
      var b, y, p, n, s, q$, c = {}, U, j, H, Z;
      while (true) {
        if (p = O[O.length - 1], this.defaultActions[p]) n = this.defaultActions[p];
        else {
          if (b === null || typeof b > "u") b = g();
          n = T[p] && T[p][b];
        }
        if (typeof n > "u" || !n.length || !n[0]) {
          var W = "";
          if (!M) {
            Z = [];
            for (U in T[p]) if (this.terminals_[U] && U > 2) Z.push("'" + this.terminals_[U] + "'");
            if (this.lexer.showPosition) W = "Parse error on line " + (f + 1) + `:
` + this.lexer.showPosition() + `
Expecting ` + Z.join(", ") + ", got '" + (this.terminals_[b] || b) + "'";
            else W = "Parse error on line " + (f + 1) + ": Unexpected " + (b == 1 ? "end of input" : "'" + (this.terminals_[b] || b) + "'");
            this.parseError(W, { text: this.lexer.match, token: this.terminals_[b] || b, line: this.lexer.yylineno, loc: E, expected: Z });
          }
        }
        if (n[0] instanceof Array && n.length > 1) throw Error("Parse Error: multiple actions possible at state: " + p + ", token: " + b);
        switch (n[0]) {
          case 1:
            if (O.push(b), z.push(this.lexer.yytext), J.push(this.lexer.yylloc), O.push(n[1]), b = null, !y) {
              if (V = this.lexer.yyleng, X = this.lexer.yytext, f = this.lexer.yylineno, E = this.lexer.yylloc, M > 0) M--;
            } else b = y, y = null;
            break;
          case 2:
            if (j = this.productions_[n[1]][1], c.$ = z[z.length - j], c._$ = { first_line: J[J.length - (j || 1)].first_line, last_line: J[J.length - 1].last_line, first_column: J[J.length - (j || 1)].first_column, last_column: J[J.length - 1].last_column }, I) c._$.range = [J[J.length - (j || 1)].range[0], J[J.length - 1].range[1]];
            if (q$ = this.performAction.call(c, X, V, f, this.yy, n[1], z, J), typeof q$ < "u") return q$;
            if (j) O = O.slice(0, -1 * j * 2), z = z.slice(0, -1 * j), J = J.slice(0, -1 * j);
            O.push(this.productions_[n[1]][0]), z.push(c.$), J.push(c._$), H = T[O[O.length - 2]][O[O.length - 1]], O.push(H);
            break;
          case 3:
            return true;
        }
      }
      return true;
    } }, q = function() {
      var P = { EOF: 1, parseError: function(Y, O) {
        if (this.yy.parser) this.yy.parser.parseError(Y, O);
        else throw Error(Y);
      }, setInput: function(Y) {
        if (this._input = Y, this._more = this._less = this.done = false, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = { first_line: 1, first_column: 0, last_line: 1, last_column: 0 }, this.options.ranges) this.yylloc.range = [0, 0];
        return this.offset = 0, this;
      }, input: function() {
        var Y = this._input[0];
        this.yytext += Y, this.yyleng++, this.offset++, this.match += Y, this.matched += Y;
        var O = Y.match(/(?:\r\n?|\n).*/g);
        if (O) this.yylineno++, this.yylloc.last_line++;
        else this.yylloc.last_column++;
        if (this.options.ranges) this.yylloc.range[1]++;
        return this._input = this._input.slice(1), Y;
      }, unput: function(Y) {
        var O = Y.length, z = Y.split(/(?:\r\n?|\n)/g);
        this._input = Y + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - O - 1), this.offset -= O;
        var J = this.match.split(/(?:\r\n?|\n)/g);
        if (this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), z.length - 1) this.yylineno -= z.length - 1;
        var T = this.yylloc.range;
        if (this.yylloc = { first_line: this.yylloc.first_line, last_line: this.yylineno + 1, first_column: this.yylloc.first_column, last_column: z ? (z.length === J.length ? this.yylloc.first_column : 0) + J[J.length - z.length].length - z[0].length : this.yylloc.first_column - O }, this.options.ranges) this.yylloc.range = [T[0], T[0] + this.yyleng - O];
        return this;
      }, more: function() {
        return this._more = true, this;
      }, less: function(Y) {
        this.unput(this.match.slice(Y));
      }, pastInput: function() {
        var Y = this.matched.substr(0, this.matched.length - this.match.length);
        return (Y.length > 20 ? "..." : "") + Y.substr(-20).replace(/\n/g, "");
      }, upcomingInput: function() {
        var Y = this.match;
        if (Y.length < 20) Y += this._input.substr(0, 20 - Y.length);
        return (Y.substr(0, 20) + (Y.length > 20 ? "..." : "")).replace(/\n/g, "");
      }, showPosition: function() {
        var Y = this.pastInput(), O = Array(Y.length + 1).join("-");
        return Y + this.upcomingInput() + `
` + O + "^";
      }, next: function() {
        if (this.done) return this.EOF;
        if (!this._input) this.done = true;
        var Y, O, z, J, T, X;
        if (!this._more) this.yytext = "", this.match = "";
        var f = this._currentRules();
        for (var V = 0; V < f.length; V++) if (z = this._input.match(this.rules[f[V]]), z && (!O || z[0].length > O[0].length)) {
          if (O = z, J = V, !this.options.flex) break;
        }
        if (O) {
          if (X = O[0].match(/(?:\r\n?|\n).*/g), X) this.yylineno += X.length;
          if (this.yylloc = { first_line: this.yylloc.last_line, last_line: this.yylineno + 1, first_column: this.yylloc.last_column, last_column: X ? X[X.length - 1].length - X[X.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + O[0].length }, this.yytext += O[0], this.match += O[0], this.matches = O, this.yyleng = this.yytext.length, this.options.ranges) this.yylloc.range = [this.offset, this.offset += this.yyleng];
          if (this._more = false, this._input = this._input.slice(O[0].length), this.matched += O[0], Y = this.performAction.call(this, this.yy, this, f[J], this.conditionStack[this.conditionStack.length - 1]), this.done && this._input) this.done = false;
          if (Y) return Y;
          else return;
        }
        if (this._input === "") return this.EOF;
        else return this.parseError("Lexical error on line " + (this.yylineno + 1) + `. Unrecognized text.
` + this.showPosition(), { text: "", token: null, line: this.yylineno });
      }, lex: function() {
        var Y = this.next();
        if (typeof Y < "u") return Y;
        else return this.lex();
      }, begin: function(Y) {
        this.conditionStack.push(Y);
      }, popState: function() {
        return this.conditionStack.pop();
      }, _currentRules: function() {
        return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
      }, topState: function() {
        return this.conditionStack[this.conditionStack.length - 2];
      }, pushState: function(Y) {
        this.begin(Y);
      } };
      return P.options = {}, P.performAction = function(Y, O, z, J) {
        function T(f, V) {
          return O.yytext = O.yytext.substring(f, O.yyleng - V + f);
        }
        var X = J;
        switch (z) {
          case 0:
            if (O.yytext.slice(-2) === "\\\\") T(0, 1), this.begin("mu");
            else if (O.yytext.slice(-1) === "\\") T(0, 1), this.begin("emu");
            else this.begin("mu");
            if (O.yytext) return 15;
            break;
          case 1:
            return 15;
          case 2:
            return this.popState(), 15;
            break;
          case 3:
            return this.begin("raw"), 15;
            break;
          case 4:
            if (this.popState(), this.conditionStack[this.conditionStack.length - 1] === "raw") return 15;
            else return T(5, 9), "END_RAW_BLOCK";
            break;
          case 5:
            return 15;
          case 6:
            return this.popState(), 14;
            break;
          case 7:
            return 65;
          case 8:
            return 68;
          case 9:
            return 19;
          case 10:
            return this.popState(), this.begin("raw"), 23;
            break;
          case 11:
            return 55;
          case 12:
            return 60;
          case 13:
            return 29;
          case 14:
            return 47;
          case 15:
            return this.popState(), 44;
            break;
          case 16:
            return this.popState(), 44;
            break;
          case 17:
            return 34;
          case 18:
            return 39;
          case 19:
            return 51;
          case 20:
            return 48;
          case 21:
            this.unput(O.yytext), this.popState(), this.begin("com");
            break;
          case 22:
            return this.popState(), 14;
            break;
          case 23:
            return 48;
          case 24:
            return 73;
          case 25:
            return 72;
          case 26:
            return 72;
          case 27:
            return 87;
          case 28:
            break;
          case 29:
            return this.popState(), 54;
            break;
          case 30:
            return this.popState(), 33;
            break;
          case 31:
            return O.yytext = T(1, 2).replace(/\\"/g, '"'), 80;
            break;
          case 32:
            return O.yytext = T(1, 2).replace(/\\'/g, "'"), 80;
            break;
          case 33:
            return 85;
          case 34:
            return 82;
          case 35:
            return 82;
          case 36:
            return 83;
          case 37:
            return 84;
          case 38:
            return 81;
          case 39:
            return 75;
          case 40:
            return 77;
          case 41:
            return 72;
          case 42:
            return O.yytext = O.yytext.replace(/\\([\\\]])/g, "$1"), 72;
            break;
          case 43:
            return "INVALID";
          case 44:
            return 5;
        }
      }, P.rules = [/^(?:[^\x00]*?(?=(\{\{)))/, /^(?:[^\x00]+)/, /^(?:[^\x00]{2,}?(?=(\{\{|\\\{\{|\\\\\{\{|$)))/, /^(?:\{\{\{\{(?=[^/]))/, /^(?:\{\{\{\{\/[^\s!"#%-,\.\/;->@\[-\^`\{-~]+(?=[=}\s\/.])\}\}\}\})/, /^(?:[^\x00]+?(?=(\{\{\{\{)))/, /^(?:[\s\S]*?--(~)?\}\})/, /^(?:\()/, /^(?:\))/, /^(?:\{\{\{\{)/, /^(?:\}\}\}\})/, /^(?:\{\{(~)?>)/, /^(?:\{\{(~)?#>)/, /^(?:\{\{(~)?#\*?)/, /^(?:\{\{(~)?\/)/, /^(?:\{\{(~)?\^\s*(~)?\}\})/, /^(?:\{\{(~)?\s*else\s*(~)?\}\})/, /^(?:\{\{(~)?\^)/, /^(?:\{\{(~)?\s*else\b)/, /^(?:\{\{(~)?\{)/, /^(?:\{\{(~)?&)/, /^(?:\{\{(~)?!--)/, /^(?:\{\{(~)?![\s\S]*?\}\})/, /^(?:\{\{(~)?\*?)/, /^(?:=)/, /^(?:\.\.)/, /^(?:\.(?=([=~}\s\/.)|])))/, /^(?:[\/.])/, /^(?:\s+)/, /^(?:\}(~)?\}\})/, /^(?:(~)?\}\})/, /^(?:"(\\["]|[^"])*")/, /^(?:'(\\[']|[^'])*')/, /^(?:@)/, /^(?:true(?=([~}\s)])))/, /^(?:false(?=([~}\s)])))/, /^(?:undefined(?=([~}\s)])))/, /^(?:null(?=([~}\s)])))/, /^(?:-?[0-9]+(?:\.[0-9]+)?(?=([~}\s)])))/, /^(?:as\s+\|)/, /^(?:\|)/, /^(?:([^\s!"#%-,\.\/;->@\[-\^`\{-~]+(?=([=~}\s\/.)|]))))/, /^(?:\[(\\\]|[^\]])*\])/, /^(?:.)/, /^(?:$)/], P.conditions = { mu: { rules: [7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44], inclusive: false }, emu: { rules: [2], inclusive: false }, com: { rules: [6], inclusive: false }, raw: { rules: [3, 4, 5], inclusive: false }, INITIAL: { rules: [0, 1, 44], inclusive: true } }, P;
    }();
    $18.lexer = q;
    function K() {
      this.yy = {};
    }
    return K.prototype = $18, $18.Parser = K, new K();
  }();
  ik.default = ax;
  Bk.exports = ik.default;
});
var nz = x$((ak, Qk) => {
  ak.__esModule = true;
  function sx($18) {
    return $18 && $18.__esModule ? $18 : { default: $18 };
  }
  var $p = k8(), oz = sx($p);
  function M5() {
    this.parents = [];
  }
  M5.prototype = { constructor: M5, mutating: false, acceptKey: function(q, K) {
    var P = this.accept(q[K]);
    if (this.mutating) {
      if (P && !M5.prototype[P.type]) throw new oz.default('Unexpected node type "' + P.type + '" found when accepting ' + K + " on " + q.type);
      q[K] = P;
    }
  }, acceptRequired: function(q, K) {
    if (this.acceptKey(q, K), !q[K]) throw new oz.default(q.type + " requires " + K);
  }, acceptArray: function(q) {
    for (var K = 0, P = q.length; K < P; K++) if (this.acceptKey(q, K), !q[K]) q.splice(K, 1), K--, P--;
  }, accept: function(q) {
    if (!q) return;
    if (!this[q.type]) throw new oz.default("Unknown type: " + q.type, q);
    if (this.current) this.parents.unshift(this.current);
    this.current = q;
    var K = this[q.type](q);
    if (this.current = this.parents.shift(), !this.mutating || K) return K;
    else if (K !== false) return q;
  }, Program: function(q) {
    this.acceptArray(q.body);
  }, MustacheStatement: N5, Decorator: N5, BlockStatement: Uk, DecoratorBlock: Uk, PartialStatement: Fk, PartialBlockStatement: function(q) {
    Fk.call(this, q), this.acceptKey(q, "program");
  }, ContentStatement: function() {
  }, CommentStatement: function() {
  }, SubExpression: N5, PathExpression: function() {
  }, StringLiteral: function() {
  }, NumberLiteral: function() {
  }, BooleanLiteral: function() {
  }, UndefinedLiteral: function() {
  }, NullLiteral: function() {
  }, Hash: function(q) {
    this.acceptArray(q.pairs);
  }, HashPair: function(q) {
    this.acceptRequired(q, "value");
  } };
  function N5($18) {
    this.acceptRequired($18, "path"), this.acceptArray($18.params), this.acceptKey($18, "hash");
  }
  function Uk($18) {
    N5.call(this, $18), this.acceptKey($18, "program"), this.acceptKey($18, "inverse");
  }
  function Fk($18) {
    this.acceptRequired($18, "name"), this.acceptArray($18.params), this.acceptKey($18, "hash");
  }
  ak.default = M5;
  Qk.exports = ak.default;
});
var $G = x$((ek, sk) => {
  ek.__esModule = true;
  function _p($18) {
    return $18 && $18.__esModule ? $18 : { default: $18 };
  }
  var Pp = nz(), Op = _p(Pp);
  function F8() {
    var $18 = arguments.length <= 0 || arguments[0] === void 0 ? {} : arguments[0];
    this.options = $18;
  }
  F8.prototype = new Op.default();
  F8.prototype.Program = function($18) {
    var q = !this.options.ignoreStandalone, K = !this.isRootSeen;
    this.isRootSeen = true;
    var P = $18.body;
    for (var _ = 0, Y = P.length; _ < Y; _++) {
      var O = P[_], z = this.accept(O);
      if (!z) continue;
      var J = iz(P, _, K), T = Bz(P, _, K), X = z.openStandalone && J, f = z.closeStandalone && T, V = z.inlineStandalone && J && T;
      if (z.close) E_(P, _, true);
      if (z.open) aK(P, _, true);
      if (q && V) {
        if (E_(P, _), aK(P, _)) {
          if (O.type === "PartialStatement") O.indent = /([ \t]+$)/.exec(P[_ - 1].original)[1];
        }
      }
      if (q && X) E_((O.program || O.inverse).body), aK(P, _);
      if (q && f) E_(P, _), aK((O.inverse || O.program).body);
    }
    return $18;
  };
  F8.prototype.BlockStatement = F8.prototype.DecoratorBlock = F8.prototype.PartialBlockStatement = function($18) {
    this.accept($18.program), this.accept($18.inverse);
    var q = $18.program || $18.inverse, K = $18.program && $18.inverse, P = K, _ = K;
    if (K && K.chained) {
      P = K.body[0].program;
      while (_.chained) _ = _.body[_.body.length - 1].program;
    }
    var Y = { open: $18.openStrip.open, close: $18.closeStrip.close, openStandalone: Bz(q.body), closeStandalone: iz((P || q).body) };
    if ($18.openStrip.close) E_(q.body, null, true);
    if (K) {
      var O = $18.inverseStrip;
      if (O.open) aK(q.body, null, true);
      if (O.close) E_(P.body, null, true);
      if ($18.closeStrip.open) aK(_.body, null, true);
      if (!this.options.ignoreStandalone && iz(q.body) && Bz(P.body)) aK(q.body), E_(P.body);
    } else if ($18.closeStrip.open) aK(q.body, null, true);
    return Y;
  };
  F8.prototype.Decorator = F8.prototype.MustacheStatement = function($18) {
    return $18.strip;
  };
  F8.prototype.PartialStatement = F8.prototype.CommentStatement = function($18) {
    var q = $18.strip || {};
    return { inlineStandalone: true, open: q.open, close: q.close };
  };
  function iz($18, q, K) {
    if (q === void 0) q = $18.length;
    var P = $18[q - 1], _ = $18[q - 2];
    if (!P) return K;
    if (P.type === "ContentStatement") return (_ || !K ? /\r?\n\s*?$/ : /(^|\r?\n)\s*?$/).test(P.original);
  }
  function Bz($18, q, K) {
    if (q === void 0) q = -1;
    var P = $18[q + 1], _ = $18[q + 2];
    if (!P) return K;
    if (P.type === "ContentStatement") return (_ || !K ? /^\s*?\r?\n/ : /^\s*?(\r?\n|$)/).test(P.original);
  }
  function E_($18, q, K) {
    var P = $18[q == null ? 0 : q + 1];
    if (!P || P.type !== "ContentStatement" || !K && P.rightStripped) return;
    var _ = P.value;
    P.value = P.value.replace(K ? /^\s+/ : /^[ \t]*\r?\n?/, ""), P.rightStripped = P.value !== _;
  }
  function aK($18, q, K) {
    var P = $18[q == null ? $18.length - 1 : q - 1];
    if (!P || P.type !== "ContentStatement" || !K && P.leftStripped) return;
    var _ = P.value;
    return P.value = P.value.replace(K ? /\s+$/ : /[ \t]+$/, ""), P.leftStripped = P.value !== _, P.leftStripped;
  }
  ek.default = F8;
  sk.exports = ek.default;
});
var qG = x$((Gp) => {
  Gp.__esModule = true;
  Gp.SourceLocation = Wp;
  Gp.id = Hp;
  Gp.stripFlags = Jp;
  Gp.stripComment = Tp;
  Gp.preparePath = wp;
  Gp.prepareMustache = fp;
  Gp.prepareRawBlock = Zp;
  Gp.prepareBlock = Xp;
  Gp.prepareProgram = Ap;
  Gp.preparePartialBlock = kp;
  function vp($18) {
    return $18 && $18.__esModule ? $18 : { default: $18 };
  }
  var zp = k8(), tz = vp(zp);
  function Uz($18, q) {
    if (q = q.path ? q.path.original : q, $18.path.original !== q) {
      var K = { loc: $18.path.loc };
      throw new tz.default($18.path.original + " doesn't match " + q, K);
    }
  }
  function Wp($18, q) {
    this.source = $18, this.start = { line: q.first_line, column: q.first_column }, this.end = { line: q.last_line, column: q.last_column };
  }
  function Hp($18) {
    if (/^\[.*\]$/.test($18)) return $18.substring(1, $18.length - 1);
    else return $18;
  }
  function Jp($18, q) {
    return { open: $18.charAt(2) === "~", close: q.charAt(q.length - 3) === "~" };
  }
  function Tp($18) {
    return $18.replace(/^\{\{~?!-?-?/, "").replace(/-?-?~?\}\}$/, "");
  }
  function wp($18, q, K) {
    K = this.locInfo(K);
    var P = $18 ? "@" : "", _ = [], Y = 0;
    for (var O = 0, z = q.length; O < z; O++) {
      var J = q[O].part, T = q[O].original !== J;
      if (P += (q[O].separator || "") + J, !T && (J === ".." || J === "." || J === "this")) {
        if (_.length > 0) throw new tz.default("Invalid path: " + P, { loc: K });
        else if (J === "..") Y++;
      } else _.push(J);
    }
    return { type: "PathExpression", data: $18, depth: Y, parts: _, original: P, loc: K };
  }
  function fp($18, q, K, P, _, Y) {
    var O = P.charAt(3) || P.charAt(2), z = O !== "{" && O !== "&", J = /\*/.test(P);
    return { type: J ? "Decorator" : "MustacheStatement", path: $18, params: q, hash: K, escaped: z, strip: _, loc: this.locInfo(Y) };
  }
  function Zp($18, q, K, P) {
    Uz($18, K), P = this.locInfo(P);
    var _ = { type: "Program", body: q, strip: {}, loc: P };
    return { type: "BlockStatement", path: $18.path, params: $18.params, hash: $18.hash, program: _, openStrip: {}, inverseStrip: {}, closeStrip: {}, loc: P };
  }
  function Xp($18, q, K, P, _, Y) {
    if (P && P.path) Uz($18, P);
    var O = /\*/.test($18.open);
    q.blockParams = $18.blockParams;
    var z = void 0, J = void 0;
    if (K) {
      if (O) throw new tz.default("Unexpected inverse block on decorator", K);
      if (K.chain) K.program.body[0].closeStrip = P.strip;
      J = K.strip, z = K.program;
    }
    if (_) _ = z, z = q, q = _;
    return { type: O ? "DecoratorBlock" : "BlockStatement", path: $18.path, params: $18.params, hash: $18.hash, program: q, inverse: z, openStrip: $18.strip, inverseStrip: J, closeStrip: P && P.strip, loc: this.locInfo(Y) };
  }
  function Ap($18, q) {
    if (!q && $18.length) {
      var K = $18[0].loc, P = $18[$18.length - 1].loc;
      if (K && P) q = { source: K.source, start: { line: K.start.line, column: K.start.column }, end: { line: P.end.line, column: P.end.column } };
    }
    return { type: "Program", body: $18, strip: {}, loc: q };
  }
  function kp($18, q, K, P) {
    return Uz($18, K), { type: "PartialBlockStatement", name: $18.path, params: $18.params, hash: $18.hash, program: q, openStrip: $18.strip, closeStrip: K && K.strip, loc: this.locInfo(P) };
  }
});
var PG = x$((dp) => {
  dp.__esModule = true;
  dp.parseWithoutProcessing = _G;
  dp.parse = mp;
  function gp($18) {
    if ($18 && $18.__esModule) return $18;
    else {
      var q = {};
      if ($18 != null) {
        for (var K in $18) if (Object.prototype.hasOwnProperty.call($18, K)) q[K] = $18[K];
      }
      return q.default = $18, q;
    }
  }
  function KG($18) {
    return $18 && $18.__esModule ? $18 : { default: $18 };
  }
  var bp = tk(), Fz = KG(bp), yp = $G(), up = KG(yp), xp = qG(), pp = gp(xp), cp = pq();
  dp.parser = Fz.default;
  var C5 = {};
  cp.extend(C5, pp);
  function _G($18, q) {
    if ($18.type === "Program") return $18;
    Fz.default.yy = C5, C5.locInfo = function(P) {
      return new C5.SourceLocation(q && q.srcName, P);
    };
    var K = Fz.default.parse($18);
    return K;
  }
  function mp($18, q) {
    var K = _G($18, q), P = new up.default(q);
    return P.accept(K);
  }
});
var vG = x$((ap) => {
  ap.__esModule = true;
  ap.Compiler = az;
  ap.precompile = Up;
  ap.compile = Fp;
  function YG($18) {
    return $18 && $18.__esModule ? $18 : { default: $18 };
  }
  var ip = k8(), h7 = YG(ip), R7 = pq(), Bp = rz(), E7 = YG(Bp), tp = [].slice;
  function az() {
  }
  az.prototype = { compiler: az, equals: function(q) {
    var K = this.opcodes.length;
    if (q.opcodes.length !== K) return false;
    for (var P = 0; P < K; P++) {
      var _ = this.opcodes[P], Y = q.opcodes[P];
      if (_.opcode !== Y.opcode || !jG(_.args, Y.args)) return false;
    }
    K = this.children.length;
    for (var P = 0; P < K; P++) if (!this.children[P].equals(q.children[P])) return false;
    return true;
  }, guid: 0, compile: function(q, K) {
    return this.sourceNode = [], this.opcodes = [], this.children = [], this.options = K, this.stringParams = K.stringParams, this.trackIds = K.trackIds, K.blockParams = K.blockParams || [], K.knownHelpers = R7.extend(/* @__PURE__ */ Object.create(null), { helperMissing: true, blockHelperMissing: true, each: true, if: true, unless: true, with: true, log: true, lookup: true }, K.knownHelpers), this.accept(q);
  }, compileProgram: function(q) {
    var K = new this.compiler(), P = K.compile(q, this.options), _ = this.guid++;
    return this.usePartial = this.usePartial || P.usePartial, this.children[_] = P, this.useDepths = this.useDepths || P.useDepths, _;
  }, accept: function(q) {
    if (!this[q.type]) throw new h7.default("Unknown type: " + q.type, q);
    this.sourceNode.unshift(q);
    var K = this[q.type](q);
    return this.sourceNode.shift(), K;
  }, Program: function(q) {
    this.options.blockParams.unshift(q.blockParams);
    var K = q.body, P = K.length;
    for (var _ = 0; _ < P; _++) this.accept(K[_]);
    return this.options.blockParams.shift(), this.isSimple = P === 1, this.blockParams = q.blockParams ? q.blockParams.length : 0, this;
  }, BlockStatement: function(q) {
    OG(q);
    var { program: K, inverse: P } = q;
    K = K && this.compileProgram(K), P = P && this.compileProgram(P);
    var _ = this.classifySexpr(q);
    if (_ === "helper") this.helperSexpr(q, K, P);
    else if (_ === "simple") this.simpleSexpr(q), this.opcode("pushProgram", K), this.opcode("pushProgram", P), this.opcode("emptyHash"), this.opcode("blockValue", q.path.original);
    else this.ambiguousSexpr(q, K, P), this.opcode("pushProgram", K), this.opcode("pushProgram", P), this.opcode("emptyHash"), this.opcode("ambiguousBlockValue");
    this.opcode("append");
  }, DecoratorBlock: function(q) {
    var K = q.program && this.compileProgram(q.program), P = this.setupFullMustacheParams(q, K, void 0), _ = q.path;
    this.useDecorators = true, this.opcode("registerDecorator", P.length, _.original);
  }, PartialStatement: function(q) {
    this.usePartial = true;
    var K = q.program;
    if (K) K = this.compileProgram(q.program);
    var P = q.params;
    if (P.length > 1) throw new h7.default("Unsupported number of partial arguments: " + P.length, q);
    else if (!P.length) if (this.options.explicitPartialContext) this.opcode("pushLiteral", "undefined");
    else P.push({ type: "PathExpression", parts: [], depth: 0 });
    var _ = q.name.original, Y = q.name.type === "SubExpression";
    if (Y) this.accept(q.name);
    this.setupFullMustacheParams(q, K, void 0, true);
    var O = q.indent || "";
    if (this.options.preventIndent && O) this.opcode("appendContent", O), O = "";
    this.opcode("invokePartial", Y, _, O), this.opcode("append");
  }, PartialBlockStatement: function(q) {
    this.PartialStatement(q);
  }, MustacheStatement: function(q) {
    if (this.SubExpression(q), q.escaped && !this.options.noEscape) this.opcode("appendEscaped");
    else this.opcode("append");
  }, Decorator: function(q) {
    this.DecoratorBlock(q);
  }, ContentStatement: function(q) {
    if (q.value) this.opcode("appendContent", q.value);
  }, CommentStatement: function() {
  }, SubExpression: function(q) {
    OG(q);
    var K = this.classifySexpr(q);
    if (K === "simple") this.simpleSexpr(q);
    else if (K === "helper") this.helperSexpr(q);
    else this.ambiguousSexpr(q);
  }, ambiguousSexpr: function(q, K, P) {
    var _ = q.path, Y = _.parts[0], O = K != null || P != null;
    this.opcode("getContext", _.depth), this.opcode("pushProgram", K), this.opcode("pushProgram", P), _.strict = true, this.accept(_), this.opcode("invokeAmbiguous", Y, O);
  }, simpleSexpr: function(q) {
    var K = q.path;
    K.strict = true, this.accept(K), this.opcode("resolvePossibleLambda");
  }, helperSexpr: function(q, K, P) {
    var _ = this.setupFullMustacheParams(q, K, P), Y = q.path, O = Y.parts[0];
    if (this.options.knownHelpers[O]) this.opcode("invokeKnownHelper", _.length, O);
    else if (this.options.knownHelpersOnly) throw new h7.default("You specified knownHelpersOnly, but used the unknown helper " + O, q);
    else Y.strict = true, Y.falsy = true, this.accept(Y), this.opcode("invokeHelper", _.length, Y.original, E7.default.helpers.simpleId(Y));
  }, PathExpression: function(q) {
    this.addDepth(q.depth), this.opcode("getContext", q.depth);
    var K = q.parts[0], P = E7.default.helpers.scopedId(q), _ = !q.depth && !P && this.blockParamIndex(K);
    if (_) this.opcode("lookupBlockParam", _, q.parts);
    else if (!K) this.opcode("pushContext");
    else if (q.data) this.options.data = true, this.opcode("lookupData", q.depth, q.parts, q.strict);
    else this.opcode("lookupOnContext", q.parts, q.falsy, q.strict, P);
  }, StringLiteral: function(q) {
    this.opcode("pushString", q.value);
  }, NumberLiteral: function(q) {
    this.opcode("pushLiteral", q.value);
  }, BooleanLiteral: function(q) {
    this.opcode("pushLiteral", q.value);
  }, UndefinedLiteral: function() {
    this.opcode("pushLiteral", "undefined");
  }, NullLiteral: function() {
    this.opcode("pushLiteral", "null");
  }, Hash: function(q) {
    var K = q.pairs, P = 0, _ = K.length;
    this.opcode("pushHash");
    for (; P < _; P++) this.pushParam(K[P].value);
    while (P--) this.opcode("assignToHash", K[P].key);
    this.opcode("popHash");
  }, opcode: function(q) {
    this.opcodes.push({ opcode: q, args: tp.call(arguments, 1), loc: this.sourceNode[0].loc });
  }, addDepth: function(q) {
    if (!q) return;
    this.useDepths = true;
  }, classifySexpr: function(q) {
    var K = E7.default.helpers.simpleId(q.path), P = K && !!this.blockParamIndex(q.path.parts[0]), _ = !P && E7.default.helpers.helperExpression(q), Y = !P && (_ || K);
    if (Y && !_) {
      var O = q.path.parts[0], z = this.options;
      if (z.knownHelpers[O]) _ = true;
      else if (z.knownHelpersOnly) Y = false;
    }
    if (_) return "helper";
    else if (Y) return "ambiguous";
    else return "simple";
  }, pushParams: function(q) {
    for (var K = 0, P = q.length; K < P; K++) this.pushParam(q[K]);
  }, pushParam: function(q) {
    var K = q.value != null ? q.value : q.original || "";
    if (this.stringParams) {
      if (K.replace) K = K.replace(/^(\.?\.\/)*/g, "").replace(/\//g, ".");
      if (q.depth) this.addDepth(q.depth);
      if (this.opcode("getContext", q.depth || 0), this.opcode("pushStringParam", K, q.type), q.type === "SubExpression") this.accept(q);
    } else {
      if (this.trackIds) {
        var P = void 0;
        if (q.parts && !E7.default.helpers.scopedId(q) && !q.depth) P = this.blockParamIndex(q.parts[0]);
        if (P) {
          var _ = q.parts.slice(1).join(".");
          this.opcode("pushId", "BlockParam", P, _);
        } else {
          if (K = q.original || K, K.replace) K = K.replace(/^this(?:\.|$)/, "").replace(/^\.\//, "").replace(/^\.$/, "");
          this.opcode("pushId", q.type, K);
        }
      }
      this.accept(q);
    }
  }, setupFullMustacheParams: function(q, K, P, _) {
    var Y = q.params;
    if (this.pushParams(Y), this.opcode("pushProgram", K), this.opcode("pushProgram", P), q.hash) this.accept(q.hash);
    else this.opcode("emptyHash", _);
    return Y;
  }, blockParamIndex: function(q) {
    for (var K = 0, P = this.options.blockParams.length; K < P; K++) {
      var _ = this.options.blockParams[K], Y = _ && R7.indexOf(_, q);
      if (_ && Y >= 0) return [K, Y];
    }
  } };
  function Up($18, q, K) {
    if ($18 == null || typeof $18 !== "string" && $18.type !== "Program") throw new h7.default("You must pass a string or Handlebars AST to Handlebars.precompile. You passed " + $18);
    if (q = q || {}, !("data" in q)) q.data = true;
    if (q.compat) q.useDepths = true;
    var P = K.parse($18, q), _ = new K.Compiler().compile(P, q);
    return new K.JavaScriptCompiler().compile(_, q);
  }
  function Fp($18, q, K) {
    if (q === void 0) q = {};
    if ($18 == null || typeof $18 !== "string" && $18.type !== "Program") throw new h7.default("You must pass a string or Handlebars AST to Handlebars.compile. You passed " + $18);
    if (q = R7.extend({}, q), !("data" in q)) q.data = true;
    if (q.compat) q.useDepths = true;
    var P = void 0;
    function _() {
      var O = K.parse($18, q), z = new K.Compiler().compile(O, q), J = new K.JavaScriptCompiler().compile(z, q, void 0, true);
      return K.template(J);
    }
    function Y(O, z) {
      if (!P) P = _();
      return P.call(this, O, z);
    }
    return Y._setup = function(O) {
      if (!P) P = _();
      return P._setup(O);
    }, Y._child = function(O, z, J, T) {
      if (!P) P = _();
      return P._child(O, z, J, T);
    }, Y;
  }
  function jG($18, q) {
    if ($18 === q) return true;
    if (R7.isArray($18) && R7.isArray(q) && $18.length === q.length) {
      for (var K = 0; K < $18.length; K++) if (!jG($18[K], q[K])) return false;
      return true;
    }
  }
  function OG($18) {
    if (!$18.path.parts) {
      var q = $18.path;
      $18.path = { type: "PathExpression", data: false, depth: 0, parts: [q.original + ""], original: q.original + "", loc: q.loc };
    }
  }
});
var WG = x$((qc) => {
  var zG = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
  qc.encode = function($18) {
    if (0 <= $18 && $18 < zG.length) return zG[$18];
    throw TypeError("Must be between 0 and 63: " + $18);
  };
  qc.decode = function($18) {
    var q = 65, K = 90, P = 97, _ = 122, Y = 48, O = 57, z = 43, J = 47, T = 26, X = 52;
    if (q <= $18 && $18 <= K) return $18 - q;
    if (P <= $18 && $18 <= _) return $18 - P + T;
    if (Y <= $18 && $18 <= O) return $18 - Y + X;
    if ($18 == z) return 62;
    if ($18 == J) return 63;
    return -1;
  };
});
var ez = x$((Yc) => {
  var HG = WG(), Qz = 5, JG = 1 << Qz, TG = JG - 1, wG = JG;
  function Pc($18) {
    return $18 < 0 ? (-$18 << 1) + 1 : ($18 << 1) + 0;
  }
  function Oc($18) {
    var q = ($18 & 1) === 1, K = $18 >> 1;
    return q ? -K : K;
  }
  Yc.encode = function(q) {
    var K = "", P, _ = Pc(q);
    do {
      if (P = _ & TG, _ >>>= Qz, _ > 0) P |= wG;
      K += HG.encode(P);
    } while (_ > 0);
    return K;
  };
  Yc.decode = function(q, K, P) {
    var _ = q.length, Y = 0, O = 0, z, J;
    do {
      if (K >= _) throw Error("Expected more digits in base 64 VLQ value.");
      if (J = HG.decode(q.charCodeAt(K++)), J === -1) throw Error("Invalid base64 digit: " + q.charAt(K - 1));
      z = !!(J & wG), J &= TG, Y = Y + (J << O), O += Qz;
    } while (z);
    P.value = Oc(Y), P.rest = K;
  };
});
var E4 = x$((kc) => {
  function zc($18, q, K) {
    if (q in $18) return $18[q];
    else if (arguments.length === 3) return K;
    else throw Error('"' + q + '" is a required argument.');
  }
  kc.getArg = zc;
  var fG = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/, Wc = /^data:.+\,.+$/;
  function I7($18) {
    var q = $18.match(fG);
    if (!q) return null;
    return { scheme: q[1], auth: q[2], host: q[3], port: q[4], path: q[5] };
  }
  kc.urlParse = I7;
  function N4($18) {
    var q = "";
    if ($18.scheme) q += $18.scheme + ":";
    if (q += "//", $18.auth) q += $18.auth + "@";
    if ($18.host) q += $18.host;
    if ($18.port) q += ":" + $18.port;
    if ($18.path) q += $18.path;
    return q;
  }
  kc.urlGenerate = N4;
  function sz($18) {
    var q = $18, K = I7($18);
    if (K) {
      if (!K.path) return $18;
      q = K.path;
    }
    var P = kc.isAbsolute(q), _ = q.split(/\/+/);
    for (var Y, O = 0, z = _.length - 1; z >= 0; z--) if (Y = _[z], Y === ".") _.splice(z, 1);
    else if (Y === "..") O++;
    else if (O > 0) if (Y === "") _.splice(z + 1, O), O = 0;
    else _.splice(z, 2), O--;
    if (q = _.join("/"), q === "") q = P ? "/" : ".";
    if (K) return K.path = q, N4(K);
    return q;
  }
  kc.normalize = sz;
  function ZG($18, q) {
    if ($18 === "") $18 = ".";
    if (q === "") q = ".";
    var K = I7(q), P = I7($18);
    if (P) $18 = P.path || "/";
    if (K && !K.scheme) {
      if (P) K.scheme = P.scheme;
      return N4(K);
    }
    if (K || q.match(Wc)) return q;
    if (P && !P.host && !P.path) return P.host = q, N4(P);
    var _ = q.charAt(0) === "/" ? q : sz($18.replace(/\/+$/, "") + "/" + q);
    if (P) return P.path = _, N4(P);
    return _;
  }
  kc.join = ZG;
  kc.isAbsolute = function($18) {
    return $18.charAt(0) === "/" || fG.test($18);
  };
  function Hc($18, q) {
    if ($18 === "") $18 = ".";
    $18 = $18.replace(/\/$/, "");
    var K = 0;
    while (q.indexOf($18 + "/") !== 0) {
      var P = $18.lastIndexOf("/");
      if (P < 0) return q;
      if ($18 = $18.slice(0, P), $18.match(/^([^\/]+:\/)?\/*$/)) return q;
      ++K;
    }
    return Array(K + 1).join("../") + q.substr($18.length + 1);
  }
  kc.relative = Hc;
  var XG = function() {
    var $18 = /* @__PURE__ */ Object.create(null);
    return !("__proto__" in $18);
  }();
  function AG($18) {
    return $18;
  }
  function Jc($18) {
    if (kG($18)) return "$" + $18;
    return $18;
  }
  kc.toSetString = XG ? AG : Jc;
  function Tc($18) {
    if (kG($18)) return $18.slice(1);
    return $18;
  }
  kc.fromSetString = XG ? AG : Tc;
  function kG($18) {
    if (!$18) return false;
    var q = $18.length;
    if (q < 9) return false;
    if ($18.charCodeAt(q - 1) !== 95 || $18.charCodeAt(q - 2) !== 95 || $18.charCodeAt(q - 3) !== 111 || $18.charCodeAt(q - 4) !== 116 || $18.charCodeAt(q - 5) !== 111 || $18.charCodeAt(q - 6) !== 114 || $18.charCodeAt(q - 7) !== 112 || $18.charCodeAt(q - 8) !== 95 || $18.charCodeAt(q - 9) !== 95) return false;
    for (var K = q - 10; K >= 0; K--) if ($18.charCodeAt(K) !== 36) return false;
    return true;
  }
  function wc($18, q, K) {
    var P = C4($18.source, q.source);
    if (P !== 0) return P;
    if (P = $18.originalLine - q.originalLine, P !== 0) return P;
    if (P = $18.originalColumn - q.originalColumn, P !== 0 || K) return P;
    if (P = $18.generatedColumn - q.generatedColumn, P !== 0) return P;
    if (P = $18.generatedLine - q.generatedLine, P !== 0) return P;
    return C4($18.name, q.name);
  }
  kc.compareByOriginalPositions = wc;
  function fc($18, q, K) {
    var P = $18.generatedLine - q.generatedLine;
    if (P !== 0) return P;
    if (P = $18.generatedColumn - q.generatedColumn, P !== 0 || K) return P;
    if (P = C4($18.source, q.source), P !== 0) return P;
    if (P = $18.originalLine - q.originalLine, P !== 0) return P;
    if (P = $18.originalColumn - q.originalColumn, P !== 0) return P;
    return C4($18.name, q.name);
  }
  kc.compareByGeneratedPositionsDeflated = fc;
  function C4($18, q) {
    if ($18 === q) return 0;
    if ($18 === null) return 1;
    if (q === null) return -1;
    if ($18 > q) return 1;
    return -1;
  }
  function Zc($18, q) {
    var K = $18.generatedLine - q.generatedLine;
    if (K !== 0) return K;
    if (K = $18.generatedColumn - q.generatedColumn, K !== 0) return K;
    if (K = C4($18.source, q.source), K !== 0) return K;
    if (K = $18.originalLine - q.originalLine, K !== 0) return K;
    if (K = $18.originalColumn - q.originalColumn, K !== 0) return K;
    return C4($18.name, q.name);
  }
  kc.compareByGeneratedPositionsInflated = Zc;
  function Xc($18) {
    return JSON.parse($18.replace(/^\)]}'[^\n]*\n/, ""));
  }
  kc.parseSourceMapInput = Xc;
  function Ac($18, q, K) {
    if (q = q || "", $18) {
      if ($18[$18.length - 1] !== "/" && q[0] !== "/") $18 += "/";
      q = $18 + q;
    }
    if (K) {
      var P = I7(K);
      if (!P) throw Error("sourceMapURL could not be parsed");
      if (P.path) {
        var _ = P.path.lastIndexOf("/");
        if (_ >= 0) P.path = P.path.substring(0, _ + 1);
      }
      q = ZG(N4(P), q);
    }
    return sz(q);
  }
  kc.computeSourceURL = Ac;
});
var KW = x$((yc) => {
  var $W = E4(), qW = Object.prototype.hasOwnProperty, h_ = typeof Map < "u";
  function AK() {
    this._array = [], this._set = h_ ? /* @__PURE__ */ new Map() : /* @__PURE__ */ Object.create(null);
  }
  AK.fromArray = function(q, K) {
    var P = new AK();
    for (var _ = 0, Y = q.length; _ < Y; _++) P.add(q[_], K);
    return P;
  };
  AK.prototype.size = function() {
    return h_ ? this._set.size : Object.getOwnPropertyNames(this._set).length;
  };
  AK.prototype.add = function(q, K) {
    var P = h_ ? q : $W.toSetString(q), _ = h_ ? this.has(q) : qW.call(this._set, P), Y = this._array.length;
    if (!_ || K) this._array.push(q);
    if (!_) if (h_) this._set.set(q, Y);
    else this._set[P] = Y;
  };
  AK.prototype.has = function(q) {
    if (h_) return this._set.has(q);
    else {
      var K = $W.toSetString(q);
      return qW.call(this._set, K);
    }
  };
  AK.prototype.indexOf = function(q) {
    if (h_) {
      var K = this._set.get(q);
      if (K >= 0) return K;
    } else {
      var P = $W.toSetString(q);
      if (qW.call(this._set, P)) return this._set[P];
    }
    throw Error('"' + q + '" is not in the set.');
  };
  AK.prototype.at = function(q) {
    if (q >= 0 && q < this._array.length) return this._array[q];
    throw Error("No element indexed by " + q);
  };
  AK.prototype.toArray = function() {
    return this._array.slice();
  };
  yc.ArraySet = AK;
});
var VG = x$((pc) => {
  var GG = E4();
  function xc($18, q) {
    var K = $18.generatedLine, P = q.generatedLine, _ = $18.generatedColumn, Y = q.generatedColumn;
    return P > K || P == K && Y >= _ || GG.compareByGeneratedPositionsInflated($18, q) <= 0;
  }
  function E5() {
    this._array = [], this._sorted = true, this._last = { generatedLine: -1, generatedColumn: 0 };
  }
  E5.prototype.unsortedForEach = function(q, K) {
    this._array.forEach(q, K);
  };
  E5.prototype.add = function(q) {
    if (xc(this._last, q)) this._last = q, this._array.push(q);
    else this._sorted = false, this._array.push(q);
  };
  E5.prototype.toArray = function() {
    if (!this._sorted) this._array.sort(GG.compareByGeneratedPositionsInflated), this._sorted = true;
    return this._array;
  };
  pc.MappingList = E5;
});
var _W = x$((dc) => {
  var D7 = ez(), n6 = E4(), h5 = KW().ArraySet, mc = VG().MappingList;
  function G8($18) {
    if (!$18) $18 = {};
    this._file = n6.getArg($18, "file", null), this._sourceRoot = n6.getArg($18, "sourceRoot", null), this._skipValidation = n6.getArg($18, "skipValidation", false), this._sources = new h5(), this._names = new h5(), this._mappings = new mc(), this._sourcesContents = null;
  }
  G8.prototype._version = 3;
  G8.fromSourceMap = function(q) {
    var K = q.sourceRoot, P = new G8({ file: q.file, sourceRoot: K });
    return q.eachMapping(function(_) {
      var Y = { generated: { line: _.generatedLine, column: _.generatedColumn } };
      if (_.source != null) {
        if (Y.source = _.source, K != null) Y.source = n6.relative(K, Y.source);
        if (Y.original = { line: _.originalLine, column: _.originalColumn }, _.name != null) Y.name = _.name;
      }
      P.addMapping(Y);
    }), q.sources.forEach(function(_) {
      var Y = _;
      if (K !== null) Y = n6.relative(K, _);
      if (!P._sources.has(Y)) P._sources.add(Y);
      var O = q.sourceContentFor(_);
      if (O != null) P.setSourceContent(_, O);
    }), P;
  };
  G8.prototype.addMapping = function(q) {
    var K = n6.getArg(q, "generated"), P = n6.getArg(q, "original", null), _ = n6.getArg(q, "source", null), Y = n6.getArg(q, "name", null);
    if (!this._skipValidation) this._validateMapping(K, P, _, Y);
    if (_ != null) {
      if (_ = String(_), !this._sources.has(_)) this._sources.add(_);
    }
    if (Y != null) {
      if (Y = String(Y), !this._names.has(Y)) this._names.add(Y);
    }
    this._mappings.add({ generatedLine: K.line, generatedColumn: K.column, originalLine: P != null && P.line, originalColumn: P != null && P.column, source: _, name: Y });
  };
  G8.prototype.setSourceContent = function(q, K) {
    var P = q;
    if (this._sourceRoot != null) P = n6.relative(this._sourceRoot, P);
    if (K != null) {
      if (!this._sourcesContents) this._sourcesContents = /* @__PURE__ */ Object.create(null);
      this._sourcesContents[n6.toSetString(P)] = K;
    } else if (this._sourcesContents) {
      if (delete this._sourcesContents[n6.toSetString(P)], Object.keys(this._sourcesContents).length === 0) this._sourcesContents = null;
    }
  };
  G8.prototype.applySourceMap = function(q, K, P) {
    var _ = K;
    if (K == null) {
      if (q.file == null) throw Error(`SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's "file" property. Both were omitted.`);
      _ = q.file;
    }
    var Y = this._sourceRoot;
    if (Y != null) _ = n6.relative(Y, _);
    var O = new h5(), z = new h5();
    this._mappings.unsortedForEach(function(J) {
      if (J.source === _ && J.originalLine != null) {
        var T = q.originalPositionFor({ line: J.originalLine, column: J.originalColumn });
        if (T.source != null) {
          if (J.source = T.source, P != null) J.source = n6.join(P, J.source);
          if (Y != null) J.source = n6.relative(Y, J.source);
          if (J.originalLine = T.line, J.originalColumn = T.column, T.name != null) J.name = T.name;
        }
      }
      var X = J.source;
      if (X != null && !O.has(X)) O.add(X);
      var f = J.name;
      if (f != null && !z.has(f)) z.add(f);
    }, this), this._sources = O, this._names = z, q.sources.forEach(function(J) {
      var T = q.sourceContentFor(J);
      if (T != null) {
        if (P != null) J = n6.join(P, J);
        if (Y != null) J = n6.relative(Y, J);
        this.setSourceContent(J, T);
      }
    }, this);
  };
  G8.prototype._validateMapping = function(q, K, P, _) {
    if (K && typeof K.line !== "number" && typeof K.column !== "number") throw Error("original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values.");
    if (q && "line" in q && "column" in q && q.line > 0 && q.column >= 0 && !K && !P && !_) return;
    else if (q && "line" in q && "column" in q && K && "line" in K && "column" in K && q.line > 0 && q.column >= 0 && K.line > 0 && K.column >= 0 && P) return;
    else throw Error("Invalid mapping: " + JSON.stringify({ generated: q, source: P, original: K, name: _ }));
  };
  G8.prototype._serializeMappings = function() {
    var q = 0, K = 1, P = 0, _ = 0, Y = 0, O = 0, z = "", J, T, X, f, V = this._mappings.toArray();
    for (var M = 0, N = V.length; M < N; M++) {
      if (T = V[M], J = "", T.generatedLine !== K) {
        q = 0;
        while (T.generatedLine !== K) J += ";", K++;
      } else if (M > 0) {
        if (!n6.compareByGeneratedPositionsInflated(T, V[M - 1])) continue;
        J += ",";
      }
      if (J += D7.encode(T.generatedColumn - q), q = T.generatedColumn, T.source != null) {
        if (f = this._sources.indexOf(T.source), J += D7.encode(f - O), O = f, J += D7.encode(T.originalLine - 1 - _), _ = T.originalLine - 1, J += D7.encode(T.originalColumn - P), P = T.originalColumn, T.name != null) X = this._names.indexOf(T.name), J += D7.encode(X - Y), Y = X;
      }
      z += J;
    }
    return z;
  };
  G8.prototype._generateSourcesContent = function(q, K) {
    return q.map(function(P) {
      if (!this._sourcesContents) return null;
      if (K != null) P = n6.relative(K, P);
      var _ = n6.toSetString(P);
      return Object.prototype.hasOwnProperty.call(this._sourcesContents, _) ? this._sourcesContents[_] : null;
    }, this);
  };
  G8.prototype.toJSON = function() {
    var q = { version: this._version, sources: this._sources.toArray(), names: this._names.toArray(), mappings: this._serializeMappings() };
    if (this._file != null) q.file = this._file;
    if (this._sourceRoot != null) q.sourceRoot = this._sourceRoot;
    if (this._sourcesContents) q.sourcesContent = this._generateSourcesContent(q.sources, q.sourceRoot);
    return q;
  };
  G8.prototype.toString = function() {
    return JSON.stringify(this.toJSON());
  };
  dc.SourceMapGenerator = G8;
});
var MG = x$((rc) => {
  rc.GREATEST_LOWER_BOUND = 1;
  rc.LEAST_UPPER_BOUND = 2;
  function PW($18, q, K, P, _, Y) {
    var O = Math.floor((q - $18) / 2) + $18, z = _(K, P[O], true);
    if (z === 0) return O;
    else if (z > 0) {
      if (q - O > 1) return PW(O, q, K, P, _, Y);
      if (Y == rc.LEAST_UPPER_BOUND) return q < P.length ? q : -1;
      else return O;
    } else {
      if (O - $18 > 1) return PW($18, O, K, P, _, Y);
      if (Y == rc.LEAST_UPPER_BOUND) return O;
      else return $18 < 0 ? -1 : $18;
    }
  }
  rc.search = function(q, K, P, _) {
    if (K.length === 0) return -1;
    var Y = PW(-1, K.length, q, K, P, _ || rc.GREATEST_LOWER_BOUND);
    if (Y < 0) return -1;
    while (Y - 1 >= 0) {
      if (P(K[Y], K[Y - 1], true) !== 0) break;
      --Y;
    }
    return Y;
  };
});
var NG = x$((ic) => {
  function YW($18, q, K) {
    var P = $18[q];
    $18[q] = $18[K], $18[K] = P;
  }
  function nc($18, q) {
    return Math.round($18 + Math.random() * (q - $18));
  }
  function jW($18, q, K, P) {
    if (K < P) {
      var _ = nc(K, P), Y = K - 1;
      YW($18, _, P);
      var O = $18[P];
      for (var z = K; z < P; z++) if (q($18[z], O) <= 0) Y += 1, YW($18, Y, z);
      YW($18, Y + 1, z);
      var J = Y + 1;
      jW($18, q, K, J - 1), jW($18, q, J + 1, P);
    }
  }
  ic.quickSort = function($18, q) {
    jW($18, q, 0, $18.length - 1);
  };
});
var EG = x$((Uc) => {
  var Q$ = E4(), vW = MG(), h4 = KW().ArraySet, tc = ez(), L7 = NG().quickSort;
  function L6($18, q) {
    var K = $18;
    if (typeof $18 === "string") K = Q$.parseSourceMapInput($18);
    return K.sections != null ? new u8(K, q) : new Gq(K, q);
  }
  L6.fromSourceMap = function($18, q) {
    return Gq.fromSourceMap($18, q);
  };
  L6.prototype._version = 3;
  L6.prototype.__generatedMappings = null;
  Object.defineProperty(L6.prototype, "_generatedMappings", { configurable: true, enumerable: true, get: function() {
    if (!this.__generatedMappings) this._parseMappings(this._mappings, this.sourceRoot);
    return this.__generatedMappings;
  } });
  L6.prototype.__originalMappings = null;
  Object.defineProperty(L6.prototype, "_originalMappings", { configurable: true, enumerable: true, get: function() {
    if (!this.__originalMappings) this._parseMappings(this._mappings, this.sourceRoot);
    return this.__originalMappings;
  } });
  L6.prototype._charIsMappingSeparator = function(q, K) {
    var P = q.charAt(K);
    return P === ";" || P === ",";
  };
  L6.prototype._parseMappings = function(q, K) {
    throw Error("Subclasses must implement _parseMappings");
  };
  L6.GENERATED_ORDER = 1;
  L6.ORIGINAL_ORDER = 2;
  L6.GREATEST_LOWER_BOUND = 1;
  L6.LEAST_UPPER_BOUND = 2;
  L6.prototype.eachMapping = function(q, K, P) {
    var _ = K || null, Y = P || L6.GENERATED_ORDER, O;
    switch (Y) {
      case L6.GENERATED_ORDER:
        O = this._generatedMappings;
        break;
      case L6.ORIGINAL_ORDER:
        O = this._originalMappings;
        break;
      default:
        throw Error("Unknown order of iteration.");
    }
    var z = this.sourceRoot;
    O.map(function(J) {
      var T = J.source === null ? null : this._sources.at(J.source);
      return T = Q$.computeSourceURL(z, T, this._sourceMapURL), { source: T, generatedLine: J.generatedLine, generatedColumn: J.generatedColumn, originalLine: J.originalLine, originalColumn: J.originalColumn, name: J.name === null ? null : this._names.at(J.name) };
    }, this).forEach(q, _);
  };
  L6.prototype.allGeneratedPositionsFor = function(q) {
    var K = Q$.getArg(q, "line"), P = { source: Q$.getArg(q, "source"), originalLine: K, originalColumn: Q$.getArg(q, "column", 0) };
    if (P.source = this._findSourceIndex(P.source), P.source < 0) return [];
    var _ = [], Y = this._findMapping(P, this._originalMappings, "originalLine", "originalColumn", Q$.compareByOriginalPositions, vW.LEAST_UPPER_BOUND);
    if (Y >= 0) {
      var O = this._originalMappings[Y];
      if (q.column === void 0) {
        var z = O.originalLine;
        while (O && O.originalLine === z) _.push({ line: Q$.getArg(O, "generatedLine", null), column: Q$.getArg(O, "generatedColumn", null), lastColumn: Q$.getArg(O, "lastGeneratedColumn", null) }), O = this._originalMappings[++Y];
      } else {
        var J = O.originalColumn;
        while (O && O.originalLine === K && O.originalColumn == J) _.push({ line: Q$.getArg(O, "generatedLine", null), column: Q$.getArg(O, "generatedColumn", null), lastColumn: Q$.getArg(O, "lastGeneratedColumn", null) }), O = this._originalMappings[++Y];
      }
    }
    return _;
  };
  Uc.SourceMapConsumer = L6;
  function Gq($18, q) {
    var K = $18;
    if (typeof $18 === "string") K = Q$.parseSourceMapInput($18);
    var P = Q$.getArg(K, "version"), _ = Q$.getArg(K, "sources"), Y = Q$.getArg(K, "names", []), O = Q$.getArg(K, "sourceRoot", null), z = Q$.getArg(K, "sourcesContent", null), J = Q$.getArg(K, "mappings"), T = Q$.getArg(K, "file", null);
    if (P != this._version) throw Error("Unsupported version: " + P);
    if (O) O = Q$.normalize(O);
    _ = _.map(String).map(Q$.normalize).map(function(X) {
      return O && Q$.isAbsolute(O) && Q$.isAbsolute(X) ? Q$.relative(O, X) : X;
    }), this._names = h4.fromArray(Y.map(String), true), this._sources = h4.fromArray(_, true), this._absoluteSources = this._sources.toArray().map(function(X) {
      return Q$.computeSourceURL(O, X, q);
    }), this.sourceRoot = O, this.sourcesContent = z, this._mappings = J, this._sourceMapURL = q, this.file = T;
  }
  Gq.prototype = Object.create(L6.prototype);
  Gq.prototype.consumer = L6;
  Gq.prototype._findSourceIndex = function($18) {
    var q = $18;
    if (this.sourceRoot != null) q = Q$.relative(this.sourceRoot, q);
    if (this._sources.has(q)) return this._sources.indexOf(q);
    var K;
    for (K = 0; K < this._absoluteSources.length; ++K) if (this._absoluteSources[K] == $18) return K;
    return -1;
  };
  Gq.fromSourceMap = function(q, K) {
    var P = Object.create(Gq.prototype), _ = P._names = h4.fromArray(q._names.toArray(), true), Y = P._sources = h4.fromArray(q._sources.toArray(), true);
    P.sourceRoot = q._sourceRoot, P.sourcesContent = q._generateSourcesContent(P._sources.toArray(), P.sourceRoot), P.file = q._file, P._sourceMapURL = K, P._absoluteSources = P._sources.toArray().map(function(M) {
      return Q$.computeSourceURL(P.sourceRoot, M, K);
    });
    var O = q._mappings.toArray().slice(), z = P.__generatedMappings = [], J = P.__originalMappings = [];
    for (var T = 0, X = O.length; T < X; T++) {
      var f = O[T], V = new CG();
      if (V.generatedLine = f.generatedLine, V.generatedColumn = f.generatedColumn, f.source) {
        if (V.source = Y.indexOf(f.source), V.originalLine = f.originalLine, V.originalColumn = f.originalColumn, f.name) V.name = _.indexOf(f.name);
        J.push(V);
      }
      z.push(V);
    }
    return L7(P.__originalMappings, Q$.compareByOriginalPositions), P;
  };
  Gq.prototype._version = 3;
  Object.defineProperty(Gq.prototype, "sources", { get: function() {
    return this._absoluteSources.slice();
  } });
  function CG() {
    this.generatedLine = 0, this.generatedColumn = 0, this.source = null, this.originalLine = null, this.originalColumn = null, this.name = null;
  }
  Gq.prototype._parseMappings = function(q, K) {
    var P = 1, _ = 0, Y = 0, O = 0, z = 0, J = 0, T = q.length, X = 0, f = {}, V = {}, M = [], N = [], h, E, I, D, g;
    while (X < T) if (q.charAt(X) === ";") P++, X++, _ = 0;
    else if (q.charAt(X) === ",") X++;
    else {
      h = new CG(), h.generatedLine = P;
      for (D = X; D < T; D++) if (this._charIsMappingSeparator(q, D)) break;
      if (E = q.slice(X, D), I = f[E], I) X += E.length;
      else {
        I = [];
        while (X < D) tc.decode(q, X, V), g = V.value, X = V.rest, I.push(g);
        if (I.length === 2) throw Error("Found a source, but no line and column");
        if (I.length === 3) throw Error("Found a source and line, but no column");
        f[E] = I;
      }
      if (h.generatedColumn = _ + I[0], _ = h.generatedColumn, I.length > 1) {
        if (h.source = z + I[1], z += I[1], h.originalLine = Y + I[2], Y = h.originalLine, h.originalLine += 1, h.originalColumn = O + I[3], O = h.originalColumn, I.length > 4) h.name = J + I[4], J += I[4];
      }
      if (N.push(h), typeof h.originalLine === "number") M.push(h);
    }
    L7(N, Q$.compareByGeneratedPositionsDeflated), this.__generatedMappings = N, L7(M, Q$.compareByOriginalPositions), this.__originalMappings = M;
  };
  Gq.prototype._findMapping = function(q, K, P, _, Y, O) {
    if (q[P] <= 0) throw TypeError("Line must be greater than or equal to 1, got " + q[P]);
    if (q[_] < 0) throw TypeError("Column must be greater than or equal to 0, got " + q[_]);
    return vW.search(q, K, Y, O);
  };
  Gq.prototype.computeColumnSpans = function() {
    for (var q = 0; q < this._generatedMappings.length; ++q) {
      var K = this._generatedMappings[q];
      if (q + 1 < this._generatedMappings.length) {
        var P = this._generatedMappings[q + 1];
        if (K.generatedLine === P.generatedLine) {
          K.lastGeneratedColumn = P.generatedColumn - 1;
          continue;
        }
      }
      K.lastGeneratedColumn = 1 / 0;
    }
  };
  Gq.prototype.originalPositionFor = function(q) {
    var K = { generatedLine: Q$.getArg(q, "line"), generatedColumn: Q$.getArg(q, "column") }, P = this._findMapping(K, this._generatedMappings, "generatedLine", "generatedColumn", Q$.compareByGeneratedPositionsDeflated, Q$.getArg(q, "bias", L6.GREATEST_LOWER_BOUND));
    if (P >= 0) {
      var _ = this._generatedMappings[P];
      if (_.generatedLine === K.generatedLine) {
        var Y = Q$.getArg(_, "source", null);
        if (Y !== null) Y = this._sources.at(Y), Y = Q$.computeSourceURL(this.sourceRoot, Y, this._sourceMapURL);
        var O = Q$.getArg(_, "name", null);
        if (O !== null) O = this._names.at(O);
        return { source: Y, line: Q$.getArg(_, "originalLine", null), column: Q$.getArg(_, "originalColumn", null), name: O };
      }
    }
    return { source: null, line: null, column: null, name: null };
  };
  Gq.prototype.hasContentsOfAllSources = function() {
    if (!this.sourcesContent) return false;
    return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(q) {
      return q == null;
    });
  };
  Gq.prototype.sourceContentFor = function(q, K) {
    if (!this.sourcesContent) return null;
    var P = this._findSourceIndex(q);
    if (P >= 0) return this.sourcesContent[P];
    var _ = q;
    if (this.sourceRoot != null) _ = Q$.relative(this.sourceRoot, _);
    var Y;
    if (this.sourceRoot != null && (Y = Q$.urlParse(this.sourceRoot))) {
      var O = _.replace(/^file:\/\//, "");
      if (Y.scheme == "file" && this._sources.has(O)) return this.sourcesContent[this._sources.indexOf(O)];
      if ((!Y.path || Y.path == "/") && this._sources.has("/" + _)) return this.sourcesContent[this._sources.indexOf("/" + _)];
    }
    if (K) return null;
    else throw Error('"' + _ + '" is not in the SourceMap.');
  };
  Gq.prototype.generatedPositionFor = function(q) {
    var K = Q$.getArg(q, "source");
    if (K = this._findSourceIndex(K), K < 0) return { line: null, column: null, lastColumn: null };
    var P = { source: K, originalLine: Q$.getArg(q, "line"), originalColumn: Q$.getArg(q, "column") }, _ = this._findMapping(P, this._originalMappings, "originalLine", "originalColumn", Q$.compareByOriginalPositions, Q$.getArg(q, "bias", L6.GREATEST_LOWER_BOUND));
    if (_ >= 0) {
      var Y = this._originalMappings[_];
      if (Y.source === P.source) return { line: Q$.getArg(Y, "generatedLine", null), column: Q$.getArg(Y, "generatedColumn", null), lastColumn: Q$.getArg(Y, "lastGeneratedColumn", null) };
    }
    return { line: null, column: null, lastColumn: null };
  };
  Uc.BasicSourceMapConsumer = Gq;
  function u8($18, q) {
    var K = $18;
    if (typeof $18 === "string") K = Q$.parseSourceMapInput($18);
    var P = Q$.getArg(K, "version"), _ = Q$.getArg(K, "sections");
    if (P != this._version) throw Error("Unsupported version: " + P);
    this._sources = new h4(), this._names = new h4();
    var Y = { line: -1, column: 0 };
    this._sections = _.map(function(O) {
      if (O.url) throw Error("Support for url field in sections not implemented.");
      var z = Q$.getArg(O, "offset"), J = Q$.getArg(z, "line"), T = Q$.getArg(z, "column");
      if (J < Y.line || J === Y.line && T < Y.column) throw Error("Section offsets must be ordered and non-overlapping.");
      return Y = z, { generatedOffset: { generatedLine: J + 1, generatedColumn: T + 1 }, consumer: new L6(Q$.getArg(O, "map"), q) };
    });
  }
  u8.prototype = Object.create(L6.prototype);
  u8.prototype.constructor = L6;
  u8.prototype._version = 3;
  Object.defineProperty(u8.prototype, "sources", { get: function() {
    var $18 = [];
    for (var q = 0; q < this._sections.length; q++) for (var K = 0; K < this._sections[q].consumer.sources.length; K++) $18.push(this._sections[q].consumer.sources[K]);
    return $18;
  } });
  u8.prototype.originalPositionFor = function(q) {
    var K = { generatedLine: Q$.getArg(q, "line"), generatedColumn: Q$.getArg(q, "column") }, P = vW.search(K, this._sections, function(Y, O) {
      var z = Y.generatedLine - O.generatedOffset.generatedLine;
      if (z) return z;
      return Y.generatedColumn - O.generatedOffset.generatedColumn;
    }), _ = this._sections[P];
    if (!_) return { source: null, line: null, column: null, name: null };
    return _.consumer.originalPositionFor({ line: K.generatedLine - (_.generatedOffset.generatedLine - 1), column: K.generatedColumn - (_.generatedOffset.generatedLine === K.generatedLine ? _.generatedOffset.generatedColumn - 1 : 0), bias: q.bias });
  };
  u8.prototype.hasContentsOfAllSources = function() {
    return this._sections.every(function(q) {
      return q.consumer.hasContentsOfAllSources();
    });
  };
  u8.prototype.sourceContentFor = function(q, K) {
    for (var P = 0; P < this._sections.length; P++) {
      var _ = this._sections[P], Y = _.consumer.sourceContentFor(q, true);
      if (Y) return Y;
    }
    if (K) return null;
    else throw Error('"' + q + '" is not in the SourceMap.');
  };
  u8.prototype.generatedPositionFor = function(q) {
    for (var K = 0; K < this._sections.length; K++) {
      var P = this._sections[K];
      if (P.consumer._findSourceIndex(Q$.getArg(q, "source")) === -1) continue;
      var _ = P.consumer.generatedPositionFor(q);
      if (_) {
        var Y = { line: _.line + (P.generatedOffset.generatedLine - 1), column: _.column + (P.generatedOffset.generatedLine === _.line ? P.generatedOffset.generatedColumn - 1 : 0) };
        return Y;
      }
    }
    return { line: null, column: null };
  };
  u8.prototype._parseMappings = function(q, K) {
    this.__generatedMappings = [], this.__originalMappings = [];
    for (var P = 0; P < this._sections.length; P++) {
      var _ = this._sections[P], Y = _.consumer._generatedMappings;
      for (var O = 0; O < Y.length; O++) {
        var z = Y[O], J = _.consumer._sources.at(z.source);
        J = Q$.computeSourceURL(_.consumer.sourceRoot, J, this._sourceMapURL), this._sources.add(J), J = this._sources.indexOf(J);
        var T = null;
        if (z.name) T = _.consumer._names.at(z.name), this._names.add(T), T = this._names.indexOf(T);
        var X = { source: J, generatedLine: z.generatedLine + (_.generatedOffset.generatedLine - 1), generatedColumn: z.generatedColumn + (_.generatedOffset.generatedLine === z.generatedLine ? _.generatedOffset.generatedColumn - 1 : 0), originalLine: z.originalLine, originalColumn: z.originalColumn, name: T };
        if (this.__generatedMappings.push(X), typeof X.originalLine === "number") this.__originalMappings.push(X);
      }
    }
    L7(this.__generatedMappings, Q$.compareByGeneratedPositionsDeflated), L7(this.__originalMappings, Q$.compareByOriginalPositions);
  };
  Uc.IndexedSourceMapConsumer = u8;
});
var hG = x$((qm) => {
  var ec = _W().SourceMapGenerator, R5 = E4(), sc = /(\r?\n)/, $m = 10, R4 = "$$$isSourceNode$$$";
  function j8($18, q, K, P, _) {
    if (this.children = [], this.sourceContents = {}, this.line = $18 == null ? null : $18, this.column = q == null ? null : q, this.source = K == null ? null : K, this.name = _ == null ? null : _, this[R4] = true, P != null) this.add(P);
  }
  j8.fromStringWithSourceMap = function(q, K, P) {
    var _ = new j8(), Y = q.split(sc), O = 0, z = function() {
      var V = N(), M = N() || "";
      return V + M;
      function N() {
        return O < Y.length ? Y[O++] : void 0;
      }
    }, J = 1, T = 0, X = null;
    if (K.eachMapping(function(V) {
      if (X !== null) if (J < V.generatedLine) f(X, z()), J++, T = 0;
      else {
        var M = Y[O] || "", N = M.substr(0, V.generatedColumn - T);
        Y[O] = M.substr(V.generatedColumn - T), T = V.generatedColumn, f(X, N), X = V;
        return;
      }
      while (J < V.generatedLine) _.add(z()), J++;
      if (T < V.generatedColumn) {
        var M = Y[O] || "";
        _.add(M.substr(0, V.generatedColumn)), Y[O] = M.substr(V.generatedColumn), T = V.generatedColumn;
      }
      X = V;
    }, this), O < Y.length) {
      if (X) f(X, z());
      _.add(Y.splice(O).join(""));
    }
    return K.sources.forEach(function(V) {
      var M = K.sourceContentFor(V);
      if (M != null) {
        if (P != null) V = R5.join(P, V);
        _.setSourceContent(V, M);
      }
    }), _;
    function f(V, M) {
      if (V === null || V.source === void 0) _.add(M);
      else {
        var N = P ? R5.join(P, V.source) : V.source;
        _.add(new j8(V.originalLine, V.originalColumn, N, M, V.name));
      }
    }
  };
  j8.prototype.add = function(q) {
    if (Array.isArray(q)) q.forEach(function(K) {
      this.add(K);
    }, this);
    else if (q[R4] || typeof q === "string") {
      if (q) this.children.push(q);
    } else throw TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + q);
    return this;
  };
  j8.prototype.prepend = function(q) {
    if (Array.isArray(q)) for (var K = q.length - 1; K >= 0; K--) this.prepend(q[K]);
    else if (q[R4] || typeof q === "string") this.children.unshift(q);
    else throw TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + q);
    return this;
  };
  j8.prototype.walk = function(q) {
    var K;
    for (var P = 0, _ = this.children.length; P < _; P++) if (K = this.children[P], K[R4]) K.walk(q);
    else if (K !== "") q(K, { source: this.source, line: this.line, column: this.column, name: this.name });
  };
  j8.prototype.join = function(q) {
    var K, P, _ = this.children.length;
    if (_ > 0) {
      K = [];
      for (P = 0; P < _ - 1; P++) K.push(this.children[P]), K.push(q);
      K.push(this.children[P]), this.children = K;
    }
    return this;
  };
  j8.prototype.replaceRight = function(q, K) {
    var P = this.children[this.children.length - 1];
    if (P[R4]) P.replaceRight(q, K);
    else if (typeof P === "string") this.children[this.children.length - 1] = P.replace(q, K);
    else this.children.push("".replace(q, K));
    return this;
  };
  j8.prototype.setSourceContent = function(q, K) {
    this.sourceContents[R5.toSetString(q)] = K;
  };
  j8.prototype.walkSourceContents = function(q) {
    for (var K = 0, P = this.children.length; K < P; K++) if (this.children[K][R4]) this.children[K].walkSourceContents(q);
    var _ = Object.keys(this.sourceContents);
    for (var K = 0, P = _.length; K < P; K++) q(R5.fromSetString(_[K]), this.sourceContents[_[K]]);
  };
  j8.prototype.toString = function() {
    var q = "";
    return this.walk(function(K) {
      q += K;
    }), q;
  };
  j8.prototype.toStringWithSourceMap = function(q) {
    var K = { code: "", line: 1, column: 0 }, P = new ec(q), _ = false, Y = null, O = null, z = null, J = null;
    return this.walk(function(T, X) {
      if (K.code += T, X.source !== null && X.line !== null && X.column !== null) {
        if (Y !== X.source || O !== X.line || z !== X.column || J !== X.name) P.addMapping({ source: X.source, original: { line: X.line, column: X.column }, generated: { line: K.line, column: K.column }, name: X.name });
        Y = X.source, O = X.line, z = X.column, J = X.name, _ = true;
      } else if (_) P.addMapping({ generated: { line: K.line, column: K.column } }), Y = null, _ = false;
      for (var f = 0, V = T.length; f < V; f++) if (T.charCodeAt(f) === $m) {
        if (K.line++, K.column = 0, f + 1 === V) Y = null, _ = false;
        else if (_) P.addMapping({ source: X.source, original: { line: X.line, column: X.column }, generated: { line: K.line, column: K.column }, name: X.name });
      } else K.column++;
    }), this.walkSourceContents(function(T, X) {
      P.setSourceContent(T, X);
    }), { code: K.code, map: P };
  };
  qm.SourceNode = j8;
});
var RG = x$((_m) => {
  _m.SourceMapGenerator = _W().SourceMapGenerator;
  _m.SourceMapConsumer = EG().SourceMapConsumer;
  _m.SourceNode = hG().SourceNode;
});
var gG = x$((DG, LG) => {
  DG.__esModule = true;
  var WW = pq(), R_ = void 0;
  try {
    if (typeof define !== "function" || !define.amd) HW = RG(), R_ = HW.SourceNode;
  } catch ($18) {
  }
  var HW;
  if (!R_) R_ = function($18, q, K, P) {
    if (this.src = "", P) this.add(P);
  }, R_.prototype = { add: function(q) {
    if (WW.isArray(q)) q = q.join("");
    this.src += q;
  }, prepend: function(q) {
    if (WW.isArray(q)) q = q.join("");
    this.src = q + this.src;
  }, toStringWithSourceMap: function() {
    return { code: this.toString() };
  }, toString: function() {
    return this.src;
  } };
  function zW($18, q, K) {
    if (WW.isArray($18)) {
      var P = [];
      for (var _ = 0, Y = $18.length; _ < Y; _++) P.push(q.wrap($18[_], K));
      return P;
    } else if (typeof $18 === "boolean" || typeof $18 === "number") return $18 + "";
    return $18;
  }
  function IG($18) {
    this.srcFile = $18, this.source = [];
  }
  IG.prototype = { isEmpty: function() {
    return !this.source.length;
  }, prepend: function(q, K) {
    this.source.unshift(this.wrap(q, K));
  }, push: function(q, K) {
    this.source.push(this.wrap(q, K));
  }, merge: function() {
    var q = this.empty();
    return this.each(function(K) {
      q.add(["  ", K, `
`]);
    }), q;
  }, each: function(q) {
    for (var K = 0, P = this.source.length; K < P; K++) q(this.source[K]);
  }, empty: function() {
    var q = this.currentLocation || { start: {} };
    return new R_(q.start.line, q.start.column, this.srcFile);
  }, wrap: function(q) {
    var K = arguments.length <= 1 || arguments[1] === void 0 ? this.currentLocation || { start: {} } : arguments[1];
    if (q instanceof R_) return q;
    return q = zW(q, this, K), new R_(K.start.line, K.start.column, this.srcFile, q);
  }, functionCall: function(q, K, P) {
    return P = this.generateList(P), this.wrap([q, K ? "." + K + "(" : "(", P, ")"]);
  }, quotedString: function(q) {
    return '"' + (q + "").replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029") + '"';
  }, objectLiteral: function(q) {
    var K = this, P = [];
    Object.keys(q).forEach(function(Y) {
      var O = zW(q[Y], K);
      if (O !== "undefined") P.push([K.quotedString(Y), ":", O]);
    });
    var _ = this.generateList(P);
    return _.prepend("{"), _.add("}"), _;
  }, generateList: function(q) {
    var K = this.empty();
    for (var P = 0, _ = q.length; P < _; P++) {
      if (P) K.add(",");
      K.add(zW(q[P], this));
    }
    return K;
  }, generateArray: function(q) {
    var K = this.generateList(q);
    return K.prepend("["), K.add("]"), K;
  } };
  DG.default = IG;
  LG.exports = DG.default;
});
var cG = x$((xG, pG) => {
  xG.__esModule = true;
  function uG($18) {
    return $18 && $18.__esModule ? $18 : { default: $18 };
  }
  var bG = V5(), zm = k8(), JW = uG(zm), Wm = pq(), Hm = gG(), yG = uG(Hm);
  function I4($18) {
    this.value = $18;
  }
  function D4() {
  }
  D4.prototype = { nameLookup: function(q, K) {
    return this.internalNameLookup(q, K);
  }, depthedLookup: function(q) {
    return [this.aliasable("container.lookup"), "(depths, ", JSON.stringify(q), ")"];
  }, compilerInfo: function() {
    var q = bG.COMPILER_REVISION, K = bG.REVISION_CHANGES[q];
    return [q, K];
  }, appendToBuffer: function(q, K, P) {
    if (!Wm.isArray(q)) q = [q];
    if (q = this.source.wrap(q, K), this.environment.isSimple) return ["return ", q, ";"];
    else if (P) return ["buffer += ", q, ";"];
    else return q.appendToBuffer = true, q;
  }, initializeBuffer: function() {
    return this.quotedString("");
  }, internalNameLookup: function(q, K) {
    return this.lookupPropertyFunctionIsUsed = true, ["lookupProperty(", q, ",", JSON.stringify(K), ")"];
  }, lookupPropertyFunctionIsUsed: false, compile: function(q, K, P, _) {
    this.environment = q, this.options = K, this.stringParams = this.options.stringParams, this.trackIds = this.options.trackIds, this.precompile = !_, this.name = this.environment.name, this.isChild = !!P, this.context = P || { decorators: [], programs: [], environments: [] }, this.preamble(), this.stackSlot = 0, this.stackVars = [], this.aliases = {}, this.registers = { list: [] }, this.hashes = [], this.compileStack = [], this.inlineStack = [], this.blockParams = [], this.compileChildren(q, K), this.useDepths = this.useDepths || q.useDepths || q.useDecorators || this.options.compat, this.useBlockParams = this.useBlockParams || q.useBlockParams;
    var Y = q.opcodes, O = void 0, z = void 0, J = void 0, T = void 0;
    for (J = 0, T = Y.length; J < T; J++) O = Y[J], this.source.currentLocation = O.loc, z = z || O.loc, this[O.opcode].apply(this, O.args);
    if (this.source.currentLocation = z, this.pushSource(""), this.stackSlot || this.inlineStack.length || this.compileStack.length) throw new JW.default("Compile completed with content left on stack");
    if (!this.decorators.isEmpty()) if (this.useDecorators = true, this.decorators.prepend(["var decorators = container.decorators, ", this.lookupPropertyFunctionVarDeclaration(), `;
`]), this.decorators.push("return fn;"), _) this.decorators = Function.apply(this, ["fn", "props", "container", "depth0", "data", "blockParams", "depths", this.decorators.merge()]);
    else this.decorators.prepend(`function(fn, props, container, depth0, data, blockParams, depths) {
`), this.decorators.push(`}
`), this.decorators = this.decorators.merge();
    else this.decorators = void 0;
    var X = this.createFunctionContext(_);
    if (!this.isChild) {
      var f = { compiler: this.compilerInfo(), main: X };
      if (this.decorators) f.main_d = this.decorators, f.useDecorators = true;
      var V = this.context, M = V.programs, N = V.decorators;
      for (J = 0, T = M.length; J < T; J++) if (M[J]) {
        if (f[J] = M[J], N[J]) f[J + "_d"] = N[J], f.useDecorators = true;
      }
      if (this.environment.usePartial) f.usePartial = true;
      if (this.options.data) f.useData = true;
      if (this.useDepths) f.useDepths = true;
      if (this.useBlockParams) f.useBlockParams = true;
      if (this.options.compat) f.compat = true;
      if (!_) if (f.compiler = JSON.stringify(f.compiler), this.source.currentLocation = { start: { line: 1, column: 0 } }, f = this.objectLiteral(f), K.srcName) f = f.toStringWithSourceMap({ file: K.destName }), f.map = f.map && f.map.toString();
      else f = f.toString();
      else f.compilerOptions = this.options;
      return f;
    } else return X;
  }, preamble: function() {
    this.lastContext = 0, this.source = new yG.default(this.options.srcName), this.decorators = new yG.default(this.options.srcName);
  }, createFunctionContext: function(q) {
    var K = this, P = "", _ = this.stackVars.concat(this.registers.list);
    if (_.length > 0) P += ", " + _.join(", ");
    var Y = 0;
    if (Object.keys(this.aliases).forEach(function(J) {
      var T = K.aliases[J];
      if (T.children && T.referenceCount > 1) P += ", alias" + ++Y + "=" + J, T.children[0] = "alias" + Y;
    }), this.lookupPropertyFunctionIsUsed) P += ", " + this.lookupPropertyFunctionVarDeclaration();
    var O = ["container", "depth0", "helpers", "partials", "data"];
    if (this.useBlockParams || this.useDepths) O.push("blockParams");
    if (this.useDepths) O.push("depths");
    var z = this.mergeSource(P);
    if (q) return O.push(z), Function.apply(this, O);
    else return this.source.wrap(["function(", O.join(","), `) {
  `, z, "}"]);
  }, mergeSource: function(q) {
    var K = this.environment.isSimple, P = !this.forceBuffer, _ = void 0, Y = void 0, O = void 0, z = void 0;
    if (this.source.each(function(J) {
      if (J.appendToBuffer) {
        if (O) J.prepend("  + ");
        else O = J;
        z = J;
      } else {
        if (O) {
          if (!Y) _ = true;
          else O.prepend("buffer += ");
          z.add(";"), O = z = void 0;
        }
        if (Y = true, !K) P = false;
      }
    }), P) {
      if (O) O.prepend("return "), z.add(";");
      else if (!Y) this.source.push('return "";');
    } else if (q += ", buffer = " + (_ ? "" : this.initializeBuffer()), O) O.prepend("return buffer + "), z.add(";");
    else this.source.push("return buffer;");
    if (q) this.source.prepend("var " + q.substring(2) + (_ ? "" : `;
`));
    return this.source.merge();
  }, lookupPropertyFunctionVarDeclaration: function() {
    return `
      lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    }
    `.trim();
  }, blockValue: function(q) {
    var K = this.aliasable("container.hooks.blockHelperMissing"), P = [this.contextName(0)];
    this.setupHelperArgs(q, 0, P);
    var _ = this.popStack();
    P.splice(1, 0, _), this.push(this.source.functionCall(K, "call", P));
  }, ambiguousBlockValue: function() {
    var q = this.aliasable("container.hooks.blockHelperMissing"), K = [this.contextName(0)];
    this.setupHelperArgs("", 0, K, true), this.flushInline();
    var P = this.topStack();
    K.splice(1, 0, P), this.pushSource(["if (!", this.lastHelper, ") { ", P, " = ", this.source.functionCall(q, "call", K), "}"]);
  }, appendContent: function(q) {
    if (this.pendingContent) q = this.pendingContent + q;
    else this.pendingLocation = this.source.currentLocation;
    this.pendingContent = q;
  }, append: function() {
    if (this.isInline()) this.replaceStack(function(K) {
      return [" != null ? ", K, ' : ""'];
    }), this.pushSource(this.appendToBuffer(this.popStack()));
    else {
      var q = this.popStack();
      if (this.pushSource(["if (", q, " != null) { ", this.appendToBuffer(q, void 0, true), " }"]), this.environment.isSimple) this.pushSource(["else { ", this.appendToBuffer("''", void 0, true), " }"]);
    }
  }, appendEscaped: function() {
    this.pushSource(this.appendToBuffer([this.aliasable("container.escapeExpression"), "(", this.popStack(), ")"]));
  }, getContext: function(q) {
    this.lastContext = q;
  }, pushContext: function() {
    this.pushStackLiteral(this.contextName(this.lastContext));
  }, lookupOnContext: function(q, K, P, _) {
    var Y = 0;
    if (!_ && this.options.compat && !this.lastContext) this.push(this.depthedLookup(q[Y++]));
    else this.pushContext();
    this.resolvePath("context", q, Y, K, P);
  }, lookupBlockParam: function(q, K) {
    this.useBlockParams = true, this.push(["blockParams[", q[0], "][", q[1], "]"]), this.resolvePath("context", K, 1);
  }, lookupData: function(q, K, P) {
    if (!q) this.pushStackLiteral("data");
    else this.pushStackLiteral("container.data(data, " + q + ")");
    this.resolvePath("data", K, 0, true, P);
  }, resolvePath: function(q, K, P, _, Y) {
    var O = this;
    if (this.options.strict || this.options.assumeObjects) {
      this.push(Jm(this.options.strict && Y, this, K, P, q));
      return;
    }
    var z = K.length;
    for (; P < z; P++) this.replaceStack(function(J) {
      var T = O.nameLookup(J, K[P], q);
      if (!_) return [" != null ? ", T, " : ", J];
      else return [" && ", T];
    });
  }, resolvePossibleLambda: function() {
    this.push([this.aliasable("container.lambda"), "(", this.popStack(), ", ", this.contextName(0), ")"]);
  }, pushStringParam: function(q, K) {
    if (this.pushContext(), this.pushString(K), K !== "SubExpression") if (typeof q === "string") this.pushString(q);
    else this.pushStackLiteral(q);
  }, emptyHash: function(q) {
    if (this.trackIds) this.push("{}");
    if (this.stringParams) this.push("{}"), this.push("{}");
    this.pushStackLiteral(q ? "undefined" : "{}");
  }, pushHash: function() {
    if (this.hash) this.hashes.push(this.hash);
    this.hash = { values: {}, types: [], contexts: [], ids: [] };
  }, popHash: function() {
    var q = this.hash;
    if (this.hash = this.hashes.pop(), this.trackIds) this.push(this.objectLiteral(q.ids));
    if (this.stringParams) this.push(this.objectLiteral(q.contexts)), this.push(this.objectLiteral(q.types));
    this.push(this.objectLiteral(q.values));
  }, pushString: function(q) {
    this.pushStackLiteral(this.quotedString(q));
  }, pushLiteral: function(q) {
    this.pushStackLiteral(q);
  }, pushProgram: function(q) {
    if (q != null) this.pushStackLiteral(this.programExpression(q));
    else this.pushStackLiteral(null);
  }, registerDecorator: function(q, K) {
    var P = this.nameLookup("decorators", K, "decorator"), _ = this.setupHelperArgs(K, q);
    this.decorators.push(["fn = ", this.decorators.functionCall(P, "", ["fn", "props", "container", _]), " || fn;"]);
  }, invokeHelper: function(q, K, P) {
    var _ = this.popStack(), Y = this.setupHelper(q, K), O = [];
    if (P) O.push(Y.name);
    if (O.push(_), !this.options.strict) O.push(this.aliasable("container.hooks.helperMissing"));
    var z = ["(", this.itemsSeparatedBy(O, "||"), ")"], J = this.source.functionCall(z, "call", Y.callParams);
    this.push(J);
  }, itemsSeparatedBy: function(q, K) {
    var P = [];
    P.push(q[0]);
    for (var _ = 1; _ < q.length; _++) P.push(K, q[_]);
    return P;
  }, invokeKnownHelper: function(q, K) {
    var P = this.setupHelper(q, K);
    this.push(this.source.functionCall(P.name, "call", P.callParams));
  }, invokeAmbiguous: function(q, K) {
    this.useRegister("helper");
    var P = this.popStack();
    this.emptyHash();
    var _ = this.setupHelper(0, q, K), Y = this.lastHelper = this.nameLookup("helpers", q, "helper"), O = ["(", "(helper = ", Y, " || ", P, ")"];
    if (!this.options.strict) O[0] = "(helper = ", O.push(" != null ? helper : ", this.aliasable("container.hooks.helperMissing"));
    this.push(["(", O, _.paramsInit ? ["),(", _.paramsInit] : [], "),", "(typeof helper === ", this.aliasable('"function"'), " ? ", this.source.functionCall("helper", "call", _.callParams), " : helper))"]);
  }, invokePartial: function(q, K, P) {
    var _ = [], Y = this.setupParams(K, 1, _);
    if (q) K = this.popStack(), delete Y.name;
    if (P) Y.indent = JSON.stringify(P);
    if (Y.helpers = "helpers", Y.partials = "partials", Y.decorators = "container.decorators", !q) _.unshift(this.nameLookup("partials", K, "partial"));
    else _.unshift(K);
    if (this.options.compat) Y.depths = "depths";
    Y = this.objectLiteral(Y), _.push(Y), this.push(this.source.functionCall("container.invokePartial", "", _));
  }, assignToHash: function(q) {
    var K = this.popStack(), P = void 0, _ = void 0, Y = void 0;
    if (this.trackIds) Y = this.popStack();
    if (this.stringParams) _ = this.popStack(), P = this.popStack();
    var O = this.hash;
    if (P) O.contexts[q] = P;
    if (_) O.types[q] = _;
    if (Y) O.ids[q] = Y;
    O.values[q] = K;
  }, pushId: function(q, K, P) {
    if (q === "BlockParam") this.pushStackLiteral("blockParams[" + K[0] + "].path[" + K[1] + "]" + (P ? " + " + JSON.stringify("." + P) : ""));
    else if (q === "PathExpression") this.pushString(K);
    else if (q === "SubExpression") this.pushStackLiteral("true");
    else this.pushStackLiteral("null");
  }, compiler: D4, compileChildren: function(q, K) {
    var P = q.children, _ = void 0, Y = void 0;
    for (var O = 0, z = P.length; O < z; O++) {
      _ = P[O], Y = new this.compiler();
      var J = this.matchExistingProgram(_);
      if (J == null) {
        this.context.programs.push("");
        var T = this.context.programs.length;
        _.index = T, _.name = "program" + T, this.context.programs[T] = Y.compile(_, K, this.context, !this.precompile), this.context.decorators[T] = Y.decorators, this.context.environments[T] = _, this.useDepths = this.useDepths || Y.useDepths, this.useBlockParams = this.useBlockParams || Y.useBlockParams, _.useDepths = this.useDepths, _.useBlockParams = this.useBlockParams;
      } else _.index = J.index, _.name = "program" + J.index, this.useDepths = this.useDepths || J.useDepths, this.useBlockParams = this.useBlockParams || J.useBlockParams;
    }
  }, matchExistingProgram: function(q) {
    for (var K = 0, P = this.context.environments.length; K < P; K++) {
      var _ = this.context.environments[K];
      if (_ && _.equals(q)) return _;
    }
  }, programExpression: function(q) {
    var K = this.environment.children[q], P = [K.index, "data", K.blockParams];
    if (this.useBlockParams || this.useDepths) P.push("blockParams");
    if (this.useDepths) P.push("depths");
    return "container.program(" + P.join(", ") + ")";
  }, useRegister: function(q) {
    if (!this.registers[q]) this.registers[q] = true, this.registers.list.push(q);
  }, push: function(q) {
    if (!(q instanceof I4)) q = this.source.wrap(q);
    return this.inlineStack.push(q), q;
  }, pushStackLiteral: function(q) {
    this.push(new I4(q));
  }, pushSource: function(q) {
    if (this.pendingContent) this.source.push(this.appendToBuffer(this.source.quotedString(this.pendingContent), this.pendingLocation)), this.pendingContent = void 0;
    if (q) this.source.push(q);
  }, replaceStack: function(q) {
    var K = ["("], P = void 0, _ = void 0, Y = void 0;
    if (!this.isInline()) throw new JW.default("replaceStack on non-inline");
    var O = this.popStack(true);
    if (O instanceof I4) P = [O.value], K = ["(", P], Y = true;
    else {
      _ = true;
      var z = this.incrStack();
      K = ["((", this.push(z), " = ", O, ")"], P = this.topStack();
    }
    var J = q.call(this, P);
    if (!Y) this.popStack();
    if (_) this.stackSlot--;
    this.push(K.concat(J, ")"));
  }, incrStack: function() {
    if (this.stackSlot++, this.stackSlot > this.stackVars.length) this.stackVars.push("stack" + this.stackSlot);
    return this.topStackName();
  }, topStackName: function() {
    return "stack" + this.stackSlot;
  }, flushInline: function() {
    var q = this.inlineStack;
    this.inlineStack = [];
    for (var K = 0, P = q.length; K < P; K++) {
      var _ = q[K];
      if (_ instanceof I4) this.compileStack.push(_);
      else {
        var Y = this.incrStack();
        this.pushSource([Y, " = ", _, ";"]), this.compileStack.push(Y);
      }
    }
  }, isInline: function() {
    return this.inlineStack.length;
  }, popStack: function(q) {
    var K = this.isInline(), P = (K ? this.inlineStack : this.compileStack).pop();
    if (!q && P instanceof I4) return P.value;
    else {
      if (!K) {
        if (!this.stackSlot) throw new JW.default("Invalid stack pop");
        this.stackSlot--;
      }
      return P;
    }
  }, topStack: function() {
    var q = this.isInline() ? this.inlineStack : this.compileStack, K = q[q.length - 1];
    if (K instanceof I4) return K.value;
    else return K;
  }, contextName: function(q) {
    if (this.useDepths && q) return "depths[" + q + "]";
    else return "depth" + q;
  }, quotedString: function(q) {
    return this.source.quotedString(q);
  }, objectLiteral: function(q) {
    return this.source.objectLiteral(q);
  }, aliasable: function(q) {
    var K = this.aliases[q];
    if (K) return K.referenceCount++, K;
    return K = this.aliases[q] = this.source.wrap(q), K.aliasable = true, K.referenceCount = 1, K;
  }, setupHelper: function(q, K, P) {
    var _ = [], Y = this.setupHelperArgs(K, q, _, P), O = this.nameLookup("helpers", K, "helper"), z = this.aliasable(this.contextName(0) + " != null ? " + this.contextName(0) + " : (container.nullContext || {})");
    return { params: _, paramsInit: Y, name: O, callParams: [z].concat(_) };
  }, setupParams: function(q, K, P) {
    var _ = {}, Y = [], O = [], z = [], J = !P, T = void 0;
    if (J) P = [];
    if (_.name = this.quotedString(q), _.hash = this.popStack(), this.trackIds) _.hashIds = this.popStack();
    if (this.stringParams) _.hashTypes = this.popStack(), _.hashContexts = this.popStack();
    var X = this.popStack(), f = this.popStack();
    if (f || X) _.fn = f || "container.noop", _.inverse = X || "container.noop";
    var V = K;
    while (V--) {
      if (T = this.popStack(), P[V] = T, this.trackIds) z[V] = this.popStack();
      if (this.stringParams) O[V] = this.popStack(), Y[V] = this.popStack();
    }
    if (J) _.args = this.source.generateArray(P);
    if (this.trackIds) _.ids = this.source.generateArray(z);
    if (this.stringParams) _.types = this.source.generateArray(O), _.contexts = this.source.generateArray(Y);
    if (this.options.data) _.data = "data";
    if (this.useBlockParams) _.blockParams = "blockParams";
    return _;
  }, setupHelperArgs: function(q, K, P, _) {
    var Y = this.setupParams(q, K, P);
    if (Y.loc = JSON.stringify(this.source.currentLocation), Y = this.objectLiteral(Y), _) return this.useRegister("options"), P.push("options"), ["options=", Y];
    else if (P) return P.push(Y), "";
    else return Y;
  } };
  (function() {
    var $18 = "break else new var case finally return void catch for switch while continue function this with default if throw delete in try do instanceof typeof abstract enum int short boolean export interface static byte extends long super char final native synchronized class float package throws const goto private transient debugger implements protected volatile double import public let yield await null true false".split(" "), q = D4.RESERVED_WORDS = {};
    for (var K = 0, P = $18.length; K < P; K++) q[$18[K]] = true;
  })();
  D4.isValidJavaScriptVariableName = function($18) {
    return !D4.RESERVED_WORDS[$18] && /^[a-zA-Z_$][0-9a-zA-Z_$]*$/.test($18);
  };
  function Jm($18, q, K, P, _) {
    var Y = q.popStack(), O = K.length;
    if ($18) O--;
    for (; P < O; P++) Y = q.nameLookup(Y, K[P], _);
    if ($18) return [q.aliasable("container.strict"), "(", Y, ", ", q.quotedString(K[P]), ", ", JSON.stringify(q.source.currentLocation), " )"];
    else return Y;
  }
  xG.default = D4;
  pG.exports = xG.default;
});
var rG = x$((dG, lG) => {
  dG.__esModule = true;
  function g7($18) {
    return $18 && $18.__esModule ? $18 : { default: $18 };
  }
  var fm = lk(), Zm = g7(fm), Xm = rz(), Am = g7(Xm), TW = PG(), wW = vG(), km = cG(), Gm = g7(km), Vm = nz(), Sm = g7(Vm), Mm = cz(), Nm = g7(Mm), Cm = Zm.default.create;
  function mG() {
    var $18 = Cm();
    return $18.compile = function(q, K) {
      return wW.compile(q, K, $18);
    }, $18.precompile = function(q, K) {
      return wW.precompile(q, K, $18);
    }, $18.AST = Am.default, $18.Compiler = wW.Compiler, $18.JavaScriptCompiler = Gm.default, $18.Parser = TW.parser, $18.parse = TW.parse, $18.parseWithoutProcessing = TW.parseWithoutProcessing, $18;
  }
  var L4 = mG();
  L4.create = mG;
  Nm.default(L4);
  L4.Visitor = Sm.default;
  L4.default = L4;
  dG.default = L4;
  lG.exports = dG.default;
});
var WH = {};
lq(WH, { sep: () => iV, resolve: () => i5, relative: () => cV, posix: () => tV, parse: () => nV, normalize: () => zH, join: () => pV, isAbsolute: () => xV, format: () => oV, extname: () => rV, dirname: () => dV, delimiter: () => BV, default: () => Fd, basename: () => lV, _makeLong: () => mV });
function a8($18) {
  if (typeof $18 !== "string") throw TypeError("Path must be a string. Received " + JSON.stringify($18));
}
function uV($18, q) {
  var K = "", P = 0, _ = -1, Y = 0, O;
  for (var z = 0; z <= $18.length; ++z) {
    if (z < $18.length) O = $18.charCodeAt(z);
    else if (O === 47) break;
    else O = 47;
    if (O === 47) {
      if (_ === z - 1 || Y === 1) ;
      else if (_ !== z - 1 && Y === 2) {
        if (K.length < 2 || P !== 2 || K.charCodeAt(K.length - 1) !== 46 || K.charCodeAt(K.length - 2) !== 46) {
          if (K.length > 2) {
            var J = K.lastIndexOf("/");
            if (J !== K.length - 1) {
              if (J === -1) K = "", P = 0;
              else K = K.slice(0, J), P = K.length - 1 - K.lastIndexOf("/");
              _ = z, Y = 0;
              continue;
            }
          } else if (K.length === 2 || K.length === 1) {
            K = "", P = 0, _ = z, Y = 0;
            continue;
          }
        }
        if (q) {
          if (K.length > 0) K += "/..";
          else K = "..";
          P = 2;
        }
      } else {
        if (K.length > 0) K += "/" + $18.slice(_ + 1, z);
        else K = $18.slice(_ + 1, z);
        P = z - _ - 1;
      }
      _ = z, Y = 0;
    } else if (O === 46 && Y !== -1) ++Y;
    else Y = -1;
  }
  return K;
}
function Ud($18, q) {
  var K = q.dir || q.root, P = q.base || (q.name || "") + (q.ext || "");
  if (!K) return P;
  if (K === q.root) return K + P;
  return K + $18 + P;
}
function i5() {
  var $18 = "", q = false, K;
  for (var P = arguments.length - 1; P >= -1 && !q; P--) {
    var _;
    if (P >= 0) _ = arguments[P];
    else {
      if (K === void 0) K = process.cwd();
      _ = K;
    }
    if (a8(_), _.length === 0) continue;
    $18 = _ + "/" + $18, q = _.charCodeAt(0) === 47;
  }
  if ($18 = uV($18, !q), q) if ($18.length > 0) return "/" + $18;
  else return "/";
  else if ($18.length > 0) return $18;
  else return ".";
}
function zH($18) {
  if (a8($18), $18.length === 0) return ".";
  var q = $18.charCodeAt(0) === 47, K = $18.charCodeAt($18.length - 1) === 47;
  if ($18 = uV($18, !q), $18.length === 0 && !q) $18 = ".";
  if ($18.length > 0 && K) $18 += "/";
  if (q) return "/" + $18;
  return $18;
}
function xV($18) {
  return a8($18), $18.length > 0 && $18.charCodeAt(0) === 47;
}
function pV() {
  if (arguments.length === 0) return ".";
  var $18;
  for (var q = 0; q < arguments.length; ++q) {
    var K = arguments[q];
    if (a8(K), K.length > 0) if ($18 === void 0) $18 = K;
    else $18 += "/" + K;
  }
  if ($18 === void 0) return ".";
  return zH($18);
}
function cV($18, q) {
  if (a8($18), a8(q), $18 === q) return "";
  if ($18 = i5($18), q = i5(q), $18 === q) return "";
  var K = 1;
  for (; K < $18.length; ++K) if ($18.charCodeAt(K) !== 47) break;
  var P = $18.length, _ = P - K, Y = 1;
  for (; Y < q.length; ++Y) if (q.charCodeAt(Y) !== 47) break;
  var O = q.length, z = O - Y, J = _ < z ? _ : z, T = -1, X = 0;
  for (; X <= J; ++X) {
    if (X === J) {
      if (z > J) {
        if (q.charCodeAt(Y + X) === 47) return q.slice(Y + X + 1);
        else if (X === 0) return q.slice(Y + X);
      } else if (_ > J) {
        if ($18.charCodeAt(K + X) === 47) T = X;
        else if (X === 0) T = 0;
      }
      break;
    }
    var f = $18.charCodeAt(K + X), V = q.charCodeAt(Y + X);
    if (f !== V) break;
    else if (f === 47) T = X;
  }
  var M = "";
  for (X = K + T + 1; X <= P; ++X) if (X === P || $18.charCodeAt(X) === 47) if (M.length === 0) M += "..";
  else M += "/..";
  if (M.length > 0) return M + q.slice(Y + T);
  else {
    if (Y += T, q.charCodeAt(Y) === 47) ++Y;
    return q.slice(Y);
  }
}
function mV($18) {
  return $18;
}
function dV($18) {
  if (a8($18), $18.length === 0) return ".";
  var q = $18.charCodeAt(0), K = q === 47, P = -1, _ = true;
  for (var Y = $18.length - 1; Y >= 1; --Y) if (q = $18.charCodeAt(Y), q === 47) {
    if (!_) {
      P = Y;
      break;
    }
  } else _ = false;
  if (P === -1) return K ? "/" : ".";
  if (K && P === 1) return "//";
  return $18.slice(0, P);
}
function lV($18, q) {
  if (q !== void 0 && typeof q !== "string") throw TypeError('"ext" argument must be a string');
  a8($18);
  var K = 0, P = -1, _ = true, Y;
  if (q !== void 0 && q.length > 0 && q.length <= $18.length) {
    if (q.length === $18.length && q === $18) return "";
    var O = q.length - 1, z = -1;
    for (Y = $18.length - 1; Y >= 0; --Y) {
      var J = $18.charCodeAt(Y);
      if (J === 47) {
        if (!_) {
          K = Y + 1;
          break;
        }
      } else {
        if (z === -1) _ = false, z = Y + 1;
        if (O >= 0) if (J === q.charCodeAt(O)) {
          if (--O === -1) P = Y;
        } else O = -1, P = z;
      }
    }
    if (K === P) P = z;
    else if (P === -1) P = $18.length;
    return $18.slice(K, P);
  } else {
    for (Y = $18.length - 1; Y >= 0; --Y) if ($18.charCodeAt(Y) === 47) {
      if (!_) {
        K = Y + 1;
        break;
      }
    } else if (P === -1) _ = false, P = Y + 1;
    if (P === -1) return "";
    return $18.slice(K, P);
  }
}
function rV($18) {
  a8($18);
  var q = -1, K = 0, P = -1, _ = true, Y = 0;
  for (var O = $18.length - 1; O >= 0; --O) {
    var z = $18.charCodeAt(O);
    if (z === 47) {
      if (!_) {
        K = O + 1;
        break;
      }
      continue;
    }
    if (P === -1) _ = false, P = O + 1;
    if (z === 46) {
      if (q === -1) q = O;
      else if (Y !== 1) Y = 1;
    } else if (q !== -1) Y = -1;
  }
  if (q === -1 || P === -1 || Y === 0 || Y === 1 && q === P - 1 && q === K + 1) return "";
  return $18.slice(q, P);
}
function oV($18) {
  if ($18 === null || typeof $18 !== "object") throw TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof $18);
  return Ud("/", $18);
}
function nV($18) {
  a8($18);
  var q = { root: "", dir: "", base: "", ext: "", name: "" };
  if ($18.length === 0) return q;
  var K = $18.charCodeAt(0), P = K === 47, _;
  if (P) q.root = "/", _ = 1;
  else _ = 0;
  var Y = -1, O = 0, z = -1, J = true, T = $18.length - 1, X = 0;
  for (; T >= _; --T) {
    if (K = $18.charCodeAt(T), K === 47) {
      if (!J) {
        O = T + 1;
        break;
      }
      continue;
    }
    if (z === -1) J = false, z = T + 1;
    if (K === 46) {
      if (Y === -1) Y = T;
      else if (X !== 1) X = 1;
    } else if (Y !== -1) X = -1;
  }
  if (Y === -1 || z === -1 || X === 0 || X === 1 && Y === z - 1 && Y === O + 1) {
    if (z !== -1) if (O === 0 && P) q.base = q.name = $18.slice(1, z);
    else q.base = q.name = $18.slice(O, z);
  } else {
    if (O === 0 && P) q.name = $18.slice(1, Y), q.base = $18.slice(1, z);
    else q.name = $18.slice(O, Y), q.base = $18.slice(O, z);
    q.ext = $18.slice(Y, z);
  }
  if (O > 0) q.dir = $18.slice(0, O - 1);
  else if (P) q.dir = "/";
  return q;
}
var iV = "/";
var BV = ":";
var tV;
var Fd;
var HH = p_(() => {
  tV = (($18) => ($18.posix = $18, $18))({ resolve: i5, normalize: zH, isAbsolute: xV, join: pV, relative: cV, _makeLong: mV, dirname: dV, basename: lV, extname: rV, format: oV, parse: nV, sep: iV, delimiter: BV, win32: null, posix: null }), Fd = tV;
});
var JH = {};
lq(JH, { uptime: () => sd, type: () => _l, totalmem: () => ql, tmpdir: () => FV, tmpDir: () => vl, release: () => Pl, platform: () => jl, networkInterfaces: () => Ol, loadavg: () => ed, hostname: () => Qd, homedir: () => Wl, getNetworkInterfaces: () => UV, freemem: () => $l, endianness: () => ad, cpus: () => Kl, arch: () => Yl, EOL: () => zl });
var ad = function() {
  return "LE";
};
var Qd = function() {
  if (typeof location < "u") return location.hostname;
  else return "";
};
var ed = function() {
  return [];
};
var sd = function() {
  return 0;
};
var $l = function() {
  return Number.MAX_VALUE;
};
var ql = function() {
  return Number.MAX_VALUE;
};
var Kl = function() {
  return [];
};
var _l = function() {
  return "Browser";
};
var Pl = function() {
  if (typeof navigator < "u") return navigator.appVersion;
  return "";
};
var UV = function() {
  return {};
};
var Ol;
var Yl = function() {
  return "javascript";
};
var jl = function() {
  return "browser";
};
var FV = function() {
  return "/tmp";
};
var vl;
var zl = `
`;
var Wl = function() {
  return "/";
};
var TH = p_(() => {
  Ol = UV, vl = FV;
});
var Tq = {};
lq(Tq, { transcode: () => Fl, resolveObjectURL: () => Bl, kStringMaxLength: () => PS, kMaxLength: () => m7, isUtf8: () => tl, isAscii: () => Ul, default: () => al, constants: () => Gl, btoa: () => Zl, atob: () => Xl, INSPECT_MAX_BYTES: () => _S, File: () => Al, Buffer: () => w$, Blob: () => kl });
function Hl($18) {
  var q = $18.length;
  if (q % 4 > 0) throw Error("Invalid string. Length must be a multiple of 4");
  var K = $18.indexOf("=");
  if (K === -1) K = q;
  var P = K === q ? 0 : 4 - K % 4;
  return [K, P];
}
function Jl($18, q) {
  return ($18 + q) * 3 / 4 - q;
}
function Tl($18) {
  var q, K = Hl($18), P = K[0], _ = K[1], Y = new Uint8Array(Jl(P, _)), O = 0, z = _ > 0 ? P - 4 : P, J;
  for (J = 0; J < z; J += 4) q = V8[$18.charCodeAt(J)] << 18 | V8[$18.charCodeAt(J + 1)] << 12 | V8[$18.charCodeAt(J + 2)] << 6 | V8[$18.charCodeAt(J + 3)], Y[O++] = q >> 16 & 255, Y[O++] = q >> 8 & 255, Y[O++] = q & 255;
  if (_ === 2) q = V8[$18.charCodeAt(J)] << 2 | V8[$18.charCodeAt(J + 1)] >> 4, Y[O++] = q & 255;
  if (_ === 1) q = V8[$18.charCodeAt(J)] << 10 | V8[$18.charCodeAt(J + 1)] << 4 | V8[$18.charCodeAt(J + 2)] >> 2, Y[O++] = q >> 8 & 255, Y[O++] = q & 255;
  return Y;
}
function wl($18) {
  return Q8[$18 >> 18 & 63] + Q8[$18 >> 12 & 63] + Q8[$18 >> 6 & 63] + Q8[$18 & 63];
}
function fl($18, q, K) {
  var P, _ = [];
  for (var Y = q; Y < K; Y += 3) P = ($18[Y] << 16 & 16711680) + ($18[Y + 1] << 8 & 65280) + ($18[Y + 2] & 255), _.push(wl(P));
  return _.join("");
}
function QV($18) {
  var q, K = $18.length, P = K % 3, _ = [], Y = 16383;
  for (var O = 0, z = K - P; O < z; O += Y) _.push(fl($18, O, O + Y > z ? z : O + Y));
  if (P === 1) q = $18[K - 1], _.push(Q8[q >> 2] + Q8[q << 4 & 63] + "==");
  else if (P === 2) q = ($18[K - 2] << 8) + $18[K - 1], _.push(Q8[q >> 10] + Q8[q >> 4 & 63] + Q8[q << 2 & 63] + "=");
  return _.join("");
}
function B5($18, q, K, P, _) {
  var Y, O, z = _ * 8 - P - 1, J = (1 << z) - 1, T = J >> 1, X = -7, f = K ? _ - 1 : 0, V = K ? -1 : 1, M = $18[q + f];
  f += V, Y = M & (1 << -X) - 1, M >>= -X, X += z;
  for (; X > 0; Y = Y * 256 + $18[q + f], f += V, X -= 8) ;
  O = Y & (1 << -X) - 1, Y >>= -X, X += P;
  for (; X > 0; O = O * 256 + $18[q + f], f += V, X -= 8) ;
  if (Y === 0) Y = 1 - T;
  else if (Y === J) return O ? NaN : (M ? -1 : 1) * (1 / 0);
  else O = O + Math.pow(2, P), Y = Y - T;
  return (M ? -1 : 1) * O * Math.pow(2, Y - P);
}
function KS($18, q, K, P, _, Y) {
  var O, z, J, T = Y * 8 - _ - 1, X = (1 << T) - 1, f = X >> 1, V = _ === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, M = P ? 0 : Y - 1, N = P ? 1 : -1, h = q < 0 || q === 0 && 1 / q < 0 ? 1 : 0;
  if (q = Math.abs(q), isNaN(q) || q === 1 / 0) z = isNaN(q) ? 1 : 0, O = X;
  else {
    if (O = Math.floor(Math.log(q) / Math.LN2), q * (J = Math.pow(2, -O)) < 1) O--, J *= 2;
    if (O + f >= 1) q += V / J;
    else q += V * Math.pow(2, 1 - f);
    if (q * J >= 2) O++, J /= 2;
    if (O + f >= X) z = 0, O = X;
    else if (O + f >= 1) z = (q * J - 1) * Math.pow(2, _), O = O + f;
    else z = q * Math.pow(2, f - 1) * Math.pow(2, _), O = 0;
  }
  for (; _ >= 8; $18[K + M] = z & 255, M += N, z /= 256, _ -= 8) ;
  O = O << _ | z, T += _;
  for (; T > 0; $18[K + M] = O & 255, M += N, O /= 256, T -= 8) ;
  $18[K + M - N] |= h * 128;
}
function GK($18) {
  if ($18 > m7) throw RangeError('The value "' + $18 + '" is invalid for option "size"');
  let q = new Uint8Array($18);
  return Object.setPrototypeOf(q, w$.prototype), q;
}
function kH($18, q, K) {
  return class extends K {
    constructor() {
      super();
      Object.defineProperty(this, "message", { value: q.apply(this, arguments), writable: true, configurable: true }), this.name = `${this.name} [${$18}]`, this.stack, delete this.name;
    }
    get code() {
      return $18;
    }
    set code(P) {
      Object.defineProperty(this, "code", { configurable: true, enumerable: true, value: P, writable: true });
    }
    toString() {
      return `${this.name} [${$18}]: ${this.message}`;
    }
  };
}
function w$($18, q, K) {
  if (typeof $18 === "number") {
    if (typeof q === "string") throw TypeError('The "string" argument must be of type string. Received type number');
    return GH($18);
  }
  return OS($18, q, K);
}
function OS($18, q, K) {
  if (typeof $18 === "string") return Nl($18, q);
  if (ArrayBuffer.isView($18)) return Cl($18);
  if ($18 == null) throw TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof $18);
  if (e8($18, ArrayBuffer) || $18 && e8($18.buffer, ArrayBuffer)) return XH($18, q, K);
  if (typeof SharedArrayBuffer < "u" && (e8($18, SharedArrayBuffer) || $18 && e8($18.buffer, SharedArrayBuffer))) return XH($18, q, K);
  if (typeof $18 === "number") throw TypeError('The "value" argument must not be of type number. Received type number');
  let P = $18.valueOf && $18.valueOf();
  if (P != null && P !== $18) return w$.from(P, q, K);
  let _ = El($18);
  if (_) return _;
  if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof $18[Symbol.toPrimitive] === "function") return w$.from($18[Symbol.toPrimitive]("string"), q, K);
  throw TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof $18);
}
function YS($18) {
  if (typeof $18 !== "number") throw TypeError('"size" argument must be of type number');
  else if ($18 < 0) throw RangeError('The value "' + $18 + '" is invalid for option "size"');
}
function Ml($18, q, K) {
  if (YS($18), $18 <= 0) return GK($18);
  if (q !== void 0) return typeof K === "string" ? GK($18).fill(q, K) : GK($18).fill(q);
  return GK($18);
}
function GH($18) {
  return YS($18), GK($18 < 0 ? 0 : VH($18) | 0);
}
function Nl($18, q) {
  if (typeof q !== "string" || q === "") q = "utf8";
  if (!w$.isEncoding(q)) throw TypeError("Unknown encoding: " + q);
  let K = jS($18, q) | 0, P = GK(K), _ = P.write($18, q);
  if (_ !== K) P = P.slice(0, _);
  return P;
}
function ZH($18) {
  let q = $18.length < 0 ? 0 : VH($18.length) | 0, K = GK(q);
  for (let P = 0; P < q; P += 1) K[P] = $18[P] & 255;
  return K;
}
function Cl($18) {
  if (e8($18, Uint8Array)) {
    let q = new Uint8Array($18);
    return XH(q.buffer, q.byteOffset, q.byteLength);
  }
  return ZH($18);
}
function XH($18, q, K) {
  if (q < 0 || $18.byteLength < q) throw RangeError('"offset" is outside of buffer bounds');
  if ($18.byteLength < q + (K || 0)) throw RangeError('"length" is outside of buffer bounds');
  let P;
  if (q === void 0 && K === void 0) P = new Uint8Array($18);
  else if (K === void 0) P = new Uint8Array($18, q);
  else P = new Uint8Array($18, q, K);
  return Object.setPrototypeOf(P, w$.prototype), P;
}
function El($18) {
  if (w$.isBuffer($18)) {
    let q = VH($18.length) | 0, K = GK(q);
    if (K.length === 0) return K;
    return $18.copy(K, 0, 0, q), K;
  }
  if ($18.length !== void 0) {
    if (typeof $18.length !== "number" || Number.isNaN($18.length)) return GK(0);
    return ZH($18);
  }
  if ($18.type === "Buffer" && Array.isArray($18.data)) return ZH($18.data);
}
function VH($18) {
  if ($18 >= m7) throw RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + m7.toString(16) + " bytes");
  return $18 | 0;
}
function jS($18, q) {
  if (w$.isBuffer($18)) return $18.length;
  if (ArrayBuffer.isView($18) || e8($18, ArrayBuffer)) return $18.byteLength;
  if (typeof $18 !== "string") throw TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof $18);
  let K = $18.length, P = arguments.length > 2 && arguments[2] === true;
  if (!P && K === 0) return 0;
  let _ = false;
  for (; ; ) switch (q) {
    case "ascii":
    case "latin1":
    case "binary":
      return K;
    case "utf8":
    case "utf-8":
      return AH($18).length;
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
      return K * 2;
    case "hex":
      return K >>> 1;
    case "base64":
      return ZS($18).length;
    default:
      if (_) return P ? -1 : AH($18).length;
      q = ("" + q).toLowerCase(), _ = true;
  }
}
function hl($18, q, K) {
  let P = false;
  if (q === void 0 || q < 0) q = 0;
  if (q > this.length) return "";
  if (K === void 0 || K > this.length) K = this.length;
  if (K <= 0) return "";
  if (K >>>= 0, q >>>= 0, K <= q) return "";
  if (!$18) $18 = "utf8";
  while (true) switch ($18) {
    case "hex":
      return pl(this, q, K);
    case "utf8":
    case "utf-8":
      return zS(this, q, K);
    case "ascii":
      return ul(this, q, K);
    case "latin1":
    case "binary":
      return xl(this, q, K);
    case "base64":
      return bl(this, q, K);
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
      return cl(this, q, K);
    default:
      if (P) throw TypeError("Unknown encoding: " + $18);
      $18 = ($18 + "").toLowerCase(), P = true;
  }
}
function D_($18, q, K) {
  let P = $18[q];
  $18[q] = $18[K], $18[K] = P;
}
function vS($18, q, K, P, _) {
  if ($18.length === 0) return -1;
  if (typeof K === "string") P = K, K = 0;
  else if (K > 2147483647) K = 2147483647;
  else if (K < -2147483648) K = -2147483648;
  if (K = +K, Number.isNaN(K)) K = _ ? 0 : $18.length - 1;
  if (K < 0) K = $18.length + K;
  if (K >= $18.length) if (_) return -1;
  else K = $18.length - 1;
  else if (K < 0) if (_) K = 0;
  else return -1;
  if (typeof q === "string") q = w$.from(q, P);
  if (w$.isBuffer(q)) {
    if (q.length === 0) return -1;
    return sV($18, q, K, P, _);
  } else if (typeof q === "number") {
    if (q = q & 255, typeof Uint8Array.prototype.indexOf === "function") if (_) return Uint8Array.prototype.indexOf.call($18, q, K);
    else return Uint8Array.prototype.lastIndexOf.call($18, q, K);
    return sV($18, [q], K, P, _);
  }
  throw TypeError("val must be string, number or Buffer");
}
function sV($18, q, K, P, _) {
  let Y = 1, O = $18.length, z = q.length;
  if (P !== void 0) {
    if (P = String(P).toLowerCase(), P === "ucs2" || P === "ucs-2" || P === "utf16le" || P === "utf-16le") {
      if ($18.length < 2 || q.length < 2) return -1;
      Y = 2, O /= 2, z /= 2, K /= 2;
    }
  }
  function J(X, f) {
    if (Y === 1) return X[f];
    else return X.readUInt16BE(f * Y);
  }
  let T;
  if (_) {
    let X = -1;
    for (T = K; T < O; T++) if (J($18, T) === J(q, X === -1 ? 0 : T - X)) {
      if (X === -1) X = T;
      if (T - X + 1 === z) return X * Y;
    } else {
      if (X !== -1) T -= T - X;
      X = -1;
    }
  } else {
    if (K + z > O) K = O - z;
    for (T = K; T >= 0; T--) {
      let X = true;
      for (let f = 0; f < z; f++) if (J($18, T + f) !== J(q, f)) {
        X = false;
        break;
      }
      if (X) return T;
    }
  }
  return -1;
}
function Rl($18, q, K, P) {
  K = Number(K) || 0;
  let _ = $18.length - K;
  if (!P) P = _;
  else if (P = Number(P), P > _) P = _;
  let Y = q.length;
  if (P > Y / 2) P = Y / 2;
  let O;
  for (O = 0; O < P; ++O) {
    let z = parseInt(q.substr(O * 2, 2), 16);
    if (Number.isNaN(z)) return O;
    $18[K + O] = z;
  }
  return O;
}
function Il($18, q, K, P) {
  return t5(AH(q, $18.length - K), $18, K, P);
}
function Dl($18, q, K, P) {
  return t5(rl(q), $18, K, P);
}
function Ll($18, q, K, P) {
  return t5(ZS(q), $18, K, P);
}
function gl($18, q, K, P) {
  return t5(ol(q, $18.length - K), $18, K, P);
}
function bl($18, q, K) {
  if (q === 0 && K === $18.length) return QV($18);
  else return QV($18.slice(q, K));
}
function zS($18, q, K) {
  K = Math.min($18.length, K);
  let P = [], _ = q;
  while (_ < K) {
    let Y = $18[_], O = null, z = Y > 239 ? 4 : Y > 223 ? 3 : Y > 191 ? 2 : 1;
    if (_ + z <= K) {
      let J, T, X, f;
      switch (z) {
        case 1:
          if (Y < 128) O = Y;
          break;
        case 2:
          if (J = $18[_ + 1], (J & 192) === 128) {
            if (f = (Y & 31) << 6 | J & 63, f > 127) O = f;
          }
          break;
        case 3:
          if (J = $18[_ + 1], T = $18[_ + 2], (J & 192) === 128 && (T & 192) === 128) {
            if (f = (Y & 15) << 12 | (J & 63) << 6 | T & 63, f > 2047 && (f < 55296 || f > 57343)) O = f;
          }
          break;
        case 4:
          if (J = $18[_ + 1], T = $18[_ + 2], X = $18[_ + 3], (J & 192) === 128 && (T & 192) === 128 && (X & 192) === 128) {
            if (f = (Y & 15) << 18 | (J & 63) << 12 | (T & 63) << 6 | X & 63, f > 65535 && f < 1114112) O = f;
          }
      }
    }
    if (O === null) O = 65533, z = 1;
    else if (O > 65535) O -= 65536, P.push(O >>> 10 & 1023 | 55296), O = 56320 | O & 1023;
    P.push(O), _ += z;
  }
  return yl(P);
}
function yl($18) {
  let q = $18.length;
  if (q <= $S) return String.fromCharCode.apply(String, $18);
  let K = "", P = 0;
  while (P < q) K += String.fromCharCode.apply(String, $18.slice(P, P += $S));
  return K;
}
function ul($18, q, K) {
  let P = "";
  K = Math.min($18.length, K);
  for (let _ = q; _ < K; ++_) P += String.fromCharCode($18[_] & 127);
  return P;
}
function xl($18, q, K) {
  let P = "";
  K = Math.min($18.length, K);
  for (let _ = q; _ < K; ++_) P += String.fromCharCode($18[_]);
  return P;
}
function pl($18, q, K) {
  let P = $18.length;
  if (!q || q < 0) q = 0;
  if (!K || K < 0 || K > P) K = P;
  let _ = "";
  for (let Y = q; Y < K; ++Y) _ += nl[$18[Y]];
  return _;
}
function cl($18, q, K) {
  let P = $18.slice(q, K), _ = "";
  for (let Y = 0; Y < P.length - 1; Y += 2) _ += String.fromCharCode(P[Y] + P[Y + 1] * 256);
  return _;
}
function Jq($18, q, K) {
  if ($18 % 1 !== 0 || $18 < 0) throw RangeError("offset is not uint");
  if ($18 + q > K) throw RangeError("Trying to access beyond buffer length");
}
function eq($18, q, K, P, _, Y) {
  if (!w$.isBuffer($18)) throw TypeError('"buffer" argument must be a Buffer instance');
  if (q > _ || q < Y) throw RangeError('"value" argument is out of bounds');
  if (K + P > $18.length) throw RangeError("Index out of range");
}
function WS($18, q, K, P, _) {
  fS(q, P, _, $18, K, 7);
  let Y = Number(q & BigInt(4294967295));
  $18[K++] = Y, Y = Y >> 8, $18[K++] = Y, Y = Y >> 8, $18[K++] = Y, Y = Y >> 8, $18[K++] = Y;
  let O = Number(q >> BigInt(32) & BigInt(4294967295));
  return $18[K++] = O, O = O >> 8, $18[K++] = O, O = O >> 8, $18[K++] = O, O = O >> 8, $18[K++] = O, K;
}
function HS($18, q, K, P, _) {
  fS(q, P, _, $18, K, 7);
  let Y = Number(q & BigInt(4294967295));
  $18[K + 7] = Y, Y = Y >> 8, $18[K + 6] = Y, Y = Y >> 8, $18[K + 5] = Y, Y = Y >> 8, $18[K + 4] = Y;
  let O = Number(q >> BigInt(32) & BigInt(4294967295));
  return $18[K + 3] = O, O = O >> 8, $18[K + 2] = O, O = O >> 8, $18[K + 1] = O, O = O >> 8, $18[K] = O, K + 8;
}
function JS($18, q, K, P, _, Y) {
  if (K + P > $18.length) throw RangeError("Index out of range");
  if (K < 0) throw RangeError("Index out of range");
}
function TS($18, q, K, P, _) {
  if (q = +q, K = K >>> 0, !_) JS($18, q, K, 4, 34028234663852886e22, -34028234663852886e22);
  return KS($18, q, K, P, 23, 4), K + 4;
}
function wS($18, q, K, P, _) {
  if (q = +q, K = K >>> 0, !_) JS($18, q, K, 8, 17976931348623157e292, -17976931348623157e292);
  return KS($18, q, K, P, 52, 8), K + 8;
}
function qS($18) {
  let q = "", K = $18.length, P = $18[0] === "-" ? 1 : 0;
  for (; K >= P + 4; K -= 3) q = `_${$18.slice(K - 3, K)}${q}`;
  return `${$18.slice(0, K)}${q}`;
}
function ml($18, q, K) {
  if (y4(q, "offset"), $18[q] === void 0 || $18[q + K] === void 0) d7(q, $18.length - (K + 1));
}
function fS($18, q, K, P, _, Y) {
  if ($18 > K || $18 < q) {
    let O = typeof q === "bigint" ? "n" : "", z;
    if (Y > 3) if (q === 0 || q === BigInt(0)) z = `>= 0${O} and < 2${O} ** ${(Y + 1) * 8}${O}`;
    else z = `>= -(2${O} ** ${(Y + 1) * 8 - 1}${O}) and < 2 ** ${(Y + 1) * 8 - 1}${O}`;
    else z = `>= ${q}${O} and <= ${K}${O}`;
    throw new fH("value", z, $18);
  }
  ml(P, _, Y);
}
function y4($18, q) {
  if (typeof $18 !== "number") throw new Sl(q, "number", $18);
}
function d7($18, q, K) {
  if (Math.floor($18) !== $18) throw y4($18, K), new fH(K || "offset", "an integer", $18);
  if (q < 0) throw new Vl();
  throw new fH(K || "offset", `>= ${K ? 1 : 0} and <= ${q}`, $18);
}
function ll($18) {
  if ($18 = $18.split("=")[0], $18 = $18.trim().replace(dl, ""), $18.length < 2) return "";
  while ($18.length % 4 !== 0) $18 = $18 + "=";
  return $18;
}
function AH($18, q) {
  q = q || 1 / 0;
  let K, P = $18.length, _ = null, Y = [];
  for (let O = 0; O < P; ++O) {
    if (K = $18.charCodeAt(O), K > 55295 && K < 57344) {
      if (!_) {
        if (K > 56319) {
          if ((q -= 3) > -1) Y.push(239, 191, 189);
          continue;
        } else if (O + 1 === P) {
          if ((q -= 3) > -1) Y.push(239, 191, 189);
          continue;
        }
        _ = K;
        continue;
      }
      if (K < 56320) {
        if ((q -= 3) > -1) Y.push(239, 191, 189);
        _ = K;
        continue;
      }
      K = (_ - 55296 << 10 | K - 56320) + 65536;
    } else if (_) {
      if ((q -= 3) > -1) Y.push(239, 191, 189);
    }
    if (_ = null, K < 128) {
      if ((q -= 1) < 0) break;
      Y.push(K);
    } else if (K < 2048) {
      if ((q -= 2) < 0) break;
      Y.push(K >> 6 | 192, K & 63 | 128);
    } else if (K < 65536) {
      if ((q -= 3) < 0) break;
      Y.push(K >> 12 | 224, K >> 6 & 63 | 128, K & 63 | 128);
    } else if (K < 1114112) {
      if ((q -= 4) < 0) break;
      Y.push(K >> 18 | 240, K >> 12 & 63 | 128, K >> 6 & 63 | 128, K & 63 | 128);
    } else throw Error("Invalid code point");
  }
  return Y;
}
function rl($18) {
  let q = [];
  for (let K = 0; K < $18.length; ++K) q.push($18.charCodeAt(K) & 255);
  return q;
}
function ol($18, q) {
  let K, P, _, Y = [];
  for (let O = 0; O < $18.length; ++O) {
    if ((q -= 2) < 0) break;
    K = $18.charCodeAt(O), P = K >> 8, _ = K % 256, Y.push(_), Y.push(P);
  }
  return Y;
}
function ZS($18) {
  return Tl(ll($18));
}
function t5($18, q, K, P) {
  let _;
  for (_ = 0; _ < P; ++_) {
    if (_ + K >= q.length || _ >= $18.length) break;
    q[_ + K] = $18[_];
  }
  return _;
}
function e8($18, q) {
  return $18 instanceof q || $18 != null && $18.constructor != null && $18.constructor.name != null && $18.constructor.name === q.name;
}
function QK($18) {
  return typeof BigInt > "u" ? il : $18;
}
function il() {
  throw Error("BigInt not supported");
}
function SH($18) {
  return () => {
    throw Error($18 + " is not implemented for node:buffer browser polyfill");
  };
}
var Q8;
var V8;
var wH = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var I_;
var aV;
var eV;
var _S = 50;
var m7 = 2147483647;
var PS = 536870888;
var Zl;
var Xl;
var Al;
var kl;
var Gl;
var Vl;
var Sl;
var fH;
var $S = 4096;
var dl;
var nl;
var Bl;
var tl;
var Ul = ($18) => {
  for (let q of $18) if (q.charCodeAt(0) > 127) return false;
  return true;
};
var Fl;
var al;
var wq = p_(() => {
  Q8 = [], V8 = [];
  for (I_ = 0, aV = wH.length; I_ < aV; ++I_) Q8[I_] = wH[I_], V8[wH.charCodeAt(I_)] = I_;
  V8[45] = 62;
  V8[95] = 63;
  eV = typeof Symbol === "function" && typeof Symbol.for === "function" ? Symbol.for("nodejs.util.inspect.custom") : null, Zl = globalThis.btoa, Xl = globalThis.atob, Al = globalThis.File, kl = globalThis.Blob, Gl = { MAX_LENGTH: m7, MAX_STRING_LENGTH: PS };
  Vl = kH("ERR_BUFFER_OUT_OF_BOUNDS", function($18) {
    if ($18) return `${$18} is outside of buffer bounds`;
    return "Attempt to access memory outside buffer bounds";
  }, RangeError), Sl = kH("ERR_INVALID_ARG_TYPE", function($18, q) {
    return `The "${$18}" argument must be of type number. Received type ${typeof q}`;
  }, TypeError), fH = kH("ERR_OUT_OF_RANGE", function($18, q, K) {
    let P = `The value of "${$18}" is out of range.`, _ = K;
    if (Number.isInteger(K) && Math.abs(K) > 4294967296) _ = qS(String(K));
    else if (typeof K === "bigint") {
      if (_ = String(K), K > BigInt(2) ** BigInt(32) || K < -(BigInt(2) ** BigInt(32))) _ = qS(_);
      _ += "n";
    }
    return P += ` It must be ${q}. Received ${_}`, P;
  }, RangeError);
  Object.defineProperty(w$.prototype, "parent", { enumerable: true, get: function() {
    if (!w$.isBuffer(this)) return;
    return this.buffer;
  } });
  Object.defineProperty(w$.prototype, "offset", { enumerable: true, get: function() {
    if (!w$.isBuffer(this)) return;
    return this.byteOffset;
  } });
  w$.poolSize = 8192;
  w$.from = function($18, q, K) {
    return OS($18, q, K);
  };
  Object.setPrototypeOf(w$.prototype, Uint8Array.prototype);
  Object.setPrototypeOf(w$, Uint8Array);
  w$.alloc = function($18, q, K) {
    return Ml($18, q, K);
  };
  w$.allocUnsafe = function($18) {
    return GH($18);
  };
  w$.allocUnsafeSlow = function($18) {
    return GH($18);
  };
  w$.isBuffer = function($18) {
    return $18 != null && $18._isBuffer === true && $18 !== w$.prototype;
  };
  w$.compare = function($18, q) {
    if (e8($18, Uint8Array)) $18 = w$.from($18, $18.offset, $18.byteLength);
    if (e8(q, Uint8Array)) q = w$.from(q, q.offset, q.byteLength);
    if (!w$.isBuffer($18) || !w$.isBuffer(q)) throw TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    if ($18 === q) return 0;
    let K = $18.length, P = q.length;
    for (let _ = 0, Y = Math.min(K, P); _ < Y; ++_) if ($18[_] !== q[_]) {
      K = $18[_], P = q[_];
      break;
    }
    if (K < P) return -1;
    if (P < K) return 1;
    return 0;
  };
  w$.isEncoding = function($18) {
    switch (String($18).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  };
  w$.concat = function($18, q) {
    if (!Array.isArray($18)) throw TypeError('"list" argument must be an Array of Buffers');
    if ($18.length === 0) return w$.alloc(0);
    let K;
    if (q === void 0) {
      q = 0;
      for (K = 0; K < $18.length; ++K) q += $18[K].length;
    }
    let P = w$.allocUnsafe(q), _ = 0;
    for (K = 0; K < $18.length; ++K) {
      let Y = $18[K];
      if (e8(Y, Uint8Array)) if (_ + Y.length > P.length) {
        if (!w$.isBuffer(Y)) Y = w$.from(Y);
        Y.copy(P, _);
      } else Uint8Array.prototype.set.call(P, Y, _);
      else if (!w$.isBuffer(Y)) throw TypeError('"list" argument must be an Array of Buffers');
      else Y.copy(P, _);
      _ += Y.length;
    }
    return P;
  };
  w$.byteLength = jS;
  w$.prototype._isBuffer = true;
  w$.prototype.swap16 = function() {
    let $18 = this.length;
    if ($18 % 2 !== 0) throw RangeError("Buffer size must be a multiple of 16-bits");
    for (let q = 0; q < $18; q += 2) D_(this, q, q + 1);
    return this;
  };
  w$.prototype.swap32 = function() {
    let $18 = this.length;
    if ($18 % 4 !== 0) throw RangeError("Buffer size must be a multiple of 32-bits");
    for (let q = 0; q < $18; q += 4) D_(this, q, q + 3), D_(this, q + 1, q + 2);
    return this;
  };
  w$.prototype.swap64 = function() {
    let $18 = this.length;
    if ($18 % 8 !== 0) throw RangeError("Buffer size must be a multiple of 64-bits");
    for (let q = 0; q < $18; q += 8) D_(this, q, q + 7), D_(this, q + 1, q + 6), D_(this, q + 2, q + 5), D_(this, q + 3, q + 4);
    return this;
  };
  w$.prototype.toString = function() {
    let $18 = this.length;
    if ($18 === 0) return "";
    if (arguments.length === 0) return zS(this, 0, $18);
    return hl.apply(this, arguments);
  };
  w$.prototype.toLocaleString = w$.prototype.toString;
  w$.prototype.equals = function($18) {
    if (!w$.isBuffer($18)) throw TypeError("Argument must be a Buffer");
    if (this === $18) return true;
    return w$.compare(this, $18) === 0;
  };
  w$.prototype.inspect = function() {
    let $18 = "", q = _S;
    if ($18 = this.toString("hex", 0, q).replace(/(.{2})/g, "$1 ").trim(), this.length > q) $18 += " ... ";
    return "<Buffer " + $18 + ">";
  };
  if (eV) w$.prototype[eV] = w$.prototype.inspect;
  w$.prototype.compare = function($18, q, K, P, _) {
    if (e8($18, Uint8Array)) $18 = w$.from($18, $18.offset, $18.byteLength);
    if (!w$.isBuffer($18)) throw TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof $18);
    if (q === void 0) q = 0;
    if (K === void 0) K = $18 ? $18.length : 0;
    if (P === void 0) P = 0;
    if (_ === void 0) _ = this.length;
    if (q < 0 || K > $18.length || P < 0 || _ > this.length) throw RangeError("out of range index");
    if (P >= _ && q >= K) return 0;
    if (P >= _) return -1;
    if (q >= K) return 1;
    if (q >>>= 0, K >>>= 0, P >>>= 0, _ >>>= 0, this === $18) return 0;
    let Y = _ - P, O = K - q, z = Math.min(Y, O), J = this.slice(P, _), T = $18.slice(q, K);
    for (let X = 0; X < z; ++X) if (J[X] !== T[X]) {
      Y = J[X], O = T[X];
      break;
    }
    if (Y < O) return -1;
    if (O < Y) return 1;
    return 0;
  };
  w$.prototype.includes = function($18, q, K) {
    return this.indexOf($18, q, K) !== -1;
  };
  w$.prototype.indexOf = function($18, q, K) {
    return vS(this, $18, q, K, true);
  };
  w$.prototype.lastIndexOf = function($18, q, K) {
    return vS(this, $18, q, K, false);
  };
  w$.prototype.write = function($18, q, K, P) {
    if (q === void 0) P = "utf8", K = this.length, q = 0;
    else if (K === void 0 && typeof q === "string") P = q, K = this.length, q = 0;
    else if (isFinite(q)) if (q = q >>> 0, isFinite(K)) {
      if (K = K >>> 0, P === void 0) P = "utf8";
    } else P = K, K = void 0;
    else throw Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
    let _ = this.length - q;
    if (K === void 0 || K > _) K = _;
    if ($18.length > 0 && (K < 0 || q < 0) || q > this.length) throw RangeError("Attempt to write outside buffer bounds");
    if (!P) P = "utf8";
    let Y = false;
    for (; ; ) switch (P) {
      case "hex":
        return Rl(this, $18, q, K);
      case "utf8":
      case "utf-8":
        return Il(this, $18, q, K);
      case "ascii":
      case "latin1":
      case "binary":
        return Dl(this, $18, q, K);
      case "base64":
        return Ll(this, $18, q, K);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return gl(this, $18, q, K);
      default:
        if (Y) throw TypeError("Unknown encoding: " + P);
        P = ("" + P).toLowerCase(), Y = true;
    }
  };
  w$.prototype.toJSON = function() {
    return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
  };
  w$.prototype.slice = function($18, q) {
    let K = this.length;
    if ($18 = ~~$18, q = q === void 0 ? K : ~~q, $18 < 0) {
      if ($18 += K, $18 < 0) $18 = 0;
    } else if ($18 > K) $18 = K;
    if (q < 0) {
      if (q += K, q < 0) q = 0;
    } else if (q > K) q = K;
    if (q < $18) q = $18;
    let P = this.subarray($18, q);
    return Object.setPrototypeOf(P, w$.prototype), P;
  };
  w$.prototype.readUintLE = w$.prototype.readUIntLE = function($18, q, K) {
    if ($18 = $18 >>> 0, q = q >>> 0, !K) Jq($18, q, this.length);
    let P = this[$18], _ = 1, Y = 0;
    while (++Y < q && (_ *= 256)) P += this[$18 + Y] * _;
    return P;
  };
  w$.prototype.readUintBE = w$.prototype.readUIntBE = function($18, q, K) {
    if ($18 = $18 >>> 0, q = q >>> 0, !K) Jq($18, q, this.length);
    let P = this[$18 + --q], _ = 1;
    while (q > 0 && (_ *= 256)) P += this[$18 + --q] * _;
    return P;
  };
  w$.prototype.readUint8 = w$.prototype.readUInt8 = function($18, q) {
    if ($18 = $18 >>> 0, !q) Jq($18, 1, this.length);
    return this[$18];
  };
  w$.prototype.readUint16LE = w$.prototype.readUInt16LE = function($18, q) {
    if ($18 = $18 >>> 0, !q) Jq($18, 2, this.length);
    return this[$18] | this[$18 + 1] << 8;
  };
  w$.prototype.readUint16BE = w$.prototype.readUInt16BE = function($18, q) {
    if ($18 = $18 >>> 0, !q) Jq($18, 2, this.length);
    return this[$18] << 8 | this[$18 + 1];
  };
  w$.prototype.readUint32LE = w$.prototype.readUInt32LE = function($18, q) {
    if ($18 = $18 >>> 0, !q) Jq($18, 4, this.length);
    return (this[$18] | this[$18 + 1] << 8 | this[$18 + 2] << 16) + this[$18 + 3] * 16777216;
  };
  w$.prototype.readUint32BE = w$.prototype.readUInt32BE = function($18, q) {
    if ($18 = $18 >>> 0, !q) Jq($18, 4, this.length);
    return this[$18] * 16777216 + (this[$18 + 1] << 16 | this[$18 + 2] << 8 | this[$18 + 3]);
  };
  w$.prototype.readBigUInt64LE = QK(function($18) {
    $18 = $18 >>> 0, y4($18, "offset");
    let q = this[$18], K = this[$18 + 7];
    if (q === void 0 || K === void 0) d7($18, this.length - 8);
    let P = q + this[++$18] * 256 + this[++$18] * 65536 + this[++$18] * 16777216, _ = this[++$18] + this[++$18] * 256 + this[++$18] * 65536 + K * 16777216;
    return BigInt(P) + (BigInt(_) << BigInt(32));
  });
  w$.prototype.readBigUInt64BE = QK(function($18) {
    $18 = $18 >>> 0, y4($18, "offset");
    let q = this[$18], K = this[$18 + 7];
    if (q === void 0 || K === void 0) d7($18, this.length - 8);
    let P = q * 16777216 + this[++$18] * 65536 + this[++$18] * 256 + this[++$18], _ = this[++$18] * 16777216 + this[++$18] * 65536 + this[++$18] * 256 + K;
    return (BigInt(P) << BigInt(32)) + BigInt(_);
  });
  w$.prototype.readIntLE = function($18, q, K) {
    if ($18 = $18 >>> 0, q = q >>> 0, !K) Jq($18, q, this.length);
    let P = this[$18], _ = 1, Y = 0;
    while (++Y < q && (_ *= 256)) P += this[$18 + Y] * _;
    if (_ *= 128, P >= _) P -= Math.pow(2, 8 * q);
    return P;
  };
  w$.prototype.readIntBE = function($18, q, K) {
    if ($18 = $18 >>> 0, q = q >>> 0, !K) Jq($18, q, this.length);
    let P = q, _ = 1, Y = this[$18 + --P];
    while (P > 0 && (_ *= 256)) Y += this[$18 + --P] * _;
    if (_ *= 128, Y >= _) Y -= Math.pow(2, 8 * q);
    return Y;
  };
  w$.prototype.readInt8 = function($18, q) {
    if ($18 = $18 >>> 0, !q) Jq($18, 1, this.length);
    if (!(this[$18] & 128)) return this[$18];
    return (255 - this[$18] + 1) * -1;
  };
  w$.prototype.readInt16LE = function($18, q) {
    if ($18 = $18 >>> 0, !q) Jq($18, 2, this.length);
    let K = this[$18] | this[$18 + 1] << 8;
    return K & 32768 ? K | 4294901760 : K;
  };
  w$.prototype.readInt16BE = function($18, q) {
    if ($18 = $18 >>> 0, !q) Jq($18, 2, this.length);
    let K = this[$18 + 1] | this[$18] << 8;
    return K & 32768 ? K | 4294901760 : K;
  };
  w$.prototype.readInt32LE = function($18, q) {
    if ($18 = $18 >>> 0, !q) Jq($18, 4, this.length);
    return this[$18] | this[$18 + 1] << 8 | this[$18 + 2] << 16 | this[$18 + 3] << 24;
  };
  w$.prototype.readInt32BE = function($18, q) {
    if ($18 = $18 >>> 0, !q) Jq($18, 4, this.length);
    return this[$18] << 24 | this[$18 + 1] << 16 | this[$18 + 2] << 8 | this[$18 + 3];
  };
  w$.prototype.readBigInt64LE = QK(function($18) {
    $18 = $18 >>> 0, y4($18, "offset");
    let q = this[$18], K = this[$18 + 7];
    if (q === void 0 || K === void 0) d7($18, this.length - 8);
    let P = this[$18 + 4] + this[$18 + 5] * 256 + this[$18 + 6] * 65536 + (K << 24);
    return (BigInt(P) << BigInt(32)) + BigInt(q + this[++$18] * 256 + this[++$18] * 65536 + this[++$18] * 16777216);
  });
  w$.prototype.readBigInt64BE = QK(function($18) {
    $18 = $18 >>> 0, y4($18, "offset");
    let q = this[$18], K = this[$18 + 7];
    if (q === void 0 || K === void 0) d7($18, this.length - 8);
    let P = (q << 24) + this[++$18] * 65536 + this[++$18] * 256 + this[++$18];
    return (BigInt(P) << BigInt(32)) + BigInt(this[++$18] * 16777216 + this[++$18] * 65536 + this[++$18] * 256 + K);
  });
  w$.prototype.readFloatLE = function($18, q) {
    if ($18 = $18 >>> 0, !q) Jq($18, 4, this.length);
    return B5(this, $18, true, 23, 4);
  };
  w$.prototype.readFloatBE = function($18, q) {
    if ($18 = $18 >>> 0, !q) Jq($18, 4, this.length);
    return B5(this, $18, false, 23, 4);
  };
  w$.prototype.readDoubleLE = function($18, q) {
    if ($18 = $18 >>> 0, !q) Jq($18, 8, this.length);
    return B5(this, $18, true, 52, 8);
  };
  w$.prototype.readDoubleBE = function($18, q) {
    if ($18 = $18 >>> 0, !q) Jq($18, 8, this.length);
    return B5(this, $18, false, 52, 8);
  };
  w$.prototype.writeUintLE = w$.prototype.writeUIntLE = function($18, q, K, P) {
    if ($18 = +$18, q = q >>> 0, K = K >>> 0, !P) {
      let O = Math.pow(2, 8 * K) - 1;
      eq(this, $18, q, K, O, 0);
    }
    let _ = 1, Y = 0;
    this[q] = $18 & 255;
    while (++Y < K && (_ *= 256)) this[q + Y] = $18 / _ & 255;
    return q + K;
  };
  w$.prototype.writeUintBE = w$.prototype.writeUIntBE = function($18, q, K, P) {
    if ($18 = +$18, q = q >>> 0, K = K >>> 0, !P) {
      let O = Math.pow(2, 8 * K) - 1;
      eq(this, $18, q, K, O, 0);
    }
    let _ = K - 1, Y = 1;
    this[q + _] = $18 & 255;
    while (--_ >= 0 && (Y *= 256)) this[q + _] = $18 / Y & 255;
    return q + K;
  };
  w$.prototype.writeUint8 = w$.prototype.writeUInt8 = function($18, q, K) {
    if ($18 = +$18, q = q >>> 0, !K) eq(this, $18, q, 1, 255, 0);
    return this[q] = $18 & 255, q + 1;
  };
  w$.prototype.writeUint16LE = w$.prototype.writeUInt16LE = function($18, q, K) {
    if ($18 = +$18, q = q >>> 0, !K) eq(this, $18, q, 2, 65535, 0);
    return this[q] = $18 & 255, this[q + 1] = $18 >>> 8, q + 2;
  };
  w$.prototype.writeUint16BE = w$.prototype.writeUInt16BE = function($18, q, K) {
    if ($18 = +$18, q = q >>> 0, !K) eq(this, $18, q, 2, 65535, 0);
    return this[q] = $18 >>> 8, this[q + 1] = $18 & 255, q + 2;
  };
  w$.prototype.writeUint32LE = w$.prototype.writeUInt32LE = function($18, q, K) {
    if ($18 = +$18, q = q >>> 0, !K) eq(this, $18, q, 4, 4294967295, 0);
    return this[q + 3] = $18 >>> 24, this[q + 2] = $18 >>> 16, this[q + 1] = $18 >>> 8, this[q] = $18 & 255, q + 4;
  };
  w$.prototype.writeUint32BE = w$.prototype.writeUInt32BE = function($18, q, K) {
    if ($18 = +$18, q = q >>> 0, !K) eq(this, $18, q, 4, 4294967295, 0);
    return this[q] = $18 >>> 24, this[q + 1] = $18 >>> 16, this[q + 2] = $18 >>> 8, this[q + 3] = $18 & 255, q + 4;
  };
  w$.prototype.writeBigUInt64LE = QK(function($18, q = 0) {
    return WS(this, $18, q, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  w$.prototype.writeBigUInt64BE = QK(function($18, q = 0) {
    return HS(this, $18, q, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  w$.prototype.writeIntLE = function($18, q, K, P) {
    if ($18 = +$18, q = q >>> 0, !P) {
      let z = Math.pow(2, 8 * K - 1);
      eq(this, $18, q, K, z - 1, -z);
    }
    let _ = 0, Y = 1, O = 0;
    this[q] = $18 & 255;
    while (++_ < K && (Y *= 256)) {
      if ($18 < 0 && O === 0 && this[q + _ - 1] !== 0) O = 1;
      this[q + _] = ($18 / Y >> 0) - O & 255;
    }
    return q + K;
  };
  w$.prototype.writeIntBE = function($18, q, K, P) {
    if ($18 = +$18, q = q >>> 0, !P) {
      let z = Math.pow(2, 8 * K - 1);
      eq(this, $18, q, K, z - 1, -z);
    }
    let _ = K - 1, Y = 1, O = 0;
    this[q + _] = $18 & 255;
    while (--_ >= 0 && (Y *= 256)) {
      if ($18 < 0 && O === 0 && this[q + _ + 1] !== 0) O = 1;
      this[q + _] = ($18 / Y >> 0) - O & 255;
    }
    return q + K;
  };
  w$.prototype.writeInt8 = function($18, q, K) {
    if ($18 = +$18, q = q >>> 0, !K) eq(this, $18, q, 1, 127, -128);
    if ($18 < 0) $18 = 255 + $18 + 1;
    return this[q] = $18 & 255, q + 1;
  };
  w$.prototype.writeInt16LE = function($18, q, K) {
    if ($18 = +$18, q = q >>> 0, !K) eq(this, $18, q, 2, 32767, -32768);
    return this[q] = $18 & 255, this[q + 1] = $18 >>> 8, q + 2;
  };
  w$.prototype.writeInt16BE = function($18, q, K) {
    if ($18 = +$18, q = q >>> 0, !K) eq(this, $18, q, 2, 32767, -32768);
    return this[q] = $18 >>> 8, this[q + 1] = $18 & 255, q + 2;
  };
  w$.prototype.writeInt32LE = function($18, q, K) {
    if ($18 = +$18, q = q >>> 0, !K) eq(this, $18, q, 4, 2147483647, -2147483648);
    return this[q] = $18 & 255, this[q + 1] = $18 >>> 8, this[q + 2] = $18 >>> 16, this[q + 3] = $18 >>> 24, q + 4;
  };
  w$.prototype.writeInt32BE = function($18, q, K) {
    if ($18 = +$18, q = q >>> 0, !K) eq(this, $18, q, 4, 2147483647, -2147483648);
    if ($18 < 0) $18 = 4294967295 + $18 + 1;
    return this[q] = $18 >>> 24, this[q + 1] = $18 >>> 16, this[q + 2] = $18 >>> 8, this[q + 3] = $18 & 255, q + 4;
  };
  w$.prototype.writeBigInt64LE = QK(function($18, q = 0) {
    return WS(this, $18, q, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  w$.prototype.writeBigInt64BE = QK(function($18, q = 0) {
    return HS(this, $18, q, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  w$.prototype.writeFloatLE = function($18, q, K) {
    return TS(this, $18, q, true, K);
  };
  w$.prototype.writeFloatBE = function($18, q, K) {
    return TS(this, $18, q, false, K);
  };
  w$.prototype.writeDoubleLE = function($18, q, K) {
    return wS(this, $18, q, true, K);
  };
  w$.prototype.writeDoubleBE = function($18, q, K) {
    return wS(this, $18, q, false, K);
  };
  w$.prototype.copy = function($18, q, K, P) {
    if (!w$.isBuffer($18)) throw TypeError("argument should be a Buffer");
    if (!K) K = 0;
    if (!P && P !== 0) P = this.length;
    if (q >= $18.length) q = $18.length;
    if (!q) q = 0;
    if (P > 0 && P < K) P = K;
    if (P === K) return 0;
    if ($18.length === 0 || this.length === 0) return 0;
    if (q < 0) throw RangeError("targetStart out of bounds");
    if (K < 0 || K >= this.length) throw RangeError("Index out of range");
    if (P < 0) throw RangeError("sourceEnd out of bounds");
    if (P > this.length) P = this.length;
    if ($18.length - q < P - K) P = $18.length - q + K;
    let _ = P - K;
    if (this === $18 && typeof Uint8Array.prototype.copyWithin === "function") this.copyWithin(q, K, P);
    else Uint8Array.prototype.set.call($18, this.subarray(K, P), q);
    return _;
  };
  w$.prototype.fill = function($18, q, K, P) {
    if (typeof $18 === "string") {
      if (typeof q === "string") P = q, q = 0, K = this.length;
      else if (typeof K === "string") P = K, K = this.length;
      if (P !== void 0 && typeof P !== "string") throw TypeError("encoding must be a string");
      if (typeof P === "string" && !w$.isEncoding(P)) throw TypeError("Unknown encoding: " + P);
      if ($18.length === 1) {
        let Y = $18.charCodeAt(0);
        if (P === "utf8" && Y < 128 || P === "latin1") $18 = Y;
      }
    } else if (typeof $18 === "number") $18 = $18 & 255;
    else if (typeof $18 === "boolean") $18 = Number($18);
    if (q < 0 || this.length < q || this.length < K) throw RangeError("Out of range index");
    if (K <= q) return this;
    if (q = q >>> 0, K = K === void 0 ? this.length : K >>> 0, !$18) $18 = 0;
    let _;
    if (typeof $18 === "number") for (_ = q; _ < K; ++_) this[_] = $18;
    else {
      let Y = w$.isBuffer($18) ? $18 : w$.from($18, P), O = Y.length;
      if (O === 0) throw TypeError('The value "' + $18 + '" is invalid for argument "value"');
      for (_ = 0; _ < K - q; ++_) this[_ + q] = Y[_ % O];
    }
    return this;
  };
  dl = /[^+/0-9A-Za-z-_]/g;
  nl = function() {
    let $18 = Array(256);
    for (let q = 0; q < 16; ++q) {
      let K = q * 16;
      for (let P = 0; P < 16; ++P) $18[K + P] = "0123456789abcdef"[q] + "0123456789abcdef"[P];
    }
    return $18;
  }();
  Bl = SH("resolveObjectURL"), tl = SH("isUtf8"), Fl = SH("transcode"), al = w$;
});
var ES = {};
lq(ES, { types: () => Yr, promisify: () => SS, log: () => kS, isUndefined: () => u4, isSymbol: () => vr, isString: () => s5, isRegExp: () => U5, isPrimitive: () => zr, isObject: () => x4, isNumber: () => AS, isNullOrUndefined: () => jr, isNull: () => e5, isFunction: () => a5, isError: () => F5, isDate: () => EH, isBuffer: () => Wr, isBoolean: () => RH, isArray: () => XS, inspect: () => L_, inherits: () => GS, format: () => hH, deprecate: () => el, default: () => Tr, debuglog: () => sl, callbackifyOnRejected: () => LH, callbackify: () => MS, _extend: () => DH, TextEncoder: () => NS, TextDecoder: () => CS });
function hH($18, ...q) {
  if (!s5($18)) {
    var K = [$18];
    for (var P = 0; P < q.length; P++) K.push(L_(q[P]));
    return K.join(" ");
  }
  var P = 0, _ = q.length, Y = String($18).replace(Ql, function(z) {
    if (z === "%%") return "%";
    if (P >= _) return z;
    switch (z) {
      case "%s":
        return String(q[P++]);
      case "%d":
        return Number(q[P++]);
      case "%j":
        try {
          return JSON.stringify(q[P++]);
        } catch (J) {
          return "[Circular]";
        }
      default:
        return z;
    }
  });
  for (var O = q[P]; P < _; O = q[++P]) if (e5(O) || !x4(O)) Y += " " + O;
  else Y += " " + L_(O);
  return Y;
}
function el($18, q) {
  if (typeof process > "u" || (process == null ? void 0 : process.noDeprecation) === true) return $18;
  var K = false;
  function P(..._) {
    if (!K) {
      if (process.throwDeprecation) throw Error(q);
      else if (process.traceDeprecation) console.trace(q);
      else console.error(q);
      K = true;
    }
    return $18.apply(this, ..._);
  }
  return P;
}
function $r($18, q) {
  var K = L_.styles[q];
  if (K) return "\x1B[" + L_.colors[K][0] + "m" + $18 + "\x1B[" + L_.colors[K][1] + "m";
  else return $18;
}
function qr($18, q) {
  return $18;
}
function Kr($18) {
  var q = {};
  return $18.forEach(function(K, P) {
    q[K] = true;
  }), q;
}
function Q5($18, q, K) {
  if ($18.customInspect && q && a5(q.inspect) && q.inspect !== L_ && !(q.constructor && q.constructor.prototype === q)) {
    var P = q.inspect(K, $18);
    if (!s5(P)) P = Q5($18, P, K);
    return P;
  }
  var _ = _r($18, q);
  if (_) return _;
  var Y = Object.keys(q), O = Kr(Y);
  if ($18.showHidden) Y = Object.getOwnPropertyNames(q);
  if (F5(q) && (Y.indexOf("message") >= 0 || Y.indexOf("description") >= 0)) return MH(q);
  if (Y.length === 0) {
    if (a5(q)) {
      var z = q.name ? ": " + q.name : "";
      return $18.stylize("[Function" + z + "]", "special");
    }
    if (U5(q)) return $18.stylize(RegExp.prototype.toString.call(q), "regexp");
    if (EH(q)) return $18.stylize(Date.prototype.toString.call(q), "date");
    if (F5(q)) return MH(q);
  }
  var J = "", T = false, X = ["{", "}"];
  if (XS(q)) T = true, X = ["[", "]"];
  if (a5(q)) {
    var f = q.name ? ": " + q.name : "";
    J = " [Function" + f + "]";
  }
  if (U5(q)) J = " " + RegExp.prototype.toString.call(q);
  if (EH(q)) J = " " + Date.prototype.toUTCString.call(q);
  if (F5(q)) J = " " + MH(q);
  if (Y.length === 0 && (!T || q.length == 0)) return X[0] + J + X[1];
  if (K < 0) if (U5(q)) return $18.stylize(RegExp.prototype.toString.call(q), "regexp");
  else return $18.stylize("[Object]", "special");
  $18.seen.push(q);
  var V;
  if (T) V = Pr($18, q, K, O, Y);
  else V = Y.map(function(M) {
    return CH($18, q, K, O, M, T);
  });
  return $18.seen.pop(), Or(V, J, X);
}
function _r($18, q) {
  if (u4(q)) return $18.stylize("undefined", "undefined");
  if (s5(q)) {
    var K = "'" + JSON.stringify(q).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
    return $18.stylize(K, "string");
  }
  if (AS(q)) return $18.stylize("" + q, "number");
  if (RH(q)) return $18.stylize("" + q, "boolean");
  if (e5(q)) return $18.stylize("null", "null");
}
function MH($18) {
  return "[" + Error.prototype.toString.call($18) + "]";
}
function Pr($18, q, K, P, _) {
  var Y = [];
  for (var O = 0, z = q.length; O < z; ++O) if (VS(q, String(O))) Y.push(CH($18, q, K, P, String(O), true));
  else Y.push("");
  return _.forEach(function(J) {
    if (!J.match(/^\d+$/)) Y.push(CH($18, q, K, P, J, true));
  }), Y;
}
function CH($18, q, K, P, _, Y) {
  var O, z, J;
  if (J = Object.getOwnPropertyDescriptor(q, _) || { value: q[_] }, J.get) if (J.set) z = $18.stylize("[Getter/Setter]", "special");
  else z = $18.stylize("[Getter]", "special");
  else if (J.set) z = $18.stylize("[Setter]", "special");
  if (!VS(P, _)) O = "[" + _ + "]";
  if (!z) if ($18.seen.indexOf(J.value) < 0) {
    if (e5(K)) z = Q5($18, J.value, null);
    else z = Q5($18, J.value, K - 1);
    if (z.indexOf(`
`) > -1) if (Y) z = z.split(`
`).map(function(T) {
      return "  " + T;
    }).join(`
`).slice(2);
    else z = `
` + z.split(`
`).map(function(T) {
      return "   " + T;
    }).join(`
`);
  } else z = $18.stylize("[Circular]", "special");
  if (u4(O)) {
    if (Y && _.match(/^\d+$/)) return z;
    if (O = JSON.stringify("" + _), O.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) O = O.slice(1, -1), O = $18.stylize(O, "name");
    else O = O.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), O = $18.stylize(O, "string");
  }
  return O + ": " + z;
}
function Or($18, q, K) {
  var P = 0, _ = $18.reduce(function(Y, O) {
    if (P++, O.indexOf(`
`) >= 0) P++;
    return Y + O.replace(/\u001b\[\d\d?m/g, "").length + 1;
  }, 0);
  if (_ > 60) return K[0] + (q === "" ? "" : q + `
 `) + " " + $18.join(`,
  `) + " " + K[1];
  return K[0] + q + " " + $18.join(", ") + " " + K[1];
}
function XS($18) {
  return Array.isArray($18);
}
function RH($18) {
  return typeof $18 === "boolean";
}
function e5($18) {
  return $18 === null;
}
function jr($18) {
  return $18 == null;
}
function AS($18) {
  return typeof $18 === "number";
}
function s5($18) {
  return typeof $18 === "string";
}
function vr($18) {
  return typeof $18 === "symbol";
}
function u4($18) {
  return $18 === void 0;
}
function U5($18) {
  return x4($18) && IH($18) === "[object RegExp]";
}
function x4($18) {
  return typeof $18 === "object" && $18 !== null;
}
function EH($18) {
  return x4($18) && IH($18) === "[object Date]";
}
function F5($18) {
  return x4($18) && (IH($18) === "[object Error]" || $18 instanceof Error);
}
function a5($18) {
  return typeof $18 === "function";
}
function zr($18) {
  return $18 === null || typeof $18 === "boolean" || typeof $18 === "number" || typeof $18 === "string" || typeof $18 === "symbol" || typeof $18 > "u";
}
function Wr($18) {
  return $18 instanceof Buffer;
}
function IH($18) {
  return Object.prototype.toString.call($18);
}
function NH($18) {
  return $18 < 10 ? "0" + $18.toString(10) : $18.toString(10);
}
function Jr() {
  var $18 = /* @__PURE__ */ new Date(), q = [NH($18.getHours()), NH($18.getMinutes()), NH($18.getSeconds())].join(":");
  return [$18.getDate(), Hr[$18.getMonth()], q].join(" ");
}
function kS(...$18) {
  console.log("%s - %s", Jr(), hH.apply(null, $18));
}
function GS($18, q) {
  if (q) $18.super_ = q, $18.prototype = Object.create(q.prototype, { constructor: { value: $18, enumerable: false, writable: true, configurable: true } });
}
function DH($18, q) {
  if (!q || !x4(q)) return $18;
  var K = Object.keys(q), P = K.length;
  while (P--) $18[K[P]] = q[K[P]];
  return $18;
}
function VS($18, q) {
  return Object.prototype.hasOwnProperty.call($18, q);
}
function LH($18, q) {
  if (!$18) {
    var K = Error("Promise was rejected with a falsy value");
    K.reason = $18, $18 = K;
  }
  return q($18);
}
function MS($18) {
  if (typeof $18 !== "function") throw TypeError('The "original" argument must be of type Function');
  function q(...K) {
    var P = K.pop();
    if (typeof P !== "function") throw TypeError("The last argument must be of type Function");
    var _ = this, Y = function(...O) {
      return P.apply(_, ...O);
    };
    $18.apply(this, K).then(function(O) {
      process.nextTick(Y.bind(null, null, O));
    }, function(O) {
      process.nextTick(LH.bind(null, O, Y));
    });
  }
  return Object.setPrototypeOf(q, Object.getPrototypeOf($18)), Object.defineProperties(q, Object.getOwnPropertyDescriptors($18)), q;
}
var Ql;
var sl;
var L_;
var Yr = () => {
};
var Hr;
var SS;
var NS;
var CS;
var Tr;
var hS = p_(() => {
  Ql = /%[sdj%]/g;
  sl = (($18 = {}, q = {}, K) => ((K = typeof process < "u" && false) && (K = K.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase()), q = new RegExp("^" + K + "$", "i"), (P) => {
    if (P = P.toUpperCase(), !$18[P]) if (q.test(P)) $18[P] = function(..._) {
      console.error("%s: %s", P, pid, hH.apply(null, ..._));
    };
    else $18[P] = function() {
    };
    return $18[P];
  }))(), L_ = (($18) => ($18.colors = { bold: [1, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], white: [37, 39], grey: [90, 39], black: [30, 39], blue: [34, 39], cyan: [36, 39], green: [32, 39], magenta: [35, 39], red: [31, 39], yellow: [33, 39] }, $18.styles = { special: "cyan", number: "yellow", boolean: "yellow", undefined: "grey", null: "bold", string: "green", date: "magenta", regexp: "red" }, $18.custom = Symbol.for("nodejs.util.inspect.custom"), $18))(function($18, q, ...K) {
    var P = { seen: [], stylize: qr };
    if (K.length >= 1) P.depth = K[0];
    if (K.length >= 2) P.colors = K[1];
    if (RH(q)) P.showHidden = q;
    else if (q) DH(P, q);
    if (u4(P.showHidden)) P.showHidden = false;
    if (u4(P.depth)) P.depth = 2;
    if (u4(P.colors)) P.colors = false;
    if (P.colors) P.stylize = $r;
    return Q5(P, $18, P.depth);
  });
  Hr = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
  SS = (($18) => ($18.custom = Symbol.for("nodejs.util.promisify.custom"), $18))(function($18) {
    if (typeof $18 !== "function") throw TypeError('The "original" argument must be of type Function');
    if (kCustomPromisifiedSymbol && $18[kCustomPromisifiedSymbol]) {
      var q = $18[kCustomPromisifiedSymbol];
      if (typeof q !== "function") throw TypeError('The "nodejs.util.promisify.custom" argument must be of type Function');
      return Object.defineProperty(q, kCustomPromisifiedSymbol, { value: q, enumerable: false, writable: false, configurable: true }), q;
    }
    function q(...K) {
      var P, _, Y = new Promise(function(O, z) {
        P = O, _ = z;
      });
      K.push(function(O, z) {
        if (O) _(O);
        else P(z);
      });
      try {
        $18.apply(this, K);
      } catch (O) {
        _(O);
      }
      return Y;
    }
    if (Object.setPrototypeOf(q, Object.getPrototypeOf($18)), kCustomPromisifiedSymbol) Object.defineProperty(q, kCustomPromisifiedSymbol, { value: q, enumerable: false, writable: false, configurable: true });
    return Object.defineProperties(q, Object.getOwnPropertyDescriptors($18));
  });
  ({ TextEncoder: NS, TextDecoder: CS } = globalThis), Tr = { TextEncoder: NS, TextDecoder: CS, promisify: SS, log: kS, inherits: GS, _extend: DH, callbackifyOnRejected: LH, callbackify: MS };
});
var r7 = {};
lq(r7, { setMaxListeners: () => cS, once: () => xS, listenerCount: () => mS, init: () => eK, getMaxListeners: () => lS, getEventListeners: () => pS, default: () => Sr, captureRejectionSymbol: () => gS, addAbortListener: () => rS, EventEmitter: () => eK });
function bS($18, q) {
  var { _events: K } = $18;
  if (q[0] ?? (q[0] = Error("Unhandled error.")), !K) throw q[0];
  var P = K[LS];
  if (P) for (var _ of IS.call(P)) _.apply($18, q);
  var Y = K.error;
  if (!Y) throw q[0];
  for (var _ of IS.call(Y)) _.apply($18, q);
  return true;
}
function Zr($18, q, K, P) {
  q.then(void 0, function(_) {
    queueMicrotask(() => Xr($18, _, K, P));
  });
}
function Xr($18, q, K, P) {
  if (typeof $18[RS] === "function") $18[RS](q, K, ...P);
  else try {
    $18[g_] = false, $18.emit("error", q);
  } finally {
    $18[g_] = true;
  }
}
function yS($18, q, K) {
  K.warned = true;
  let P = Error(`Possible EventEmitter memory leak detected. ${K.length} ${String(q)} listeners added to [${$18.constructor.name}]. Use emitter.setMaxListeners() to increase limit`);
  P.name = "MaxListenersExceededWarning", P.emitter = $18, P.type = q, P.count = K.length, console.warn(P);
}
function uS($18, q, ...K) {
  this.removeListener($18, q), q.apply(this, K);
}
function xS($18, q, K) {
  var P = K == null ? void 0 : K.signal;
  if (dS(P, "options.signal"), P == null ? void 0 : P.aborted) throw new gH(void 0, { cause: P == null ? void 0 : P.reason });
  let { resolve: _, reject: Y, promise: O } = $newPromiseCapability(Promise), z = (X) => {
    if ($18.removeListener(q, J), P != null) $O(P, "abort", T);
    Y(X);
  }, J = (...X) => {
    if (typeof $18.removeListener === "function") $18.removeListener("error", z);
    if (P != null) $O(P, "abort", T);
    _(X);
  };
  if (DS($18, q, J, { once: true }), q !== "error" && typeof $18.once === "function") $18.once("error", z);
  function T() {
    $O($18, q, J), $O($18, "error", z), Y(new gH(void 0, { cause: P == null ? void 0 : P.reason }));
  }
  if (P != null) DS(P, "abort", T, { once: true });
  return O;
}
function pS($18, q) {
  return $18.listeners(q);
}
function cS($18, ...q) {
  yH($18, "setMaxListeners", 0);
  var K;
  if (q && (K = q.length)) for (let P = 0; P < K; P++) q[P].setMaxListeners($18);
  else b_ = $18;
}
function mS($18, q) {
  return $18.listenerCount(q);
}
function $O($18, q, K, P) {
  if (typeof $18.removeListener === "function") $18.removeListener(q, K);
  else $18.removeEventListener(q, K, P);
}
function DS($18, q, K, P) {
  if (typeof $18.on === "function") if (P.once) $18.once(q, K);
  else $18.on(q, K);
  else $18.addEventListener(q, K, P);
}
function p4($18, q, K) {
  let P = TypeError(`The "${$18}" argument must be of type ${q}. Received ${K}`);
  return P.code = "ERR_INVALID_ARG_TYPE", P;
}
function Gr($18, q, K) {
  let P = RangeError(`The "${$18}" argument is out of range. It must be ${q}. Received ${K}`);
  return P.code = "ERR_OUT_OF_RANGE", P;
}
function dS($18, q) {
  if ($18 !== void 0 && ($18 === null || typeof $18 !== "object" || !("aborted" in $18))) throw p4(q, "AbortSignal", $18);
}
function yH($18, q, K, P) {
  if (typeof $18 !== "number") throw p4(q, "number", $18);
  if (K != null && $18 < K || P != null && $18 > P || (K != null || P != null) && Number.isNaN($18)) throw Gr(q, `${K != null ? `>= ${K}` : ""}${K != null && P != null ? " && " : ""}${P != null ? `<= ${P}` : ""}`, $18);
}
function l7($18) {
  if (typeof $18 !== "function") throw TypeError("The listener must be a function");
}
function Vr($18, q) {
  if (typeof $18 !== "boolean") throw p4(q, "boolean", $18);
}
function lS($18) {
  return ($18 == null ? void 0 : $18._maxListeners) ?? b_;
}
function rS($18, q) {
  if ($18 === void 0) throw p4("signal", "AbortSignal", $18);
  if (dS($18, "signal"), typeof q !== "function") throw p4("listener", "function", q);
  let K;
  if ($18.aborted) queueMicrotask(() => q());
  else $18.addEventListener("abort", q, { __proto__: null, once: true }), K = () => {
    $18.removeEventListener("abort", q);
  };
  return { __proto__: null, [Symbol.dispose]() {
    K == null ? void 0 : K();
  } };
}
var bH;
var g_;
var LS;
var wr;
var fr;
var RS;
var gS;
var IS;
var b_ = 10;
var eK = function($18) {
  if (this._events === void 0 || this._events === this.__proto__._events) this._events = { __proto__: null }, this._eventsCount = 0;
  if (this._maxListeners ?? (this._maxListeners = void 0), this[g_] = ($18 == null ? void 0 : $18.captureRejections) ? Boolean($18 == null ? void 0 : $18.captureRejections) : g6[g_]) this.emit = kr;
};
var g6;
var Ar = function($18, ...q) {
  if ($18 === "error") return bS(this, q);
  var { _events: K } = this;
  if (K === void 0) return false;
  var P = K[$18];
  if (P === void 0) return false;
  let _ = P.length > 1 ? P.slice() : P;
  for (let Y = 0, { length: O } = _; Y < O; Y++) {
    let z = _[Y];
    switch (q.length) {
      case 0:
        z.call(this);
        break;
      case 1:
        z.call(this, q[0]);
        break;
      case 2:
        z.call(this, q[0], q[1]);
        break;
      case 3:
        z.call(this, q[0], q[1], q[2]);
        break;
      default:
        z.apply(this, q);
        break;
    }
  }
  return true;
};
var kr = function($18, ...q) {
  if ($18 === "error") return bS(this, q);
  var { _events: K } = this;
  if (K === void 0) return false;
  var P = K[$18];
  if (P === void 0) return false;
  let _ = P.length > 1 ? P.slice() : P;
  for (let Y = 0, { length: O } = _; Y < O; Y++) {
    let z = _[Y], J;
    switch (q.length) {
      case 0:
        J = z.call(this);
        break;
      case 1:
        J = z.call(this, q[0]);
        break;
      case 2:
        J = z.call(this, q[0], q[1]);
        break;
      case 3:
        J = z.call(this, q[0], q[1], q[2]);
        break;
      default:
        J = z.apply(this, q);
        break;
    }
    if (J !== void 0 && typeof (J == null ? void 0 : J.then) === "function" && J.then === Promise.prototype.then) Zr(this, J, $18, q);
  }
  return true;
};
var gH;
var Sr;
var o7 = p_(() => {
  bH = Symbol.for, g_ = Symbol("kCapture"), LS = bH("events.errorMonitor"), wr = Symbol("events.maxEventTargetListeners"), fr = Symbol("events.maxEventTargetListenersWarned"), RS = bH("nodejs.rejection"), gS = bH("nodejs.rejection"), IS = Array.prototype.slice, g6 = eK.prototype = {};
  g6._events = void 0;
  g6._eventsCount = 0;
  g6._maxListeners = void 0;
  g6.setMaxListeners = function($18) {
    return yH($18, "setMaxListeners", 0), this._maxListeners = $18, this;
  };
  g6.constructor = eK;
  g6.getMaxListeners = function() {
    return (this == null ? void 0 : this._maxListeners) ?? b_;
  };
  g6.emit = Ar;
  g6.addListener = function($18, q) {
    l7(q);
    var K = this._events;
    if (!K) K = this._events = { __proto__: null }, this._eventsCount = 0;
    else if (K.newListener) this.emit("newListener", $18, q.listener ?? q);
    var P = K[$18];
    if (!P) K[$18] = [q], this._eventsCount++;
    else {
      P.push(q);
      var _ = this._maxListeners ?? b_;
      if (_ > 0 && P.length > _ && !P.warned) yS(this, $18, P);
    }
    return this;
  };
  g6.on = g6.addListener;
  g6.prependListener = function($18, q) {
    l7(q);
    var K = this._events;
    if (!K) K = this._events = { __proto__: null }, this._eventsCount = 0;
    else if (K.newListener) this.emit("newListener", $18, q.listener ?? q);
    var P = K[$18];
    if (!P) K[$18] = [q], this._eventsCount++;
    else {
      P.unshift(q);
      var _ = this._maxListeners ?? b_;
      if (_ > 0 && P.length > _ && !P.warned) yS(this, $18, P);
    }
    return this;
  };
  g6.once = function($18, q) {
    l7(q);
    let K = uS.bind(this, $18, q);
    return K.listener = q, this.addListener($18, K), this;
  };
  g6.prependOnceListener = function($18, q) {
    l7(q);
    let K = uS.bind(this, $18, q);
    return K.listener = q, this.prependListener($18, K), this;
  };
  g6.removeListener = function($18, q) {
    l7(q);
    var { _events: K } = this;
    if (!K) return this;
    var P = K[$18];
    if (!P) return this;
    var _ = P.length;
    let Y = -1;
    for (let O = _ - 1; O >= 0; O--) if (P[O] === q || P[O].listener === q) {
      Y = O;
      break;
    }
    if (Y < 0) return this;
    if (Y === 0) P.shift();
    else P.splice(Y, 1);
    if (P.length === 0) delete K[$18], this._eventsCount--;
    return this;
  };
  g6.off = g6.removeListener;
  g6.removeAllListeners = function($18) {
    var { _events: q } = this;
    if ($18 && q) {
      if (q[$18]) delete q[$18], this._eventsCount--;
    } else this._events = { __proto__: null };
    return this;
  };
  g6.listeners = function($18) {
    var { _events: q } = this;
    if (!q) return [];
    var K = q[$18];
    if (!K) return [];
    return K.map((P) => P.listener ?? P);
  };
  g6.rawListeners = function($18) {
    var { _events: q } = this;
    if (!q) return [];
    var K = q[$18];
    if (!K) return [];
    return K.slice();
  };
  g6.listenerCount = function($18) {
    var _a2;
    var { _events: q } = this;
    if (!q) return 0;
    return ((_a2 = q[$18]) == null ? void 0 : _a2.length) ?? 0;
  };
  g6.eventNames = function() {
    return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
  };
  g6[g_] = false;
  gH = class gH extends Error {
    constructor($18 = "The operation was aborted", q = void 0) {
      if (q !== void 0 && typeof q !== "object") throw p4("options", "Object", q);
      super($18, q);
      this.code = "ABORT_ERR", this.name = "AbortError";
    }
  };
  Object.defineProperties(eK, { captureRejections: { get() {
    return g6[g_];
  }, set($18) {
    Vr($18, "EventEmitter.captureRejections"), g6[g_] = $18;
  }, enumerable: true }, defaultMaxListeners: { enumerable: true, get: () => {
    return b_;
  }, set: ($18) => {
    yH($18, "defaultMaxListeners", 0), b_ = $18;
  } }, kMaxEventTargetListeners: { value: wr, enumerable: false, configurable: false, writable: false }, kMaxEventTargetListenersWarned: { value: fr, enumerable: false, configurable: false, writable: false } });
  Object.assign(eK, { once: xS, getEventListeners: pS, getMaxListeners: lS, setMaxListeners: cS, EventEmitter: eK, usingDomains: false, captureRejectionSymbol: gS, errorMonitor: LS, addAbortListener: rS, init: eK, listenerCount: mS });
  Sr = eK;
});
var cH = x$((HP$, aS) => {
  var V6 = ($18, q) => () => (q || $18((q = { exports: {} }).exports, q), q.exports), u6 = V6(($18, q) => {
    class K extends Error {
      constructor(P) {
        if (!Array.isArray(P)) throw TypeError(`Expected input to be an Array, got ${typeof P}`);
        let _ = "";
        for (let Y = 0; Y < P.length; Y++) _ += `    ${P[Y].stack}
`;
        super(_);
        this.name = "AggregateError", this.errors = P;
      }
    }
    q.exports = { AggregateError: K, ArrayIsArray(P) {
      return Array.isArray(P);
    }, ArrayPrototypeIncludes(P, _) {
      return P.includes(_);
    }, ArrayPrototypeIndexOf(P, _) {
      return P.indexOf(_);
    }, ArrayPrototypeJoin(P, _) {
      return P.join(_);
    }, ArrayPrototypeMap(P, _) {
      return P.map(_);
    }, ArrayPrototypePop(P, _) {
      return P.pop(_);
    }, ArrayPrototypePush(P, _) {
      return P.push(_);
    }, ArrayPrototypeSlice(P, _, Y) {
      return P.slice(_, Y);
    }, Error, FunctionPrototypeCall(P, _, ...Y) {
      return P.call(_, ...Y);
    }, FunctionPrototypeSymbolHasInstance(P, _) {
      return Function.prototype[Symbol.hasInstance].call(P, _);
    }, MathFloor: Math.floor, Number, NumberIsInteger: Number.isInteger, NumberIsNaN: Number.isNaN, NumberMAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER, NumberMIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER, NumberParseInt: Number.parseInt, ObjectDefineProperties(P, _) {
      return Object.defineProperties(P, _);
    }, ObjectDefineProperty(P, _, Y) {
      return Object.defineProperty(P, _, Y);
    }, ObjectGetOwnPropertyDescriptor(P, _) {
      return Object.getOwnPropertyDescriptor(P, _);
    }, ObjectKeys(P) {
      return Object.keys(P);
    }, ObjectSetPrototypeOf(P, _) {
      return Object.setPrototypeOf(P, _);
    }, Promise, PromisePrototypeCatch(P, _) {
      return P.catch(_);
    }, PromisePrototypeThen(P, _, Y) {
      return P.then(_, Y);
    }, PromiseReject(P) {
      return Promise.reject(P);
    }, PromiseResolve(P) {
      return Promise.resolve(P);
    }, ReflectApply: Reflect.apply, RegExpPrototypeTest(P, _) {
      return P.test(_);
    }, SafeSet: Set, String, StringPrototypeSlice(P, _, Y) {
      return P.slice(_, Y);
    }, StringPrototypeToLowerCase(P) {
      return P.toLowerCase();
    }, StringPrototypeToUpperCase(P) {
      return P.toUpperCase();
    }, StringPrototypeTrim(P) {
      return P.trim();
    }, Symbol, SymbolFor: Symbol.for, SymbolAsyncIterator: Symbol.asyncIterator, SymbolHasInstance: Symbol.hasInstance, SymbolIterator: Symbol.iterator, SymbolDispose: Symbol.dispose || Symbol("Symbol.dispose"), SymbolAsyncDispose: Symbol.asyncDispose || Symbol("Symbol.asyncDispose"), TypedArrayPrototypeSet(P, _, Y) {
      return P.set(_, Y);
    }, Boolean, Uint8Array };
  }), oS = V6(($18, q) => {
    q.exports = { format(K, ...P) {
      return K.replace(/%([sdifj])/g, function(...[_, Y]) {
        let O = P.shift();
        if (Y === "f") return O.toFixed(6);
        else if (Y === "j") return JSON.stringify(O);
        else if (Y === "s" && typeof O === "object") return `${O.constructor !== Object ? O.constructor.name : ""} {}`.trim();
        else return O.toString();
      });
    }, inspect(K) {
      switch (typeof K) {
        case "string":
          if (K.includes("'")) {
            if (!K.includes('"')) return `"${K}"`;
            else if (!K.includes("`") && !K.includes("${")) return `\`${K}\``;
          }
          return `'${K}'`;
        case "number":
          if (isNaN(K)) return "NaN";
          else if (Object.is(K, -0)) return String(K);
          return K;
        case "bigint":
          return `${String(K)}n`;
        case "boolean":
        case "undefined":
          return String(K);
        case "object":
          return "{}";
      }
    } };
  }), cq = V6(($18, q) => {
    var { format: K, inspect: P } = oS(), { AggregateError: _ } = u6(), Y = globalThis.AggregateError || _, O = Symbol("kIsNodeError"), z = ["string", "function", "number", "object", "Function", "Object", "boolean", "bigint", "symbol"], J = /^([A-Z][a-z0-9]*)+$/, T = {};
    function X(I, D) {
      if (!I) throw new T.ERR_INTERNAL_ASSERTION(D);
    }
    function f(I) {
      let D = "", g = I.length, b = I[0] === "-" ? 1 : 0;
      for (; g >= b + 4; g -= 3) D = `_${I.slice(g - 3, g)}${D}`;
      return `${I.slice(0, g)}${D}`;
    }
    function V(I, D, g) {
      if (typeof D === "function") return X(D.length <= g.length, `Code: ${I}; The provided arguments length (${g.length}) does not match the required ones (${D.length}).`), D(...g);
      let b = (D.match(/%[dfijoOs]/g) || []).length;
      if (X(b === g.length, `Code: ${I}; The provided arguments length (${g.length}) does not match the required ones (${b}).`), g.length === 0) return D;
      return K(D, ...g);
    }
    function M(I, D, g) {
      if (!g) g = Error;
      class b extends g {
        constructor(...y) {
          super(V(I, D, y));
        }
        toString() {
          return `${this.name} [${I}]: ${this.message}`;
        }
      }
      Object.defineProperties(b.prototype, { name: { value: g.name, writable: true, enumerable: false, configurable: true }, toString: { value() {
        return `${this.name} [${I}]: ${this.message}`;
      }, writable: true, enumerable: false, configurable: true } }), b.prototype.code = I, b.prototype[O] = true, T[I] = b;
    }
    function N(I) {
      let D = "__node_internal_" + I.name;
      return Object.defineProperty(I, "name", { value: D }), I;
    }
    function h(I, D) {
      if (I && D && I !== D) {
        if (Array.isArray(D.errors)) return D.errors.push(I), D;
        let g = new Y([D, I], D.message);
        return g.code = D.code, g;
      }
      return I || D;
    }
    class E extends Error {
      constructor(I = "The operation was aborted", D = void 0) {
        if (D !== void 0 && typeof D !== "object") throw new T.ERR_INVALID_ARG_TYPE("options", "Object", D);
        super(I, D);
        this.code = "ABORT_ERR", this.name = "AbortError";
      }
    }
    M("ERR_ASSERTION", "%s", Error), M("ERR_INVALID_ARG_TYPE", (I, D, g) => {
      if (X(typeof I === "string", "'name' must be a string"), !Array.isArray(D)) D = [D];
      let b = "The ";
      if (I.endsWith(" argument")) b += `${I} `;
      else b += `"${I}" ${I.includes(".") ? "property" : "argument"} `;
      b += "must be ";
      let y = [], p = [], n = [];
      for (let q$ of D) if (X(typeof q$ === "string", "All expected entries have to be of type string"), z.includes(q$)) y.push(q$.toLowerCase());
      else if (J.test(q$)) p.push(q$);
      else X(q$ !== "object", 'The value "object" should be written as "Object"'), n.push(q$);
      if (p.length > 0) {
        let q$ = y.indexOf("object");
        if (q$ !== -1) y.splice(y, q$, 1), p.push("Object");
      }
      if (y.length > 0) {
        switch (y.length) {
          case 1:
            b += `of type ${y[0]}`;
            break;
          case 2:
            b += `one of type ${y[0]} or ${y[1]}`;
            break;
          default: {
            let q$ = y.pop();
            b += `one of type ${y.join(", ")}, or ${q$}`;
          }
        }
        if (p.length > 0 || n.length > 0) b += " or ";
      }
      if (p.length > 0) {
        switch (p.length) {
          case 1:
            b += `an instance of ${p[0]}`;
            break;
          case 2:
            b += `an instance of ${p[0]} or ${p[1]}`;
            break;
          default: {
            let q$ = p.pop();
            b += `an instance of ${p.join(", ")}, or ${q$}`;
          }
        }
        if (n.length > 0) b += " or ";
      }
      switch (n.length) {
        case 0:
          break;
        case 1:
          if (n[0].toLowerCase() !== n[0]) b += "an ";
          b += `${n[0]}`;
          break;
        case 2:
          b += `one of ${n[0]} or ${n[1]}`;
          break;
        default: {
          let q$ = n.pop();
          b += `one of ${n.join(", ")}, or ${q$}`;
        }
      }
      if (g == null) b += `. Received ${g}`;
      else if (typeof g === "function" && g.name) b += `. Received function ${g.name}`;
      else if (typeof g === "object") {
        var s;
        if ((s = g.constructor) !== null && s !== void 0 && s.name) b += `. Received an instance of ${g.constructor.name}`;
        else {
          let q$ = P(g, { depth: -1 });
          b += `. Received ${q$}`;
        }
      } else {
        let q$ = P(g, { colors: false });
        if (q$.length > 25) q$ = `${q$.slice(0, 25)}...`;
        b += `. Received type ${typeof g} (${q$})`;
      }
      return b;
    }, TypeError), M("ERR_INVALID_ARG_VALUE", (I, D, g = "is invalid") => {
      let b = P(D);
      if (b.length > 128) b = b.slice(0, 128) + "...";
      return `The ${I.includes(".") ? "property" : "argument"} '${I}' ${g}. Received ${b}`;
    }, TypeError), M("ERR_INVALID_RETURN_VALUE", (I, D, g) => {
      var b;
      let y = g !== null && g !== void 0 && (b = g.constructor) !== null && b !== void 0 && b.name ? `instance of ${g.constructor.name}` : `type ${typeof g}`;
      return `Expected ${I} to be returned from the "${D}" function but got ${y}.`;
    }, TypeError), M("ERR_MISSING_ARGS", (...I) => {
      X(I.length > 0, "At least one arg needs to be specified");
      let D, g = I.length;
      switch (I = (Array.isArray(I) ? I : [I]).map((b) => `"${b}"`).join(" or "), g) {
        case 1:
          D += `The ${I[0]} argument`;
          break;
        case 2:
          D += `The ${I[0]} and ${I[1]} arguments`;
          break;
        default:
          {
            let b = I.pop();
            D += `The ${I.join(", ")}, and ${b} arguments`;
          }
          break;
      }
      return `${D} must be specified`;
    }, TypeError), M("ERR_OUT_OF_RANGE", (I, D, g) => {
      X(D, 'Missing "range" argument');
      let b;
      if (Number.isInteger(g) && Math.abs(g) > 4294967296) b = f(String(g));
      else if (typeof g === "bigint") {
        b = String(g);
        let y = BigInt(2) ** BigInt(32);
        if (g > y || g < -y) b = f(b);
        b += "n";
      } else b = P(g);
      return `The value of "${I}" is out of range. It must be ${D}. Received ${b}`;
    }, RangeError), M("ERR_MULTIPLE_CALLBACK", "Callback called multiple times", Error), M("ERR_METHOD_NOT_IMPLEMENTED", "The %s method is not implemented", Error), M("ERR_STREAM_ALREADY_FINISHED", "Cannot call %s after a stream was finished", Error), M("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable", Error), M("ERR_STREAM_DESTROYED", "Cannot call %s after a stream was destroyed", Error), M("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError), M("ERR_STREAM_PREMATURE_CLOSE", "Premature close", Error), M("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF", Error), M("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event", Error), M("ERR_STREAM_WRITE_AFTER_END", "write after end", Error), M("ERR_UNKNOWN_ENCODING", "Unknown encoding: %s", TypeError), q.exports = { AbortError: E, aggregateTwoErrors: N(h), hideStackFrames: N, codes: T };
  }), Mr = V6(($18, q) => {
    Object.defineProperty($18, "__esModule", { value: true });
    var K = /* @__PURE__ */ new WeakMap(), P = /* @__PURE__ */ new WeakMap();
    function _(c) {
      let U = K.get(c);
      return console.assert(U != null, "'this' is expected an Event object, but got", c), U;
    }
    function Y(c) {
      if (c.passiveListener != null) {
        if (typeof console < "u" && typeof console.error === "function") console.error("Unable to preventDefault inside passive event listener invocation.", c.passiveListener);
        return;
      }
      if (!c.event.cancelable) return;
      if (c.canceled = true, typeof c.event.preventDefault === "function") c.event.preventDefault();
    }
    function O(c, U) {
      K.set(this, { eventTarget: c, event: U, eventPhase: 2, currentTarget: c, canceled: false, stopped: false, immediateStopped: false, passiveListener: null, timeStamp: U.timeStamp || Date.now() }), Object.defineProperty(this, "isTrusted", { value: false, enumerable: true });
      let j = Object.keys(U);
      for (let H = 0; H < j.length; ++H) {
        let Z = j[H];
        if (!(Z in this)) Object.defineProperty(this, Z, z(Z));
      }
    }
    if (O.prototype = { get type() {
      return _(this).event.type;
    }, get target() {
      return _(this).eventTarget;
    }, get currentTarget() {
      return _(this).currentTarget;
    }, composedPath() {
      let c = _(this).currentTarget;
      if (c == null) return [];
      return [c];
    }, get NONE() {
      return 0;
    }, get CAPTURING_PHASE() {
      return 1;
    }, get AT_TARGET() {
      return 2;
    }, get BUBBLING_PHASE() {
      return 3;
    }, get eventPhase() {
      return _(this).eventPhase;
    }, stopPropagation() {
      let c = _(this);
      if (c.stopped = true, typeof c.event.stopPropagation === "function") c.event.stopPropagation();
    }, stopImmediatePropagation() {
      let c = _(this);
      if (c.stopped = true, c.immediateStopped = true, typeof c.event.stopImmediatePropagation === "function") c.event.stopImmediatePropagation();
    }, get bubbles() {
      return Boolean(_(this).event.bubbles);
    }, get cancelable() {
      return Boolean(_(this).event.cancelable);
    }, preventDefault() {
      Y(_(this));
    }, get defaultPrevented() {
      return _(this).canceled;
    }, get composed() {
      return Boolean(_(this).event.composed);
    }, get timeStamp() {
      return _(this).timeStamp;
    }, get srcElement() {
      return _(this).eventTarget;
    }, get cancelBubble() {
      return _(this).stopped;
    }, set cancelBubble(c) {
      if (!c) return;
      let U = _(this);
      if (U.stopped = true, typeof U.event.cancelBubble === "boolean") U.event.cancelBubble = true;
    }, get returnValue() {
      return !_(this).canceled;
    }, set returnValue(c) {
      if (!c) Y(_(this));
    }, initEvent() {
    } }, Object.defineProperty(O.prototype, "constructor", { value: O, configurable: true, writable: true }), typeof window < "u" && typeof window.Event < "u") Object.setPrototypeOf(O.prototype, window.Event.prototype), P.set(window.Event.prototype, O);
    function z(c) {
      return { get() {
        return _(this).event[c];
      }, set(U) {
        _(this).event[c] = U;
      }, configurable: true, enumerable: true };
    }
    function J(c) {
      return { value() {
        let U = _(this).event;
        return U[c].apply(U, arguments);
      }, configurable: true, enumerable: true };
    }
    function T(c, U) {
      let j = Object.keys(U);
      if (j.length === 0) return c;
      function H(Z, W) {
        c.call(this, Z, W);
      }
      H.prototype = Object.create(c.prototype, { constructor: { value: H, configurable: true, writable: true } });
      for (let Z = 0; Z < j.length; ++Z) {
        let W = j[Z];
        if (!(W in c.prototype)) {
          let w = typeof Object.getOwnPropertyDescriptor(U, W).value === "function";
          Object.defineProperty(H.prototype, W, w ? J(W) : z(W));
        }
      }
      return H;
    }
    function X(c) {
      if (c == null || c === Object.prototype) return O;
      let U = P.get(c);
      if (U == null) U = T(X(Object.getPrototypeOf(c)), c), P.set(c, U);
      return U;
    }
    function f(c, U) {
      return new (X(Object.getPrototypeOf(U)))(c, U);
    }
    function V(c) {
      return _(c).immediateStopped;
    }
    function M(c, U) {
      _(c).eventPhase = U;
    }
    function N(c, U) {
      _(c).currentTarget = U;
    }
    function h(c, U) {
      _(c).passiveListener = U;
    }
    var E = /* @__PURE__ */ new WeakMap(), I = 1, D = 2, g = 3;
    function b(c) {
      return c !== null && typeof c === "object";
    }
    function y(c) {
      let U = E.get(c);
      if (U == null) throw TypeError("'this' is expected an EventTarget object, but got another value.");
      return U;
    }
    function p(c) {
      return { get() {
        let U = y(this).get(c);
        while (U != null) {
          if (U.listenerType === g) return U.listener;
          U = U.next;
        }
        return null;
      }, set(U) {
        if (typeof U !== "function" && !b(U)) U = null;
        let j = y(this), H = null, Z = j.get(c);
        while (Z != null) {
          if (Z.listenerType === g) if (H !== null) H.next = Z.next;
          else if (Z.next !== null) j.set(c, Z.next);
          else j.delete(c);
          else H = Z;
          Z = Z.next;
        }
        if (U !== null) {
          let W = { listener: U, listenerType: g, passive: false, once: false, next: null };
          if (H === null) j.set(c, W);
          else H.next = W;
        }
      }, configurable: true, enumerable: true };
    }
    function n(c, U) {
      Object.defineProperty(c, `on${U}`, p(U));
    }
    function s(c) {
      function U() {
        q$.call(this);
      }
      U.prototype = Object.create(q$.prototype, { constructor: { value: U, configurable: true, writable: true } });
      for (let j = 0; j < c.length; ++j) n(U.prototype, c[j]);
      return U;
    }
    function q$() {
      if (this instanceof q$) {
        E.set(this, /* @__PURE__ */ new Map());
        return;
      }
      if (arguments.length === 1 && Array.isArray(arguments[0])) return s(arguments[0]);
      if (arguments.length > 0) {
        let c = Array(arguments.length);
        for (let U = 0; U < arguments.length; ++U) c[U] = arguments[U];
        return s(c);
      }
      throw TypeError("Cannot call a class as a function");
    }
    if (q$.prototype = { addEventListener(c, U, j) {
      if (U == null) return;
      if (typeof U !== "function" && !b(U)) throw TypeError("'listener' should be a function or an object.");
      let H = y(this), Z = b(j), W = (Z ? Boolean(j.capture) : Boolean(j)) ? I : D, w = { listener: U, listenerType: W, passive: Z && Boolean(j.passive), once: Z && Boolean(j.once), next: null }, G = H.get(c);
      if (G === void 0) {
        H.set(c, w);
        return;
      }
      let S = null;
      while (G != null) {
        if (G.listener === U && G.listenerType === W) return;
        S = G, G = G.next;
      }
      S.next = w;
    }, removeEventListener(c, U, j) {
      if (U == null) return;
      let H = y(this), Z = (b(j) ? Boolean(j.capture) : Boolean(j)) ? I : D, W = null, w = H.get(c);
      while (w != null) {
        if (w.listener === U && w.listenerType === Z) {
          if (W !== null) W.next = w.next;
          else if (w.next !== null) H.set(c, w.next);
          else H.delete(c);
          return;
        }
        W = w, w = w.next;
      }
    }, dispatchEvent(c) {
      if (c == null || typeof c.type !== "string") throw TypeError('"event.type" should be a string.');
      let U = y(this), j = c.type, H = U.get(j);
      if (H == null) return true;
      let Z = f(this, c), W = null;
      while (H != null) {
        if (H.once) if (W !== null) W.next = H.next;
        else if (H.next !== null) U.set(j, H.next);
        else U.delete(j);
        else W = H;
        if (h(Z, H.passive ? H.listener : null), typeof H.listener === "function") try {
          H.listener.call(this, Z);
        } catch (w) {
          if (typeof console < "u" && typeof console.error === "function") console.error(w);
        }
        else if (H.listenerType !== g && typeof H.listener.handleEvent === "function") H.listener.handleEvent(Z);
        if (V(Z)) break;
        H = H.next;
      }
      return h(Z, null), M(Z, 0), N(Z, null), !Z.defaultPrevented;
    } }, Object.defineProperty(q$.prototype, "constructor", { value: q$, configurable: true, writable: true }), typeof window < "u" && typeof window.EventTarget < "u") Object.setPrototypeOf(q$.prototype, window.EventTarget.prototype);
    $18.defineEventAttribute = n, $18.EventTarget = q$, $18.default = q$, q.exports = q$, q.exports.EventTarget = q.exports.default = q$, q.exports.defineEventAttribute = n;
  }), n7 = V6(($18, q) => {
    Object.defineProperty($18, "__esModule", { value: true });
    var K = Mr();
    class P extends K.EventTarget {
      constructor() {
        super();
        throw TypeError("AbortSignal cannot be constructed directly");
      }
      get aborted() {
        let X = O.get(this);
        if (typeof X !== "boolean") throw TypeError(`Expected 'this' to be an 'AbortSignal' object, but got ${this === null ? "null" : typeof this}`);
        return X;
      }
    }
    K.defineEventAttribute(P.prototype, "abort");
    function _() {
      let X = Object.create(P.prototype);
      return K.EventTarget.call(X), O.set(X, false), X;
    }
    function Y(X) {
      if (O.get(X) !== false) return;
      O.set(X, true), X.dispatchEvent({ type: "abort" });
    }
    var O = /* @__PURE__ */ new WeakMap();
    if (Object.defineProperties(P.prototype, { aborted: { enumerable: true } }), typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol") Object.defineProperty(P.prototype, Symbol.toStringTag, { configurable: true, value: "AbortSignal" });
    class z {
      constructor() {
        J.set(this, _());
      }
      get signal() {
        return T(this);
      }
      abort() {
        Y(T(this));
      }
    }
    var J = /* @__PURE__ */ new WeakMap();
    function T(X) {
      let f = J.get(X);
      if (f == null) throw TypeError(`Expected 'this' to be an 'AbortController' object, but got ${X === null ? "null" : typeof X}`);
      return f;
    }
    if (Object.defineProperties(z.prototype, { signal: { enumerable: true }, abort: { enumerable: true } }), typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol") Object.defineProperty(z.prototype, Symbol.toStringTag, { configurable: true, value: "AbortController" });
    $18.AbortController = z, $18.AbortSignal = P, $18.default = z, q.exports = z, q.exports.AbortController = q.exports.default = z, q.exports.AbortSignal = P;
  }), sq = V6(($18, q) => {
    var K = (wq(), J6(Tq)), { format: P, inspect: _ } = oS(), { codes: { ERR_INVALID_ARG_TYPE: Y } } = cq(), { kResistStopPropagation: O, AggregateError: z, SymbolDispose: J } = u6(), T = globalThis.AbortSignal || n7().AbortSignal, X = globalThis.AbortController || n7().AbortController, f = Object.getPrototypeOf(async function() {
    }).constructor, V = globalThis.Blob || K.Blob, M = typeof V < "u" ? function(E) {
      return E instanceof V;
    } : function(E) {
      return false;
    }, N = (E, I) => {
      if (E !== void 0 && (E === null || typeof E !== "object" || !("aborted" in E))) throw new Y(I, "AbortSignal", E);
    }, h = (E, I) => {
      if (typeof E !== "function") throw new Y(I, "Function", E);
    };
    q.exports = { AggregateError: z, kEmptyObject: Object.freeze({}), once(E) {
      let I = false;
      return function(...D) {
        if (I) return;
        I = true, E.apply(this, D);
      };
    }, createDeferredPromise: function() {
      let E, I;
      return { promise: new Promise((D, g) => {
        E = D, I = g;
      }), resolve: E, reject: I };
    }, promisify(E) {
      return new Promise((I, D) => {
        E((g, ...b) => {
          if (g) return D(g);
          return I(...b);
        });
      });
    }, debuglog() {
      return function() {
      };
    }, format: P, inspect: _, types: { isAsyncFunction(E) {
      return E instanceof f;
    }, isArrayBufferView(E) {
      return ArrayBuffer.isView(E);
    } }, isBlob: M, deprecate(E, I) {
      return E;
    }, addAbortListener: (o7(), J6(r7)).addAbortListener || function(E, I) {
      if (E === void 0) throw new Y("signal", "AbortSignal", E);
      N(E, "signal"), h(I, "listener");
      let D;
      if (E.aborted) queueMicrotask(() => I());
      else E.addEventListener("abort", I, { __proto__: null, once: true, [O]: true }), D = () => {
        E.removeEventListener("abort", I);
      };
      return { __proto__: null, [J]() {
        var g;
        (g = D) === null || g === void 0 || g();
      } };
    }, AbortSignalAny: T.any || function(E) {
      if (E.length === 1) return E[0];
      let I = new X(), D = () => I.abort();
      return E.forEach((g) => {
        N(g, "signals"), g.addEventListener("abort", D, { once: true });
      }), I.signal.addEventListener("abort", () => {
        E.forEach((g) => g.removeEventListener("abort", D));
      }, { once: true }), I.signal;
    } }, q.exports.promisify.custom = Symbol.for("nodejs.util.promisify.custom");
  }), i7 = V6(($18, q) => {
    var { ArrayIsArray: K, ArrayPrototypeIncludes: P, ArrayPrototypeJoin: _, ArrayPrototypeMap: Y, NumberIsInteger: O, NumberIsNaN: z, NumberMAX_SAFE_INTEGER: J, NumberMIN_SAFE_INTEGER: T, NumberParseInt: X, ObjectPrototypeHasOwnProperty: f, RegExpPrototypeExec: V, String: M, StringPrototypeToUpperCase: N, StringPrototypeTrim: h } = u6(), { hideStackFrames: E, codes: { ERR_SOCKET_BAD_PORT: I, ERR_INVALID_ARG_TYPE: D, ERR_INVALID_ARG_VALUE: g, ERR_OUT_OF_RANGE: b, ERR_UNKNOWN_SIGNAL: y } } = cq(), { normalizeEncoding: p } = sq(), { isAsyncFunction: n, isArrayBufferView: s } = sq().types, q$ = {};
    function c(d) {
      return d === (d | 0);
    }
    function U(d) {
      return d === d >>> 0;
    }
    var j = /^[0-7]+$/, H = "must be a 32-bit unsigned integer or an octal string";
    function Z(d, o, W$) {
      if (typeof d > "u") d = W$;
      if (typeof d === "string") {
        if (V(j, d) === null) throw new g(o, d, H);
        d = X(d, 8);
      }
      return G(d, o), d;
    }
    var W = E((d, o, W$ = T, t = J) => {
      if (typeof d !== "number") throw new D(o, "number", d);
      if (!O(d)) throw new b(o, "an integer", d);
      if (d < W$ || d > t) throw new b(o, `>= ${W$} && <= ${t}`, d);
    }), w = E((d, o, W$ = -2147483648, t = 2147483647) => {
      if (typeof d !== "number") throw new D(o, "number", d);
      if (!O(d)) throw new b(o, "an integer", d);
      if (d < W$ || d > t) throw new b(o, `>= ${W$} && <= ${t}`, d);
    }), G = E((d, o, W$ = false) => {
      if (typeof d !== "number") throw new D(o, "number", d);
      if (!O(d)) throw new b(o, "an integer", d);
      let t = W$ ? 1 : 0, F = 4294967295;
      if (d < t || d > F) throw new b(o, `>= ${t} && <= ${F}`, d);
    });
    function S(d, o) {
      if (typeof d !== "string") throw new D(o, "string", d);
    }
    function A(d, o, W$ = void 0, t) {
      if (typeof d !== "number") throw new D(o, "number", d);
      if (W$ != null && d < W$ || t != null && d > t || (W$ != null || t != null) && z(d)) throw new b(o, `${W$ != null ? `>= ${W$}` : ""}${W$ != null && t != null ? " && " : ""}${t != null ? `<= ${t}` : ""}`, d);
    }
    var v = E((d, o, W$) => {
      if (!P(W$, d)) {
        let t = "must be one of: " + _(Y(W$, (F) => typeof F === "string" ? `'${F}'` : M(F)), ", ");
        throw new g(o, d, t);
      }
    });
    function k(d, o) {
      if (typeof d !== "boolean") throw new D(o, "boolean", d);
    }
    function R(d, o, W$) {
      return d == null || !f(d, o) ? W$ : d[o];
    }
    var C = E((d, o, W$ = null) => {
      let t = R(W$, "allowArray", false), F = R(W$, "allowFunction", false);
      if (!R(W$, "nullable", false) && d === null || !t && K(d) || typeof d !== "object" && (!F || typeof d !== "function")) throw new D(o, "Object", d);
    }), L = E((d, o) => {
      if (d != null && typeof d !== "object" && typeof d !== "function") throw new D(o, "a dictionary", d);
    }), x = E((d, o, W$ = 0) => {
      if (!K(d)) throw new D(o, "Array", d);
      if (d.length < W$) {
        let t = `must be longer than ${W$}`;
        throw new g(o, d, t);
      }
    });
    function l(d, o) {
      x(d, o);
      for (let W$ = 0; W$ < d.length; W$++) S(d[W$], `${o}[${W$}]`);
    }
    function a(d, o) {
      x(d, o);
      for (let W$ = 0; W$ < d.length; W$++) k(d[W$], `${o}[${W$}]`);
    }
    function f$(d, o) {
      x(d, o);
      for (let W$ = 0; W$ < d.length; W$++) {
        let t = d[W$], F = `${o}[${W$}]`;
        if (t == null) throw new D(F, "AbortSignal", t);
        v$(t, F);
      }
    }
    function $$(d, o = "signal") {
      if (S(d, o), q$[d] === void 0) {
        if (q$[N(d)] !== void 0) throw new y(d + " (signals must use all capital letters)");
        throw new y(d);
      }
    }
    var B = E((d, o = "buffer") => {
      if (!s(d)) throw new D(o, ["Buffer", "TypedArray", "DataView"], d);
    });
    function H$(d, o) {
      let W$ = p(o), t = d.length;
      if (W$ === "hex" && t % 2 !== 0) throw new g("encoding", o, `is invalid for data of length ${t}`);
    }
    function Q(d, o = "Port", W$ = true) {
      if (typeof d !== "number" && typeof d !== "string" || typeof d === "string" && h(d).length === 0 || +d !== +d >>> 0 || d > 65535 || d === 0 && !W$) throw new I(o, d, W$);
      return d | 0;
    }
    var v$ = E((d, o) => {
      if (d !== void 0 && (d === null || typeof d !== "object" || !("aborted" in d))) throw new D(o, "AbortSignal", d);
    }), t$ = E((d, o) => {
      if (typeof d !== "function") throw new D(o, "Function", d);
    }), m = E((d, o) => {
      if (typeof d !== "function" || n(d)) throw new D(o, "Function", d);
    }), r = E((d, o) => {
      if (d !== void 0) throw new D(o, "undefined", d);
    });
    function J$(d, o, W$) {
      if (!P(W$, d)) throw new D(o, `('${_(W$, "|")}')`, d);
    }
    var e = /^(?:<[^>]*>)(?:\s*;\s*[^;"\s]+(?:=(")?[^;"\s]*\1)?)*$/;
    function _$2(d, o) {
      if (typeof d > "u" || !V(e, d)) throw new g(o, d, 'must be an array or string of format "</styles.css>; rel=preload; as=style"');
    }
    function Y$(d) {
      if (typeof d === "string") return _$2(d, "hints"), d;
      else if (K(d)) {
        let o = d.length, W$ = "";
        if (o === 0) return W$;
        for (let t = 0; t < o; t++) {
          let F = d[t];
          if (_$2(F, "hints"), W$ += F, t !== o - 1) W$ += ", ";
        }
        return W$;
      }
      throw new g("hints", d, 'must be an array or string of format "</styles.css>; rel=preload; as=style"');
    }
    q.exports = { isInt32: c, isUint32: U, parseFileMode: Z, validateArray: x, validateStringArray: l, validateBooleanArray: a, validateAbortSignalArray: f$, validateBoolean: k, validateBuffer: B, validateDictionary: L, validateEncoding: H$, validateFunction: t$, validateInt32: w, validateInteger: W, validateNumber: A, validateObject: C, validateOneOf: v, validatePlainFunction: m, validatePort: Q, validateSignalName: $$, validateString: S, validateUint32: G, validateUndefined: r, validateUnion: J$, validateAbortSignal: v$, validateLinkHeaderValue: Y$ };
  }), y_ = V6(($18, q) => {
    q.exports = globalThis.process;
  }), SK = V6(($18, q) => {
    var { SymbolAsyncIterator: K, SymbolIterator: P, SymbolFor: _ } = u6(), Y = _("nodejs.stream.destroyed"), O = _("nodejs.stream.errored"), z = _("nodejs.stream.readable"), J = _("nodejs.stream.writable"), T = _("nodejs.stream.disturbed"), X = _("nodejs.webstream.isClosedPromise"), f = _("nodejs.webstream.controllerErrorFunction");
    function V(R, C = false) {
      var L;
      return !!(R && typeof R.pipe === "function" && typeof R.on === "function" && (!C || typeof R.pause === "function" && typeof R.resume === "function") && (!R._writableState || ((L = R._readableState) === null || L === void 0 ? void 0 : L.readable) !== false) && (!R._writableState || R._readableState));
    }
    function M(R) {
      var C;
      return !!(R && typeof R.write === "function" && typeof R.on === "function" && (!R._readableState || ((C = R._writableState) === null || C === void 0 ? void 0 : C.writable) !== false));
    }
    function N(R) {
      return !!(R && typeof R.pipe === "function" && R._readableState && typeof R.on === "function" && typeof R.write === "function");
    }
    function h(R) {
      return R && (R._readableState || R._writableState || typeof R.write === "function" && typeof R.on === "function" || typeof R.pipe === "function" && typeof R.on === "function");
    }
    function E(R) {
      return !!(R && !h(R) && typeof R.pipeThrough === "function" && typeof R.getReader === "function" && typeof R.cancel === "function");
    }
    function I(R) {
      return !!(R && !h(R) && typeof R.getWriter === "function" && typeof R.abort === "function");
    }
    function D(R) {
      return !!(R && !h(R) && typeof R.readable === "object" && typeof R.writable === "object");
    }
    function g(R) {
      return E(R) || I(R) || D(R);
    }
    function b(R, C) {
      if (R == null) return false;
      if (C === true) return typeof R[K] === "function";
      if (C === false) return typeof R[P] === "function";
      return typeof R[K] === "function" || typeof R[P] === "function";
    }
    function y(R) {
      if (!h(R)) return null;
      let { _writableState: C, _readableState: L } = R, x = C || L;
      return !!(R.destroyed || R[Y] || x !== null && x !== void 0 && x.destroyed);
    }
    function p(R) {
      if (!M(R)) return null;
      if (R.writableEnded === true) return true;
      let C = R._writableState;
      if (C !== null && C !== void 0 && C.errored) return false;
      if (typeof (C === null || C === void 0 ? void 0 : C.ended) !== "boolean") return null;
      return C.ended;
    }
    function n(R, C) {
      if (!M(R)) return null;
      if (R.writableFinished === true) return true;
      let L = R._writableState;
      if (L !== null && L !== void 0 && L.errored) return false;
      if (typeof (L === null || L === void 0 ? void 0 : L.finished) !== "boolean") return null;
      return !!(L.finished || C === false && L.ended === true && L.length === 0);
    }
    function s(R) {
      if (!V(R)) return null;
      if (R.readableEnded === true) return true;
      let C = R._readableState;
      if (!C || C.errored) return false;
      if (typeof (C === null || C === void 0 ? void 0 : C.ended) !== "boolean") return null;
      return C.ended;
    }
    function q$(R, C) {
      if (!V(R)) return null;
      let L = R._readableState;
      if (L !== null && L !== void 0 && L.errored) return false;
      if (typeof (L === null || L === void 0 ? void 0 : L.endEmitted) !== "boolean") return null;
      return !!(L.endEmitted || C === false && L.ended === true && L.length === 0);
    }
    function c(R) {
      if (R && R[z] != null) return R[z];
      if (typeof (R === null || R === void 0 ? void 0 : R.readable) !== "boolean") return null;
      if (y(R)) return false;
      return V(R) && R.readable && !q$(R);
    }
    function U(R) {
      if (R && R[J] != null) return R[J];
      if (typeof (R === null || R === void 0 ? void 0 : R.writable) !== "boolean") return null;
      if (y(R)) return false;
      return M(R) && R.writable && !p(R);
    }
    function j(R, C) {
      if (!h(R)) return null;
      if (y(R)) return true;
      if ((C === null || C === void 0 ? void 0 : C.readable) !== false && c(R)) return false;
      if ((C === null || C === void 0 ? void 0 : C.writable) !== false && U(R)) return false;
      return true;
    }
    function H(R) {
      var C, L;
      if (!h(R)) return null;
      if (R.writableErrored) return R.writableErrored;
      return (C = (L = R._writableState) === null || L === void 0 ? void 0 : L.errored) !== null && C !== void 0 ? C : null;
    }
    function Z(R) {
      var C, L;
      if (!h(R)) return null;
      if (R.readableErrored) return R.readableErrored;
      return (C = (L = R._readableState) === null || L === void 0 ? void 0 : L.errored) !== null && C !== void 0 ? C : null;
    }
    function W(R) {
      if (!h(R)) return null;
      if (typeof R.closed === "boolean") return R.closed;
      let { _writableState: C, _readableState: L } = R;
      if (typeof (C === null || C === void 0 ? void 0 : C.closed) === "boolean" || typeof (L === null || L === void 0 ? void 0 : L.closed) === "boolean") return (C === null || C === void 0 ? void 0 : C.closed) || (L === null || L === void 0 ? void 0 : L.closed);
      if (typeof R._closed === "boolean" && w(R)) return R._closed;
      return null;
    }
    function w(R) {
      return typeof R._closed === "boolean" && typeof R._defaultKeepAlive === "boolean" && typeof R._removedConnection === "boolean" && typeof R._removedContLen === "boolean";
    }
    function G(R) {
      return typeof R._sent100 === "boolean" && w(R);
    }
    function S(R) {
      var C;
      return typeof R._consuming === "boolean" && typeof R._dumped === "boolean" && ((C = R.req) === null || C === void 0 ? void 0 : C.upgradeOrConnect) === void 0;
    }
    function A(R) {
      if (!h(R)) return null;
      let { _writableState: C, _readableState: L } = R, x = C || L;
      return !x && G(R) || !!(x && x.autoDestroy && x.emitClose && x.closed === false);
    }
    function v(R) {
      var C;
      return !!(R && ((C = R[T]) !== null && C !== void 0 ? C : R.readableDidRead || R.readableAborted));
    }
    function k(R) {
      var C, L, x, l, a, f$, $$, B, H$, Q;
      return !!(R && ((C = (L = (x = (l = (a = (f$ = R[O]) !== null && f$ !== void 0 ? f$ : R.readableErrored) !== null && a !== void 0 ? a : R.writableErrored) !== null && l !== void 0 ? l : ($$ = R._readableState) === null || $$ === void 0 ? void 0 : $$.errorEmitted) !== null && x !== void 0 ? x : (B = R._writableState) === null || B === void 0 ? void 0 : B.errorEmitted) !== null && L !== void 0 ? L : (H$ = R._readableState) === null || H$ === void 0 ? void 0 : H$.errored) !== null && C !== void 0 ? C : (Q = R._writableState) === null || Q === void 0 ? void 0 : Q.errored));
    }
    q.exports = { isDestroyed: y, kIsDestroyed: Y, isDisturbed: v, kIsDisturbed: T, isErrored: k, kIsErrored: O, isReadable: c, kIsReadable: z, kIsClosedPromise: X, kControllerErrorFunction: f, kIsWritable: J, isClosed: W, isDuplexNodeStream: N, isFinished: j, isIterable: b, isReadableNodeStream: V, isReadableStream: E, isReadableEnded: s, isReadableFinished: q$, isReadableErrored: Z, isNodeStream: h, isWebStream: g, isWritable: U, isWritableNodeStream: M, isWritableStream: I, isWritableEnded: p, isWritableFinished: n, isWritableErrored: H, isServerRequest: S, isServerResponse: G, willEmitClose: A, isTransformStream: D };
  }), sK = V6(($18, q) => {
    var K = y_(), { AbortError: P, codes: _ } = cq(), { ERR_INVALID_ARG_TYPE: Y, ERR_STREAM_PREMATURE_CLOSE: O } = _, { kEmptyObject: z, once: J } = sq(), { validateAbortSignal: T, validateFunction: X, validateObject: f, validateBoolean: V } = i7(), { Promise: M, PromisePrototypeThen: N, SymbolDispose: h } = u6(), { isClosed: E, isReadable: I, isReadableNodeStream: D, isReadableStream: g, isReadableFinished: b, isReadableErrored: y, isWritable: p, isWritableNodeStream: n, isWritableStream: s, isWritableFinished: q$, isWritableErrored: c, isNodeStream: U, willEmitClose: j, kIsClosedPromise: H } = SK(), Z;
    function W(v) {
      return v.setHeader && typeof v.abort === "function";
    }
    var w = () => {
    };
    function G(v, k, R) {
      var C, L;
      if (arguments.length === 2) R = k, k = z;
      else if (k == null) k = z;
      else f(k, "options");
      if (X(R, "callback"), T(k.signal, "options.signal"), R = J(R), g(v) || s(v)) return S(v, k, R);
      if (!U(v)) throw new Y("stream", ["ReadableStream", "WritableStream", "Stream"], v);
      let x = (C = k.readable) !== null && C !== void 0 ? C : D(v), l = (L = k.writable) !== null && L !== void 0 ? L : n(v), a = v._writableState, f$ = v._readableState, $$ = () => {
        if (!v.writable) Q();
      }, B = j(v) && D(v) === x && n(v) === l, H$ = q$(v, false), Q = () => {
        if (H$ = true, v.destroyed) B = false;
        if (B && (!v.readable || x)) return;
        if (!x || v$) R.call(v);
      }, v$ = b(v, false), t$ = () => {
        if (v$ = true, v.destroyed) B = false;
        if (B && (!v.writable || l)) return;
        if (!l || H$) R.call(v);
      }, m = (d) => {
        R.call(v, d);
      }, r = E(v), J$ = () => {
        r = true;
        let d = c(v) || y(v);
        if (d && typeof d !== "boolean") return R.call(v, d);
        if (x && !v$ && D(v, true)) {
          if (!b(v, false)) return R.call(v, new O());
        }
        if (l && !H$) {
          if (!q$(v, false)) return R.call(v, new O());
        }
        R.call(v);
      }, e = () => {
        r = true;
        let d = c(v) || y(v);
        if (d && typeof d !== "boolean") return R.call(v, d);
        R.call(v);
      }, _$2 = () => {
        v.req.on("finish", Q);
      };
      if (W(v)) {
        if (v.on("complete", Q), !B) v.on("abort", J$);
        if (v.req) _$2();
        else v.on("request", _$2);
      } else if (l && !a) v.on("end", $$), v.on("close", $$);
      if (!B && typeof v.aborted === "boolean") v.on("aborted", J$);
      if (v.on("end", t$), v.on("finish", Q), k.error !== false) v.on("error", m);
      if (v.on("close", J$), r) K.nextTick(J$);
      else if (a !== null && a !== void 0 && a.errorEmitted || f$ !== null && f$ !== void 0 && f$.errorEmitted) {
        if (!B) K.nextTick(e);
      } else if (!x && (!B || I(v)) && (H$ || p(v) === false)) K.nextTick(e);
      else if (!l && (!B || p(v)) && (v$ || I(v) === false)) K.nextTick(e);
      else if (f$ && v.req && v.aborted) K.nextTick(e);
      let Y$ = () => {
        if (R = w, v.removeListener("aborted", J$), v.removeListener("complete", Q), v.removeListener("abort", J$), v.removeListener("request", _$2), v.req) v.req.removeListener("finish", Q);
        v.removeListener("end", $$), v.removeListener("close", $$), v.removeListener("finish", Q), v.removeListener("end", t$), v.removeListener("error", m), v.removeListener("close", J$);
      };
      if (k.signal && !r) {
        let d = () => {
          let o = R;
          Y$(), o.call(v, new P(void 0, { cause: k.signal.reason }));
        };
        if (k.signal.aborted) K.nextTick(d);
        else {
          Z = Z || sq().addAbortListener;
          let o = Z(k.signal, d), W$ = R;
          R = J((...t) => {
            o[h](), W$.apply(v, t);
          });
        }
      }
      return Y$;
    }
    function S(v, k, R) {
      let C = false, L = w;
      if (k.signal) if (L = () => {
        C = true, R.call(v, new P(void 0, { cause: k.signal.reason }));
      }, k.signal.aborted) K.nextTick(L);
      else {
        Z = Z || sq().addAbortListener;
        let l = Z(k.signal, L), a = R;
        R = J((...f$) => {
          l[h](), a.apply(v, f$);
        });
      }
      let x = (...l) => {
        if (!C) K.nextTick(() => R.apply(v, l));
      };
      return N(v[H].promise, x, x), w;
    }
    function A(v, k) {
      var R;
      let C = false;
      if (k === null) k = z;
      if ((R = k) !== null && R !== void 0 && R.cleanup) V(k.cleanup, "cleanup"), C = k.cleanup;
      return new M((L, x) => {
        let l = G(v, k, (a) => {
          if (C) l();
          if (a) x(a);
          else L();
        });
      });
    }
    q.exports = G, q.exports.finished = A;
  }), c4 = V6(($18, q) => {
    var K = y_(), { aggregateTwoErrors: P, codes: { ERR_MULTIPLE_CALLBACK: _ }, AbortError: Y } = cq(), { Symbol: O } = u6(), { kIsDestroyed: z, isDestroyed: J, isFinished: T, isServerRequest: X } = SK(), f = O("kDestroy"), V = O("kConstruct");
    function M(j, H, Z) {
      if (j) {
        if (j.stack, H && !H.errored) H.errored = j;
        if (Z && !Z.errored) Z.errored = j;
      }
    }
    function N(j, H) {
      let Z = this._readableState, W = this._writableState, w = W || Z;
      if (W !== null && W !== void 0 && W.destroyed || Z !== null && Z !== void 0 && Z.destroyed) {
        if (typeof H === "function") H();
        return this;
      }
      if (M(j, W, Z), W) W.destroyed = true;
      if (Z) Z.destroyed = true;
      if (!w.constructed) this.once(f, function(G) {
        h(this, P(G, j), H);
      });
      else h(this, j, H);
      return this;
    }
    function h(j, H, Z) {
      let W = false;
      function w(G) {
        if (W) return;
        W = true;
        let { _readableState: S, _writableState: A } = j;
        if (M(G, A, S), A) A.closed = true;
        if (S) S.closed = true;
        if (typeof Z === "function") Z(G);
        if (G) K.nextTick(E, j, G);
        else K.nextTick(I, j);
      }
      try {
        j._destroy(H || null, w);
      } catch (G) {
        w(G);
      }
    }
    function E(j, H) {
      D(j, H), I(j);
    }
    function I(j) {
      let { _readableState: H, _writableState: Z } = j;
      if (Z) Z.closeEmitted = true;
      if (H) H.closeEmitted = true;
      if (Z !== null && Z !== void 0 && Z.emitClose || H !== null && H !== void 0 && H.emitClose) j.emit("close");
    }
    function D(j, H) {
      let { _readableState: Z, _writableState: W } = j;
      if (W !== null && W !== void 0 && W.errorEmitted || Z !== null && Z !== void 0 && Z.errorEmitted) return;
      if (W) W.errorEmitted = true;
      if (Z) Z.errorEmitted = true;
      j.emit("error", H);
    }
    function g() {
      let j = this._readableState, H = this._writableState;
      if (j) j.constructed = true, j.closed = false, j.closeEmitted = false, j.destroyed = false, j.errored = null, j.errorEmitted = false, j.reading = false, j.ended = j.readable === false, j.endEmitted = j.readable === false;
      if (H) H.constructed = true, H.destroyed = false, H.closed = false, H.closeEmitted = false, H.errored = null, H.errorEmitted = false, H.finalCalled = false, H.prefinished = false, H.ended = H.writable === false, H.ending = H.writable === false, H.finished = H.writable === false;
    }
    function b(j, H, Z) {
      let { _readableState: W, _writableState: w } = j;
      if (w !== null && w !== void 0 && w.destroyed || W !== null && W !== void 0 && W.destroyed) return this;
      if (W !== null && W !== void 0 && W.autoDestroy || w !== null && w !== void 0 && w.autoDestroy) j.destroy(H);
      else if (H) {
        if (H.stack, w && !w.errored) w.errored = H;
        if (W && !W.errored) W.errored = H;
        if (Z) K.nextTick(D, j, H);
        else D(j, H);
      }
    }
    function y(j, H) {
      if (typeof j._construct !== "function") return;
      let { _readableState: Z, _writableState: W } = j;
      if (Z) Z.constructed = false;
      if (W) W.constructed = false;
      if (j.once(V, H), j.listenerCount(V) > 1) return;
      K.nextTick(p, j);
    }
    function p(j) {
      let H = false;
      function Z(W) {
        if (H) {
          b(j, W !== null && W !== void 0 ? W : new _());
          return;
        }
        H = true;
        let { _readableState: w, _writableState: G } = j, S = G || w;
        if (w) w.constructed = true;
        if (G) G.constructed = true;
        if (S.destroyed) j.emit(f, W);
        else if (W) b(j, W, true);
        else K.nextTick(n, j);
      }
      try {
        j._construct((W) => {
          K.nextTick(Z, W);
        });
      } catch (W) {
        K.nextTick(Z, W);
      }
    }
    function n(j) {
      j.emit(V);
    }
    function s(j) {
      return (j === null || j === void 0 ? void 0 : j.setHeader) && typeof j.abort === "function";
    }
    function q$(j) {
      j.emit("close");
    }
    function c(j, H) {
      j.emit("error", H), K.nextTick(q$, j);
    }
    function U(j, H) {
      if (!j || J(j)) return;
      if (!H && !T(j)) H = new Y();
      if (X(j)) j.socket = null, j.destroy(H);
      else if (s(j)) j.abort();
      else if (s(j.req)) j.req.abort();
      else if (typeof j.destroy === "function") j.destroy(H);
      else if (typeof j.close === "function") j.close();
      else if (H) K.nextTick(c, j, H);
      else K.nextTick(q$, j);
      if (!j.destroyed) j[z] = true;
    }
    q.exports = { construct: y, destroyer: U, destroy: N, undestroy: g, errorOrDestroy: b };
  }), uH = V6(($18, q) => {
    var { ArrayIsArray: K, ObjectSetPrototypeOf: P } = u6(), { EventEmitter: _ } = (o7(), J6(r7));
    function Y(z) {
      _.call(this, z);
    }
    P(Y.prototype, _.prototype), P(Y, _), Y.prototype.pipe = function(z, J) {
      let T = this;
      function X(I) {
        if (z.writable && z.write(I) === false && T.pause) T.pause();
      }
      T.on("data", X);
      function f() {
        if (T.readable && T.resume) T.resume();
      }
      if (z.on("drain", f), !z._isStdio && (!J || J.end !== false)) T.on("end", M), T.on("close", N);
      let V = false;
      function M() {
        if (V) return;
        V = true, z.end();
      }
      function N() {
        if (V) return;
        if (V = true, typeof z.destroy === "function") z.destroy();
      }
      function h(I) {
        if (E(), _.listenerCount(this, "error") === 0) this.emit("error", I);
      }
      O(T, "error", h), O(z, "error", h);
      function E() {
        T.removeListener("data", X), z.removeListener("drain", f), T.removeListener("end", M), T.removeListener("close", N), T.removeListener("error", h), z.removeListener("error", h), T.removeListener("end", E), T.removeListener("close", E), z.removeListener("close", E);
      }
      return T.on("end", E), T.on("close", E), z.on("close", E), z.emit("pipe", T), z;
    };
    function O(z, J, T) {
      if (typeof z.prependListener === "function") return z.prependListener(J, T);
      if (!z._events || !z._events[J]) z.on(J, T);
      else if (K(z._events[J])) z._events[J].unshift(T);
      else z._events[J] = [T, z._events[J]];
    }
    q.exports = { Stream: Y, prependListener: O };
  }), qO = V6(($18, q) => {
    var { SymbolDispose: K } = u6(), { AbortError: P, codes: _ } = cq(), { isNodeStream: Y, isWebStream: O, kControllerErrorFunction: z } = SK(), J = sK(), { ERR_INVALID_ARG_TYPE: T } = _, X, f = (V, M) => {
      if (typeof V !== "object" || !("aborted" in V)) throw new T(M, "AbortSignal", V);
    };
    q.exports.addAbortSignal = function(V, M) {
      if (f(V, "signal"), !Y(M) && !O(M)) throw new T("stream", ["ReadableStream", "WritableStream", "Stream"], M);
      return q.exports.addAbortSignalNoValidate(V, M);
    }, q.exports.addAbortSignalNoValidate = function(V, M) {
      if (typeof V !== "object" || !("aborted" in V)) return M;
      let N = Y(M) ? () => {
        M.destroy(new P(void 0, { cause: V.reason }));
      } : () => {
        M[z](new P(void 0, { cause: V.reason }));
      };
      if (V.aborted) N();
      else {
        X = X || sq().addAbortListener;
        let h = X(V, N);
        J(M, h[K]);
      }
      return M;
    };
  }), Nr = V6(($18, q) => {
    var { StringPrototypeSlice: K, SymbolIterator: P, TypedArrayPrototypeSet: _, Uint8Array: Y } = u6(), { Buffer: O } = (wq(), J6(Tq)), { inspect: z } = sq();
    q.exports = class {
      constructor() {
        this.head = null, this.tail = null, this.length = 0;
      }
      push(J) {
        let T = { data: J, next: null };
        if (this.length > 0) this.tail.next = T;
        else this.head = T;
        this.tail = T, ++this.length;
      }
      unshift(J) {
        let T = { data: J, next: this.head };
        if (this.length === 0) this.tail = T;
        this.head = T, ++this.length;
      }
      shift() {
        if (this.length === 0) return;
        let J = this.head.data;
        if (this.length === 1) this.head = this.tail = null;
        else this.head = this.head.next;
        return --this.length, J;
      }
      clear() {
        this.head = this.tail = null, this.length = 0;
      }
      join(J) {
        if (this.length === 0) return "";
        let T = this.head, X = "" + T.data;
        while ((T = T.next) !== null) X += J + T.data;
        return X;
      }
      concat(J) {
        if (this.length === 0) return O.alloc(0);
        let T = O.allocUnsafe(J >>> 0), X = this.head, f = 0;
        while (X) _(T, X.data, f), f += X.data.length, X = X.next;
        return T;
      }
      consume(J, T) {
        let X = this.head.data;
        if (J < X.length) {
          let f = X.slice(0, J);
          return this.head.data = X.slice(J), f;
        }
        if (J === X.length) return this.shift();
        return T ? this._getString(J) : this._getBuffer(J);
      }
      first() {
        return this.head.data;
      }
      *[P]() {
        for (let J = this.head; J; J = J.next) yield J.data;
      }
      _getString(J) {
        let T = "", X = this.head, f = 0;
        do {
          let V = X.data;
          if (J > V.length) T += V, J -= V.length;
          else {
            if (J === V.length) if (T += V, ++f, X.next) this.head = X.next;
            else this.head = this.tail = null;
            else T += K(V, 0, J), this.head = X, X.data = K(V, J);
            break;
          }
          ++f;
        } while ((X = X.next) !== null);
        return this.length -= f, T;
      }
      _getBuffer(J) {
        let T = O.allocUnsafe(J), X = J, f = this.head, V = 0;
        do {
          let M = f.data;
          if (J > M.length) _(T, M, X - J), J -= M.length;
          else {
            if (J === M.length) if (_(T, M, X - J), ++V, f.next) this.head = f.next;
            else this.head = this.tail = null;
            else _(T, new Y(M.buffer, M.byteOffset, J), X - J), this.head = f, f.data = M.slice(J);
            break;
          }
          ++V;
        } while ((f = f.next) !== null);
        return this.length -= V, T;
      }
      [Symbol.for("nodejs.util.inspect.custom")](J, T) {
        return z(this, { ...T, depth: 0, customInspect: false });
      }
    };
  }), KO = V6(($18, q) => {
    var { MathFloor: K, NumberIsInteger: P } = u6(), { validateInteger: _ } = i7(), { ERR_INVALID_ARG_VALUE: Y } = cq().codes, O = 16384, z = 16;
    function J(V, M, N) {
      return V.highWaterMark != null ? V.highWaterMark : M ? V[N] : null;
    }
    function T(V) {
      return V ? z : O;
    }
    function X(V, M) {
      if (_(M, "value", 0), V) z = M;
      else O = M;
    }
    function f(V, M, N, h) {
      let E = J(M, h, N);
      if (E != null) {
        if (!P(E) || E < 0) {
          let I = h ? `options.${N}` : "options.highWaterMark";
          throw new Y(I, E);
        }
        return K(E);
      }
      return T(V.objectMode);
    }
    q.exports = { getHighWaterMark: f, getDefaultHighWaterMark: T, setDefaultHighWaterMark: X };
  }), Cr = V6(($18, q) => {
    var K = (wq(), J6(Tq)), P = K.Buffer;
    function _(O, z) {
      for (var J in O) z[J] = O[J];
    }
    if (P.from && P.alloc && P.allocUnsafe && P.allocUnsafeSlow) q.exports = K;
    else _(K, $18), $18.Buffer = Y;
    function Y(O, z, J) {
      return P(O, z, J);
    }
    Y.prototype = Object.create(P.prototype), _(P, Y), Y.from = function(O, z, J) {
      if (typeof O === "number") throw TypeError("Argument must not be a number");
      return P(O, z, J);
    }, Y.alloc = function(O, z, J) {
      if (typeof O !== "number") throw TypeError("Argument must be a number");
      var T = P(O);
      if (z !== void 0) if (typeof J === "string") T.fill(z, J);
      else T.fill(z);
      else T.fill(0);
      return T;
    }, Y.allocUnsafe = function(O) {
      if (typeof O !== "number") throw TypeError("Argument must be a number");
      return P(O);
    }, Y.allocUnsafeSlow = function(O) {
      if (typeof O !== "number") throw TypeError("Argument must be a number");
      return K.SlowBuffer(O);
    };
  }), Er = V6(($18) => {
    var q = Cr().Buffer, K = q.isEncoding || function(D) {
      switch (D = "" + D, D && D.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function P(D) {
      if (!D) return "utf8";
      var g;
      while (true) switch (D) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return D;
        default:
          if (g) return;
          D = ("" + D).toLowerCase(), g = true;
      }
    }
    function _(D) {
      var g = P(D);
      if (typeof g !== "string" && (q.isEncoding === K || !K(D))) throw Error("Unknown encoding: " + D);
      return g || D;
    }
    $18.StringDecoder = Y;
    function Y(D) {
      this.encoding = _(D);
      var g;
      switch (this.encoding) {
        case "utf16le":
          this.text = V, this.end = M, g = 4;
          break;
        case "utf8":
          this.fillLast = T, g = 4;
          break;
        case "base64":
          this.text = N, this.end = h, g = 3;
          break;
        default:
          this.write = E, this.end = I;
          return;
      }
      this.lastNeed = 0, this.lastTotal = 0, this.lastChar = q.allocUnsafe(g);
    }
    Y.prototype.write = function(D) {
      if (D.length === 0) return "";
      var g, b;
      if (this.lastNeed) {
        if (g = this.fillLast(D), g === void 0) return "";
        b = this.lastNeed, this.lastNeed = 0;
      } else b = 0;
      if (b < D.length) return g ? g + this.text(D, b) : this.text(D, b);
      return g || "";
    }, Y.prototype.end = f, Y.prototype.text = X, Y.prototype.fillLast = function(D) {
      if (this.lastNeed <= D.length) return D.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
      D.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, D.length), this.lastNeed -= D.length;
    };
    function O(D) {
      if (D <= 127) return 0;
      else if (D >> 5 === 6) return 2;
      else if (D >> 4 === 14) return 3;
      else if (D >> 3 === 30) return 4;
      return D >> 6 === 2 ? -1 : -2;
    }
    function z(D, g, b) {
      var y = g.length - 1;
      if (y < b) return 0;
      var p = O(g[y]);
      if (p >= 0) {
        if (p > 0) D.lastNeed = p - 1;
        return p;
      }
      if (--y < b || p === -2) return 0;
      if (p = O(g[y]), p >= 0) {
        if (p > 0) D.lastNeed = p - 2;
        return p;
      }
      if (--y < b || p === -2) return 0;
      if (p = O(g[y]), p >= 0) {
        if (p > 0) if (p === 2) p = 0;
        else D.lastNeed = p - 3;
        return p;
      }
      return 0;
    }
    function J(D, g, b) {
      if ((g[0] & 192) !== 128) return D.lastNeed = 0, "";
      if (D.lastNeed > 1 && g.length > 1) {
        if ((g[1] & 192) !== 128) return D.lastNeed = 1, "";
        if (D.lastNeed > 2 && g.length > 2) {
          if ((g[2] & 192) !== 128) return D.lastNeed = 2, "";
        }
      }
    }
    function T(D) {
      var g = this.lastTotal - this.lastNeed, b = J(this, D, g);
      if (b !== void 0) return b;
      if (this.lastNeed <= D.length) return D.copy(this.lastChar, g, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
      D.copy(this.lastChar, g, 0, D.length), this.lastNeed -= D.length;
    }
    function X(D, g) {
      var b = z(this, D, g);
      if (!this.lastNeed) return D.toString("utf8", g);
      this.lastTotal = b;
      var y = D.length - (b - this.lastNeed);
      return D.copy(this.lastChar, 0, y), D.toString("utf8", g, y);
    }
    function f(D) {
      var g = D && D.length ? this.write(D) : "";
      if (this.lastNeed) return g + "";
      return g;
    }
    function V(D, g) {
      if ((D.length - g) % 2 === 0) {
        var b = D.toString("utf16le", g);
        if (b) {
          var y = b.charCodeAt(b.length - 1);
          if (y >= 55296 && y <= 56319) return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = D[D.length - 2], this.lastChar[1] = D[D.length - 1], b.slice(0, -1);
        }
        return b;
      }
      return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = D[D.length - 1], D.toString("utf16le", g, D.length - 1);
    }
    function M(D) {
      var g = D && D.length ? this.write(D) : "";
      if (this.lastNeed) {
        var b = this.lastTotal - this.lastNeed;
        return g + this.lastChar.toString("utf16le", 0, b);
      }
      return g;
    }
    function N(D, g) {
      var b = (D.length - g) % 3;
      if (b === 0) return D.toString("base64", g);
      if (this.lastNeed = 3 - b, this.lastTotal = 3, b === 1) this.lastChar[0] = D[D.length - 1];
      else this.lastChar[0] = D[D.length - 2], this.lastChar[1] = D[D.length - 1];
      return D.toString("base64", g, D.length - b);
    }
    function h(D) {
      var g = D && D.length ? this.write(D) : "";
      if (this.lastNeed) return g + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
      return g;
    }
    function E(D) {
      return D.toString(this.encoding);
    }
    function I(D) {
      return D && D.length ? this.write(D) : "";
    }
  }), nS = V6(($18, q) => {
    var K = y_(), { PromisePrototypeThen: P, SymbolAsyncIterator: _, SymbolIterator: Y } = u6(), { Buffer: O } = (wq(), J6(Tq)), { ERR_INVALID_ARG_TYPE: z, ERR_STREAM_NULL_VALUES: J } = cq().codes;
    function T(X, f, V) {
      let M;
      if (typeof f === "string" || f instanceof O) return new X({ objectMode: true, ...V, read() {
        this.push(f), this.push(null);
      } });
      let N;
      if (f && f[_]) N = true, M = f[_]();
      else if (f && f[Y]) N = false, M = f[Y]();
      else throw new z("iterable", ["Iterable"], f);
      let h = new X({ objectMode: true, highWaterMark: 1, ...V }), E = false;
      h._read = function() {
        if (!E) E = true, D();
      }, h._destroy = function(g, b) {
        P(I(g), () => K.nextTick(b, g), (y) => K.nextTick(b, y || g));
      };
      async function I(g) {
        let b = g !== void 0 && g !== null, y = typeof M.throw === "function";
        if (b && y) {
          let { value: p, done: n } = await M.throw(g);
          if (await p, n) return;
        }
        if (typeof M.return === "function") {
          let { value: p } = await M.return();
          await p;
        }
      }
      async function D() {
        for (; ; ) {
          try {
            let { value: g, done: b } = N ? await M.next() : M.next();
            if (b) h.push(null);
            else {
              let y = g && typeof g.then === "function" ? await g : g;
              if (y === null) throw E = false, new J();
              else if (h.push(y)) continue;
              else E = false;
            }
          } catch (g) {
            h.destroy(g);
          }
          break;
        }
      }
      return h;
    }
    q.exports = T;
  }), _O = V6(($18, q) => {
    var K = y_(), { ArrayPrototypeIndexOf: P, NumberIsInteger: _, NumberIsNaN: Y, NumberParseInt: O, ObjectDefineProperties: z, ObjectKeys: J, ObjectSetPrototypeOf: T, Promise: X, SafeSet: f, SymbolAsyncDispose: V, SymbolAsyncIterator: M, Symbol: N } = u6();
    q.exports = t, t.ReadableState = W$;
    var { EventEmitter: h } = (o7(), J6(r7)), { Stream: E, prependListener: I } = uH(), { Buffer: D } = (wq(), J6(Tq)), { addAbortSignal: g } = qO(), b = sK(), y = sq().debuglog("stream", (u) => {
      y = u;
    }), p = Nr(), n = c4(), { getHighWaterMark: s, getDefaultHighWaterMark: q$ } = KO(), { aggregateTwoErrors: c, codes: { ERR_INVALID_ARG_TYPE: U, ERR_METHOD_NOT_IMPLEMENTED: j, ERR_OUT_OF_RANGE: H, ERR_STREAM_PUSH_AFTER_EOF: Z, ERR_STREAM_UNSHIFT_AFTER_END_EVENT: W }, AbortError: w } = cq(), { validateObject: G } = i7(), S = N("kPaused"), { StringDecoder: A } = Er(), v = nS();
    T(t.prototype, E.prototype), T(t, E);
    var k = () => {
    }, { errorOrDestroy: R } = n, C = 1, L = 2, x = 4, l = 8, a = 16, f$ = 32, $$ = 64, B = 128, H$ = 256, Q = 512, v$ = 1024, t$ = 2048, m = 4096, r = 8192, J$ = 16384, e = 32768, _$2 = 65536, Y$ = 131072, d = 262144;
    function o(u) {
      return { enumerable: false, get() {
        return (this.state & u) !== 0;
      }, set(i) {
        if (i) this.state |= u;
        else this.state &= ~u;
      } };
    }
    z(W$.prototype, { objectMode: o(C), ended: o(L), endEmitted: o(x), reading: o(l), constructed: o(a), sync: o(f$), needReadable: o($$), emittedReadable: o(B), readableListening: o(H$), resumeScheduled: o(Q), errorEmitted: o(v$), emitClose: o(t$), autoDestroy: o(m), destroyed: o(r), closed: o(J$), closeEmitted: o(e), multiAwaitDrain: o(_$2), readingMore: o(Y$), dataEmitted: o(d) });
    function W$(u, i, K$) {
      if (typeof K$ !== "boolean") K$ = i instanceof VK();
      if (this.state = t$ | m | a | f$, u && u.objectMode) this.state |= C;
      if (K$ && u && u.readableObjectMode) this.state |= C;
      if (this.highWaterMark = u ? s(this, u, "readableHighWaterMark", K$) : q$(false), this.buffer = new p(), this.length = 0, this.pipes = [], this.flowing = null, this[S] = null, u && u.emitClose === false) this.state &= ~t$;
      if (u && u.autoDestroy === false) this.state &= ~m;
      if (this.errored = null, this.defaultEncoding = u && u.defaultEncoding || "utf8", this.awaitDrainWriters = null, this.decoder = null, this.encoding = null, u && u.encoding) this.decoder = new A(u.encoding), this.encoding = u.encoding;
    }
    function t(u) {
      if (!(this instanceof t)) return new t(u);
      let i = this instanceof VK();
      if (this._readableState = new W$(u, this, i), u) {
        if (typeof u.read === "function") this._read = u.read;
        if (typeof u.destroy === "function") this._destroy = u.destroy;
        if (typeof u.construct === "function") this._construct = u.construct;
        if (u.signal && !i) g(u.signal, this);
      }
      E.call(this, u), n.construct(this, () => {
        if (this._readableState.needReadable) S$(this, this._readableState);
      });
    }
    t.prototype.destroy = n.destroy, t.prototype._undestroy = n.undestroy, t.prototype._destroy = function(u, i) {
      i(u);
    }, t.prototype[h.captureRejectionSymbol] = function(u) {
      this.destroy(u);
    }, t.prototype[V] = function() {
      let u;
      if (!this.destroyed) u = this.readableEnded ? null : new w(), this.destroy(u);
      return new X((i, K$) => b(this, (P$) => P$ && P$ !== u ? K$(P$) : i(null)));
    }, t.prototype.push = function(u, i) {
      return F(this, u, i, false);
    }, t.prototype.unshift = function(u, i) {
      return F(this, u, i, true);
    };
    function F(u, i, K$, P$) {
      y("readableAddChunk", i);
      let i$ = u._readableState, k$;
      if ((i$.state & C) === 0) {
        if (typeof i === "string") {
          if (K$ = K$ || i$.defaultEncoding, i$.encoding !== K$) if (P$ && i$.encoding) i = D.from(i, K$).toString(i$.encoding);
          else i = D.from(i, K$), K$ = "";
        } else if (i instanceof D) K$ = "";
        else if (E._isUint8Array(i)) i = E._uint8ArrayToBuffer(i), K$ = "";
        else if (i != null) k$ = new U("chunk", ["string", "Buffer", "Uint8Array"], i);
      }
      if (k$) R(u, k$);
      else if (i === null) i$.state &= ~l, Z$(u, i$);
      else if ((i$.state & C) !== 0 || i && i.length > 0) if (P$) if ((i$.state & x) !== 0) R(u, new W());
      else if (i$.destroyed || i$.errored) return false;
      else X$(u, i$, i, true);
      else if (i$.ended) R(u, new Z());
      else if (i$.destroyed || i$.errored) return false;
      else if (i$.state &= ~l, i$.decoder && !K$) if (i = i$.decoder.write(i), i$.objectMode || i.length !== 0) X$(u, i$, i, false);
      else S$(u, i$);
      else X$(u, i$, i, false);
      else if (!P$) i$.state &= ~l, S$(u, i$);
      return !i$.ended && (i$.length < i$.highWaterMark || i$.length === 0);
    }
    function X$(u, i, K$, P$) {
      if (i.flowing && i.length === 0 && !i.sync && u.listenerCount("data") > 0) {
        if ((i.state & _$2) !== 0) i.awaitDrainWriters.clear();
        else i.awaitDrainWriters = null;
        i.dataEmitted = true, u.emit("data", K$);
      } else {
        if (i.length += i.objectMode ? 1 : K$.length, P$) i.buffer.unshift(K$);
        else i.buffer.push(K$);
        if ((i.state & $$) !== 0) A$(u);
      }
      S$(u, i);
    }
    t.prototype.isPaused = function() {
      let u = this._readableState;
      return u[S] === true || u.flowing === false;
    }, t.prototype.setEncoding = function(u) {
      let i = new A(u);
      this._readableState.decoder = i, this._readableState.encoding = this._readableState.decoder.encoding;
      let K$ = this._readableState.buffer, P$ = "";
      for (let i$ of K$) P$ += i.write(i$);
      if (K$.clear(), P$ !== "") K$.push(P$);
      return this._readableState.length = P$.length, this;
    };
    var z$ = 1073741824;
    function j$(u) {
      if (u > z$) throw new H("size", "<= 1GiB", u);
      else u--, u |= u >>> 1, u |= u >>> 2, u |= u >>> 4, u |= u >>> 8, u |= u >>> 16, u++;
      return u;
    }
    function X6(u, i) {
      if (u <= 0 || i.length === 0 && i.ended) return 0;
      if ((i.state & C) !== 0) return 1;
      if (Y(u)) {
        if (i.flowing && i.length) return i.buffer.first().length;
        return i.length;
      }
      if (u <= i.length) return u;
      return i.ended ? i.length : 0;
    }
    t.prototype.read = function(u) {
      if (y("read", u), u === void 0) u = NaN;
      else if (!_(u)) u = O(u, 10);
      let i = this._readableState, K$ = u;
      if (u > i.highWaterMark) i.highWaterMark = j$(u);
      if (u !== 0) i.state &= ~B;
      if (u === 0 && i.needReadable && ((i.highWaterMark !== 0 ? i.length >= i.highWaterMark : i.length > 0) || i.ended)) {
        if (y("read: emitReadable", i.length, i.ended), i.length === 0 && i.ended) vq(this);
        else A$(this);
        return null;
      }
      if (u = X6(u, i), u === 0 && i.ended) {
        if (i.length === 0) vq(this);
        return null;
      }
      let P$ = (i.state & $$) !== 0;
      if (y("need readable", P$), i.length === 0 || i.length - u < i.highWaterMark) P$ = true, y("length less than watermark", P$);
      if (i.ended || i.reading || i.destroyed || i.errored || !i.constructed) P$ = false, y("reading, ended or constructing", P$);
      else if (P$) {
        if (y("do read"), i.state |= l | f$, i.length === 0) i.state |= $$;
        try {
          this._read(i.highWaterMark);
        } catch (k$) {
          R(this, k$);
        }
        if (i.state &= ~f$, !i.reading) u = X6(K$, i);
      }
      let i$;
      if (u > 0) i$ = E$(u, i);
      else i$ = null;
      if (i$ === null) i.needReadable = i.length <= i.highWaterMark, u = 0;
      else if (i.length -= u, i.multiAwaitDrain) i.awaitDrainWriters.clear();
      else i.awaitDrainWriters = null;
      if (i.length === 0) {
        if (!i.ended) i.needReadable = true;
        if (K$ !== u && i.ended) vq(this);
      }
      if (i$ !== null && !i.errorEmitted && !i.closeEmitted) i.dataEmitted = true, this.emit("data", i$);
      return i$;
    };
    function Z$(u, i) {
      if (y("onEofChunk"), i.ended) return;
      if (i.decoder) {
        let K$ = i.decoder.end();
        if (K$ && K$.length) i.buffer.push(K$), i.length += i.objectMode ? 1 : K$.length;
      }
      if (i.ended = true, i.sync) A$(u);
      else i.needReadable = false, i.emittedReadable = true, d6(u);
    }
    function A$(u) {
      let i = u._readableState;
      if (y("emitReadable", i.needReadable, i.emittedReadable), i.needReadable = false, !i.emittedReadable) y("emitReadable", i.flowing), i.emittedReadable = true, K.nextTick(d6, u);
    }
    function d6(u) {
      let i = u._readableState;
      if (y("emitReadable_", i.destroyed, i.length, i.ended), !i.destroyed && !i.errored && (i.length || i.ended)) u.emit("readable"), i.emittedReadable = false;
      i.needReadable = !i.flowing && !i.ended && i.length <= i.highWaterMark, C$(u);
    }
    function S$(u, i) {
      if (!i.readingMore && i.constructed) i.readingMore = true, K.nextTick(V$, u, i);
    }
    function V$(u, i) {
      while (!i.reading && !i.ended && (i.length < i.highWaterMark || i.flowing && i.length === 0)) {
        let K$ = i.length;
        if (y("maybeReadMore read 0"), u.read(0), K$ === i.length) break;
      }
      i.readingMore = false;
    }
    t.prototype._read = function(u) {
      throw new j("_read()");
    }, t.prototype.pipe = function(u, i) {
      let K$ = this, P$ = this._readableState;
      if (P$.pipes.length === 1) {
        if (!P$.multiAwaitDrain) P$.multiAwaitDrain = true, P$.awaitDrainWriters = new f(P$.awaitDrainWriters ? [P$.awaitDrainWriters] : []);
      }
      P$.pipes.push(u), y("pipe count=%d opts=%j", P$.pipes.length, i);
      let i$ = (!i || i.end !== false) && u !== K.stdout && u !== K.stderr ? G$ : v6;
      if (P$.endEmitted) K.nextTick(i$);
      else K$.once("end", i$);
      u.on("unpipe", k$);
      function k$(C6, S6) {
        if (y("onunpipe"), C6 === K$) {
          if (S6 && S6.hasUnpiped === false) S6.hasUnpiped = true, u$();
        }
      }
      function G$() {
        y("onend"), u.end();
      }
      let x6, R$ = false;
      function u$() {
        if (y("cleanup"), u.removeListener("close", p6), u.removeListener("finish", H6), x6) u.removeListener("drain", x6);
        if (u.removeListener("error", M$), u.removeListener("unpipe", k$), K$.removeListener("end", G$), K$.removeListener("end", v6), K$.removeListener("data", I$), R$ = true, x6 && P$.awaitDrainWriters && (!u._writableState || u._writableState.needDrain)) x6();
      }
      function Zq() {
        if (!R$) {
          if (P$.pipes.length === 1 && P$.pipes[0] === u) y("false write response, pause", 0), P$.awaitDrainWriters = u, P$.multiAwaitDrain = false;
          else if (P$.pipes.length > 1 && P$.pipes.includes(u)) y("false write response, pause", P$.awaitDrainWriters.size), P$.awaitDrainWriters.add(u);
          K$.pause();
        }
        if (!x6) x6 = Sq(K$, u), u.on("drain", x6);
      }
      K$.on("data", I$);
      function I$(C6) {
        y("ondata");
        let S6 = u.write(C6);
        if (y("dest.write", S6), S6 === false) Zq();
      }
      function M$(C6) {
        if (y("onerror", C6), v6(), u.removeListener("error", M$), u.listenerCount("error") === 0) {
          let S6 = u._writableState || u._readableState;
          if (S6 && !S6.errorEmitted) R(u, C6);
          else u.emit("error", C6);
        }
      }
      I(u, "error", M$);
      function p6() {
        u.removeListener("finish", H6), v6();
      }
      u.once("close", p6);
      function H6() {
        y("onfinish"), u.removeListener("close", p6), v6();
      }
      u.once("finish", H6);
      function v6() {
        y("unpipe"), K$.unpipe(u);
      }
      if (u.emit("pipe", K$), u.writableNeedDrain === true) Zq();
      else if (!P$.flowing) y("pipe resume"), K$.resume();
      return u;
    };
    function Sq(u, i) {
      return function() {
        let K$ = u._readableState;
        if (K$.awaitDrainWriters === i) y("pipeOnDrain", 1), K$.awaitDrainWriters = null;
        else if (K$.multiAwaitDrain) y("pipeOnDrain", K$.awaitDrainWriters.size), K$.awaitDrainWriters.delete(i);
        if ((!K$.awaitDrainWriters || K$.awaitDrainWriters.size === 0) && u.listenerCount("data")) u.resume();
      };
    }
    t.prototype.unpipe = function(u) {
      let i = this._readableState, K$ = { hasUnpiped: false };
      if (i.pipes.length === 0) return this;
      if (!u) {
        let i$ = i.pipes;
        i.pipes = [], this.pause();
        for (let k$ = 0; k$ < i$.length; k$++) i$[k$].emit("unpipe", this, { hasUnpiped: false });
        return this;
      }
      let P$ = P(i.pipes, u);
      if (P$ === -1) return this;
      if (i.pipes.splice(P$, 1), i.pipes.length === 0) this.pause();
      return u.emit("unpipe", this, K$), this;
    }, t.prototype.on = function(u, i) {
      let K$ = E.prototype.on.call(this, u, i), P$ = this._readableState;
      if (u === "data") {
        if (P$.readableListening = this.listenerCount("readable") > 0, P$.flowing !== false) this.resume();
      } else if (u === "readable") {
        if (!P$.endEmitted && !P$.readableListening) {
          if (P$.readableListening = P$.needReadable = true, P$.flowing = false, P$.emittedReadable = false, y("on readable", P$.length, P$.reading), P$.length) A$(this);
          else if (!P$.reading) K.nextTick(D$, this);
        }
      }
      return K$;
    }, t.prototype.addListener = t.prototype.on, t.prototype.removeListener = function(u, i) {
      let K$ = E.prototype.removeListener.call(this, u, i);
      if (u === "readable") K.nextTick(N$, this);
      return K$;
    }, t.prototype.off = t.prototype.removeListener, t.prototype.removeAllListeners = function(u) {
      let i = E.prototype.removeAllListeners.apply(this, arguments);
      if (u === "readable" || u === void 0) K.nextTick(N$, this);
      return i;
    };
    function N$(u) {
      let i = u._readableState;
      if (i.readableListening = u.listenerCount("readable") > 0, i.resumeScheduled && i[S] === false) i.flowing = true;
      else if (u.listenerCount("data") > 0) u.resume();
      else if (!i.readableListening) i.flowing = null;
    }
    function D$(u) {
      y("readable nexttick read 0"), u.read(0);
    }
    t.prototype.resume = function() {
      let u = this._readableState;
      if (!u.flowing) y("resume"), u.flowing = !u.readableListening, Mq(this, u);
      return u[S] = false, this;
    };
    function Mq(u, i) {
      if (!i.resumeScheduled) i.resumeScheduled = true, K.nextTick(L$, u, i);
    }
    function L$(u, i) {
      if (y("resume", i.reading), !i.reading) u.read(0);
      if (i.resumeScheduled = false, u.emit("resume"), C$(u), i.flowing && !i.reading) u.read(0);
    }
    t.prototype.pause = function() {
      if (y("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== false) y("pause"), this._readableState.flowing = false, this.emit("pause");
      return this._readableState[S] = true, this;
    };
    function C$(u) {
      let i = u._readableState;
      y("flow", i.flowing);
      while (i.flowing && u.read() !== null) ;
    }
    t.prototype.wrap = function(u) {
      let i = false;
      u.on("data", (P$) => {
        if (!this.push(P$) && u.pause) i = true, u.pause();
      }), u.on("end", () => {
        this.push(null);
      }), u.on("error", (P$) => {
        R(this, P$);
      }), u.on("close", () => {
        this.destroy();
      }), u.on("destroy", () => {
        this.destroy();
      }), this._read = () => {
        if (i && u.resume) i = false, u.resume();
      };
      let K$ = J(u);
      for (let P$ = 1; P$ < K$.length; P$++) {
        let i$ = K$[P$];
        if (this[i$] === void 0 && typeof u[i$] === "function") this[i$] = u[i$].bind(u);
      }
      return this;
    }, t.prototype[M] = function() {
      return fq(this);
    }, t.prototype.iterator = function(u) {
      if (u !== void 0) G(u, "options");
      return fq(this, u);
    };
    function fq(u, i) {
      if (typeof u.read !== "function") u = t.wrap(u, { objectMode: true });
      let K$ = g$(u, i);
      return K$.stream = u, K$;
    }
    async function* g$(u, i) {
      let K$ = k;
      function P$(G$) {
        if (this === u) K$(), K$ = k;
        else K$ = G$;
      }
      u.on("readable", P$);
      let i$, k$ = b(u, { writable: false }, (G$) => {
        i$ = G$ ? c(i$, G$) : null, K$(), K$ = k;
      });
      try {
        while (true) {
          let G$ = u.destroyed ? null : u.read();
          if (G$ !== null) yield G$;
          else if (i$) throw i$;
          else if (i$ === null) return;
          else await new X(P$);
        }
      } catch (G$) {
        throw i$ = c(i$, G$), i$;
      } finally {
        if ((i$ || (i === null || i === void 0 ? void 0 : i.destroyOnReturn) !== false) && (i$ === void 0 || u._readableState.autoDestroy)) n.destroyer(u, null);
        else u.off("readable", P$), k$();
      }
    }
    z(t.prototype, { readable: { __proto__: null, get() {
      let u = this._readableState;
      return !!u && u.readable !== false && !u.destroyed && !u.errorEmitted && !u.endEmitted;
    }, set(u) {
      if (this._readableState) this._readableState.readable = !!u;
    } }, readableDidRead: { __proto__: null, enumerable: false, get: function() {
      return this._readableState.dataEmitted;
    } }, readableAborted: { __proto__: null, enumerable: false, get: function() {
      return !!(this._readableState.readable !== false && (this._readableState.destroyed || this._readableState.errored) && !this._readableState.endEmitted);
    } }, readableHighWaterMark: { __proto__: null, enumerable: false, get: function() {
      return this._readableState.highWaterMark;
    } }, readableBuffer: { __proto__: null, enumerable: false, get: function() {
      return this._readableState && this._readableState.buffer;
    } }, readableFlowing: { __proto__: null, enumerable: false, get: function() {
      return this._readableState.flowing;
    }, set: function(u) {
      if (this._readableState) this._readableState.flowing = u;
    } }, readableLength: { __proto__: null, enumerable: false, get() {
      return this._readableState.length;
    } }, readableObjectMode: { __proto__: null, enumerable: false, get() {
      return this._readableState ? this._readableState.objectMode : false;
    } }, readableEncoding: { __proto__: null, enumerable: false, get() {
      return this._readableState ? this._readableState.encoding : null;
    } }, errored: { __proto__: null, enumerable: false, get() {
      return this._readableState ? this._readableState.errored : null;
    } }, closed: { __proto__: null, get() {
      return this._readableState ? this._readableState.closed : false;
    } }, destroyed: { __proto__: null, enumerable: false, get() {
      return this._readableState ? this._readableState.destroyed : false;
    }, set(u) {
      if (!this._readableState) return;
      this._readableState.destroyed = u;
    } }, readableEnded: { __proto__: null, enumerable: false, get() {
      return this._readableState ? this._readableState.endEmitted : false;
    } } }), z(W$.prototype, { pipesCount: { __proto__: null, get() {
      return this.pipes.length;
    } }, paused: { __proto__: null, get() {
      return this[S] !== false;
    }, set(u) {
      this[S] = !!u;
    } } }), t._fromList = E$;
    function E$(u, i) {
      if (i.length === 0) return null;
      let K$;
      if (i.objectMode) K$ = i.buffer.shift();
      else if (!u || u >= i.length) {
        if (i.decoder) K$ = i.buffer.join("");
        else if (i.buffer.length === 1) K$ = i.buffer.first();
        else K$ = i.buffer.concat(i.length);
        i.buffer.clear();
      } else K$ = i.buffer.consume(u, i.decoder);
      return K$;
    }
    function vq(u) {
      let i = u._readableState;
      if (y("endReadable", i.endEmitted), !i.endEmitted) i.ended = true, K.nextTick(b$, i, u);
    }
    function b$(u, i) {
      if (y("endReadableNT", u.endEmitted, u.length), !u.errored && !u.closeEmitted && !u.endEmitted && u.length === 0) {
        if (u.endEmitted = true, i.emit("end"), i.writable && i.allowHalfOpen === false) K.nextTick(y$, i);
        else if (u.autoDestroy) {
          let K$ = i._writableState;
          if (!K$ || K$.autoDestroy && (K$.finished || K$.writable === false)) i.destroy();
        }
      }
    }
    function y$(u) {
      if (u.writable && !u.writableEnded && !u.destroyed) u.end();
    }
    t.from = function(u, i) {
      return v(t, u, i);
    };
    var zq;
    function h$() {
      if (zq === void 0) zq = {};
      return zq;
    }
    t.fromWeb = function(u, i) {
      return h$().newStreamReadableFromReadableStream(u, i);
    }, t.toWeb = function(u, i) {
      return h$().newReadableStreamFromStreamReadable(u, i);
    }, t.wrap = function(u, i) {
      var K$, P$;
      return new t({ objectMode: (K$ = (P$ = u.readableObjectMode) !== null && P$ !== void 0 ? P$ : u.objectMode) !== null && K$ !== void 0 ? K$ : true, ...i, destroy(i$, k$) {
        n.destroyer(u, i$), k$(i$);
      } }).wrap(u);
    };
  }), xH = V6(($18, q) => {
    var K = y_(), { ArrayPrototypeSlice: P, Error: _, FunctionPrototypeSymbolHasInstance: Y, ObjectDefineProperty: O, ObjectDefineProperties: z, ObjectSetPrototypeOf: J, StringPrototypeToLowerCase: T, Symbol: X, SymbolHasInstance: f } = u6();
    q.exports = G, G.WritableState = W;
    var { EventEmitter: V } = (o7(), J6(r7)), M = uH().Stream, { Buffer: N } = (wq(), J6(Tq)), h = c4(), { addAbortSignal: E } = qO(), { getHighWaterMark: I, getDefaultHighWaterMark: D } = KO(), { ERR_INVALID_ARG_TYPE: g, ERR_METHOD_NOT_IMPLEMENTED: b, ERR_MULTIPLE_CALLBACK: y, ERR_STREAM_CANNOT_PIPE: p, ERR_STREAM_DESTROYED: n, ERR_STREAM_ALREADY_FINISHED: s, ERR_STREAM_NULL_VALUES: q$, ERR_STREAM_WRITE_AFTER_END: c, ERR_UNKNOWN_ENCODING: U } = cq().codes, { errorOrDestroy: j } = h;
    J(G.prototype, M.prototype), J(G, M);
    function H() {
    }
    var Z = X("kOnFinished");
    function W(m, r, J$) {
      if (typeof J$ !== "boolean") J$ = r instanceof VK();
      if (this.objectMode = !!(m && m.objectMode), J$) this.objectMode = this.objectMode || !!(m && m.writableObjectMode);
      this.highWaterMark = m ? I(this, m, "writableHighWaterMark", J$) : D(false), this.finalCalled = false, this.needDrain = false, this.ending = false, this.ended = false, this.finished = false, this.destroyed = false;
      let e = !!(m && m.decodeStrings === false);
      this.decodeStrings = !e, this.defaultEncoding = m && m.defaultEncoding || "utf8", this.length = 0, this.writing = false, this.corked = 0, this.sync = true, this.bufferProcessing = false, this.onwrite = R.bind(void 0, r), this.writecb = null, this.writelen = 0, this.afterWriteTickInfo = null, w(this), this.pendingcb = 0, this.constructed = true, this.prefinished = false, this.errorEmitted = false, this.emitClose = !m || m.emitClose !== false, this.autoDestroy = !m || m.autoDestroy !== false, this.errored = null, this.closed = false, this.closeEmitted = false, this[Z] = [];
    }
    function w(m) {
      m.buffered = [], m.bufferedIndex = 0, m.allBuffers = true, m.allNoop = true;
    }
    W.prototype.getBuffer = function() {
      return P(this.buffered, this.bufferedIndex);
    }, O(W.prototype, "bufferedRequestCount", { __proto__: null, get() {
      return this.buffered.length - this.bufferedIndex;
    } });
    function G(m) {
      let r = this instanceof VK();
      if (!r && !Y(G, this)) return new G(m);
      if (this._writableState = new W(m, this, r), m) {
        if (typeof m.write === "function") this._write = m.write;
        if (typeof m.writev === "function") this._writev = m.writev;
        if (typeof m.destroy === "function") this._destroy = m.destroy;
        if (typeof m.final === "function") this._final = m.final;
        if (typeof m.construct === "function") this._construct = m.construct;
        if (m.signal) E(m.signal, this);
      }
      M.call(this, m), h.construct(this, () => {
        let J$ = this._writableState;
        if (!J$.writing) l(this, J$);
        B(this, J$);
      });
    }
    O(G, f, { __proto__: null, value: function(m) {
      if (Y(this, m)) return true;
      if (this !== G) return false;
      return m && m._writableState instanceof W;
    } }), G.prototype.pipe = function() {
      j(this, new p());
    };
    function S(m, r, J$, e) {
      let _$2 = m._writableState;
      if (typeof J$ === "function") e = J$, J$ = _$2.defaultEncoding;
      else {
        if (!J$) J$ = _$2.defaultEncoding;
        else if (J$ !== "buffer" && !N.isEncoding(J$)) throw new U(J$);
        if (typeof e !== "function") e = H;
      }
      if (r === null) throw new q$();
      else if (!_$2.objectMode) if (typeof r === "string") {
        if (_$2.decodeStrings !== false) r = N.from(r, J$), J$ = "buffer";
      } else if (r instanceof N) J$ = "buffer";
      else if (M._isUint8Array(r)) r = M._uint8ArrayToBuffer(r), J$ = "buffer";
      else throw new g("chunk", ["string", "Buffer", "Uint8Array"], r);
      let Y$;
      if (_$2.ending) Y$ = new c();
      else if (_$2.destroyed) Y$ = new n("write");
      if (Y$) return K.nextTick(e, Y$), j(m, Y$, true), Y$;
      return _$2.pendingcb++, A(m, _$2, r, J$, e);
    }
    G.prototype.write = function(m, r, J$) {
      return S(this, m, r, J$) === true;
    }, G.prototype.cork = function() {
      this._writableState.corked++;
    }, G.prototype.uncork = function() {
      let m = this._writableState;
      if (m.corked) {
        if (m.corked--, !m.writing) l(this, m);
      }
    }, G.prototype.setDefaultEncoding = function(m) {
      if (typeof m === "string") m = T(m);
      if (!N.isEncoding(m)) throw new U(m);
      return this._writableState.defaultEncoding = m, this;
    };
    function A(m, r, J$, e, _$2) {
      let Y$ = r.objectMode ? 1 : J$.length;
      r.length += Y$;
      let d = r.length < r.highWaterMark;
      if (!d) r.needDrain = true;
      if (r.writing || r.corked || r.errored || !r.constructed) {
        if (r.buffered.push({ chunk: J$, encoding: e, callback: _$2 }), r.allBuffers && e !== "buffer") r.allBuffers = false;
        if (r.allNoop && _$2 !== H) r.allNoop = false;
      } else r.writelen = Y$, r.writecb = _$2, r.writing = true, r.sync = true, m._write(J$, e, r.onwrite), r.sync = false;
      return d && !r.errored && !r.destroyed;
    }
    function v(m, r, J$, e, _$2, Y$, d) {
      if (r.writelen = e, r.writecb = d, r.writing = true, r.sync = true, r.destroyed) r.onwrite(new n("write"));
      else if (J$) m._writev(_$2, r.onwrite);
      else m._write(_$2, Y$, r.onwrite);
      r.sync = false;
    }
    function k(m, r, J$, e) {
      --r.pendingcb, e(J$), x(r), j(m, J$);
    }
    function R(m, r) {
      let J$ = m._writableState, e = J$.sync, _$2 = J$.writecb;
      if (typeof _$2 !== "function") {
        j(m, new y());
        return;
      }
      if (J$.writing = false, J$.writecb = null, J$.length -= J$.writelen, J$.writelen = 0, r) {
        if (r.stack, !J$.errored) J$.errored = r;
        if (m._readableState && !m._readableState.errored) m._readableState.errored = r;
        if (e) K.nextTick(k, m, J$, r, _$2);
        else k(m, J$, r, _$2);
      } else {
        if (J$.buffered.length > J$.bufferedIndex) l(m, J$);
        if (e) if (J$.afterWriteTickInfo !== null && J$.afterWriteTickInfo.cb === _$2) J$.afterWriteTickInfo.count++;
        else J$.afterWriteTickInfo = { count: 1, cb: _$2, stream: m, state: J$ }, K.nextTick(C, J$.afterWriteTickInfo);
        else L(m, J$, 1, _$2);
      }
    }
    function C({ stream: m, state: r, count: J$, cb: e }) {
      return r.afterWriteTickInfo = null, L(m, r, J$, e);
    }
    function L(m, r, J$, e) {
      if (!r.ending && !m.destroyed && r.length === 0 && r.needDrain) r.needDrain = false, m.emit("drain");
      while (J$-- > 0) r.pendingcb--, e();
      if (r.destroyed) x(r);
      B(m, r);
    }
    function x(m) {
      if (m.writing) return;
      for (let _$2 = m.bufferedIndex; _$2 < m.buffered.length; ++_$2) {
        var r;
        let { chunk: Y$, callback: d } = m.buffered[_$2], o = m.objectMode ? 1 : Y$.length;
        m.length -= o, d((r = m.errored) !== null && r !== void 0 ? r : new n("write"));
      }
      let J$ = m[Z].splice(0);
      for (let _$2 = 0; _$2 < J$.length; _$2++) {
        var e;
        J$[_$2]((e = m.errored) !== null && e !== void 0 ? e : new n("end"));
      }
      w(m);
    }
    function l(m, r) {
      if (r.corked || r.bufferProcessing || r.destroyed || !r.constructed) return;
      let { buffered: J$, bufferedIndex: e, objectMode: _$2 } = r, Y$ = J$.length - e;
      if (!Y$) return;
      let d = e;
      if (r.bufferProcessing = true, Y$ > 1 && m._writev) {
        r.pendingcb -= Y$ - 1;
        let o = r.allNoop ? H : (t) => {
          for (let F = d; F < J$.length; ++F) J$[F].callback(t);
        }, W$ = r.allNoop && d === 0 ? J$ : P(J$, d);
        W$.allBuffers = r.allBuffers, v(m, r, true, r.length, W$, "", o), w(r);
      } else {
        do {
          let { chunk: o, encoding: W$, callback: t } = J$[d];
          J$[d++] = null;
          let F = _$2 ? 1 : o.length;
          v(m, r, false, F, o, W$, t);
        } while (d < J$.length && !r.writing);
        if (d === J$.length) w(r);
        else if (d > 256) J$.splice(0, d), r.bufferedIndex = 0;
        else r.bufferedIndex = d;
      }
      r.bufferProcessing = false;
    }
    G.prototype._write = function(m, r, J$) {
      if (this._writev) this._writev([{ chunk: m, encoding: r }], J$);
      else throw new b("_write()");
    }, G.prototype._writev = null, G.prototype.end = function(m, r, J$) {
      let e = this._writableState;
      if (typeof m === "function") J$ = m, m = null, r = null;
      else if (typeof r === "function") J$ = r, r = null;
      let _$2;
      if (m !== null && m !== void 0) {
        let Y$ = S(this, m, r);
        if (Y$ instanceof _) _$2 = Y$;
      }
      if (e.corked) e.corked = 1, this.uncork();
      if (_$2) ;
      else if (!e.errored && !e.ending) e.ending = true, B(this, e, true), e.ended = true;
      else if (e.finished) _$2 = new s("end");
      else if (e.destroyed) _$2 = new n("end");
      if (typeof J$ === "function") if (_$2 || e.finished) K.nextTick(J$, _$2);
      else e[Z].push(J$);
      return this;
    };
    function a(m) {
      return m.ending && !m.destroyed && m.constructed && m.length === 0 && !m.errored && m.buffered.length === 0 && !m.finished && !m.writing && !m.errorEmitted && !m.closeEmitted;
    }
    function f$(m, r) {
      let J$ = false;
      function e(_$2) {
        if (J$) {
          j(m, _$2 !== null && _$2 !== void 0 ? _$2 : y());
          return;
        }
        if (J$ = true, r.pendingcb--, _$2) {
          let Y$ = r[Z].splice(0);
          for (let d = 0; d < Y$.length; d++) Y$[d](_$2);
          j(m, _$2, r.sync);
        } else if (a(r)) r.prefinished = true, m.emit("prefinish"), r.pendingcb++, K.nextTick(H$, m, r);
      }
      r.sync = true, r.pendingcb++;
      try {
        m._final(e);
      } catch (_$2) {
        e(_$2);
      }
      r.sync = false;
    }
    function $$(m, r) {
      if (!r.prefinished && !r.finalCalled) if (typeof m._final === "function" && !r.destroyed) r.finalCalled = true, f$(m, r);
      else r.prefinished = true, m.emit("prefinish");
    }
    function B(m, r, J$) {
      if (a(r)) {
        if ($$(m, r), r.pendingcb === 0) {
          if (J$) r.pendingcb++, K.nextTick((e, _$2) => {
            if (a(_$2)) H$(e, _$2);
            else _$2.pendingcb--;
          }, m, r);
          else if (a(r)) r.pendingcb++, H$(m, r);
        }
      }
    }
    function H$(m, r) {
      r.pendingcb--, r.finished = true;
      let J$ = r[Z].splice(0);
      for (let e = 0; e < J$.length; e++) J$[e]();
      if (m.emit("finish"), r.autoDestroy) {
        let e = m._readableState;
        if (!e || e.autoDestroy && (e.endEmitted || e.readable === false)) m.destroy();
      }
    }
    z(G.prototype, { closed: { __proto__: null, get() {
      return this._writableState ? this._writableState.closed : false;
    } }, destroyed: { __proto__: null, get() {
      return this._writableState ? this._writableState.destroyed : false;
    }, set(m) {
      if (this._writableState) this._writableState.destroyed = m;
    } }, writable: { __proto__: null, get() {
      let m = this._writableState;
      return !!m && m.writable !== false && !m.destroyed && !m.errored && !m.ending && !m.ended;
    }, set(m) {
      if (this._writableState) this._writableState.writable = !!m;
    } }, writableFinished: { __proto__: null, get() {
      return this._writableState ? this._writableState.finished : false;
    } }, writableObjectMode: { __proto__: null, get() {
      return this._writableState ? this._writableState.objectMode : false;
    } }, writableBuffer: { __proto__: null, get() {
      return this._writableState && this._writableState.getBuffer();
    } }, writableEnded: { __proto__: null, get() {
      return this._writableState ? this._writableState.ending : false;
    } }, writableNeedDrain: { __proto__: null, get() {
      let m = this._writableState;
      if (!m) return false;
      return !m.destroyed && !m.ending && m.needDrain;
    } }, writableHighWaterMark: { __proto__: null, get() {
      return this._writableState && this._writableState.highWaterMark;
    } }, writableCorked: { __proto__: null, get() {
      return this._writableState ? this._writableState.corked : 0;
    } }, writableLength: { __proto__: null, get() {
      return this._writableState && this._writableState.length;
    } }, errored: { __proto__: null, enumerable: false, get() {
      return this._writableState ? this._writableState.errored : null;
    } }, writableAborted: { __proto__: null, enumerable: false, get: function() {
      return !!(this._writableState.writable !== false && (this._writableState.destroyed || this._writableState.errored) && !this._writableState.finished);
    } } });
    var Q = h.destroy;
    G.prototype.destroy = function(m, r) {
      let J$ = this._writableState;
      if (!J$.destroyed && (J$.bufferedIndex < J$.buffered.length || J$[Z].length)) K.nextTick(x, J$);
      return Q.call(this, m, r), this;
    }, G.prototype._undestroy = h.undestroy, G.prototype._destroy = function(m, r) {
      r(m);
    }, G.prototype[V.captureRejectionSymbol] = function(m) {
      this.destroy(m);
    };
    var v$;
    function t$() {
      if (v$ === void 0) v$ = {};
      return v$;
    }
    G.fromWeb = function(m, r) {
      return t$().newStreamWritableFromWritableStream(m, r);
    }, G.toWeb = function(m) {
      return t$().newWritableStreamFromStreamWritable(m);
    };
  }), hr = V6(($18, q) => {
    var K = y_(), P = (wq(), J6(Tq)), { isReadable: _, isWritable: Y, isIterable: O, isNodeStream: z, isReadableNodeStream: J, isWritableNodeStream: T, isDuplexNodeStream: X, isReadableStream: f, isWritableStream: V } = SK(), M = sK(), { AbortError: N, codes: { ERR_INVALID_ARG_TYPE: h, ERR_INVALID_RETURN_VALUE: E } } = cq(), { destroyer: I } = c4(), D = VK(), g = _O(), b = xH(), { createDeferredPromise: y } = sq(), p = nS(), n = globalThis.Blob || P.Blob, s = typeof n < "u" ? function(Z) {
      return Z instanceof n;
    } : function(Z) {
      return false;
    }, q$ = globalThis.AbortController || n7().AbortController, { FunctionPrototypeCall: c } = u6();
    class U extends D {
      constructor(Z) {
        super(Z);
        if ((Z === null || Z === void 0 ? void 0 : Z.readable) === false) this._readableState.readable = false, this._readableState.ended = true, this._readableState.endEmitted = true;
        if ((Z === null || Z === void 0 ? void 0 : Z.writable) === false) this._writableState.writable = false, this._writableState.ending = true, this._writableState.ended = true, this._writableState.finished = true;
      }
    }
    q.exports = function Z(W, w) {
      if (X(W)) return W;
      if (J(W)) return H({ readable: W });
      if (T(W)) return H({ writable: W });
      if (z(W)) return H({ writable: false, readable: false });
      if (f(W)) return H({ readable: g.fromWeb(W) });
      if (V(W)) return H({ writable: b.fromWeb(W) });
      if (typeof W === "function") {
        let { value: S, write: A, final: v, destroy: k } = j(W);
        if (O(S)) return p(U, S, { objectMode: true, write: A, final: v, destroy: k });
        let R = S === null || S === void 0 ? void 0 : S.then;
        if (typeof R === "function") {
          let C, L = c(R, S, (x) => {
            if (x != null) throw new E("nully", "body", x);
          }, (x) => {
            I(C, x);
          });
          return C = new U({ objectMode: true, readable: false, write: A, final(x) {
            v(async () => {
              try {
                await L, K.nextTick(x, null);
              } catch (l) {
                K.nextTick(x, l);
              }
            });
          }, destroy: k });
        }
        throw new E("Iterable, AsyncIterable or AsyncFunction", w, S);
      }
      if (s(W)) return Z(W.arrayBuffer());
      if (O(W)) return p(U, W, { objectMode: true, writable: false });
      if (f(W === null || W === void 0 ? void 0 : W.readable) && V(W === null || W === void 0 ? void 0 : W.writable)) return U.fromWeb(W);
      if (typeof (W === null || W === void 0 ? void 0 : W.writable) === "object" || typeof (W === null || W === void 0 ? void 0 : W.readable) === "object") {
        let S = W !== null && W !== void 0 && W.readable ? J(W === null || W === void 0 ? void 0 : W.readable) ? W === null || W === void 0 ? void 0 : W.readable : Z(W.readable) : void 0, A = W !== null && W !== void 0 && W.writable ? T(W === null || W === void 0 ? void 0 : W.writable) ? W === null || W === void 0 ? void 0 : W.writable : Z(W.writable) : void 0;
        return H({ readable: S, writable: A });
      }
      let G = W === null || W === void 0 ? void 0 : W.then;
      if (typeof G === "function") {
        let S;
        return c(G, W, (A) => {
          if (A != null) S.push(A);
          S.push(null);
        }, (A) => {
          I(S, A);
        }), S = new U({ objectMode: true, writable: false, read() {
        } });
      }
      throw new h(w, ["Blob", "ReadableStream", "WritableStream", "Stream", "Iterable", "AsyncIterable", "Function", "{ readable, writable } pair", "Promise"], W);
    };
    function j(Z) {
      let { promise: W, resolve: w } = y(), G = new q$(), S = G.signal;
      return { value: Z(async function* () {
        while (true) {
          let A = W;
          W = null;
          let { chunk: v, done: k, cb: R } = await A;
          if (K.nextTick(R), k) return;
          if (S.aborted) throw new N(void 0, { cause: S.reason });
          ({ promise: W, resolve: w } = y()), yield v;
        }
      }(), { signal: S }), write(A, v, k) {
        let R = w;
        w = null, R({ chunk: A, done: false, cb: k });
      }, final(A) {
        let v = w;
        w = null, v({ done: true, cb: A });
      }, destroy(A, v) {
        G.abort(), v(A);
      } };
    }
    function H(Z) {
      let W = Z.readable && typeof Z.readable.read !== "function" ? g.wrap(Z.readable) : Z.readable, w = Z.writable, G = !!_(W), S = !!Y(w), A, v, k, R, C;
      function L(x) {
        let l = R;
        if (R = null, l) l(x);
        else if (x) C.destroy(x);
      }
      if (C = new U({ readableObjectMode: !!(W !== null && W !== void 0 && W.readableObjectMode), writableObjectMode: !!(w !== null && w !== void 0 && w.writableObjectMode), readable: G, writable: S }), S) M(w, (x) => {
        if (S = false, x) I(W, x);
        L(x);
      }), C._write = function(x, l, a) {
        if (w.write(x, l)) a();
        else A = a;
      }, C._final = function(x) {
        w.end(), v = x;
      }, w.on("drain", function() {
        if (A) {
          let x = A;
          A = null, x();
        }
      }), w.on("finish", function() {
        if (v) {
          let x = v;
          v = null, x();
        }
      });
      if (G) M(W, (x) => {
        if (G = false, x) I(W, x);
        L(x);
      }), W.on("readable", function() {
        if (k) {
          let x = k;
          k = null, x();
        }
      }), W.on("end", function() {
        C.push(null);
      }), C._read = function() {
        while (true) {
          let x = W.read();
          if (x === null) {
            k = C._read;
            return;
          }
          if (!C.push(x)) return;
        }
      };
      return C._destroy = function(x, l) {
        if (!x && R !== null) x = new N();
        if (k = null, A = null, v = null, R === null) l(x);
        else R = l, I(w, x), I(W, x);
      }, C;
    }
  }), VK = V6(($18, q) => {
    var { ObjectDefineProperties: K, ObjectGetOwnPropertyDescriptor: P, ObjectKeys: _, ObjectSetPrototypeOf: Y } = u6();
    q.exports = J;
    var O = _O(), z = xH();
    Y(J.prototype, O.prototype), Y(J, O);
    {
      let V = _(z.prototype);
      for (let M = 0; M < V.length; M++) {
        let N = V[M];
        if (!J.prototype[N]) J.prototype[N] = z.prototype[N];
      }
    }
    function J(V) {
      if (!(this instanceof J)) return new J(V);
      if (O.call(this, V), z.call(this, V), V) {
        if (this.allowHalfOpen = V.allowHalfOpen !== false, V.readable === false) this._readableState.readable = false, this._readableState.ended = true, this._readableState.endEmitted = true;
        if (V.writable === false) this._writableState.writable = false, this._writableState.ending = true, this._writableState.ended = true, this._writableState.finished = true;
      } else this.allowHalfOpen = true;
    }
    K(J.prototype, { writable: { __proto__: null, ...P(z.prototype, "writable") }, writableHighWaterMark: { __proto__: null, ...P(z.prototype, "writableHighWaterMark") }, writableObjectMode: { __proto__: null, ...P(z.prototype, "writableObjectMode") }, writableBuffer: { __proto__: null, ...P(z.prototype, "writableBuffer") }, writableLength: { __proto__: null, ...P(z.prototype, "writableLength") }, writableFinished: { __proto__: null, ...P(z.prototype, "writableFinished") }, writableCorked: { __proto__: null, ...P(z.prototype, "writableCorked") }, writableEnded: { __proto__: null, ...P(z.prototype, "writableEnded") }, writableNeedDrain: { __proto__: null, ...P(z.prototype, "writableNeedDrain") }, destroyed: { __proto__: null, get() {
      if (this._readableState === void 0 || this._writableState === void 0) return false;
      return this._readableState.destroyed && this._writableState.destroyed;
    }, set(V) {
      if (this._readableState && this._writableState) this._readableState.destroyed = V, this._writableState.destroyed = V;
    } } });
    var T;
    function X() {
      if (T === void 0) T = {};
      return T;
    }
    J.fromWeb = function(V, M) {
      return X().newStreamDuplexFromReadableWritablePair(V, M);
    }, J.toWeb = function(V) {
      return X().newReadableWritablePairFromDuplex(V);
    };
    var f;
    J.from = function(V) {
      if (!f) f = hr();
      return f(V, "body");
    };
  }), iS = V6(($18, q) => {
    var { ObjectSetPrototypeOf: K, Symbol: P } = u6();
    q.exports = J;
    var { ERR_METHOD_NOT_IMPLEMENTED: _ } = cq().codes, Y = VK(), { getHighWaterMark: O } = KO();
    K(J.prototype, Y.prototype), K(J, Y);
    var z = P("kCallback");
    function J(f) {
      if (!(this instanceof J)) return new J(f);
      let V = f ? O(this, f, "readableHighWaterMark", true) : null;
      if (V === 0) f = { ...f, highWaterMark: null, readableHighWaterMark: V, writableHighWaterMark: f.writableHighWaterMark || 0 };
      if (Y.call(this, f), this._readableState.sync = false, this[z] = null, f) {
        if (typeof f.transform === "function") this._transform = f.transform;
        if (typeof f.flush === "function") this._flush = f.flush;
      }
      this.on("prefinish", X);
    }
    function T(f) {
      if (typeof this._flush === "function" && !this.destroyed) this._flush((V, M) => {
        if (V) {
          if (f) f(V);
          else this.destroy(V);
          return;
        }
        if (M != null) this.push(M);
        if (this.push(null), f) f();
      });
      else if (this.push(null), f) f();
    }
    function X() {
      if (this._final !== T) T.call(this);
    }
    J.prototype._final = T, J.prototype._transform = function(f, V, M) {
      throw new _("_transform()");
    }, J.prototype._write = function(f, V, M) {
      let N = this._readableState, h = this._writableState, E = N.length;
      this._transform(f, V, (I, D) => {
        if (I) {
          M(I);
          return;
        }
        if (D != null) this.push(D);
        if (h.ended || E === N.length || N.length < N.highWaterMark) M();
        else this[z] = M;
      });
    }, J.prototype._read = function() {
      if (this[z]) {
        let f = this[z];
        this[z] = null, f();
      }
    };
  }), BS = V6(($18, q) => {
    var { ObjectSetPrototypeOf: K } = u6();
    q.exports = _;
    var P = iS();
    K(_.prototype, P.prototype), K(_, P);
    function _(Y) {
      if (!(this instanceof _)) return new _(Y);
      P.call(this, Y);
    }
    _.prototype._transform = function(Y, O, z) {
      z(null, Y);
    };
  }), pH = V6(($18, q) => {
    var K = y_(), { ArrayIsArray: P, Promise: _, SymbolAsyncIterator: Y, SymbolDispose: O } = u6(), z = sK(), { once: J } = sq(), T = c4(), X = VK(), { aggregateTwoErrors: f, codes: { ERR_INVALID_ARG_TYPE: V, ERR_INVALID_RETURN_VALUE: M, ERR_MISSING_ARGS: N, ERR_STREAM_DESTROYED: h, ERR_STREAM_PREMATURE_CLOSE: E }, AbortError: I } = cq(), { validateFunction: D, validateAbortSignal: g } = i7(), { isIterable: b, isReadable: y, isReadableNodeStream: p, isNodeStream: n, isTransformStream: s, isWebStream: q$, isReadableStream: c, isReadableFinished: U } = SK(), j = globalThis.AbortController || n7().AbortController, H, Z, W;
    function w(x, l, a) {
      let f$ = false;
      x.on("close", () => {
        f$ = true;
      });
      let $$ = z(x, { readable: l, writable: a }, (B) => {
        f$ = !B;
      });
      return { destroy: (B) => {
        if (f$) return;
        f$ = true, T.destroyer(x, B || new h("pipe"));
      }, cleanup: $$ };
    }
    function G(x) {
      return D(x[x.length - 1], "streams[stream.length - 1]"), x.pop();
    }
    function S(x) {
      if (b(x)) return x;
      else if (p(x)) return A(x);
      throw new V("val", ["Readable", "Iterable", "AsyncIterable"], x);
    }
    async function* A(x) {
      if (!Z) Z = _O();
      yield* Z.prototype[Y].call(x);
    }
    async function v(x, l, a, { end: f$ }) {
      let $$, B = null, H$ = (t$) => {
        if (t$) $$ = t$;
        if (B) {
          let m = B;
          B = null, m();
        }
      }, Q = () => new _((t$, m) => {
        if ($$) m($$);
        else B = () => {
          if ($$) m($$);
          else t$();
        };
      });
      l.on("drain", H$);
      let v$ = z(l, { readable: false }, H$);
      try {
        if (l.writableNeedDrain) await Q();
        for await (let t$ of x) if (!l.write(t$)) await Q();
        if (f$) l.end(), await Q();
        a();
      } catch (t$) {
        a($$ !== t$ ? f($$, t$) : t$);
      } finally {
        v$(), l.off("drain", H$);
      }
    }
    async function k(x, l, a, { end: f$ }) {
      if (s(l)) l = l.writable;
      let $$ = l.getWriter();
      try {
        for await (let B of x) await $$.ready, $$.write(B).catch(() => {
        });
        if (await $$.ready, f$) await $$.close();
        a();
      } catch (B) {
        try {
          await $$.abort(B), a(B);
        } catch (H$) {
          a(H$);
        }
      }
    }
    function R(...x) {
      return C(x, J(G(x)));
    }
    function C(x, l, a) {
      if (x.length === 1 && P(x[0])) x = x[0];
      if (x.length < 2) throw new N("streams");
      let f$ = new j(), $$ = f$.signal, B = a === null || a === void 0 ? void 0 : a.signal, H$ = [];
      g(B, "options.signal");
      function Q() {
        _$2(new I());
      }
      W = W || sq().addAbortListener;
      let v$;
      if (B) v$ = W(B, Q);
      let t$, m, r = [], J$ = 0;
      function e(t) {
        _$2(t, --J$ === 0);
      }
      function _$2(t, F) {
        var X$;
        if (t && (!t$ || t$.code === "ERR_STREAM_PREMATURE_CLOSE")) t$ = t;
        if (!t$ && !F) return;
        while (r.length) r.shift()(t$);
        if ((X$ = v$) === null || X$ === void 0 || X$[O](), f$.abort(), F) {
          if (!t$) H$.forEach((z$) => z$());
          K.nextTick(l, t$, m);
        }
      }
      let Y$;
      for (let t = 0; t < x.length; t++) {
        let F = x[t], X$ = t < x.length - 1, z$ = t > 0, j$ = X$ || (a === null || a === void 0 ? void 0 : a.end) !== false, X6 = t === x.length - 1;
        if (n(F)) {
          let Z$ = function(A$) {
            if (A$ && A$.name !== "AbortError" && A$.code !== "ERR_STREAM_PREMATURE_CLOSE") e(A$);
          };
          var d = Z$;
          if (j$) {
            let { destroy: A$, cleanup: d6 } = w(F, X$, z$);
            if (r.push(A$), y(F) && X6) H$.push(d6);
          }
          if (F.on("error", Z$), y(F) && X6) H$.push(() => {
            F.removeListener("error", Z$);
          });
        }
        if (t === 0) if (typeof F === "function") {
          if (Y$ = F({ signal: $$ }), !b(Y$)) throw new M("Iterable, AsyncIterable or Stream", "source", Y$);
        } else if (b(F) || p(F) || s(F)) Y$ = F;
        else Y$ = X.from(F);
        else if (typeof F === "function") {
          if (s(Y$)) {
            var o;
            Y$ = S((o = Y$) === null || o === void 0 ? void 0 : o.readable);
          } else Y$ = S(Y$);
          if (Y$ = F(Y$, { signal: $$ }), X$) {
            if (!b(Y$, true)) throw new M("AsyncIterable", `transform[${t - 1}]`, Y$);
          } else {
            var W$;
            if (!H) H = BS();
            let Z$ = new H({ objectMode: true }), A$ = (W$ = Y$) === null || W$ === void 0 ? void 0 : W$.then;
            if (typeof A$ === "function") J$++, A$.call(Y$, (V$) => {
              if (m = V$, V$ != null) Z$.write(V$);
              if (j$) Z$.end();
              K.nextTick(e);
            }, (V$) => {
              Z$.destroy(V$), K.nextTick(e, V$);
            });
            else if (b(Y$, true)) J$++, v(Y$, Z$, e, { end: j$ });
            else if (c(Y$) || s(Y$)) {
              let V$ = Y$.readable || Y$;
              J$++, v(V$, Z$, e, { end: j$ });
            } else throw new M("AsyncIterable or Promise", "destination", Y$);
            Y$ = Z$;
            let { destroy: d6, cleanup: S$ } = w(Y$, false, true);
            if (r.push(d6), X6) H$.push(S$);
          }
        } else if (n(F)) {
          if (p(Y$)) {
            J$ += 2;
            let Z$ = L(Y$, F, e, { end: j$ });
            if (y(F) && X6) H$.push(Z$);
          } else if (s(Y$) || c(Y$)) {
            let Z$ = Y$.readable || Y$;
            J$++, v(Z$, F, e, { end: j$ });
          } else if (b(Y$)) J$++, v(Y$, F, e, { end: j$ });
          else throw new V("val", ["Readable", "Iterable", "AsyncIterable", "ReadableStream", "TransformStream"], Y$);
          Y$ = F;
        } else if (q$(F)) {
          if (p(Y$)) J$++, k(S(Y$), F, e, { end: j$ });
          else if (c(Y$) || b(Y$)) J$++, k(Y$, F, e, { end: j$ });
          else if (s(Y$)) J$++, k(Y$.readable, F, e, { end: j$ });
          else throw new V("val", ["Readable", "Iterable", "AsyncIterable", "ReadableStream", "TransformStream"], Y$);
          Y$ = F;
        } else Y$ = X.from(F);
      }
      if ($$ !== null && $$ !== void 0 && $$.aborted || B !== null && B !== void 0 && B.aborted) K.nextTick(Q);
      return Y$;
    }
    function L(x, l, a, { end: f$ }) {
      let $$ = false;
      if (l.on("close", () => {
        if (!$$) a(new E());
      }), x.pipe(l, { end: false }), f$) {
        let H$ = function() {
          $$ = true, l.end();
        };
        var B = H$;
        if (U(x)) K.nextTick(H$);
        else x.once("end", H$);
      } else a();
      return z(x, { readable: true, writable: false }, (H$) => {
        let Q = x._readableState;
        if (H$ && H$.code === "ERR_STREAM_PREMATURE_CLOSE" && Q && Q.ended && !Q.errored && !Q.errorEmitted) x.once("end", a).once("error", a);
        else a(H$);
      }), z(l, { readable: false, writable: true }, a);
    }
    q.exports = { pipelineImpl: C, pipeline: R };
  }), tS = V6(($18, q) => {
    var { pipeline: K } = pH(), P = VK(), { destroyer: _ } = c4(), { isNodeStream: Y, isReadable: O, isWritable: z, isWebStream: J, isTransformStream: T, isWritableStream: X, isReadableStream: f } = SK(), { AbortError: V, codes: { ERR_INVALID_ARG_VALUE: M, ERR_MISSING_ARGS: N } } = cq(), h = sK();
    q.exports = function(...E) {
      if (E.length === 0) throw new N("streams");
      if (E.length === 1) return P.from(E[0]);
      let I = [...E];
      if (typeof E[0] === "function") E[0] = P.from(E[0]);
      if (typeof E[E.length - 1] === "function") {
        let j = E.length - 1;
        E[j] = P.from(E[j]);
      }
      for (let j = 0; j < E.length; ++j) {
        if (!Y(E[j]) && !J(E[j])) continue;
        if (j < E.length - 1 && !(O(E[j]) || f(E[j]) || T(E[j]))) throw new M(`streams[${j}]`, I[j], "must be readable");
        if (j > 0 && !(z(E[j]) || X(E[j]) || T(E[j]))) throw new M(`streams[${j}]`, I[j], "must be writable");
      }
      let D, g, b, y, p;
      function n(j) {
        let H = y;
        if (y = null, H) H(j);
        else if (j) p.destroy(j);
        else if (!U && !c) p.destroy();
      }
      let s = E[0], q$ = K(E, n), c = !!(z(s) || X(s) || T(s)), U = !!(O(q$) || f(q$) || T(q$));
      if (p = new P({ writableObjectMode: !!(s !== null && s !== void 0 && s.writableObjectMode), readableObjectMode: !!(q$ !== null && q$ !== void 0 && q$.readableObjectMode), writable: c, readable: U }), c) {
        if (Y(s)) p._write = function(H, Z, W) {
          if (s.write(H, Z)) W();
          else D = W;
        }, p._final = function(H) {
          s.end(), g = H;
        }, s.on("drain", function() {
          if (D) {
            let H = D;
            D = null, H();
          }
        });
        else if (J(s)) {
          let H = (T(s) ? s.writable : s).getWriter();
          p._write = async function(Z, W, w) {
            try {
              await H.ready, H.write(Z).catch(() => {
              }), w();
            } catch (G) {
              w(G);
            }
          }, p._final = async function(Z) {
            try {
              await H.ready, H.close().catch(() => {
              }), g = Z;
            } catch (W) {
              Z(W);
            }
          };
        }
        let j = T(q$) ? q$.readable : q$;
        h(j, () => {
          if (g) {
            let H = g;
            g = null, H();
          }
        });
      }
      if (U) {
        if (Y(q$)) q$.on("readable", function() {
          if (b) {
            let j = b;
            b = null, j();
          }
        }), q$.on("end", function() {
          p.push(null);
        }), p._read = function() {
          while (true) {
            let j = q$.read();
            if (j === null) {
              b = p._read;
              return;
            }
            if (!p.push(j)) return;
          }
        };
        else if (J(q$)) {
          let j = (T(q$) ? q$.readable : q$).getReader();
          p._read = async function() {
            while (true) try {
              let { value: H, done: Z } = await j.read();
              if (!p.push(H)) return;
              if (Z) {
                p.push(null);
                return;
              }
            } catch {
              return;
            }
          };
        }
      }
      return p._destroy = function(j, H) {
        if (!j && y !== null) j = new V();
        if (b = null, D = null, g = null, y === null) H(j);
        else if (y = H, Y(q$)) _(q$, j);
      }, p;
    };
  }), Rr = V6(($18, q) => {
    var K = globalThis.AbortController || n7().AbortController, { codes: { ERR_INVALID_ARG_VALUE: P, ERR_INVALID_ARG_TYPE: _, ERR_MISSING_ARGS: Y, ERR_OUT_OF_RANGE: O }, AbortError: z } = cq(), { validateAbortSignal: J, validateInteger: T, validateObject: X } = i7(), f = u6().Symbol("kWeak"), V = u6().Symbol("kResistStopPropagation"), { finished: M } = sK(), N = tS(), { addAbortSignalNoValidate: h } = qO(), { isWritable: E, isNodeStream: I } = SK(), { deprecate: D } = sq(), { ArrayPrototypePush: g, Boolean: b, MathFloor: y, Number: p, NumberIsNaN: n, Promise: s, PromiseReject: q$, PromiseResolve: c, PromisePrototypeThen: U, Symbol: j } = u6(), H = j("kEmpty"), Z = j("kEof");
    function W(B, H$) {
      if (H$ != null) X(H$, "options");
      if ((H$ === null || H$ === void 0 ? void 0 : H$.signal) != null) J(H$.signal, "options.signal");
      if (I(B) && !E(B)) throw new P("stream", B, "must be writable");
      let Q = N(this, B);
      if (H$ !== null && H$ !== void 0 && H$.signal) h(H$.signal, Q);
      return Q;
    }
    function w(B, H$) {
      if (typeof B !== "function") throw new _("fn", ["Function", "AsyncFunction"], B);
      if (H$ != null) X(H$, "options");
      if ((H$ === null || H$ === void 0 ? void 0 : H$.signal) != null) J(H$.signal, "options.signal");
      let Q = 1;
      if ((H$ === null || H$ === void 0 ? void 0 : H$.concurrency) != null) Q = y(H$.concurrency);
      let v$ = Q - 1;
      if ((H$ === null || H$ === void 0 ? void 0 : H$.highWaterMark) != null) v$ = y(H$.highWaterMark);
      return T(Q, "options.concurrency", 1), T(v$, "options.highWaterMark", 0), v$ += Q, (async function* () {
        let t$ = sq().AbortSignalAny([H$ === null || H$ === void 0 ? void 0 : H$.signal].filter(b)), m = this, r = [], J$ = { signal: t$ }, e, _$2, Y$ = false, d = 0;
        function o() {
          Y$ = true, W$();
        }
        function W$() {
          d -= 1, t();
        }
        function t() {
          if (_$2 && !Y$ && d < Q && r.length < v$) _$2(), _$2 = null;
        }
        async function F() {
          try {
            for await (let X$ of m) {
              if (Y$) return;
              if (t$.aborted) throw new z();
              try {
                if (X$ = B(X$, J$), X$ === H) continue;
                X$ = c(X$);
              } catch (z$) {
                X$ = q$(z$);
              }
              if (d += 1, U(X$, W$, o), r.push(X$), e) e(), e = null;
              if (!Y$ && (r.length >= v$ || d >= Q)) await new s((z$) => {
                _$2 = z$;
              });
            }
            r.push(Z);
          } catch (X$) {
            let z$ = q$(X$);
            U(z$, W$, o), r.push(z$);
          } finally {
            if (Y$ = true, e) e(), e = null;
          }
        }
        F();
        try {
          while (true) {
            while (r.length > 0) {
              let X$ = await r[0];
              if (X$ === Z) return;
              if (t$.aborted) throw new z();
              if (X$ !== H) yield X$;
              r.shift(), t();
            }
            await new s((X$) => {
              e = X$;
            });
          }
        } finally {
          if (Y$ = true, _$2) _$2(), _$2 = null;
        }
      }).call(this);
    }
    function G(B = void 0) {
      if (B != null) X(B, "options");
      if ((B === null || B === void 0 ? void 0 : B.signal) != null) J(B.signal, "options.signal");
      return (async function* () {
        let H$ = 0;
        for await (let v$ of this) {
          var Q;
          if (B !== null && B !== void 0 && (Q = B.signal) !== null && Q !== void 0 && Q.aborted) throw new z({ cause: B.signal.reason });
          yield [H$++, v$];
        }
      }).call(this);
    }
    async function S(B, H$ = void 0) {
      for await (let Q of R.call(this, B, H$)) return true;
      return false;
    }
    async function A(B, H$ = void 0) {
      if (typeof B !== "function") throw new _("fn", ["Function", "AsyncFunction"], B);
      return !await S.call(this, async (...Q) => {
        return !await B(...Q);
      }, H$);
    }
    async function v(B, H$) {
      for await (let Q of R.call(this, B, H$)) return Q;
      return;
    }
    async function k(B, H$) {
      if (typeof B !== "function") throw new _("fn", ["Function", "AsyncFunction"], B);
      async function Q(v$, t$) {
        return await B(v$, t$), H;
      }
      for await (let v$ of w.call(this, Q, H$)) ;
    }
    function R(B, H$) {
      if (typeof B !== "function") throw new _("fn", ["Function", "AsyncFunction"], B);
      async function Q(v$, t$) {
        if (await B(v$, t$)) return v$;
        return H;
      }
      return w.call(this, Q, H$);
    }
    class C extends Y {
      constructor() {
        super("reduce");
        this.message = "Reduce of an empty stream requires an initial value";
      }
    }
    async function L(B, H$, Q) {
      var v$;
      if (typeof B !== "function") throw new _("reducer", ["Function", "AsyncFunction"], B);
      if (Q != null) X(Q, "options");
      if ((Q === null || Q === void 0 ? void 0 : Q.signal) != null) J(Q.signal, "options.signal");
      let t$ = arguments.length > 1;
      if (Q !== null && Q !== void 0 && (v$ = Q.signal) !== null && v$ !== void 0 && v$.aborted) {
        let _$2 = new z(void 0, { cause: Q.signal.reason });
        throw this.once("error", () => {
        }), await M(this.destroy(_$2)), _$2;
      }
      let m = new K(), r = m.signal;
      if (Q !== null && Q !== void 0 && Q.signal) {
        let _$2 = { once: true, [f]: this, [V]: true };
        Q.signal.addEventListener("abort", () => m.abort(), _$2);
      }
      let J$ = false;
      try {
        for await (let _$2 of this) {
          var e;
          if (J$ = true, Q !== null && Q !== void 0 && (e = Q.signal) !== null && e !== void 0 && e.aborted) throw new z();
          if (!t$) H$ = _$2, t$ = true;
          else H$ = await B(H$, _$2, { signal: r });
        }
        if (!J$ && !t$) throw new C();
      } finally {
        m.abort();
      }
      return H$;
    }
    async function x(B) {
      if (B != null) X(B, "options");
      if ((B === null || B === void 0 ? void 0 : B.signal) != null) J(B.signal, "options.signal");
      let H$ = [];
      for await (let v$ of this) {
        var Q;
        if (B !== null && B !== void 0 && (Q = B.signal) !== null && Q !== void 0 && Q.aborted) throw new z(void 0, { cause: B.signal.reason });
        g(H$, v$);
      }
      return H$;
    }
    function l(B, H$) {
      let Q = w.call(this, B, H$);
      return (async function* () {
        for await (let v$ of Q) yield* v$;
      }).call(this);
    }
    function a(B) {
      if (B = p(B), n(B)) return 0;
      if (B < 0) throw new O("number", ">= 0", B);
      return B;
    }
    function f$(B, H$ = void 0) {
      if (H$ != null) X(H$, "options");
      if ((H$ === null || H$ === void 0 ? void 0 : H$.signal) != null) J(H$.signal, "options.signal");
      return B = a(B), (async function* () {
        var Q;
        if (H$ !== null && H$ !== void 0 && (Q = H$.signal) !== null && Q !== void 0 && Q.aborted) throw new z();
        for await (let t$ of this) {
          var v$;
          if (H$ !== null && H$ !== void 0 && (v$ = H$.signal) !== null && v$ !== void 0 && v$.aborted) throw new z();
          if (B-- <= 0) yield t$;
        }
      }).call(this);
    }
    function $$(B, H$ = void 0) {
      if (H$ != null) X(H$, "options");
      if ((H$ === null || H$ === void 0 ? void 0 : H$.signal) != null) J(H$.signal, "options.signal");
      return B = a(B), (async function* () {
        var Q;
        if (H$ !== null && H$ !== void 0 && (Q = H$.signal) !== null && Q !== void 0 && Q.aborted) throw new z();
        for await (let t$ of this) {
          var v$;
          if (H$ !== null && H$ !== void 0 && (v$ = H$.signal) !== null && v$ !== void 0 && v$.aborted) throw new z();
          if (B-- > 0) yield t$;
          if (B <= 0) return;
        }
      }).call(this);
    }
    q.exports.streamReturningOperators = { asIndexedPairs: D(G, "readable.asIndexedPairs will be removed in a future version."), drop: f$, filter: R, flatMap: l, map: w, take: $$, compose: W }, q.exports.promiseReturningOperators = { every: A, forEach: k, reduce: L, toArray: x, some: S, find: v };
  }), US = V6(($18, q) => {
    var { ArrayPrototypePop: K, Promise: P } = u6(), { isIterable: _, isNodeStream: Y, isWebStream: O } = SK(), { pipelineImpl: z } = pH(), { finished: J } = sK();
    FS();
    function T(...X) {
      return new P((f, V) => {
        let M, N, h = X[X.length - 1];
        if (h && typeof h === "object" && !Y(h) && !_(h) && !O(h)) {
          let E = K(X);
          M = E.signal, N = E.end;
        }
        z(X, (E, I) => {
          if (E) V(E);
          else f(I);
        }, { signal: M, end: N });
      });
    }
    q.exports = { finished: J, pipeline: T };
  }), FS = V6(($18, q) => {
    var { Buffer: K } = (wq(), J6(Tq)), { ObjectDefineProperty: P, ObjectKeys: _, ReflectApply: Y } = u6(), { promisify: { custom: O } } = sq(), { streamReturningOperators: z, promiseReturningOperators: J } = Rr(), { codes: { ERR_ILLEGAL_CONSTRUCTOR: T } } = cq(), X = tS(), { setDefaultHighWaterMark: f, getDefaultHighWaterMark: V } = KO(), { pipeline: M } = pH(), { destroyer: N } = c4(), h = sK(), E = US(), I = SK(), D = q.exports = uH().Stream;
    D.isDestroyed = I.isDestroyed, D.isDisturbed = I.isDisturbed, D.isErrored = I.isErrored, D.isReadable = I.isReadable, D.isWritable = I.isWritable, D.Readable = _O();
    for (let b of _(z)) {
      let y = function(...n) {
        if (new.target) throw T();
        return D.Readable.from(Y(p, this, n));
      }, p = z[b];
      P(y, "name", { __proto__: null, value: p.name }), P(y, "length", { __proto__: null, value: p.length }), P(D.Readable.prototype, b, { __proto__: null, value: y, enumerable: false, configurable: true, writable: true });
    }
    for (let b of _(J)) {
      let y = function(...n) {
        if (new.target) throw T();
        return Y(p, this, n);
      }, p = J[b];
      P(y, "name", { __proto__: null, value: p.name }), P(y, "length", { __proto__: null, value: p.length }), P(D.Readable.prototype, b, { __proto__: null, value: y, enumerable: false, configurable: true, writable: true });
    }
    D.Writable = xH(), D.Duplex = VK(), D.Transform = iS(), D.PassThrough = BS(), D.pipeline = M;
    var { addAbortSignal: g } = qO();
    D.addAbortSignal = g, D.finished = h, D.destroy = N, D.compose = X, D.setDefaultHighWaterMark = f, D.getDefaultHighWaterMark = V, P(D, "promises", { __proto__: null, configurable: true, enumerable: true, get() {
      return E;
    } }), P(M, O, { __proto__: null, enumerable: true, get() {
      return E.pipeline;
    } }), P(h, O, { __proto__: null, enumerable: true, get() {
      return E.finished;
    } }), D.Stream = D, D._isUint8Array = function(b) {
      return b instanceof Uint8Array;
    }, D._uint8ArrayToBuffer = function(b) {
      return K.from(b.buffer, b.byteOffset, b.byteLength);
    };
  }), Ir = V6(($18, q) => {
    var K = cH();
    {
      let P = FS(), _ = US(), Y = P.Readable.destroy;
      q.exports = P.Readable, q.exports._uint8ArrayToBuffer = P._uint8ArrayToBuffer, q.exports._isUint8Array = P._isUint8Array, q.exports.isDisturbed = P.isDisturbed, q.exports.isErrored = P.isErrored, q.exports.isReadable = P.isReadable, q.exports.Readable = P.Readable, q.exports.Writable = P.Writable, q.exports.Duplex = P.Duplex, q.exports.Transform = P.Transform, q.exports.PassThrough = P.PassThrough, q.exports.addAbortSignal = P.addAbortSignal, q.exports.finished = P.finished, q.exports.destroy = P.destroy, q.exports.destroy = Y, q.exports.pipeline = P.pipeline, q.exports.compose = P.compose, Object.defineProperty(P, "promises", { configurable: true, enumerable: true, get() {
        return _;
      } }), q.exports.Stream = P.Stream;
    }
    q.exports.default = q.exports;
  });
  aS.exports = Ir();
});
var mq = {};
lq(mq, { webcrypto: () => Mn, rng: () => yo, randomUUID: () => Gn, randomFillSync: () => fn, randomFill: () => wn, randomBytes: () => uo, publicEncrypt: () => Wn, publicDecrypt: () => Jn, pseudoRandomBytes: () => bo, prng: () => go, privateEncrypt: () => Hn, privateDecrypt: () => Tn, pbkdf2Sync: () => oo, pbkdf2: () => ro, listCiphers: () => so, getRandomValues: () => kn, getHashes: () => lo, getDiffieHellman: () => Kn, getCurves: () => Sn, getCiphers: () => eo, default: () => Nn, createVerify: () => jn, createSign: () => On, createHmac: () => mo, createHash: () => po, createECDH: () => zn, createDiffieHellmanGroup: () => qn, createDiffieHellman: () => _n, createDecipheriv: () => Qo, createDecipher: () => Fo, createCredentials: () => Zn, createCipheriv: () => to, createCipher: () => io, constants: () => Xn, Verify: () => vn, Sign: () => Yn, Hmac: () => co, Hash: () => xo, DiffieHellmanGroup: () => $n, DiffieHellman: () => Pn, Decipheriv: () => ao, Decipher: () => Uo, DEFAULT_ENCODING: () => An, Cipheriv: () => Bo, Cipher: () => no });
function Sn() {
  return Vn;
}
var Dr;
var Lr;
var QS;
var gr;
var br;
var yr = ($18, q, K) => {
  K = $18 != null ? Dr(Lr($18)) : {};
  let P = q || !$18 || !$18.__esModule ? QS(K, "default", { value: $18, enumerable: true }) : K;
  for (let _ of gr($18)) if (!br.call(P, _)) QS(P, _, { get: () => $18[_], enumerable: true });
  return P;
};
var r$ = ($18, q) => () => (q || $18((q = { exports: {} }).exports, q), q.exports);
var PO;
var OO;
var sS;
var ur;
var dH;
var lH;
var $8;
var rH;
var $0;
var xr;
var q0;
var pr;
var cr;
var mr;
var dr;
var MK;
var $_;
var K0;
var S8;
var _0;
var YO;
var lr;
var v8;
var rr;
var or;
var nr;
var P0;
var s8;
var t7;
var O0;
var ir;
var Y0;
var Br;
var j0;
var tr;
var Ur;
var Fr;
var ar;
var oH;
var Qr;
var nH;
var er;
var sr;
var $o;
var qo;
var Ko;
var _o;
var Po;
var Oo;
var Yo;
var jo;
var vo;
var zo;
var Wo;
var Ho;
var eS;
var Jo;
var B7;
var To;
var v0;
var z0;
var wo;
var fo;
var W0;
var Zo;
var Xo;
var U7;
var Ao;
var ko;
var Go;
var Vo;
var So;
var Mo;
var H0;
var No;
var J0;
var T0;
var w0;
var iH;
var f0;
var Co;
var Z0;
var Eo;
var ho;
var mH;
var Ro;
var Io;
var Do;
var Lo;
var f6;
var go;
var bo;
var yo;
var uo;
var xo;
var po;
var co;
var mo;
var lo;
var ro;
var oo;
var no;
var io;
var Bo;
var to;
var Uo;
var Fo;
var ao;
var Qo;
var eo;
var so;
var $n;
var qn;
var Kn;
var _n;
var Pn;
var On;
var Yn;
var jn;
var vn;
var zn;
var Wn;
var Hn;
var Jn;
var Tn;
var wn;
var fn;
var Zn;
var Xn;
var An = "buffer";
var kn = ($18) => {
  return crypto.getRandomValues($18);
};
var Gn = () => {
  return crypto.randomUUID();
};
var Vn;
var Mn;
var Nn;
var dq = p_(() => {
  Dr = Object.create, { getPrototypeOf: Lr, defineProperty: QS, getOwnPropertyNames: gr } = Object, br = Object.prototype.hasOwnProperty, PO = r$(($18, q) => {
    q.exports = (dq(), J6(mq)).randomBytes;
  }), OO = r$(($18, q) => {
    q.exports = (dq(), J6(mq)).createHash;
  }), sS = r$(($18, q) => {
    q.exports = (dq(), J6(mq)).createHmac;
  }), ur = r$(($18, q) => {
    q.exports = { sha224WithRSAEncryption: { sign: "rsa", hash: "sha224", id: "302d300d06096086480165030402040500041c" }, "RSA-SHA224": { sign: "ecdsa/rsa", hash: "sha224", id: "302d300d06096086480165030402040500041c" }, sha256WithRSAEncryption: { sign: "rsa", hash: "sha256", id: "3031300d060960864801650304020105000420" }, "RSA-SHA256": { sign: "ecdsa/rsa", hash: "sha256", id: "3031300d060960864801650304020105000420" }, sha384WithRSAEncryption: { sign: "rsa", hash: "sha384", id: "3041300d060960864801650304020205000430" }, "RSA-SHA384": { sign: "ecdsa/rsa", hash: "sha384", id: "3041300d060960864801650304020205000430" }, sha512WithRSAEncryption: { sign: "rsa", hash: "sha512", id: "3051300d060960864801650304020305000440" }, "RSA-SHA512": { sign: "ecdsa/rsa", hash: "sha512", id: "3051300d060960864801650304020305000440" }, "RSA-SHA1": { sign: "rsa", hash: "sha1", id: "3021300906052b0e03021a05000414" }, "ecdsa-with-SHA1": { sign: "ecdsa", hash: "sha1", id: "" }, sha256: { sign: "ecdsa", hash: "sha256", id: "" }, sha224: { sign: "ecdsa", hash: "sha224", id: "" }, sha384: { sign: "ecdsa", hash: "sha384", id: "" }, sha512: { sign: "ecdsa", hash: "sha512", id: "" }, "DSA-SHA": { sign: "dsa", hash: "sha1", id: "" }, "DSA-SHA1": { sign: "dsa", hash: "sha1", id: "" }, DSA: { sign: "dsa", hash: "sha1", id: "" }, "DSA-WITH-SHA224": { sign: "dsa", hash: "sha224", id: "" }, "DSA-SHA224": { sign: "dsa", hash: "sha224", id: "" }, "DSA-WITH-SHA256": { sign: "dsa", hash: "sha256", id: "" }, "DSA-SHA256": { sign: "dsa", hash: "sha256", id: "" }, "DSA-WITH-SHA384": { sign: "dsa", hash: "sha384", id: "" }, "DSA-SHA384": { sign: "dsa", hash: "sha384", id: "" }, "DSA-WITH-SHA512": { sign: "dsa", hash: "sha512", id: "" }, "DSA-SHA512": { sign: "dsa", hash: "sha512", id: "" }, "DSA-RIPEMD160": { sign: "dsa", hash: "rmd160", id: "" }, ripemd160WithRSA: { sign: "rsa", hash: "rmd160", id: "3021300906052b2403020105000414" }, "RSA-RIPEMD160": { sign: "rsa", hash: "rmd160", id: "3021300906052b2403020105000414" }, md5WithRSAEncryption: { sign: "rsa", hash: "md5", id: "3020300c06082a864886f70d020505000410" }, "RSA-MD5": { sign: "rsa", hash: "md5", id: "3020300c06082a864886f70d020505000410" } };
  }), dH = r$(($18, q) => {
    var K = Math.pow(2, 30) - 1;
    q.exports = function(P, _) {
      if (typeof P !== "number") throw TypeError("Iterations not a number");
      if (P < 0) throw TypeError("Bad iterations");
      if (typeof _ !== "number") throw TypeError("Key length not a number");
      if (_ < 0 || _ > K || _ !== _) throw TypeError("Bad key length");
    };
  }), lH = r$(($18, q) => {
    var K;
    if (globalThis.process && globalThis.process.browser) K = "utf-8";
    else if (globalThis.process && globalThis.process.version) P = parseInt(process.version.split(".")[0].slice(1), 10), K = P >= 6 ? "utf-8" : "binary";
    else K = "utf-8";
    var P;
    q.exports = K;
  }), $8 = r$(($18, q) => {
    var K = (wq(), J6(Tq)), P = K.Buffer;
    function _(O, z) {
      for (var J in O) z[J] = O[J];
    }
    if (P.from && P.alloc && P.allocUnsafe && P.allocUnsafeSlow) q.exports = K;
    else _(K, $18), $18.Buffer = Y;
    function Y(O, z, J) {
      return P(O, z, J);
    }
    Y.prototype = Object.create(P.prototype), _(P, Y), Y.from = function(O, z, J) {
      if (typeof O === "number") throw TypeError("Argument must not be a number");
      return P(O, z, J);
    }, Y.alloc = function(O, z, J) {
      if (typeof O !== "number") throw TypeError("Argument must be a number");
      var T = P(O);
      if (z !== void 0) if (typeof J === "string") T.fill(z, J);
      else T.fill(z);
      else T.fill(0);
      return T;
    }, Y.allocUnsafe = function(O) {
      if (typeof O !== "number") throw TypeError("Argument must be a number");
      return P(O);
    }, Y.allocUnsafeSlow = function(O) {
      if (typeof O !== "number") throw TypeError("Argument must be a number");
      return K.SlowBuffer(O);
    };
  }), rH = r$(($18, q) => {
    var K = $8().Buffer;
    q.exports = function(P, _, Y) {
      if (K.isBuffer(P)) return P;
      else if (typeof P === "string") return K.from(P, _);
      else if (ArrayBuffer.isView(P)) return K.from(P.buffer);
      else throw TypeError(Y + " must be a string, a Buffer, a typed array or a DataView");
    };
  }), $0 = r$(($18, q) => {
    var K = { md5: 16, sha1: 20, sha224: 28, sha256: 32, sha384: 48, sha512: 64, rmd160: 20, ripemd160: 20 }, P = sS(), _ = $8().Buffer, Y = dH(), O = lH(), z = rH();
    function J(T, X, f, V, M) {
      Y(f, V), T = z(T, O, "Password"), X = z(X, O, "Salt"), M = M || "sha1";
      var N = _.allocUnsafe(V), h = _.allocUnsafe(X.length + 4);
      X.copy(h, 0, 0, X.length);
      var E = 0, I = K[M], D = Math.ceil(V / I);
      for (var g = 1; g <= D; g++) {
        h.writeUInt32BE(g, X.length);
        var b = P(M, T).update(h).digest(), y = b;
        for (var p = 1; p < f; p++) {
          y = P(M, T).update(y).digest();
          for (var n = 0; n < I; n++) b[n] ^= y[n];
        }
        b.copy(N, E), E += I;
      }
      return N;
    }
    q.exports = J;
  }), xr = r$(($18, q) => {
    var K = $8().Buffer, P = dH(), _ = lH(), Y = $0(), O = rH(), z, J = globalThis.crypto && globalThis.crypto.subtle, T = { sha: "SHA-1", "sha-1": "SHA-1", sha1: "SHA-1", sha256: "SHA-256", "sha-256": "SHA-256", sha384: "SHA-384", "sha-384": "SHA-384", "sha-512": "SHA-512", sha512: "SHA-512" }, X = [];
    function f(E) {
      if (globalThis.process && !globalThis.process.browser) return Promise.resolve(false);
      if (!J || !J.importKey || !J.deriveBits) return Promise.resolve(false);
      if (X[E] !== void 0) return X[E];
      z = z || K.alloc(8);
      var I = N(z, z, 10, 128, E).then(function() {
        return true;
      }).catch(function() {
        return false;
      });
      return X[E] = I, I;
    }
    var V;
    function M() {
      if (V) return V;
      if (globalThis.process && globalThis.process.nextTick) V = globalThis.process.nextTick;
      else if (globalThis.queueMicrotask) V = globalThis.queueMicrotask;
      else if (globalThis.setImmediate) V = globalThis.setImmediate;
      else V = globalThis.setTimeout;
      return V;
    }
    function N(E, I, D, g, b) {
      return J.importKey("raw", E, { name: "PBKDF2" }, false, ["deriveBits"]).then(function(y) {
        return J.deriveBits({ name: "PBKDF2", salt: I, iterations: D, hash: { name: b } }, y, g << 3);
      }).then(function(y) {
        return K.from(y);
      });
    }
    function h(E, I) {
      E.then(function(D) {
        M()(function() {
          I(null, D);
        });
      }, function(D) {
        M()(function() {
          I(D);
        });
      });
    }
    q.exports = function(E, I, D, g, b, y) {
      if (typeof b === "function") y = b, b = void 0;
      b = b || "sha1";
      var p = T[b.toLowerCase()];
      if (!p || typeof globalThis.Promise !== "function") {
        M()(function() {
          var n;
          try {
            n = Y(E, I, D, g, b);
          } catch (s) {
            return y(s);
          }
          y(null, n);
        });
        return;
      }
      if (P(D, g), E = O(E, _, "Password"), I = O(I, _, "Salt"), typeof y !== "function") throw Error("No callback provided to pbkdf2");
      h(f(p).then(function(n) {
        if (n) return N(E, I, D, g, p);
        return Y(E, I, D, g, b);
      }), y);
    };
  }), q0 = r$(($18) => {
    var q = (dq(), J6(mq)), K = dH(), P = lH(), _ = rH();
    function Y(z, J, T, X, f, V) {
      if (K(T, X), z = _(z, P, "Password"), J = _(J, P, "Salt"), typeof f === "function") V = f, f = "sha1";
      if (typeof V !== "function") throw Error("No callback provided to pbkdf2");
      return q.pbkdf2(z, J, T, X, f, V);
    }
    function O(z, J, T, X, f) {
      return K(T, X), z = _(z, P, "Password"), J = _(J, P, "Salt"), f = f || "sha1", q.pbkdf2Sync(z, J, T, X, f);
    }
    if (!q.pbkdf2Sync || q.pbkdf2Sync.toString().indexOf("keylen, digest") === -1) $18.pbkdf2Sync = $0(), $18.pbkdf2 = xr();
    else $18.pbkdf2Sync = O, $18.pbkdf2 = Y;
  }), pr = r$(($18) => {
    var q = (dq(), J6(mq));
    $18.createCipher = $18.Cipher = q.createCipher, $18.createCipheriv = $18.Cipheriv = q.createCipheriv, $18.createDecipher = $18.Decipher = q.createDecipher, $18.createDecipheriv = $18.Decipheriv = q.createDecipheriv, $18.listCiphers = $18.getCiphers = q.getCiphers;
  }), cr = r$(($18) => {
    var q = (dq(), J6(mq));
    $18.DiffieHellmanGroup = q.DiffieHellmanGroup, $18.createDiffieHellmanGroup = q.createDiffieHellmanGroup, $18.getDiffieHellman = q.getDiffieHellman, $18.createDiffieHellman = q.createDiffieHellman, $18.DiffieHellman = q.DiffieHellman;
  }), mr = r$(($18) => {
    var q = (dq(), J6(mq));
    $18.createSign = q.createSign, $18.Sign = q.Sign, $18.createVerify = q.createVerify, $18.Verify = q.Verify;
  }), dr = r$(($18, q) => {
    q.exports = { name: "elliptic", version: "6.6.1", description: "EC cryptography", main: "lib/elliptic.js", files: ["lib"], scripts: { lint: "eslint lib test", "lint:fix": "npm run lint -- --fix", unit: "istanbul test _mocha --reporter=spec test/index.js", test: "npm run lint && npm run unit", version: "grunt dist && git add dist/" }, repository: { type: "git", url: "git@github.com:indutny/elliptic" }, keywords: ["EC", "Elliptic", "curve", "Cryptography"], author: "Fedor Indutny <fedor@indutny.com>", license: "MIT", bugs: { url: "https://github.com/indutny/elliptic/issues" }, homepage: "https://github.com/indutny/elliptic", devDependencies: { brfs: "^2.0.2", coveralls: "^3.1.0", eslint: "^7.6.0", grunt: "^1.2.1", "grunt-browserify": "^5.3.0", "grunt-cli": "^1.3.2", "grunt-contrib-connect": "^3.0.0", "grunt-contrib-copy": "^1.0.0", "grunt-contrib-uglify": "^5.0.0", "grunt-mocha-istanbul": "^5.0.2", "grunt-saucelabs": "^9.0.1", istanbul: "^0.4.5", mocha: "^8.0.1" }, dependencies: { "bn.js": "^4.11.9", brorand: "^1.1.0", "hash.js": "^1.0.0", "hmac-drbg": "^1.0.1", inherits: "^2.0.4", "minimalistic-assert": "^1.0.1", "minimalistic-crypto-utils": "^1.0.1" } };
  }), MK = r$(($18, q) => {
    (function(K, P) {
      function _(j, H) {
        if (!j) throw Error(H || "Assertion failed");
      }
      function Y(j, H) {
        j.super_ = H;
        var Z = function() {
        };
        Z.prototype = H.prototype, j.prototype = new Z(), j.prototype.constructor = j;
      }
      function O(j, H, Z) {
        if (O.isBN(j)) return j;
        if (this.negative = 0, this.words = null, this.length = 0, this.red = null, j !== null) {
          if (H === "le" || H === "be") Z = H, H = 10;
          this._init(j || 0, H || 10, Z || "be");
        }
      }
      if (typeof K === "object") K.exports = O;
      else P.BN = O;
      O.BN = O, O.wordSize = 26;
      var z;
      try {
        if (typeof window < "u" && typeof window.Buffer < "u") z = window.Buffer;
        else z = (wq(), J6(Tq)).Buffer;
      } catch (j) {
      }
      O.isBN = function(j) {
        if (j instanceof O) return true;
        return j !== null && typeof j === "object" && j.constructor.wordSize === O.wordSize && Array.isArray(j.words);
      }, O.max = function(j, H) {
        if (j.cmp(H) > 0) return j;
        return H;
      }, O.min = function(j, H) {
        if (j.cmp(H) < 0) return j;
        return H;
      }, O.prototype._init = function(j, H, Z) {
        if (typeof j === "number") return this._initNumber(j, H, Z);
        if (typeof j === "object") return this._initArray(j, H, Z);
        if (H === "hex") H = 16;
        _(H === (H | 0) && H >= 2 && H <= 36), j = j.toString().replace(/\s+/g, "");
        var W = 0;
        if (j[0] === "-") W++, this.negative = 1;
        if (W < j.length) {
          if (H === 16) this._parseHex(j, W, Z);
          else if (this._parseBase(j, H, W), Z === "le") this._initArray(this.toArray(), H, Z);
        }
      }, O.prototype._initNumber = function(j, H, Z) {
        if (j < 0) this.negative = 1, j = -j;
        if (j < 67108864) this.words = [j & 67108863], this.length = 1;
        else if (j < 4503599627370496) this.words = [j & 67108863, j / 67108864 & 67108863], this.length = 2;
        else _(j < 9007199254740992), this.words = [j & 67108863, j / 67108864 & 67108863, 1], this.length = 3;
        if (Z !== "le") return;
        this._initArray(this.toArray(), H, Z);
      }, O.prototype._initArray = function(j, H, Z) {
        if (_(typeof j.length === "number"), j.length <= 0) return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(j.length / 3), this.words = Array(this.length);
        for (var W = 0; W < this.length; W++) this.words[W] = 0;
        var w, G, S = 0;
        if (Z === "be") {
          for (W = j.length - 1, w = 0; W >= 0; W -= 3) if (G = j[W] | j[W - 1] << 8 | j[W - 2] << 16, this.words[w] |= G << S & 67108863, this.words[w + 1] = G >>> 26 - S & 67108863, S += 24, S >= 26) S -= 26, w++;
        } else if (Z === "le") {
          for (W = 0, w = 0; W < j.length; W += 3) if (G = j[W] | j[W + 1] << 8 | j[W + 2] << 16, this.words[w] |= G << S & 67108863, this.words[w + 1] = G >>> 26 - S & 67108863, S += 24, S >= 26) S -= 26, w++;
        }
        return this.strip();
      };
      function J(j, H) {
        var Z = j.charCodeAt(H);
        if (Z >= 65 && Z <= 70) return Z - 55;
        else if (Z >= 97 && Z <= 102) return Z - 87;
        else return Z - 48 & 15;
      }
      function T(j, H, Z) {
        var W = J(j, Z);
        if (Z - 1 >= H) W |= J(j, Z - 1) << 4;
        return W;
      }
      O.prototype._parseHex = function(j, H, Z) {
        this.length = Math.ceil((j.length - H) / 6), this.words = Array(this.length);
        for (var W = 0; W < this.length; W++) this.words[W] = 0;
        var w = 0, G = 0, S;
        if (Z === "be") for (W = j.length - 1; W >= H; W -= 2) if (S = T(j, H, W) << w, this.words[G] |= S & 67108863, w >= 18) w -= 18, G += 1, this.words[G] |= S >>> 26;
        else w += 8;
        else {
          var A = j.length - H;
          for (W = A % 2 === 0 ? H + 1 : H; W < j.length; W += 2) if (S = T(j, H, W) << w, this.words[G] |= S & 67108863, w >= 18) w -= 18, G += 1, this.words[G] |= S >>> 26;
          else w += 8;
        }
        this.strip();
      };
      function X(j, H, Z, W) {
        var w = 0, G = Math.min(j.length, Z);
        for (var S = H; S < G; S++) {
          var A = j.charCodeAt(S) - 48;
          if (w *= W, A >= 49) w += A - 49 + 10;
          else if (A >= 17) w += A - 17 + 10;
          else w += A;
        }
        return w;
      }
      O.prototype._parseBase = function(j, H, Z) {
        this.words = [0], this.length = 1;
        for (var W = 0, w = 1; w <= 67108863; w *= H) W++;
        W--, w = w / H | 0;
        var G = j.length - Z, S = G % W, A = Math.min(G, G - S) + Z, v = 0;
        for (var k = Z; k < A; k += W) if (v = X(j, k, k + W, H), this.imuln(w), this.words[0] + v < 67108864) this.words[0] += v;
        else this._iaddn(v);
        if (S !== 0) {
          var R = 1;
          v = X(j, k, j.length, H);
          for (k = 0; k < S; k++) R *= H;
          if (this.imuln(R), this.words[0] + v < 67108864) this.words[0] += v;
          else this._iaddn(v);
        }
        this.strip();
      }, O.prototype.copy = function(j) {
        j.words = Array(this.length);
        for (var H = 0; H < this.length; H++) j.words[H] = this.words[H];
        j.length = this.length, j.negative = this.negative, j.red = this.red;
      }, O.prototype.clone = function() {
        var j = new O(null);
        return this.copy(j), j;
      }, O.prototype._expand = function(j) {
        while (this.length < j) this.words[this.length++] = 0;
        return this;
      }, O.prototype.strip = function() {
        while (this.length > 1 && this.words[this.length - 1] === 0) this.length--;
        return this._normSign();
      }, O.prototype._normSign = function() {
        if (this.length === 1 && this.words[0] === 0) this.negative = 0;
        return this;
      }, O.prototype.inspect = function() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var f = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], V = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], M = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
      if (O.prototype.toString = function(j, H) {
        j = j || 10, H = H | 0 || 1;
        var Z;
        if (j === 16 || j === "hex") {
          Z = "";
          var W = 0, w = 0;
          for (var G = 0; G < this.length; G++) {
            var S = this.words[G], A = ((S << W | w) & 16777215).toString(16);
            if (w = S >>> 24 - W & 16777215, W += 2, W >= 26) W -= 26, G--;
            if (w !== 0 || G !== this.length - 1) Z = f[6 - A.length] + A + Z;
            else Z = A + Z;
          }
          if (w !== 0) Z = w.toString(16) + Z;
          while (Z.length % H !== 0) Z = "0" + Z;
          if (this.negative !== 0) Z = "-" + Z;
          return Z;
        }
        if (j === (j | 0) && j >= 2 && j <= 36) {
          var v = V[j], k = M[j];
          Z = "";
          var R = this.clone();
          R.negative = 0;
          while (!R.isZero()) {
            var C = R.modn(k).toString(j);
            if (R = R.idivn(k), !R.isZero()) Z = f[v - C.length] + C + Z;
            else Z = C + Z;
          }
          if (this.isZero()) Z = "0" + Z;
          while (Z.length % H !== 0) Z = "0" + Z;
          if (this.negative !== 0) Z = "-" + Z;
          return Z;
        }
        _(false, "Base should be between 2 and 36");
      }, O.prototype.toNumber = function() {
        var j = this.words[0];
        if (this.length === 2) j += this.words[1] * 67108864;
        else if (this.length === 3 && this.words[2] === 1) j += 4503599627370496 + this.words[1] * 67108864;
        else if (this.length > 2) _(false, "Number can only safely store up to 53 bits");
        return this.negative !== 0 ? -j : j;
      }, O.prototype.toJSON = function() {
        return this.toString(16);
      }, O.prototype.toBuffer = function(j, H) {
        return _(typeof z < "u"), this.toArrayLike(z, j, H);
      }, O.prototype.toArray = function(j, H) {
        return this.toArrayLike(Array, j, H);
      }, O.prototype.toArrayLike = function(j, H, Z) {
        var W = this.byteLength(), w = Z || Math.max(1, W);
        _(W <= w, "byte array longer than desired length"), _(w > 0, "Requested array length <= 0"), this.strip();
        var G = H === "le", S = new j(w), A, v, k = this.clone();
        if (!G) {
          for (v = 0; v < w - W; v++) S[v] = 0;
          for (v = 0; !k.isZero(); v++) A = k.andln(255), k.iushrn(8), S[w - v - 1] = A;
        } else {
          for (v = 0; !k.isZero(); v++) A = k.andln(255), k.iushrn(8), S[v] = A;
          for (; v < w; v++) S[v] = 0;
        }
        return S;
      }, Math.clz32) O.prototype._countBits = function(j) {
        return 32 - Math.clz32(j);
      };
      else O.prototype._countBits = function(j) {
        var H = j, Z = 0;
        if (H >= 4096) Z += 13, H >>>= 13;
        if (H >= 64) Z += 7, H >>>= 7;
        if (H >= 8) Z += 4, H >>>= 4;
        if (H >= 2) Z += 2, H >>>= 2;
        return Z + H;
      };
      O.prototype._zeroBits = function(j) {
        if (j === 0) return 26;
        var H = j, Z = 0;
        if ((H & 8191) === 0) Z += 13, H >>>= 13;
        if ((H & 127) === 0) Z += 7, H >>>= 7;
        if ((H & 15) === 0) Z += 4, H >>>= 4;
        if ((H & 3) === 0) Z += 2, H >>>= 2;
        if ((H & 1) === 0) Z++;
        return Z;
      }, O.prototype.bitLength = function() {
        var j = this.words[this.length - 1], H = this._countBits(j);
        return (this.length - 1) * 26 + H;
      };
      function N(j) {
        var H = Array(j.bitLength());
        for (var Z = 0; Z < H.length; Z++) {
          var W = Z / 26 | 0, w = Z % 26;
          H[Z] = (j.words[W] & 1 << w) >>> w;
        }
        return H;
      }
      O.prototype.zeroBits = function() {
        if (this.isZero()) return 0;
        var j = 0;
        for (var H = 0; H < this.length; H++) {
          var Z = this._zeroBits(this.words[H]);
          if (j += Z, Z !== 26) break;
        }
        return j;
      }, O.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, O.prototype.toTwos = function(j) {
        if (this.negative !== 0) return this.abs().inotn(j).iaddn(1);
        return this.clone();
      }, O.prototype.fromTwos = function(j) {
        if (this.testn(j - 1)) return this.notn(j).iaddn(1).ineg();
        return this.clone();
      }, O.prototype.isNeg = function() {
        return this.negative !== 0;
      }, O.prototype.neg = function() {
        return this.clone().ineg();
      }, O.prototype.ineg = function() {
        if (!this.isZero()) this.negative ^= 1;
        return this;
      }, O.prototype.iuor = function(j) {
        while (this.length < j.length) this.words[this.length++] = 0;
        for (var H = 0; H < j.length; H++) this.words[H] = this.words[H] | j.words[H];
        return this.strip();
      }, O.prototype.ior = function(j) {
        return _((this.negative | j.negative) === 0), this.iuor(j);
      }, O.prototype.or = function(j) {
        if (this.length > j.length) return this.clone().ior(j);
        return j.clone().ior(this);
      }, O.prototype.uor = function(j) {
        if (this.length > j.length) return this.clone().iuor(j);
        return j.clone().iuor(this);
      }, O.prototype.iuand = function(j) {
        var H;
        if (this.length > j.length) H = j;
        else H = this;
        for (var Z = 0; Z < H.length; Z++) this.words[Z] = this.words[Z] & j.words[Z];
        return this.length = H.length, this.strip();
      }, O.prototype.iand = function(j) {
        return _((this.negative | j.negative) === 0), this.iuand(j);
      }, O.prototype.and = function(j) {
        if (this.length > j.length) return this.clone().iand(j);
        return j.clone().iand(this);
      }, O.prototype.uand = function(j) {
        if (this.length > j.length) return this.clone().iuand(j);
        return j.clone().iuand(this);
      }, O.prototype.iuxor = function(j) {
        var H, Z;
        if (this.length > j.length) H = this, Z = j;
        else H = j, Z = this;
        for (var W = 0; W < Z.length; W++) this.words[W] = H.words[W] ^ Z.words[W];
        if (this !== H) for (; W < H.length; W++) this.words[W] = H.words[W];
        return this.length = H.length, this.strip();
      }, O.prototype.ixor = function(j) {
        return _((this.negative | j.negative) === 0), this.iuxor(j);
      }, O.prototype.xor = function(j) {
        if (this.length > j.length) return this.clone().ixor(j);
        return j.clone().ixor(this);
      }, O.prototype.uxor = function(j) {
        if (this.length > j.length) return this.clone().iuxor(j);
        return j.clone().iuxor(this);
      }, O.prototype.inotn = function(j) {
        _(typeof j === "number" && j >= 0);
        var H = Math.ceil(j / 26) | 0, Z = j % 26;
        if (this._expand(H), Z > 0) H--;
        for (var W = 0; W < H; W++) this.words[W] = ~this.words[W] & 67108863;
        if (Z > 0) this.words[W] = ~this.words[W] & 67108863 >> 26 - Z;
        return this.strip();
      }, O.prototype.notn = function(j) {
        return this.clone().inotn(j);
      }, O.prototype.setn = function(j, H) {
        _(typeof j === "number" && j >= 0);
        var Z = j / 26 | 0, W = j % 26;
        if (this._expand(Z + 1), H) this.words[Z] = this.words[Z] | 1 << W;
        else this.words[Z] = this.words[Z] & ~(1 << W);
        return this.strip();
      }, O.prototype.iadd = function(j) {
        var H;
        if (this.negative !== 0 && j.negative === 0) return this.negative = 0, H = this.isub(j), this.negative ^= 1, this._normSign();
        else if (this.negative === 0 && j.negative !== 0) return j.negative = 0, H = this.isub(j), j.negative = 1, H._normSign();
        var Z, W;
        if (this.length > j.length) Z = this, W = j;
        else Z = j, W = this;
        var w = 0;
        for (var G = 0; G < W.length; G++) H = (Z.words[G] | 0) + (W.words[G] | 0) + w, this.words[G] = H & 67108863, w = H >>> 26;
        for (; w !== 0 && G < Z.length; G++) H = (Z.words[G] | 0) + w, this.words[G] = H & 67108863, w = H >>> 26;
        if (this.length = Z.length, w !== 0) this.words[this.length] = w, this.length++;
        else if (Z !== this) for (; G < Z.length; G++) this.words[G] = Z.words[G];
        return this;
      }, O.prototype.add = function(j) {
        var H;
        if (j.negative !== 0 && this.negative === 0) return j.negative = 0, H = this.sub(j), j.negative ^= 1, H;
        else if (j.negative === 0 && this.negative !== 0) return this.negative = 0, H = j.sub(this), this.negative = 1, H;
        if (this.length > j.length) return this.clone().iadd(j);
        return j.clone().iadd(this);
      }, O.prototype.isub = function(j) {
        if (j.negative !== 0) {
          j.negative = 0;
          var H = this.iadd(j);
          return j.negative = 1, H._normSign();
        } else if (this.negative !== 0) return this.negative = 0, this.iadd(j), this.negative = 1, this._normSign();
        var Z = this.cmp(j);
        if (Z === 0) return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var W, w;
        if (Z > 0) W = this, w = j;
        else W = j, w = this;
        var G = 0;
        for (var S = 0; S < w.length; S++) H = (W.words[S] | 0) - (w.words[S] | 0) + G, G = H >> 26, this.words[S] = H & 67108863;
        for (; G !== 0 && S < W.length; S++) H = (W.words[S] | 0) + G, G = H >> 26, this.words[S] = H & 67108863;
        if (G === 0 && S < W.length && W !== this) for (; S < W.length; S++) this.words[S] = W.words[S];
        if (this.length = Math.max(this.length, S), W !== this) this.negative = 1;
        return this.strip();
      }, O.prototype.sub = function(j) {
        return this.clone().isub(j);
      };
      function h(j, H, Z) {
        Z.negative = H.negative ^ j.negative;
        var W = j.length + H.length | 0;
        Z.length = W, W = W - 1 | 0;
        var w = j.words[0] | 0, G = H.words[0] | 0, S = w * G, A = S & 67108863, v = S / 67108864 | 0;
        Z.words[0] = A;
        for (var k = 1; k < W; k++) {
          var R = v >>> 26, C = v & 67108863, L = Math.min(k, H.length - 1);
          for (var x = Math.max(0, k - j.length + 1); x <= L; x++) {
            var l = k - x | 0;
            w = j.words[l] | 0, G = H.words[x] | 0, S = w * G + C, R += S / 67108864 | 0, C = S & 67108863;
          }
          Z.words[k] = C | 0, v = R | 0;
        }
        if (v !== 0) Z.words[k] = v | 0;
        else Z.length--;
        return Z.strip();
      }
      var E = function(j, H, Z) {
        var W = j.words, w = H.words, G = Z.words, S = 0, A, v, k, R = W[0] | 0, C = R & 8191, L = R >>> 13, x = W[1] | 0, l = x & 8191, a = x >>> 13, f$ = W[2] | 0, $$ = f$ & 8191, B = f$ >>> 13, H$ = W[3] | 0, Q = H$ & 8191, v$ = H$ >>> 13, t$ = W[4] | 0, m = t$ & 8191, r = t$ >>> 13, J$ = W[5] | 0, e = J$ & 8191, _$2 = J$ >>> 13, Y$ = W[6] | 0, d = Y$ & 8191, o = Y$ >>> 13, W$ = W[7] | 0, t = W$ & 8191, F = W$ >>> 13, X$ = W[8] | 0, z$ = X$ & 8191, j$ = X$ >>> 13, X6 = W[9] | 0, Z$ = X6 & 8191, A$ = X6 >>> 13, d6 = w[0] | 0, S$ = d6 & 8191, V$ = d6 >>> 13, Sq = w[1] | 0, N$ = Sq & 8191, D$ = Sq >>> 13, Mq = w[2] | 0, L$ = Mq & 8191, C$ = Mq >>> 13, fq = w[3] | 0, g$ = fq & 8191, E$ = fq >>> 13, vq = w[4] | 0, b$ = vq & 8191, y$ = vq >>> 13, zq = w[5] | 0, h$ = zq & 8191, u = zq >>> 13, i = w[6] | 0, K$ = i & 8191, P$ = i >>> 13, i$ = w[7] | 0, k$ = i$ & 8191, G$ = i$ >>> 13, x6 = w[8] | 0, R$ = x6 & 8191, u$ = x6 >>> 13, Zq = w[9] | 0, I$ = Zq & 8191, M$ = Zq >>> 13;
        Z.negative = j.negative ^ H.negative, Z.length = 19, A = Math.imul(C, S$), v = Math.imul(C, V$), v = v + Math.imul(L, S$) | 0, k = Math.imul(L, V$);
        var p6 = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (p6 >>> 26) | 0, p6 &= 67108863, A = Math.imul(l, S$), v = Math.imul(l, V$), v = v + Math.imul(a, S$) | 0, k = Math.imul(a, V$), A = A + Math.imul(C, N$) | 0, v = v + Math.imul(C, D$) | 0, v = v + Math.imul(L, N$) | 0, k = k + Math.imul(L, D$) | 0;
        var H6 = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (H6 >>> 26) | 0, H6 &= 67108863, A = Math.imul($$, S$), v = Math.imul($$, V$), v = v + Math.imul(B, S$) | 0, k = Math.imul(B, V$), A = A + Math.imul(l, N$) | 0, v = v + Math.imul(l, D$) | 0, v = v + Math.imul(a, N$) | 0, k = k + Math.imul(a, D$) | 0, A = A + Math.imul(C, L$) | 0, v = v + Math.imul(C, C$) | 0, v = v + Math.imul(L, L$) | 0, k = k + Math.imul(L, C$) | 0;
        var v6 = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (v6 >>> 26) | 0, v6 &= 67108863, A = Math.imul(Q, S$), v = Math.imul(Q, V$), v = v + Math.imul(v$, S$) | 0, k = Math.imul(v$, V$), A = A + Math.imul($$, N$) | 0, v = v + Math.imul($$, D$) | 0, v = v + Math.imul(B, N$) | 0, k = k + Math.imul(B, D$) | 0, A = A + Math.imul(l, L$) | 0, v = v + Math.imul(l, C$) | 0, v = v + Math.imul(a, L$) | 0, k = k + Math.imul(a, C$) | 0, A = A + Math.imul(C, g$) | 0, v = v + Math.imul(C, E$) | 0, v = v + Math.imul(L, g$) | 0, k = k + Math.imul(L, E$) | 0;
        var C6 = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (C6 >>> 26) | 0, C6 &= 67108863, A = Math.imul(m, S$), v = Math.imul(m, V$), v = v + Math.imul(r, S$) | 0, k = Math.imul(r, V$), A = A + Math.imul(Q, N$) | 0, v = v + Math.imul(Q, D$) | 0, v = v + Math.imul(v$, N$) | 0, k = k + Math.imul(v$, D$) | 0, A = A + Math.imul($$, L$) | 0, v = v + Math.imul($$, C$) | 0, v = v + Math.imul(B, L$) | 0, k = k + Math.imul(B, C$) | 0, A = A + Math.imul(l, g$) | 0, v = v + Math.imul(l, E$) | 0, v = v + Math.imul(a, g$) | 0, k = k + Math.imul(a, E$) | 0, A = A + Math.imul(C, b$) | 0, v = v + Math.imul(C, y$) | 0, v = v + Math.imul(L, b$) | 0, k = k + Math.imul(L, y$) | 0;
        var S6 = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (S6 >>> 26) | 0, S6 &= 67108863, A = Math.imul(e, S$), v = Math.imul(e, V$), v = v + Math.imul(_$2, S$) | 0, k = Math.imul(_$2, V$), A = A + Math.imul(m, N$) | 0, v = v + Math.imul(m, D$) | 0, v = v + Math.imul(r, N$) | 0, k = k + Math.imul(r, D$) | 0, A = A + Math.imul(Q, L$) | 0, v = v + Math.imul(Q, C$) | 0, v = v + Math.imul(v$, L$) | 0, k = k + Math.imul(v$, C$) | 0, A = A + Math.imul($$, g$) | 0, v = v + Math.imul($$, E$) | 0, v = v + Math.imul(B, g$) | 0, k = k + Math.imul(B, E$) | 0, A = A + Math.imul(l, b$) | 0, v = v + Math.imul(l, y$) | 0, v = v + Math.imul(a, b$) | 0, k = k + Math.imul(a, y$) | 0, A = A + Math.imul(C, h$) | 0, v = v + Math.imul(C, u) | 0, v = v + Math.imul(L, h$) | 0, k = k + Math.imul(L, u) | 0;
        var i6 = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (i6 >>> 26) | 0, i6 &= 67108863, A = Math.imul(d, S$), v = Math.imul(d, V$), v = v + Math.imul(o, S$) | 0, k = Math.imul(o, V$), A = A + Math.imul(e, N$) | 0, v = v + Math.imul(e, D$) | 0, v = v + Math.imul(_$2, N$) | 0, k = k + Math.imul(_$2, D$) | 0, A = A + Math.imul(m, L$) | 0, v = v + Math.imul(m, C$) | 0, v = v + Math.imul(r, L$) | 0, k = k + Math.imul(r, C$) | 0, A = A + Math.imul(Q, g$) | 0, v = v + Math.imul(Q, E$) | 0, v = v + Math.imul(v$, g$) | 0, k = k + Math.imul(v$, E$) | 0, A = A + Math.imul($$, b$) | 0, v = v + Math.imul($$, y$) | 0, v = v + Math.imul(B, b$) | 0, k = k + Math.imul(B, y$) | 0, A = A + Math.imul(l, h$) | 0, v = v + Math.imul(l, u) | 0, v = v + Math.imul(a, h$) | 0, k = k + Math.imul(a, u) | 0, A = A + Math.imul(C, K$) | 0, v = v + Math.imul(C, P$) | 0, v = v + Math.imul(L, K$) | 0, k = k + Math.imul(L, P$) | 0;
        var B6 = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (B6 >>> 26) | 0, B6 &= 67108863, A = Math.imul(t, S$), v = Math.imul(t, V$), v = v + Math.imul(F, S$) | 0, k = Math.imul(F, V$), A = A + Math.imul(d, N$) | 0, v = v + Math.imul(d, D$) | 0, v = v + Math.imul(o, N$) | 0, k = k + Math.imul(o, D$) | 0, A = A + Math.imul(e, L$) | 0, v = v + Math.imul(e, C$) | 0, v = v + Math.imul(_$2, L$) | 0, k = k + Math.imul(_$2, C$) | 0, A = A + Math.imul(m, g$) | 0, v = v + Math.imul(m, E$) | 0, v = v + Math.imul(r, g$) | 0, k = k + Math.imul(r, E$) | 0, A = A + Math.imul(Q, b$) | 0, v = v + Math.imul(Q, y$) | 0, v = v + Math.imul(v$, b$) | 0, k = k + Math.imul(v$, y$) | 0, A = A + Math.imul($$, h$) | 0, v = v + Math.imul($$, u) | 0, v = v + Math.imul(B, h$) | 0, k = k + Math.imul(B, u) | 0, A = A + Math.imul(l, K$) | 0, v = v + Math.imul(l, P$) | 0, v = v + Math.imul(a, K$) | 0, k = k + Math.imul(a, P$) | 0, A = A + Math.imul(C, k$) | 0, v = v + Math.imul(C, G$) | 0, v = v + Math.imul(L, k$) | 0, k = k + Math.imul(L, G$) | 0;
        var t6 = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (t6 >>> 26) | 0, t6 &= 67108863, A = Math.imul(z$, S$), v = Math.imul(z$, V$), v = v + Math.imul(j$, S$) | 0, k = Math.imul(j$, V$), A = A + Math.imul(t, N$) | 0, v = v + Math.imul(t, D$) | 0, v = v + Math.imul(F, N$) | 0, k = k + Math.imul(F, D$) | 0, A = A + Math.imul(d, L$) | 0, v = v + Math.imul(d, C$) | 0, v = v + Math.imul(o, L$) | 0, k = k + Math.imul(o, C$) | 0, A = A + Math.imul(e, g$) | 0, v = v + Math.imul(e, E$) | 0, v = v + Math.imul(_$2, g$) | 0, k = k + Math.imul(_$2, E$) | 0, A = A + Math.imul(m, b$) | 0, v = v + Math.imul(m, y$) | 0, v = v + Math.imul(r, b$) | 0, k = k + Math.imul(r, y$) | 0, A = A + Math.imul(Q, h$) | 0, v = v + Math.imul(Q, u) | 0, v = v + Math.imul(v$, h$) | 0, k = k + Math.imul(v$, u) | 0, A = A + Math.imul($$, K$) | 0, v = v + Math.imul($$, P$) | 0, v = v + Math.imul(B, K$) | 0, k = k + Math.imul(B, P$) | 0, A = A + Math.imul(l, k$) | 0, v = v + Math.imul(l, G$) | 0, v = v + Math.imul(a, k$) | 0, k = k + Math.imul(a, G$) | 0, A = A + Math.imul(C, R$) | 0, v = v + Math.imul(C, u$) | 0, v = v + Math.imul(L, R$) | 0, k = k + Math.imul(L, u$) | 0;
        var U6 = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (U6 >>> 26) | 0, U6 &= 67108863, A = Math.imul(Z$, S$), v = Math.imul(Z$, V$), v = v + Math.imul(A$, S$) | 0, k = Math.imul(A$, V$), A = A + Math.imul(z$, N$) | 0, v = v + Math.imul(z$, D$) | 0, v = v + Math.imul(j$, N$) | 0, k = k + Math.imul(j$, D$) | 0, A = A + Math.imul(t, L$) | 0, v = v + Math.imul(t, C$) | 0, v = v + Math.imul(F, L$) | 0, k = k + Math.imul(F, C$) | 0, A = A + Math.imul(d, g$) | 0, v = v + Math.imul(d, E$) | 0, v = v + Math.imul(o, g$) | 0, k = k + Math.imul(o, E$) | 0, A = A + Math.imul(e, b$) | 0, v = v + Math.imul(e, y$) | 0, v = v + Math.imul(_$2, b$) | 0, k = k + Math.imul(_$2, y$) | 0, A = A + Math.imul(m, h$) | 0, v = v + Math.imul(m, u) | 0, v = v + Math.imul(r, h$) | 0, k = k + Math.imul(r, u) | 0, A = A + Math.imul(Q, K$) | 0, v = v + Math.imul(Q, P$) | 0, v = v + Math.imul(v$, K$) | 0, k = k + Math.imul(v$, P$) | 0, A = A + Math.imul($$, k$) | 0, v = v + Math.imul($$, G$) | 0, v = v + Math.imul(B, k$) | 0, k = k + Math.imul(B, G$) | 0, A = A + Math.imul(l, R$) | 0, v = v + Math.imul(l, u$) | 0, v = v + Math.imul(a, R$) | 0, k = k + Math.imul(a, u$) | 0, A = A + Math.imul(C, I$) | 0, v = v + Math.imul(C, M$) | 0, v = v + Math.imul(L, I$) | 0, k = k + Math.imul(L, M$) | 0;
        var F6 = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (F6 >>> 26) | 0, F6 &= 67108863, A = Math.imul(Z$, N$), v = Math.imul(Z$, D$), v = v + Math.imul(A$, N$) | 0, k = Math.imul(A$, D$), A = A + Math.imul(z$, L$) | 0, v = v + Math.imul(z$, C$) | 0, v = v + Math.imul(j$, L$) | 0, k = k + Math.imul(j$, C$) | 0, A = A + Math.imul(t, g$) | 0, v = v + Math.imul(t, E$) | 0, v = v + Math.imul(F, g$) | 0, k = k + Math.imul(F, E$) | 0, A = A + Math.imul(d, b$) | 0, v = v + Math.imul(d, y$) | 0, v = v + Math.imul(o, b$) | 0, k = k + Math.imul(o, y$) | 0, A = A + Math.imul(e, h$) | 0, v = v + Math.imul(e, u) | 0, v = v + Math.imul(_$2, h$) | 0, k = k + Math.imul(_$2, u) | 0, A = A + Math.imul(m, K$) | 0, v = v + Math.imul(m, P$) | 0, v = v + Math.imul(r, K$) | 0, k = k + Math.imul(r, P$) | 0, A = A + Math.imul(Q, k$) | 0, v = v + Math.imul(Q, G$) | 0, v = v + Math.imul(v$, k$) | 0, k = k + Math.imul(v$, G$) | 0, A = A + Math.imul($$, R$) | 0, v = v + Math.imul($$, u$) | 0, v = v + Math.imul(B, R$) | 0, k = k + Math.imul(B, u$) | 0, A = A + Math.imul(l, I$) | 0, v = v + Math.imul(l, M$) | 0, v = v + Math.imul(a, I$) | 0, k = k + Math.imul(a, M$) | 0;
        var a6 = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (a6 >>> 26) | 0, a6 &= 67108863, A = Math.imul(Z$, L$), v = Math.imul(Z$, C$), v = v + Math.imul(A$, L$) | 0, k = Math.imul(A$, C$), A = A + Math.imul(z$, g$) | 0, v = v + Math.imul(z$, E$) | 0, v = v + Math.imul(j$, g$) | 0, k = k + Math.imul(j$, E$) | 0, A = A + Math.imul(t, b$) | 0, v = v + Math.imul(t, y$) | 0, v = v + Math.imul(F, b$) | 0, k = k + Math.imul(F, y$) | 0, A = A + Math.imul(d, h$) | 0, v = v + Math.imul(d, u) | 0, v = v + Math.imul(o, h$) | 0, k = k + Math.imul(o, u) | 0, A = A + Math.imul(e, K$) | 0, v = v + Math.imul(e, P$) | 0, v = v + Math.imul(_$2, K$) | 0, k = k + Math.imul(_$2, P$) | 0, A = A + Math.imul(m, k$) | 0, v = v + Math.imul(m, G$) | 0, v = v + Math.imul(r, k$) | 0, k = k + Math.imul(r, G$) | 0, A = A + Math.imul(Q, R$) | 0, v = v + Math.imul(Q, u$) | 0, v = v + Math.imul(v$, R$) | 0, k = k + Math.imul(v$, u$) | 0, A = A + Math.imul($$, I$) | 0, v = v + Math.imul($$, M$) | 0, v = v + Math.imul(B, I$) | 0, k = k + Math.imul(B, M$) | 0;
        var Q6 = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (Q6 >>> 26) | 0, Q6 &= 67108863, A = Math.imul(Z$, g$), v = Math.imul(Z$, E$), v = v + Math.imul(A$, g$) | 0, k = Math.imul(A$, E$), A = A + Math.imul(z$, b$) | 0, v = v + Math.imul(z$, y$) | 0, v = v + Math.imul(j$, b$) | 0, k = k + Math.imul(j$, y$) | 0, A = A + Math.imul(t, h$) | 0, v = v + Math.imul(t, u) | 0, v = v + Math.imul(F, h$) | 0, k = k + Math.imul(F, u) | 0, A = A + Math.imul(d, K$) | 0, v = v + Math.imul(d, P$) | 0, v = v + Math.imul(o, K$) | 0, k = k + Math.imul(o, P$) | 0, A = A + Math.imul(e, k$) | 0, v = v + Math.imul(e, G$) | 0, v = v + Math.imul(_$2, k$) | 0, k = k + Math.imul(_$2, G$) | 0, A = A + Math.imul(m, R$) | 0, v = v + Math.imul(m, u$) | 0, v = v + Math.imul(r, R$) | 0, k = k + Math.imul(r, u$) | 0, A = A + Math.imul(Q, I$) | 0, v = v + Math.imul(Q, M$) | 0, v = v + Math.imul(v$, I$) | 0, k = k + Math.imul(v$, M$) | 0;
        var e6 = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (e6 >>> 26) | 0, e6 &= 67108863, A = Math.imul(Z$, b$), v = Math.imul(Z$, y$), v = v + Math.imul(A$, b$) | 0, k = Math.imul(A$, y$), A = A + Math.imul(z$, h$) | 0, v = v + Math.imul(z$, u) | 0, v = v + Math.imul(j$, h$) | 0, k = k + Math.imul(j$, u) | 0, A = A + Math.imul(t, K$) | 0, v = v + Math.imul(t, P$) | 0, v = v + Math.imul(F, K$) | 0, k = k + Math.imul(F, P$) | 0, A = A + Math.imul(d, k$) | 0, v = v + Math.imul(d, G$) | 0, v = v + Math.imul(o, k$) | 0, k = k + Math.imul(o, G$) | 0, A = A + Math.imul(e, R$) | 0, v = v + Math.imul(e, u$) | 0, v = v + Math.imul(_$2, R$) | 0, k = k + Math.imul(_$2, u$) | 0, A = A + Math.imul(m, I$) | 0, v = v + Math.imul(m, M$) | 0, v = v + Math.imul(r, I$) | 0, k = k + Math.imul(r, M$) | 0;
        var s6 = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (s6 >>> 26) | 0, s6 &= 67108863, A = Math.imul(Z$, h$), v = Math.imul(Z$, u), v = v + Math.imul(A$, h$) | 0, k = Math.imul(A$, u), A = A + Math.imul(z$, K$) | 0, v = v + Math.imul(z$, P$) | 0, v = v + Math.imul(j$, K$) | 0, k = k + Math.imul(j$, P$) | 0, A = A + Math.imul(t, k$) | 0, v = v + Math.imul(t, G$) | 0, v = v + Math.imul(F, k$) | 0, k = k + Math.imul(F, G$) | 0, A = A + Math.imul(d, R$) | 0, v = v + Math.imul(d, u$) | 0, v = v + Math.imul(o, R$) | 0, k = k + Math.imul(o, u$) | 0, A = A + Math.imul(e, I$) | 0, v = v + Math.imul(e, M$) | 0, v = v + Math.imul(_$2, I$) | 0, k = k + Math.imul(_$2, M$) | 0;
        var $q = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + ($q >>> 26) | 0, $q &= 67108863, A = Math.imul(Z$, K$), v = Math.imul(Z$, P$), v = v + Math.imul(A$, K$) | 0, k = Math.imul(A$, P$), A = A + Math.imul(z$, k$) | 0, v = v + Math.imul(z$, G$) | 0, v = v + Math.imul(j$, k$) | 0, k = k + Math.imul(j$, G$) | 0, A = A + Math.imul(t, R$) | 0, v = v + Math.imul(t, u$) | 0, v = v + Math.imul(F, R$) | 0, k = k + Math.imul(F, u$) | 0, A = A + Math.imul(d, I$) | 0, v = v + Math.imul(d, M$) | 0, v = v + Math.imul(o, I$) | 0, k = k + Math.imul(o, M$) | 0;
        var qq = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (qq >>> 26) | 0, qq &= 67108863, A = Math.imul(Z$, k$), v = Math.imul(Z$, G$), v = v + Math.imul(A$, k$) | 0, k = Math.imul(A$, G$), A = A + Math.imul(z$, R$) | 0, v = v + Math.imul(z$, u$) | 0, v = v + Math.imul(j$, R$) | 0, k = k + Math.imul(j$, u$) | 0, A = A + Math.imul(t, I$) | 0, v = v + Math.imul(t, M$) | 0, v = v + Math.imul(F, I$) | 0, k = k + Math.imul(F, M$) | 0;
        var Kq = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (Kq >>> 26) | 0, Kq &= 67108863, A = Math.imul(Z$, R$), v = Math.imul(Z$, u$), v = v + Math.imul(A$, R$) | 0, k = Math.imul(A$, u$), A = A + Math.imul(z$, I$) | 0, v = v + Math.imul(z$, M$) | 0, v = v + Math.imul(j$, I$) | 0, k = k + Math.imul(j$, M$) | 0;
        var _q = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (_q >>> 26) | 0, _q &= 67108863, A = Math.imul(Z$, I$), v = Math.imul(Z$, M$), v = v + Math.imul(A$, I$) | 0, k = Math.imul(A$, M$);
        var Pq = (S + A | 0) + ((v & 8191) << 13) | 0;
        if (S = (k + (v >>> 13) | 0) + (Pq >>> 26) | 0, Pq &= 67108863, G[0] = p6, G[1] = H6, G[2] = v6, G[3] = C6, G[4] = S6, G[5] = i6, G[6] = B6, G[7] = t6, G[8] = U6, G[9] = F6, G[10] = a6, G[11] = Q6, G[12] = e6, G[13] = s6, G[14] = $q, G[15] = qq, G[16] = Kq, G[17] = _q, G[18] = Pq, S !== 0) G[19] = S, Z.length++;
        return Z;
      };
      if (!Math.imul) E = h;
      function I(j, H, Z) {
        Z.negative = H.negative ^ j.negative, Z.length = j.length + H.length;
        var W = 0, w = 0;
        for (var G = 0; G < Z.length - 1; G++) {
          var S = w;
          w = 0;
          var A = W & 67108863, v = Math.min(G, H.length - 1);
          for (var k = Math.max(0, G - j.length + 1); k <= v; k++) {
            var R = G - k, C = j.words[R] | 0, L = H.words[k] | 0, x = C * L, l = x & 67108863;
            S = S + (x / 67108864 | 0) | 0, l = l + A | 0, A = l & 67108863, S = S + (l >>> 26) | 0, w += S >>> 26, S &= 67108863;
          }
          Z.words[G] = A, W = S, S = w;
        }
        if (W !== 0) Z.words[G] = W;
        else Z.length--;
        return Z.strip();
      }
      function D(j, H, Z) {
        var W = new g();
        return W.mulp(j, H, Z);
      }
      O.prototype.mulTo = function(j, H) {
        var Z, W = this.length + j.length;
        if (this.length === 10 && j.length === 10) Z = E(this, j, H);
        else if (W < 63) Z = h(this, j, H);
        else if (W < 1024) Z = I(this, j, H);
        else Z = D(this, j, H);
        return Z;
      };
      function g(j, H) {
        this.x = j, this.y = H;
      }
      g.prototype.makeRBT = function(j) {
        var H = Array(j), Z = O.prototype._countBits(j) - 1;
        for (var W = 0; W < j; W++) H[W] = this.revBin(W, Z, j);
        return H;
      }, g.prototype.revBin = function(j, H, Z) {
        if (j === 0 || j === Z - 1) return j;
        var W = 0;
        for (var w = 0; w < H; w++) W |= (j & 1) << H - w - 1, j >>= 1;
        return W;
      }, g.prototype.permute = function(j, H, Z, W, w, G) {
        for (var S = 0; S < G; S++) W[S] = H[j[S]], w[S] = Z[j[S]];
      }, g.prototype.transform = function(j, H, Z, W, w, G) {
        this.permute(G, j, H, Z, W, w);
        for (var S = 1; S < w; S <<= 1) {
          var A = S << 1, v = Math.cos(2 * Math.PI / A), k = Math.sin(2 * Math.PI / A);
          for (var R = 0; R < w; R += A) {
            var C = v, L = k;
            for (var x = 0; x < S; x++) {
              var l = Z[R + x], a = W[R + x], f$ = Z[R + x + S], $$ = W[R + x + S], B = C * f$ - L * $$;
              if ($$ = C * $$ + L * f$, f$ = B, Z[R + x] = l + f$, W[R + x] = a + $$, Z[R + x + S] = l - f$, W[R + x + S] = a - $$, x !== A) B = v * C - k * L, L = v * L + k * C, C = B;
            }
          }
        }
      }, g.prototype.guessLen13b = function(j, H) {
        var Z = Math.max(H, j) | 1, W = Z & 1, w = 0;
        for (Z = Z / 2 | 0; Z; Z = Z >>> 1) w++;
        return 1 << w + 1 + W;
      }, g.prototype.conjugate = function(j, H, Z) {
        if (Z <= 1) return;
        for (var W = 0; W < Z / 2; W++) {
          var w = j[W];
          j[W] = j[Z - W - 1], j[Z - W - 1] = w, w = H[W], H[W] = -H[Z - W - 1], H[Z - W - 1] = -w;
        }
      }, g.prototype.normalize13b = function(j, H) {
        var Z = 0;
        for (var W = 0; W < H / 2; W++) {
          var w = Math.round(j[2 * W + 1] / H) * 8192 + Math.round(j[2 * W] / H) + Z;
          if (j[W] = w & 67108863, w < 67108864) Z = 0;
          else Z = w / 67108864 | 0;
        }
        return j;
      }, g.prototype.convert13b = function(j, H, Z, W) {
        var w = 0;
        for (var G = 0; G < H; G++) w = w + (j[G] | 0), Z[2 * G] = w & 8191, w = w >>> 13, Z[2 * G + 1] = w & 8191, w = w >>> 13;
        for (G = 2 * H; G < W; ++G) Z[G] = 0;
        _(w === 0), _((w & -8192) === 0);
      }, g.prototype.stub = function(j) {
        var H = Array(j);
        for (var Z = 0; Z < j; Z++) H[Z] = 0;
        return H;
      }, g.prototype.mulp = function(j, H, Z) {
        var W = 2 * this.guessLen13b(j.length, H.length), w = this.makeRBT(W), G = this.stub(W), S = Array(W), A = Array(W), v = Array(W), k = Array(W), R = Array(W), C = Array(W), L = Z.words;
        L.length = W, this.convert13b(j.words, j.length, S, W), this.convert13b(H.words, H.length, k, W), this.transform(S, G, A, v, W, w), this.transform(k, G, R, C, W, w);
        for (var x = 0; x < W; x++) {
          var l = A[x] * R[x] - v[x] * C[x];
          v[x] = A[x] * C[x] + v[x] * R[x], A[x] = l;
        }
        return this.conjugate(A, v, W), this.transform(A, v, L, G, W, w), this.conjugate(L, G, W), this.normalize13b(L, W), Z.negative = j.negative ^ H.negative, Z.length = j.length + H.length, Z.strip();
      }, O.prototype.mul = function(j) {
        var H = new O(null);
        return H.words = Array(this.length + j.length), this.mulTo(j, H);
      }, O.prototype.mulf = function(j) {
        var H = new O(null);
        return H.words = Array(this.length + j.length), D(this, j, H);
      }, O.prototype.imul = function(j) {
        return this.clone().mulTo(j, this);
      }, O.prototype.imuln = function(j) {
        _(typeof j === "number"), _(j < 67108864);
        var H = 0;
        for (var Z = 0; Z < this.length; Z++) {
          var W = (this.words[Z] | 0) * j, w = (W & 67108863) + (H & 67108863);
          H >>= 26, H += W / 67108864 | 0, H += w >>> 26, this.words[Z] = w & 67108863;
        }
        if (H !== 0) this.words[Z] = H, this.length++;
        return this.length = j === 0 ? 1 : this.length, this;
      }, O.prototype.muln = function(j) {
        return this.clone().imuln(j);
      }, O.prototype.sqr = function() {
        return this.mul(this);
      }, O.prototype.isqr = function() {
        return this.imul(this.clone());
      }, O.prototype.pow = function(j) {
        var H = N(j);
        if (H.length === 0) return new O(1);
        var Z = this;
        for (var W = 0; W < H.length; W++, Z = Z.sqr()) if (H[W] !== 0) break;
        if (++W < H.length) for (var w = Z.sqr(); W < H.length; W++, w = w.sqr()) {
          if (H[W] === 0) continue;
          Z = Z.mul(w);
        }
        return Z;
      }, O.prototype.iushln = function(j) {
        _(typeof j === "number" && j >= 0);
        var H = j % 26, Z = (j - H) / 26, W = 67108863 >>> 26 - H << 26 - H, w;
        if (H !== 0) {
          var G = 0;
          for (w = 0; w < this.length; w++) {
            var S = this.words[w] & W, A = (this.words[w] | 0) - S << H;
            this.words[w] = A | G, G = S >>> 26 - H;
          }
          if (G) this.words[w] = G, this.length++;
        }
        if (Z !== 0) {
          for (w = this.length - 1; w >= 0; w--) this.words[w + Z] = this.words[w];
          for (w = 0; w < Z; w++) this.words[w] = 0;
          this.length += Z;
        }
        return this.strip();
      }, O.prototype.ishln = function(j) {
        return _(this.negative === 0), this.iushln(j);
      }, O.prototype.iushrn = function(j, H, Z) {
        _(typeof j === "number" && j >= 0);
        var W;
        if (H) W = (H - H % 26) / 26;
        else W = 0;
        var w = j % 26, G = Math.min((j - w) / 26, this.length), S = 67108863 ^ 67108863 >>> w << w, A = Z;
        if (W -= G, W = Math.max(0, W), A) {
          for (var v = 0; v < G; v++) A.words[v] = this.words[v];
          A.length = G;
        }
        if (G === 0) ;
        else if (this.length > G) {
          this.length -= G;
          for (v = 0; v < this.length; v++) this.words[v] = this.words[v + G];
        } else this.words[0] = 0, this.length = 1;
        var k = 0;
        for (v = this.length - 1; v >= 0 && (k !== 0 || v >= W); v--) {
          var R = this.words[v] | 0;
          this.words[v] = k << 26 - w | R >>> w, k = R & S;
        }
        if (A && k !== 0) A.words[A.length++] = k;
        if (this.length === 0) this.words[0] = 0, this.length = 1;
        return this.strip();
      }, O.prototype.ishrn = function(j, H, Z) {
        return _(this.negative === 0), this.iushrn(j, H, Z);
      }, O.prototype.shln = function(j) {
        return this.clone().ishln(j);
      }, O.prototype.ushln = function(j) {
        return this.clone().iushln(j);
      }, O.prototype.shrn = function(j) {
        return this.clone().ishrn(j);
      }, O.prototype.ushrn = function(j) {
        return this.clone().iushrn(j);
      }, O.prototype.testn = function(j) {
        _(typeof j === "number" && j >= 0);
        var H = j % 26, Z = (j - H) / 26, W = 1 << H;
        if (this.length <= Z) return false;
        var w = this.words[Z];
        return !!(w & W);
      }, O.prototype.imaskn = function(j) {
        _(typeof j === "number" && j >= 0);
        var H = j % 26, Z = (j - H) / 26;
        if (_(this.negative === 0, "imaskn works only with positive numbers"), this.length <= Z) return this;
        if (H !== 0) Z++;
        if (this.length = Math.min(Z, this.length), H !== 0) {
          var W = 67108863 ^ 67108863 >>> H << H;
          this.words[this.length - 1] &= W;
        }
        return this.strip();
      }, O.prototype.maskn = function(j) {
        return this.clone().imaskn(j);
      }, O.prototype.iaddn = function(j) {
        if (_(typeof j === "number"), _(j < 67108864), j < 0) return this.isubn(-j);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) < j) return this.words[0] = j - (this.words[0] | 0), this.negative = 0, this;
          return this.negative = 0, this.isubn(j), this.negative = 1, this;
        }
        return this._iaddn(j);
      }, O.prototype._iaddn = function(j) {
        this.words[0] += j;
        for (var H = 0; H < this.length && this.words[H] >= 67108864; H++) if (this.words[H] -= 67108864, H === this.length - 1) this.words[H + 1] = 1;
        else this.words[H + 1]++;
        return this.length = Math.max(this.length, H + 1), this;
      }, O.prototype.isubn = function(j) {
        if (_(typeof j === "number"), _(j < 67108864), j < 0) return this.iaddn(-j);
        if (this.negative !== 0) return this.negative = 0, this.iaddn(j), this.negative = 1, this;
        if (this.words[0] -= j, this.length === 1 && this.words[0] < 0) this.words[0] = -this.words[0], this.negative = 1;
        else for (var H = 0; H < this.length && this.words[H] < 0; H++) this.words[H] += 67108864, this.words[H + 1] -= 1;
        return this.strip();
      }, O.prototype.addn = function(j) {
        return this.clone().iaddn(j);
      }, O.prototype.subn = function(j) {
        return this.clone().isubn(j);
      }, O.prototype.iabs = function() {
        return this.negative = 0, this;
      }, O.prototype.abs = function() {
        return this.clone().iabs();
      }, O.prototype._ishlnsubmul = function(j, H, Z) {
        var W = j.length + Z, w;
        this._expand(W);
        var G, S = 0;
        for (w = 0; w < j.length; w++) {
          G = (this.words[w + Z] | 0) + S;
          var A = (j.words[w] | 0) * H;
          G -= A & 67108863, S = (G >> 26) - (A / 67108864 | 0), this.words[w + Z] = G & 67108863;
        }
        for (; w < this.length - Z; w++) G = (this.words[w + Z] | 0) + S, S = G >> 26, this.words[w + Z] = G & 67108863;
        if (S === 0) return this.strip();
        _(S === -1), S = 0;
        for (w = 0; w < this.length; w++) G = -(this.words[w] | 0) + S, S = G >> 26, this.words[w] = G & 67108863;
        return this.negative = 1, this.strip();
      }, O.prototype._wordDiv = function(j, H) {
        var Z = this.length - j.length, W = this.clone(), w = j, G = w.words[w.length - 1] | 0, S = this._countBits(G);
        if (Z = 26 - S, Z !== 0) w = w.ushln(Z), W.iushln(Z), G = w.words[w.length - 1] | 0;
        var A = W.length - w.length, v;
        if (H !== "mod") {
          v = new O(null), v.length = A + 1, v.words = Array(v.length);
          for (var k = 0; k < v.length; k++) v.words[k] = 0;
        }
        var R = W.clone()._ishlnsubmul(w, 1, A);
        if (R.negative === 0) {
          if (W = R, v) v.words[A] = 1;
        }
        for (var C = A - 1; C >= 0; C--) {
          var L = (W.words[w.length + C] | 0) * 67108864 + (W.words[w.length + C - 1] | 0);
          L = Math.min(L / G | 0, 67108863), W._ishlnsubmul(w, L, C);
          while (W.negative !== 0) if (L--, W.negative = 0, W._ishlnsubmul(w, 1, C), !W.isZero()) W.negative ^= 1;
          if (v) v.words[C] = L;
        }
        if (v) v.strip();
        if (W.strip(), H !== "div" && Z !== 0) W.iushrn(Z);
        return { div: v || null, mod: W };
      }, O.prototype.divmod = function(j, H, Z) {
        if (_(!j.isZero()), this.isZero()) return { div: new O(0), mod: new O(0) };
        var W, w, G;
        if (this.negative !== 0 && j.negative === 0) {
          if (G = this.neg().divmod(j, H), H !== "mod") W = G.div.neg();
          if (H !== "div") {
            if (w = G.mod.neg(), Z && w.negative !== 0) w.iadd(j);
          }
          return { div: W, mod: w };
        }
        if (this.negative === 0 && j.negative !== 0) {
          if (G = this.divmod(j.neg(), H), H !== "mod") W = G.div.neg();
          return { div: W, mod: G.mod };
        }
        if ((this.negative & j.negative) !== 0) {
          if (G = this.neg().divmod(j.neg(), H), H !== "div") {
            if (w = G.mod.neg(), Z && w.negative !== 0) w.isub(j);
          }
          return { div: G.div, mod: w };
        }
        if (j.length > this.length || this.cmp(j) < 0) return { div: new O(0), mod: this };
        if (j.length === 1) {
          if (H === "div") return { div: this.divn(j.words[0]), mod: null };
          if (H === "mod") return { div: null, mod: new O(this.modn(j.words[0])) };
          return { div: this.divn(j.words[0]), mod: new O(this.modn(j.words[0])) };
        }
        return this._wordDiv(j, H);
      }, O.prototype.div = function(j) {
        return this.divmod(j, "div", false).div;
      }, O.prototype.mod = function(j) {
        return this.divmod(j, "mod", false).mod;
      }, O.prototype.umod = function(j) {
        return this.divmod(j, "mod", true).mod;
      }, O.prototype.divRound = function(j) {
        var H = this.divmod(j);
        if (H.mod.isZero()) return H.div;
        var Z = H.div.negative !== 0 ? H.mod.isub(j) : H.mod, W = j.ushrn(1), w = j.andln(1), G = Z.cmp(W);
        if (G < 0 || w === 1 && G === 0) return H.div;
        return H.div.negative !== 0 ? H.div.isubn(1) : H.div.iaddn(1);
      }, O.prototype.modn = function(j) {
        _(j <= 67108863);
        var H = 67108864 % j, Z = 0;
        for (var W = this.length - 1; W >= 0; W--) Z = (H * Z + (this.words[W] | 0)) % j;
        return Z;
      }, O.prototype.idivn = function(j) {
        _(j <= 67108863);
        var H = 0;
        for (var Z = this.length - 1; Z >= 0; Z--) {
          var W = (this.words[Z] | 0) + H * 67108864;
          this.words[Z] = W / j | 0, H = W % j;
        }
        return this.strip();
      }, O.prototype.divn = function(j) {
        return this.clone().idivn(j);
      }, O.prototype.egcd = function(j) {
        _(j.negative === 0), _(!j.isZero());
        var H = this, Z = j.clone();
        if (H.negative !== 0) H = H.umod(j);
        else H = H.clone();
        var W = new O(1), w = new O(0), G = new O(0), S = new O(1), A = 0;
        while (H.isEven() && Z.isEven()) H.iushrn(1), Z.iushrn(1), ++A;
        var v = Z.clone(), k = H.clone();
        while (!H.isZero()) {
          for (var R = 0, C = 1; (H.words[0] & C) === 0 && R < 26; ++R, C <<= 1) ;
          if (R > 0) {
            H.iushrn(R);
            while (R-- > 0) {
              if (W.isOdd() || w.isOdd()) W.iadd(v), w.isub(k);
              W.iushrn(1), w.iushrn(1);
            }
          }
          for (var L = 0, x = 1; (Z.words[0] & x) === 0 && L < 26; ++L, x <<= 1) ;
          if (L > 0) {
            Z.iushrn(L);
            while (L-- > 0) {
              if (G.isOdd() || S.isOdd()) G.iadd(v), S.isub(k);
              G.iushrn(1), S.iushrn(1);
            }
          }
          if (H.cmp(Z) >= 0) H.isub(Z), W.isub(G), w.isub(S);
          else Z.isub(H), G.isub(W), S.isub(w);
        }
        return { a: G, b: S, gcd: Z.iushln(A) };
      }, O.prototype._invmp = function(j) {
        _(j.negative === 0), _(!j.isZero());
        var H = this, Z = j.clone();
        if (H.negative !== 0) H = H.umod(j);
        else H = H.clone();
        var W = new O(1), w = new O(0), G = Z.clone();
        while (H.cmpn(1) > 0 && Z.cmpn(1) > 0) {
          for (var S = 0, A = 1; (H.words[0] & A) === 0 && S < 26; ++S, A <<= 1) ;
          if (S > 0) {
            H.iushrn(S);
            while (S-- > 0) {
              if (W.isOdd()) W.iadd(G);
              W.iushrn(1);
            }
          }
          for (var v = 0, k = 1; (Z.words[0] & k) === 0 && v < 26; ++v, k <<= 1) ;
          if (v > 0) {
            Z.iushrn(v);
            while (v-- > 0) {
              if (w.isOdd()) w.iadd(G);
              w.iushrn(1);
            }
          }
          if (H.cmp(Z) >= 0) H.isub(Z), W.isub(w);
          else Z.isub(H), w.isub(W);
        }
        var R;
        if (H.cmpn(1) === 0) R = W;
        else R = w;
        if (R.cmpn(0) < 0) R.iadd(j);
        return R;
      }, O.prototype.gcd = function(j) {
        if (this.isZero()) return j.abs();
        if (j.isZero()) return this.abs();
        var H = this.clone(), Z = j.clone();
        H.negative = 0, Z.negative = 0;
        for (var W = 0; H.isEven() && Z.isEven(); W++) H.iushrn(1), Z.iushrn(1);
        do {
          while (H.isEven()) H.iushrn(1);
          while (Z.isEven()) Z.iushrn(1);
          var w = H.cmp(Z);
          if (w < 0) {
            var G = H;
            H = Z, Z = G;
          } else if (w === 0 || Z.cmpn(1) === 0) break;
          H.isub(Z);
        } while (true);
        return Z.iushln(W);
      }, O.prototype.invm = function(j) {
        return this.egcd(j).a.umod(j);
      }, O.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, O.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, O.prototype.andln = function(j) {
        return this.words[0] & j;
      }, O.prototype.bincn = function(j) {
        _(typeof j === "number");
        var H = j % 26, Z = (j - H) / 26, W = 1 << H;
        if (this.length <= Z) return this._expand(Z + 1), this.words[Z] |= W, this;
        var w = W;
        for (var G = Z; w !== 0 && G < this.length; G++) {
          var S = this.words[G] | 0;
          S += w, w = S >>> 26, S &= 67108863, this.words[G] = S;
        }
        if (w !== 0) this.words[G] = w, this.length++;
        return this;
      }, O.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, O.prototype.cmpn = function(j) {
        var H = j < 0;
        if (this.negative !== 0 && !H) return -1;
        if (this.negative === 0 && H) return 1;
        this.strip();
        var Z;
        if (this.length > 1) Z = 1;
        else {
          if (H) j = -j;
          _(j <= 67108863, "Number is too big");
          var W = this.words[0] | 0;
          Z = W === j ? 0 : W < j ? -1 : 1;
        }
        if (this.negative !== 0) return -Z | 0;
        return Z;
      }, O.prototype.cmp = function(j) {
        if (this.negative !== 0 && j.negative === 0) return -1;
        if (this.negative === 0 && j.negative !== 0) return 1;
        var H = this.ucmp(j);
        if (this.negative !== 0) return -H | 0;
        return H;
      }, O.prototype.ucmp = function(j) {
        if (this.length > j.length) return 1;
        if (this.length < j.length) return -1;
        var H = 0;
        for (var Z = this.length - 1; Z >= 0; Z--) {
          var W = this.words[Z] | 0, w = j.words[Z] | 0;
          if (W === w) continue;
          if (W < w) H = -1;
          else if (W > w) H = 1;
          break;
        }
        return H;
      }, O.prototype.gtn = function(j) {
        return this.cmpn(j) === 1;
      }, O.prototype.gt = function(j) {
        return this.cmp(j) === 1;
      }, O.prototype.gten = function(j) {
        return this.cmpn(j) >= 0;
      }, O.prototype.gte = function(j) {
        return this.cmp(j) >= 0;
      }, O.prototype.ltn = function(j) {
        return this.cmpn(j) === -1;
      }, O.prototype.lt = function(j) {
        return this.cmp(j) === -1;
      }, O.prototype.lten = function(j) {
        return this.cmpn(j) <= 0;
      }, O.prototype.lte = function(j) {
        return this.cmp(j) <= 0;
      }, O.prototype.eqn = function(j) {
        return this.cmpn(j) === 0;
      }, O.prototype.eq = function(j) {
        return this.cmp(j) === 0;
      }, O.red = function(j) {
        return new c(j);
      }, O.prototype.toRed = function(j) {
        return _(!this.red, "Already a number in reduction context"), _(this.negative === 0, "red works only with positives"), j.convertTo(this)._forceRed(j);
      }, O.prototype.fromRed = function() {
        return _(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, O.prototype._forceRed = function(j) {
        return this.red = j, this;
      }, O.prototype.forceRed = function(j) {
        return _(!this.red, "Already a number in reduction context"), this._forceRed(j);
      }, O.prototype.redAdd = function(j) {
        return _(this.red, "redAdd works only with red numbers"), this.red.add(this, j);
      }, O.prototype.redIAdd = function(j) {
        return _(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, j);
      }, O.prototype.redSub = function(j) {
        return _(this.red, "redSub works only with red numbers"), this.red.sub(this, j);
      }, O.prototype.redISub = function(j) {
        return _(this.red, "redISub works only with red numbers"), this.red.isub(this, j);
      }, O.prototype.redShl = function(j) {
        return _(this.red, "redShl works only with red numbers"), this.red.shl(this, j);
      }, O.prototype.redMul = function(j) {
        return _(this.red, "redMul works only with red numbers"), this.red._verify2(this, j), this.red.mul(this, j);
      }, O.prototype.redIMul = function(j) {
        return _(this.red, "redMul works only with red numbers"), this.red._verify2(this, j), this.red.imul(this, j);
      }, O.prototype.redSqr = function() {
        return _(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, O.prototype.redISqr = function() {
        return _(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, O.prototype.redSqrt = function() {
        return _(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, O.prototype.redInvm = function() {
        return _(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, O.prototype.redNeg = function() {
        return _(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, O.prototype.redPow = function(j) {
        return _(this.red && !j.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, j);
      };
      var b = { k256: null, p224: null, p192: null, p25519: null };
      function y(j, H) {
        this.name = j, this.p = new O(H, 16), this.n = this.p.bitLength(), this.k = new O(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      y.prototype._tmp = function() {
        var j = new O(null);
        return j.words = Array(Math.ceil(this.n / 13)), j;
      }, y.prototype.ireduce = function(j) {
        var H = j, Z;
        do
          this.split(H, this.tmp), H = this.imulK(H), H = H.iadd(this.tmp), Z = H.bitLength();
        while (Z > this.n);
        var W = Z < this.n ? -1 : H.ucmp(this.p);
        if (W === 0) H.words[0] = 0, H.length = 1;
        else if (W > 0) H.isub(this.p);
        else if (H.strip !== void 0) H.strip();
        else H._strip();
        return H;
      }, y.prototype.split = function(j, H) {
        j.iushrn(this.n, 0, H);
      }, y.prototype.imulK = function(j) {
        return j.imul(this.k);
      };
      function p() {
        y.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
      }
      Y(p, y), p.prototype.split = function(j, H) {
        var Z = 4194303, W = Math.min(j.length, 9);
        for (var w = 0; w < W; w++) H.words[w] = j.words[w];
        if (H.length = W, j.length <= 9) {
          j.words[0] = 0, j.length = 1;
          return;
        }
        var G = j.words[9];
        H.words[H.length++] = G & Z;
        for (w = 10; w < j.length; w++) {
          var S = j.words[w] | 0;
          j.words[w - 10] = (S & Z) << 4 | G >>> 22, G = S;
        }
        if (G >>>= 22, j.words[w - 10] = G, G === 0 && j.length > 10) j.length -= 10;
        else j.length -= 9;
      }, p.prototype.imulK = function(j) {
        j.words[j.length] = 0, j.words[j.length + 1] = 0, j.length += 2;
        var H = 0;
        for (var Z = 0; Z < j.length; Z++) {
          var W = j.words[Z] | 0;
          H += W * 977, j.words[Z] = H & 67108863, H = W * 64 + (H / 67108864 | 0);
        }
        if (j.words[j.length - 1] === 0) {
          if (j.length--, j.words[j.length - 1] === 0) j.length--;
        }
        return j;
      };
      function n() {
        y.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
      }
      Y(n, y);
      function s() {
        y.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
      }
      Y(s, y);
      function q$() {
        y.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
      }
      Y(q$, y), q$.prototype.imulK = function(j) {
        var H = 0;
        for (var Z = 0; Z < j.length; Z++) {
          var W = (j.words[Z] | 0) * 19 + H, w = W & 67108863;
          W >>>= 26, j.words[Z] = w, H = W;
        }
        if (H !== 0) j.words[j.length++] = H;
        return j;
      }, O._prime = function(j) {
        if (b[j]) return b[j];
        var H;
        if (j === "k256") H = new p();
        else if (j === "p224") H = new n();
        else if (j === "p192") H = new s();
        else if (j === "p25519") H = new q$();
        else throw Error("Unknown prime " + j);
        return b[j] = H, H;
      };
      function c(j) {
        if (typeof j === "string") {
          var H = O._prime(j);
          this.m = H.p, this.prime = H;
        } else _(j.gtn(1), "modulus must be greater than 1"), this.m = j, this.prime = null;
      }
      c.prototype._verify1 = function(j) {
        _(j.negative === 0, "red works only with positives"), _(j.red, "red works only with red numbers");
      }, c.prototype._verify2 = function(j, H) {
        _((j.negative | H.negative) === 0, "red works only with positives"), _(j.red && j.red === H.red, "red works only with red numbers");
      }, c.prototype.imod = function(j) {
        if (this.prime) return this.prime.ireduce(j)._forceRed(this);
        return j.umod(this.m)._forceRed(this);
      }, c.prototype.neg = function(j) {
        if (j.isZero()) return j.clone();
        return this.m.sub(j)._forceRed(this);
      }, c.prototype.add = function(j, H) {
        this._verify2(j, H);
        var Z = j.add(H);
        if (Z.cmp(this.m) >= 0) Z.isub(this.m);
        return Z._forceRed(this);
      }, c.prototype.iadd = function(j, H) {
        this._verify2(j, H);
        var Z = j.iadd(H);
        if (Z.cmp(this.m) >= 0) Z.isub(this.m);
        return Z;
      }, c.prototype.sub = function(j, H) {
        this._verify2(j, H);
        var Z = j.sub(H);
        if (Z.cmpn(0) < 0) Z.iadd(this.m);
        return Z._forceRed(this);
      }, c.prototype.isub = function(j, H) {
        this._verify2(j, H);
        var Z = j.isub(H);
        if (Z.cmpn(0) < 0) Z.iadd(this.m);
        return Z;
      }, c.prototype.shl = function(j, H) {
        return this._verify1(j), this.imod(j.ushln(H));
      }, c.prototype.imul = function(j, H) {
        return this._verify2(j, H), this.imod(j.imul(H));
      }, c.prototype.mul = function(j, H) {
        return this._verify2(j, H), this.imod(j.mul(H));
      }, c.prototype.isqr = function(j) {
        return this.imul(j, j.clone());
      }, c.prototype.sqr = function(j) {
        return this.mul(j, j);
      }, c.prototype.sqrt = function(j) {
        if (j.isZero()) return j.clone();
        var H = this.m.andln(3);
        if (_(H % 2 === 1), H === 3) {
          var Z = this.m.add(new O(1)).iushrn(2);
          return this.pow(j, Z);
        }
        var W = this.m.subn(1), w = 0;
        while (!W.isZero() && W.andln(1) === 0) w++, W.iushrn(1);
        _(!W.isZero());
        var G = new O(1).toRed(this), S = G.redNeg(), A = this.m.subn(1).iushrn(1), v = this.m.bitLength();
        v = new O(2 * v * v).toRed(this);
        while (this.pow(v, A).cmp(S) !== 0) v.redIAdd(S);
        var k = this.pow(v, W), R = this.pow(j, W.addn(1).iushrn(1)), C = this.pow(j, W), L = w;
        while (C.cmp(G) !== 0) {
          var x = C;
          for (var l = 0; x.cmp(G) !== 0; l++) x = x.redSqr();
          _(l < L);
          var a = this.pow(k, new O(1).iushln(L - l - 1));
          R = R.redMul(a), k = a.redSqr(), C = C.redMul(k), L = l;
        }
        return R;
      }, c.prototype.invm = function(j) {
        var H = j._invmp(this.m);
        if (H.negative !== 0) return H.negative = 0, this.imod(H).redNeg();
        else return this.imod(H);
      }, c.prototype.pow = function(j, H) {
        if (H.isZero()) return new O(1).toRed(this);
        if (H.cmpn(1) === 0) return j.clone();
        var Z = 4, W = Array(1 << Z);
        W[0] = new O(1).toRed(this), W[1] = j;
        for (var w = 2; w < W.length; w++) W[w] = this.mul(W[w - 1], j);
        var G = W[0], S = 0, A = 0, v = H.bitLength() % 26;
        if (v === 0) v = 26;
        for (w = H.length - 1; w >= 0; w--) {
          var k = H.words[w];
          for (var R = v - 1; R >= 0; R--) {
            var C = k >> R & 1;
            if (G !== W[0]) G = this.sqr(G);
            if (C === 0 && S === 0) {
              A = 0;
              continue;
            }
            if (S <<= 1, S |= C, A++, A !== Z && (w !== 0 || R !== 0)) continue;
            G = this.mul(G, W[S]), A = 0, S = 0;
          }
          v = 26;
        }
        return G;
      }, c.prototype.convertTo = function(j) {
        var H = j.umod(this.m);
        return H === j ? H.clone() : H;
      }, c.prototype.convertFrom = function(j) {
        var H = j.clone();
        return H.red = null, H;
      }, O.mont = function(j) {
        return new U(j);
      };
      function U(j) {
        if (c.call(this, j), this.shift = this.m.bitLength(), this.shift % 26 !== 0) this.shift += 26 - this.shift % 26;
        this.r = new O(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      Y(U, c), U.prototype.convertTo = function(j) {
        return this.imod(j.ushln(this.shift));
      }, U.prototype.convertFrom = function(j) {
        var H = this.imod(j.mul(this.rinv));
        return H.red = null, H;
      }, U.prototype.imul = function(j, H) {
        if (j.isZero() || H.isZero()) return j.words[0] = 0, j.length = 1, j;
        var Z = j.imul(H), W = Z.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), w = Z.isub(W).iushrn(this.shift), G = w;
        if (w.cmp(this.m) >= 0) G = w.isub(this.m);
        else if (w.cmpn(0) < 0) G = w.iadd(this.m);
        return G._forceRed(this);
      }, U.prototype.mul = function(j, H) {
        if (j.isZero() || H.isZero()) return new O(0)._forceRed(this);
        var Z = j.mul(H), W = Z.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), w = Z.isub(W).iushrn(this.shift), G = w;
        if (w.cmp(this.m) >= 0) G = w.isub(this.m);
        else if (w.cmpn(0) < 0) G = w.iadd(this.m);
        return G._forceRed(this);
      }, U.prototype.invm = function(j) {
        var H = this.imod(j._invmp(this.m).mul(this.r2));
        return H._forceRed(this);
      };
    })(typeof q > "u" || q, $18);
  }), $_ = r$(($18, q) => {
    q.exports = K;
    function K(P, _) {
      if (!P) throw Error(_ || "Assertion failed");
    }
    K.equal = function(P, _, Y) {
      if (P != _) throw Error(Y || "Assertion failed: " + P + " != " + _);
    };
  }), K0 = r$(($18) => {
    var q = $18;
    function K(Y, O) {
      if (Array.isArray(Y)) return Y.slice();
      if (!Y) return [];
      var z = [];
      if (typeof Y !== "string") {
        for (var J = 0; J < Y.length; J++) z[J] = Y[J] | 0;
        return z;
      }
      if (O === "hex") {
        if (Y = Y.replace(/[^a-z0-9]+/ig, ""), Y.length % 2 !== 0) Y = "0" + Y;
        for (var J = 0; J < Y.length; J += 2) z.push(parseInt(Y[J] + Y[J + 1], 16));
      } else for (var J = 0; J < Y.length; J++) {
        var T = Y.charCodeAt(J), X = T >> 8, f = T & 255;
        if (X) z.push(X, f);
        else z.push(f);
      }
      return z;
    }
    q.toArray = K;
    function P(Y) {
      if (Y.length === 1) return "0" + Y;
      else return Y;
    }
    q.zero2 = P;
    function _(Y) {
      var O = "";
      for (var z = 0; z < Y.length; z++) O += P(Y[z].toString(16));
      return O;
    }
    q.toHex = _, q.encode = function(Y, O) {
      if (O === "hex") return _(Y);
      else return Y;
    };
  }), S8 = r$(($18) => {
    var q = $18, K = MK(), P = $_(), _ = K0();
    q.assert = P, q.toArray = _.toArray, q.zero2 = _.zero2, q.toHex = _.toHex, q.encode = _.encode;
    function Y(X, f, V) {
      var M = Array(Math.max(X.bitLength(), V) + 1), N;
      for (N = 0; N < M.length; N += 1) M[N] = 0;
      var h = 1 << f + 1, E = X.clone();
      for (N = 0; N < M.length; N++) {
        var I, D = E.andln(h - 1);
        if (E.isOdd()) {
          if (D > (h >> 1) - 1) I = (h >> 1) - D;
          else I = D;
          E.isubn(I);
        } else I = 0;
        M[N] = I, E.iushrn(1);
      }
      return M;
    }
    q.getNAF = Y;
    function O(X, f) {
      var V = [[], []];
      X = X.clone(), f = f.clone();
      var M = 0, N = 0, h;
      while (X.cmpn(-M) > 0 || f.cmpn(-N) > 0) {
        var E = X.andln(3) + M & 3, I = f.andln(3) + N & 3;
        if (E === 3) E = -1;
        if (I === 3) I = -1;
        var D;
        if ((E & 1) === 0) D = 0;
        else if (h = X.andln(7) + M & 7, (h === 3 || h === 5) && I === 2) D = -E;
        else D = E;
        V[0].push(D);
        var g;
        if ((I & 1) === 0) g = 0;
        else if (h = f.andln(7) + N & 7, (h === 3 || h === 5) && E === 2) g = -I;
        else g = I;
        if (V[1].push(g), 2 * M === D + 1) M = 1 - M;
        if (2 * N === g + 1) N = 1 - N;
        X.iushrn(1), f.iushrn(1);
      }
      return V;
    }
    q.getJSF = O;
    function z(X, f, V) {
      var M = "_" + f;
      X.prototype[f] = function() {
        return this[M] !== void 0 ? this[M] : this[M] = V.call(this);
      };
    }
    q.cachedProperty = z;
    function J(X) {
      return typeof X === "string" ? q.toArray(X, "hex") : X;
    }
    q.parseBytes = J;
    function T(X) {
      return new K(X, "hex", "le");
    }
    q.intFromLE = T;
  }), _0 = r$(($18, q) => {
    var K;
    q.exports = function(Y) {
      if (!K) K = new P(null);
      return K.generate(Y);
    };
    function P(Y) {
      this.rand = Y;
    }
    if (q.exports.Rand = P, P.prototype.generate = function(Y) {
      return this._rand(Y);
    }, P.prototype._rand = function(Y) {
      if (this.rand.getBytes) return this.rand.getBytes(Y);
      var O = new Uint8Array(Y);
      for (var z = 0; z < O.length; z++) O[z] = this.rand.getByte();
      return O;
    }, typeof self === "object") {
      if (self.crypto && self.crypto.getRandomValues) P.prototype._rand = function(Y) {
        var O = new Uint8Array(Y);
        return self.crypto.getRandomValues(O), O;
      };
      else if (self.msCrypto && self.msCrypto.getRandomValues) P.prototype._rand = function(Y) {
        var O = new Uint8Array(Y);
        return self.msCrypto.getRandomValues(O), O;
      };
      else if (typeof window === "object") P.prototype._rand = function() {
        throw Error("Not implemented yet");
      };
    } else try {
      if (_ = (dq(), J6(mq)), typeof _.randomBytes !== "function") throw Error("Not supported");
      P.prototype._rand = function(Y) {
        return _.randomBytes(Y);
      };
    } catch (Y) {
    }
    var _;
  }), YO = r$(($18, q) => {
    var K = MK(), P = S8(), _ = P.getNAF, Y = P.getJSF, O = P.assert;
    function z(T, X) {
      this.type = T, this.p = new K(X.p, 16), this.red = X.prime ? K.red(X.prime) : K.mont(this.p), this.zero = new K(0).toRed(this.red), this.one = new K(1).toRed(this.red), this.two = new K(2).toRed(this.red), this.n = X.n && new K(X.n, 16), this.g = X.g && this.pointFromJSON(X.g, X.gRed), this._wnafT1 = [, , , ,], this._wnafT2 = [, , , ,], this._wnafT3 = [, , , ,], this._wnafT4 = [, , , ,], this._bitLength = this.n ? this.n.bitLength() : 0;
      var f = this.n && this.p.div(this.n);
      if (!f || f.cmpn(100) > 0) this.redN = null;
      else this._maxwellTrick = true, this.redN = this.n.toRed(this.red);
    }
    q.exports = z, z.prototype.point = function() {
      throw Error("Not implemented");
    }, z.prototype.validate = function() {
      throw Error("Not implemented");
    }, z.prototype._fixedNafMul = function(T, X) {
      O(T.precomputed);
      var f = T._getDoubles(), V = _(X, 1, this._bitLength), M = (1 << f.step + 1) - (f.step % 2 === 0 ? 2 : 1);
      M /= 3;
      var N = [], h, E;
      for (h = 0; h < V.length; h += f.step) {
        E = 0;
        for (var I = h + f.step - 1; I >= h; I--) E = (E << 1) + V[I];
        N.push(E);
      }
      var D = this.jpoint(null, null, null), g = this.jpoint(null, null, null);
      for (var b = M; b > 0; b--) {
        for (h = 0; h < N.length; h++) if (E = N[h], E === b) g = g.mixedAdd(f.points[h]);
        else if (E === -b) g = g.mixedAdd(f.points[h].neg());
        D = D.add(g);
      }
      return D.toP();
    }, z.prototype._wnafMul = function(T, X) {
      var f = 4, V = T._getNAFPoints(f);
      f = V.wnd;
      var M = V.points, N = _(X, f, this._bitLength), h = this.jpoint(null, null, null);
      for (var E = N.length - 1; E >= 0; E--) {
        for (var I = 0; E >= 0 && N[E] === 0; E--) I++;
        if (E >= 0) I++;
        if (h = h.dblp(I), E < 0) break;
        var D = N[E];
        if (O(D !== 0), T.type === "affine") if (D > 0) h = h.mixedAdd(M[D - 1 >> 1]);
        else h = h.mixedAdd(M[-D - 1 >> 1].neg());
        else if (D > 0) h = h.add(M[D - 1 >> 1]);
        else h = h.add(M[-D - 1 >> 1].neg());
      }
      return T.type === "affine" ? h.toP() : h;
    }, z.prototype._wnafMulAdd = function(T, X, f, V, M) {
      var N = this._wnafT1, h = this._wnafT2, E = this._wnafT3, I = 0, D, g, b;
      for (D = 0; D < V; D++) {
        b = X[D];
        var y = b._getNAFPoints(T);
        N[D] = y.wnd, h[D] = y.points;
      }
      for (D = V - 1; D >= 1; D -= 2) {
        var p = D - 1, n = D;
        if (N[p] !== 1 || N[n] !== 1) {
          E[p] = _(f[p], N[p], this._bitLength), E[n] = _(f[n], N[n], this._bitLength), I = Math.max(E[p].length, I), I = Math.max(E[n].length, I);
          continue;
        }
        var s = [X[p], null, null, X[n]];
        if (X[p].y.cmp(X[n].y) === 0) s[1] = X[p].add(X[n]), s[2] = X[p].toJ().mixedAdd(X[n].neg());
        else if (X[p].y.cmp(X[n].y.redNeg()) === 0) s[1] = X[p].toJ().mixedAdd(X[n]), s[2] = X[p].add(X[n].neg());
        else s[1] = X[p].toJ().mixedAdd(X[n]), s[2] = X[p].toJ().mixedAdd(X[n].neg());
        var q$ = [-3, -1, -5, -7, 0, 7, 5, 1, 3], c = Y(f[p], f[n]);
        I = Math.max(c[0].length, I), E[p] = Array(I), E[n] = Array(I);
        for (g = 0; g < I; g++) {
          var U = c[0][g] | 0, j = c[1][g] | 0;
          E[p][g] = q$[(U + 1) * 3 + (j + 1)], E[n][g] = 0, h[p] = s;
        }
      }
      var H = this.jpoint(null, null, null), Z = this._wnafT4;
      for (D = I; D >= 0; D--) {
        var W = 0;
        while (D >= 0) {
          var w = true;
          for (g = 0; g < V; g++) if (Z[g] = E[g][D] | 0, Z[g] !== 0) w = false;
          if (!w) break;
          W++, D--;
        }
        if (D >= 0) W++;
        if (H = H.dblp(W), D < 0) break;
        for (g = 0; g < V; g++) {
          var G = Z[g];
          if (G === 0) continue;
          else if (G > 0) b = h[g][G - 1 >> 1];
          else if (G < 0) b = h[g][-G - 1 >> 1].neg();
          if (b.type === "affine") H = H.mixedAdd(b);
          else H = H.add(b);
        }
      }
      for (D = 0; D < V; D++) h[D] = null;
      if (M) return H;
      else return H.toP();
    };
    function J(T, X) {
      this.curve = T, this.type = X, this.precomputed = null;
    }
    z.BasePoint = J, J.prototype.eq = function() {
      throw Error("Not implemented");
    }, J.prototype.validate = function() {
      return this.curve.validate(this);
    }, z.prototype.decodePoint = function(T, X) {
      T = P.toArray(T, X);
      var f = this.p.byteLength();
      if ((T[0] === 4 || T[0] === 6 || T[0] === 7) && T.length - 1 === 2 * f) {
        if (T[0] === 6) O(T[T.length - 1] % 2 === 0);
        else if (T[0] === 7) O(T[T.length - 1] % 2 === 1);
        var V = this.point(T.slice(1, 1 + f), T.slice(1 + f, 1 + 2 * f));
        return V;
      } else if ((T[0] === 2 || T[0] === 3) && T.length - 1 === f) return this.pointFromX(T.slice(1, 1 + f), T[0] === 3);
      throw Error("Unknown point format");
    }, J.prototype.encodeCompressed = function(T) {
      return this.encode(T, true);
    }, J.prototype._encode = function(T) {
      var X = this.curve.p.byteLength(), f = this.getX().toArray("be", X);
      if (T) return [this.getY().isEven() ? 2 : 3].concat(f);
      return [4].concat(f, this.getY().toArray("be", X));
    }, J.prototype.encode = function(T, X) {
      return P.encode(this._encode(X), T);
    }, J.prototype.precompute = function(T) {
      if (this.precomputed) return this;
      var X = { doubles: null, naf: null, beta: null };
      return X.naf = this._getNAFPoints(8), X.doubles = this._getDoubles(4, T), X.beta = this._getBeta(), this.precomputed = X, this;
    }, J.prototype._hasDoubles = function(T) {
      if (!this.precomputed) return false;
      var X = this.precomputed.doubles;
      if (!X) return false;
      return X.points.length >= Math.ceil((T.bitLength() + 1) / X.step);
    }, J.prototype._getDoubles = function(T, X) {
      if (this.precomputed && this.precomputed.doubles) return this.precomputed.doubles;
      var f = [this], V = this;
      for (var M = 0; M < X; M += T) {
        for (var N = 0; N < T; N++) V = V.dbl();
        f.push(V);
      }
      return { step: T, points: f };
    }, J.prototype._getNAFPoints = function(T) {
      if (this.precomputed && this.precomputed.naf) return this.precomputed.naf;
      var X = [this], f = (1 << T) - 1, V = f === 1 ? null : this.dbl();
      for (var M = 1; M < f; M++) X[M] = X[M - 1].add(V);
      return { wnd: T, points: X };
    }, J.prototype._getBeta = function() {
      return null;
    }, J.prototype.dblp = function(T) {
      var X = this;
      for (var f = 0; f < T; f++) X = X.dbl();
      return X;
    };
  }), lr = r$(($18, q) => {
    if (typeof Object.create === "function") q.exports = function(K, P) {
      if (P) K.super_ = P, K.prototype = Object.create(P.prototype, { constructor: { value: K, enumerable: false, writable: true, configurable: true } });
    };
    else q.exports = function(K, P) {
      if (P) {
        K.super_ = P;
        var _ = function() {
        };
        _.prototype = P.prototype, K.prototype = new _(), K.prototype.constructor = K;
      }
    };
  }), v8 = r$(($18, q) => {
    try {
      if (K = (hS(), J6(ES)), typeof K.inherits !== "function") throw "";
      q.exports = K.inherits;
    } catch (P) {
      q.exports = lr();
    }
    var K;
  }), rr = r$(($18, q) => {
    var K = S8(), P = MK(), _ = v8(), Y = YO(), O = K.assert;
    function z(X) {
      Y.call(this, "short", X), this.a = new P(X.a, 16).toRed(this.red), this.b = new P(X.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(X), this._endoWnafT1 = [, , , ,], this._endoWnafT2 = [, , , ,];
    }
    _(z, Y), q.exports = z, z.prototype._getEndomorphism = function(X) {
      if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1) return;
      var f, V;
      if (X.beta) f = new P(X.beta, 16).toRed(this.red);
      else {
        var M = this._getEndoRoots(this.p);
        f = M[0].cmp(M[1]) < 0 ? M[0] : M[1], f = f.toRed(this.red);
      }
      if (X.lambda) V = new P(X.lambda, 16);
      else {
        var N = this._getEndoRoots(this.n);
        if (this.g.mul(N[0]).x.cmp(this.g.x.redMul(f)) === 0) V = N[0];
        else V = N[1], O(this.g.mul(V).x.cmp(this.g.x.redMul(f)) === 0);
      }
      var h;
      if (X.basis) h = X.basis.map(function(E) {
        return { a: new P(E.a, 16), b: new P(E.b, 16) };
      });
      else h = this._getEndoBasis(V);
      return { beta: f, lambda: V, basis: h };
    }, z.prototype._getEndoRoots = function(X) {
      var f = X === this.p ? this.red : P.mont(X), V = new P(2).toRed(f).redInvm(), M = V.redNeg(), N = new P(3).toRed(f).redNeg().redSqrt().redMul(V), h = M.redAdd(N).fromRed(), E = M.redSub(N).fromRed();
      return [h, E];
    }, z.prototype._getEndoBasis = function(X) {
      var f = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), V = X, M = this.n.clone(), N = new P(1), h = new P(0), E = new P(0), I = new P(1), D, g, b, y, p, n, s, q$ = 0, c, U;
      while (V.cmpn(0) !== 0) {
        var j = M.div(V);
        c = M.sub(j.mul(V)), U = E.sub(j.mul(N));
        var H = I.sub(j.mul(h));
        if (!b && c.cmp(f) < 0) D = s.neg(), g = N, b = c.neg(), y = U;
        else if (b && ++q$ === 2) break;
        s = c, M = V, V = c, E = N, N = U, I = h, h = H;
      }
      p = c.neg(), n = U;
      var Z = b.sqr().add(y.sqr()), W = p.sqr().add(n.sqr());
      if (W.cmp(Z) >= 0) p = D, n = g;
      if (b.negative) b = b.neg(), y = y.neg();
      if (p.negative) p = p.neg(), n = n.neg();
      return [{ a: b, b: y }, { a: p, b: n }];
    }, z.prototype._endoSplit = function(X) {
      var f = this.endo.basis, V = f[0], M = f[1], N = M.b.mul(X).divRound(this.n), h = V.b.neg().mul(X).divRound(this.n), E = N.mul(V.a), I = h.mul(M.a), D = N.mul(V.b), g = h.mul(M.b), b = X.sub(E).sub(I), y = D.add(g).neg();
      return { k1: b, k2: y };
    }, z.prototype.pointFromX = function(X, f) {
      if (X = new P(X, 16), !X.red) X = X.toRed(this.red);
      var V = X.redSqr().redMul(X).redIAdd(X.redMul(this.a)).redIAdd(this.b), M = V.redSqrt();
      if (M.redSqr().redSub(V).cmp(this.zero) !== 0) throw Error("invalid point");
      var N = M.fromRed().isOdd();
      if (f && !N || !f && N) M = M.redNeg();
      return this.point(X, M);
    }, z.prototype.validate = function(X) {
      if (X.inf) return true;
      var { x: f, y: V } = X, M = this.a.redMul(f), N = f.redSqr().redMul(f).redIAdd(M).redIAdd(this.b);
      return V.redSqr().redISub(N).cmpn(0) === 0;
    }, z.prototype._endoWnafMulAdd = function(X, f, V) {
      var M = this._endoWnafT1, N = this._endoWnafT2;
      for (var h = 0; h < X.length; h++) {
        var E = this._endoSplit(f[h]), I = X[h], D = I._getBeta();
        if (E.k1.negative) E.k1.ineg(), I = I.neg(true);
        if (E.k2.negative) E.k2.ineg(), D = D.neg(true);
        M[h * 2] = I, M[h * 2 + 1] = D, N[h * 2] = E.k1, N[h * 2 + 1] = E.k2;
      }
      var g = this._wnafMulAdd(1, M, N, h * 2, V);
      for (var b = 0; b < h * 2; b++) M[b] = null, N[b] = null;
      return g;
    };
    function J(X, f, V, M) {
      if (Y.BasePoint.call(this, X, "affine"), f === null && V === null) this.x = null, this.y = null, this.inf = true;
      else {
        if (this.x = new P(f, 16), this.y = new P(V, 16), M) this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red);
        if (!this.x.red) this.x = this.x.toRed(this.curve.red);
        if (!this.y.red) this.y = this.y.toRed(this.curve.red);
        this.inf = false;
      }
    }
    _(J, Y.BasePoint), z.prototype.point = function(X, f, V) {
      return new J(this, X, f, V);
    }, z.prototype.pointFromJSON = function(X, f) {
      return J.fromJSON(this, X, f);
    }, J.prototype._getBeta = function() {
      if (!this.curve.endo) return;
      var X = this.precomputed;
      if (X && X.beta) return X.beta;
      var f = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
      if (X) {
        var V = this.curve, M = function(N) {
          return V.point(N.x.redMul(V.endo.beta), N.y);
        };
        X.beta = f, f.precomputed = { beta: null, naf: X.naf && { wnd: X.naf.wnd, points: X.naf.points.map(M) }, doubles: X.doubles && { step: X.doubles.step, points: X.doubles.points.map(M) } };
      }
      return f;
    }, J.prototype.toJSON = function() {
      if (!this.precomputed) return [this.x, this.y];
      return [this.x, this.y, this.precomputed && { doubles: this.precomputed.doubles && { step: this.precomputed.doubles.step, points: this.precomputed.doubles.points.slice(1) }, naf: this.precomputed.naf && { wnd: this.precomputed.naf.wnd, points: this.precomputed.naf.points.slice(1) } }];
    }, J.fromJSON = function(X, f, V) {
      if (typeof f === "string") f = JSON.parse(f);
      var M = X.point(f[0], f[1], V);
      if (!f[2]) return M;
      function N(E) {
        return X.point(E[0], E[1], V);
      }
      var h = f[2];
      return M.precomputed = { beta: null, doubles: h.doubles && { step: h.doubles.step, points: [M].concat(h.doubles.points.map(N)) }, naf: h.naf && { wnd: h.naf.wnd, points: [M].concat(h.naf.points.map(N)) } }, M;
    }, J.prototype.inspect = function() {
      if (this.isInfinity()) return "<EC Point Infinity>";
      return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
    }, J.prototype.isInfinity = function() {
      return this.inf;
    }, J.prototype.add = function(X) {
      if (this.inf) return X;
      if (X.inf) return this;
      if (this.eq(X)) return this.dbl();
      if (this.neg().eq(X)) return this.curve.point(null, null);
      if (this.x.cmp(X.x) === 0) return this.curve.point(null, null);
      var f = this.y.redSub(X.y);
      if (f.cmpn(0) !== 0) f = f.redMul(this.x.redSub(X.x).redInvm());
      var V = f.redSqr().redISub(this.x).redISub(X.x), M = f.redMul(this.x.redSub(V)).redISub(this.y);
      return this.curve.point(V, M);
    }, J.prototype.dbl = function() {
      if (this.inf) return this;
      var X = this.y.redAdd(this.y);
      if (X.cmpn(0) === 0) return this.curve.point(null, null);
      var f = this.curve.a, V = this.x.redSqr(), M = X.redInvm(), N = V.redAdd(V).redIAdd(V).redIAdd(f).redMul(M), h = N.redSqr().redISub(this.x.redAdd(this.x)), E = N.redMul(this.x.redSub(h)).redISub(this.y);
      return this.curve.point(h, E);
    }, J.prototype.getX = function() {
      return this.x.fromRed();
    }, J.prototype.getY = function() {
      return this.y.fromRed();
    }, J.prototype.mul = function(X) {
      if (X = new P(X, 16), this.isInfinity()) return this;
      else if (this._hasDoubles(X)) return this.curve._fixedNafMul(this, X);
      else if (this.curve.endo) return this.curve._endoWnafMulAdd([this], [X]);
      else return this.curve._wnafMul(this, X);
    }, J.prototype.mulAdd = function(X, f, V) {
      var M = [this, f], N = [X, V];
      if (this.curve.endo) return this.curve._endoWnafMulAdd(M, N);
      else return this.curve._wnafMulAdd(1, M, N, 2);
    }, J.prototype.jmulAdd = function(X, f, V) {
      var M = [this, f], N = [X, V];
      if (this.curve.endo) return this.curve._endoWnafMulAdd(M, N, true);
      else return this.curve._wnafMulAdd(1, M, N, 2, true);
    }, J.prototype.eq = function(X) {
      return this === X || this.inf === X.inf && (this.inf || this.x.cmp(X.x) === 0 && this.y.cmp(X.y) === 0);
    }, J.prototype.neg = function(X) {
      if (this.inf) return this;
      var f = this.curve.point(this.x, this.y.redNeg());
      if (X && this.precomputed) {
        var V = this.precomputed, M = function(N) {
          return N.neg();
        };
        f.precomputed = { naf: V.naf && { wnd: V.naf.wnd, points: V.naf.points.map(M) }, doubles: V.doubles && { step: V.doubles.step, points: V.doubles.points.map(M) } };
      }
      return f;
    }, J.prototype.toJ = function() {
      if (this.inf) return this.curve.jpoint(null, null, null);
      var X = this.curve.jpoint(this.x, this.y, this.curve.one);
      return X;
    };
    function T(X, f, V, M) {
      if (Y.BasePoint.call(this, X, "jacobian"), f === null && V === null && M === null) this.x = this.curve.one, this.y = this.curve.one, this.z = new P(0);
      else this.x = new P(f, 16), this.y = new P(V, 16), this.z = new P(M, 16);
      if (!this.x.red) this.x = this.x.toRed(this.curve.red);
      if (!this.y.red) this.y = this.y.toRed(this.curve.red);
      if (!this.z.red) this.z = this.z.toRed(this.curve.red);
      this.zOne = this.z === this.curve.one;
    }
    _(T, Y.BasePoint), z.prototype.jpoint = function(X, f, V) {
      return new T(this, X, f, V);
    }, T.prototype.toP = function() {
      if (this.isInfinity()) return this.curve.point(null, null);
      var X = this.z.redInvm(), f = X.redSqr(), V = this.x.redMul(f), M = this.y.redMul(f).redMul(X);
      return this.curve.point(V, M);
    }, T.prototype.neg = function() {
      return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
    }, T.prototype.add = function(X) {
      if (this.isInfinity()) return X;
      if (X.isInfinity()) return this;
      var f = X.z.redSqr(), V = this.z.redSqr(), M = this.x.redMul(f), N = X.x.redMul(V), h = this.y.redMul(f.redMul(X.z)), E = X.y.redMul(V.redMul(this.z)), I = M.redSub(N), D = h.redSub(E);
      if (I.cmpn(0) === 0) if (D.cmpn(0) !== 0) return this.curve.jpoint(null, null, null);
      else return this.dbl();
      var g = I.redSqr(), b = g.redMul(I), y = M.redMul(g), p = D.redSqr().redIAdd(b).redISub(y).redISub(y), n = D.redMul(y.redISub(p)).redISub(h.redMul(b)), s = this.z.redMul(X.z).redMul(I);
      return this.curve.jpoint(p, n, s);
    }, T.prototype.mixedAdd = function(X) {
      if (this.isInfinity()) return X.toJ();
      if (X.isInfinity()) return this;
      var f = this.z.redSqr(), V = this.x, M = X.x.redMul(f), N = this.y, h = X.y.redMul(f).redMul(this.z), E = V.redSub(M), I = N.redSub(h);
      if (E.cmpn(0) === 0) if (I.cmpn(0) !== 0) return this.curve.jpoint(null, null, null);
      else return this.dbl();
      var D = E.redSqr(), g = D.redMul(E), b = V.redMul(D), y = I.redSqr().redIAdd(g).redISub(b).redISub(b), p = I.redMul(b.redISub(y)).redISub(N.redMul(g)), n = this.z.redMul(E);
      return this.curve.jpoint(y, p, n);
    }, T.prototype.dblp = function(X) {
      if (X === 0) return this;
      if (this.isInfinity()) return this;
      if (!X) return this.dbl();
      var f;
      if (this.curve.zeroA || this.curve.threeA) {
        var V = this;
        for (f = 0; f < X; f++) V = V.dbl();
        return V;
      }
      var M = this.curve.a, N = this.curve.tinv, h = this.x, E = this.y, I = this.z, D = I.redSqr().redSqr(), g = E.redAdd(E);
      for (f = 0; f < X; f++) {
        var b = h.redSqr(), y = g.redSqr(), p = y.redSqr(), n = b.redAdd(b).redIAdd(b).redIAdd(M.redMul(D)), s = h.redMul(y), q$ = n.redSqr().redISub(s.redAdd(s)), c = s.redISub(q$), U = n.redMul(c);
        U = U.redIAdd(U).redISub(p);
        var j = g.redMul(I);
        if (f + 1 < X) D = D.redMul(p);
        h = q$, I = j, g = U;
      }
      return this.curve.jpoint(h, g.redMul(N), I);
    }, T.prototype.dbl = function() {
      if (this.isInfinity()) return this;
      if (this.curve.zeroA) return this._zeroDbl();
      else if (this.curve.threeA) return this._threeDbl();
      else return this._dbl();
    }, T.prototype._zeroDbl = function() {
      var X, f, V;
      if (this.zOne) {
        var M = this.x.redSqr(), N = this.y.redSqr(), h = N.redSqr(), E = this.x.redAdd(N).redSqr().redISub(M).redISub(h);
        E = E.redIAdd(E);
        var I = M.redAdd(M).redIAdd(M), D = I.redSqr().redISub(E).redISub(E), g = h.redIAdd(h);
        g = g.redIAdd(g), g = g.redIAdd(g), X = D, f = I.redMul(E.redISub(D)).redISub(g), V = this.y.redAdd(this.y);
      } else {
        var b = this.x.redSqr(), y = this.y.redSqr(), p = y.redSqr(), n = this.x.redAdd(y).redSqr().redISub(b).redISub(p);
        n = n.redIAdd(n);
        var s = b.redAdd(b).redIAdd(b), q$ = s.redSqr(), c = p.redIAdd(p);
        c = c.redIAdd(c), c = c.redIAdd(c), X = q$.redISub(n).redISub(n), f = s.redMul(n.redISub(X)).redISub(c), V = this.y.redMul(this.z), V = V.redIAdd(V);
      }
      return this.curve.jpoint(X, f, V);
    }, T.prototype._threeDbl = function() {
      var X, f, V;
      if (this.zOne) {
        var M = this.x.redSqr(), N = this.y.redSqr(), h = N.redSqr(), E = this.x.redAdd(N).redSqr().redISub(M).redISub(h);
        E = E.redIAdd(E);
        var I = M.redAdd(M).redIAdd(M).redIAdd(this.curve.a), D = I.redSqr().redISub(E).redISub(E);
        X = D;
        var g = h.redIAdd(h);
        g = g.redIAdd(g), g = g.redIAdd(g), f = I.redMul(E.redISub(D)).redISub(g), V = this.y.redAdd(this.y);
      } else {
        var b = this.z.redSqr(), y = this.y.redSqr(), p = this.x.redMul(y), n = this.x.redSub(b).redMul(this.x.redAdd(b));
        n = n.redAdd(n).redIAdd(n);
        var s = p.redIAdd(p);
        s = s.redIAdd(s);
        var q$ = s.redAdd(s);
        X = n.redSqr().redISub(q$), V = this.y.redAdd(this.z).redSqr().redISub(y).redISub(b);
        var c = y.redSqr();
        c = c.redIAdd(c), c = c.redIAdd(c), c = c.redIAdd(c), f = n.redMul(s.redISub(X)).redISub(c);
      }
      return this.curve.jpoint(X, f, V);
    }, T.prototype._dbl = function() {
      var X = this.curve.a, f = this.x, V = this.y, M = this.z, N = M.redSqr().redSqr(), h = f.redSqr(), E = V.redSqr(), I = h.redAdd(h).redIAdd(h).redIAdd(X.redMul(N)), D = f.redAdd(f);
      D = D.redIAdd(D);
      var g = D.redMul(E), b = I.redSqr().redISub(g.redAdd(g)), y = g.redISub(b), p = E.redSqr();
      p = p.redIAdd(p), p = p.redIAdd(p), p = p.redIAdd(p);
      var n = I.redMul(y).redISub(p), s = V.redAdd(V).redMul(M);
      return this.curve.jpoint(b, n, s);
    }, T.prototype.trpl = function() {
      if (!this.curve.zeroA) return this.dbl().add(this);
      var X = this.x.redSqr(), f = this.y.redSqr(), V = this.z.redSqr(), M = f.redSqr(), N = X.redAdd(X).redIAdd(X), h = N.redSqr(), E = this.x.redAdd(f).redSqr().redISub(X).redISub(M);
      E = E.redIAdd(E), E = E.redAdd(E).redIAdd(E), E = E.redISub(h);
      var I = E.redSqr(), D = M.redIAdd(M);
      D = D.redIAdd(D), D = D.redIAdd(D), D = D.redIAdd(D);
      var g = N.redIAdd(E).redSqr().redISub(h).redISub(I).redISub(D), b = f.redMul(g);
      b = b.redIAdd(b), b = b.redIAdd(b);
      var y = this.x.redMul(I).redISub(b);
      y = y.redIAdd(y), y = y.redIAdd(y);
      var p = this.y.redMul(g.redMul(D.redISub(g)).redISub(E.redMul(I)));
      p = p.redIAdd(p), p = p.redIAdd(p), p = p.redIAdd(p);
      var n = this.z.redAdd(E).redSqr().redISub(V).redISub(I);
      return this.curve.jpoint(y, p, n);
    }, T.prototype.mul = function(X, f) {
      return X = new P(X, f), this.curve._wnafMul(this, X);
    }, T.prototype.eq = function(X) {
      if (X.type === "affine") return this.eq(X.toJ());
      if (this === X) return true;
      var f = this.z.redSqr(), V = X.z.redSqr();
      if (this.x.redMul(V).redISub(X.x.redMul(f)).cmpn(0) !== 0) return false;
      var M = f.redMul(this.z), N = V.redMul(X.z);
      return this.y.redMul(N).redISub(X.y.redMul(M)).cmpn(0) === 0;
    }, T.prototype.eqXToP = function(X) {
      var f = this.z.redSqr(), V = X.toRed(this.curve.red).redMul(f);
      if (this.x.cmp(V) === 0) return true;
      var M = X.clone(), N = this.curve.redN.redMul(f);
      for (; ; ) {
        if (M.iadd(this.curve.n), M.cmp(this.curve.p) >= 0) return false;
        if (V.redIAdd(N), this.x.cmp(V) === 0) return true;
      }
    }, T.prototype.inspect = function() {
      if (this.isInfinity()) return "<EC JPoint Infinity>";
      return "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
    }, T.prototype.isInfinity = function() {
      return this.z.cmpn(0) === 0;
    };
  }), or = r$(($18, q) => {
    var K = MK(), P = v8(), _ = YO(), Y = S8();
    function O(J) {
      _.call(this, "mont", J), this.a = new K(J.a, 16).toRed(this.red), this.b = new K(J.b, 16).toRed(this.red), this.i4 = new K(4).toRed(this.red).redInvm(), this.two = new K(2).toRed(this.red), this.a24 = this.i4.redMul(this.a.redAdd(this.two));
    }
    P(O, _), q.exports = O, O.prototype.validate = function(J) {
      var T = J.normalize().x, X = T.redSqr(), f = X.redMul(T).redAdd(X.redMul(this.a)).redAdd(T), V = f.redSqrt();
      return V.redSqr().cmp(f) === 0;
    };
    function z(J, T, X) {
      if (_.BasePoint.call(this, J, "projective"), T === null && X === null) this.x = this.curve.one, this.z = this.curve.zero;
      else {
        if (this.x = new K(T, 16), this.z = new K(X, 16), !this.x.red) this.x = this.x.toRed(this.curve.red);
        if (!this.z.red) this.z = this.z.toRed(this.curve.red);
      }
    }
    P(z, _.BasePoint), O.prototype.decodePoint = function(J, T) {
      return this.point(Y.toArray(J, T), 1);
    }, O.prototype.point = function(J, T) {
      return new z(this, J, T);
    }, O.prototype.pointFromJSON = function(J) {
      return z.fromJSON(this, J);
    }, z.prototype.precompute = function() {
    }, z.prototype._encode = function() {
      return this.getX().toArray("be", this.curve.p.byteLength());
    }, z.fromJSON = function(J, T) {
      return new z(J, T[0], T[1] || J.one);
    }, z.prototype.inspect = function() {
      if (this.isInfinity()) return "<EC Point Infinity>";
      return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
    }, z.prototype.isInfinity = function() {
      return this.z.cmpn(0) === 0;
    }, z.prototype.dbl = function() {
      var J = this.x.redAdd(this.z), T = J.redSqr(), X = this.x.redSub(this.z), f = X.redSqr(), V = T.redSub(f), M = T.redMul(f), N = V.redMul(f.redAdd(this.curve.a24.redMul(V)));
      return this.curve.point(M, N);
    }, z.prototype.add = function() {
      throw Error("Not supported on Montgomery curve");
    }, z.prototype.diffAdd = function(J, T) {
      var X = this.x.redAdd(this.z), f = this.x.redSub(this.z), V = J.x.redAdd(J.z), M = J.x.redSub(J.z), N = M.redMul(X), h = V.redMul(f), E = T.z.redMul(N.redAdd(h).redSqr()), I = T.x.redMul(N.redISub(h).redSqr());
      return this.curve.point(E, I);
    }, z.prototype.mul = function(J) {
      var T = J.clone(), X = this, f = this.curve.point(null, null), V = this;
      for (var M = []; T.cmpn(0) !== 0; T.iushrn(1)) M.push(T.andln(1));
      for (var N = M.length - 1; N >= 0; N--) if (M[N] === 0) X = X.diffAdd(f, V), f = f.dbl();
      else f = X.diffAdd(f, V), X = X.dbl();
      return f;
    }, z.prototype.mulAdd = function() {
      throw Error("Not supported on Montgomery curve");
    }, z.prototype.jumlAdd = function() {
      throw Error("Not supported on Montgomery curve");
    }, z.prototype.eq = function(J) {
      return this.getX().cmp(J.getX()) === 0;
    }, z.prototype.normalize = function() {
      return this.x = this.x.redMul(this.z.redInvm()), this.z = this.curve.one, this;
    }, z.prototype.getX = function() {
      return this.normalize(), this.x.fromRed();
    };
  }), nr = r$(($18, q) => {
    var K = S8(), P = MK(), _ = v8(), Y = YO(), O = K.assert;
    function z(T) {
      this.twisted = (T.a | 0) !== 1, this.mOneA = this.twisted && (T.a | 0) === -1, this.extended = this.mOneA, Y.call(this, "edwards", T), this.a = new P(T.a, 16).umod(this.red.m), this.a = this.a.toRed(this.red), this.c = new P(T.c, 16).toRed(this.red), this.c2 = this.c.redSqr(), this.d = new P(T.d, 16).toRed(this.red), this.dd = this.d.redAdd(this.d), O(!this.twisted || this.c.fromRed().cmpn(1) === 0), this.oneC = (T.c | 0) === 1;
    }
    _(z, Y), q.exports = z, z.prototype._mulA = function(T) {
      if (this.mOneA) return T.redNeg();
      else return this.a.redMul(T);
    }, z.prototype._mulC = function(T) {
      if (this.oneC) return T;
      else return this.c.redMul(T);
    }, z.prototype.jpoint = function(T, X, f, V) {
      return this.point(T, X, f, V);
    }, z.prototype.pointFromX = function(T, X) {
      if (T = new P(T, 16), !T.red) T = T.toRed(this.red);
      var f = T.redSqr(), V = this.c2.redSub(this.a.redMul(f)), M = this.one.redSub(this.c2.redMul(this.d).redMul(f)), N = V.redMul(M.redInvm()), h = N.redSqrt();
      if (h.redSqr().redSub(N).cmp(this.zero) !== 0) throw Error("invalid point");
      var E = h.fromRed().isOdd();
      if (X && !E || !X && E) h = h.redNeg();
      return this.point(T, h);
    }, z.prototype.pointFromY = function(T, X) {
      if (T = new P(T, 16), !T.red) T = T.toRed(this.red);
      var f = T.redSqr(), V = f.redSub(this.c2), M = f.redMul(this.d).redMul(this.c2).redSub(this.a), N = V.redMul(M.redInvm());
      if (N.cmp(this.zero) === 0) if (X) throw Error("invalid point");
      else return this.point(this.zero, T);
      var h = N.redSqrt();
      if (h.redSqr().redSub(N).cmp(this.zero) !== 0) throw Error("invalid point");
      if (h.fromRed().isOdd() !== X) h = h.redNeg();
      return this.point(h, T);
    }, z.prototype.validate = function(T) {
      if (T.isInfinity()) return true;
      T.normalize();
      var X = T.x.redSqr(), f = T.y.redSqr(), V = X.redMul(this.a).redAdd(f), M = this.c2.redMul(this.one.redAdd(this.d.redMul(X).redMul(f)));
      return V.cmp(M) === 0;
    };
    function J(T, X, f, V, M) {
      if (Y.BasePoint.call(this, T, "projective"), X === null && f === null && V === null) this.x = this.curve.zero, this.y = this.curve.one, this.z = this.curve.one, this.t = this.curve.zero, this.zOne = true;
      else {
        if (this.x = new P(X, 16), this.y = new P(f, 16), this.z = V ? new P(V, 16) : this.curve.one, this.t = M && new P(M, 16), !this.x.red) this.x = this.x.toRed(this.curve.red);
        if (!this.y.red) this.y = this.y.toRed(this.curve.red);
        if (!this.z.red) this.z = this.z.toRed(this.curve.red);
        if (this.t && !this.t.red) this.t = this.t.toRed(this.curve.red);
        if (this.zOne = this.z === this.curve.one, this.curve.extended && !this.t) {
          if (this.t = this.x.redMul(this.y), !this.zOne) this.t = this.t.redMul(this.z.redInvm());
        }
      }
    }
    _(J, Y.BasePoint), z.prototype.pointFromJSON = function(T) {
      return J.fromJSON(this, T);
    }, z.prototype.point = function(T, X, f, V) {
      return new J(this, T, X, f, V);
    }, J.fromJSON = function(T, X) {
      return new J(T, X[0], X[1], X[2]);
    }, J.prototype.inspect = function() {
      if (this.isInfinity()) return "<EC Point Infinity>";
      return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
    }, J.prototype.isInfinity = function() {
      return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
    }, J.prototype._extDbl = function() {
      var T = this.x.redSqr(), X = this.y.redSqr(), f = this.z.redSqr();
      f = f.redIAdd(f);
      var V = this.curve._mulA(T), M = this.x.redAdd(this.y).redSqr().redISub(T).redISub(X), N = V.redAdd(X), h = N.redSub(f), E = V.redSub(X), I = M.redMul(h), D = N.redMul(E), g = M.redMul(E), b = h.redMul(N);
      return this.curve.point(I, D, b, g);
    }, J.prototype._projDbl = function() {
      var T = this.x.redAdd(this.y).redSqr(), X = this.x.redSqr(), f = this.y.redSqr(), V, M, N, h, E, I;
      if (this.curve.twisted) {
        h = this.curve._mulA(X);
        var D = h.redAdd(f);
        if (this.zOne) V = T.redSub(X).redSub(f).redMul(D.redSub(this.curve.two)), M = D.redMul(h.redSub(f)), N = D.redSqr().redSub(D).redSub(D);
        else E = this.z.redSqr(), I = D.redSub(E).redISub(E), V = T.redSub(X).redISub(f).redMul(I), M = D.redMul(h.redSub(f)), N = D.redMul(I);
      } else h = X.redAdd(f), E = this.curve._mulC(this.z).redSqr(), I = h.redSub(E).redSub(E), V = this.curve._mulC(T.redISub(h)).redMul(I), M = this.curve._mulC(h).redMul(X.redISub(f)), N = h.redMul(I);
      return this.curve.point(V, M, N);
    }, J.prototype.dbl = function() {
      if (this.isInfinity()) return this;
      if (this.curve.extended) return this._extDbl();
      else return this._projDbl();
    }, J.prototype._extAdd = function(T) {
      var X = this.y.redSub(this.x).redMul(T.y.redSub(T.x)), f = this.y.redAdd(this.x).redMul(T.y.redAdd(T.x)), V = this.t.redMul(this.curve.dd).redMul(T.t), M = this.z.redMul(T.z.redAdd(T.z)), N = f.redSub(X), h = M.redSub(V), E = M.redAdd(V), I = f.redAdd(X), D = N.redMul(h), g = E.redMul(I), b = N.redMul(I), y = h.redMul(E);
      return this.curve.point(D, g, y, b);
    }, J.prototype._projAdd = function(T) {
      var X = this.z.redMul(T.z), f = X.redSqr(), V = this.x.redMul(T.x), M = this.y.redMul(T.y), N = this.curve.d.redMul(V).redMul(M), h = f.redSub(N), E = f.redAdd(N), I = this.x.redAdd(this.y).redMul(T.x.redAdd(T.y)).redISub(V).redISub(M), D = X.redMul(h).redMul(I), g, b;
      if (this.curve.twisted) g = X.redMul(E).redMul(M.redSub(this.curve._mulA(V))), b = h.redMul(E);
      else g = X.redMul(E).redMul(M.redSub(V)), b = this.curve._mulC(h).redMul(E);
      return this.curve.point(D, g, b);
    }, J.prototype.add = function(T) {
      if (this.isInfinity()) return T;
      if (T.isInfinity()) return this;
      if (this.curve.extended) return this._extAdd(T);
      else return this._projAdd(T);
    }, J.prototype.mul = function(T) {
      if (this._hasDoubles(T)) return this.curve._fixedNafMul(this, T);
      else return this.curve._wnafMul(this, T);
    }, J.prototype.mulAdd = function(T, X, f) {
      return this.curve._wnafMulAdd(1, [this, X], [T, f], 2, false);
    }, J.prototype.jmulAdd = function(T, X, f) {
      return this.curve._wnafMulAdd(1, [this, X], [T, f], 2, true);
    }, J.prototype.normalize = function() {
      if (this.zOne) return this;
      var T = this.z.redInvm();
      if (this.x = this.x.redMul(T), this.y = this.y.redMul(T), this.t) this.t = this.t.redMul(T);
      return this.z = this.curve.one, this.zOne = true, this;
    }, J.prototype.neg = function() {
      return this.curve.point(this.x.redNeg(), this.y, this.z, this.t && this.t.redNeg());
    }, J.prototype.getX = function() {
      return this.normalize(), this.x.fromRed();
    }, J.prototype.getY = function() {
      return this.normalize(), this.y.fromRed();
    }, J.prototype.eq = function(T) {
      return this === T || this.getX().cmp(T.getX()) === 0 && this.getY().cmp(T.getY()) === 0;
    }, J.prototype.eqXToP = function(T) {
      var X = T.toRed(this.curve.red).redMul(this.z);
      if (this.x.cmp(X) === 0) return true;
      var f = T.clone(), V = this.curve.redN.redMul(this.z);
      for (; ; ) {
        if (f.iadd(this.curve.n), f.cmp(this.curve.p) >= 0) return false;
        if (X.redIAdd(V), this.x.cmp(X) === 0) return true;
      }
    }, J.prototype.toP = J.prototype.normalize, J.prototype.mixedAdd = J.prototype.add;
  }), P0 = r$(($18) => {
    var q = $18;
    q.base = YO(), q.short = rr(), q.mont = or(), q.edwards = nr();
  }), s8 = r$(($18) => {
    var q = $_(), K = v8();
    $18.inherits = K;
    function P(H, Z) {
      if ((H.charCodeAt(Z) & 64512) !== 55296) return false;
      if (Z < 0 || Z + 1 >= H.length) return false;
      return (H.charCodeAt(Z + 1) & 64512) === 56320;
    }
    function _(H, Z) {
      if (Array.isArray(H)) return H.slice();
      if (!H) return [];
      var W = [];
      if (typeof H === "string") {
        if (!Z) {
          var w = 0;
          for (var G = 0; G < H.length; G++) {
            var S = H.charCodeAt(G);
            if (S < 128) W[w++] = S;
            else if (S < 2048) W[w++] = S >> 6 | 192, W[w++] = S & 63 | 128;
            else if (P(H, G)) S = 65536 + ((S & 1023) << 10) + (H.charCodeAt(++G) & 1023), W[w++] = S >> 18 | 240, W[w++] = S >> 12 & 63 | 128, W[w++] = S >> 6 & 63 | 128, W[w++] = S & 63 | 128;
            else W[w++] = S >> 12 | 224, W[w++] = S >> 6 & 63 | 128, W[w++] = S & 63 | 128;
          }
        } else if (Z === "hex") {
          if (H = H.replace(/[^a-z0-9]+/ig, ""), H.length % 2 !== 0) H = "0" + H;
          for (G = 0; G < H.length; G += 2) W.push(parseInt(H[G] + H[G + 1], 16));
        }
      } else for (G = 0; G < H.length; G++) W[G] = H[G] | 0;
      return W;
    }
    $18.toArray = _;
    function Y(H) {
      var Z = "";
      for (var W = 0; W < H.length; W++) Z += J(H[W].toString(16));
      return Z;
    }
    $18.toHex = Y;
    function O(H) {
      var Z = H >>> 24 | H >>> 8 & 65280 | H << 8 & 16711680 | (H & 255) << 24;
      return Z >>> 0;
    }
    $18.htonl = O;
    function z(H, Z) {
      var W = "";
      for (var w = 0; w < H.length; w++) {
        var G = H[w];
        if (Z === "little") G = O(G);
        W += T(G.toString(16));
      }
      return W;
    }
    $18.toHex32 = z;
    function J(H) {
      if (H.length === 1) return "0" + H;
      else return H;
    }
    $18.zero2 = J;
    function T(H) {
      if (H.length === 7) return "0" + H;
      else if (H.length === 6) return "00" + H;
      else if (H.length === 5) return "000" + H;
      else if (H.length === 4) return "0000" + H;
      else if (H.length === 3) return "00000" + H;
      else if (H.length === 2) return "000000" + H;
      else if (H.length === 1) return "0000000" + H;
      else return H;
    }
    $18.zero8 = T;
    function X(H, Z, W, w) {
      var G = W - Z;
      q(G % 4 === 0);
      var S = Array(G / 4);
      for (var A = 0, v = Z; A < S.length; A++, v += 4) {
        var k;
        if (w === "big") k = H[v] << 24 | H[v + 1] << 16 | H[v + 2] << 8 | H[v + 3];
        else k = H[v + 3] << 24 | H[v + 2] << 16 | H[v + 1] << 8 | H[v];
        S[A] = k >>> 0;
      }
      return S;
    }
    $18.join32 = X;
    function f(H, Z) {
      var W = Array(H.length * 4);
      for (var w = 0, G = 0; w < H.length; w++, G += 4) {
        var S = H[w];
        if (Z === "big") W[G] = S >>> 24, W[G + 1] = S >>> 16 & 255, W[G + 2] = S >>> 8 & 255, W[G + 3] = S & 255;
        else W[G + 3] = S >>> 24, W[G + 2] = S >>> 16 & 255, W[G + 1] = S >>> 8 & 255, W[G] = S & 255;
      }
      return W;
    }
    $18.split32 = f;
    function V(H, Z) {
      return H >>> Z | H << 32 - Z;
    }
    $18.rotr32 = V;
    function M(H, Z) {
      return H << Z | H >>> 32 - Z;
    }
    $18.rotl32 = M;
    function N(H, Z) {
      return H + Z >>> 0;
    }
    $18.sum32 = N;
    function h(H, Z, W) {
      return H + Z + W >>> 0;
    }
    $18.sum32_3 = h;
    function E(H, Z, W, w) {
      return H + Z + W + w >>> 0;
    }
    $18.sum32_4 = E;
    function I(H, Z, W, w, G) {
      return H + Z + W + w + G >>> 0;
    }
    $18.sum32_5 = I;
    function D(H, Z, W, w) {
      var G = H[Z], S = H[Z + 1], A = w + S >>> 0, v = (A < w ? 1 : 0) + W + G;
      H[Z] = v >>> 0, H[Z + 1] = A;
    }
    $18.sum64 = D;
    function g(H, Z, W, w) {
      var G = Z + w >>> 0, S = (G < Z ? 1 : 0) + H + W;
      return S >>> 0;
    }
    $18.sum64_hi = g;
    function b(H, Z, W, w) {
      var G = Z + w;
      return G >>> 0;
    }
    $18.sum64_lo = b;
    function y(H, Z, W, w, G, S, A, v) {
      var k = 0, R = Z;
      R = R + w >>> 0, k += R < Z ? 1 : 0, R = R + S >>> 0, k += R < S ? 1 : 0, R = R + v >>> 0, k += R < v ? 1 : 0;
      var C = H + W + G + A + k;
      return C >>> 0;
    }
    $18.sum64_4_hi = y;
    function p(H, Z, W, w, G, S, A, v) {
      var k = Z + w + S + v;
      return k >>> 0;
    }
    $18.sum64_4_lo = p;
    function n(H, Z, W, w, G, S, A, v, k, R) {
      var C = 0, L = Z;
      L = L + w >>> 0, C += L < Z ? 1 : 0, L = L + S >>> 0, C += L < S ? 1 : 0, L = L + v >>> 0, C += L < v ? 1 : 0, L = L + R >>> 0, C += L < R ? 1 : 0;
      var x = H + W + G + A + k + C;
      return x >>> 0;
    }
    $18.sum64_5_hi = n;
    function s(H, Z, W, w, G, S, A, v, k, R) {
      var C = Z + w + S + v + R;
      return C >>> 0;
    }
    $18.sum64_5_lo = s;
    function q$(H, Z, W) {
      var w = Z << 32 - W | H >>> W;
      return w >>> 0;
    }
    $18.rotr64_hi = q$;
    function c(H, Z, W) {
      var w = H << 32 - W | Z >>> W;
      return w >>> 0;
    }
    $18.rotr64_lo = c;
    function U(H, Z, W) {
      return H >>> W;
    }
    $18.shr64_hi = U;
    function j(H, Z, W) {
      var w = H << 32 - W | Z >>> W;
      return w >>> 0;
    }
    $18.shr64_lo = j;
  }), t7 = r$(($18) => {
    var q = s8(), K = $_();
    function P() {
      this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32;
    }
    $18.BlockHash = P, P.prototype.update = function(_, Y) {
      if (_ = q.toArray(_, Y), !this.pending) this.pending = _;
      else this.pending = this.pending.concat(_);
      if (this.pendingTotal += _.length, this.pending.length >= this._delta8) {
        _ = this.pending;
        var O = _.length % this._delta8;
        if (this.pending = _.slice(_.length - O, _.length), this.pending.length === 0) this.pending = null;
        _ = q.join32(_, 0, _.length - O, this.endian);
        for (var z = 0; z < _.length; z += this._delta32) this._update(_, z, z + this._delta32);
      }
      return this;
    }, P.prototype.digest = function(_) {
      return this.update(this._pad()), K(this.pending === null), this._digest(_);
    }, P.prototype._pad = function() {
      var _ = this.pendingTotal, Y = this._delta8, O = Y - (_ + this.padLength) % Y, z = Array(O + this.padLength);
      z[0] = 128;
      for (var J = 1; J < O; J++) z[J] = 0;
      if (_ <<= 3, this.endian === "big") {
        for (var T = 8; T < this.padLength; T++) z[J++] = 0;
        z[J++] = 0, z[J++] = 0, z[J++] = 0, z[J++] = 0, z[J++] = _ >>> 24 & 255, z[J++] = _ >>> 16 & 255, z[J++] = _ >>> 8 & 255, z[J++] = _ & 255;
      } else {
        z[J++] = _ & 255, z[J++] = _ >>> 8 & 255, z[J++] = _ >>> 16 & 255, z[J++] = _ >>> 24 & 255, z[J++] = 0, z[J++] = 0, z[J++] = 0, z[J++] = 0;
        for (T = 8; T < this.padLength; T++) z[J++] = 0;
      }
      return z;
    };
  }), O0 = r$(($18) => {
    var q = s8(), K = q.rotr32;
    function P(f, V, M, N) {
      if (f === 0) return _(V, M, N);
      if (f === 1 || f === 3) return O(V, M, N);
      if (f === 2) return Y(V, M, N);
    }
    $18.ft_1 = P;
    function _(f, V, M) {
      return f & V ^ ~f & M;
    }
    $18.ch32 = _;
    function Y(f, V, M) {
      return f & V ^ f & M ^ V & M;
    }
    $18.maj32 = Y;
    function O(f, V, M) {
      return f ^ V ^ M;
    }
    $18.p32 = O;
    function z(f) {
      return K(f, 2) ^ K(f, 13) ^ K(f, 22);
    }
    $18.s0_256 = z;
    function J(f) {
      return K(f, 6) ^ K(f, 11) ^ K(f, 25);
    }
    $18.s1_256 = J;
    function T(f) {
      return K(f, 7) ^ K(f, 18) ^ f >>> 3;
    }
    $18.g0_256 = T;
    function X(f) {
      return K(f, 17) ^ K(f, 19) ^ f >>> 10;
    }
    $18.g1_256 = X;
  }), ir = r$(($18, q) => {
    var K = s8(), P = t7(), _ = O0(), Y = K.rotl32, O = K.sum32, z = K.sum32_5, J = _.ft_1, T = P.BlockHash, X = [1518500249, 1859775393, 2400959708, 3395469782];
    function f() {
      if (!(this instanceof f)) return new f();
      T.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.W = Array(80);
    }
    K.inherits(f, T), q.exports = f, f.blockSize = 512, f.outSize = 160, f.hmacStrength = 80, f.padLength = 64, f.prototype._update = function(V, M) {
      var N = this.W;
      for (var h = 0; h < 16; h++) N[h] = V[M + h];
      for (; h < N.length; h++) N[h] = Y(N[h - 3] ^ N[h - 8] ^ N[h - 14] ^ N[h - 16], 1);
      var E = this.h[0], I = this.h[1], D = this.h[2], g = this.h[3], b = this.h[4];
      for (h = 0; h < N.length; h++) {
        var y = ~~(h / 20), p = z(Y(E, 5), J(y, I, D, g), b, N[h], X[y]);
        b = g, g = D, D = Y(I, 30), I = E, E = p;
      }
      this.h[0] = O(this.h[0], E), this.h[1] = O(this.h[1], I), this.h[2] = O(this.h[2], D), this.h[3] = O(this.h[3], g), this.h[4] = O(this.h[4], b);
    }, f.prototype._digest = function(V) {
      if (V === "hex") return K.toHex32(this.h, "big");
      else return K.split32(this.h, "big");
    };
  }), Y0 = r$(($18, q) => {
    var K = s8(), P = t7(), _ = O0(), Y = $_(), O = K.sum32, z = K.sum32_4, J = K.sum32_5, T = _.ch32, X = _.maj32, f = _.s0_256, V = _.s1_256, M = _.g0_256, N = _.g1_256, h = P.BlockHash, E = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298];
    function I() {
      if (!(this instanceof I)) return new I();
      h.call(this), this.h = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225], this.k = E, this.W = Array(64);
    }
    K.inherits(I, h), q.exports = I, I.blockSize = 512, I.outSize = 256, I.hmacStrength = 192, I.padLength = 64, I.prototype._update = function(D, g) {
      var b = this.W;
      for (var y = 0; y < 16; y++) b[y] = D[g + y];
      for (; y < b.length; y++) b[y] = z(N(b[y - 2]), b[y - 7], M(b[y - 15]), b[y - 16]);
      var p = this.h[0], n = this.h[1], s = this.h[2], q$ = this.h[3], c = this.h[4], U = this.h[5], j = this.h[6], H = this.h[7];
      Y(this.k.length === b.length);
      for (y = 0; y < b.length; y++) {
        var Z = J(H, V(c), T(c, U, j), this.k[y], b[y]), W = O(f(p), X(p, n, s));
        H = j, j = U, U = c, c = O(q$, Z), q$ = s, s = n, n = p, p = O(Z, W);
      }
      this.h[0] = O(this.h[0], p), this.h[1] = O(this.h[1], n), this.h[2] = O(this.h[2], s), this.h[3] = O(this.h[3], q$), this.h[4] = O(this.h[4], c), this.h[5] = O(this.h[5], U), this.h[6] = O(this.h[6], j), this.h[7] = O(this.h[7], H);
    }, I.prototype._digest = function(D) {
      if (D === "hex") return K.toHex32(this.h, "big");
      else return K.split32(this.h, "big");
    };
  }), Br = r$(($18, q) => {
    var K = s8(), P = Y0();
    function _() {
      if (!(this instanceof _)) return new _();
      P.call(this), this.h = [3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428];
    }
    K.inherits(_, P), q.exports = _, _.blockSize = 512, _.outSize = 224, _.hmacStrength = 192, _.padLength = 64, _.prototype._digest = function(Y) {
      if (Y === "hex") return K.toHex32(this.h.slice(0, 7), "big");
      else return K.split32(this.h.slice(0, 7), "big");
    };
  }), j0 = r$(($18, q) => {
    var K = s8(), P = t7(), _ = $_(), Y = K.rotr64_hi, O = K.rotr64_lo, z = K.shr64_hi, J = K.shr64_lo, T = K.sum64, X = K.sum64_hi, f = K.sum64_lo, V = K.sum64_4_hi, M = K.sum64_4_lo, N = K.sum64_5_hi, h = K.sum64_5_lo, E = P.BlockHash, I = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591];
    function D() {
      if (!(this instanceof D)) return new D();
      E.call(this), this.h = [1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723, 2773480762, 1595750129, 1359893119, 2917565137, 2600822924, 725511199, 528734635, 4215389547, 1541459225, 327033209], this.k = I, this.W = Array(160);
    }
    K.inherits(D, E), q.exports = D, D.blockSize = 1024, D.outSize = 512, D.hmacStrength = 192, D.padLength = 128, D.prototype._prepareBlock = function(W, w) {
      var G = this.W;
      for (var S = 0; S < 32; S++) G[S] = W[w + S];
      for (; S < G.length; S += 2) {
        var A = H(G[S - 4], G[S - 3]), v = Z(G[S - 4], G[S - 3]), k = G[S - 14], R = G[S - 13], C = U(G[S - 30], G[S - 29]), L = j(G[S - 30], G[S - 29]), x = G[S - 32], l = G[S - 31];
        G[S] = V(A, v, k, R, C, L, x, l), G[S + 1] = M(A, v, k, R, C, L, x, l);
      }
    }, D.prototype._update = function(W, w) {
      this._prepareBlock(W, w);
      var G = this.W, S = this.h[0], A = this.h[1], v = this.h[2], k = this.h[3], R = this.h[4], C = this.h[5], L = this.h[6], x = this.h[7], l = this.h[8], a = this.h[9], f$ = this.h[10], $$ = this.h[11], B = this.h[12], H$ = this.h[13], Q = this.h[14], v$ = this.h[15];
      _(this.k.length === G.length);
      for (var t$ = 0; t$ < G.length; t$ += 2) {
        var m = Q, r = v$, J$ = q$(l, a), e = c(l, a), _$2 = g(l, a, f$, $$, B, H$), Y$ = b(l, a, f$, $$, B, H$), d = this.k[t$], o = this.k[t$ + 1], W$ = G[t$], t = G[t$ + 1], F = N(m, r, J$, e, _$2, Y$, d, o, W$, t), X$ = h(m, r, J$, e, _$2, Y$, d, o, W$, t);
        m = n(S, A), r = s(S, A), J$ = y(S, A, v, k, R, C), e = p(S, A, v, k, R, C);
        var z$ = X(m, r, J$, e), j$ = f(m, r, J$, e);
        Q = B, v$ = H$, B = f$, H$ = $$, f$ = l, $$ = a, l = X(L, x, F, X$), a = f(x, x, F, X$), L = R, x = C, R = v, C = k, v = S, k = A, S = X(F, X$, z$, j$), A = f(F, X$, z$, j$);
      }
      T(this.h, 0, S, A), T(this.h, 2, v, k), T(this.h, 4, R, C), T(this.h, 6, L, x), T(this.h, 8, l, a), T(this.h, 10, f$, $$), T(this.h, 12, B, H$), T(this.h, 14, Q, v$);
    }, D.prototype._digest = function(W) {
      if (W === "hex") return K.toHex32(this.h, "big");
      else return K.split32(this.h, "big");
    };
    function g(W, w, G, S, A) {
      var v = W & G ^ ~W & A;
      if (v < 0) v += 4294967296;
      return v;
    }
    function b(W, w, G, S, A, v) {
      var k = w & S ^ ~w & v;
      if (k < 0) k += 4294967296;
      return k;
    }
    function y(W, w, G, S, A) {
      var v = W & G ^ W & A ^ G & A;
      if (v < 0) v += 4294967296;
      return v;
    }
    function p(W, w, G, S, A, v) {
      var k = w & S ^ w & v ^ S & v;
      if (k < 0) k += 4294967296;
      return k;
    }
    function n(W, w) {
      var G = Y(W, w, 28), S = Y(w, W, 2), A = Y(w, W, 7), v = G ^ S ^ A;
      if (v < 0) v += 4294967296;
      return v;
    }
    function s(W, w) {
      var G = O(W, w, 28), S = O(w, W, 2), A = O(w, W, 7), v = G ^ S ^ A;
      if (v < 0) v += 4294967296;
      return v;
    }
    function q$(W, w) {
      var G = Y(W, w, 14), S = Y(W, w, 18), A = Y(w, W, 9), v = G ^ S ^ A;
      if (v < 0) v += 4294967296;
      return v;
    }
    function c(W, w) {
      var G = O(W, w, 14), S = O(W, w, 18), A = O(w, W, 9), v = G ^ S ^ A;
      if (v < 0) v += 4294967296;
      return v;
    }
    function U(W, w) {
      var G = Y(W, w, 1), S = Y(W, w, 8), A = z(W, w, 7), v = G ^ S ^ A;
      if (v < 0) v += 4294967296;
      return v;
    }
    function j(W, w) {
      var G = O(W, w, 1), S = O(W, w, 8), A = J(W, w, 7), v = G ^ S ^ A;
      if (v < 0) v += 4294967296;
      return v;
    }
    function H(W, w) {
      var G = Y(W, w, 19), S = Y(w, W, 29), A = z(W, w, 6), v = G ^ S ^ A;
      if (v < 0) v += 4294967296;
      return v;
    }
    function Z(W, w) {
      var G = O(W, w, 19), S = O(w, W, 29), A = J(W, w, 6), v = G ^ S ^ A;
      if (v < 0) v += 4294967296;
      return v;
    }
  }), tr = r$(($18, q) => {
    var K = s8(), P = j0();
    function _() {
      if (!(this instanceof _)) return new _();
      P.call(this), this.h = [3418070365, 3238371032, 1654270250, 914150663, 2438529370, 812702999, 355462360, 4144912697, 1731405415, 4290775857, 2394180231, 1750603025, 3675008525, 1694076839, 1203062813, 3204075428];
    }
    K.inherits(_, P), q.exports = _, _.blockSize = 1024, _.outSize = 384, _.hmacStrength = 192, _.padLength = 128, _.prototype._digest = function(Y) {
      if (Y === "hex") return K.toHex32(this.h.slice(0, 12), "big");
      else return K.split32(this.h.slice(0, 12), "big");
    };
  }), Ur = r$(($18) => {
    $18.sha1 = ir(), $18.sha224 = Br(), $18.sha256 = Y0(), $18.sha384 = tr(), $18.sha512 = j0();
  }), Fr = r$(($18) => {
    var q = s8(), K = t7(), P = q.rotl32, _ = q.sum32, Y = q.sum32_3, O = q.sum32_4, z = K.BlockHash;
    function J() {
      if (!(this instanceof J)) return new J();
      z.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = "little";
    }
    q.inherits(J, z), $18.ripemd160 = J, J.blockSize = 512, J.outSize = 160, J.hmacStrength = 192, J.padLength = 64, J.prototype._update = function(E, I) {
      var D = this.h[0], g = this.h[1], b = this.h[2], y = this.h[3], p = this.h[4], n = D, s = g, q$ = b, c = y, U = p;
      for (var j = 0; j < 80; j++) {
        var H = _(P(O(D, T(j, g, b, y), E[V[j] + I], X(j)), N[j]), p);
        D = p, p = y, y = P(b, 10), b = g, g = H, H = _(P(O(n, T(79 - j, s, q$, c), E[M[j] + I], f(j)), h[j]), U), n = U, U = c, c = P(q$, 10), q$ = s, s = H;
      }
      H = Y(this.h[1], b, c), this.h[1] = Y(this.h[2], y, U), this.h[2] = Y(this.h[3], p, n), this.h[3] = Y(this.h[4], D, s), this.h[4] = Y(this.h[0], g, q$), this.h[0] = H;
    }, J.prototype._digest = function(E) {
      if (E === "hex") return q.toHex32(this.h, "little");
      else return q.split32(this.h, "little");
    };
    function T(E, I, D, g) {
      if (E <= 15) return I ^ D ^ g;
      else if (E <= 31) return I & D | ~I & g;
      else if (E <= 47) return (I | ~D) ^ g;
      else if (E <= 63) return I & g | D & ~g;
      else return I ^ (D | ~g);
    }
    function X(E) {
      if (E <= 15) return 0;
      else if (E <= 31) return 1518500249;
      else if (E <= 47) return 1859775393;
      else if (E <= 63) return 2400959708;
      else return 2840853838;
    }
    function f(E) {
      if (E <= 15) return 1352829926;
      else if (E <= 31) return 1548603684;
      else if (E <= 47) return 1836072691;
      else if (E <= 63) return 2053994217;
      else return 0;
    }
    var V = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13], M = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11], N = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6], h = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11];
  }), ar = r$(($18, q) => {
    var K = s8(), P = $_();
    function _(Y, O, z) {
      if (!(this instanceof _)) return new _(Y, O, z);
      this.Hash = Y, this.blockSize = Y.blockSize / 8, this.outSize = Y.outSize / 8, this.inner = null, this.outer = null, this._init(K.toArray(O, z));
    }
    q.exports = _, _.prototype._init = function(Y) {
      if (Y.length > this.blockSize) Y = new this.Hash().update(Y).digest();
      P(Y.length <= this.blockSize);
      for (var O = Y.length; O < this.blockSize; O++) Y.push(0);
      for (O = 0; O < Y.length; O++) Y[O] ^= 54;
      this.inner = new this.Hash().update(Y);
      for (O = 0; O < Y.length; O++) Y[O] ^= 106;
      this.outer = new this.Hash().update(Y);
    }, _.prototype.update = function(Y, O) {
      return this.inner.update(Y, O), this;
    }, _.prototype.digest = function(Y) {
      return this.outer.update(this.inner.digest()), this.outer.digest(Y);
    };
  }), oH = r$(($18) => {
    var q = $18;
    q.utils = s8(), q.common = t7(), q.sha = Ur(), q.ripemd = Fr(), q.hmac = ar(), q.sha1 = q.sha.sha1, q.sha256 = q.sha.sha256, q.sha224 = q.sha.sha224, q.sha384 = q.sha.sha384, q.sha512 = q.sha.sha512, q.ripemd160 = q.ripemd.ripemd160;
  }), Qr = r$(($18, q) => {
    q.exports = { doubles: { step: 4, points: [["e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a", "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"], ["8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508", "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"], ["175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739", "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"], ["363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640", "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"], ["8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c", "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"], ["723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda", "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"], ["eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa", "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"], ["100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0", "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"], ["e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d", "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"], ["feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d", "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"], ["da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1", "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"], ["53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0", "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"], ["8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047", "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"], ["385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862", "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"], ["6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7", "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"], ["3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd", "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"], ["85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83", "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"], ["948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a", "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"], ["6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8", "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"], ["e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d", "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"], ["e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725", "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"], ["213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754", "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"], ["4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c", "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"], ["fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6", "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"], ["76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39", "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"], ["c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891", "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"], ["d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b", "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"], ["b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03", "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"], ["e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d", "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"], ["a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070", "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"], ["90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4", "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"], ["8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da", "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"], ["e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11", "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"], ["8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e", "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"], ["e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41", "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"], ["b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef", "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"], ["d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8", "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"], ["324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d", "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"], ["4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96", "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"], ["9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd", "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"], ["6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5", "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"], ["a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266", "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"], ["7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71", "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"], ["928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac", "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"], ["85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751", "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"], ["ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e", "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"], ["827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241", "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"], ["eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3", "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"], ["e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f", "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"], ["1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19", "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"], ["146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be", "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"], ["fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9", "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"], ["da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2", "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"], ["a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13", "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"], ["174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c", "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"], ["959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba", "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"], ["d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151", "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"], ["64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073", "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"], ["8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458", "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"], ["13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b", "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"], ["bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366", "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"], ["8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa", "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"], ["8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0", "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"], ["dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787", "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"], ["f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e", "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"]] }, naf: { wnd: 7, points: [["f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9", "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"], ["2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4", "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"], ["5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc", "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"], ["acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe", "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"], ["774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb", "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"], ["f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8", "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"], ["d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e", "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"], ["defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34", "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"], ["2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c", "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"], ["352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5", "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"], ["2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f", "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"], ["9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714", "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"], ["daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729", "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"], ["c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db", "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"], ["6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4", "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"], ["1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5", "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"], ["605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479", "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"], ["62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d", "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"], ["80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f", "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"], ["7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb", "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"], ["d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9", "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"], ["49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963", "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"], ["77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74", "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"], ["f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530", "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"], ["463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b", "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"], ["f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247", "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"], ["caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1", "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"], ["2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120", "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"], ["7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435", "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"], ["754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18", "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"], ["e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8", "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"], ["186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb", "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"], ["df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f", "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"], ["5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143", "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"], ["290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba", "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"], ["af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45", "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"], ["766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a", "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"], ["59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e", "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"], ["f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8", "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"], ["7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c", "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"], ["948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519", "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"], ["7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab", "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"], ["3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca", "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"], ["d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf", "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"], ["1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610", "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"], ["733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4", "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"], ["15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c", "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"], ["a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940", "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"], ["e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980", "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"], ["311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3", "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"], ["34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf", "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"], ["f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63", "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"], ["d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448", "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"], ["32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf", "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"], ["7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5", "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"], ["ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6", "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"], ["16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5", "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"], ["eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99", "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"], ["78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51", "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"], ["494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5", "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"], ["a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5", "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"], ["c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997", "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"], ["841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881", "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"], ["5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5", "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"], ["36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66", "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"], ["336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726", "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"], ["8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede", "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"], ["1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94", "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"], ["85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31", "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"], ["29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51", "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"], ["a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252", "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"], ["4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5", "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"], ["d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b", "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"], ["ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4", "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"], ["af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f", "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"], ["e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889", "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"], ["591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246", "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"], ["11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984", "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"], ["3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a", "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"], ["cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030", "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"], ["c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197", "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"], ["c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593", "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"], ["a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef", "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"], ["347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38", "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"], ["da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a", "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"], ["c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111", "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"], ["4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502", "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"], ["3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea", "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"], ["cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26", "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"], ["b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986", "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"], ["d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e", "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"], ["48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4", "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"], ["dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda", "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"], ["6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859", "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"], ["e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f", "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"], ["eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c", "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"], ["13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942", "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"], ["ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a", "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"], ["b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80", "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"], ["ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d", "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"], ["8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1", "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"], ["52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63", "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"], ["e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352", "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"], ["7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193", "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"], ["5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00", "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"], ["32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58", "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"], ["e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7", "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"], ["8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8", "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"], ["4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e", "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"], ["3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d", "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"], ["674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b", "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"], ["d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f", "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"], ["30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6", "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"], ["be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297", "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"], ["93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a", "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"], ["b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c", "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"], ["d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52", "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"], ["d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb", "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"], ["463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065", "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"], ["7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917", "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"], ["74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9", "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"], ["30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3", "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"], ["9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57", "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"], ["176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66", "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"], ["75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8", "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"], ["809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721", "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"], ["1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180", "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"]] } };
  }), nH = r$(($18) => {
    var q = $18, K = oH(), P = P0(), _ = S8(), Y = _.assert;
    function O(T) {
      if (T.type === "short") this.curve = new P.short(T);
      else if (T.type === "edwards") this.curve = new P.edwards(T);
      else this.curve = new P.mont(T);
      this.g = this.curve.g, this.n = this.curve.n, this.hash = T.hash, Y(this.g.validate(), "Invalid curve"), Y(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
    }
    q.PresetCurve = O;
    function z(T, X) {
      Object.defineProperty(q, T, { configurable: true, enumerable: true, get: function() {
        var f = new O(X);
        return Object.defineProperty(q, T, { configurable: true, enumerable: true, value: f }), f;
      } });
    }
    z("p192", { type: "short", prime: "p192", p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff", a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc", b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1", n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831", hash: K.sha256, gRed: false, g: ["188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012", "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"] }), z("p224", { type: "short", prime: "p224", p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001", a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe", b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4", n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d", hash: K.sha256, gRed: false, g: ["b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21", "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"] }), z("p256", { type: "short", prime: null, p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff", a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc", b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b", n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551", hash: K.sha256, gRed: false, g: ["6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296", "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"] }), z("p384", { type: "short", prime: null, p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff", a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc", b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef", n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973", hash: K.sha384, gRed: false, g: ["aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7", "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"] }), z("p521", { type: "short", prime: null, p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff", a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc", b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00", n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409", hash: K.sha512, gRed: false, g: ["000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66", "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"] }), z("curve25519", { type: "mont", prime: "p25519", p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed", a: "76d06", b: "1", n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed", hash: K.sha256, gRed: false, g: ["9"] }), z("ed25519", { type: "edwards", prime: "p25519", p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed", a: "-1", c: "1", d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3", n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed", hash: K.sha256, gRed: false, g: ["216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a", "6666666666666666666666666666666666666666666666666666666666666658"] });
    var J;
    try {
      J = Qr();
    } catch (T) {
      J = void 0;
    }
    z("secp256k1", { type: "short", prime: "k256", p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f", a: "0", b: "7", n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141", h: "1", hash: K.sha256, beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee", lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72", basis: [{ a: "3086d221a7d46bcde86c90e49284eb15", b: "-e4437ed6010e88286f547fa90abfe4c3" }, { a: "114ca50f7a8e2f3f657c1108d9d44cfd8", b: "3086d221a7d46bcde86c90e49284eb15" }], gRed: false, g: ["79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798", "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8", J] });
  }), er = r$(($18, q) => {
    var K = oH(), P = K0(), _ = $_();
    function Y(O) {
      if (!(this instanceof Y)) return new Y(O);
      this.hash = O.hash, this.predResist = !!O.predResist, this.outLen = this.hash.outSize, this.minEntropy = O.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
      var z = P.toArray(O.entropy, O.entropyEnc || "hex"), J = P.toArray(O.nonce, O.nonceEnc || "hex"), T = P.toArray(O.pers, O.persEnc || "hex");
      _(z.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._init(z, J, T);
    }
    q.exports = Y, Y.prototype._init = function(O, z, J) {
      var T = O.concat(z).concat(J);
      this.K = Array(this.outLen / 8), this.V = Array(this.outLen / 8);
      for (var X = 0; X < this.V.length; X++) this.K[X] = 0, this.V[X] = 1;
      this._update(T), this._reseed = 1, this.reseedInterval = 281474976710656;
    }, Y.prototype._hmac = function() {
      return new K.hmac(this.hash, this.K);
    }, Y.prototype._update = function(O) {
      var z = this._hmac().update(this.V).update([0]);
      if (O) z = z.update(O);
      if (this.K = z.digest(), this.V = this._hmac().update(this.V).digest(), !O) return;
      this.K = this._hmac().update(this.V).update([1]).update(O).digest(), this.V = this._hmac().update(this.V).digest();
    }, Y.prototype.reseed = function(O, z, J, T) {
      if (typeof z !== "string") T = J, J = z, z = null;
      O = P.toArray(O, z), J = P.toArray(J, T), _(O.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._update(O.concat(J || [])), this._reseed = 1;
    }, Y.prototype.generate = function(O, z, J, T) {
      if (this._reseed > this.reseedInterval) throw Error("Reseed is required");
      if (typeof z !== "string") T = J, J = z, z = null;
      if (J) J = P.toArray(J, T || "hex"), this._update(J);
      var X = [];
      while (X.length < O) this.V = this._hmac().update(this.V).digest(), X = X.concat(this.V);
      var f = X.slice(0, O);
      return this._update(J), this._reseed++, P.encode(f, z);
    };
  }), sr = r$(($18, q) => {
    var K = MK(), P = S8(), _ = P.assert;
    function Y(O, z) {
      if (this.ec = O, this.priv = null, this.pub = null, z.priv) this._importPrivate(z.priv, z.privEnc);
      if (z.pub) this._importPublic(z.pub, z.pubEnc);
    }
    q.exports = Y, Y.fromPublic = function(O, z, J) {
      if (z instanceof Y) return z;
      return new Y(O, { pub: z, pubEnc: J });
    }, Y.fromPrivate = function(O, z, J) {
      if (z instanceof Y) return z;
      return new Y(O, { priv: z, privEnc: J });
    }, Y.prototype.validate = function() {
      var O = this.getPublic();
      if (O.isInfinity()) return { result: false, reason: "Invalid public key" };
      if (!O.validate()) return { result: false, reason: "Public key is not a point" };
      if (!O.mul(this.ec.curve.n).isInfinity()) return { result: false, reason: "Public key * N != O" };
      return { result: true, reason: null };
    }, Y.prototype.getPublic = function(O, z) {
      if (typeof O === "string") z = O, O = null;
      if (!this.pub) this.pub = this.ec.g.mul(this.priv);
      if (!z) return this.pub;
      return this.pub.encode(z, O);
    }, Y.prototype.getPrivate = function(O) {
      if (O === "hex") return this.priv.toString(16, 2);
      else return this.priv;
    }, Y.prototype._importPrivate = function(O, z) {
      this.priv = new K(O, z || 16), this.priv = this.priv.umod(this.ec.curve.n);
    }, Y.prototype._importPublic = function(O, z) {
      if (O.x || O.y) {
        if (this.ec.curve.type === "mont") _(O.x, "Need x coordinate");
        else if (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") _(O.x && O.y, "Need both x and y coordinate");
        this.pub = this.ec.curve.point(O.x, O.y);
        return;
      }
      this.pub = this.ec.curve.decodePoint(O, z);
    }, Y.prototype.derive = function(O) {
      if (!O.validate()) _(O.validate(), "public point not validated");
      return O.mul(this.priv).getX();
    }, Y.prototype.sign = function(O, z, J) {
      return this.ec.sign(O, this, z, J);
    }, Y.prototype.verify = function(O, z, J) {
      return this.ec.verify(O, z, this, void 0, J);
    }, Y.prototype.inspect = function() {
      return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
    };
  }), $o = r$(($18, q) => {
    var K = MK(), P = S8(), _ = P.assert;
    function Y(X, f) {
      if (X instanceof Y) return X;
      if (this._importDER(X, f)) return;
      if (_(X.r && X.s, "Signature without r or s"), this.r = new K(X.r, 16), this.s = new K(X.s, 16), X.recoveryParam === void 0) this.recoveryParam = null;
      else this.recoveryParam = X.recoveryParam;
    }
    q.exports = Y;
    function O() {
      this.place = 0;
    }
    function z(X, f) {
      var V = X[f.place++];
      if (!(V & 128)) return V;
      var M = V & 15;
      if (M === 0 || M > 4) return false;
      if (X[f.place] === 0) return false;
      var N = 0;
      for (var h = 0, E = f.place; h < M; h++, E++) N <<= 8, N |= X[E], N >>>= 0;
      if (N <= 127) return false;
      return f.place = E, N;
    }
    function J(X) {
      var f = 0, V = X.length - 1;
      while (!X[f] && !(X[f + 1] & 128) && f < V) f++;
      if (f === 0) return X;
      return X.slice(f);
    }
    Y.prototype._importDER = function(X, f) {
      X = P.toArray(X, f);
      var V = new O();
      if (X[V.place++] !== 48) return false;
      var M = z(X, V);
      if (M === false) return false;
      if (M + V.place !== X.length) return false;
      if (X[V.place++] !== 2) return false;
      var N = z(X, V);
      if (N === false) return false;
      if ((X[V.place] & 128) !== 0) return false;
      var h = X.slice(V.place, N + V.place);
      if (V.place += N, X[V.place++] !== 2) return false;
      var E = z(X, V);
      if (E === false) return false;
      if (X.length !== E + V.place) return false;
      if ((X[V.place] & 128) !== 0) return false;
      var I = X.slice(V.place, E + V.place);
      if (h[0] === 0) if (h[1] & 128) h = h.slice(1);
      else return false;
      if (I[0] === 0) if (I[1] & 128) I = I.slice(1);
      else return false;
      return this.r = new K(h), this.s = new K(I), this.recoveryParam = null, true;
    };
    function T(X, f) {
      if (f < 128) {
        X.push(f);
        return;
      }
      var V = 1 + (Math.log(f) / Math.LN2 >>> 3);
      X.push(V | 128);
      while (--V) X.push(f >>> (V << 3) & 255);
      X.push(f);
    }
    Y.prototype.toDER = function(X) {
      var f = this.r.toArray(), V = this.s.toArray();
      if (f[0] & 128) f = [0].concat(f);
      if (V[0] & 128) V = [0].concat(V);
      f = J(f), V = J(V);
      while (!V[0] && !(V[1] & 128)) V = V.slice(1);
      var M = [2];
      T(M, f.length), M = M.concat(f), M.push(2), T(M, V.length);
      var N = M.concat(V), h = [48];
      return T(h, N.length), h = h.concat(N), P.encode(h, X);
    };
  }), qo = r$(($18, q) => {
    var K = MK(), P = er(), _ = S8(), Y = nH(), O = _0(), z = _.assert, J = sr(), T = $o();
    function X(f) {
      if (!(this instanceof X)) return new X(f);
      if (typeof f === "string") z(Object.prototype.hasOwnProperty.call(Y, f), "Unknown curve " + f), f = Y[f];
      if (f instanceof Y.PresetCurve) f = { curve: f };
      this.curve = f.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = f.curve.g, this.g.precompute(f.curve.n.bitLength() + 1), this.hash = f.hash || f.curve.hash;
    }
    q.exports = X, X.prototype.keyPair = function(f) {
      return new J(this, f);
    }, X.prototype.keyFromPrivate = function(f, V) {
      return J.fromPrivate(this, f, V);
    }, X.prototype.keyFromPublic = function(f, V) {
      return J.fromPublic(this, f, V);
    }, X.prototype.genKeyPair = function(f) {
      if (!f) f = {};
      var V = new P({ hash: this.hash, pers: f.pers, persEnc: f.persEnc || "utf8", entropy: f.entropy || O(this.hash.hmacStrength), entropyEnc: f.entropy && f.entropyEnc || "utf8", nonce: this.n.toArray() }), M = this.n.byteLength(), N = this.n.sub(new K(2));
      for (; ; ) {
        var h = new K(V.generate(M));
        if (h.cmp(N) > 0) continue;
        return h.iaddn(1), this.keyFromPrivate(h);
      }
    }, X.prototype._truncateToN = function(f, V, M) {
      var N;
      if (K.isBN(f) || typeof f === "number") f = new K(f, 16), N = f.byteLength();
      else if (typeof f === "object") N = f.length, f = new K(f, 16);
      else {
        var h = f.toString();
        N = h.length + 1 >>> 1, f = new K(h, 16);
      }
      if (typeof M !== "number") M = N * 8;
      var E = M - this.n.bitLength();
      if (E > 0) f = f.ushrn(E);
      if (!V && f.cmp(this.n) >= 0) return f.sub(this.n);
      else return f;
    }, X.prototype.sign = function(f, V, M, N) {
      if (typeof M === "object") N = M, M = null;
      if (!N) N = {};
      if (typeof f !== "string" && typeof f !== "number" && !K.isBN(f)) {
        z(typeof f === "object" && f && typeof f.length === "number", "Expected message to be an array-like, a hex string, or a BN instance"), z(f.length >>> 0 === f.length);
        for (var h = 0; h < f.length; h++) z((f[h] & 255) === f[h]);
      }
      V = this.keyFromPrivate(V, M), f = this._truncateToN(f, false, N.msgBitLength), z(!f.isNeg(), "Can not sign a negative message");
      var E = this.n.byteLength(), I = V.getPrivate().toArray("be", E), D = f.toArray("be", E);
      z(new K(D).eq(f), "Can not sign message");
      var g = new P({ hash: this.hash, entropy: I, nonce: D, pers: N.pers, persEnc: N.persEnc || "utf8" }), b = this.n.sub(new K(1));
      for (var y = 0; ; y++) {
        var p = N.k ? N.k(y) : new K(g.generate(this.n.byteLength()));
        if (p = this._truncateToN(p, true), p.cmpn(1) <= 0 || p.cmp(b) >= 0) continue;
        var n = this.g.mul(p);
        if (n.isInfinity()) continue;
        var s = n.getX(), q$ = s.umod(this.n);
        if (q$.cmpn(0) === 0) continue;
        var c = p.invm(this.n).mul(q$.mul(V.getPrivate()).iadd(f));
        if (c = c.umod(this.n), c.cmpn(0) === 0) continue;
        var U = (n.getY().isOdd() ? 1 : 0) | (s.cmp(q$) !== 0 ? 2 : 0);
        if (N.canonical && c.cmp(this.nh) > 0) c = this.n.sub(c), U ^= 1;
        return new T({ r: q$, s: c, recoveryParam: U });
      }
    }, X.prototype.verify = function(f, V, M, N, h) {
      if (!h) h = {};
      f = this._truncateToN(f, false, h.msgBitLength), M = this.keyFromPublic(M, N), V = new T(V, "hex");
      var { r: E, s: I } = V;
      if (E.cmpn(1) < 0 || E.cmp(this.n) >= 0) return false;
      if (I.cmpn(1) < 0 || I.cmp(this.n) >= 0) return false;
      var D = I.invm(this.n), g = D.mul(f).umod(this.n), b = D.mul(E).umod(this.n), y;
      if (!this.curve._maxwellTrick) {
        if (y = this.g.mulAdd(g, M.getPublic(), b), y.isInfinity()) return false;
        return y.getX().umod(this.n).cmp(E) === 0;
      }
      if (y = this.g.jmulAdd(g, M.getPublic(), b), y.isInfinity()) return false;
      return y.eqXToP(E);
    }, X.prototype.recoverPubKey = function(f, V, M, N) {
      z((3 & M) === M, "The recovery param is more than two bits"), V = new T(V, N);
      var h = this.n, E = new K(f), I = V.r, D = V.s, g = M & 1, b = M >> 1;
      if (I.cmp(this.curve.p.umod(this.curve.n)) >= 0 && b) throw Error("Unable to find sencond key candinate");
      if (b) I = this.curve.pointFromX(I.add(this.curve.n), g);
      else I = this.curve.pointFromX(I, g);
      var y = V.r.invm(h), p = h.sub(E).mul(y).umod(h), n = D.mul(y).umod(h);
      return this.g.mulAdd(p, I, n);
    }, X.prototype.getKeyRecoveryParam = function(f, V, M, N) {
      if (V = new T(V, N), V.recoveryParam !== null) return V.recoveryParam;
      for (var h = 0; h < 4; h++) {
        var E;
        try {
          E = this.recoverPubKey(f, V, h);
        } catch (I) {
          continue;
        }
        if (E.eq(M)) return h;
      }
      throw Error("Unable to find valid recovery factor");
    };
  }), Ko = r$(($18, q) => {
    var K = S8(), P = K.assert, _ = K.parseBytes, Y = K.cachedProperty;
    function O(z, J) {
      if (this.eddsa = z, this._secret = _(J.secret), z.isPoint(J.pub)) this._pub = J.pub;
      else this._pubBytes = _(J.pub);
    }
    O.fromPublic = function(z, J) {
      if (J instanceof O) return J;
      return new O(z, { pub: J });
    }, O.fromSecret = function(z, J) {
      if (J instanceof O) return J;
      return new O(z, { secret: J });
    }, O.prototype.secret = function() {
      return this._secret;
    }, Y(O, "pubBytes", function() {
      return this.eddsa.encodePoint(this.pub());
    }), Y(O, "pub", function() {
      if (this._pubBytes) return this.eddsa.decodePoint(this._pubBytes);
      return this.eddsa.g.mul(this.priv());
    }), Y(O, "privBytes", function() {
      var z = this.eddsa, J = this.hash(), T = z.encodingLength - 1, X = J.slice(0, z.encodingLength);
      return X[0] &= 248, X[T] &= 127, X[T] |= 64, X;
    }), Y(O, "priv", function() {
      return this.eddsa.decodeInt(this.privBytes());
    }), Y(O, "hash", function() {
      return this.eddsa.hash().update(this.secret()).digest();
    }), Y(O, "messagePrefix", function() {
      return this.hash().slice(this.eddsa.encodingLength);
    }), O.prototype.sign = function(z) {
      return P(this._secret, "KeyPair can only verify"), this.eddsa.sign(z, this);
    }, O.prototype.verify = function(z, J) {
      return this.eddsa.verify(z, J, this);
    }, O.prototype.getSecret = function(z) {
      return P(this._secret, "KeyPair is public only"), K.encode(this.secret(), z);
    }, O.prototype.getPublic = function(z) {
      return K.encode(this.pubBytes(), z);
    }, q.exports = O;
  }), _o = r$(($18, q) => {
    var K = MK(), P = S8(), _ = P.assert, Y = P.cachedProperty, O = P.parseBytes;
    function z(J, T) {
      if (this.eddsa = J, typeof T !== "object") T = O(T);
      if (Array.isArray(T)) _(T.length === J.encodingLength * 2, "Signature has invalid size"), T = { R: T.slice(0, J.encodingLength), S: T.slice(J.encodingLength) };
      if (_(T.R && T.S, "Signature without R or S"), J.isPoint(T.R)) this._R = T.R;
      if (T.S instanceof K) this._S = T.S;
      this._Rencoded = Array.isArray(T.R) ? T.R : T.Rencoded, this._Sencoded = Array.isArray(T.S) ? T.S : T.Sencoded;
    }
    Y(z, "S", function() {
      return this.eddsa.decodeInt(this.Sencoded());
    }), Y(z, "R", function() {
      return this.eddsa.decodePoint(this.Rencoded());
    }), Y(z, "Rencoded", function() {
      return this.eddsa.encodePoint(this.R());
    }), Y(z, "Sencoded", function() {
      return this.eddsa.encodeInt(this.S());
    }), z.prototype.toBytes = function() {
      return this.Rencoded().concat(this.Sencoded());
    }, z.prototype.toHex = function() {
      return P.encode(this.toBytes(), "hex").toUpperCase();
    }, q.exports = z;
  }), Po = r$(($18, q) => {
    var K = oH(), P = nH(), _ = S8(), Y = _.assert, O = _.parseBytes, z = Ko(), J = _o();
    function T(X) {
      if (Y(X === "ed25519", "only tested with ed25519 so far"), !(this instanceof T)) return new T(X);
      X = P[X].curve, this.curve = X, this.g = X.g, this.g.precompute(X.n.bitLength() + 1), this.pointClass = X.point().constructor, this.encodingLength = Math.ceil(X.n.bitLength() / 8), this.hash = K.sha512;
    }
    q.exports = T, T.prototype.sign = function(X, f) {
      X = O(X);
      var V = this.keyFromSecret(f), M = this.hashInt(V.messagePrefix(), X), N = this.g.mul(M), h = this.encodePoint(N), E = this.hashInt(h, V.pubBytes(), X).mul(V.priv()), I = M.add(E).umod(this.curve.n);
      return this.makeSignature({ R: N, S: I, Rencoded: h });
    }, T.prototype.verify = function(X, f, V) {
      if (X = O(X), f = this.makeSignature(f), f.S().gte(f.eddsa.curve.n) || f.S().isNeg()) return false;
      var M = this.keyFromPublic(V), N = this.hashInt(f.Rencoded(), M.pubBytes(), X), h = this.g.mul(f.S()), E = f.R().add(M.pub().mul(N));
      return E.eq(h);
    }, T.prototype.hashInt = function() {
      var X = this.hash();
      for (var f = 0; f < arguments.length; f++) X.update(arguments[f]);
      return _.intFromLE(X.digest()).umod(this.curve.n);
    }, T.prototype.keyFromPublic = function(X) {
      return z.fromPublic(this, X);
    }, T.prototype.keyFromSecret = function(X) {
      return z.fromSecret(this, X);
    }, T.prototype.makeSignature = function(X) {
      if (X instanceof J) return X;
      return new J(this, X);
    }, T.prototype.encodePoint = function(X) {
      var f = X.getY().toArray("le", this.encodingLength);
      return f[this.encodingLength - 1] |= X.getX().isOdd() ? 128 : 0, f;
    }, T.prototype.decodePoint = function(X) {
      X = _.parseBytes(X);
      var f = X.length - 1, V = X.slice(0, f).concat(X[f] & -129), M = (X[f] & 128) !== 0, N = _.intFromLE(V);
      return this.curve.pointFromY(N, M);
    }, T.prototype.encodeInt = function(X) {
      return X.toArray("le", this.encodingLength);
    }, T.prototype.decodeInt = function(X) {
      return _.intFromLE(X);
    }, T.prototype.isPoint = function(X) {
      return X instanceof this.pointClass;
    };
  }), Oo = r$(($18) => {
    var q = $18;
    q.version = dr().version, q.utils = S8(), q.rand = _0(), q.curve = P0(), q.curves = nH(), q.ec = qo(), q.eddsa = Po();
  }), Yo = r$(($18, q) => {
    (function(K, P) {
      function _(j, H) {
        if (!j) throw Error(H || "Assertion failed");
      }
      function Y(j, H) {
        j.super_ = H;
        var Z = function() {
        };
        Z.prototype = H.prototype, j.prototype = new Z(), j.prototype.constructor = j;
      }
      function O(j, H, Z) {
        if (O.isBN(j)) return j;
        if (this.negative = 0, this.words = null, this.length = 0, this.red = null, j !== null) {
          if (H === "le" || H === "be") Z = H, H = 10;
          this._init(j || 0, H || 10, Z || "be");
        }
      }
      if (typeof K === "object") K.exports = O;
      else P.BN = O;
      O.BN = O, O.wordSize = 26;
      var z;
      try {
        if (typeof window < "u" && typeof window.Buffer < "u") z = window.Buffer;
        else z = (wq(), J6(Tq)).Buffer;
      } catch (j) {
      }
      O.isBN = function(j) {
        if (j instanceof O) return true;
        return j !== null && typeof j === "object" && j.constructor.wordSize === O.wordSize && Array.isArray(j.words);
      }, O.max = function(j, H) {
        if (j.cmp(H) > 0) return j;
        return H;
      }, O.min = function(j, H) {
        if (j.cmp(H) < 0) return j;
        return H;
      }, O.prototype._init = function(j, H, Z) {
        if (typeof j === "number") return this._initNumber(j, H, Z);
        if (typeof j === "object") return this._initArray(j, H, Z);
        if (H === "hex") H = 16;
        _(H === (H | 0) && H >= 2 && H <= 36), j = j.toString().replace(/\s+/g, "");
        var W = 0;
        if (j[0] === "-") W++, this.negative = 1;
        if (W < j.length) {
          if (H === 16) this._parseHex(j, W, Z);
          else if (this._parseBase(j, H, W), Z === "le") this._initArray(this.toArray(), H, Z);
        }
      }, O.prototype._initNumber = function(j, H, Z) {
        if (j < 0) this.negative = 1, j = -j;
        if (j < 67108864) this.words = [j & 67108863], this.length = 1;
        else if (j < 4503599627370496) this.words = [j & 67108863, j / 67108864 & 67108863], this.length = 2;
        else _(j < 9007199254740992), this.words = [j & 67108863, j / 67108864 & 67108863, 1], this.length = 3;
        if (Z !== "le") return;
        this._initArray(this.toArray(), H, Z);
      }, O.prototype._initArray = function(j, H, Z) {
        if (_(typeof j.length === "number"), j.length <= 0) return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(j.length / 3), this.words = Array(this.length);
        for (var W = 0; W < this.length; W++) this.words[W] = 0;
        var w, G, S = 0;
        if (Z === "be") {
          for (W = j.length - 1, w = 0; W >= 0; W -= 3) if (G = j[W] | j[W - 1] << 8 | j[W - 2] << 16, this.words[w] |= G << S & 67108863, this.words[w + 1] = G >>> 26 - S & 67108863, S += 24, S >= 26) S -= 26, w++;
        } else if (Z === "le") {
          for (W = 0, w = 0; W < j.length; W += 3) if (G = j[W] | j[W + 1] << 8 | j[W + 2] << 16, this.words[w] |= G << S & 67108863, this.words[w + 1] = G >>> 26 - S & 67108863, S += 24, S >= 26) S -= 26, w++;
        }
        return this.strip();
      };
      function J(j, H) {
        var Z = j.charCodeAt(H);
        if (Z >= 65 && Z <= 70) return Z - 55;
        else if (Z >= 97 && Z <= 102) return Z - 87;
        else return Z - 48 & 15;
      }
      function T(j, H, Z) {
        var W = J(j, Z);
        if (Z - 1 >= H) W |= J(j, Z - 1) << 4;
        return W;
      }
      O.prototype._parseHex = function(j, H, Z) {
        this.length = Math.ceil((j.length - H) / 6), this.words = Array(this.length);
        for (var W = 0; W < this.length; W++) this.words[W] = 0;
        var w = 0, G = 0, S;
        if (Z === "be") for (W = j.length - 1; W >= H; W -= 2) if (S = T(j, H, W) << w, this.words[G] |= S & 67108863, w >= 18) w -= 18, G += 1, this.words[G] |= S >>> 26;
        else w += 8;
        else {
          var A = j.length - H;
          for (W = A % 2 === 0 ? H + 1 : H; W < j.length; W += 2) if (S = T(j, H, W) << w, this.words[G] |= S & 67108863, w >= 18) w -= 18, G += 1, this.words[G] |= S >>> 26;
          else w += 8;
        }
        this.strip();
      };
      function X(j, H, Z, W) {
        var w = 0, G = Math.min(j.length, Z);
        for (var S = H; S < G; S++) {
          var A = j.charCodeAt(S) - 48;
          if (w *= W, A >= 49) w += A - 49 + 10;
          else if (A >= 17) w += A - 17 + 10;
          else w += A;
        }
        return w;
      }
      O.prototype._parseBase = function(j, H, Z) {
        this.words = [0], this.length = 1;
        for (var W = 0, w = 1; w <= 67108863; w *= H) W++;
        W--, w = w / H | 0;
        var G = j.length - Z, S = G % W, A = Math.min(G, G - S) + Z, v = 0;
        for (var k = Z; k < A; k += W) if (v = X(j, k, k + W, H), this.imuln(w), this.words[0] + v < 67108864) this.words[0] += v;
        else this._iaddn(v);
        if (S !== 0) {
          var R = 1;
          v = X(j, k, j.length, H);
          for (k = 0; k < S; k++) R *= H;
          if (this.imuln(R), this.words[0] + v < 67108864) this.words[0] += v;
          else this._iaddn(v);
        }
        this.strip();
      }, O.prototype.copy = function(j) {
        j.words = Array(this.length);
        for (var H = 0; H < this.length; H++) j.words[H] = this.words[H];
        j.length = this.length, j.negative = this.negative, j.red = this.red;
      }, O.prototype.clone = function() {
        var j = new O(null);
        return this.copy(j), j;
      }, O.prototype._expand = function(j) {
        while (this.length < j) this.words[this.length++] = 0;
        return this;
      }, O.prototype.strip = function() {
        while (this.length > 1 && this.words[this.length - 1] === 0) this.length--;
        return this._normSign();
      }, O.prototype._normSign = function() {
        if (this.length === 1 && this.words[0] === 0) this.negative = 0;
        return this;
      }, O.prototype.inspect = function() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var f = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], V = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], M = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
      if (O.prototype.toString = function(j, H) {
        j = j || 10, H = H | 0 || 1;
        var Z;
        if (j === 16 || j === "hex") {
          Z = "";
          var W = 0, w = 0;
          for (var G = 0; G < this.length; G++) {
            var S = this.words[G], A = ((S << W | w) & 16777215).toString(16);
            if (w = S >>> 24 - W & 16777215, W += 2, W >= 26) W -= 26, G--;
            if (w !== 0 || G !== this.length - 1) Z = f[6 - A.length] + A + Z;
            else Z = A + Z;
          }
          if (w !== 0) Z = w.toString(16) + Z;
          while (Z.length % H !== 0) Z = "0" + Z;
          if (this.negative !== 0) Z = "-" + Z;
          return Z;
        }
        if (j === (j | 0) && j >= 2 && j <= 36) {
          var v = V[j], k = M[j];
          Z = "";
          var R = this.clone();
          R.negative = 0;
          while (!R.isZero()) {
            var C = R.modn(k).toString(j);
            if (R = R.idivn(k), !R.isZero()) Z = f[v - C.length] + C + Z;
            else Z = C + Z;
          }
          if (this.isZero()) Z = "0" + Z;
          while (Z.length % H !== 0) Z = "0" + Z;
          if (this.negative !== 0) Z = "-" + Z;
          return Z;
        }
        _(false, "Base should be between 2 and 36");
      }, O.prototype.toNumber = function() {
        var j = this.words[0];
        if (this.length === 2) j += this.words[1] * 67108864;
        else if (this.length === 3 && this.words[2] === 1) j += 4503599627370496 + this.words[1] * 67108864;
        else if (this.length > 2) _(false, "Number can only safely store up to 53 bits");
        return this.negative !== 0 ? -j : j;
      }, O.prototype.toJSON = function() {
        return this.toString(16);
      }, O.prototype.toBuffer = function(j, H) {
        return _(typeof z < "u"), this.toArrayLike(z, j, H);
      }, O.prototype.toArray = function(j, H) {
        return this.toArrayLike(Array, j, H);
      }, O.prototype.toArrayLike = function(j, H, Z) {
        var W = this.byteLength(), w = Z || Math.max(1, W);
        _(W <= w, "byte array longer than desired length"), _(w > 0, "Requested array length <= 0"), this.strip();
        var G = H === "le", S = new j(w), A, v, k = this.clone();
        if (!G) {
          for (v = 0; v < w - W; v++) S[v] = 0;
          for (v = 0; !k.isZero(); v++) A = k.andln(255), k.iushrn(8), S[w - v - 1] = A;
        } else {
          for (v = 0; !k.isZero(); v++) A = k.andln(255), k.iushrn(8), S[v] = A;
          for (; v < w; v++) S[v] = 0;
        }
        return S;
      }, Math.clz32) O.prototype._countBits = function(j) {
        return 32 - Math.clz32(j);
      };
      else O.prototype._countBits = function(j) {
        var H = j, Z = 0;
        if (H >= 4096) Z += 13, H >>>= 13;
        if (H >= 64) Z += 7, H >>>= 7;
        if (H >= 8) Z += 4, H >>>= 4;
        if (H >= 2) Z += 2, H >>>= 2;
        return Z + H;
      };
      O.prototype._zeroBits = function(j) {
        if (j === 0) return 26;
        var H = j, Z = 0;
        if ((H & 8191) === 0) Z += 13, H >>>= 13;
        if ((H & 127) === 0) Z += 7, H >>>= 7;
        if ((H & 15) === 0) Z += 4, H >>>= 4;
        if ((H & 3) === 0) Z += 2, H >>>= 2;
        if ((H & 1) === 0) Z++;
        return Z;
      }, O.prototype.bitLength = function() {
        var j = this.words[this.length - 1], H = this._countBits(j);
        return (this.length - 1) * 26 + H;
      };
      function N(j) {
        var H = Array(j.bitLength());
        for (var Z = 0; Z < H.length; Z++) {
          var W = Z / 26 | 0, w = Z % 26;
          H[Z] = (j.words[W] & 1 << w) >>> w;
        }
        return H;
      }
      O.prototype.zeroBits = function() {
        if (this.isZero()) return 0;
        var j = 0;
        for (var H = 0; H < this.length; H++) {
          var Z = this._zeroBits(this.words[H]);
          if (j += Z, Z !== 26) break;
        }
        return j;
      }, O.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, O.prototype.toTwos = function(j) {
        if (this.negative !== 0) return this.abs().inotn(j).iaddn(1);
        return this.clone();
      }, O.prototype.fromTwos = function(j) {
        if (this.testn(j - 1)) return this.notn(j).iaddn(1).ineg();
        return this.clone();
      }, O.prototype.isNeg = function() {
        return this.negative !== 0;
      }, O.prototype.neg = function() {
        return this.clone().ineg();
      }, O.prototype.ineg = function() {
        if (!this.isZero()) this.negative ^= 1;
        return this;
      }, O.prototype.iuor = function(j) {
        while (this.length < j.length) this.words[this.length++] = 0;
        for (var H = 0; H < j.length; H++) this.words[H] = this.words[H] | j.words[H];
        return this.strip();
      }, O.prototype.ior = function(j) {
        return _((this.negative | j.negative) === 0), this.iuor(j);
      }, O.prototype.or = function(j) {
        if (this.length > j.length) return this.clone().ior(j);
        return j.clone().ior(this);
      }, O.prototype.uor = function(j) {
        if (this.length > j.length) return this.clone().iuor(j);
        return j.clone().iuor(this);
      }, O.prototype.iuand = function(j) {
        var H;
        if (this.length > j.length) H = j;
        else H = this;
        for (var Z = 0; Z < H.length; Z++) this.words[Z] = this.words[Z] & j.words[Z];
        return this.length = H.length, this.strip();
      }, O.prototype.iand = function(j) {
        return _((this.negative | j.negative) === 0), this.iuand(j);
      }, O.prototype.and = function(j) {
        if (this.length > j.length) return this.clone().iand(j);
        return j.clone().iand(this);
      }, O.prototype.uand = function(j) {
        if (this.length > j.length) return this.clone().iuand(j);
        return j.clone().iuand(this);
      }, O.prototype.iuxor = function(j) {
        var H, Z;
        if (this.length > j.length) H = this, Z = j;
        else H = j, Z = this;
        for (var W = 0; W < Z.length; W++) this.words[W] = H.words[W] ^ Z.words[W];
        if (this !== H) for (; W < H.length; W++) this.words[W] = H.words[W];
        return this.length = H.length, this.strip();
      }, O.prototype.ixor = function(j) {
        return _((this.negative | j.negative) === 0), this.iuxor(j);
      }, O.prototype.xor = function(j) {
        if (this.length > j.length) return this.clone().ixor(j);
        return j.clone().ixor(this);
      }, O.prototype.uxor = function(j) {
        if (this.length > j.length) return this.clone().iuxor(j);
        return j.clone().iuxor(this);
      }, O.prototype.inotn = function(j) {
        _(typeof j === "number" && j >= 0);
        var H = Math.ceil(j / 26) | 0, Z = j % 26;
        if (this._expand(H), Z > 0) H--;
        for (var W = 0; W < H; W++) this.words[W] = ~this.words[W] & 67108863;
        if (Z > 0) this.words[W] = ~this.words[W] & 67108863 >> 26 - Z;
        return this.strip();
      }, O.prototype.notn = function(j) {
        return this.clone().inotn(j);
      }, O.prototype.setn = function(j, H) {
        _(typeof j === "number" && j >= 0);
        var Z = j / 26 | 0, W = j % 26;
        if (this._expand(Z + 1), H) this.words[Z] = this.words[Z] | 1 << W;
        else this.words[Z] = this.words[Z] & ~(1 << W);
        return this.strip();
      }, O.prototype.iadd = function(j) {
        var H;
        if (this.negative !== 0 && j.negative === 0) return this.negative = 0, H = this.isub(j), this.negative ^= 1, this._normSign();
        else if (this.negative === 0 && j.negative !== 0) return j.negative = 0, H = this.isub(j), j.negative = 1, H._normSign();
        var Z, W;
        if (this.length > j.length) Z = this, W = j;
        else Z = j, W = this;
        var w = 0;
        for (var G = 0; G < W.length; G++) H = (Z.words[G] | 0) + (W.words[G] | 0) + w, this.words[G] = H & 67108863, w = H >>> 26;
        for (; w !== 0 && G < Z.length; G++) H = (Z.words[G] | 0) + w, this.words[G] = H & 67108863, w = H >>> 26;
        if (this.length = Z.length, w !== 0) this.words[this.length] = w, this.length++;
        else if (Z !== this) for (; G < Z.length; G++) this.words[G] = Z.words[G];
        return this;
      }, O.prototype.add = function(j) {
        var H;
        if (j.negative !== 0 && this.negative === 0) return j.negative = 0, H = this.sub(j), j.negative ^= 1, H;
        else if (j.negative === 0 && this.negative !== 0) return this.negative = 0, H = j.sub(this), this.negative = 1, H;
        if (this.length > j.length) return this.clone().iadd(j);
        return j.clone().iadd(this);
      }, O.prototype.isub = function(j) {
        if (j.negative !== 0) {
          j.negative = 0;
          var H = this.iadd(j);
          return j.negative = 1, H._normSign();
        } else if (this.negative !== 0) return this.negative = 0, this.iadd(j), this.negative = 1, this._normSign();
        var Z = this.cmp(j);
        if (Z === 0) return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var W, w;
        if (Z > 0) W = this, w = j;
        else W = j, w = this;
        var G = 0;
        for (var S = 0; S < w.length; S++) H = (W.words[S] | 0) - (w.words[S] | 0) + G, G = H >> 26, this.words[S] = H & 67108863;
        for (; G !== 0 && S < W.length; S++) H = (W.words[S] | 0) + G, G = H >> 26, this.words[S] = H & 67108863;
        if (G === 0 && S < W.length && W !== this) for (; S < W.length; S++) this.words[S] = W.words[S];
        if (this.length = Math.max(this.length, S), W !== this) this.negative = 1;
        return this.strip();
      }, O.prototype.sub = function(j) {
        return this.clone().isub(j);
      };
      function h(j, H, Z) {
        Z.negative = H.negative ^ j.negative;
        var W = j.length + H.length | 0;
        Z.length = W, W = W - 1 | 0;
        var w = j.words[0] | 0, G = H.words[0] | 0, S = w * G, A = S & 67108863, v = S / 67108864 | 0;
        Z.words[0] = A;
        for (var k = 1; k < W; k++) {
          var R = v >>> 26, C = v & 67108863, L = Math.min(k, H.length - 1);
          for (var x = Math.max(0, k - j.length + 1); x <= L; x++) {
            var l = k - x | 0;
            w = j.words[l] | 0, G = H.words[x] | 0, S = w * G + C, R += S / 67108864 | 0, C = S & 67108863;
          }
          Z.words[k] = C | 0, v = R | 0;
        }
        if (v !== 0) Z.words[k] = v | 0;
        else Z.length--;
        return Z.strip();
      }
      var E = function(j, H, Z) {
        var W = j.words, w = H.words, G = Z.words, S = 0, A, v, k, R = W[0] | 0, C = R & 8191, L = R >>> 13, x = W[1] | 0, l = x & 8191, a = x >>> 13, f$ = W[2] | 0, $$ = f$ & 8191, B = f$ >>> 13, H$ = W[3] | 0, Q = H$ & 8191, v$ = H$ >>> 13, t$ = W[4] | 0, m = t$ & 8191, r = t$ >>> 13, J$ = W[5] | 0, e = J$ & 8191, _$2 = J$ >>> 13, Y$ = W[6] | 0, d = Y$ & 8191, o = Y$ >>> 13, W$ = W[7] | 0, t = W$ & 8191, F = W$ >>> 13, X$ = W[8] | 0, z$ = X$ & 8191, j$ = X$ >>> 13, X6 = W[9] | 0, Z$ = X6 & 8191, A$ = X6 >>> 13, d6 = w[0] | 0, S$ = d6 & 8191, V$ = d6 >>> 13, Sq = w[1] | 0, N$ = Sq & 8191, D$ = Sq >>> 13, Mq = w[2] | 0, L$ = Mq & 8191, C$ = Mq >>> 13, fq = w[3] | 0, g$ = fq & 8191, E$ = fq >>> 13, vq = w[4] | 0, b$ = vq & 8191, y$ = vq >>> 13, zq = w[5] | 0, h$ = zq & 8191, u = zq >>> 13, i = w[6] | 0, K$ = i & 8191, P$ = i >>> 13, i$ = w[7] | 0, k$ = i$ & 8191, G$ = i$ >>> 13, x6 = w[8] | 0, R$ = x6 & 8191, u$ = x6 >>> 13, Zq = w[9] | 0, I$ = Zq & 8191, M$ = Zq >>> 13;
        Z.negative = j.negative ^ H.negative, Z.length = 19, A = Math.imul(C, S$), v = Math.imul(C, V$), v = v + Math.imul(L, S$) | 0, k = Math.imul(L, V$);
        var p6 = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (p6 >>> 26) | 0, p6 &= 67108863, A = Math.imul(l, S$), v = Math.imul(l, V$), v = v + Math.imul(a, S$) | 0, k = Math.imul(a, V$), A = A + Math.imul(C, N$) | 0, v = v + Math.imul(C, D$) | 0, v = v + Math.imul(L, N$) | 0, k = k + Math.imul(L, D$) | 0;
        var H6 = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (H6 >>> 26) | 0, H6 &= 67108863, A = Math.imul($$, S$), v = Math.imul($$, V$), v = v + Math.imul(B, S$) | 0, k = Math.imul(B, V$), A = A + Math.imul(l, N$) | 0, v = v + Math.imul(l, D$) | 0, v = v + Math.imul(a, N$) | 0, k = k + Math.imul(a, D$) | 0, A = A + Math.imul(C, L$) | 0, v = v + Math.imul(C, C$) | 0, v = v + Math.imul(L, L$) | 0, k = k + Math.imul(L, C$) | 0;
        var v6 = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (v6 >>> 26) | 0, v6 &= 67108863, A = Math.imul(Q, S$), v = Math.imul(Q, V$), v = v + Math.imul(v$, S$) | 0, k = Math.imul(v$, V$), A = A + Math.imul($$, N$) | 0, v = v + Math.imul($$, D$) | 0, v = v + Math.imul(B, N$) | 0, k = k + Math.imul(B, D$) | 0, A = A + Math.imul(l, L$) | 0, v = v + Math.imul(l, C$) | 0, v = v + Math.imul(a, L$) | 0, k = k + Math.imul(a, C$) | 0, A = A + Math.imul(C, g$) | 0, v = v + Math.imul(C, E$) | 0, v = v + Math.imul(L, g$) | 0, k = k + Math.imul(L, E$) | 0;
        var C6 = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (C6 >>> 26) | 0, C6 &= 67108863, A = Math.imul(m, S$), v = Math.imul(m, V$), v = v + Math.imul(r, S$) | 0, k = Math.imul(r, V$), A = A + Math.imul(Q, N$) | 0, v = v + Math.imul(Q, D$) | 0, v = v + Math.imul(v$, N$) | 0, k = k + Math.imul(v$, D$) | 0, A = A + Math.imul($$, L$) | 0, v = v + Math.imul($$, C$) | 0, v = v + Math.imul(B, L$) | 0, k = k + Math.imul(B, C$) | 0, A = A + Math.imul(l, g$) | 0, v = v + Math.imul(l, E$) | 0, v = v + Math.imul(a, g$) | 0, k = k + Math.imul(a, E$) | 0, A = A + Math.imul(C, b$) | 0, v = v + Math.imul(C, y$) | 0, v = v + Math.imul(L, b$) | 0, k = k + Math.imul(L, y$) | 0;
        var S6 = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (S6 >>> 26) | 0, S6 &= 67108863, A = Math.imul(e, S$), v = Math.imul(e, V$), v = v + Math.imul(_$2, S$) | 0, k = Math.imul(_$2, V$), A = A + Math.imul(m, N$) | 0, v = v + Math.imul(m, D$) | 0, v = v + Math.imul(r, N$) | 0, k = k + Math.imul(r, D$) | 0, A = A + Math.imul(Q, L$) | 0, v = v + Math.imul(Q, C$) | 0, v = v + Math.imul(v$, L$) | 0, k = k + Math.imul(v$, C$) | 0, A = A + Math.imul($$, g$) | 0, v = v + Math.imul($$, E$) | 0, v = v + Math.imul(B, g$) | 0, k = k + Math.imul(B, E$) | 0, A = A + Math.imul(l, b$) | 0, v = v + Math.imul(l, y$) | 0, v = v + Math.imul(a, b$) | 0, k = k + Math.imul(a, y$) | 0, A = A + Math.imul(C, h$) | 0, v = v + Math.imul(C, u) | 0, v = v + Math.imul(L, h$) | 0, k = k + Math.imul(L, u) | 0;
        var i6 = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (i6 >>> 26) | 0, i6 &= 67108863, A = Math.imul(d, S$), v = Math.imul(d, V$), v = v + Math.imul(o, S$) | 0, k = Math.imul(o, V$), A = A + Math.imul(e, N$) | 0, v = v + Math.imul(e, D$) | 0, v = v + Math.imul(_$2, N$) | 0, k = k + Math.imul(_$2, D$) | 0, A = A + Math.imul(m, L$) | 0, v = v + Math.imul(m, C$) | 0, v = v + Math.imul(r, L$) | 0, k = k + Math.imul(r, C$) | 0, A = A + Math.imul(Q, g$) | 0, v = v + Math.imul(Q, E$) | 0, v = v + Math.imul(v$, g$) | 0, k = k + Math.imul(v$, E$) | 0, A = A + Math.imul($$, b$) | 0, v = v + Math.imul($$, y$) | 0, v = v + Math.imul(B, b$) | 0, k = k + Math.imul(B, y$) | 0, A = A + Math.imul(l, h$) | 0, v = v + Math.imul(l, u) | 0, v = v + Math.imul(a, h$) | 0, k = k + Math.imul(a, u) | 0, A = A + Math.imul(C, K$) | 0, v = v + Math.imul(C, P$) | 0, v = v + Math.imul(L, K$) | 0, k = k + Math.imul(L, P$) | 0;
        var B6 = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (B6 >>> 26) | 0, B6 &= 67108863, A = Math.imul(t, S$), v = Math.imul(t, V$), v = v + Math.imul(F, S$) | 0, k = Math.imul(F, V$), A = A + Math.imul(d, N$) | 0, v = v + Math.imul(d, D$) | 0, v = v + Math.imul(o, N$) | 0, k = k + Math.imul(o, D$) | 0, A = A + Math.imul(e, L$) | 0, v = v + Math.imul(e, C$) | 0, v = v + Math.imul(_$2, L$) | 0, k = k + Math.imul(_$2, C$) | 0, A = A + Math.imul(m, g$) | 0, v = v + Math.imul(m, E$) | 0, v = v + Math.imul(r, g$) | 0, k = k + Math.imul(r, E$) | 0, A = A + Math.imul(Q, b$) | 0, v = v + Math.imul(Q, y$) | 0, v = v + Math.imul(v$, b$) | 0, k = k + Math.imul(v$, y$) | 0, A = A + Math.imul($$, h$) | 0, v = v + Math.imul($$, u) | 0, v = v + Math.imul(B, h$) | 0, k = k + Math.imul(B, u) | 0, A = A + Math.imul(l, K$) | 0, v = v + Math.imul(l, P$) | 0, v = v + Math.imul(a, K$) | 0, k = k + Math.imul(a, P$) | 0, A = A + Math.imul(C, k$) | 0, v = v + Math.imul(C, G$) | 0, v = v + Math.imul(L, k$) | 0, k = k + Math.imul(L, G$) | 0;
        var t6 = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (t6 >>> 26) | 0, t6 &= 67108863, A = Math.imul(z$, S$), v = Math.imul(z$, V$), v = v + Math.imul(j$, S$) | 0, k = Math.imul(j$, V$), A = A + Math.imul(t, N$) | 0, v = v + Math.imul(t, D$) | 0, v = v + Math.imul(F, N$) | 0, k = k + Math.imul(F, D$) | 0, A = A + Math.imul(d, L$) | 0, v = v + Math.imul(d, C$) | 0, v = v + Math.imul(o, L$) | 0, k = k + Math.imul(o, C$) | 0, A = A + Math.imul(e, g$) | 0, v = v + Math.imul(e, E$) | 0, v = v + Math.imul(_$2, g$) | 0, k = k + Math.imul(_$2, E$) | 0, A = A + Math.imul(m, b$) | 0, v = v + Math.imul(m, y$) | 0, v = v + Math.imul(r, b$) | 0, k = k + Math.imul(r, y$) | 0, A = A + Math.imul(Q, h$) | 0, v = v + Math.imul(Q, u) | 0, v = v + Math.imul(v$, h$) | 0, k = k + Math.imul(v$, u) | 0, A = A + Math.imul($$, K$) | 0, v = v + Math.imul($$, P$) | 0, v = v + Math.imul(B, K$) | 0, k = k + Math.imul(B, P$) | 0, A = A + Math.imul(l, k$) | 0, v = v + Math.imul(l, G$) | 0, v = v + Math.imul(a, k$) | 0, k = k + Math.imul(a, G$) | 0, A = A + Math.imul(C, R$) | 0, v = v + Math.imul(C, u$) | 0, v = v + Math.imul(L, R$) | 0, k = k + Math.imul(L, u$) | 0;
        var U6 = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (U6 >>> 26) | 0, U6 &= 67108863, A = Math.imul(Z$, S$), v = Math.imul(Z$, V$), v = v + Math.imul(A$, S$) | 0, k = Math.imul(A$, V$), A = A + Math.imul(z$, N$) | 0, v = v + Math.imul(z$, D$) | 0, v = v + Math.imul(j$, N$) | 0, k = k + Math.imul(j$, D$) | 0, A = A + Math.imul(t, L$) | 0, v = v + Math.imul(t, C$) | 0, v = v + Math.imul(F, L$) | 0, k = k + Math.imul(F, C$) | 0, A = A + Math.imul(d, g$) | 0, v = v + Math.imul(d, E$) | 0, v = v + Math.imul(o, g$) | 0, k = k + Math.imul(o, E$) | 0, A = A + Math.imul(e, b$) | 0, v = v + Math.imul(e, y$) | 0, v = v + Math.imul(_$2, b$) | 0, k = k + Math.imul(_$2, y$) | 0, A = A + Math.imul(m, h$) | 0, v = v + Math.imul(m, u) | 0, v = v + Math.imul(r, h$) | 0, k = k + Math.imul(r, u) | 0, A = A + Math.imul(Q, K$) | 0, v = v + Math.imul(Q, P$) | 0, v = v + Math.imul(v$, K$) | 0, k = k + Math.imul(v$, P$) | 0, A = A + Math.imul($$, k$) | 0, v = v + Math.imul($$, G$) | 0, v = v + Math.imul(B, k$) | 0, k = k + Math.imul(B, G$) | 0, A = A + Math.imul(l, R$) | 0, v = v + Math.imul(l, u$) | 0, v = v + Math.imul(a, R$) | 0, k = k + Math.imul(a, u$) | 0, A = A + Math.imul(C, I$) | 0, v = v + Math.imul(C, M$) | 0, v = v + Math.imul(L, I$) | 0, k = k + Math.imul(L, M$) | 0;
        var F6 = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (F6 >>> 26) | 0, F6 &= 67108863, A = Math.imul(Z$, N$), v = Math.imul(Z$, D$), v = v + Math.imul(A$, N$) | 0, k = Math.imul(A$, D$), A = A + Math.imul(z$, L$) | 0, v = v + Math.imul(z$, C$) | 0, v = v + Math.imul(j$, L$) | 0, k = k + Math.imul(j$, C$) | 0, A = A + Math.imul(t, g$) | 0, v = v + Math.imul(t, E$) | 0, v = v + Math.imul(F, g$) | 0, k = k + Math.imul(F, E$) | 0, A = A + Math.imul(d, b$) | 0, v = v + Math.imul(d, y$) | 0, v = v + Math.imul(o, b$) | 0, k = k + Math.imul(o, y$) | 0, A = A + Math.imul(e, h$) | 0, v = v + Math.imul(e, u) | 0, v = v + Math.imul(_$2, h$) | 0, k = k + Math.imul(_$2, u) | 0, A = A + Math.imul(m, K$) | 0, v = v + Math.imul(m, P$) | 0, v = v + Math.imul(r, K$) | 0, k = k + Math.imul(r, P$) | 0, A = A + Math.imul(Q, k$) | 0, v = v + Math.imul(Q, G$) | 0, v = v + Math.imul(v$, k$) | 0, k = k + Math.imul(v$, G$) | 0, A = A + Math.imul($$, R$) | 0, v = v + Math.imul($$, u$) | 0, v = v + Math.imul(B, R$) | 0, k = k + Math.imul(B, u$) | 0, A = A + Math.imul(l, I$) | 0, v = v + Math.imul(l, M$) | 0, v = v + Math.imul(a, I$) | 0, k = k + Math.imul(a, M$) | 0;
        var a6 = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (a6 >>> 26) | 0, a6 &= 67108863, A = Math.imul(Z$, L$), v = Math.imul(Z$, C$), v = v + Math.imul(A$, L$) | 0, k = Math.imul(A$, C$), A = A + Math.imul(z$, g$) | 0, v = v + Math.imul(z$, E$) | 0, v = v + Math.imul(j$, g$) | 0, k = k + Math.imul(j$, E$) | 0, A = A + Math.imul(t, b$) | 0, v = v + Math.imul(t, y$) | 0, v = v + Math.imul(F, b$) | 0, k = k + Math.imul(F, y$) | 0, A = A + Math.imul(d, h$) | 0, v = v + Math.imul(d, u) | 0, v = v + Math.imul(o, h$) | 0, k = k + Math.imul(o, u) | 0, A = A + Math.imul(e, K$) | 0, v = v + Math.imul(e, P$) | 0, v = v + Math.imul(_$2, K$) | 0, k = k + Math.imul(_$2, P$) | 0, A = A + Math.imul(m, k$) | 0, v = v + Math.imul(m, G$) | 0, v = v + Math.imul(r, k$) | 0, k = k + Math.imul(r, G$) | 0, A = A + Math.imul(Q, R$) | 0, v = v + Math.imul(Q, u$) | 0, v = v + Math.imul(v$, R$) | 0, k = k + Math.imul(v$, u$) | 0, A = A + Math.imul($$, I$) | 0, v = v + Math.imul($$, M$) | 0, v = v + Math.imul(B, I$) | 0, k = k + Math.imul(B, M$) | 0;
        var Q6 = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (Q6 >>> 26) | 0, Q6 &= 67108863, A = Math.imul(Z$, g$), v = Math.imul(Z$, E$), v = v + Math.imul(A$, g$) | 0, k = Math.imul(A$, E$), A = A + Math.imul(z$, b$) | 0, v = v + Math.imul(z$, y$) | 0, v = v + Math.imul(j$, b$) | 0, k = k + Math.imul(j$, y$) | 0, A = A + Math.imul(t, h$) | 0, v = v + Math.imul(t, u) | 0, v = v + Math.imul(F, h$) | 0, k = k + Math.imul(F, u) | 0, A = A + Math.imul(d, K$) | 0, v = v + Math.imul(d, P$) | 0, v = v + Math.imul(o, K$) | 0, k = k + Math.imul(o, P$) | 0, A = A + Math.imul(e, k$) | 0, v = v + Math.imul(e, G$) | 0, v = v + Math.imul(_$2, k$) | 0, k = k + Math.imul(_$2, G$) | 0, A = A + Math.imul(m, R$) | 0, v = v + Math.imul(m, u$) | 0, v = v + Math.imul(r, R$) | 0, k = k + Math.imul(r, u$) | 0, A = A + Math.imul(Q, I$) | 0, v = v + Math.imul(Q, M$) | 0, v = v + Math.imul(v$, I$) | 0, k = k + Math.imul(v$, M$) | 0;
        var e6 = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (e6 >>> 26) | 0, e6 &= 67108863, A = Math.imul(Z$, b$), v = Math.imul(Z$, y$), v = v + Math.imul(A$, b$) | 0, k = Math.imul(A$, y$), A = A + Math.imul(z$, h$) | 0, v = v + Math.imul(z$, u) | 0, v = v + Math.imul(j$, h$) | 0, k = k + Math.imul(j$, u) | 0, A = A + Math.imul(t, K$) | 0, v = v + Math.imul(t, P$) | 0, v = v + Math.imul(F, K$) | 0, k = k + Math.imul(F, P$) | 0, A = A + Math.imul(d, k$) | 0, v = v + Math.imul(d, G$) | 0, v = v + Math.imul(o, k$) | 0, k = k + Math.imul(o, G$) | 0, A = A + Math.imul(e, R$) | 0, v = v + Math.imul(e, u$) | 0, v = v + Math.imul(_$2, R$) | 0, k = k + Math.imul(_$2, u$) | 0, A = A + Math.imul(m, I$) | 0, v = v + Math.imul(m, M$) | 0, v = v + Math.imul(r, I$) | 0, k = k + Math.imul(r, M$) | 0;
        var s6 = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (s6 >>> 26) | 0, s6 &= 67108863, A = Math.imul(Z$, h$), v = Math.imul(Z$, u), v = v + Math.imul(A$, h$) | 0, k = Math.imul(A$, u), A = A + Math.imul(z$, K$) | 0, v = v + Math.imul(z$, P$) | 0, v = v + Math.imul(j$, K$) | 0, k = k + Math.imul(j$, P$) | 0, A = A + Math.imul(t, k$) | 0, v = v + Math.imul(t, G$) | 0, v = v + Math.imul(F, k$) | 0, k = k + Math.imul(F, G$) | 0, A = A + Math.imul(d, R$) | 0, v = v + Math.imul(d, u$) | 0, v = v + Math.imul(o, R$) | 0, k = k + Math.imul(o, u$) | 0, A = A + Math.imul(e, I$) | 0, v = v + Math.imul(e, M$) | 0, v = v + Math.imul(_$2, I$) | 0, k = k + Math.imul(_$2, M$) | 0;
        var $q = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + ($q >>> 26) | 0, $q &= 67108863, A = Math.imul(Z$, K$), v = Math.imul(Z$, P$), v = v + Math.imul(A$, K$) | 0, k = Math.imul(A$, P$), A = A + Math.imul(z$, k$) | 0, v = v + Math.imul(z$, G$) | 0, v = v + Math.imul(j$, k$) | 0, k = k + Math.imul(j$, G$) | 0, A = A + Math.imul(t, R$) | 0, v = v + Math.imul(t, u$) | 0, v = v + Math.imul(F, R$) | 0, k = k + Math.imul(F, u$) | 0, A = A + Math.imul(d, I$) | 0, v = v + Math.imul(d, M$) | 0, v = v + Math.imul(o, I$) | 0, k = k + Math.imul(o, M$) | 0;
        var qq = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (qq >>> 26) | 0, qq &= 67108863, A = Math.imul(Z$, k$), v = Math.imul(Z$, G$), v = v + Math.imul(A$, k$) | 0, k = Math.imul(A$, G$), A = A + Math.imul(z$, R$) | 0, v = v + Math.imul(z$, u$) | 0, v = v + Math.imul(j$, R$) | 0, k = k + Math.imul(j$, u$) | 0, A = A + Math.imul(t, I$) | 0, v = v + Math.imul(t, M$) | 0, v = v + Math.imul(F, I$) | 0, k = k + Math.imul(F, M$) | 0;
        var Kq = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (Kq >>> 26) | 0, Kq &= 67108863, A = Math.imul(Z$, R$), v = Math.imul(Z$, u$), v = v + Math.imul(A$, R$) | 0, k = Math.imul(A$, u$), A = A + Math.imul(z$, I$) | 0, v = v + Math.imul(z$, M$) | 0, v = v + Math.imul(j$, I$) | 0, k = k + Math.imul(j$, M$) | 0;
        var _q = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (_q >>> 26) | 0, _q &= 67108863, A = Math.imul(Z$, I$), v = Math.imul(Z$, M$), v = v + Math.imul(A$, I$) | 0, k = Math.imul(A$, M$);
        var Pq = (S + A | 0) + ((v & 8191) << 13) | 0;
        if (S = (k + (v >>> 13) | 0) + (Pq >>> 26) | 0, Pq &= 67108863, G[0] = p6, G[1] = H6, G[2] = v6, G[3] = C6, G[4] = S6, G[5] = i6, G[6] = B6, G[7] = t6, G[8] = U6, G[9] = F6, G[10] = a6, G[11] = Q6, G[12] = e6, G[13] = s6, G[14] = $q, G[15] = qq, G[16] = Kq, G[17] = _q, G[18] = Pq, S !== 0) G[19] = S, Z.length++;
        return Z;
      };
      if (!Math.imul) E = h;
      function I(j, H, Z) {
        Z.negative = H.negative ^ j.negative, Z.length = j.length + H.length;
        var W = 0, w = 0;
        for (var G = 0; G < Z.length - 1; G++) {
          var S = w;
          w = 0;
          var A = W & 67108863, v = Math.min(G, H.length - 1);
          for (var k = Math.max(0, G - j.length + 1); k <= v; k++) {
            var R = G - k, C = j.words[R] | 0, L = H.words[k] | 0, x = C * L, l = x & 67108863;
            S = S + (x / 67108864 | 0) | 0, l = l + A | 0, A = l & 67108863, S = S + (l >>> 26) | 0, w += S >>> 26, S &= 67108863;
          }
          Z.words[G] = A, W = S, S = w;
        }
        if (W !== 0) Z.words[G] = W;
        else Z.length--;
        return Z.strip();
      }
      function D(j, H, Z) {
        var W = new g();
        return W.mulp(j, H, Z);
      }
      O.prototype.mulTo = function(j, H) {
        var Z, W = this.length + j.length;
        if (this.length === 10 && j.length === 10) Z = E(this, j, H);
        else if (W < 63) Z = h(this, j, H);
        else if (W < 1024) Z = I(this, j, H);
        else Z = D(this, j, H);
        return Z;
      };
      function g(j, H) {
        this.x = j, this.y = H;
      }
      g.prototype.makeRBT = function(j) {
        var H = Array(j), Z = O.prototype._countBits(j) - 1;
        for (var W = 0; W < j; W++) H[W] = this.revBin(W, Z, j);
        return H;
      }, g.prototype.revBin = function(j, H, Z) {
        if (j === 0 || j === Z - 1) return j;
        var W = 0;
        for (var w = 0; w < H; w++) W |= (j & 1) << H - w - 1, j >>= 1;
        return W;
      }, g.prototype.permute = function(j, H, Z, W, w, G) {
        for (var S = 0; S < G; S++) W[S] = H[j[S]], w[S] = Z[j[S]];
      }, g.prototype.transform = function(j, H, Z, W, w, G) {
        this.permute(G, j, H, Z, W, w);
        for (var S = 1; S < w; S <<= 1) {
          var A = S << 1, v = Math.cos(2 * Math.PI / A), k = Math.sin(2 * Math.PI / A);
          for (var R = 0; R < w; R += A) {
            var C = v, L = k;
            for (var x = 0; x < S; x++) {
              var l = Z[R + x], a = W[R + x], f$ = Z[R + x + S], $$ = W[R + x + S], B = C * f$ - L * $$;
              if ($$ = C * $$ + L * f$, f$ = B, Z[R + x] = l + f$, W[R + x] = a + $$, Z[R + x + S] = l - f$, W[R + x + S] = a - $$, x !== A) B = v * C - k * L, L = v * L + k * C, C = B;
            }
          }
        }
      }, g.prototype.guessLen13b = function(j, H) {
        var Z = Math.max(H, j) | 1, W = Z & 1, w = 0;
        for (Z = Z / 2 | 0; Z; Z = Z >>> 1) w++;
        return 1 << w + 1 + W;
      }, g.prototype.conjugate = function(j, H, Z) {
        if (Z <= 1) return;
        for (var W = 0; W < Z / 2; W++) {
          var w = j[W];
          j[W] = j[Z - W - 1], j[Z - W - 1] = w, w = H[W], H[W] = -H[Z - W - 1], H[Z - W - 1] = -w;
        }
      }, g.prototype.normalize13b = function(j, H) {
        var Z = 0;
        for (var W = 0; W < H / 2; W++) {
          var w = Math.round(j[2 * W + 1] / H) * 8192 + Math.round(j[2 * W] / H) + Z;
          if (j[W] = w & 67108863, w < 67108864) Z = 0;
          else Z = w / 67108864 | 0;
        }
        return j;
      }, g.prototype.convert13b = function(j, H, Z, W) {
        var w = 0;
        for (var G = 0; G < H; G++) w = w + (j[G] | 0), Z[2 * G] = w & 8191, w = w >>> 13, Z[2 * G + 1] = w & 8191, w = w >>> 13;
        for (G = 2 * H; G < W; ++G) Z[G] = 0;
        _(w === 0), _((w & -8192) === 0);
      }, g.prototype.stub = function(j) {
        var H = Array(j);
        for (var Z = 0; Z < j; Z++) H[Z] = 0;
        return H;
      }, g.prototype.mulp = function(j, H, Z) {
        var W = 2 * this.guessLen13b(j.length, H.length), w = this.makeRBT(W), G = this.stub(W), S = Array(W), A = Array(W), v = Array(W), k = Array(W), R = Array(W), C = Array(W), L = Z.words;
        L.length = W, this.convert13b(j.words, j.length, S, W), this.convert13b(H.words, H.length, k, W), this.transform(S, G, A, v, W, w), this.transform(k, G, R, C, W, w);
        for (var x = 0; x < W; x++) {
          var l = A[x] * R[x] - v[x] * C[x];
          v[x] = A[x] * C[x] + v[x] * R[x], A[x] = l;
        }
        return this.conjugate(A, v, W), this.transform(A, v, L, G, W, w), this.conjugate(L, G, W), this.normalize13b(L, W), Z.negative = j.negative ^ H.negative, Z.length = j.length + H.length, Z.strip();
      }, O.prototype.mul = function(j) {
        var H = new O(null);
        return H.words = Array(this.length + j.length), this.mulTo(j, H);
      }, O.prototype.mulf = function(j) {
        var H = new O(null);
        return H.words = Array(this.length + j.length), D(this, j, H);
      }, O.prototype.imul = function(j) {
        return this.clone().mulTo(j, this);
      }, O.prototype.imuln = function(j) {
        _(typeof j === "number"), _(j < 67108864);
        var H = 0;
        for (var Z = 0; Z < this.length; Z++) {
          var W = (this.words[Z] | 0) * j, w = (W & 67108863) + (H & 67108863);
          H >>= 26, H += W / 67108864 | 0, H += w >>> 26, this.words[Z] = w & 67108863;
        }
        if (H !== 0) this.words[Z] = H, this.length++;
        return this.length = j === 0 ? 1 : this.length, this;
      }, O.prototype.muln = function(j) {
        return this.clone().imuln(j);
      }, O.prototype.sqr = function() {
        return this.mul(this);
      }, O.prototype.isqr = function() {
        return this.imul(this.clone());
      }, O.prototype.pow = function(j) {
        var H = N(j);
        if (H.length === 0) return new O(1);
        var Z = this;
        for (var W = 0; W < H.length; W++, Z = Z.sqr()) if (H[W] !== 0) break;
        if (++W < H.length) for (var w = Z.sqr(); W < H.length; W++, w = w.sqr()) {
          if (H[W] === 0) continue;
          Z = Z.mul(w);
        }
        return Z;
      }, O.prototype.iushln = function(j) {
        _(typeof j === "number" && j >= 0);
        var H = j % 26, Z = (j - H) / 26, W = 67108863 >>> 26 - H << 26 - H, w;
        if (H !== 0) {
          var G = 0;
          for (w = 0; w < this.length; w++) {
            var S = this.words[w] & W, A = (this.words[w] | 0) - S << H;
            this.words[w] = A | G, G = S >>> 26 - H;
          }
          if (G) this.words[w] = G, this.length++;
        }
        if (Z !== 0) {
          for (w = this.length - 1; w >= 0; w--) this.words[w + Z] = this.words[w];
          for (w = 0; w < Z; w++) this.words[w] = 0;
          this.length += Z;
        }
        return this.strip();
      }, O.prototype.ishln = function(j) {
        return _(this.negative === 0), this.iushln(j);
      }, O.prototype.iushrn = function(j, H, Z) {
        _(typeof j === "number" && j >= 0);
        var W;
        if (H) W = (H - H % 26) / 26;
        else W = 0;
        var w = j % 26, G = Math.min((j - w) / 26, this.length), S = 67108863 ^ 67108863 >>> w << w, A = Z;
        if (W -= G, W = Math.max(0, W), A) {
          for (var v = 0; v < G; v++) A.words[v] = this.words[v];
          A.length = G;
        }
        if (G === 0) ;
        else if (this.length > G) {
          this.length -= G;
          for (v = 0; v < this.length; v++) this.words[v] = this.words[v + G];
        } else this.words[0] = 0, this.length = 1;
        var k = 0;
        for (v = this.length - 1; v >= 0 && (k !== 0 || v >= W); v--) {
          var R = this.words[v] | 0;
          this.words[v] = k << 26 - w | R >>> w, k = R & S;
        }
        if (A && k !== 0) A.words[A.length++] = k;
        if (this.length === 0) this.words[0] = 0, this.length = 1;
        return this.strip();
      }, O.prototype.ishrn = function(j, H, Z) {
        return _(this.negative === 0), this.iushrn(j, H, Z);
      }, O.prototype.shln = function(j) {
        return this.clone().ishln(j);
      }, O.prototype.ushln = function(j) {
        return this.clone().iushln(j);
      }, O.prototype.shrn = function(j) {
        return this.clone().ishrn(j);
      }, O.prototype.ushrn = function(j) {
        return this.clone().iushrn(j);
      }, O.prototype.testn = function(j) {
        _(typeof j === "number" && j >= 0);
        var H = j % 26, Z = (j - H) / 26, W = 1 << H;
        if (this.length <= Z) return false;
        var w = this.words[Z];
        return !!(w & W);
      }, O.prototype.imaskn = function(j) {
        _(typeof j === "number" && j >= 0);
        var H = j % 26, Z = (j - H) / 26;
        if (_(this.negative === 0, "imaskn works only with positive numbers"), this.length <= Z) return this;
        if (H !== 0) Z++;
        if (this.length = Math.min(Z, this.length), H !== 0) {
          var W = 67108863 ^ 67108863 >>> H << H;
          this.words[this.length - 1] &= W;
        }
        return this.strip();
      }, O.prototype.maskn = function(j) {
        return this.clone().imaskn(j);
      }, O.prototype.iaddn = function(j) {
        if (_(typeof j === "number"), _(j < 67108864), j < 0) return this.isubn(-j);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) < j) return this.words[0] = j - (this.words[0] | 0), this.negative = 0, this;
          return this.negative = 0, this.isubn(j), this.negative = 1, this;
        }
        return this._iaddn(j);
      }, O.prototype._iaddn = function(j) {
        this.words[0] += j;
        for (var H = 0; H < this.length && this.words[H] >= 67108864; H++) if (this.words[H] -= 67108864, H === this.length - 1) this.words[H + 1] = 1;
        else this.words[H + 1]++;
        return this.length = Math.max(this.length, H + 1), this;
      }, O.prototype.isubn = function(j) {
        if (_(typeof j === "number"), _(j < 67108864), j < 0) return this.iaddn(-j);
        if (this.negative !== 0) return this.negative = 0, this.iaddn(j), this.negative = 1, this;
        if (this.words[0] -= j, this.length === 1 && this.words[0] < 0) this.words[0] = -this.words[0], this.negative = 1;
        else for (var H = 0; H < this.length && this.words[H] < 0; H++) this.words[H] += 67108864, this.words[H + 1] -= 1;
        return this.strip();
      }, O.prototype.addn = function(j) {
        return this.clone().iaddn(j);
      }, O.prototype.subn = function(j) {
        return this.clone().isubn(j);
      }, O.prototype.iabs = function() {
        return this.negative = 0, this;
      }, O.prototype.abs = function() {
        return this.clone().iabs();
      }, O.prototype._ishlnsubmul = function(j, H, Z) {
        var W = j.length + Z, w;
        this._expand(W);
        var G, S = 0;
        for (w = 0; w < j.length; w++) {
          G = (this.words[w + Z] | 0) + S;
          var A = (j.words[w] | 0) * H;
          G -= A & 67108863, S = (G >> 26) - (A / 67108864 | 0), this.words[w + Z] = G & 67108863;
        }
        for (; w < this.length - Z; w++) G = (this.words[w + Z] | 0) + S, S = G >> 26, this.words[w + Z] = G & 67108863;
        if (S === 0) return this.strip();
        _(S === -1), S = 0;
        for (w = 0; w < this.length; w++) G = -(this.words[w] | 0) + S, S = G >> 26, this.words[w] = G & 67108863;
        return this.negative = 1, this.strip();
      }, O.prototype._wordDiv = function(j, H) {
        var Z = this.length - j.length, W = this.clone(), w = j, G = w.words[w.length - 1] | 0, S = this._countBits(G);
        if (Z = 26 - S, Z !== 0) w = w.ushln(Z), W.iushln(Z), G = w.words[w.length - 1] | 0;
        var A = W.length - w.length, v;
        if (H !== "mod") {
          v = new O(null), v.length = A + 1, v.words = Array(v.length);
          for (var k = 0; k < v.length; k++) v.words[k] = 0;
        }
        var R = W.clone()._ishlnsubmul(w, 1, A);
        if (R.negative === 0) {
          if (W = R, v) v.words[A] = 1;
        }
        for (var C = A - 1; C >= 0; C--) {
          var L = (W.words[w.length + C] | 0) * 67108864 + (W.words[w.length + C - 1] | 0);
          L = Math.min(L / G | 0, 67108863), W._ishlnsubmul(w, L, C);
          while (W.negative !== 0) if (L--, W.negative = 0, W._ishlnsubmul(w, 1, C), !W.isZero()) W.negative ^= 1;
          if (v) v.words[C] = L;
        }
        if (v) v.strip();
        if (W.strip(), H !== "div" && Z !== 0) W.iushrn(Z);
        return { div: v || null, mod: W };
      }, O.prototype.divmod = function(j, H, Z) {
        if (_(!j.isZero()), this.isZero()) return { div: new O(0), mod: new O(0) };
        var W, w, G;
        if (this.negative !== 0 && j.negative === 0) {
          if (G = this.neg().divmod(j, H), H !== "mod") W = G.div.neg();
          if (H !== "div") {
            if (w = G.mod.neg(), Z && w.negative !== 0) w.iadd(j);
          }
          return { div: W, mod: w };
        }
        if (this.negative === 0 && j.negative !== 0) {
          if (G = this.divmod(j.neg(), H), H !== "mod") W = G.div.neg();
          return { div: W, mod: G.mod };
        }
        if ((this.negative & j.negative) !== 0) {
          if (G = this.neg().divmod(j.neg(), H), H !== "div") {
            if (w = G.mod.neg(), Z && w.negative !== 0) w.isub(j);
          }
          return { div: G.div, mod: w };
        }
        if (j.length > this.length || this.cmp(j) < 0) return { div: new O(0), mod: this };
        if (j.length === 1) {
          if (H === "div") return { div: this.divn(j.words[0]), mod: null };
          if (H === "mod") return { div: null, mod: new O(this.modn(j.words[0])) };
          return { div: this.divn(j.words[0]), mod: new O(this.modn(j.words[0])) };
        }
        return this._wordDiv(j, H);
      }, O.prototype.div = function(j) {
        return this.divmod(j, "div", false).div;
      }, O.prototype.mod = function(j) {
        return this.divmod(j, "mod", false).mod;
      }, O.prototype.umod = function(j) {
        return this.divmod(j, "mod", true).mod;
      }, O.prototype.divRound = function(j) {
        var H = this.divmod(j);
        if (H.mod.isZero()) return H.div;
        var Z = H.div.negative !== 0 ? H.mod.isub(j) : H.mod, W = j.ushrn(1), w = j.andln(1), G = Z.cmp(W);
        if (G < 0 || w === 1 && G === 0) return H.div;
        return H.div.negative !== 0 ? H.div.isubn(1) : H.div.iaddn(1);
      }, O.prototype.modn = function(j) {
        _(j <= 67108863);
        var H = 67108864 % j, Z = 0;
        for (var W = this.length - 1; W >= 0; W--) Z = (H * Z + (this.words[W] | 0)) % j;
        return Z;
      }, O.prototype.idivn = function(j) {
        _(j <= 67108863);
        var H = 0;
        for (var Z = this.length - 1; Z >= 0; Z--) {
          var W = (this.words[Z] | 0) + H * 67108864;
          this.words[Z] = W / j | 0, H = W % j;
        }
        return this.strip();
      }, O.prototype.divn = function(j) {
        return this.clone().idivn(j);
      }, O.prototype.egcd = function(j) {
        _(j.negative === 0), _(!j.isZero());
        var H = this, Z = j.clone();
        if (H.negative !== 0) H = H.umod(j);
        else H = H.clone();
        var W = new O(1), w = new O(0), G = new O(0), S = new O(1), A = 0;
        while (H.isEven() && Z.isEven()) H.iushrn(1), Z.iushrn(1), ++A;
        var v = Z.clone(), k = H.clone();
        while (!H.isZero()) {
          for (var R = 0, C = 1; (H.words[0] & C) === 0 && R < 26; ++R, C <<= 1) ;
          if (R > 0) {
            H.iushrn(R);
            while (R-- > 0) {
              if (W.isOdd() || w.isOdd()) W.iadd(v), w.isub(k);
              W.iushrn(1), w.iushrn(1);
            }
          }
          for (var L = 0, x = 1; (Z.words[0] & x) === 0 && L < 26; ++L, x <<= 1) ;
          if (L > 0) {
            Z.iushrn(L);
            while (L-- > 0) {
              if (G.isOdd() || S.isOdd()) G.iadd(v), S.isub(k);
              G.iushrn(1), S.iushrn(1);
            }
          }
          if (H.cmp(Z) >= 0) H.isub(Z), W.isub(G), w.isub(S);
          else Z.isub(H), G.isub(W), S.isub(w);
        }
        return { a: G, b: S, gcd: Z.iushln(A) };
      }, O.prototype._invmp = function(j) {
        _(j.negative === 0), _(!j.isZero());
        var H = this, Z = j.clone();
        if (H.negative !== 0) H = H.umod(j);
        else H = H.clone();
        var W = new O(1), w = new O(0), G = Z.clone();
        while (H.cmpn(1) > 0 && Z.cmpn(1) > 0) {
          for (var S = 0, A = 1; (H.words[0] & A) === 0 && S < 26; ++S, A <<= 1) ;
          if (S > 0) {
            H.iushrn(S);
            while (S-- > 0) {
              if (W.isOdd()) W.iadd(G);
              W.iushrn(1);
            }
          }
          for (var v = 0, k = 1; (Z.words[0] & k) === 0 && v < 26; ++v, k <<= 1) ;
          if (v > 0) {
            Z.iushrn(v);
            while (v-- > 0) {
              if (w.isOdd()) w.iadd(G);
              w.iushrn(1);
            }
          }
          if (H.cmp(Z) >= 0) H.isub(Z), W.isub(w);
          else Z.isub(H), w.isub(W);
        }
        var R;
        if (H.cmpn(1) === 0) R = W;
        else R = w;
        if (R.cmpn(0) < 0) R.iadd(j);
        return R;
      }, O.prototype.gcd = function(j) {
        if (this.isZero()) return j.abs();
        if (j.isZero()) return this.abs();
        var H = this.clone(), Z = j.clone();
        H.negative = 0, Z.negative = 0;
        for (var W = 0; H.isEven() && Z.isEven(); W++) H.iushrn(1), Z.iushrn(1);
        do {
          while (H.isEven()) H.iushrn(1);
          while (Z.isEven()) Z.iushrn(1);
          var w = H.cmp(Z);
          if (w < 0) {
            var G = H;
            H = Z, Z = G;
          } else if (w === 0 || Z.cmpn(1) === 0) break;
          H.isub(Z);
        } while (true);
        return Z.iushln(W);
      }, O.prototype.invm = function(j) {
        return this.egcd(j).a.umod(j);
      }, O.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, O.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, O.prototype.andln = function(j) {
        return this.words[0] & j;
      }, O.prototype.bincn = function(j) {
        _(typeof j === "number");
        var H = j % 26, Z = (j - H) / 26, W = 1 << H;
        if (this.length <= Z) return this._expand(Z + 1), this.words[Z] |= W, this;
        var w = W;
        for (var G = Z; w !== 0 && G < this.length; G++) {
          var S = this.words[G] | 0;
          S += w, w = S >>> 26, S &= 67108863, this.words[G] = S;
        }
        if (w !== 0) this.words[G] = w, this.length++;
        return this;
      }, O.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, O.prototype.cmpn = function(j) {
        var H = j < 0;
        if (this.negative !== 0 && !H) return -1;
        if (this.negative === 0 && H) return 1;
        this.strip();
        var Z;
        if (this.length > 1) Z = 1;
        else {
          if (H) j = -j;
          _(j <= 67108863, "Number is too big");
          var W = this.words[0] | 0;
          Z = W === j ? 0 : W < j ? -1 : 1;
        }
        if (this.negative !== 0) return -Z | 0;
        return Z;
      }, O.prototype.cmp = function(j) {
        if (this.negative !== 0 && j.negative === 0) return -1;
        if (this.negative === 0 && j.negative !== 0) return 1;
        var H = this.ucmp(j);
        if (this.negative !== 0) return -H | 0;
        return H;
      }, O.prototype.ucmp = function(j) {
        if (this.length > j.length) return 1;
        if (this.length < j.length) return -1;
        var H = 0;
        for (var Z = this.length - 1; Z >= 0; Z--) {
          var W = this.words[Z] | 0, w = j.words[Z] | 0;
          if (W === w) continue;
          if (W < w) H = -1;
          else if (W > w) H = 1;
          break;
        }
        return H;
      }, O.prototype.gtn = function(j) {
        return this.cmpn(j) === 1;
      }, O.prototype.gt = function(j) {
        return this.cmp(j) === 1;
      }, O.prototype.gten = function(j) {
        return this.cmpn(j) >= 0;
      }, O.prototype.gte = function(j) {
        return this.cmp(j) >= 0;
      }, O.prototype.ltn = function(j) {
        return this.cmpn(j) === -1;
      }, O.prototype.lt = function(j) {
        return this.cmp(j) === -1;
      }, O.prototype.lten = function(j) {
        return this.cmpn(j) <= 0;
      }, O.prototype.lte = function(j) {
        return this.cmp(j) <= 0;
      }, O.prototype.eqn = function(j) {
        return this.cmpn(j) === 0;
      }, O.prototype.eq = function(j) {
        return this.cmp(j) === 0;
      }, O.red = function(j) {
        return new c(j);
      }, O.prototype.toRed = function(j) {
        return _(!this.red, "Already a number in reduction context"), _(this.negative === 0, "red works only with positives"), j.convertTo(this)._forceRed(j);
      }, O.prototype.fromRed = function() {
        return _(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, O.prototype._forceRed = function(j) {
        return this.red = j, this;
      }, O.prototype.forceRed = function(j) {
        return _(!this.red, "Already a number in reduction context"), this._forceRed(j);
      }, O.prototype.redAdd = function(j) {
        return _(this.red, "redAdd works only with red numbers"), this.red.add(this, j);
      }, O.prototype.redIAdd = function(j) {
        return _(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, j);
      }, O.prototype.redSub = function(j) {
        return _(this.red, "redSub works only with red numbers"), this.red.sub(this, j);
      }, O.prototype.redISub = function(j) {
        return _(this.red, "redISub works only with red numbers"), this.red.isub(this, j);
      }, O.prototype.redShl = function(j) {
        return _(this.red, "redShl works only with red numbers"), this.red.shl(this, j);
      }, O.prototype.redMul = function(j) {
        return _(this.red, "redMul works only with red numbers"), this.red._verify2(this, j), this.red.mul(this, j);
      }, O.prototype.redIMul = function(j) {
        return _(this.red, "redMul works only with red numbers"), this.red._verify2(this, j), this.red.imul(this, j);
      }, O.prototype.redSqr = function() {
        return _(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, O.prototype.redISqr = function() {
        return _(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, O.prototype.redSqrt = function() {
        return _(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, O.prototype.redInvm = function() {
        return _(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, O.prototype.redNeg = function() {
        return _(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, O.prototype.redPow = function(j) {
        return _(this.red && !j.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, j);
      };
      var b = { k256: null, p224: null, p192: null, p25519: null };
      function y(j, H) {
        this.name = j, this.p = new O(H, 16), this.n = this.p.bitLength(), this.k = new O(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      y.prototype._tmp = function() {
        var j = new O(null);
        return j.words = Array(Math.ceil(this.n / 13)), j;
      }, y.prototype.ireduce = function(j) {
        var H = j, Z;
        do
          this.split(H, this.tmp), H = this.imulK(H), H = H.iadd(this.tmp), Z = H.bitLength();
        while (Z > this.n);
        var W = Z < this.n ? -1 : H.ucmp(this.p);
        if (W === 0) H.words[0] = 0, H.length = 1;
        else if (W > 0) H.isub(this.p);
        else if (H.strip !== void 0) H.strip();
        else H._strip();
        return H;
      }, y.prototype.split = function(j, H) {
        j.iushrn(this.n, 0, H);
      }, y.prototype.imulK = function(j) {
        return j.imul(this.k);
      };
      function p() {
        y.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
      }
      Y(p, y), p.prototype.split = function(j, H) {
        var Z = 4194303, W = Math.min(j.length, 9);
        for (var w = 0; w < W; w++) H.words[w] = j.words[w];
        if (H.length = W, j.length <= 9) {
          j.words[0] = 0, j.length = 1;
          return;
        }
        var G = j.words[9];
        H.words[H.length++] = G & Z;
        for (w = 10; w < j.length; w++) {
          var S = j.words[w] | 0;
          j.words[w - 10] = (S & Z) << 4 | G >>> 22, G = S;
        }
        if (G >>>= 22, j.words[w - 10] = G, G === 0 && j.length > 10) j.length -= 10;
        else j.length -= 9;
      }, p.prototype.imulK = function(j) {
        j.words[j.length] = 0, j.words[j.length + 1] = 0, j.length += 2;
        var H = 0;
        for (var Z = 0; Z < j.length; Z++) {
          var W = j.words[Z] | 0;
          H += W * 977, j.words[Z] = H & 67108863, H = W * 64 + (H / 67108864 | 0);
        }
        if (j.words[j.length - 1] === 0) {
          if (j.length--, j.words[j.length - 1] === 0) j.length--;
        }
        return j;
      };
      function n() {
        y.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
      }
      Y(n, y);
      function s() {
        y.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
      }
      Y(s, y);
      function q$() {
        y.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
      }
      Y(q$, y), q$.prototype.imulK = function(j) {
        var H = 0;
        for (var Z = 0; Z < j.length; Z++) {
          var W = (j.words[Z] | 0) * 19 + H, w = W & 67108863;
          W >>>= 26, j.words[Z] = w, H = W;
        }
        if (H !== 0) j.words[j.length++] = H;
        return j;
      }, O._prime = function(j) {
        if (b[j]) return b[j];
        var H;
        if (j === "k256") H = new p();
        else if (j === "p224") H = new n();
        else if (j === "p192") H = new s();
        else if (j === "p25519") H = new q$();
        else throw Error("Unknown prime " + j);
        return b[j] = H, H;
      };
      function c(j) {
        if (typeof j === "string") {
          var H = O._prime(j);
          this.m = H.p, this.prime = H;
        } else _(j.gtn(1), "modulus must be greater than 1"), this.m = j, this.prime = null;
      }
      c.prototype._verify1 = function(j) {
        _(j.negative === 0, "red works only with positives"), _(j.red, "red works only with red numbers");
      }, c.prototype._verify2 = function(j, H) {
        _((j.negative | H.negative) === 0, "red works only with positives"), _(j.red && j.red === H.red, "red works only with red numbers");
      }, c.prototype.imod = function(j) {
        if (this.prime) return this.prime.ireduce(j)._forceRed(this);
        return j.umod(this.m)._forceRed(this);
      }, c.prototype.neg = function(j) {
        if (j.isZero()) return j.clone();
        return this.m.sub(j)._forceRed(this);
      }, c.prototype.add = function(j, H) {
        this._verify2(j, H);
        var Z = j.add(H);
        if (Z.cmp(this.m) >= 0) Z.isub(this.m);
        return Z._forceRed(this);
      }, c.prototype.iadd = function(j, H) {
        this._verify2(j, H);
        var Z = j.iadd(H);
        if (Z.cmp(this.m) >= 0) Z.isub(this.m);
        return Z;
      }, c.prototype.sub = function(j, H) {
        this._verify2(j, H);
        var Z = j.sub(H);
        if (Z.cmpn(0) < 0) Z.iadd(this.m);
        return Z._forceRed(this);
      }, c.prototype.isub = function(j, H) {
        this._verify2(j, H);
        var Z = j.isub(H);
        if (Z.cmpn(0) < 0) Z.iadd(this.m);
        return Z;
      }, c.prototype.shl = function(j, H) {
        return this._verify1(j), this.imod(j.ushln(H));
      }, c.prototype.imul = function(j, H) {
        return this._verify2(j, H), this.imod(j.imul(H));
      }, c.prototype.mul = function(j, H) {
        return this._verify2(j, H), this.imod(j.mul(H));
      }, c.prototype.isqr = function(j) {
        return this.imul(j, j.clone());
      }, c.prototype.sqr = function(j) {
        return this.mul(j, j);
      }, c.prototype.sqrt = function(j) {
        if (j.isZero()) return j.clone();
        var H = this.m.andln(3);
        if (_(H % 2 === 1), H === 3) {
          var Z = this.m.add(new O(1)).iushrn(2);
          return this.pow(j, Z);
        }
        var W = this.m.subn(1), w = 0;
        while (!W.isZero() && W.andln(1) === 0) w++, W.iushrn(1);
        _(!W.isZero());
        var G = new O(1).toRed(this), S = G.redNeg(), A = this.m.subn(1).iushrn(1), v = this.m.bitLength();
        v = new O(2 * v * v).toRed(this);
        while (this.pow(v, A).cmp(S) !== 0) v.redIAdd(S);
        var k = this.pow(v, W), R = this.pow(j, W.addn(1).iushrn(1)), C = this.pow(j, W), L = w;
        while (C.cmp(G) !== 0) {
          var x = C;
          for (var l = 0; x.cmp(G) !== 0; l++) x = x.redSqr();
          _(l < L);
          var a = this.pow(k, new O(1).iushln(L - l - 1));
          R = R.redMul(a), k = a.redSqr(), C = C.redMul(k), L = l;
        }
        return R;
      }, c.prototype.invm = function(j) {
        var H = j._invmp(this.m);
        if (H.negative !== 0) return H.negative = 0, this.imod(H).redNeg();
        else return this.imod(H);
      }, c.prototype.pow = function(j, H) {
        if (H.isZero()) return new O(1).toRed(this);
        if (H.cmpn(1) === 0) return j.clone();
        var Z = 4, W = Array(1 << Z);
        W[0] = new O(1).toRed(this), W[1] = j;
        for (var w = 2; w < W.length; w++) W[w] = this.mul(W[w - 1], j);
        var G = W[0], S = 0, A = 0, v = H.bitLength() % 26;
        if (v === 0) v = 26;
        for (w = H.length - 1; w >= 0; w--) {
          var k = H.words[w];
          for (var R = v - 1; R >= 0; R--) {
            var C = k >> R & 1;
            if (G !== W[0]) G = this.sqr(G);
            if (C === 0 && S === 0) {
              A = 0;
              continue;
            }
            if (S <<= 1, S |= C, A++, A !== Z && (w !== 0 || R !== 0)) continue;
            G = this.mul(G, W[S]), A = 0, S = 0;
          }
          v = 26;
        }
        return G;
      }, c.prototype.convertTo = function(j) {
        var H = j.umod(this.m);
        return H === j ? H.clone() : H;
      }, c.prototype.convertFrom = function(j) {
        var H = j.clone();
        return H.red = null, H;
      }, O.mont = function(j) {
        return new U(j);
      };
      function U(j) {
        if (c.call(this, j), this.shift = this.m.bitLength(), this.shift % 26 !== 0) this.shift += 26 - this.shift % 26;
        this.r = new O(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      Y(U, c), U.prototype.convertTo = function(j) {
        return this.imod(j.ushln(this.shift));
      }, U.prototype.convertFrom = function(j) {
        var H = this.imod(j.mul(this.rinv));
        return H.red = null, H;
      }, U.prototype.imul = function(j, H) {
        if (j.isZero() || H.isZero()) return j.words[0] = 0, j.length = 1, j;
        var Z = j.imul(H), W = Z.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), w = Z.isub(W).iushrn(this.shift), G = w;
        if (w.cmp(this.m) >= 0) G = w.isub(this.m);
        else if (w.cmpn(0) < 0) G = w.iadd(this.m);
        return G._forceRed(this);
      }, U.prototype.mul = function(j, H) {
        if (j.isZero() || H.isZero()) return new O(0)._forceRed(this);
        var Z = j.mul(H), W = Z.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), w = Z.isub(W).iushrn(this.shift), G = w;
        if (w.cmp(this.m) >= 0) G = w.isub(this.m);
        else if (w.cmpn(0) < 0) G = w.iadd(this.m);
        return G._forceRed(this);
      }, U.prototype.invm = function(j) {
        var H = this.imod(j._invmp(this.m).mul(this.r2));
        return H._forceRed(this);
      };
    })(typeof q > "u" || q, $18);
  }), jo = r$(($18, q) => {
    var K = Oo(), P = Yo();
    q.exports = function(z) {
      return new Y(z);
    };
    var _ = { secp256k1: { name: "secp256k1", byteLength: 32 }, secp224r1: { name: "p224", byteLength: 28 }, prime256v1: { name: "p256", byteLength: 32 }, prime192v1: { name: "p192", byteLength: 24 }, ed25519: { name: "ed25519", byteLength: 32 }, secp384r1: { name: "p384", byteLength: 48 }, secp521r1: { name: "p521", byteLength: 66 } };
    _.p224 = _.secp224r1, _.p256 = _.secp256r1 = _.prime256v1, _.p192 = _.secp192r1 = _.prime192v1, _.p384 = _.secp384r1, _.p521 = _.secp521r1;
    function Y(z) {
      if (this.curveType = _[z], !this.curveType) this.curveType = { name: z };
      this.curve = new K.ec(this.curveType.name), this.keys = void 0;
    }
    Y.prototype.generateKeys = function(z, J) {
      return this.keys = this.curve.genKeyPair(), this.getPublicKey(z, J);
    }, Y.prototype.computeSecret = function(z, J, T) {
      if (J = J || "utf8", !Buffer.isBuffer(z)) z = new Buffer(z, J);
      var X = this.curve.keyFromPublic(z).getPublic(), f = X.mul(this.keys.getPrivate()).getX();
      return O(f, T, this.curveType.byteLength);
    }, Y.prototype.getPublicKey = function(z, J) {
      var T = this.keys.getPublic(J === "compressed", true);
      if (J === "hybrid") if (T[T.length - 1] % 2) T[0] = 7;
      else T[0] = 6;
      return O(T, z);
    }, Y.prototype.getPrivateKey = function(z) {
      return O(this.keys.getPrivate(), z);
    }, Y.prototype.setPublicKey = function(z, J) {
      if (J = J || "utf8", !Buffer.isBuffer(z)) z = new Buffer(z, J);
      return this.keys._importPublic(z), this;
    }, Y.prototype.setPrivateKey = function(z, J) {
      if (J = J || "utf8", !Buffer.isBuffer(z)) z = new Buffer(z, J);
      var T = new P(z);
      return T = T.toString(16), this.keys = this.curve.genKeyPair(), this.keys._importPrivate(T), this;
    };
    function O(z, J, T) {
      if (!Array.isArray(z)) z = z.toArray();
      var X = new Buffer(z);
      if (T && X.length < T) {
        var f = new Buffer(T - X.length);
        f.fill(0), X = Buffer.concat([f, X]);
      }
      if (!J) return X;
      else return X.toString(J);
    }
  }), vo = r$(($18, q) => {
    var K = (dq(), J6(mq)).createECDH;
    q.exports = K || jo();
  }), zo = r$(($18, q) => {
    (function(K, P) {
      function _(j, H) {
        if (!j) throw Error(H || "Assertion failed");
      }
      function Y(j, H) {
        j.super_ = H;
        var Z = function() {
        };
        Z.prototype = H.prototype, j.prototype = new Z(), j.prototype.constructor = j;
      }
      function O(j, H, Z) {
        if (O.isBN(j)) return j;
        if (this.negative = 0, this.words = null, this.length = 0, this.red = null, j !== null) {
          if (H === "le" || H === "be") Z = H, H = 10;
          this._init(j || 0, H || 10, Z || "be");
        }
      }
      if (typeof K === "object") K.exports = O;
      else P.BN = O;
      O.BN = O, O.wordSize = 26;
      var z;
      try {
        if (typeof window < "u" && typeof window.Buffer < "u") z = window.Buffer;
        else z = (wq(), J6(Tq)).Buffer;
      } catch (j) {
      }
      O.isBN = function(j) {
        if (j instanceof O) return true;
        return j !== null && typeof j === "object" && j.constructor.wordSize === O.wordSize && Array.isArray(j.words);
      }, O.max = function(j, H) {
        if (j.cmp(H) > 0) return j;
        return H;
      }, O.min = function(j, H) {
        if (j.cmp(H) < 0) return j;
        return H;
      }, O.prototype._init = function(j, H, Z) {
        if (typeof j === "number") return this._initNumber(j, H, Z);
        if (typeof j === "object") return this._initArray(j, H, Z);
        if (H === "hex") H = 16;
        _(H === (H | 0) && H >= 2 && H <= 36), j = j.toString().replace(/\s+/g, "");
        var W = 0;
        if (j[0] === "-") W++, this.negative = 1;
        if (W < j.length) {
          if (H === 16) this._parseHex(j, W, Z);
          else if (this._parseBase(j, H, W), Z === "le") this._initArray(this.toArray(), H, Z);
        }
      }, O.prototype._initNumber = function(j, H, Z) {
        if (j < 0) this.negative = 1, j = -j;
        if (j < 67108864) this.words = [j & 67108863], this.length = 1;
        else if (j < 4503599627370496) this.words = [j & 67108863, j / 67108864 & 67108863], this.length = 2;
        else _(j < 9007199254740992), this.words = [j & 67108863, j / 67108864 & 67108863, 1], this.length = 3;
        if (Z !== "le") return;
        this._initArray(this.toArray(), H, Z);
      }, O.prototype._initArray = function(j, H, Z) {
        if (_(typeof j.length === "number"), j.length <= 0) return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(j.length / 3), this.words = Array(this.length);
        for (var W = 0; W < this.length; W++) this.words[W] = 0;
        var w, G, S = 0;
        if (Z === "be") {
          for (W = j.length - 1, w = 0; W >= 0; W -= 3) if (G = j[W] | j[W - 1] << 8 | j[W - 2] << 16, this.words[w] |= G << S & 67108863, this.words[w + 1] = G >>> 26 - S & 67108863, S += 24, S >= 26) S -= 26, w++;
        } else if (Z === "le") {
          for (W = 0, w = 0; W < j.length; W += 3) if (G = j[W] | j[W + 1] << 8 | j[W + 2] << 16, this.words[w] |= G << S & 67108863, this.words[w + 1] = G >>> 26 - S & 67108863, S += 24, S >= 26) S -= 26, w++;
        }
        return this.strip();
      };
      function J(j, H) {
        var Z = j.charCodeAt(H);
        if (Z >= 65 && Z <= 70) return Z - 55;
        else if (Z >= 97 && Z <= 102) return Z - 87;
        else return Z - 48 & 15;
      }
      function T(j, H, Z) {
        var W = J(j, Z);
        if (Z - 1 >= H) W |= J(j, Z - 1) << 4;
        return W;
      }
      O.prototype._parseHex = function(j, H, Z) {
        this.length = Math.ceil((j.length - H) / 6), this.words = Array(this.length);
        for (var W = 0; W < this.length; W++) this.words[W] = 0;
        var w = 0, G = 0, S;
        if (Z === "be") for (W = j.length - 1; W >= H; W -= 2) if (S = T(j, H, W) << w, this.words[G] |= S & 67108863, w >= 18) w -= 18, G += 1, this.words[G] |= S >>> 26;
        else w += 8;
        else {
          var A = j.length - H;
          for (W = A % 2 === 0 ? H + 1 : H; W < j.length; W += 2) if (S = T(j, H, W) << w, this.words[G] |= S & 67108863, w >= 18) w -= 18, G += 1, this.words[G] |= S >>> 26;
          else w += 8;
        }
        this.strip();
      };
      function X(j, H, Z, W) {
        var w = 0, G = Math.min(j.length, Z);
        for (var S = H; S < G; S++) {
          var A = j.charCodeAt(S) - 48;
          if (w *= W, A >= 49) w += A - 49 + 10;
          else if (A >= 17) w += A - 17 + 10;
          else w += A;
        }
        return w;
      }
      O.prototype._parseBase = function(j, H, Z) {
        this.words = [0], this.length = 1;
        for (var W = 0, w = 1; w <= 67108863; w *= H) W++;
        W--, w = w / H | 0;
        var G = j.length - Z, S = G % W, A = Math.min(G, G - S) + Z, v = 0;
        for (var k = Z; k < A; k += W) if (v = X(j, k, k + W, H), this.imuln(w), this.words[0] + v < 67108864) this.words[0] += v;
        else this._iaddn(v);
        if (S !== 0) {
          var R = 1;
          v = X(j, k, j.length, H);
          for (k = 0; k < S; k++) R *= H;
          if (this.imuln(R), this.words[0] + v < 67108864) this.words[0] += v;
          else this._iaddn(v);
        }
        this.strip();
      }, O.prototype.copy = function(j) {
        j.words = Array(this.length);
        for (var H = 0; H < this.length; H++) j.words[H] = this.words[H];
        j.length = this.length, j.negative = this.negative, j.red = this.red;
      }, O.prototype.clone = function() {
        var j = new O(null);
        return this.copy(j), j;
      }, O.prototype._expand = function(j) {
        while (this.length < j) this.words[this.length++] = 0;
        return this;
      }, O.prototype.strip = function() {
        while (this.length > 1 && this.words[this.length - 1] === 0) this.length--;
        return this._normSign();
      }, O.prototype._normSign = function() {
        if (this.length === 1 && this.words[0] === 0) this.negative = 0;
        return this;
      }, O.prototype.inspect = function() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var f = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], V = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], M = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
      if (O.prototype.toString = function(j, H) {
        j = j || 10, H = H | 0 || 1;
        var Z;
        if (j === 16 || j === "hex") {
          Z = "";
          var W = 0, w = 0;
          for (var G = 0; G < this.length; G++) {
            var S = this.words[G], A = ((S << W | w) & 16777215).toString(16);
            if (w = S >>> 24 - W & 16777215, W += 2, W >= 26) W -= 26, G--;
            if (w !== 0 || G !== this.length - 1) Z = f[6 - A.length] + A + Z;
            else Z = A + Z;
          }
          if (w !== 0) Z = w.toString(16) + Z;
          while (Z.length % H !== 0) Z = "0" + Z;
          if (this.negative !== 0) Z = "-" + Z;
          return Z;
        }
        if (j === (j | 0) && j >= 2 && j <= 36) {
          var v = V[j], k = M[j];
          Z = "";
          var R = this.clone();
          R.negative = 0;
          while (!R.isZero()) {
            var C = R.modn(k).toString(j);
            if (R = R.idivn(k), !R.isZero()) Z = f[v - C.length] + C + Z;
            else Z = C + Z;
          }
          if (this.isZero()) Z = "0" + Z;
          while (Z.length % H !== 0) Z = "0" + Z;
          if (this.negative !== 0) Z = "-" + Z;
          return Z;
        }
        _(false, "Base should be between 2 and 36");
      }, O.prototype.toNumber = function() {
        var j = this.words[0];
        if (this.length === 2) j += this.words[1] * 67108864;
        else if (this.length === 3 && this.words[2] === 1) j += 4503599627370496 + this.words[1] * 67108864;
        else if (this.length > 2) _(false, "Number can only safely store up to 53 bits");
        return this.negative !== 0 ? -j : j;
      }, O.prototype.toJSON = function() {
        return this.toString(16);
      }, O.prototype.toBuffer = function(j, H) {
        return _(typeof z < "u"), this.toArrayLike(z, j, H);
      }, O.prototype.toArray = function(j, H) {
        return this.toArrayLike(Array, j, H);
      }, O.prototype.toArrayLike = function(j, H, Z) {
        var W = this.byteLength(), w = Z || Math.max(1, W);
        _(W <= w, "byte array longer than desired length"), _(w > 0, "Requested array length <= 0"), this.strip();
        var G = H === "le", S = new j(w), A, v, k = this.clone();
        if (!G) {
          for (v = 0; v < w - W; v++) S[v] = 0;
          for (v = 0; !k.isZero(); v++) A = k.andln(255), k.iushrn(8), S[w - v - 1] = A;
        } else {
          for (v = 0; !k.isZero(); v++) A = k.andln(255), k.iushrn(8), S[v] = A;
          for (; v < w; v++) S[v] = 0;
        }
        return S;
      }, Math.clz32) O.prototype._countBits = function(j) {
        return 32 - Math.clz32(j);
      };
      else O.prototype._countBits = function(j) {
        var H = j, Z = 0;
        if (H >= 4096) Z += 13, H >>>= 13;
        if (H >= 64) Z += 7, H >>>= 7;
        if (H >= 8) Z += 4, H >>>= 4;
        if (H >= 2) Z += 2, H >>>= 2;
        return Z + H;
      };
      O.prototype._zeroBits = function(j) {
        if (j === 0) return 26;
        var H = j, Z = 0;
        if ((H & 8191) === 0) Z += 13, H >>>= 13;
        if ((H & 127) === 0) Z += 7, H >>>= 7;
        if ((H & 15) === 0) Z += 4, H >>>= 4;
        if ((H & 3) === 0) Z += 2, H >>>= 2;
        if ((H & 1) === 0) Z++;
        return Z;
      }, O.prototype.bitLength = function() {
        var j = this.words[this.length - 1], H = this._countBits(j);
        return (this.length - 1) * 26 + H;
      };
      function N(j) {
        var H = Array(j.bitLength());
        for (var Z = 0; Z < H.length; Z++) {
          var W = Z / 26 | 0, w = Z % 26;
          H[Z] = (j.words[W] & 1 << w) >>> w;
        }
        return H;
      }
      O.prototype.zeroBits = function() {
        if (this.isZero()) return 0;
        var j = 0;
        for (var H = 0; H < this.length; H++) {
          var Z = this._zeroBits(this.words[H]);
          if (j += Z, Z !== 26) break;
        }
        return j;
      }, O.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, O.prototype.toTwos = function(j) {
        if (this.negative !== 0) return this.abs().inotn(j).iaddn(1);
        return this.clone();
      }, O.prototype.fromTwos = function(j) {
        if (this.testn(j - 1)) return this.notn(j).iaddn(1).ineg();
        return this.clone();
      }, O.prototype.isNeg = function() {
        return this.negative !== 0;
      }, O.prototype.neg = function() {
        return this.clone().ineg();
      }, O.prototype.ineg = function() {
        if (!this.isZero()) this.negative ^= 1;
        return this;
      }, O.prototype.iuor = function(j) {
        while (this.length < j.length) this.words[this.length++] = 0;
        for (var H = 0; H < j.length; H++) this.words[H] = this.words[H] | j.words[H];
        return this.strip();
      }, O.prototype.ior = function(j) {
        return _((this.negative | j.negative) === 0), this.iuor(j);
      }, O.prototype.or = function(j) {
        if (this.length > j.length) return this.clone().ior(j);
        return j.clone().ior(this);
      }, O.prototype.uor = function(j) {
        if (this.length > j.length) return this.clone().iuor(j);
        return j.clone().iuor(this);
      }, O.prototype.iuand = function(j) {
        var H;
        if (this.length > j.length) H = j;
        else H = this;
        for (var Z = 0; Z < H.length; Z++) this.words[Z] = this.words[Z] & j.words[Z];
        return this.length = H.length, this.strip();
      }, O.prototype.iand = function(j) {
        return _((this.negative | j.negative) === 0), this.iuand(j);
      }, O.prototype.and = function(j) {
        if (this.length > j.length) return this.clone().iand(j);
        return j.clone().iand(this);
      }, O.prototype.uand = function(j) {
        if (this.length > j.length) return this.clone().iuand(j);
        return j.clone().iuand(this);
      }, O.prototype.iuxor = function(j) {
        var H, Z;
        if (this.length > j.length) H = this, Z = j;
        else H = j, Z = this;
        for (var W = 0; W < Z.length; W++) this.words[W] = H.words[W] ^ Z.words[W];
        if (this !== H) for (; W < H.length; W++) this.words[W] = H.words[W];
        return this.length = H.length, this.strip();
      }, O.prototype.ixor = function(j) {
        return _((this.negative | j.negative) === 0), this.iuxor(j);
      }, O.prototype.xor = function(j) {
        if (this.length > j.length) return this.clone().ixor(j);
        return j.clone().ixor(this);
      }, O.prototype.uxor = function(j) {
        if (this.length > j.length) return this.clone().iuxor(j);
        return j.clone().iuxor(this);
      }, O.prototype.inotn = function(j) {
        _(typeof j === "number" && j >= 0);
        var H = Math.ceil(j / 26) | 0, Z = j % 26;
        if (this._expand(H), Z > 0) H--;
        for (var W = 0; W < H; W++) this.words[W] = ~this.words[W] & 67108863;
        if (Z > 0) this.words[W] = ~this.words[W] & 67108863 >> 26 - Z;
        return this.strip();
      }, O.prototype.notn = function(j) {
        return this.clone().inotn(j);
      }, O.prototype.setn = function(j, H) {
        _(typeof j === "number" && j >= 0);
        var Z = j / 26 | 0, W = j % 26;
        if (this._expand(Z + 1), H) this.words[Z] = this.words[Z] | 1 << W;
        else this.words[Z] = this.words[Z] & ~(1 << W);
        return this.strip();
      }, O.prototype.iadd = function(j) {
        var H;
        if (this.negative !== 0 && j.negative === 0) return this.negative = 0, H = this.isub(j), this.negative ^= 1, this._normSign();
        else if (this.negative === 0 && j.negative !== 0) return j.negative = 0, H = this.isub(j), j.negative = 1, H._normSign();
        var Z, W;
        if (this.length > j.length) Z = this, W = j;
        else Z = j, W = this;
        var w = 0;
        for (var G = 0; G < W.length; G++) H = (Z.words[G] | 0) + (W.words[G] | 0) + w, this.words[G] = H & 67108863, w = H >>> 26;
        for (; w !== 0 && G < Z.length; G++) H = (Z.words[G] | 0) + w, this.words[G] = H & 67108863, w = H >>> 26;
        if (this.length = Z.length, w !== 0) this.words[this.length] = w, this.length++;
        else if (Z !== this) for (; G < Z.length; G++) this.words[G] = Z.words[G];
        return this;
      }, O.prototype.add = function(j) {
        var H;
        if (j.negative !== 0 && this.negative === 0) return j.negative = 0, H = this.sub(j), j.negative ^= 1, H;
        else if (j.negative === 0 && this.negative !== 0) return this.negative = 0, H = j.sub(this), this.negative = 1, H;
        if (this.length > j.length) return this.clone().iadd(j);
        return j.clone().iadd(this);
      }, O.prototype.isub = function(j) {
        if (j.negative !== 0) {
          j.negative = 0;
          var H = this.iadd(j);
          return j.negative = 1, H._normSign();
        } else if (this.negative !== 0) return this.negative = 0, this.iadd(j), this.negative = 1, this._normSign();
        var Z = this.cmp(j);
        if (Z === 0) return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var W, w;
        if (Z > 0) W = this, w = j;
        else W = j, w = this;
        var G = 0;
        for (var S = 0; S < w.length; S++) H = (W.words[S] | 0) - (w.words[S] | 0) + G, G = H >> 26, this.words[S] = H & 67108863;
        for (; G !== 0 && S < W.length; S++) H = (W.words[S] | 0) + G, G = H >> 26, this.words[S] = H & 67108863;
        if (G === 0 && S < W.length && W !== this) for (; S < W.length; S++) this.words[S] = W.words[S];
        if (this.length = Math.max(this.length, S), W !== this) this.negative = 1;
        return this.strip();
      }, O.prototype.sub = function(j) {
        return this.clone().isub(j);
      };
      function h(j, H, Z) {
        Z.negative = H.negative ^ j.negative;
        var W = j.length + H.length | 0;
        Z.length = W, W = W - 1 | 0;
        var w = j.words[0] | 0, G = H.words[0] | 0, S = w * G, A = S & 67108863, v = S / 67108864 | 0;
        Z.words[0] = A;
        for (var k = 1; k < W; k++) {
          var R = v >>> 26, C = v & 67108863, L = Math.min(k, H.length - 1);
          for (var x = Math.max(0, k - j.length + 1); x <= L; x++) {
            var l = k - x | 0;
            w = j.words[l] | 0, G = H.words[x] | 0, S = w * G + C, R += S / 67108864 | 0, C = S & 67108863;
          }
          Z.words[k] = C | 0, v = R | 0;
        }
        if (v !== 0) Z.words[k] = v | 0;
        else Z.length--;
        return Z.strip();
      }
      var E = function(j, H, Z) {
        var W = j.words, w = H.words, G = Z.words, S = 0, A, v, k, R = W[0] | 0, C = R & 8191, L = R >>> 13, x = W[1] | 0, l = x & 8191, a = x >>> 13, f$ = W[2] | 0, $$ = f$ & 8191, B = f$ >>> 13, H$ = W[3] | 0, Q = H$ & 8191, v$ = H$ >>> 13, t$ = W[4] | 0, m = t$ & 8191, r = t$ >>> 13, J$ = W[5] | 0, e = J$ & 8191, _$2 = J$ >>> 13, Y$ = W[6] | 0, d = Y$ & 8191, o = Y$ >>> 13, W$ = W[7] | 0, t = W$ & 8191, F = W$ >>> 13, X$ = W[8] | 0, z$ = X$ & 8191, j$ = X$ >>> 13, X6 = W[9] | 0, Z$ = X6 & 8191, A$ = X6 >>> 13, d6 = w[0] | 0, S$ = d6 & 8191, V$ = d6 >>> 13, Sq = w[1] | 0, N$ = Sq & 8191, D$ = Sq >>> 13, Mq = w[2] | 0, L$ = Mq & 8191, C$ = Mq >>> 13, fq = w[3] | 0, g$ = fq & 8191, E$ = fq >>> 13, vq = w[4] | 0, b$ = vq & 8191, y$ = vq >>> 13, zq = w[5] | 0, h$ = zq & 8191, u = zq >>> 13, i = w[6] | 0, K$ = i & 8191, P$ = i >>> 13, i$ = w[7] | 0, k$ = i$ & 8191, G$ = i$ >>> 13, x6 = w[8] | 0, R$ = x6 & 8191, u$ = x6 >>> 13, Zq = w[9] | 0, I$ = Zq & 8191, M$ = Zq >>> 13;
        Z.negative = j.negative ^ H.negative, Z.length = 19, A = Math.imul(C, S$), v = Math.imul(C, V$), v = v + Math.imul(L, S$) | 0, k = Math.imul(L, V$);
        var p6 = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (p6 >>> 26) | 0, p6 &= 67108863, A = Math.imul(l, S$), v = Math.imul(l, V$), v = v + Math.imul(a, S$) | 0, k = Math.imul(a, V$), A = A + Math.imul(C, N$) | 0, v = v + Math.imul(C, D$) | 0, v = v + Math.imul(L, N$) | 0, k = k + Math.imul(L, D$) | 0;
        var H6 = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (H6 >>> 26) | 0, H6 &= 67108863, A = Math.imul($$, S$), v = Math.imul($$, V$), v = v + Math.imul(B, S$) | 0, k = Math.imul(B, V$), A = A + Math.imul(l, N$) | 0, v = v + Math.imul(l, D$) | 0, v = v + Math.imul(a, N$) | 0, k = k + Math.imul(a, D$) | 0, A = A + Math.imul(C, L$) | 0, v = v + Math.imul(C, C$) | 0, v = v + Math.imul(L, L$) | 0, k = k + Math.imul(L, C$) | 0;
        var v6 = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (v6 >>> 26) | 0, v6 &= 67108863, A = Math.imul(Q, S$), v = Math.imul(Q, V$), v = v + Math.imul(v$, S$) | 0, k = Math.imul(v$, V$), A = A + Math.imul($$, N$) | 0, v = v + Math.imul($$, D$) | 0, v = v + Math.imul(B, N$) | 0, k = k + Math.imul(B, D$) | 0, A = A + Math.imul(l, L$) | 0, v = v + Math.imul(l, C$) | 0, v = v + Math.imul(a, L$) | 0, k = k + Math.imul(a, C$) | 0, A = A + Math.imul(C, g$) | 0, v = v + Math.imul(C, E$) | 0, v = v + Math.imul(L, g$) | 0, k = k + Math.imul(L, E$) | 0;
        var C6 = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (C6 >>> 26) | 0, C6 &= 67108863, A = Math.imul(m, S$), v = Math.imul(m, V$), v = v + Math.imul(r, S$) | 0, k = Math.imul(r, V$), A = A + Math.imul(Q, N$) | 0, v = v + Math.imul(Q, D$) | 0, v = v + Math.imul(v$, N$) | 0, k = k + Math.imul(v$, D$) | 0, A = A + Math.imul($$, L$) | 0, v = v + Math.imul($$, C$) | 0, v = v + Math.imul(B, L$) | 0, k = k + Math.imul(B, C$) | 0, A = A + Math.imul(l, g$) | 0, v = v + Math.imul(l, E$) | 0, v = v + Math.imul(a, g$) | 0, k = k + Math.imul(a, E$) | 0, A = A + Math.imul(C, b$) | 0, v = v + Math.imul(C, y$) | 0, v = v + Math.imul(L, b$) | 0, k = k + Math.imul(L, y$) | 0;
        var S6 = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (S6 >>> 26) | 0, S6 &= 67108863, A = Math.imul(e, S$), v = Math.imul(e, V$), v = v + Math.imul(_$2, S$) | 0, k = Math.imul(_$2, V$), A = A + Math.imul(m, N$) | 0, v = v + Math.imul(m, D$) | 0, v = v + Math.imul(r, N$) | 0, k = k + Math.imul(r, D$) | 0, A = A + Math.imul(Q, L$) | 0, v = v + Math.imul(Q, C$) | 0, v = v + Math.imul(v$, L$) | 0, k = k + Math.imul(v$, C$) | 0, A = A + Math.imul($$, g$) | 0, v = v + Math.imul($$, E$) | 0, v = v + Math.imul(B, g$) | 0, k = k + Math.imul(B, E$) | 0, A = A + Math.imul(l, b$) | 0, v = v + Math.imul(l, y$) | 0, v = v + Math.imul(a, b$) | 0, k = k + Math.imul(a, y$) | 0, A = A + Math.imul(C, h$) | 0, v = v + Math.imul(C, u) | 0, v = v + Math.imul(L, h$) | 0, k = k + Math.imul(L, u) | 0;
        var i6 = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (i6 >>> 26) | 0, i6 &= 67108863, A = Math.imul(d, S$), v = Math.imul(d, V$), v = v + Math.imul(o, S$) | 0, k = Math.imul(o, V$), A = A + Math.imul(e, N$) | 0, v = v + Math.imul(e, D$) | 0, v = v + Math.imul(_$2, N$) | 0, k = k + Math.imul(_$2, D$) | 0, A = A + Math.imul(m, L$) | 0, v = v + Math.imul(m, C$) | 0, v = v + Math.imul(r, L$) | 0, k = k + Math.imul(r, C$) | 0, A = A + Math.imul(Q, g$) | 0, v = v + Math.imul(Q, E$) | 0, v = v + Math.imul(v$, g$) | 0, k = k + Math.imul(v$, E$) | 0, A = A + Math.imul($$, b$) | 0, v = v + Math.imul($$, y$) | 0, v = v + Math.imul(B, b$) | 0, k = k + Math.imul(B, y$) | 0, A = A + Math.imul(l, h$) | 0, v = v + Math.imul(l, u) | 0, v = v + Math.imul(a, h$) | 0, k = k + Math.imul(a, u) | 0, A = A + Math.imul(C, K$) | 0, v = v + Math.imul(C, P$) | 0, v = v + Math.imul(L, K$) | 0, k = k + Math.imul(L, P$) | 0;
        var B6 = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (B6 >>> 26) | 0, B6 &= 67108863, A = Math.imul(t, S$), v = Math.imul(t, V$), v = v + Math.imul(F, S$) | 0, k = Math.imul(F, V$), A = A + Math.imul(d, N$) | 0, v = v + Math.imul(d, D$) | 0, v = v + Math.imul(o, N$) | 0, k = k + Math.imul(o, D$) | 0, A = A + Math.imul(e, L$) | 0, v = v + Math.imul(e, C$) | 0, v = v + Math.imul(_$2, L$) | 0, k = k + Math.imul(_$2, C$) | 0, A = A + Math.imul(m, g$) | 0, v = v + Math.imul(m, E$) | 0, v = v + Math.imul(r, g$) | 0, k = k + Math.imul(r, E$) | 0, A = A + Math.imul(Q, b$) | 0, v = v + Math.imul(Q, y$) | 0, v = v + Math.imul(v$, b$) | 0, k = k + Math.imul(v$, y$) | 0, A = A + Math.imul($$, h$) | 0, v = v + Math.imul($$, u) | 0, v = v + Math.imul(B, h$) | 0, k = k + Math.imul(B, u) | 0, A = A + Math.imul(l, K$) | 0, v = v + Math.imul(l, P$) | 0, v = v + Math.imul(a, K$) | 0, k = k + Math.imul(a, P$) | 0, A = A + Math.imul(C, k$) | 0, v = v + Math.imul(C, G$) | 0, v = v + Math.imul(L, k$) | 0, k = k + Math.imul(L, G$) | 0;
        var t6 = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (t6 >>> 26) | 0, t6 &= 67108863, A = Math.imul(z$, S$), v = Math.imul(z$, V$), v = v + Math.imul(j$, S$) | 0, k = Math.imul(j$, V$), A = A + Math.imul(t, N$) | 0, v = v + Math.imul(t, D$) | 0, v = v + Math.imul(F, N$) | 0, k = k + Math.imul(F, D$) | 0, A = A + Math.imul(d, L$) | 0, v = v + Math.imul(d, C$) | 0, v = v + Math.imul(o, L$) | 0, k = k + Math.imul(o, C$) | 0, A = A + Math.imul(e, g$) | 0, v = v + Math.imul(e, E$) | 0, v = v + Math.imul(_$2, g$) | 0, k = k + Math.imul(_$2, E$) | 0, A = A + Math.imul(m, b$) | 0, v = v + Math.imul(m, y$) | 0, v = v + Math.imul(r, b$) | 0, k = k + Math.imul(r, y$) | 0, A = A + Math.imul(Q, h$) | 0, v = v + Math.imul(Q, u) | 0, v = v + Math.imul(v$, h$) | 0, k = k + Math.imul(v$, u) | 0, A = A + Math.imul($$, K$) | 0, v = v + Math.imul($$, P$) | 0, v = v + Math.imul(B, K$) | 0, k = k + Math.imul(B, P$) | 0, A = A + Math.imul(l, k$) | 0, v = v + Math.imul(l, G$) | 0, v = v + Math.imul(a, k$) | 0, k = k + Math.imul(a, G$) | 0, A = A + Math.imul(C, R$) | 0, v = v + Math.imul(C, u$) | 0, v = v + Math.imul(L, R$) | 0, k = k + Math.imul(L, u$) | 0;
        var U6 = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (U6 >>> 26) | 0, U6 &= 67108863, A = Math.imul(Z$, S$), v = Math.imul(Z$, V$), v = v + Math.imul(A$, S$) | 0, k = Math.imul(A$, V$), A = A + Math.imul(z$, N$) | 0, v = v + Math.imul(z$, D$) | 0, v = v + Math.imul(j$, N$) | 0, k = k + Math.imul(j$, D$) | 0, A = A + Math.imul(t, L$) | 0, v = v + Math.imul(t, C$) | 0, v = v + Math.imul(F, L$) | 0, k = k + Math.imul(F, C$) | 0, A = A + Math.imul(d, g$) | 0, v = v + Math.imul(d, E$) | 0, v = v + Math.imul(o, g$) | 0, k = k + Math.imul(o, E$) | 0, A = A + Math.imul(e, b$) | 0, v = v + Math.imul(e, y$) | 0, v = v + Math.imul(_$2, b$) | 0, k = k + Math.imul(_$2, y$) | 0, A = A + Math.imul(m, h$) | 0, v = v + Math.imul(m, u) | 0, v = v + Math.imul(r, h$) | 0, k = k + Math.imul(r, u) | 0, A = A + Math.imul(Q, K$) | 0, v = v + Math.imul(Q, P$) | 0, v = v + Math.imul(v$, K$) | 0, k = k + Math.imul(v$, P$) | 0, A = A + Math.imul($$, k$) | 0, v = v + Math.imul($$, G$) | 0, v = v + Math.imul(B, k$) | 0, k = k + Math.imul(B, G$) | 0, A = A + Math.imul(l, R$) | 0, v = v + Math.imul(l, u$) | 0, v = v + Math.imul(a, R$) | 0, k = k + Math.imul(a, u$) | 0, A = A + Math.imul(C, I$) | 0, v = v + Math.imul(C, M$) | 0, v = v + Math.imul(L, I$) | 0, k = k + Math.imul(L, M$) | 0;
        var F6 = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (F6 >>> 26) | 0, F6 &= 67108863, A = Math.imul(Z$, N$), v = Math.imul(Z$, D$), v = v + Math.imul(A$, N$) | 0, k = Math.imul(A$, D$), A = A + Math.imul(z$, L$) | 0, v = v + Math.imul(z$, C$) | 0, v = v + Math.imul(j$, L$) | 0, k = k + Math.imul(j$, C$) | 0, A = A + Math.imul(t, g$) | 0, v = v + Math.imul(t, E$) | 0, v = v + Math.imul(F, g$) | 0, k = k + Math.imul(F, E$) | 0, A = A + Math.imul(d, b$) | 0, v = v + Math.imul(d, y$) | 0, v = v + Math.imul(o, b$) | 0, k = k + Math.imul(o, y$) | 0, A = A + Math.imul(e, h$) | 0, v = v + Math.imul(e, u) | 0, v = v + Math.imul(_$2, h$) | 0, k = k + Math.imul(_$2, u) | 0, A = A + Math.imul(m, K$) | 0, v = v + Math.imul(m, P$) | 0, v = v + Math.imul(r, K$) | 0, k = k + Math.imul(r, P$) | 0, A = A + Math.imul(Q, k$) | 0, v = v + Math.imul(Q, G$) | 0, v = v + Math.imul(v$, k$) | 0, k = k + Math.imul(v$, G$) | 0, A = A + Math.imul($$, R$) | 0, v = v + Math.imul($$, u$) | 0, v = v + Math.imul(B, R$) | 0, k = k + Math.imul(B, u$) | 0, A = A + Math.imul(l, I$) | 0, v = v + Math.imul(l, M$) | 0, v = v + Math.imul(a, I$) | 0, k = k + Math.imul(a, M$) | 0;
        var a6 = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (a6 >>> 26) | 0, a6 &= 67108863, A = Math.imul(Z$, L$), v = Math.imul(Z$, C$), v = v + Math.imul(A$, L$) | 0, k = Math.imul(A$, C$), A = A + Math.imul(z$, g$) | 0, v = v + Math.imul(z$, E$) | 0, v = v + Math.imul(j$, g$) | 0, k = k + Math.imul(j$, E$) | 0, A = A + Math.imul(t, b$) | 0, v = v + Math.imul(t, y$) | 0, v = v + Math.imul(F, b$) | 0, k = k + Math.imul(F, y$) | 0, A = A + Math.imul(d, h$) | 0, v = v + Math.imul(d, u) | 0, v = v + Math.imul(o, h$) | 0, k = k + Math.imul(o, u) | 0, A = A + Math.imul(e, K$) | 0, v = v + Math.imul(e, P$) | 0, v = v + Math.imul(_$2, K$) | 0, k = k + Math.imul(_$2, P$) | 0, A = A + Math.imul(m, k$) | 0, v = v + Math.imul(m, G$) | 0, v = v + Math.imul(r, k$) | 0, k = k + Math.imul(r, G$) | 0, A = A + Math.imul(Q, R$) | 0, v = v + Math.imul(Q, u$) | 0, v = v + Math.imul(v$, R$) | 0, k = k + Math.imul(v$, u$) | 0, A = A + Math.imul($$, I$) | 0, v = v + Math.imul($$, M$) | 0, v = v + Math.imul(B, I$) | 0, k = k + Math.imul(B, M$) | 0;
        var Q6 = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (Q6 >>> 26) | 0, Q6 &= 67108863, A = Math.imul(Z$, g$), v = Math.imul(Z$, E$), v = v + Math.imul(A$, g$) | 0, k = Math.imul(A$, E$), A = A + Math.imul(z$, b$) | 0, v = v + Math.imul(z$, y$) | 0, v = v + Math.imul(j$, b$) | 0, k = k + Math.imul(j$, y$) | 0, A = A + Math.imul(t, h$) | 0, v = v + Math.imul(t, u) | 0, v = v + Math.imul(F, h$) | 0, k = k + Math.imul(F, u) | 0, A = A + Math.imul(d, K$) | 0, v = v + Math.imul(d, P$) | 0, v = v + Math.imul(o, K$) | 0, k = k + Math.imul(o, P$) | 0, A = A + Math.imul(e, k$) | 0, v = v + Math.imul(e, G$) | 0, v = v + Math.imul(_$2, k$) | 0, k = k + Math.imul(_$2, G$) | 0, A = A + Math.imul(m, R$) | 0, v = v + Math.imul(m, u$) | 0, v = v + Math.imul(r, R$) | 0, k = k + Math.imul(r, u$) | 0, A = A + Math.imul(Q, I$) | 0, v = v + Math.imul(Q, M$) | 0, v = v + Math.imul(v$, I$) | 0, k = k + Math.imul(v$, M$) | 0;
        var e6 = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (e6 >>> 26) | 0, e6 &= 67108863, A = Math.imul(Z$, b$), v = Math.imul(Z$, y$), v = v + Math.imul(A$, b$) | 0, k = Math.imul(A$, y$), A = A + Math.imul(z$, h$) | 0, v = v + Math.imul(z$, u) | 0, v = v + Math.imul(j$, h$) | 0, k = k + Math.imul(j$, u) | 0, A = A + Math.imul(t, K$) | 0, v = v + Math.imul(t, P$) | 0, v = v + Math.imul(F, K$) | 0, k = k + Math.imul(F, P$) | 0, A = A + Math.imul(d, k$) | 0, v = v + Math.imul(d, G$) | 0, v = v + Math.imul(o, k$) | 0, k = k + Math.imul(o, G$) | 0, A = A + Math.imul(e, R$) | 0, v = v + Math.imul(e, u$) | 0, v = v + Math.imul(_$2, R$) | 0, k = k + Math.imul(_$2, u$) | 0, A = A + Math.imul(m, I$) | 0, v = v + Math.imul(m, M$) | 0, v = v + Math.imul(r, I$) | 0, k = k + Math.imul(r, M$) | 0;
        var s6 = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (s6 >>> 26) | 0, s6 &= 67108863, A = Math.imul(Z$, h$), v = Math.imul(Z$, u), v = v + Math.imul(A$, h$) | 0, k = Math.imul(A$, u), A = A + Math.imul(z$, K$) | 0, v = v + Math.imul(z$, P$) | 0, v = v + Math.imul(j$, K$) | 0, k = k + Math.imul(j$, P$) | 0, A = A + Math.imul(t, k$) | 0, v = v + Math.imul(t, G$) | 0, v = v + Math.imul(F, k$) | 0, k = k + Math.imul(F, G$) | 0, A = A + Math.imul(d, R$) | 0, v = v + Math.imul(d, u$) | 0, v = v + Math.imul(o, R$) | 0, k = k + Math.imul(o, u$) | 0, A = A + Math.imul(e, I$) | 0, v = v + Math.imul(e, M$) | 0, v = v + Math.imul(_$2, I$) | 0, k = k + Math.imul(_$2, M$) | 0;
        var $q = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + ($q >>> 26) | 0, $q &= 67108863, A = Math.imul(Z$, K$), v = Math.imul(Z$, P$), v = v + Math.imul(A$, K$) | 0, k = Math.imul(A$, P$), A = A + Math.imul(z$, k$) | 0, v = v + Math.imul(z$, G$) | 0, v = v + Math.imul(j$, k$) | 0, k = k + Math.imul(j$, G$) | 0, A = A + Math.imul(t, R$) | 0, v = v + Math.imul(t, u$) | 0, v = v + Math.imul(F, R$) | 0, k = k + Math.imul(F, u$) | 0, A = A + Math.imul(d, I$) | 0, v = v + Math.imul(d, M$) | 0, v = v + Math.imul(o, I$) | 0, k = k + Math.imul(o, M$) | 0;
        var qq = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (qq >>> 26) | 0, qq &= 67108863, A = Math.imul(Z$, k$), v = Math.imul(Z$, G$), v = v + Math.imul(A$, k$) | 0, k = Math.imul(A$, G$), A = A + Math.imul(z$, R$) | 0, v = v + Math.imul(z$, u$) | 0, v = v + Math.imul(j$, R$) | 0, k = k + Math.imul(j$, u$) | 0, A = A + Math.imul(t, I$) | 0, v = v + Math.imul(t, M$) | 0, v = v + Math.imul(F, I$) | 0, k = k + Math.imul(F, M$) | 0;
        var Kq = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (Kq >>> 26) | 0, Kq &= 67108863, A = Math.imul(Z$, R$), v = Math.imul(Z$, u$), v = v + Math.imul(A$, R$) | 0, k = Math.imul(A$, u$), A = A + Math.imul(z$, I$) | 0, v = v + Math.imul(z$, M$) | 0, v = v + Math.imul(j$, I$) | 0, k = k + Math.imul(j$, M$) | 0;
        var _q = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (_q >>> 26) | 0, _q &= 67108863, A = Math.imul(Z$, I$), v = Math.imul(Z$, M$), v = v + Math.imul(A$, I$) | 0, k = Math.imul(A$, M$);
        var Pq = (S + A | 0) + ((v & 8191) << 13) | 0;
        if (S = (k + (v >>> 13) | 0) + (Pq >>> 26) | 0, Pq &= 67108863, G[0] = p6, G[1] = H6, G[2] = v6, G[3] = C6, G[4] = S6, G[5] = i6, G[6] = B6, G[7] = t6, G[8] = U6, G[9] = F6, G[10] = a6, G[11] = Q6, G[12] = e6, G[13] = s6, G[14] = $q, G[15] = qq, G[16] = Kq, G[17] = _q, G[18] = Pq, S !== 0) G[19] = S, Z.length++;
        return Z;
      };
      if (!Math.imul) E = h;
      function I(j, H, Z) {
        Z.negative = H.negative ^ j.negative, Z.length = j.length + H.length;
        var W = 0, w = 0;
        for (var G = 0; G < Z.length - 1; G++) {
          var S = w;
          w = 0;
          var A = W & 67108863, v = Math.min(G, H.length - 1);
          for (var k = Math.max(0, G - j.length + 1); k <= v; k++) {
            var R = G - k, C = j.words[R] | 0, L = H.words[k] | 0, x = C * L, l = x & 67108863;
            S = S + (x / 67108864 | 0) | 0, l = l + A | 0, A = l & 67108863, S = S + (l >>> 26) | 0, w += S >>> 26, S &= 67108863;
          }
          Z.words[G] = A, W = S, S = w;
        }
        if (W !== 0) Z.words[G] = W;
        else Z.length--;
        return Z.strip();
      }
      function D(j, H, Z) {
        var W = new g();
        return W.mulp(j, H, Z);
      }
      O.prototype.mulTo = function(j, H) {
        var Z, W = this.length + j.length;
        if (this.length === 10 && j.length === 10) Z = E(this, j, H);
        else if (W < 63) Z = h(this, j, H);
        else if (W < 1024) Z = I(this, j, H);
        else Z = D(this, j, H);
        return Z;
      };
      function g(j, H) {
        this.x = j, this.y = H;
      }
      g.prototype.makeRBT = function(j) {
        var H = Array(j), Z = O.prototype._countBits(j) - 1;
        for (var W = 0; W < j; W++) H[W] = this.revBin(W, Z, j);
        return H;
      }, g.prototype.revBin = function(j, H, Z) {
        if (j === 0 || j === Z - 1) return j;
        var W = 0;
        for (var w = 0; w < H; w++) W |= (j & 1) << H - w - 1, j >>= 1;
        return W;
      }, g.prototype.permute = function(j, H, Z, W, w, G) {
        for (var S = 0; S < G; S++) W[S] = H[j[S]], w[S] = Z[j[S]];
      }, g.prototype.transform = function(j, H, Z, W, w, G) {
        this.permute(G, j, H, Z, W, w);
        for (var S = 1; S < w; S <<= 1) {
          var A = S << 1, v = Math.cos(2 * Math.PI / A), k = Math.sin(2 * Math.PI / A);
          for (var R = 0; R < w; R += A) {
            var C = v, L = k;
            for (var x = 0; x < S; x++) {
              var l = Z[R + x], a = W[R + x], f$ = Z[R + x + S], $$ = W[R + x + S], B = C * f$ - L * $$;
              if ($$ = C * $$ + L * f$, f$ = B, Z[R + x] = l + f$, W[R + x] = a + $$, Z[R + x + S] = l - f$, W[R + x + S] = a - $$, x !== A) B = v * C - k * L, L = v * L + k * C, C = B;
            }
          }
        }
      }, g.prototype.guessLen13b = function(j, H) {
        var Z = Math.max(H, j) | 1, W = Z & 1, w = 0;
        for (Z = Z / 2 | 0; Z; Z = Z >>> 1) w++;
        return 1 << w + 1 + W;
      }, g.prototype.conjugate = function(j, H, Z) {
        if (Z <= 1) return;
        for (var W = 0; W < Z / 2; W++) {
          var w = j[W];
          j[W] = j[Z - W - 1], j[Z - W - 1] = w, w = H[W], H[W] = -H[Z - W - 1], H[Z - W - 1] = -w;
        }
      }, g.prototype.normalize13b = function(j, H) {
        var Z = 0;
        for (var W = 0; W < H / 2; W++) {
          var w = Math.round(j[2 * W + 1] / H) * 8192 + Math.round(j[2 * W] / H) + Z;
          if (j[W] = w & 67108863, w < 67108864) Z = 0;
          else Z = w / 67108864 | 0;
        }
        return j;
      }, g.prototype.convert13b = function(j, H, Z, W) {
        var w = 0;
        for (var G = 0; G < H; G++) w = w + (j[G] | 0), Z[2 * G] = w & 8191, w = w >>> 13, Z[2 * G + 1] = w & 8191, w = w >>> 13;
        for (G = 2 * H; G < W; ++G) Z[G] = 0;
        _(w === 0), _((w & -8192) === 0);
      }, g.prototype.stub = function(j) {
        var H = Array(j);
        for (var Z = 0; Z < j; Z++) H[Z] = 0;
        return H;
      }, g.prototype.mulp = function(j, H, Z) {
        var W = 2 * this.guessLen13b(j.length, H.length), w = this.makeRBT(W), G = this.stub(W), S = Array(W), A = Array(W), v = Array(W), k = Array(W), R = Array(W), C = Array(W), L = Z.words;
        L.length = W, this.convert13b(j.words, j.length, S, W), this.convert13b(H.words, H.length, k, W), this.transform(S, G, A, v, W, w), this.transform(k, G, R, C, W, w);
        for (var x = 0; x < W; x++) {
          var l = A[x] * R[x] - v[x] * C[x];
          v[x] = A[x] * C[x] + v[x] * R[x], A[x] = l;
        }
        return this.conjugate(A, v, W), this.transform(A, v, L, G, W, w), this.conjugate(L, G, W), this.normalize13b(L, W), Z.negative = j.negative ^ H.negative, Z.length = j.length + H.length, Z.strip();
      }, O.prototype.mul = function(j) {
        var H = new O(null);
        return H.words = Array(this.length + j.length), this.mulTo(j, H);
      }, O.prototype.mulf = function(j) {
        var H = new O(null);
        return H.words = Array(this.length + j.length), D(this, j, H);
      }, O.prototype.imul = function(j) {
        return this.clone().mulTo(j, this);
      }, O.prototype.imuln = function(j) {
        _(typeof j === "number"), _(j < 67108864);
        var H = 0;
        for (var Z = 0; Z < this.length; Z++) {
          var W = (this.words[Z] | 0) * j, w = (W & 67108863) + (H & 67108863);
          H >>= 26, H += W / 67108864 | 0, H += w >>> 26, this.words[Z] = w & 67108863;
        }
        if (H !== 0) this.words[Z] = H, this.length++;
        return this.length = j === 0 ? 1 : this.length, this;
      }, O.prototype.muln = function(j) {
        return this.clone().imuln(j);
      }, O.prototype.sqr = function() {
        return this.mul(this);
      }, O.prototype.isqr = function() {
        return this.imul(this.clone());
      }, O.prototype.pow = function(j) {
        var H = N(j);
        if (H.length === 0) return new O(1);
        var Z = this;
        for (var W = 0; W < H.length; W++, Z = Z.sqr()) if (H[W] !== 0) break;
        if (++W < H.length) for (var w = Z.sqr(); W < H.length; W++, w = w.sqr()) {
          if (H[W] === 0) continue;
          Z = Z.mul(w);
        }
        return Z;
      }, O.prototype.iushln = function(j) {
        _(typeof j === "number" && j >= 0);
        var H = j % 26, Z = (j - H) / 26, W = 67108863 >>> 26 - H << 26 - H, w;
        if (H !== 0) {
          var G = 0;
          for (w = 0; w < this.length; w++) {
            var S = this.words[w] & W, A = (this.words[w] | 0) - S << H;
            this.words[w] = A | G, G = S >>> 26 - H;
          }
          if (G) this.words[w] = G, this.length++;
        }
        if (Z !== 0) {
          for (w = this.length - 1; w >= 0; w--) this.words[w + Z] = this.words[w];
          for (w = 0; w < Z; w++) this.words[w] = 0;
          this.length += Z;
        }
        return this.strip();
      }, O.prototype.ishln = function(j) {
        return _(this.negative === 0), this.iushln(j);
      }, O.prototype.iushrn = function(j, H, Z) {
        _(typeof j === "number" && j >= 0);
        var W;
        if (H) W = (H - H % 26) / 26;
        else W = 0;
        var w = j % 26, G = Math.min((j - w) / 26, this.length), S = 67108863 ^ 67108863 >>> w << w, A = Z;
        if (W -= G, W = Math.max(0, W), A) {
          for (var v = 0; v < G; v++) A.words[v] = this.words[v];
          A.length = G;
        }
        if (G === 0) ;
        else if (this.length > G) {
          this.length -= G;
          for (v = 0; v < this.length; v++) this.words[v] = this.words[v + G];
        } else this.words[0] = 0, this.length = 1;
        var k = 0;
        for (v = this.length - 1; v >= 0 && (k !== 0 || v >= W); v--) {
          var R = this.words[v] | 0;
          this.words[v] = k << 26 - w | R >>> w, k = R & S;
        }
        if (A && k !== 0) A.words[A.length++] = k;
        if (this.length === 0) this.words[0] = 0, this.length = 1;
        return this.strip();
      }, O.prototype.ishrn = function(j, H, Z) {
        return _(this.negative === 0), this.iushrn(j, H, Z);
      }, O.prototype.shln = function(j) {
        return this.clone().ishln(j);
      }, O.prototype.ushln = function(j) {
        return this.clone().iushln(j);
      }, O.prototype.shrn = function(j) {
        return this.clone().ishrn(j);
      }, O.prototype.ushrn = function(j) {
        return this.clone().iushrn(j);
      }, O.prototype.testn = function(j) {
        _(typeof j === "number" && j >= 0);
        var H = j % 26, Z = (j - H) / 26, W = 1 << H;
        if (this.length <= Z) return false;
        var w = this.words[Z];
        return !!(w & W);
      }, O.prototype.imaskn = function(j) {
        _(typeof j === "number" && j >= 0);
        var H = j % 26, Z = (j - H) / 26;
        if (_(this.negative === 0, "imaskn works only with positive numbers"), this.length <= Z) return this;
        if (H !== 0) Z++;
        if (this.length = Math.min(Z, this.length), H !== 0) {
          var W = 67108863 ^ 67108863 >>> H << H;
          this.words[this.length - 1] &= W;
        }
        return this.strip();
      }, O.prototype.maskn = function(j) {
        return this.clone().imaskn(j);
      }, O.prototype.iaddn = function(j) {
        if (_(typeof j === "number"), _(j < 67108864), j < 0) return this.isubn(-j);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) < j) return this.words[0] = j - (this.words[0] | 0), this.negative = 0, this;
          return this.negative = 0, this.isubn(j), this.negative = 1, this;
        }
        return this._iaddn(j);
      }, O.prototype._iaddn = function(j) {
        this.words[0] += j;
        for (var H = 0; H < this.length && this.words[H] >= 67108864; H++) if (this.words[H] -= 67108864, H === this.length - 1) this.words[H + 1] = 1;
        else this.words[H + 1]++;
        return this.length = Math.max(this.length, H + 1), this;
      }, O.prototype.isubn = function(j) {
        if (_(typeof j === "number"), _(j < 67108864), j < 0) return this.iaddn(-j);
        if (this.negative !== 0) return this.negative = 0, this.iaddn(j), this.negative = 1, this;
        if (this.words[0] -= j, this.length === 1 && this.words[0] < 0) this.words[0] = -this.words[0], this.negative = 1;
        else for (var H = 0; H < this.length && this.words[H] < 0; H++) this.words[H] += 67108864, this.words[H + 1] -= 1;
        return this.strip();
      }, O.prototype.addn = function(j) {
        return this.clone().iaddn(j);
      }, O.prototype.subn = function(j) {
        return this.clone().isubn(j);
      }, O.prototype.iabs = function() {
        return this.negative = 0, this;
      }, O.prototype.abs = function() {
        return this.clone().iabs();
      }, O.prototype._ishlnsubmul = function(j, H, Z) {
        var W = j.length + Z, w;
        this._expand(W);
        var G, S = 0;
        for (w = 0; w < j.length; w++) {
          G = (this.words[w + Z] | 0) + S;
          var A = (j.words[w] | 0) * H;
          G -= A & 67108863, S = (G >> 26) - (A / 67108864 | 0), this.words[w + Z] = G & 67108863;
        }
        for (; w < this.length - Z; w++) G = (this.words[w + Z] | 0) + S, S = G >> 26, this.words[w + Z] = G & 67108863;
        if (S === 0) return this.strip();
        _(S === -1), S = 0;
        for (w = 0; w < this.length; w++) G = -(this.words[w] | 0) + S, S = G >> 26, this.words[w] = G & 67108863;
        return this.negative = 1, this.strip();
      }, O.prototype._wordDiv = function(j, H) {
        var Z = this.length - j.length, W = this.clone(), w = j, G = w.words[w.length - 1] | 0, S = this._countBits(G);
        if (Z = 26 - S, Z !== 0) w = w.ushln(Z), W.iushln(Z), G = w.words[w.length - 1] | 0;
        var A = W.length - w.length, v;
        if (H !== "mod") {
          v = new O(null), v.length = A + 1, v.words = Array(v.length);
          for (var k = 0; k < v.length; k++) v.words[k] = 0;
        }
        var R = W.clone()._ishlnsubmul(w, 1, A);
        if (R.negative === 0) {
          if (W = R, v) v.words[A] = 1;
        }
        for (var C = A - 1; C >= 0; C--) {
          var L = (W.words[w.length + C] | 0) * 67108864 + (W.words[w.length + C - 1] | 0);
          L = Math.min(L / G | 0, 67108863), W._ishlnsubmul(w, L, C);
          while (W.negative !== 0) if (L--, W.negative = 0, W._ishlnsubmul(w, 1, C), !W.isZero()) W.negative ^= 1;
          if (v) v.words[C] = L;
        }
        if (v) v.strip();
        if (W.strip(), H !== "div" && Z !== 0) W.iushrn(Z);
        return { div: v || null, mod: W };
      }, O.prototype.divmod = function(j, H, Z) {
        if (_(!j.isZero()), this.isZero()) return { div: new O(0), mod: new O(0) };
        var W, w, G;
        if (this.negative !== 0 && j.negative === 0) {
          if (G = this.neg().divmod(j, H), H !== "mod") W = G.div.neg();
          if (H !== "div") {
            if (w = G.mod.neg(), Z && w.negative !== 0) w.iadd(j);
          }
          return { div: W, mod: w };
        }
        if (this.negative === 0 && j.negative !== 0) {
          if (G = this.divmod(j.neg(), H), H !== "mod") W = G.div.neg();
          return { div: W, mod: G.mod };
        }
        if ((this.negative & j.negative) !== 0) {
          if (G = this.neg().divmod(j.neg(), H), H !== "div") {
            if (w = G.mod.neg(), Z && w.negative !== 0) w.isub(j);
          }
          return { div: G.div, mod: w };
        }
        if (j.length > this.length || this.cmp(j) < 0) return { div: new O(0), mod: this };
        if (j.length === 1) {
          if (H === "div") return { div: this.divn(j.words[0]), mod: null };
          if (H === "mod") return { div: null, mod: new O(this.modn(j.words[0])) };
          return { div: this.divn(j.words[0]), mod: new O(this.modn(j.words[0])) };
        }
        return this._wordDiv(j, H);
      }, O.prototype.div = function(j) {
        return this.divmod(j, "div", false).div;
      }, O.prototype.mod = function(j) {
        return this.divmod(j, "mod", false).mod;
      }, O.prototype.umod = function(j) {
        return this.divmod(j, "mod", true).mod;
      }, O.prototype.divRound = function(j) {
        var H = this.divmod(j);
        if (H.mod.isZero()) return H.div;
        var Z = H.div.negative !== 0 ? H.mod.isub(j) : H.mod, W = j.ushrn(1), w = j.andln(1), G = Z.cmp(W);
        if (G < 0 || w === 1 && G === 0) return H.div;
        return H.div.negative !== 0 ? H.div.isubn(1) : H.div.iaddn(1);
      }, O.prototype.modn = function(j) {
        _(j <= 67108863);
        var H = 67108864 % j, Z = 0;
        for (var W = this.length - 1; W >= 0; W--) Z = (H * Z + (this.words[W] | 0)) % j;
        return Z;
      }, O.prototype.idivn = function(j) {
        _(j <= 67108863);
        var H = 0;
        for (var Z = this.length - 1; Z >= 0; Z--) {
          var W = (this.words[Z] | 0) + H * 67108864;
          this.words[Z] = W / j | 0, H = W % j;
        }
        return this.strip();
      }, O.prototype.divn = function(j) {
        return this.clone().idivn(j);
      }, O.prototype.egcd = function(j) {
        _(j.negative === 0), _(!j.isZero());
        var H = this, Z = j.clone();
        if (H.negative !== 0) H = H.umod(j);
        else H = H.clone();
        var W = new O(1), w = new O(0), G = new O(0), S = new O(1), A = 0;
        while (H.isEven() && Z.isEven()) H.iushrn(1), Z.iushrn(1), ++A;
        var v = Z.clone(), k = H.clone();
        while (!H.isZero()) {
          for (var R = 0, C = 1; (H.words[0] & C) === 0 && R < 26; ++R, C <<= 1) ;
          if (R > 0) {
            H.iushrn(R);
            while (R-- > 0) {
              if (W.isOdd() || w.isOdd()) W.iadd(v), w.isub(k);
              W.iushrn(1), w.iushrn(1);
            }
          }
          for (var L = 0, x = 1; (Z.words[0] & x) === 0 && L < 26; ++L, x <<= 1) ;
          if (L > 0) {
            Z.iushrn(L);
            while (L-- > 0) {
              if (G.isOdd() || S.isOdd()) G.iadd(v), S.isub(k);
              G.iushrn(1), S.iushrn(1);
            }
          }
          if (H.cmp(Z) >= 0) H.isub(Z), W.isub(G), w.isub(S);
          else Z.isub(H), G.isub(W), S.isub(w);
        }
        return { a: G, b: S, gcd: Z.iushln(A) };
      }, O.prototype._invmp = function(j) {
        _(j.negative === 0), _(!j.isZero());
        var H = this, Z = j.clone();
        if (H.negative !== 0) H = H.umod(j);
        else H = H.clone();
        var W = new O(1), w = new O(0), G = Z.clone();
        while (H.cmpn(1) > 0 && Z.cmpn(1) > 0) {
          for (var S = 0, A = 1; (H.words[0] & A) === 0 && S < 26; ++S, A <<= 1) ;
          if (S > 0) {
            H.iushrn(S);
            while (S-- > 0) {
              if (W.isOdd()) W.iadd(G);
              W.iushrn(1);
            }
          }
          for (var v = 0, k = 1; (Z.words[0] & k) === 0 && v < 26; ++v, k <<= 1) ;
          if (v > 0) {
            Z.iushrn(v);
            while (v-- > 0) {
              if (w.isOdd()) w.iadd(G);
              w.iushrn(1);
            }
          }
          if (H.cmp(Z) >= 0) H.isub(Z), W.isub(w);
          else Z.isub(H), w.isub(W);
        }
        var R;
        if (H.cmpn(1) === 0) R = W;
        else R = w;
        if (R.cmpn(0) < 0) R.iadd(j);
        return R;
      }, O.prototype.gcd = function(j) {
        if (this.isZero()) return j.abs();
        if (j.isZero()) return this.abs();
        var H = this.clone(), Z = j.clone();
        H.negative = 0, Z.negative = 0;
        for (var W = 0; H.isEven() && Z.isEven(); W++) H.iushrn(1), Z.iushrn(1);
        do {
          while (H.isEven()) H.iushrn(1);
          while (Z.isEven()) Z.iushrn(1);
          var w = H.cmp(Z);
          if (w < 0) {
            var G = H;
            H = Z, Z = G;
          } else if (w === 0 || Z.cmpn(1) === 0) break;
          H.isub(Z);
        } while (true);
        return Z.iushln(W);
      }, O.prototype.invm = function(j) {
        return this.egcd(j).a.umod(j);
      }, O.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, O.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, O.prototype.andln = function(j) {
        return this.words[0] & j;
      }, O.prototype.bincn = function(j) {
        _(typeof j === "number");
        var H = j % 26, Z = (j - H) / 26, W = 1 << H;
        if (this.length <= Z) return this._expand(Z + 1), this.words[Z] |= W, this;
        var w = W;
        for (var G = Z; w !== 0 && G < this.length; G++) {
          var S = this.words[G] | 0;
          S += w, w = S >>> 26, S &= 67108863, this.words[G] = S;
        }
        if (w !== 0) this.words[G] = w, this.length++;
        return this;
      }, O.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, O.prototype.cmpn = function(j) {
        var H = j < 0;
        if (this.negative !== 0 && !H) return -1;
        if (this.negative === 0 && H) return 1;
        this.strip();
        var Z;
        if (this.length > 1) Z = 1;
        else {
          if (H) j = -j;
          _(j <= 67108863, "Number is too big");
          var W = this.words[0] | 0;
          Z = W === j ? 0 : W < j ? -1 : 1;
        }
        if (this.negative !== 0) return -Z | 0;
        return Z;
      }, O.prototype.cmp = function(j) {
        if (this.negative !== 0 && j.negative === 0) return -1;
        if (this.negative === 0 && j.negative !== 0) return 1;
        var H = this.ucmp(j);
        if (this.negative !== 0) return -H | 0;
        return H;
      }, O.prototype.ucmp = function(j) {
        if (this.length > j.length) return 1;
        if (this.length < j.length) return -1;
        var H = 0;
        for (var Z = this.length - 1; Z >= 0; Z--) {
          var W = this.words[Z] | 0, w = j.words[Z] | 0;
          if (W === w) continue;
          if (W < w) H = -1;
          else if (W > w) H = 1;
          break;
        }
        return H;
      }, O.prototype.gtn = function(j) {
        return this.cmpn(j) === 1;
      }, O.prototype.gt = function(j) {
        return this.cmp(j) === 1;
      }, O.prototype.gten = function(j) {
        return this.cmpn(j) >= 0;
      }, O.prototype.gte = function(j) {
        return this.cmp(j) >= 0;
      }, O.prototype.ltn = function(j) {
        return this.cmpn(j) === -1;
      }, O.prototype.lt = function(j) {
        return this.cmp(j) === -1;
      }, O.prototype.lten = function(j) {
        return this.cmpn(j) <= 0;
      }, O.prototype.lte = function(j) {
        return this.cmp(j) <= 0;
      }, O.prototype.eqn = function(j) {
        return this.cmpn(j) === 0;
      }, O.prototype.eq = function(j) {
        return this.cmp(j) === 0;
      }, O.red = function(j) {
        return new c(j);
      }, O.prototype.toRed = function(j) {
        return _(!this.red, "Already a number in reduction context"), _(this.negative === 0, "red works only with positives"), j.convertTo(this)._forceRed(j);
      }, O.prototype.fromRed = function() {
        return _(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, O.prototype._forceRed = function(j) {
        return this.red = j, this;
      }, O.prototype.forceRed = function(j) {
        return _(!this.red, "Already a number in reduction context"), this._forceRed(j);
      }, O.prototype.redAdd = function(j) {
        return _(this.red, "redAdd works only with red numbers"), this.red.add(this, j);
      }, O.prototype.redIAdd = function(j) {
        return _(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, j);
      }, O.prototype.redSub = function(j) {
        return _(this.red, "redSub works only with red numbers"), this.red.sub(this, j);
      }, O.prototype.redISub = function(j) {
        return _(this.red, "redISub works only with red numbers"), this.red.isub(this, j);
      }, O.prototype.redShl = function(j) {
        return _(this.red, "redShl works only with red numbers"), this.red.shl(this, j);
      }, O.prototype.redMul = function(j) {
        return _(this.red, "redMul works only with red numbers"), this.red._verify2(this, j), this.red.mul(this, j);
      }, O.prototype.redIMul = function(j) {
        return _(this.red, "redMul works only with red numbers"), this.red._verify2(this, j), this.red.imul(this, j);
      }, O.prototype.redSqr = function() {
        return _(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, O.prototype.redISqr = function() {
        return _(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, O.prototype.redSqrt = function() {
        return _(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, O.prototype.redInvm = function() {
        return _(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, O.prototype.redNeg = function() {
        return _(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, O.prototype.redPow = function(j) {
        return _(this.red && !j.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, j);
      };
      var b = { k256: null, p224: null, p192: null, p25519: null };
      function y(j, H) {
        this.name = j, this.p = new O(H, 16), this.n = this.p.bitLength(), this.k = new O(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      y.prototype._tmp = function() {
        var j = new O(null);
        return j.words = Array(Math.ceil(this.n / 13)), j;
      }, y.prototype.ireduce = function(j) {
        var H = j, Z;
        do
          this.split(H, this.tmp), H = this.imulK(H), H = H.iadd(this.tmp), Z = H.bitLength();
        while (Z > this.n);
        var W = Z < this.n ? -1 : H.ucmp(this.p);
        if (W === 0) H.words[0] = 0, H.length = 1;
        else if (W > 0) H.isub(this.p);
        else if (H.strip !== void 0) H.strip();
        else H._strip();
        return H;
      }, y.prototype.split = function(j, H) {
        j.iushrn(this.n, 0, H);
      }, y.prototype.imulK = function(j) {
        return j.imul(this.k);
      };
      function p() {
        y.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
      }
      Y(p, y), p.prototype.split = function(j, H) {
        var Z = 4194303, W = Math.min(j.length, 9);
        for (var w = 0; w < W; w++) H.words[w] = j.words[w];
        if (H.length = W, j.length <= 9) {
          j.words[0] = 0, j.length = 1;
          return;
        }
        var G = j.words[9];
        H.words[H.length++] = G & Z;
        for (w = 10; w < j.length; w++) {
          var S = j.words[w] | 0;
          j.words[w - 10] = (S & Z) << 4 | G >>> 22, G = S;
        }
        if (G >>>= 22, j.words[w - 10] = G, G === 0 && j.length > 10) j.length -= 10;
        else j.length -= 9;
      }, p.prototype.imulK = function(j) {
        j.words[j.length] = 0, j.words[j.length + 1] = 0, j.length += 2;
        var H = 0;
        for (var Z = 0; Z < j.length; Z++) {
          var W = j.words[Z] | 0;
          H += W * 977, j.words[Z] = H & 67108863, H = W * 64 + (H / 67108864 | 0);
        }
        if (j.words[j.length - 1] === 0) {
          if (j.length--, j.words[j.length - 1] === 0) j.length--;
        }
        return j;
      };
      function n() {
        y.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
      }
      Y(n, y);
      function s() {
        y.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
      }
      Y(s, y);
      function q$() {
        y.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
      }
      Y(q$, y), q$.prototype.imulK = function(j) {
        var H = 0;
        for (var Z = 0; Z < j.length; Z++) {
          var W = (j.words[Z] | 0) * 19 + H, w = W & 67108863;
          W >>>= 26, j.words[Z] = w, H = W;
        }
        if (H !== 0) j.words[j.length++] = H;
        return j;
      }, O._prime = function(j) {
        if (b[j]) return b[j];
        var H;
        if (j === "k256") H = new p();
        else if (j === "p224") H = new n();
        else if (j === "p192") H = new s();
        else if (j === "p25519") H = new q$();
        else throw Error("Unknown prime " + j);
        return b[j] = H, H;
      };
      function c(j) {
        if (typeof j === "string") {
          var H = O._prime(j);
          this.m = H.p, this.prime = H;
        } else _(j.gtn(1), "modulus must be greater than 1"), this.m = j, this.prime = null;
      }
      c.prototype._verify1 = function(j) {
        _(j.negative === 0, "red works only with positives"), _(j.red, "red works only with red numbers");
      }, c.prototype._verify2 = function(j, H) {
        _((j.negative | H.negative) === 0, "red works only with positives"), _(j.red && j.red === H.red, "red works only with red numbers");
      }, c.prototype.imod = function(j) {
        if (this.prime) return this.prime.ireduce(j)._forceRed(this);
        return j.umod(this.m)._forceRed(this);
      }, c.prototype.neg = function(j) {
        if (j.isZero()) return j.clone();
        return this.m.sub(j)._forceRed(this);
      }, c.prototype.add = function(j, H) {
        this._verify2(j, H);
        var Z = j.add(H);
        if (Z.cmp(this.m) >= 0) Z.isub(this.m);
        return Z._forceRed(this);
      }, c.prototype.iadd = function(j, H) {
        this._verify2(j, H);
        var Z = j.iadd(H);
        if (Z.cmp(this.m) >= 0) Z.isub(this.m);
        return Z;
      }, c.prototype.sub = function(j, H) {
        this._verify2(j, H);
        var Z = j.sub(H);
        if (Z.cmpn(0) < 0) Z.iadd(this.m);
        return Z._forceRed(this);
      }, c.prototype.isub = function(j, H) {
        this._verify2(j, H);
        var Z = j.isub(H);
        if (Z.cmpn(0) < 0) Z.iadd(this.m);
        return Z;
      }, c.prototype.shl = function(j, H) {
        return this._verify1(j), this.imod(j.ushln(H));
      }, c.prototype.imul = function(j, H) {
        return this._verify2(j, H), this.imod(j.imul(H));
      }, c.prototype.mul = function(j, H) {
        return this._verify2(j, H), this.imod(j.mul(H));
      }, c.prototype.isqr = function(j) {
        return this.imul(j, j.clone());
      }, c.prototype.sqr = function(j) {
        return this.mul(j, j);
      }, c.prototype.sqrt = function(j) {
        if (j.isZero()) return j.clone();
        var H = this.m.andln(3);
        if (_(H % 2 === 1), H === 3) {
          var Z = this.m.add(new O(1)).iushrn(2);
          return this.pow(j, Z);
        }
        var W = this.m.subn(1), w = 0;
        while (!W.isZero() && W.andln(1) === 0) w++, W.iushrn(1);
        _(!W.isZero());
        var G = new O(1).toRed(this), S = G.redNeg(), A = this.m.subn(1).iushrn(1), v = this.m.bitLength();
        v = new O(2 * v * v).toRed(this);
        while (this.pow(v, A).cmp(S) !== 0) v.redIAdd(S);
        var k = this.pow(v, W), R = this.pow(j, W.addn(1).iushrn(1)), C = this.pow(j, W), L = w;
        while (C.cmp(G) !== 0) {
          var x = C;
          for (var l = 0; x.cmp(G) !== 0; l++) x = x.redSqr();
          _(l < L);
          var a = this.pow(k, new O(1).iushln(L - l - 1));
          R = R.redMul(a), k = a.redSqr(), C = C.redMul(k), L = l;
        }
        return R;
      }, c.prototype.invm = function(j) {
        var H = j._invmp(this.m);
        if (H.negative !== 0) return H.negative = 0, this.imod(H).redNeg();
        else return this.imod(H);
      }, c.prototype.pow = function(j, H) {
        if (H.isZero()) return new O(1).toRed(this);
        if (H.cmpn(1) === 0) return j.clone();
        var Z = 4, W = Array(1 << Z);
        W[0] = new O(1).toRed(this), W[1] = j;
        for (var w = 2; w < W.length; w++) W[w] = this.mul(W[w - 1], j);
        var G = W[0], S = 0, A = 0, v = H.bitLength() % 26;
        if (v === 0) v = 26;
        for (w = H.length - 1; w >= 0; w--) {
          var k = H.words[w];
          for (var R = v - 1; R >= 0; R--) {
            var C = k >> R & 1;
            if (G !== W[0]) G = this.sqr(G);
            if (C === 0 && S === 0) {
              A = 0;
              continue;
            }
            if (S <<= 1, S |= C, A++, A !== Z && (w !== 0 || R !== 0)) continue;
            G = this.mul(G, W[S]), A = 0, S = 0;
          }
          v = 26;
        }
        return G;
      }, c.prototype.convertTo = function(j) {
        var H = j.umod(this.m);
        return H === j ? H.clone() : H;
      }, c.prototype.convertFrom = function(j) {
        var H = j.clone();
        return H.red = null, H;
      }, O.mont = function(j) {
        return new U(j);
      };
      function U(j) {
        if (c.call(this, j), this.shift = this.m.bitLength(), this.shift % 26 !== 0) this.shift += 26 - this.shift % 26;
        this.r = new O(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      Y(U, c), U.prototype.convertTo = function(j) {
        return this.imod(j.ushln(this.shift));
      }, U.prototype.convertFrom = function(j) {
        var H = this.imod(j.mul(this.rinv));
        return H.red = null, H;
      }, U.prototype.imul = function(j, H) {
        if (j.isZero() || H.isZero()) return j.words[0] = 0, j.length = 1, j;
        var Z = j.imul(H), W = Z.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), w = Z.isub(W).iushrn(this.shift), G = w;
        if (w.cmp(this.m) >= 0) G = w.isub(this.m);
        else if (w.cmpn(0) < 0) G = w.iadd(this.m);
        return G._forceRed(this);
      }, U.prototype.mul = function(j, H) {
        if (j.isZero() || H.isZero()) return new O(0)._forceRed(this);
        var Z = j.mul(H), W = Z.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), w = Z.isub(W).iushrn(this.shift), G = w;
        if (w.cmp(this.m) >= 0) G = w.isub(this.m);
        else if (w.cmpn(0) < 0) G = w.iadd(this.m);
        return G._forceRed(this);
      }, U.prototype.invm = function(j) {
        var H = this.imod(j._invmp(this.m).mul(this.r2));
        return H._forceRed(this);
      };
    })(typeof q > "u" || q, $18);
  }), Wo = r$(($18) => {
    var q = U7(), K = v8(), P = $18;
    P.define = function(Y, O) {
      return new _(Y, O);
    };
    function _(Y, O) {
      this.name = Y, this.body = O, this.decoders = {}, this.encoders = {};
    }
    _.prototype._createNamed = function(Y) {
      var O;
      try {
        O = (() => {
          throw new Error("Cannot require module vm");
        })().runInThisContext("(function " + this.name + `(entity) {
  this._initNamed(entity);
})`);
      } catch (z) {
        O = function(J) {
          this._initNamed(J);
        };
      }
      return K(O, Y), O.prototype._initNamed = function(z) {
        Y.call(this, z);
      }, new O(this);
    }, _.prototype._getDecoder = function(Y) {
      if (Y = Y || "der", !this.decoders.hasOwnProperty(Y)) this.decoders[Y] = this._createNamed(q.decoders[Y]);
      return this.decoders[Y];
    }, _.prototype.decode = function(Y, O, z) {
      return this._getDecoder(O).decode(Y, z);
    }, _.prototype._getEncoder = function(Y) {
      if (Y = Y || "der", !this.encoders.hasOwnProperty(Y)) this.encoders[Y] = this._createNamed(q.encoders[Y]);
      return this.encoders[Y];
    }, _.prototype.encode = function(Y, O, z) {
      return this._getEncoder(O).encode(Y, z);
    };
  }), Ho = r$(($18) => {
    var q = v8();
    function K(_) {
      this._reporterState = { obj: null, path: [], options: _ || {}, errors: [] };
    }
    $18.Reporter = K, K.prototype.isError = function(_) {
      return _ instanceof P;
    }, K.prototype.save = function() {
      var _ = this._reporterState;
      return { obj: _.obj, pathLen: _.path.length };
    }, K.prototype.restore = function(_) {
      var Y = this._reporterState;
      Y.obj = _.obj, Y.path = Y.path.slice(0, _.pathLen);
    }, K.prototype.enterKey = function(_) {
      return this._reporterState.path.push(_);
    }, K.prototype.exitKey = function(_) {
      var Y = this._reporterState;
      Y.path = Y.path.slice(0, _ - 1);
    }, K.prototype.leaveKey = function(_, Y, O) {
      var z = this._reporterState;
      if (this.exitKey(_), z.obj !== null) z.obj[Y] = O;
    }, K.prototype.path = function() {
      return this._reporterState.path.join("/");
    }, K.prototype.enterObject = function() {
      var _ = this._reporterState, Y = _.obj;
      return _.obj = {}, Y;
    }, K.prototype.leaveObject = function(_) {
      var Y = this._reporterState, O = Y.obj;
      return Y.obj = _, O;
    }, K.prototype.error = function(_) {
      var Y, O = this._reporterState, z = _ instanceof P;
      if (z) Y = _;
      else Y = new P(O.path.map(function(J) {
        return "[" + JSON.stringify(J) + "]";
      }).join(""), _.message || _, _.stack);
      if (!O.options.partial) throw Y;
      if (!z) O.errors.push(Y);
      return Y;
    }, K.prototype.wrapResult = function(_) {
      var Y = this._reporterState;
      if (!Y.options.partial) return _;
      return { result: this.isError(_) ? null : _, errors: Y.errors };
    };
    function P(_, Y) {
      this.path = _, this.rethrow(Y);
    }
    q(P, Error), P.prototype.rethrow = function(_) {
      if (this.message = _ + " at: " + (this.path || "(shallow)"), Error.captureStackTrace) Error.captureStackTrace(this, P);
      if (!this.stack) try {
        throw Error(this.message);
      } catch (Y) {
        this.stack = Y.stack;
      }
      return this;
    };
  }), eS = r$(($18) => {
    var q = v8(), K = B7().Reporter, P = (wq(), J6(Tq)).Buffer;
    function _(O, z) {
      if (K.call(this, z), !P.isBuffer(O)) {
        this.error("Input not Buffer");
        return;
      }
      this.base = O, this.offset = 0, this.length = O.length;
    }
    q(_, K), $18.DecoderBuffer = _, _.prototype.save = function() {
      return { offset: this.offset, reporter: K.prototype.save.call(this) };
    }, _.prototype.restore = function(O) {
      var z = new _(this.base);
      return z.offset = O.offset, z.length = this.offset, this.offset = O.offset, K.prototype.restore.call(this, O.reporter), z;
    }, _.prototype.isEmpty = function() {
      return this.offset === this.length;
    }, _.prototype.readUInt8 = function(O) {
      if (this.offset + 1 <= this.length) return this.base.readUInt8(this.offset++, true);
      else return this.error(O || "DecoderBuffer overrun");
    }, _.prototype.skip = function(O, z) {
      if (!(this.offset + O <= this.length)) return this.error(z || "DecoderBuffer overrun");
      var J = new _(this.base);
      return J._reporterState = this._reporterState, J.offset = this.offset, J.length = this.offset + O, this.offset += O, J;
    }, _.prototype.raw = function(O) {
      return this.base.slice(O ? O.offset : this.offset, this.length);
    };
    function Y(O, z) {
      if (Array.isArray(O)) this.length = 0, this.value = O.map(function(J) {
        if (!(J instanceof Y)) J = new Y(J, z);
        return this.length += J.length, J;
      }, this);
      else if (typeof O === "number") {
        if (!(0 <= O && O <= 255)) return z.error("non-byte EncoderBuffer value");
        this.value = O, this.length = 1;
      } else if (typeof O === "string") this.value = O, this.length = P.byteLength(O);
      else if (P.isBuffer(O)) this.value = O, this.length = O.length;
      else return z.error("Unsupported type: " + typeof O);
    }
    $18.EncoderBuffer = Y, Y.prototype.join = function(O, z) {
      if (!O) O = new P(this.length);
      if (!z) z = 0;
      if (this.length === 0) return O;
      if (Array.isArray(this.value)) this.value.forEach(function(J) {
        J.join(O, z), z += J.length;
      });
      else {
        if (typeof this.value === "number") O[z] = this.value;
        else if (typeof this.value === "string") O.write(this.value, z);
        else if (P.isBuffer(this.value)) this.value.copy(O, z);
        z += this.length;
      }
      return O;
    };
  }), Jo = r$(($18, q) => {
    var K = B7().Reporter, P = B7().EncoderBuffer, _ = B7().DecoderBuffer, Y = $_(), O = ["seq", "seqof", "set", "setof", "objid", "bool", "gentime", "utctime", "null_", "enum", "int", "objDesc", "bitstr", "bmpstr", "charstr", "genstr", "graphstr", "ia5str", "iso646str", "numstr", "octstr", "printstr", "t61str", "unistr", "utf8str", "videostr"], z = ["key", "obj", "use", "optional", "explicit", "implicit", "def", "choice", "any", "contains"].concat(O), J = ["_peekTag", "_decodeTag", "_use", "_decodeStr", "_decodeObjid", "_decodeTime", "_decodeNull", "_decodeInt", "_decodeBool", "_decodeList", "_encodeComposite", "_encodeStr", "_encodeObjid", "_encodeTime", "_encodeNull", "_encodeInt", "_encodeBool"];
    function T(f, V) {
      var M = {};
      if (this._baseState = M, M.enc = f, M.parent = V || null, M.children = null, M.tag = null, M.args = null, M.reverseArgs = null, M.choice = null, M.optional = false, M.any = false, M.obj = false, M.use = null, M.useDecoder = null, M.key = null, M.default = null, M.explicit = null, M.implicit = null, M.contains = null, !M.parent) M.children = [], this._wrap();
    }
    q.exports = T;
    var X = ["enc", "parent", "children", "tag", "args", "reverseArgs", "choice", "optional", "any", "obj", "use", "alteredUse", "key", "default", "explicit", "implicit", "contains"];
    T.prototype.clone = function() {
      var f = this._baseState, V = {};
      X.forEach(function(N) {
        V[N] = f[N];
      });
      var M = new this.constructor(V.parent);
      return M._baseState = V, M;
    }, T.prototype._wrap = function() {
      var f = this._baseState;
      z.forEach(function(V) {
        this[V] = function() {
          var M = new this.constructor(this);
          return f.children.push(M), M[V].apply(M, arguments);
        };
      }, this);
    }, T.prototype._init = function(f) {
      var V = this._baseState;
      Y(V.parent === null), f.call(this), V.children = V.children.filter(function(M) {
        return M._baseState.parent === this;
      }, this), Y.equal(V.children.length, 1, "Root node can have only one child");
    }, T.prototype._useArgs = function(f) {
      var V = this._baseState, M = f.filter(function(N) {
        return N instanceof this.constructor;
      }, this);
      if (f = f.filter(function(N) {
        return !(N instanceof this.constructor);
      }, this), M.length !== 0) Y(V.children === null), V.children = M, M.forEach(function(N) {
        N._baseState.parent = this;
      }, this);
      if (f.length !== 0) Y(V.args === null), V.args = f, V.reverseArgs = f.map(function(N) {
        if (typeof N !== "object" || N.constructor !== Object) return N;
        var h = {};
        return Object.keys(N).forEach(function(E) {
          if (E == (E | 0)) E |= 0;
          var I = N[E];
          h[I] = E;
        }), h;
      });
    }, J.forEach(function(f) {
      T.prototype[f] = function() {
        var V = this._baseState;
        throw Error(f + " not implemented for encoding: " + V.enc);
      };
    }), O.forEach(function(f) {
      T.prototype[f] = function() {
        var V = this._baseState, M = Array.prototype.slice.call(arguments);
        return Y(V.tag === null), V.tag = f, this._useArgs(M), this;
      };
    }), T.prototype.use = function(f) {
      Y(f);
      var V = this._baseState;
      return Y(V.use === null), V.use = f, this;
    }, T.prototype.optional = function() {
      var f = this._baseState;
      return f.optional = true, this;
    }, T.prototype.def = function(f) {
      var V = this._baseState;
      return Y(V.default === null), V.default = f, V.optional = true, this;
    }, T.prototype.explicit = function(f) {
      var V = this._baseState;
      return Y(V.explicit === null && V.implicit === null), V.explicit = f, this;
    }, T.prototype.implicit = function(f) {
      var V = this._baseState;
      return Y(V.explicit === null && V.implicit === null), V.implicit = f, this;
    }, T.prototype.obj = function() {
      var f = this._baseState, V = Array.prototype.slice.call(arguments);
      if (f.obj = true, V.length !== 0) this._useArgs(V);
      return this;
    }, T.prototype.key = function(f) {
      var V = this._baseState;
      return Y(V.key === null), V.key = f, this;
    }, T.prototype.any = function() {
      var f = this._baseState;
      return f.any = true, this;
    }, T.prototype.choice = function(f) {
      var V = this._baseState;
      return Y(V.choice === null), V.choice = f, this._useArgs(Object.keys(f).map(function(M) {
        return f[M];
      })), this;
    }, T.prototype.contains = function(f) {
      var V = this._baseState;
      return Y(V.use === null), V.contains = f, this;
    }, T.prototype._decode = function(f, V) {
      var M = this._baseState;
      if (M.parent === null) return f.wrapResult(M.children[0]._decode(f, V));
      var N = M.default, h = true, E = null;
      if (M.key !== null) E = f.enterKey(M.key);
      if (M.optional) {
        var I = null;
        if (M.explicit !== null) I = M.explicit;
        else if (M.implicit !== null) I = M.implicit;
        else if (M.tag !== null) I = M.tag;
        if (I === null && !M.any) {
          var D = f.save();
          try {
            if (M.choice === null) this._decodeGeneric(M.tag, f, V);
            else this._decodeChoice(f, V);
            h = true;
          } catch (s) {
            h = false;
          }
          f.restore(D);
        } else if (h = this._peekTag(f, I, M.any), f.isError(h)) return h;
      }
      var g;
      if (M.obj && h) g = f.enterObject();
      if (h) {
        if (M.explicit !== null) {
          var b = this._decodeTag(f, M.explicit);
          if (f.isError(b)) return b;
          f = b;
        }
        var y = f.offset;
        if (M.use === null && M.choice === null) {
          if (M.any) var D = f.save();
          var p = this._decodeTag(f, M.implicit !== null ? M.implicit : M.tag, M.any);
          if (f.isError(p)) return p;
          if (M.any) N = f.raw(D);
          else f = p;
        }
        if (V && V.track && M.tag !== null) V.track(f.path(), y, f.length, "tagged");
        if (V && V.track && M.tag !== null) V.track(f.path(), f.offset, f.length, "content");
        if (M.any) N = N;
        else if (M.choice === null) N = this._decodeGeneric(M.tag, f, V);
        else N = this._decodeChoice(f, V);
        if (f.isError(N)) return N;
        if (!M.any && M.choice === null && M.children !== null) M.children.forEach(function(s) {
          s._decode(f, V);
        });
        if (M.contains && (M.tag === "octstr" || M.tag === "bitstr")) {
          var n = new _(N);
          N = this._getUse(M.contains, f._reporterState.obj)._decode(n, V);
        }
      }
      if (M.obj && h) N = f.leaveObject(g);
      if (M.key !== null && (N !== null || h === true)) f.leaveKey(E, M.key, N);
      else if (E !== null) f.exitKey(E);
      return N;
    }, T.prototype._decodeGeneric = function(f, V, M) {
      var N = this._baseState;
      if (f === "seq" || f === "set") return null;
      if (f === "seqof" || f === "setof") return this._decodeList(V, f, N.args[0], M);
      else if (/str$/.test(f)) return this._decodeStr(V, f, M);
      else if (f === "objid" && N.args) return this._decodeObjid(V, N.args[0], N.args[1], M);
      else if (f === "objid") return this._decodeObjid(V, null, null, M);
      else if (f === "gentime" || f === "utctime") return this._decodeTime(V, f, M);
      else if (f === "null_") return this._decodeNull(V, M);
      else if (f === "bool") return this._decodeBool(V, M);
      else if (f === "objDesc") return this._decodeStr(V, f, M);
      else if (f === "int" || f === "enum") return this._decodeInt(V, N.args && N.args[0], M);
      if (N.use !== null) return this._getUse(N.use, V._reporterState.obj)._decode(V, M);
      else return V.error("unknown tag: " + f);
    }, T.prototype._getUse = function(f, V) {
      var M = this._baseState;
      if (M.useDecoder = this._use(f, V), Y(M.useDecoder._baseState.parent === null), M.useDecoder = M.useDecoder._baseState.children[0], M.implicit !== M.useDecoder._baseState.implicit) M.useDecoder = M.useDecoder.clone(), M.useDecoder._baseState.implicit = M.implicit;
      return M.useDecoder;
    }, T.prototype._decodeChoice = function(f, V) {
      var M = this._baseState, N = null, h = false;
      if (Object.keys(M.choice).some(function(E) {
        var I = f.save(), D = M.choice[E];
        try {
          var g = D._decode(f, V);
          if (f.isError(g)) return false;
          N = { type: E, value: g }, h = true;
        } catch (b) {
          return f.restore(I), false;
        }
        return true;
      }, this), !h) return f.error("Choice not matched");
      return N;
    }, T.prototype._createEncoderBuffer = function(f) {
      return new P(f, this.reporter);
    }, T.prototype._encode = function(f, V, M) {
      var N = this._baseState;
      if (N.default !== null && N.default === f) return;
      var h = this._encodeValue(f, V, M);
      if (h === void 0) return;
      if (this._skipDefault(h, V, M)) return;
      return h;
    }, T.prototype._encodeValue = function(f, V, M) {
      var N = this._baseState;
      if (N.parent === null) return N.children[0]._encode(f, V || new K());
      var D = null;
      if (this.reporter = V, N.optional && f === void 0) if (N.default !== null) f = N.default;
      else return;
      var h = null, E = false;
      if (N.any) D = this._createEncoderBuffer(f);
      else if (N.choice) D = this._encodeChoice(f, V);
      else if (N.contains) h = this._getUse(N.contains, M)._encode(f, V), E = true;
      else if (N.children) h = N.children.map(function(y) {
        if (y._baseState.tag === "null_") return y._encode(null, V, f);
        if (y._baseState.key === null) return V.error("Child should have a key");
        var p = V.enterKey(y._baseState.key);
        if (typeof f !== "object") return V.error("Child expected, but input is not object");
        var n = y._encode(f[y._baseState.key], V, f);
        return V.leaveKey(p), n;
      }, this).filter(function(y) {
        return y;
      }), h = this._createEncoderBuffer(h);
      else if (N.tag === "seqof" || N.tag === "setof") {
        if (!(N.args && N.args.length === 1)) return V.error("Too many args for : " + N.tag);
        if (!Array.isArray(f)) return V.error("seqof/setof, but data is not Array");
        var I = this.clone();
        I._baseState.implicit = null, h = this._createEncoderBuffer(f.map(function(y) {
          var p = this._baseState;
          return this._getUse(p.args[0], f)._encode(y, V);
        }, I));
      } else if (N.use !== null) D = this._getUse(N.use, M)._encode(f, V);
      else h = this._encodePrimitive(N.tag, f), E = true;
      var D;
      if (!N.any && N.choice === null) {
        var g = N.implicit !== null ? N.implicit : N.tag, b = N.implicit === null ? "universal" : "context";
        if (g === null) {
          if (N.use === null) V.error("Tag could be omitted only for .use()");
        } else if (N.use === null) D = this._encodeComposite(g, E, b, h);
      }
      if (N.explicit !== null) D = this._encodeComposite(N.explicit, false, "context", D);
      return D;
    }, T.prototype._encodeChoice = function(f, V) {
      var M = this._baseState, N = M.choice[f.type];
      if (!N) Y(false, f.type + " not found in " + JSON.stringify(Object.keys(M.choice)));
      return N._encode(f.value, V);
    }, T.prototype._encodePrimitive = function(f, V) {
      var M = this._baseState;
      if (/str$/.test(f)) return this._encodeStr(V, f);
      else if (f === "objid" && M.args) return this._encodeObjid(V, M.reverseArgs[0], M.args[1]);
      else if (f === "objid") return this._encodeObjid(V, null, null);
      else if (f === "gentime" || f === "utctime") return this._encodeTime(V, f);
      else if (f === "null_") return this._encodeNull();
      else if (f === "int" || f === "enum") return this._encodeInt(V, M.args && M.reverseArgs[0]);
      else if (f === "bool") return this._encodeBool(V);
      else if (f === "objDesc") return this._encodeStr(V, f);
      else throw Error("Unsupported tag: " + f);
    }, T.prototype._isNumstr = function(f) {
      return /^[0-9 ]*$/.test(f);
    }, T.prototype._isPrintstr = function(f) {
      return /^[A-Za-z0-9 '\(\)\+,\-\.\/:=\?]*$/.test(f);
    };
  }), B7 = r$(($18) => {
    var q = $18;
    q.Reporter = Ho().Reporter, q.DecoderBuffer = eS().DecoderBuffer, q.EncoderBuffer = eS().EncoderBuffer, q.Node = Jo();
  }), To = r$(($18) => {
    var q = v0();
    $18.tagClass = { 0: "universal", 1: "application", 2: "context", 3: "private" }, $18.tagClassByName = q._reverse($18.tagClass), $18.tag = { 0: "end", 1: "bool", 2: "int", 3: "bitstr", 4: "octstr", 5: "null_", 6: "objid", 7: "objDesc", 8: "external", 9: "real", 10: "enum", 11: "embed", 12: "utf8str", 13: "relativeOid", 16: "seq", 17: "set", 18: "numstr", 19: "printstr", 20: "t61str", 21: "videostr", 22: "ia5str", 23: "utctime", 24: "gentime", 25: "graphstr", 26: "iso646str", 27: "genstr", 28: "unistr", 29: "charstr", 30: "bmpstr" }, $18.tagByName = q._reverse($18.tag);
  }), v0 = r$(($18) => {
    var q = $18;
    q._reverse = function(K) {
      var P = {};
      return Object.keys(K).forEach(function(_) {
        if ((_ | 0) == _) _ = _ | 0;
        var Y = K[_];
        P[Y] = _;
      }), P;
    }, q.der = To();
  }), z0 = r$(($18, q) => {
    var K = v8(), P = U7(), _ = P.base, Y = P.bignum, O = P.constants.der;
    function z(f) {
      this.enc = "der", this.name = f.name, this.entity = f, this.tree = new J(), this.tree._init(f.body);
    }
    q.exports = z, z.prototype.decode = function(f, V) {
      if (!(f instanceof _.DecoderBuffer)) f = new _.DecoderBuffer(f, V);
      return this.tree._decode(f, V);
    };
    function J(f) {
      _.Node.call(this, "der", f);
    }
    K(J, _.Node), J.prototype._peekTag = function(f, V, M) {
      if (f.isEmpty()) return false;
      var N = f.save(), h = T(f, 'Failed to peek tag: "' + V + '"');
      if (f.isError(h)) return h;
      return f.restore(N), h.tag === V || h.tagStr === V || h.tagStr + "of" === V || M;
    }, J.prototype._decodeTag = function(f, V, M) {
      var N = T(f, 'Failed to decode tag of "' + V + '"');
      if (f.isError(N)) return N;
      var h = X(f, N.primitive, 'Failed to get length of "' + V + '"');
      if (f.isError(h)) return h;
      if (!M && N.tag !== V && N.tagStr !== V && N.tagStr + "of" !== V) return f.error('Failed to match tag: "' + V + '"');
      if (N.primitive || h !== null) return f.skip(h, 'Failed to match body of: "' + V + '"');
      var E = f.save(), I = this._skipUntilEnd(f, 'Failed to skip indefinite length body: "' + this.tag + '"');
      if (f.isError(I)) return I;
      return h = f.offset - E.offset, f.restore(E), f.skip(h, 'Failed to match body of: "' + V + '"');
    }, J.prototype._skipUntilEnd = function(f, V) {
      while (true) {
        var M = T(f, V);
        if (f.isError(M)) return M;
        var N = X(f, M.primitive, V);
        if (f.isError(N)) return N;
        var h;
        if (M.primitive || N !== null) h = f.skip(N);
        else h = this._skipUntilEnd(f, V);
        if (f.isError(h)) return h;
        if (M.tagStr === "end") break;
      }
    }, J.prototype._decodeList = function(f, V, M, N) {
      var h = [];
      while (!f.isEmpty()) {
        var E = this._peekTag(f, "end");
        if (f.isError(E)) return E;
        var I = M.decode(f, "der", N);
        if (f.isError(I) && E) break;
        h.push(I);
      }
      return h;
    }, J.prototype._decodeStr = function(f, V) {
      if (V === "bitstr") {
        var M = f.readUInt8();
        if (f.isError(M)) return M;
        return { unused: M, data: f.raw() };
      } else if (V === "bmpstr") {
        var N = f.raw();
        if (N.length % 2 === 1) return f.error("Decoding of string type: bmpstr length mismatch");
        var h = "";
        for (var E = 0; E < N.length / 2; E++) h += String.fromCharCode(N.readUInt16BE(E * 2));
        return h;
      } else if (V === "numstr") {
        var I = f.raw().toString("ascii");
        if (!this._isNumstr(I)) return f.error("Decoding of string type: numstr unsupported characters");
        return I;
      } else if (V === "octstr") return f.raw();
      else if (V === "objDesc") return f.raw();
      else if (V === "printstr") {
        var D = f.raw().toString("ascii");
        if (!this._isPrintstr(D)) return f.error("Decoding of string type: printstr unsupported characters");
        return D;
      } else if (/str$/.test(V)) return f.raw().toString();
      else return f.error("Decoding of string type: " + V + " unsupported");
    }, J.prototype._decodeObjid = function(f, V, M) {
      var N, h = [], E = 0;
      while (!f.isEmpty()) {
        var I = f.readUInt8();
        if (E <<= 7, E |= I & 127, (I & 128) === 0) h.push(E), E = 0;
      }
      if (I & 128) h.push(E);
      var D = h[0] / 40 | 0, g = h[0] % 40;
      if (M) N = h;
      else N = [D, g].concat(h.slice(1));
      if (V) {
        var b = V[N.join(" ")];
        if (b === void 0) b = V[N.join(".")];
        if (b !== void 0) N = b;
      }
      return N;
    }, J.prototype._decodeTime = function(f, V) {
      var M = f.raw().toString();
      if (V === "gentime") var N = M.slice(0, 4) | 0, h = M.slice(4, 6) | 0, E = M.slice(6, 8) | 0, I = M.slice(8, 10) | 0, D = M.slice(10, 12) | 0, g = M.slice(12, 14) | 0;
      else if (V === "utctime") {
        var N = M.slice(0, 2) | 0, h = M.slice(2, 4) | 0, E = M.slice(4, 6) | 0, I = M.slice(6, 8) | 0, D = M.slice(8, 10) | 0, g = M.slice(10, 12) | 0;
        if (N < 70) N = 2e3 + N;
        else N = 1900 + N;
      } else return f.error("Decoding " + V + " time is not supported yet");
      return Date.UTC(N, h - 1, E, I, D, g, 0);
    }, J.prototype._decodeNull = function(f) {
      return null;
    }, J.prototype._decodeBool = function(f) {
      var V = f.readUInt8();
      if (f.isError(V)) return V;
      else return V !== 0;
    }, J.prototype._decodeInt = function(f, V) {
      var M = f.raw(), N = new Y(M);
      if (V) N = V[N.toString(10)] || N;
      return N;
    }, J.prototype._use = function(f, V) {
      if (typeof f === "function") f = f(V);
      return f._getDecoder("der").tree;
    };
    function T(f, V) {
      var M = f.readUInt8(V);
      if (f.isError(M)) return M;
      var N = O.tagClass[M >> 6], h = (M & 32) === 0;
      if ((M & 31) === 31) {
        var E = M;
        M = 0;
        while ((E & 128) === 128) {
          if (E = f.readUInt8(V), f.isError(E)) return E;
          M <<= 7, M |= E & 127;
        }
      } else M &= 31;
      var I = O.tag[M];
      return { cls: N, primitive: h, tag: M, tagStr: I };
    }
    function X(f, V, M) {
      var N = f.readUInt8(M);
      if (f.isError(N)) return N;
      if (!V && N === 128) return null;
      if ((N & 128) === 0) return N;
      var h = N & 127;
      if (h > 4) return f.error("length octect is too long");
      N = 0;
      for (var E = 0; E < h; E++) {
        N <<= 8;
        var I = f.readUInt8(M);
        if (f.isError(I)) return I;
        N |= I;
      }
      return N;
    }
  }), wo = r$(($18, q) => {
    var K = v8(), P = (wq(), J6(Tq)).Buffer, _ = z0();
    function Y(O) {
      _.call(this, O), this.enc = "pem";
    }
    K(Y, _), q.exports = Y, Y.prototype.decode = function(O, z) {
      var J = O.toString().split(/[\r\n]+/g), T = z.label.toUpperCase(), X = /^-----(BEGIN|END) ([^-]+)-----$/, f = -1, V = -1;
      for (var M = 0; M < J.length; M++) {
        var N = J[M].match(X);
        if (N === null) continue;
        if (N[2] !== T) continue;
        if (f === -1) {
          if (N[1] !== "BEGIN") break;
          f = M;
        } else {
          if (N[1] !== "END") break;
          V = M;
          break;
        }
      }
      if (f === -1 || V === -1) throw Error("PEM section not found for: " + T);
      var h = J.slice(f + 1, V).join("");
      h.replace(/[^a-z0-9\+\/=]+/gi, "");
      var E = new P(h, "base64");
      return _.prototype.decode.call(this, E, z);
    };
  }), fo = r$(($18) => {
    var q = $18;
    q.der = z0(), q.pem = wo();
  }), W0 = r$(($18, q) => {
    var K = v8(), P = (wq(), J6(Tq)).Buffer, _ = U7(), Y = _.base, O = _.constants.der;
    function z(f) {
      this.enc = "der", this.name = f.name, this.entity = f, this.tree = new J(), this.tree._init(f.body);
    }
    q.exports = z, z.prototype.encode = function(f, V) {
      return this.tree._encode(f, V).join();
    };
    function J(f) {
      Y.Node.call(this, "der", f);
    }
    K(J, Y.Node), J.prototype._encodeComposite = function(f, V, M, N) {
      var h = X(f, V, M, this.reporter);
      if (N.length < 128) {
        var D = new P(2);
        return D[0] = h, D[1] = N.length, this._createEncoderBuffer([D, N]);
      }
      var E = 1;
      for (var I = N.length; I >= 256; I >>= 8) E++;
      var D = new P(2 + E);
      D[0] = h, D[1] = 128 | E;
      for (var I = 1 + E, g = N.length; g > 0; I--, g >>= 8) D[I] = g & 255;
      return this._createEncoderBuffer([D, N]);
    }, J.prototype._encodeStr = function(f, V) {
      if (V === "bitstr") return this._createEncoderBuffer([f.unused | 0, f.data]);
      else if (V === "bmpstr") {
        var M = new P(f.length * 2);
        for (var N = 0; N < f.length; N++) M.writeUInt16BE(f.charCodeAt(N), N * 2);
        return this._createEncoderBuffer(M);
      } else if (V === "numstr") {
        if (!this._isNumstr(f)) return this.reporter.error("Encoding of string type: numstr supports only digits and space");
        return this._createEncoderBuffer(f);
      } else if (V === "printstr") {
        if (!this._isPrintstr(f)) return this.reporter.error("Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark");
        return this._createEncoderBuffer(f);
      } else if (/str$/.test(V)) return this._createEncoderBuffer(f);
      else if (V === "objDesc") return this._createEncoderBuffer(f);
      else return this.reporter.error("Encoding of string type: " + V + " unsupported");
    }, J.prototype._encodeObjid = function(f, V, M) {
      if (typeof f === "string") {
        if (!V) return this.reporter.error("string objid given, but no values map found");
        if (!V.hasOwnProperty(f)) return this.reporter.error("objid not found in values map");
        f = V[f].split(/[\s\.]+/g);
        for (var N = 0; N < f.length; N++) f[N] |= 0;
      } else if (Array.isArray(f)) {
        f = f.slice();
        for (var N = 0; N < f.length; N++) f[N] |= 0;
      }
      if (!Array.isArray(f)) return this.reporter.error("objid() should be either array or string, got: " + JSON.stringify(f));
      if (!M) {
        if (f[1] >= 40) return this.reporter.error("Second objid identifier OOB");
        f.splice(0, 2, f[0] * 40 + f[1]);
      }
      var h = 0;
      for (var N = 0; N < f.length; N++) {
        var E = f[N];
        for (h++; E >= 128; E >>= 7) h++;
      }
      var I = new P(h), D = I.length - 1;
      for (var N = f.length - 1; N >= 0; N--) {
        var E = f[N];
        I[D--] = E & 127;
        while ((E >>= 7) > 0) I[D--] = 128 | E & 127;
      }
      return this._createEncoderBuffer(I);
    };
    function T(f) {
      if (f < 10) return "0" + f;
      else return f;
    }
    J.prototype._encodeTime = function(f, V) {
      var M, N = new Date(f);
      if (V === "gentime") M = [T(N.getFullYear()), T(N.getUTCMonth() + 1), T(N.getUTCDate()), T(N.getUTCHours()), T(N.getUTCMinutes()), T(N.getUTCSeconds()), "Z"].join("");
      else if (V === "utctime") M = [T(N.getFullYear() % 100), T(N.getUTCMonth() + 1), T(N.getUTCDate()), T(N.getUTCHours()), T(N.getUTCMinutes()), T(N.getUTCSeconds()), "Z"].join("");
      else this.reporter.error("Encoding " + V + " time is not supported yet");
      return this._encodeStr(M, "octstr");
    }, J.prototype._encodeNull = function() {
      return this._createEncoderBuffer("");
    }, J.prototype._encodeInt = function(f, V) {
      if (typeof f === "string") {
        if (!V) return this.reporter.error("String int or enum given, but no values map");
        if (!V.hasOwnProperty(f)) return this.reporter.error("Values map doesn't contain: " + JSON.stringify(f));
        f = V[f];
      }
      if (typeof f !== "number" && !P.isBuffer(f)) {
        var M = f.toArray();
        if (!f.sign && M[0] & 128) M.unshift(0);
        f = new P(M);
      }
      if (P.isBuffer(f)) {
        var N = f.length;
        if (f.length === 0) N++;
        var E = new P(N);
        if (f.copy(E), f.length === 0) E[0] = 0;
        return this._createEncoderBuffer(E);
      }
      if (f < 128) return this._createEncoderBuffer(f);
      if (f < 256) return this._createEncoderBuffer([0, f]);
      var N = 1;
      for (var h = f; h >= 256; h >>= 8) N++;
      var E = Array(N);
      for (var h = E.length - 1; h >= 0; h--) E[h] = f & 255, f >>= 8;
      if (E[0] & 128) E.unshift(0);
      return this._createEncoderBuffer(new P(E));
    }, J.prototype._encodeBool = function(f) {
      return this._createEncoderBuffer(f ? 255 : 0);
    }, J.prototype._use = function(f, V) {
      if (typeof f === "function") f = f(V);
      return f._getEncoder("der").tree;
    }, J.prototype._skipDefault = function(f, V, M) {
      var N = this._baseState, h;
      if (N.default === null) return false;
      var E = f.join();
      if (N.defaultBuffer === void 0) N.defaultBuffer = this._encodeValue(N.default, V, M).join();
      if (E.length !== N.defaultBuffer.length) return false;
      for (h = 0; h < E.length; h++) if (E[h] !== N.defaultBuffer[h]) return false;
      return true;
    };
    function X(f, V, M, N) {
      var h;
      if (f === "seqof") f = "seq";
      else if (f === "setof") f = "set";
      if (O.tagByName.hasOwnProperty(f)) h = O.tagByName[f];
      else if (typeof f === "number" && (f | 0) === f) h = f;
      else return N.error("Unknown tag: " + f);
      if (h >= 31) return N.error("Multi-octet tag encoding unsupported");
      if (!V) h |= 32;
      return h |= O.tagClassByName[M || "universal"] << 6, h;
    }
  }), Zo = r$(($18, q) => {
    var K = v8(), P = W0();
    function _(Y) {
      P.call(this, Y), this.enc = "pem";
    }
    K(_, P), q.exports = _, _.prototype.encode = function(Y, O) {
      var z = P.prototype.encode.call(this, Y), J = z.toString("base64"), T = ["-----BEGIN " + O.label + "-----"];
      for (var X = 0; X < J.length; X += 64) T.push(J.slice(X, X + 64));
      return T.push("-----END " + O.label + "-----"), T.join(`
`);
    };
  }), Xo = r$(($18) => {
    var q = $18;
    q.der = W0(), q.pem = Zo();
  }), U7 = r$(($18) => {
    var q = $18;
    q.bignum = zo(), q.define = Wo().define, q.base = B7(), q.constants = v0(), q.decoders = fo(), q.encoders = Xo();
  }), Ao = r$(($18, q) => {
    var K = U7(), P = K.define("Time", function() {
      this.choice({ utcTime: this.utctime(), generalTime: this.gentime() });
    }), _ = K.define("AttributeTypeValue", function() {
      this.seq().obj(this.key("type").objid(), this.key("value").any());
    }), Y = K.define("AlgorithmIdentifier", function() {
      this.seq().obj(this.key("algorithm").objid(), this.key("parameters").optional(), this.key("curve").objid().optional());
    }), O = K.define("SubjectPublicKeyInfo", function() {
      this.seq().obj(this.key("algorithm").use(Y), this.key("subjectPublicKey").bitstr());
    }), z = K.define("RelativeDistinguishedName", function() {
      this.setof(_);
    }), J = K.define("RDNSequence", function() {
      this.seqof(z);
    }), T = K.define("Name", function() {
      this.choice({ rdnSequence: this.use(J) });
    }), X = K.define("Validity", function() {
      this.seq().obj(this.key("notBefore").use(P), this.key("notAfter").use(P));
    }), f = K.define("Extension", function() {
      this.seq().obj(this.key("extnID").objid(), this.key("critical").bool().def(false), this.key("extnValue").octstr());
    }), V = K.define("TBSCertificate", function() {
      this.seq().obj(this.key("version").explicit(0).int().optional(), this.key("serialNumber").int(), this.key("signature").use(Y), this.key("issuer").use(T), this.key("validity").use(X), this.key("subject").use(T), this.key("subjectPublicKeyInfo").use(O), this.key("issuerUniqueID").implicit(1).bitstr().optional(), this.key("subjectUniqueID").implicit(2).bitstr().optional(), this.key("extensions").explicit(3).seqof(f).optional());
    }), M = K.define("X509Certificate", function() {
      this.seq().obj(this.key("tbsCertificate").use(V), this.key("signatureAlgorithm").use(Y), this.key("signatureValue").bitstr());
    });
    q.exports = M;
  }), ko = r$(($18) => {
    var q = U7();
    $18.certificate = Ao();
    var K = q.define("RSAPrivateKey", function() {
      this.seq().obj(this.key("version").int(), this.key("modulus").int(), this.key("publicExponent").int(), this.key("privateExponent").int(), this.key("prime1").int(), this.key("prime2").int(), this.key("exponent1").int(), this.key("exponent2").int(), this.key("coefficient").int());
    });
    $18.RSAPrivateKey = K;
    var P = q.define("RSAPublicKey", function() {
      this.seq().obj(this.key("modulus").int(), this.key("publicExponent").int());
    });
    $18.RSAPublicKey = P;
    var _ = q.define("AlgorithmIdentifier", function() {
      this.seq().obj(this.key("algorithm").objid(), this.key("none").null_().optional(), this.key("curve").objid().optional(), this.key("params").seq().obj(this.key("p").int(), this.key("q").int(), this.key("g").int()).optional());
    }), Y = q.define("SubjectPublicKeyInfo", function() {
      this.seq().obj(this.key("algorithm").use(_), this.key("subjectPublicKey").bitstr());
    });
    $18.PublicKey = Y;
    var O = q.define("PrivateKeyInfo", function() {
      this.seq().obj(this.key("version").int(), this.key("algorithm").use(_), this.key("subjectPrivateKey").octstr());
    });
    $18.PrivateKey = O;
    var z = q.define("EncryptedPrivateKeyInfo", function() {
      this.seq().obj(this.key("algorithm").seq().obj(this.key("id").objid(), this.key("decrypt").seq().obj(this.key("kde").seq().obj(this.key("id").objid(), this.key("kdeparams").seq().obj(this.key("salt").octstr(), this.key("iters").int())), this.key("cipher").seq().obj(this.key("algo").objid(), this.key("iv").octstr()))), this.key("subjectPrivateKey").octstr());
    });
    $18.EncryptedPrivateKey = z;
    var J = q.define("DSAPrivateKey", function() {
      this.seq().obj(this.key("version").int(), this.key("p").int(), this.key("q").int(), this.key("g").int(), this.key("pub_key").int(), this.key("priv_key").int());
    });
    $18.DSAPrivateKey = J, $18.DSAparam = q.define("DSAparam", function() {
      this.int();
    });
    var T = q.define("ECParameters", function() {
      this.choice({ namedCurve: this.objid() });
    }), X = q.define("ECPrivateKey", function() {
      this.seq().obj(this.key("version").int(), this.key("privateKey").octstr(), this.key("parameters").optional().explicit(0).use(T), this.key("publicKey").optional().explicit(1).bitstr());
    });
    $18.ECPrivateKey = X, $18.signature = q.define("signature", function() {
      this.seq().obj(this.key("r").int(), this.key("s").int());
    });
  }), Go = r$(($18, q) => {
    q.exports = { "2.16.840.1.101.3.4.1.1": "aes-128-ecb", "2.16.840.1.101.3.4.1.2": "aes-128-cbc", "2.16.840.1.101.3.4.1.3": "aes-128-ofb", "2.16.840.1.101.3.4.1.4": "aes-128-cfb", "2.16.840.1.101.3.4.1.21": "aes-192-ecb", "2.16.840.1.101.3.4.1.22": "aes-192-cbc", "2.16.840.1.101.3.4.1.23": "aes-192-ofb", "2.16.840.1.101.3.4.1.24": "aes-192-cfb", "2.16.840.1.101.3.4.1.41": "aes-256-ecb", "2.16.840.1.101.3.4.1.42": "aes-256-cbc", "2.16.840.1.101.3.4.1.43": "aes-256-ofb", "2.16.840.1.101.3.4.1.44": "aes-256-cfb" };
  }), Vo = r$(($18, q) => {
    var K = $8().Buffer, P = cH().Transform, _ = v8();
    function Y(T) {
      P.call(this), this._block = K.allocUnsafe(T), this._blockSize = T, this._blockOffset = 0, this._length = [0, 0, 0, 0], this._finalized = false;
    }
    _(Y, P), Y.prototype._transform = function(T, X, f) {
      var V = null;
      try {
        this.update(T, X);
      } catch (M) {
        V = M;
      }
      f(V);
    }, Y.prototype._flush = function(T) {
      var X = null;
      try {
        this.push(this.digest());
      } catch (f) {
        X = f;
      }
      T(X);
    };
    var O = typeof Uint8Array < "u", z = typeof ArrayBuffer < "u" && typeof Uint8Array < "u" && ArrayBuffer.isView && (K.prototype instanceof Uint8Array || K.TYPED_ARRAY_SUPPORT);
    function J(T, X) {
      if (T instanceof K) return T;
      if (typeof T === "string") return K.from(T, X);
      if (z && ArrayBuffer.isView(T)) {
        if (T.byteLength === 0) return K.alloc(0);
        var f = K.from(T.buffer, T.byteOffset, T.byteLength);
        if (f.byteLength === T.byteLength) return f;
      }
      if (O && T instanceof Uint8Array) return K.from(T);
      if (K.isBuffer(T) && T.constructor && typeof T.constructor.isBuffer === "function" && T.constructor.isBuffer(T)) return K.from(T);
      throw TypeError('The "data" argument must be of type string or an instance of Buffer, TypedArray, or DataView.');
    }
    Y.prototype.update = function(T, X) {
      if (this._finalized) throw Error("Digest already called");
      T = J(T, X);
      var f = this._block, V = 0;
      while (this._blockOffset + T.length - V >= this._blockSize) {
        for (var M = this._blockOffset; M < this._blockSize; ) f[M++] = T[V++];
        this._update(), this._blockOffset = 0;
      }
      while (V < T.length) f[this._blockOffset++] = T[V++];
      for (var N = 0, h = T.length * 8; h > 0; ++N) if (this._length[N] += h, h = this._length[N] / 4294967296 | 0, h > 0) this._length[N] -= 4294967296 * h;
      return this;
    }, Y.prototype._update = function() {
      throw Error("_update is not implemented");
    }, Y.prototype.digest = function(T) {
      if (this._finalized) throw Error("Digest already called");
      this._finalized = true;
      var X = this._digest();
      if (T !== void 0) X = X.toString(T);
      this._block.fill(0), this._blockOffset = 0;
      for (var f = 0; f < 4; ++f) this._length[f] = 0;
      return X;
    }, Y.prototype._digest = function() {
      throw Error("_digest is not implemented");
    }, q.exports = Y;
  }), So = r$(($18, q) => {
    var K = v8(), P = Vo(), _ = $8().Buffer, Y = Array(16);
    function O() {
      P.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878;
    }
    K(O, P), O.prototype._update = function() {
      var V = Y;
      for (var M = 0; M < 16; ++M) V[M] = this._block.readInt32LE(M * 4);
      var N = this._a, h = this._b, E = this._c, I = this._d;
      N = J(N, h, E, I, V[0], 3614090360, 7), I = J(I, N, h, E, V[1], 3905402710, 12), E = J(E, I, N, h, V[2], 606105819, 17), h = J(h, E, I, N, V[3], 3250441966, 22), N = J(N, h, E, I, V[4], 4118548399, 7), I = J(I, N, h, E, V[5], 1200080426, 12), E = J(E, I, N, h, V[6], 2821735955, 17), h = J(h, E, I, N, V[7], 4249261313, 22), N = J(N, h, E, I, V[8], 1770035416, 7), I = J(I, N, h, E, V[9], 2336552879, 12), E = J(E, I, N, h, V[10], 4294925233, 17), h = J(h, E, I, N, V[11], 2304563134, 22), N = J(N, h, E, I, V[12], 1804603682, 7), I = J(I, N, h, E, V[13], 4254626195, 12), E = J(E, I, N, h, V[14], 2792965006, 17), h = J(h, E, I, N, V[15], 1236535329, 22), N = T(N, h, E, I, V[1], 4129170786, 5), I = T(I, N, h, E, V[6], 3225465664, 9), E = T(E, I, N, h, V[11], 643717713, 14), h = T(h, E, I, N, V[0], 3921069994, 20), N = T(N, h, E, I, V[5], 3593408605, 5), I = T(I, N, h, E, V[10], 38016083, 9), E = T(E, I, N, h, V[15], 3634488961, 14), h = T(h, E, I, N, V[4], 3889429448, 20), N = T(N, h, E, I, V[9], 568446438, 5), I = T(I, N, h, E, V[14], 3275163606, 9), E = T(E, I, N, h, V[3], 4107603335, 14), h = T(h, E, I, N, V[8], 1163531501, 20), N = T(N, h, E, I, V[13], 2850285829, 5), I = T(I, N, h, E, V[2], 4243563512, 9), E = T(E, I, N, h, V[7], 1735328473, 14), h = T(h, E, I, N, V[12], 2368359562, 20), N = X(N, h, E, I, V[5], 4294588738, 4), I = X(I, N, h, E, V[8], 2272392833, 11), E = X(E, I, N, h, V[11], 1839030562, 16), h = X(h, E, I, N, V[14], 4259657740, 23), N = X(N, h, E, I, V[1], 2763975236, 4), I = X(I, N, h, E, V[4], 1272893353, 11), E = X(E, I, N, h, V[7], 4139469664, 16), h = X(h, E, I, N, V[10], 3200236656, 23), N = X(N, h, E, I, V[13], 681279174, 4), I = X(I, N, h, E, V[0], 3936430074, 11), E = X(E, I, N, h, V[3], 3572445317, 16), h = X(h, E, I, N, V[6], 76029189, 23), N = X(N, h, E, I, V[9], 3654602809, 4), I = X(I, N, h, E, V[12], 3873151461, 11), E = X(E, I, N, h, V[15], 530742520, 16), h = X(h, E, I, N, V[2], 3299628645, 23), N = f(N, h, E, I, V[0], 4096336452, 6), I = f(I, N, h, E, V[7], 1126891415, 10), E = f(E, I, N, h, V[14], 2878612391, 15), h = f(h, E, I, N, V[5], 4237533241, 21), N = f(N, h, E, I, V[12], 1700485571, 6), I = f(I, N, h, E, V[3], 2399980690, 10), E = f(E, I, N, h, V[10], 4293915773, 15), h = f(h, E, I, N, V[1], 2240044497, 21), N = f(N, h, E, I, V[8], 1873313359, 6), I = f(I, N, h, E, V[15], 4264355552, 10), E = f(E, I, N, h, V[6], 2734768916, 15), h = f(h, E, I, N, V[13], 1309151649, 21), N = f(N, h, E, I, V[4], 4149444226, 6), I = f(I, N, h, E, V[11], 3174756917, 10), E = f(E, I, N, h, V[2], 718787259, 15), h = f(h, E, I, N, V[9], 3951481745, 21), this._a = this._a + N | 0, this._b = this._b + h | 0, this._c = this._c + E | 0, this._d = this._d + I | 0;
    }, O.prototype._digest = function() {
      if (this._block[this._blockOffset++] = 128, this._blockOffset > 56) this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0;
      this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
      var V = _.allocUnsafe(16);
      return V.writeInt32LE(this._a, 0), V.writeInt32LE(this._b, 4), V.writeInt32LE(this._c, 8), V.writeInt32LE(this._d, 12), V;
    };
    function z(V, M) {
      return V << M | V >>> 32 - M;
    }
    function J(V, M, N, h, E, I, D) {
      return z(V + (M & N | ~M & h) + E + I | 0, D) + M | 0;
    }
    function T(V, M, N, h, E, I, D) {
      return z(V + (M & h | N & ~h) + E + I | 0, D) + M | 0;
    }
    function X(V, M, N, h, E, I, D) {
      return z(V + (M ^ N ^ h) + E + I | 0, D) + M | 0;
    }
    function f(V, M, N, h, E, I, D) {
      return z(V + (N ^ (M | ~h)) + E + I | 0, D) + M | 0;
    }
    q.exports = O;
  }), Mo = r$(($18, q) => {
    var K = $8().Buffer, P = So();
    function _(Y, O, z, J) {
      if (!K.isBuffer(Y)) Y = K.from(Y, "binary");
      if (O) {
        if (!K.isBuffer(O)) O = K.from(O, "binary");
        if (O.length !== 8) throw RangeError("salt should be Buffer with 8 byte length");
      }
      var T = z / 8, X = K.alloc(T), f = K.alloc(J || 0), V = K.alloc(0);
      while (T > 0 || J > 0) {
        var M = new P();
        if (M.update(V), M.update(Y), O) M.update(O);
        V = M.digest();
        var N = 0;
        if (T > 0) {
          var h = X.length - T;
          N = Math.min(T, V.length), V.copy(X, h, 0, N), T -= N;
        }
        if (N < V.length && J > 0) {
          var E = f.length - J, I = Math.min(J, V.length - N);
          V.copy(f, E, N, N + I), J -= I;
        }
      }
      return V.fill(0), { key: X, iv: f };
    }
    q.exports = _;
  }), H0 = r$(($18) => {
    var q = (dq(), J6(mq));
    $18.createCipher = $18.Cipher = q.createCipher, $18.createCipheriv = $18.Cipheriv = q.createCipheriv, $18.createDecipher = $18.Decipher = q.createDecipher, $18.createDecipheriv = $18.Decipheriv = q.createDecipheriv, $18.listCiphers = $18.getCiphers = q.getCiphers;
  }), No = r$(($18, q) => {
    var K = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m, P = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m, _ = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m, Y = Mo(), O = H0(), z = $8().Buffer;
    q.exports = function(J, T) {
      var X = J.toString(), f = X.match(K), V;
      if (!f) {
        var M = X.match(_);
        V = z.from(M[2].replace(/[\r\n]/g, ""), "base64");
      } else {
        var N = "aes" + f[1], h = z.from(f[2], "hex"), E = z.from(f[3].replace(/[\r\n]/g, ""), "base64"), I = Y(T, h.slice(0, 8), parseInt(f[1], 10)).key, D = [], g = O.createDecipheriv(N, I, h);
        D.push(g.update(E)), D.push(g.final()), V = z.concat(D);
      }
      var b = X.match(P)[1];
      return { tag: b, data: V };
    };
  }), J0 = r$(($18, q) => {
    var K = ko(), P = Go(), _ = No(), Y = H0(), O = q0(), z = $8().Buffer;
    function J(X, f) {
      var V = X.algorithm.decrypt.kde.kdeparams.salt, M = parseInt(X.algorithm.decrypt.kde.kdeparams.iters.toString(), 10), N = P[X.algorithm.decrypt.cipher.algo.join(".")], h = X.algorithm.decrypt.cipher.iv, E = X.subjectPrivateKey, I = parseInt(N.split("-")[1], 10) / 8, D = O.pbkdf2Sync(f, V, M, I, "sha1"), g = Y.createDecipheriv(N, D, h), b = [];
      return b.push(g.update(E)), b.push(g.final()), z.concat(b);
    }
    function T(X) {
      var f;
      if (typeof X === "object" && !z.isBuffer(X)) f = X.passphrase, X = X.key;
      if (typeof X === "string") X = z.from(X);
      var V = _(X, f), M = V.tag, N = V.data, h, E;
      switch (M) {
        case "CERTIFICATE":
          E = K.certificate.decode(N, "der").tbsCertificate.subjectPublicKeyInfo;
        case "PUBLIC KEY":
          if (!E) E = K.PublicKey.decode(N, "der");
          switch (h = E.algorithm.algorithm.join("."), h) {
            case "1.2.840.113549.1.1.1":
              return K.RSAPublicKey.decode(E.subjectPublicKey.data, "der");
            case "1.2.840.10045.2.1":
              return E.subjectPrivateKey = E.subjectPublicKey, { type: "ec", data: E };
            case "1.2.840.10040.4.1":
              return E.algorithm.params.pub_key = K.DSAparam.decode(E.subjectPublicKey.data, "der"), { type: "dsa", data: E.algorithm.params };
            default:
              throw Error("unknown key id " + h);
          }
        case "ENCRYPTED PRIVATE KEY":
          N = K.EncryptedPrivateKey.decode(N, "der"), N = J(N, f);
        case "PRIVATE KEY":
          switch (E = K.PrivateKey.decode(N, "der"), h = E.algorithm.algorithm.join("."), h) {
            case "1.2.840.113549.1.1.1":
              return K.RSAPrivateKey.decode(E.subjectPrivateKey, "der");
            case "1.2.840.10045.2.1":
              return { curve: E.algorithm.curve, privateKey: K.ECPrivateKey.decode(E.subjectPrivateKey, "der").privateKey };
            case "1.2.840.10040.4.1":
              return E.algorithm.params.priv_key = K.DSAparam.decode(E.subjectPrivateKey, "der"), { type: "dsa", params: E.algorithm.params };
            default:
              throw Error("unknown key id " + h);
          }
        case "RSA PUBLIC KEY":
          return K.RSAPublicKey.decode(N, "der");
        case "RSA PRIVATE KEY":
          return K.RSAPrivateKey.decode(N, "der");
        case "DSA PRIVATE KEY":
          return { type: "dsa", params: K.DSAPrivateKey.decode(N, "der") };
        case "EC PRIVATE KEY":
          return N = K.ECPrivateKey.decode(N, "der"), { curve: N.parameters.value, privateKey: N.privateKey };
        default:
          throw Error("unknown key type " + M);
      }
    }
    T.signature = K.signature, q.exports = T;
  }), T0 = r$(($18, q) => {
    var K = OO(), P = $8().Buffer;
    q.exports = function(Y, O) {
      var z = P.alloc(0), J = 0, T;
      while (z.length < O) T = _(J++), z = P.concat([z, K("sha1").update(Y).update(T).digest()]);
      return z.slice(0, O);
    };
    function _(Y) {
      var O = P.allocUnsafe(4);
      return O.writeUInt32BE(Y, 0), O;
    }
  }), w0 = r$(($18, q) => {
    q.exports = function(K, P) {
      var _ = K.length, Y = -1;
      while (++Y < _) K[Y] ^= P[Y];
      return K;
    };
  }), iH = r$(($18, q) => {
    (function(K, P) {
      function _(j, H) {
        if (!j) throw Error(H || "Assertion failed");
      }
      function Y(j, H) {
        j.super_ = H;
        var Z = function() {
        };
        Z.prototype = H.prototype, j.prototype = new Z(), j.prototype.constructor = j;
      }
      function O(j, H, Z) {
        if (O.isBN(j)) return j;
        if (this.negative = 0, this.words = null, this.length = 0, this.red = null, j !== null) {
          if (H === "le" || H === "be") Z = H, H = 10;
          this._init(j || 0, H || 10, Z || "be");
        }
      }
      if (typeof K === "object") K.exports = O;
      else P.BN = O;
      O.BN = O, O.wordSize = 26;
      var z;
      try {
        if (typeof window < "u" && typeof window.Buffer < "u") z = window.Buffer;
        else z = (wq(), J6(Tq)).Buffer;
      } catch (j) {
      }
      O.isBN = function(j) {
        if (j instanceof O) return true;
        return j !== null && typeof j === "object" && j.constructor.wordSize === O.wordSize && Array.isArray(j.words);
      }, O.max = function(j, H) {
        if (j.cmp(H) > 0) return j;
        return H;
      }, O.min = function(j, H) {
        if (j.cmp(H) < 0) return j;
        return H;
      }, O.prototype._init = function(j, H, Z) {
        if (typeof j === "number") return this._initNumber(j, H, Z);
        if (typeof j === "object") return this._initArray(j, H, Z);
        if (H === "hex") H = 16;
        _(H === (H | 0) && H >= 2 && H <= 36), j = j.toString().replace(/\s+/g, "");
        var W = 0;
        if (j[0] === "-") W++, this.negative = 1;
        if (W < j.length) {
          if (H === 16) this._parseHex(j, W, Z);
          else if (this._parseBase(j, H, W), Z === "le") this._initArray(this.toArray(), H, Z);
        }
      }, O.prototype._initNumber = function(j, H, Z) {
        if (j < 0) this.negative = 1, j = -j;
        if (j < 67108864) this.words = [j & 67108863], this.length = 1;
        else if (j < 4503599627370496) this.words = [j & 67108863, j / 67108864 & 67108863], this.length = 2;
        else _(j < 9007199254740992), this.words = [j & 67108863, j / 67108864 & 67108863, 1], this.length = 3;
        if (Z !== "le") return;
        this._initArray(this.toArray(), H, Z);
      }, O.prototype._initArray = function(j, H, Z) {
        if (_(typeof j.length === "number"), j.length <= 0) return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(j.length / 3), this.words = Array(this.length);
        for (var W = 0; W < this.length; W++) this.words[W] = 0;
        var w, G, S = 0;
        if (Z === "be") {
          for (W = j.length - 1, w = 0; W >= 0; W -= 3) if (G = j[W] | j[W - 1] << 8 | j[W - 2] << 16, this.words[w] |= G << S & 67108863, this.words[w + 1] = G >>> 26 - S & 67108863, S += 24, S >= 26) S -= 26, w++;
        } else if (Z === "le") {
          for (W = 0, w = 0; W < j.length; W += 3) if (G = j[W] | j[W + 1] << 8 | j[W + 2] << 16, this.words[w] |= G << S & 67108863, this.words[w + 1] = G >>> 26 - S & 67108863, S += 24, S >= 26) S -= 26, w++;
        }
        return this.strip();
      };
      function J(j, H) {
        var Z = j.charCodeAt(H);
        if (Z >= 65 && Z <= 70) return Z - 55;
        else if (Z >= 97 && Z <= 102) return Z - 87;
        else return Z - 48 & 15;
      }
      function T(j, H, Z) {
        var W = J(j, Z);
        if (Z - 1 >= H) W |= J(j, Z - 1) << 4;
        return W;
      }
      O.prototype._parseHex = function(j, H, Z) {
        this.length = Math.ceil((j.length - H) / 6), this.words = Array(this.length);
        for (var W = 0; W < this.length; W++) this.words[W] = 0;
        var w = 0, G = 0, S;
        if (Z === "be") for (W = j.length - 1; W >= H; W -= 2) if (S = T(j, H, W) << w, this.words[G] |= S & 67108863, w >= 18) w -= 18, G += 1, this.words[G] |= S >>> 26;
        else w += 8;
        else {
          var A = j.length - H;
          for (W = A % 2 === 0 ? H + 1 : H; W < j.length; W += 2) if (S = T(j, H, W) << w, this.words[G] |= S & 67108863, w >= 18) w -= 18, G += 1, this.words[G] |= S >>> 26;
          else w += 8;
        }
        this.strip();
      };
      function X(j, H, Z, W) {
        var w = 0, G = Math.min(j.length, Z);
        for (var S = H; S < G; S++) {
          var A = j.charCodeAt(S) - 48;
          if (w *= W, A >= 49) w += A - 49 + 10;
          else if (A >= 17) w += A - 17 + 10;
          else w += A;
        }
        return w;
      }
      O.prototype._parseBase = function(j, H, Z) {
        this.words = [0], this.length = 1;
        for (var W = 0, w = 1; w <= 67108863; w *= H) W++;
        W--, w = w / H | 0;
        var G = j.length - Z, S = G % W, A = Math.min(G, G - S) + Z, v = 0;
        for (var k = Z; k < A; k += W) if (v = X(j, k, k + W, H), this.imuln(w), this.words[0] + v < 67108864) this.words[0] += v;
        else this._iaddn(v);
        if (S !== 0) {
          var R = 1;
          v = X(j, k, j.length, H);
          for (k = 0; k < S; k++) R *= H;
          if (this.imuln(R), this.words[0] + v < 67108864) this.words[0] += v;
          else this._iaddn(v);
        }
        this.strip();
      }, O.prototype.copy = function(j) {
        j.words = Array(this.length);
        for (var H = 0; H < this.length; H++) j.words[H] = this.words[H];
        j.length = this.length, j.negative = this.negative, j.red = this.red;
      }, O.prototype.clone = function() {
        var j = new O(null);
        return this.copy(j), j;
      }, O.prototype._expand = function(j) {
        while (this.length < j) this.words[this.length++] = 0;
        return this;
      }, O.prototype.strip = function() {
        while (this.length > 1 && this.words[this.length - 1] === 0) this.length--;
        return this._normSign();
      }, O.prototype._normSign = function() {
        if (this.length === 1 && this.words[0] === 0) this.negative = 0;
        return this;
      }, O.prototype.inspect = function() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var f = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], V = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], M = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
      if (O.prototype.toString = function(j, H) {
        j = j || 10, H = H | 0 || 1;
        var Z;
        if (j === 16 || j === "hex") {
          Z = "";
          var W = 0, w = 0;
          for (var G = 0; G < this.length; G++) {
            var S = this.words[G], A = ((S << W | w) & 16777215).toString(16);
            if (w = S >>> 24 - W & 16777215, W += 2, W >= 26) W -= 26, G--;
            if (w !== 0 || G !== this.length - 1) Z = f[6 - A.length] + A + Z;
            else Z = A + Z;
          }
          if (w !== 0) Z = w.toString(16) + Z;
          while (Z.length % H !== 0) Z = "0" + Z;
          if (this.negative !== 0) Z = "-" + Z;
          return Z;
        }
        if (j === (j | 0) && j >= 2 && j <= 36) {
          var v = V[j], k = M[j];
          Z = "";
          var R = this.clone();
          R.negative = 0;
          while (!R.isZero()) {
            var C = R.modn(k).toString(j);
            if (R = R.idivn(k), !R.isZero()) Z = f[v - C.length] + C + Z;
            else Z = C + Z;
          }
          if (this.isZero()) Z = "0" + Z;
          while (Z.length % H !== 0) Z = "0" + Z;
          if (this.negative !== 0) Z = "-" + Z;
          return Z;
        }
        _(false, "Base should be between 2 and 36");
      }, O.prototype.toNumber = function() {
        var j = this.words[0];
        if (this.length === 2) j += this.words[1] * 67108864;
        else if (this.length === 3 && this.words[2] === 1) j += 4503599627370496 + this.words[1] * 67108864;
        else if (this.length > 2) _(false, "Number can only safely store up to 53 bits");
        return this.negative !== 0 ? -j : j;
      }, O.prototype.toJSON = function() {
        return this.toString(16);
      }, O.prototype.toBuffer = function(j, H) {
        return _(typeof z < "u"), this.toArrayLike(z, j, H);
      }, O.prototype.toArray = function(j, H) {
        return this.toArrayLike(Array, j, H);
      }, O.prototype.toArrayLike = function(j, H, Z) {
        var W = this.byteLength(), w = Z || Math.max(1, W);
        _(W <= w, "byte array longer than desired length"), _(w > 0, "Requested array length <= 0"), this.strip();
        var G = H === "le", S = new j(w), A, v, k = this.clone();
        if (!G) {
          for (v = 0; v < w - W; v++) S[v] = 0;
          for (v = 0; !k.isZero(); v++) A = k.andln(255), k.iushrn(8), S[w - v - 1] = A;
        } else {
          for (v = 0; !k.isZero(); v++) A = k.andln(255), k.iushrn(8), S[v] = A;
          for (; v < w; v++) S[v] = 0;
        }
        return S;
      }, Math.clz32) O.prototype._countBits = function(j) {
        return 32 - Math.clz32(j);
      };
      else O.prototype._countBits = function(j) {
        var H = j, Z = 0;
        if (H >= 4096) Z += 13, H >>>= 13;
        if (H >= 64) Z += 7, H >>>= 7;
        if (H >= 8) Z += 4, H >>>= 4;
        if (H >= 2) Z += 2, H >>>= 2;
        return Z + H;
      };
      O.prototype._zeroBits = function(j) {
        if (j === 0) return 26;
        var H = j, Z = 0;
        if ((H & 8191) === 0) Z += 13, H >>>= 13;
        if ((H & 127) === 0) Z += 7, H >>>= 7;
        if ((H & 15) === 0) Z += 4, H >>>= 4;
        if ((H & 3) === 0) Z += 2, H >>>= 2;
        if ((H & 1) === 0) Z++;
        return Z;
      }, O.prototype.bitLength = function() {
        var j = this.words[this.length - 1], H = this._countBits(j);
        return (this.length - 1) * 26 + H;
      };
      function N(j) {
        var H = Array(j.bitLength());
        for (var Z = 0; Z < H.length; Z++) {
          var W = Z / 26 | 0, w = Z % 26;
          H[Z] = (j.words[W] & 1 << w) >>> w;
        }
        return H;
      }
      O.prototype.zeroBits = function() {
        if (this.isZero()) return 0;
        var j = 0;
        for (var H = 0; H < this.length; H++) {
          var Z = this._zeroBits(this.words[H]);
          if (j += Z, Z !== 26) break;
        }
        return j;
      }, O.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, O.prototype.toTwos = function(j) {
        if (this.negative !== 0) return this.abs().inotn(j).iaddn(1);
        return this.clone();
      }, O.prototype.fromTwos = function(j) {
        if (this.testn(j - 1)) return this.notn(j).iaddn(1).ineg();
        return this.clone();
      }, O.prototype.isNeg = function() {
        return this.negative !== 0;
      }, O.prototype.neg = function() {
        return this.clone().ineg();
      }, O.prototype.ineg = function() {
        if (!this.isZero()) this.negative ^= 1;
        return this;
      }, O.prototype.iuor = function(j) {
        while (this.length < j.length) this.words[this.length++] = 0;
        for (var H = 0; H < j.length; H++) this.words[H] = this.words[H] | j.words[H];
        return this.strip();
      }, O.prototype.ior = function(j) {
        return _((this.negative | j.negative) === 0), this.iuor(j);
      }, O.prototype.or = function(j) {
        if (this.length > j.length) return this.clone().ior(j);
        return j.clone().ior(this);
      }, O.prototype.uor = function(j) {
        if (this.length > j.length) return this.clone().iuor(j);
        return j.clone().iuor(this);
      }, O.prototype.iuand = function(j) {
        var H;
        if (this.length > j.length) H = j;
        else H = this;
        for (var Z = 0; Z < H.length; Z++) this.words[Z] = this.words[Z] & j.words[Z];
        return this.length = H.length, this.strip();
      }, O.prototype.iand = function(j) {
        return _((this.negative | j.negative) === 0), this.iuand(j);
      }, O.prototype.and = function(j) {
        if (this.length > j.length) return this.clone().iand(j);
        return j.clone().iand(this);
      }, O.prototype.uand = function(j) {
        if (this.length > j.length) return this.clone().iuand(j);
        return j.clone().iuand(this);
      }, O.prototype.iuxor = function(j) {
        var H, Z;
        if (this.length > j.length) H = this, Z = j;
        else H = j, Z = this;
        for (var W = 0; W < Z.length; W++) this.words[W] = H.words[W] ^ Z.words[W];
        if (this !== H) for (; W < H.length; W++) this.words[W] = H.words[W];
        return this.length = H.length, this.strip();
      }, O.prototype.ixor = function(j) {
        return _((this.negative | j.negative) === 0), this.iuxor(j);
      }, O.prototype.xor = function(j) {
        if (this.length > j.length) return this.clone().ixor(j);
        return j.clone().ixor(this);
      }, O.prototype.uxor = function(j) {
        if (this.length > j.length) return this.clone().iuxor(j);
        return j.clone().iuxor(this);
      }, O.prototype.inotn = function(j) {
        _(typeof j === "number" && j >= 0);
        var H = Math.ceil(j / 26) | 0, Z = j % 26;
        if (this._expand(H), Z > 0) H--;
        for (var W = 0; W < H; W++) this.words[W] = ~this.words[W] & 67108863;
        if (Z > 0) this.words[W] = ~this.words[W] & 67108863 >> 26 - Z;
        return this.strip();
      }, O.prototype.notn = function(j) {
        return this.clone().inotn(j);
      }, O.prototype.setn = function(j, H) {
        _(typeof j === "number" && j >= 0);
        var Z = j / 26 | 0, W = j % 26;
        if (this._expand(Z + 1), H) this.words[Z] = this.words[Z] | 1 << W;
        else this.words[Z] = this.words[Z] & ~(1 << W);
        return this.strip();
      }, O.prototype.iadd = function(j) {
        var H;
        if (this.negative !== 0 && j.negative === 0) return this.negative = 0, H = this.isub(j), this.negative ^= 1, this._normSign();
        else if (this.negative === 0 && j.negative !== 0) return j.negative = 0, H = this.isub(j), j.negative = 1, H._normSign();
        var Z, W;
        if (this.length > j.length) Z = this, W = j;
        else Z = j, W = this;
        var w = 0;
        for (var G = 0; G < W.length; G++) H = (Z.words[G] | 0) + (W.words[G] | 0) + w, this.words[G] = H & 67108863, w = H >>> 26;
        for (; w !== 0 && G < Z.length; G++) H = (Z.words[G] | 0) + w, this.words[G] = H & 67108863, w = H >>> 26;
        if (this.length = Z.length, w !== 0) this.words[this.length] = w, this.length++;
        else if (Z !== this) for (; G < Z.length; G++) this.words[G] = Z.words[G];
        return this;
      }, O.prototype.add = function(j) {
        var H;
        if (j.negative !== 0 && this.negative === 0) return j.negative = 0, H = this.sub(j), j.negative ^= 1, H;
        else if (j.negative === 0 && this.negative !== 0) return this.negative = 0, H = j.sub(this), this.negative = 1, H;
        if (this.length > j.length) return this.clone().iadd(j);
        return j.clone().iadd(this);
      }, O.prototype.isub = function(j) {
        if (j.negative !== 0) {
          j.negative = 0;
          var H = this.iadd(j);
          return j.negative = 1, H._normSign();
        } else if (this.negative !== 0) return this.negative = 0, this.iadd(j), this.negative = 1, this._normSign();
        var Z = this.cmp(j);
        if (Z === 0) return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var W, w;
        if (Z > 0) W = this, w = j;
        else W = j, w = this;
        var G = 0;
        for (var S = 0; S < w.length; S++) H = (W.words[S] | 0) - (w.words[S] | 0) + G, G = H >> 26, this.words[S] = H & 67108863;
        for (; G !== 0 && S < W.length; S++) H = (W.words[S] | 0) + G, G = H >> 26, this.words[S] = H & 67108863;
        if (G === 0 && S < W.length && W !== this) for (; S < W.length; S++) this.words[S] = W.words[S];
        if (this.length = Math.max(this.length, S), W !== this) this.negative = 1;
        return this.strip();
      }, O.prototype.sub = function(j) {
        return this.clone().isub(j);
      };
      function h(j, H, Z) {
        Z.negative = H.negative ^ j.negative;
        var W = j.length + H.length | 0;
        Z.length = W, W = W - 1 | 0;
        var w = j.words[0] | 0, G = H.words[0] | 0, S = w * G, A = S & 67108863, v = S / 67108864 | 0;
        Z.words[0] = A;
        for (var k = 1; k < W; k++) {
          var R = v >>> 26, C = v & 67108863, L = Math.min(k, H.length - 1);
          for (var x = Math.max(0, k - j.length + 1); x <= L; x++) {
            var l = k - x | 0;
            w = j.words[l] | 0, G = H.words[x] | 0, S = w * G + C, R += S / 67108864 | 0, C = S & 67108863;
          }
          Z.words[k] = C | 0, v = R | 0;
        }
        if (v !== 0) Z.words[k] = v | 0;
        else Z.length--;
        return Z.strip();
      }
      var E = function(j, H, Z) {
        var W = j.words, w = H.words, G = Z.words, S = 0, A, v, k, R = W[0] | 0, C = R & 8191, L = R >>> 13, x = W[1] | 0, l = x & 8191, a = x >>> 13, f$ = W[2] | 0, $$ = f$ & 8191, B = f$ >>> 13, H$ = W[3] | 0, Q = H$ & 8191, v$ = H$ >>> 13, t$ = W[4] | 0, m = t$ & 8191, r = t$ >>> 13, J$ = W[5] | 0, e = J$ & 8191, _$2 = J$ >>> 13, Y$ = W[6] | 0, d = Y$ & 8191, o = Y$ >>> 13, W$ = W[7] | 0, t = W$ & 8191, F = W$ >>> 13, X$ = W[8] | 0, z$ = X$ & 8191, j$ = X$ >>> 13, X6 = W[9] | 0, Z$ = X6 & 8191, A$ = X6 >>> 13, d6 = w[0] | 0, S$ = d6 & 8191, V$ = d6 >>> 13, Sq = w[1] | 0, N$ = Sq & 8191, D$ = Sq >>> 13, Mq = w[2] | 0, L$ = Mq & 8191, C$ = Mq >>> 13, fq = w[3] | 0, g$ = fq & 8191, E$ = fq >>> 13, vq = w[4] | 0, b$ = vq & 8191, y$ = vq >>> 13, zq = w[5] | 0, h$ = zq & 8191, u = zq >>> 13, i = w[6] | 0, K$ = i & 8191, P$ = i >>> 13, i$ = w[7] | 0, k$ = i$ & 8191, G$ = i$ >>> 13, x6 = w[8] | 0, R$ = x6 & 8191, u$ = x6 >>> 13, Zq = w[9] | 0, I$ = Zq & 8191, M$ = Zq >>> 13;
        Z.negative = j.negative ^ H.negative, Z.length = 19, A = Math.imul(C, S$), v = Math.imul(C, V$), v = v + Math.imul(L, S$) | 0, k = Math.imul(L, V$);
        var p6 = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (p6 >>> 26) | 0, p6 &= 67108863, A = Math.imul(l, S$), v = Math.imul(l, V$), v = v + Math.imul(a, S$) | 0, k = Math.imul(a, V$), A = A + Math.imul(C, N$) | 0, v = v + Math.imul(C, D$) | 0, v = v + Math.imul(L, N$) | 0, k = k + Math.imul(L, D$) | 0;
        var H6 = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (H6 >>> 26) | 0, H6 &= 67108863, A = Math.imul($$, S$), v = Math.imul($$, V$), v = v + Math.imul(B, S$) | 0, k = Math.imul(B, V$), A = A + Math.imul(l, N$) | 0, v = v + Math.imul(l, D$) | 0, v = v + Math.imul(a, N$) | 0, k = k + Math.imul(a, D$) | 0, A = A + Math.imul(C, L$) | 0, v = v + Math.imul(C, C$) | 0, v = v + Math.imul(L, L$) | 0, k = k + Math.imul(L, C$) | 0;
        var v6 = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (v6 >>> 26) | 0, v6 &= 67108863, A = Math.imul(Q, S$), v = Math.imul(Q, V$), v = v + Math.imul(v$, S$) | 0, k = Math.imul(v$, V$), A = A + Math.imul($$, N$) | 0, v = v + Math.imul($$, D$) | 0, v = v + Math.imul(B, N$) | 0, k = k + Math.imul(B, D$) | 0, A = A + Math.imul(l, L$) | 0, v = v + Math.imul(l, C$) | 0, v = v + Math.imul(a, L$) | 0, k = k + Math.imul(a, C$) | 0, A = A + Math.imul(C, g$) | 0, v = v + Math.imul(C, E$) | 0, v = v + Math.imul(L, g$) | 0, k = k + Math.imul(L, E$) | 0;
        var C6 = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (C6 >>> 26) | 0, C6 &= 67108863, A = Math.imul(m, S$), v = Math.imul(m, V$), v = v + Math.imul(r, S$) | 0, k = Math.imul(r, V$), A = A + Math.imul(Q, N$) | 0, v = v + Math.imul(Q, D$) | 0, v = v + Math.imul(v$, N$) | 0, k = k + Math.imul(v$, D$) | 0, A = A + Math.imul($$, L$) | 0, v = v + Math.imul($$, C$) | 0, v = v + Math.imul(B, L$) | 0, k = k + Math.imul(B, C$) | 0, A = A + Math.imul(l, g$) | 0, v = v + Math.imul(l, E$) | 0, v = v + Math.imul(a, g$) | 0, k = k + Math.imul(a, E$) | 0, A = A + Math.imul(C, b$) | 0, v = v + Math.imul(C, y$) | 0, v = v + Math.imul(L, b$) | 0, k = k + Math.imul(L, y$) | 0;
        var S6 = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (S6 >>> 26) | 0, S6 &= 67108863, A = Math.imul(e, S$), v = Math.imul(e, V$), v = v + Math.imul(_$2, S$) | 0, k = Math.imul(_$2, V$), A = A + Math.imul(m, N$) | 0, v = v + Math.imul(m, D$) | 0, v = v + Math.imul(r, N$) | 0, k = k + Math.imul(r, D$) | 0, A = A + Math.imul(Q, L$) | 0, v = v + Math.imul(Q, C$) | 0, v = v + Math.imul(v$, L$) | 0, k = k + Math.imul(v$, C$) | 0, A = A + Math.imul($$, g$) | 0, v = v + Math.imul($$, E$) | 0, v = v + Math.imul(B, g$) | 0, k = k + Math.imul(B, E$) | 0, A = A + Math.imul(l, b$) | 0, v = v + Math.imul(l, y$) | 0, v = v + Math.imul(a, b$) | 0, k = k + Math.imul(a, y$) | 0, A = A + Math.imul(C, h$) | 0, v = v + Math.imul(C, u) | 0, v = v + Math.imul(L, h$) | 0, k = k + Math.imul(L, u) | 0;
        var i6 = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (i6 >>> 26) | 0, i6 &= 67108863, A = Math.imul(d, S$), v = Math.imul(d, V$), v = v + Math.imul(o, S$) | 0, k = Math.imul(o, V$), A = A + Math.imul(e, N$) | 0, v = v + Math.imul(e, D$) | 0, v = v + Math.imul(_$2, N$) | 0, k = k + Math.imul(_$2, D$) | 0, A = A + Math.imul(m, L$) | 0, v = v + Math.imul(m, C$) | 0, v = v + Math.imul(r, L$) | 0, k = k + Math.imul(r, C$) | 0, A = A + Math.imul(Q, g$) | 0, v = v + Math.imul(Q, E$) | 0, v = v + Math.imul(v$, g$) | 0, k = k + Math.imul(v$, E$) | 0, A = A + Math.imul($$, b$) | 0, v = v + Math.imul($$, y$) | 0, v = v + Math.imul(B, b$) | 0, k = k + Math.imul(B, y$) | 0, A = A + Math.imul(l, h$) | 0, v = v + Math.imul(l, u) | 0, v = v + Math.imul(a, h$) | 0, k = k + Math.imul(a, u) | 0, A = A + Math.imul(C, K$) | 0, v = v + Math.imul(C, P$) | 0, v = v + Math.imul(L, K$) | 0, k = k + Math.imul(L, P$) | 0;
        var B6 = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (B6 >>> 26) | 0, B6 &= 67108863, A = Math.imul(t, S$), v = Math.imul(t, V$), v = v + Math.imul(F, S$) | 0, k = Math.imul(F, V$), A = A + Math.imul(d, N$) | 0, v = v + Math.imul(d, D$) | 0, v = v + Math.imul(o, N$) | 0, k = k + Math.imul(o, D$) | 0, A = A + Math.imul(e, L$) | 0, v = v + Math.imul(e, C$) | 0, v = v + Math.imul(_$2, L$) | 0, k = k + Math.imul(_$2, C$) | 0, A = A + Math.imul(m, g$) | 0, v = v + Math.imul(m, E$) | 0, v = v + Math.imul(r, g$) | 0, k = k + Math.imul(r, E$) | 0, A = A + Math.imul(Q, b$) | 0, v = v + Math.imul(Q, y$) | 0, v = v + Math.imul(v$, b$) | 0, k = k + Math.imul(v$, y$) | 0, A = A + Math.imul($$, h$) | 0, v = v + Math.imul($$, u) | 0, v = v + Math.imul(B, h$) | 0, k = k + Math.imul(B, u) | 0, A = A + Math.imul(l, K$) | 0, v = v + Math.imul(l, P$) | 0, v = v + Math.imul(a, K$) | 0, k = k + Math.imul(a, P$) | 0, A = A + Math.imul(C, k$) | 0, v = v + Math.imul(C, G$) | 0, v = v + Math.imul(L, k$) | 0, k = k + Math.imul(L, G$) | 0;
        var t6 = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (t6 >>> 26) | 0, t6 &= 67108863, A = Math.imul(z$, S$), v = Math.imul(z$, V$), v = v + Math.imul(j$, S$) | 0, k = Math.imul(j$, V$), A = A + Math.imul(t, N$) | 0, v = v + Math.imul(t, D$) | 0, v = v + Math.imul(F, N$) | 0, k = k + Math.imul(F, D$) | 0, A = A + Math.imul(d, L$) | 0, v = v + Math.imul(d, C$) | 0, v = v + Math.imul(o, L$) | 0, k = k + Math.imul(o, C$) | 0, A = A + Math.imul(e, g$) | 0, v = v + Math.imul(e, E$) | 0, v = v + Math.imul(_$2, g$) | 0, k = k + Math.imul(_$2, E$) | 0, A = A + Math.imul(m, b$) | 0, v = v + Math.imul(m, y$) | 0, v = v + Math.imul(r, b$) | 0, k = k + Math.imul(r, y$) | 0, A = A + Math.imul(Q, h$) | 0, v = v + Math.imul(Q, u) | 0, v = v + Math.imul(v$, h$) | 0, k = k + Math.imul(v$, u) | 0, A = A + Math.imul($$, K$) | 0, v = v + Math.imul($$, P$) | 0, v = v + Math.imul(B, K$) | 0, k = k + Math.imul(B, P$) | 0, A = A + Math.imul(l, k$) | 0, v = v + Math.imul(l, G$) | 0, v = v + Math.imul(a, k$) | 0, k = k + Math.imul(a, G$) | 0, A = A + Math.imul(C, R$) | 0, v = v + Math.imul(C, u$) | 0, v = v + Math.imul(L, R$) | 0, k = k + Math.imul(L, u$) | 0;
        var U6 = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (U6 >>> 26) | 0, U6 &= 67108863, A = Math.imul(Z$, S$), v = Math.imul(Z$, V$), v = v + Math.imul(A$, S$) | 0, k = Math.imul(A$, V$), A = A + Math.imul(z$, N$) | 0, v = v + Math.imul(z$, D$) | 0, v = v + Math.imul(j$, N$) | 0, k = k + Math.imul(j$, D$) | 0, A = A + Math.imul(t, L$) | 0, v = v + Math.imul(t, C$) | 0, v = v + Math.imul(F, L$) | 0, k = k + Math.imul(F, C$) | 0, A = A + Math.imul(d, g$) | 0, v = v + Math.imul(d, E$) | 0, v = v + Math.imul(o, g$) | 0, k = k + Math.imul(o, E$) | 0, A = A + Math.imul(e, b$) | 0, v = v + Math.imul(e, y$) | 0, v = v + Math.imul(_$2, b$) | 0, k = k + Math.imul(_$2, y$) | 0, A = A + Math.imul(m, h$) | 0, v = v + Math.imul(m, u) | 0, v = v + Math.imul(r, h$) | 0, k = k + Math.imul(r, u) | 0, A = A + Math.imul(Q, K$) | 0, v = v + Math.imul(Q, P$) | 0, v = v + Math.imul(v$, K$) | 0, k = k + Math.imul(v$, P$) | 0, A = A + Math.imul($$, k$) | 0, v = v + Math.imul($$, G$) | 0, v = v + Math.imul(B, k$) | 0, k = k + Math.imul(B, G$) | 0, A = A + Math.imul(l, R$) | 0, v = v + Math.imul(l, u$) | 0, v = v + Math.imul(a, R$) | 0, k = k + Math.imul(a, u$) | 0, A = A + Math.imul(C, I$) | 0, v = v + Math.imul(C, M$) | 0, v = v + Math.imul(L, I$) | 0, k = k + Math.imul(L, M$) | 0;
        var F6 = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (F6 >>> 26) | 0, F6 &= 67108863, A = Math.imul(Z$, N$), v = Math.imul(Z$, D$), v = v + Math.imul(A$, N$) | 0, k = Math.imul(A$, D$), A = A + Math.imul(z$, L$) | 0, v = v + Math.imul(z$, C$) | 0, v = v + Math.imul(j$, L$) | 0, k = k + Math.imul(j$, C$) | 0, A = A + Math.imul(t, g$) | 0, v = v + Math.imul(t, E$) | 0, v = v + Math.imul(F, g$) | 0, k = k + Math.imul(F, E$) | 0, A = A + Math.imul(d, b$) | 0, v = v + Math.imul(d, y$) | 0, v = v + Math.imul(o, b$) | 0, k = k + Math.imul(o, y$) | 0, A = A + Math.imul(e, h$) | 0, v = v + Math.imul(e, u) | 0, v = v + Math.imul(_$2, h$) | 0, k = k + Math.imul(_$2, u) | 0, A = A + Math.imul(m, K$) | 0, v = v + Math.imul(m, P$) | 0, v = v + Math.imul(r, K$) | 0, k = k + Math.imul(r, P$) | 0, A = A + Math.imul(Q, k$) | 0, v = v + Math.imul(Q, G$) | 0, v = v + Math.imul(v$, k$) | 0, k = k + Math.imul(v$, G$) | 0, A = A + Math.imul($$, R$) | 0, v = v + Math.imul($$, u$) | 0, v = v + Math.imul(B, R$) | 0, k = k + Math.imul(B, u$) | 0, A = A + Math.imul(l, I$) | 0, v = v + Math.imul(l, M$) | 0, v = v + Math.imul(a, I$) | 0, k = k + Math.imul(a, M$) | 0;
        var a6 = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (a6 >>> 26) | 0, a6 &= 67108863, A = Math.imul(Z$, L$), v = Math.imul(Z$, C$), v = v + Math.imul(A$, L$) | 0, k = Math.imul(A$, C$), A = A + Math.imul(z$, g$) | 0, v = v + Math.imul(z$, E$) | 0, v = v + Math.imul(j$, g$) | 0, k = k + Math.imul(j$, E$) | 0, A = A + Math.imul(t, b$) | 0, v = v + Math.imul(t, y$) | 0, v = v + Math.imul(F, b$) | 0, k = k + Math.imul(F, y$) | 0, A = A + Math.imul(d, h$) | 0, v = v + Math.imul(d, u) | 0, v = v + Math.imul(o, h$) | 0, k = k + Math.imul(o, u) | 0, A = A + Math.imul(e, K$) | 0, v = v + Math.imul(e, P$) | 0, v = v + Math.imul(_$2, K$) | 0, k = k + Math.imul(_$2, P$) | 0, A = A + Math.imul(m, k$) | 0, v = v + Math.imul(m, G$) | 0, v = v + Math.imul(r, k$) | 0, k = k + Math.imul(r, G$) | 0, A = A + Math.imul(Q, R$) | 0, v = v + Math.imul(Q, u$) | 0, v = v + Math.imul(v$, R$) | 0, k = k + Math.imul(v$, u$) | 0, A = A + Math.imul($$, I$) | 0, v = v + Math.imul($$, M$) | 0, v = v + Math.imul(B, I$) | 0, k = k + Math.imul(B, M$) | 0;
        var Q6 = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (Q6 >>> 26) | 0, Q6 &= 67108863, A = Math.imul(Z$, g$), v = Math.imul(Z$, E$), v = v + Math.imul(A$, g$) | 0, k = Math.imul(A$, E$), A = A + Math.imul(z$, b$) | 0, v = v + Math.imul(z$, y$) | 0, v = v + Math.imul(j$, b$) | 0, k = k + Math.imul(j$, y$) | 0, A = A + Math.imul(t, h$) | 0, v = v + Math.imul(t, u) | 0, v = v + Math.imul(F, h$) | 0, k = k + Math.imul(F, u) | 0, A = A + Math.imul(d, K$) | 0, v = v + Math.imul(d, P$) | 0, v = v + Math.imul(o, K$) | 0, k = k + Math.imul(o, P$) | 0, A = A + Math.imul(e, k$) | 0, v = v + Math.imul(e, G$) | 0, v = v + Math.imul(_$2, k$) | 0, k = k + Math.imul(_$2, G$) | 0, A = A + Math.imul(m, R$) | 0, v = v + Math.imul(m, u$) | 0, v = v + Math.imul(r, R$) | 0, k = k + Math.imul(r, u$) | 0, A = A + Math.imul(Q, I$) | 0, v = v + Math.imul(Q, M$) | 0, v = v + Math.imul(v$, I$) | 0, k = k + Math.imul(v$, M$) | 0;
        var e6 = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (e6 >>> 26) | 0, e6 &= 67108863, A = Math.imul(Z$, b$), v = Math.imul(Z$, y$), v = v + Math.imul(A$, b$) | 0, k = Math.imul(A$, y$), A = A + Math.imul(z$, h$) | 0, v = v + Math.imul(z$, u) | 0, v = v + Math.imul(j$, h$) | 0, k = k + Math.imul(j$, u) | 0, A = A + Math.imul(t, K$) | 0, v = v + Math.imul(t, P$) | 0, v = v + Math.imul(F, K$) | 0, k = k + Math.imul(F, P$) | 0, A = A + Math.imul(d, k$) | 0, v = v + Math.imul(d, G$) | 0, v = v + Math.imul(o, k$) | 0, k = k + Math.imul(o, G$) | 0, A = A + Math.imul(e, R$) | 0, v = v + Math.imul(e, u$) | 0, v = v + Math.imul(_$2, R$) | 0, k = k + Math.imul(_$2, u$) | 0, A = A + Math.imul(m, I$) | 0, v = v + Math.imul(m, M$) | 0, v = v + Math.imul(r, I$) | 0, k = k + Math.imul(r, M$) | 0;
        var s6 = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (s6 >>> 26) | 0, s6 &= 67108863, A = Math.imul(Z$, h$), v = Math.imul(Z$, u), v = v + Math.imul(A$, h$) | 0, k = Math.imul(A$, u), A = A + Math.imul(z$, K$) | 0, v = v + Math.imul(z$, P$) | 0, v = v + Math.imul(j$, K$) | 0, k = k + Math.imul(j$, P$) | 0, A = A + Math.imul(t, k$) | 0, v = v + Math.imul(t, G$) | 0, v = v + Math.imul(F, k$) | 0, k = k + Math.imul(F, G$) | 0, A = A + Math.imul(d, R$) | 0, v = v + Math.imul(d, u$) | 0, v = v + Math.imul(o, R$) | 0, k = k + Math.imul(o, u$) | 0, A = A + Math.imul(e, I$) | 0, v = v + Math.imul(e, M$) | 0, v = v + Math.imul(_$2, I$) | 0, k = k + Math.imul(_$2, M$) | 0;
        var $q = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + ($q >>> 26) | 0, $q &= 67108863, A = Math.imul(Z$, K$), v = Math.imul(Z$, P$), v = v + Math.imul(A$, K$) | 0, k = Math.imul(A$, P$), A = A + Math.imul(z$, k$) | 0, v = v + Math.imul(z$, G$) | 0, v = v + Math.imul(j$, k$) | 0, k = k + Math.imul(j$, G$) | 0, A = A + Math.imul(t, R$) | 0, v = v + Math.imul(t, u$) | 0, v = v + Math.imul(F, R$) | 0, k = k + Math.imul(F, u$) | 0, A = A + Math.imul(d, I$) | 0, v = v + Math.imul(d, M$) | 0, v = v + Math.imul(o, I$) | 0, k = k + Math.imul(o, M$) | 0;
        var qq = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (qq >>> 26) | 0, qq &= 67108863, A = Math.imul(Z$, k$), v = Math.imul(Z$, G$), v = v + Math.imul(A$, k$) | 0, k = Math.imul(A$, G$), A = A + Math.imul(z$, R$) | 0, v = v + Math.imul(z$, u$) | 0, v = v + Math.imul(j$, R$) | 0, k = k + Math.imul(j$, u$) | 0, A = A + Math.imul(t, I$) | 0, v = v + Math.imul(t, M$) | 0, v = v + Math.imul(F, I$) | 0, k = k + Math.imul(F, M$) | 0;
        var Kq = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (Kq >>> 26) | 0, Kq &= 67108863, A = Math.imul(Z$, R$), v = Math.imul(Z$, u$), v = v + Math.imul(A$, R$) | 0, k = Math.imul(A$, u$), A = A + Math.imul(z$, I$) | 0, v = v + Math.imul(z$, M$) | 0, v = v + Math.imul(j$, I$) | 0, k = k + Math.imul(j$, M$) | 0;
        var _q = (S + A | 0) + ((v & 8191) << 13) | 0;
        S = (k + (v >>> 13) | 0) + (_q >>> 26) | 0, _q &= 67108863, A = Math.imul(Z$, I$), v = Math.imul(Z$, M$), v = v + Math.imul(A$, I$) | 0, k = Math.imul(A$, M$);
        var Pq = (S + A | 0) + ((v & 8191) << 13) | 0;
        if (S = (k + (v >>> 13) | 0) + (Pq >>> 26) | 0, Pq &= 67108863, G[0] = p6, G[1] = H6, G[2] = v6, G[3] = C6, G[4] = S6, G[5] = i6, G[6] = B6, G[7] = t6, G[8] = U6, G[9] = F6, G[10] = a6, G[11] = Q6, G[12] = e6, G[13] = s6, G[14] = $q, G[15] = qq, G[16] = Kq, G[17] = _q, G[18] = Pq, S !== 0) G[19] = S, Z.length++;
        return Z;
      };
      if (!Math.imul) E = h;
      function I(j, H, Z) {
        Z.negative = H.negative ^ j.negative, Z.length = j.length + H.length;
        var W = 0, w = 0;
        for (var G = 0; G < Z.length - 1; G++) {
          var S = w;
          w = 0;
          var A = W & 67108863, v = Math.min(G, H.length - 1);
          for (var k = Math.max(0, G - j.length + 1); k <= v; k++) {
            var R = G - k, C = j.words[R] | 0, L = H.words[k] | 0, x = C * L, l = x & 67108863;
            S = S + (x / 67108864 | 0) | 0, l = l + A | 0, A = l & 67108863, S = S + (l >>> 26) | 0, w += S >>> 26, S &= 67108863;
          }
          Z.words[G] = A, W = S, S = w;
        }
        if (W !== 0) Z.words[G] = W;
        else Z.length--;
        return Z.strip();
      }
      function D(j, H, Z) {
        var W = new g();
        return W.mulp(j, H, Z);
      }
      O.prototype.mulTo = function(j, H) {
        var Z, W = this.length + j.length;
        if (this.length === 10 && j.length === 10) Z = E(this, j, H);
        else if (W < 63) Z = h(this, j, H);
        else if (W < 1024) Z = I(this, j, H);
        else Z = D(this, j, H);
        return Z;
      };
      function g(j, H) {
        this.x = j, this.y = H;
      }
      g.prototype.makeRBT = function(j) {
        var H = Array(j), Z = O.prototype._countBits(j) - 1;
        for (var W = 0; W < j; W++) H[W] = this.revBin(W, Z, j);
        return H;
      }, g.prototype.revBin = function(j, H, Z) {
        if (j === 0 || j === Z - 1) return j;
        var W = 0;
        for (var w = 0; w < H; w++) W |= (j & 1) << H - w - 1, j >>= 1;
        return W;
      }, g.prototype.permute = function(j, H, Z, W, w, G) {
        for (var S = 0; S < G; S++) W[S] = H[j[S]], w[S] = Z[j[S]];
      }, g.prototype.transform = function(j, H, Z, W, w, G) {
        this.permute(G, j, H, Z, W, w);
        for (var S = 1; S < w; S <<= 1) {
          var A = S << 1, v = Math.cos(2 * Math.PI / A), k = Math.sin(2 * Math.PI / A);
          for (var R = 0; R < w; R += A) {
            var C = v, L = k;
            for (var x = 0; x < S; x++) {
              var l = Z[R + x], a = W[R + x], f$ = Z[R + x + S], $$ = W[R + x + S], B = C * f$ - L * $$;
              if ($$ = C * $$ + L * f$, f$ = B, Z[R + x] = l + f$, W[R + x] = a + $$, Z[R + x + S] = l - f$, W[R + x + S] = a - $$, x !== A) B = v * C - k * L, L = v * L + k * C, C = B;
            }
          }
        }
      }, g.prototype.guessLen13b = function(j, H) {
        var Z = Math.max(H, j) | 1, W = Z & 1, w = 0;
        for (Z = Z / 2 | 0; Z; Z = Z >>> 1) w++;
        return 1 << w + 1 + W;
      }, g.prototype.conjugate = function(j, H, Z) {
        if (Z <= 1) return;
        for (var W = 0; W < Z / 2; W++) {
          var w = j[W];
          j[W] = j[Z - W - 1], j[Z - W - 1] = w, w = H[W], H[W] = -H[Z - W - 1], H[Z - W - 1] = -w;
        }
      }, g.prototype.normalize13b = function(j, H) {
        var Z = 0;
        for (var W = 0; W < H / 2; W++) {
          var w = Math.round(j[2 * W + 1] / H) * 8192 + Math.round(j[2 * W] / H) + Z;
          if (j[W] = w & 67108863, w < 67108864) Z = 0;
          else Z = w / 67108864 | 0;
        }
        return j;
      }, g.prototype.convert13b = function(j, H, Z, W) {
        var w = 0;
        for (var G = 0; G < H; G++) w = w + (j[G] | 0), Z[2 * G] = w & 8191, w = w >>> 13, Z[2 * G + 1] = w & 8191, w = w >>> 13;
        for (G = 2 * H; G < W; ++G) Z[G] = 0;
        _(w === 0), _((w & -8192) === 0);
      }, g.prototype.stub = function(j) {
        var H = Array(j);
        for (var Z = 0; Z < j; Z++) H[Z] = 0;
        return H;
      }, g.prototype.mulp = function(j, H, Z) {
        var W = 2 * this.guessLen13b(j.length, H.length), w = this.makeRBT(W), G = this.stub(W), S = Array(W), A = Array(W), v = Array(W), k = Array(W), R = Array(W), C = Array(W), L = Z.words;
        L.length = W, this.convert13b(j.words, j.length, S, W), this.convert13b(H.words, H.length, k, W), this.transform(S, G, A, v, W, w), this.transform(k, G, R, C, W, w);
        for (var x = 0; x < W; x++) {
          var l = A[x] * R[x] - v[x] * C[x];
          v[x] = A[x] * C[x] + v[x] * R[x], A[x] = l;
        }
        return this.conjugate(A, v, W), this.transform(A, v, L, G, W, w), this.conjugate(L, G, W), this.normalize13b(L, W), Z.negative = j.negative ^ H.negative, Z.length = j.length + H.length, Z.strip();
      }, O.prototype.mul = function(j) {
        var H = new O(null);
        return H.words = Array(this.length + j.length), this.mulTo(j, H);
      }, O.prototype.mulf = function(j) {
        var H = new O(null);
        return H.words = Array(this.length + j.length), D(this, j, H);
      }, O.prototype.imul = function(j) {
        return this.clone().mulTo(j, this);
      }, O.prototype.imuln = function(j) {
        _(typeof j === "number"), _(j < 67108864);
        var H = 0;
        for (var Z = 0; Z < this.length; Z++) {
          var W = (this.words[Z] | 0) * j, w = (W & 67108863) + (H & 67108863);
          H >>= 26, H += W / 67108864 | 0, H += w >>> 26, this.words[Z] = w & 67108863;
        }
        if (H !== 0) this.words[Z] = H, this.length++;
        return this.length = j === 0 ? 1 : this.length, this;
      }, O.prototype.muln = function(j) {
        return this.clone().imuln(j);
      }, O.prototype.sqr = function() {
        return this.mul(this);
      }, O.prototype.isqr = function() {
        return this.imul(this.clone());
      }, O.prototype.pow = function(j) {
        var H = N(j);
        if (H.length === 0) return new O(1);
        var Z = this;
        for (var W = 0; W < H.length; W++, Z = Z.sqr()) if (H[W] !== 0) break;
        if (++W < H.length) for (var w = Z.sqr(); W < H.length; W++, w = w.sqr()) {
          if (H[W] === 0) continue;
          Z = Z.mul(w);
        }
        return Z;
      }, O.prototype.iushln = function(j) {
        _(typeof j === "number" && j >= 0);
        var H = j % 26, Z = (j - H) / 26, W = 67108863 >>> 26 - H << 26 - H, w;
        if (H !== 0) {
          var G = 0;
          for (w = 0; w < this.length; w++) {
            var S = this.words[w] & W, A = (this.words[w] | 0) - S << H;
            this.words[w] = A | G, G = S >>> 26 - H;
          }
          if (G) this.words[w] = G, this.length++;
        }
        if (Z !== 0) {
          for (w = this.length - 1; w >= 0; w--) this.words[w + Z] = this.words[w];
          for (w = 0; w < Z; w++) this.words[w] = 0;
          this.length += Z;
        }
        return this.strip();
      }, O.prototype.ishln = function(j) {
        return _(this.negative === 0), this.iushln(j);
      }, O.prototype.iushrn = function(j, H, Z) {
        _(typeof j === "number" && j >= 0);
        var W;
        if (H) W = (H - H % 26) / 26;
        else W = 0;
        var w = j % 26, G = Math.min((j - w) / 26, this.length), S = 67108863 ^ 67108863 >>> w << w, A = Z;
        if (W -= G, W = Math.max(0, W), A) {
          for (var v = 0; v < G; v++) A.words[v] = this.words[v];
          A.length = G;
        }
        if (G === 0) ;
        else if (this.length > G) {
          this.length -= G;
          for (v = 0; v < this.length; v++) this.words[v] = this.words[v + G];
        } else this.words[0] = 0, this.length = 1;
        var k = 0;
        for (v = this.length - 1; v >= 0 && (k !== 0 || v >= W); v--) {
          var R = this.words[v] | 0;
          this.words[v] = k << 26 - w | R >>> w, k = R & S;
        }
        if (A && k !== 0) A.words[A.length++] = k;
        if (this.length === 0) this.words[0] = 0, this.length = 1;
        return this.strip();
      }, O.prototype.ishrn = function(j, H, Z) {
        return _(this.negative === 0), this.iushrn(j, H, Z);
      }, O.prototype.shln = function(j) {
        return this.clone().ishln(j);
      }, O.prototype.ushln = function(j) {
        return this.clone().iushln(j);
      }, O.prototype.shrn = function(j) {
        return this.clone().ishrn(j);
      }, O.prototype.ushrn = function(j) {
        return this.clone().iushrn(j);
      }, O.prototype.testn = function(j) {
        _(typeof j === "number" && j >= 0);
        var H = j % 26, Z = (j - H) / 26, W = 1 << H;
        if (this.length <= Z) return false;
        var w = this.words[Z];
        return !!(w & W);
      }, O.prototype.imaskn = function(j) {
        _(typeof j === "number" && j >= 0);
        var H = j % 26, Z = (j - H) / 26;
        if (_(this.negative === 0, "imaskn works only with positive numbers"), this.length <= Z) return this;
        if (H !== 0) Z++;
        if (this.length = Math.min(Z, this.length), H !== 0) {
          var W = 67108863 ^ 67108863 >>> H << H;
          this.words[this.length - 1] &= W;
        }
        return this.strip();
      }, O.prototype.maskn = function(j) {
        return this.clone().imaskn(j);
      }, O.prototype.iaddn = function(j) {
        if (_(typeof j === "number"), _(j < 67108864), j < 0) return this.isubn(-j);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) < j) return this.words[0] = j - (this.words[0] | 0), this.negative = 0, this;
          return this.negative = 0, this.isubn(j), this.negative = 1, this;
        }
        return this._iaddn(j);
      }, O.prototype._iaddn = function(j) {
        this.words[0] += j;
        for (var H = 0; H < this.length && this.words[H] >= 67108864; H++) if (this.words[H] -= 67108864, H === this.length - 1) this.words[H + 1] = 1;
        else this.words[H + 1]++;
        return this.length = Math.max(this.length, H + 1), this;
      }, O.prototype.isubn = function(j) {
        if (_(typeof j === "number"), _(j < 67108864), j < 0) return this.iaddn(-j);
        if (this.negative !== 0) return this.negative = 0, this.iaddn(j), this.negative = 1, this;
        if (this.words[0] -= j, this.length === 1 && this.words[0] < 0) this.words[0] = -this.words[0], this.negative = 1;
        else for (var H = 0; H < this.length && this.words[H] < 0; H++) this.words[H] += 67108864, this.words[H + 1] -= 1;
        return this.strip();
      }, O.prototype.addn = function(j) {
        return this.clone().iaddn(j);
      }, O.prototype.subn = function(j) {
        return this.clone().isubn(j);
      }, O.prototype.iabs = function() {
        return this.negative = 0, this;
      }, O.prototype.abs = function() {
        return this.clone().iabs();
      }, O.prototype._ishlnsubmul = function(j, H, Z) {
        var W = j.length + Z, w;
        this._expand(W);
        var G, S = 0;
        for (w = 0; w < j.length; w++) {
          G = (this.words[w + Z] | 0) + S;
          var A = (j.words[w] | 0) * H;
          G -= A & 67108863, S = (G >> 26) - (A / 67108864 | 0), this.words[w + Z] = G & 67108863;
        }
        for (; w < this.length - Z; w++) G = (this.words[w + Z] | 0) + S, S = G >> 26, this.words[w + Z] = G & 67108863;
        if (S === 0) return this.strip();
        _(S === -1), S = 0;
        for (w = 0; w < this.length; w++) G = -(this.words[w] | 0) + S, S = G >> 26, this.words[w] = G & 67108863;
        return this.negative = 1, this.strip();
      }, O.prototype._wordDiv = function(j, H) {
        var Z = this.length - j.length, W = this.clone(), w = j, G = w.words[w.length - 1] | 0, S = this._countBits(G);
        if (Z = 26 - S, Z !== 0) w = w.ushln(Z), W.iushln(Z), G = w.words[w.length - 1] | 0;
        var A = W.length - w.length, v;
        if (H !== "mod") {
          v = new O(null), v.length = A + 1, v.words = Array(v.length);
          for (var k = 0; k < v.length; k++) v.words[k] = 0;
        }
        var R = W.clone()._ishlnsubmul(w, 1, A);
        if (R.negative === 0) {
          if (W = R, v) v.words[A] = 1;
        }
        for (var C = A - 1; C >= 0; C--) {
          var L = (W.words[w.length + C] | 0) * 67108864 + (W.words[w.length + C - 1] | 0);
          L = Math.min(L / G | 0, 67108863), W._ishlnsubmul(w, L, C);
          while (W.negative !== 0) if (L--, W.negative = 0, W._ishlnsubmul(w, 1, C), !W.isZero()) W.negative ^= 1;
          if (v) v.words[C] = L;
        }
        if (v) v.strip();
        if (W.strip(), H !== "div" && Z !== 0) W.iushrn(Z);
        return { div: v || null, mod: W };
      }, O.prototype.divmod = function(j, H, Z) {
        if (_(!j.isZero()), this.isZero()) return { div: new O(0), mod: new O(0) };
        var W, w, G;
        if (this.negative !== 0 && j.negative === 0) {
          if (G = this.neg().divmod(j, H), H !== "mod") W = G.div.neg();
          if (H !== "div") {
            if (w = G.mod.neg(), Z && w.negative !== 0) w.iadd(j);
          }
          return { div: W, mod: w };
        }
        if (this.negative === 0 && j.negative !== 0) {
          if (G = this.divmod(j.neg(), H), H !== "mod") W = G.div.neg();
          return { div: W, mod: G.mod };
        }
        if ((this.negative & j.negative) !== 0) {
          if (G = this.neg().divmod(j.neg(), H), H !== "div") {
            if (w = G.mod.neg(), Z && w.negative !== 0) w.isub(j);
          }
          return { div: G.div, mod: w };
        }
        if (j.length > this.length || this.cmp(j) < 0) return { div: new O(0), mod: this };
        if (j.length === 1) {
          if (H === "div") return { div: this.divn(j.words[0]), mod: null };
          if (H === "mod") return { div: null, mod: new O(this.modn(j.words[0])) };
          return { div: this.divn(j.words[0]), mod: new O(this.modn(j.words[0])) };
        }
        return this._wordDiv(j, H);
      }, O.prototype.div = function(j) {
        return this.divmod(j, "div", false).div;
      }, O.prototype.mod = function(j) {
        return this.divmod(j, "mod", false).mod;
      }, O.prototype.umod = function(j) {
        return this.divmod(j, "mod", true).mod;
      }, O.prototype.divRound = function(j) {
        var H = this.divmod(j);
        if (H.mod.isZero()) return H.div;
        var Z = H.div.negative !== 0 ? H.mod.isub(j) : H.mod, W = j.ushrn(1), w = j.andln(1), G = Z.cmp(W);
        if (G < 0 || w === 1 && G === 0) return H.div;
        return H.div.negative !== 0 ? H.div.isubn(1) : H.div.iaddn(1);
      }, O.prototype.modn = function(j) {
        _(j <= 67108863);
        var H = 67108864 % j, Z = 0;
        for (var W = this.length - 1; W >= 0; W--) Z = (H * Z + (this.words[W] | 0)) % j;
        return Z;
      }, O.prototype.idivn = function(j) {
        _(j <= 67108863);
        var H = 0;
        for (var Z = this.length - 1; Z >= 0; Z--) {
          var W = (this.words[Z] | 0) + H * 67108864;
          this.words[Z] = W / j | 0, H = W % j;
        }
        return this.strip();
      }, O.prototype.divn = function(j) {
        return this.clone().idivn(j);
      }, O.prototype.egcd = function(j) {
        _(j.negative === 0), _(!j.isZero());
        var H = this, Z = j.clone();
        if (H.negative !== 0) H = H.umod(j);
        else H = H.clone();
        var W = new O(1), w = new O(0), G = new O(0), S = new O(1), A = 0;
        while (H.isEven() && Z.isEven()) H.iushrn(1), Z.iushrn(1), ++A;
        var v = Z.clone(), k = H.clone();
        while (!H.isZero()) {
          for (var R = 0, C = 1; (H.words[0] & C) === 0 && R < 26; ++R, C <<= 1) ;
          if (R > 0) {
            H.iushrn(R);
            while (R-- > 0) {
              if (W.isOdd() || w.isOdd()) W.iadd(v), w.isub(k);
              W.iushrn(1), w.iushrn(1);
            }
          }
          for (var L = 0, x = 1; (Z.words[0] & x) === 0 && L < 26; ++L, x <<= 1) ;
          if (L > 0) {
            Z.iushrn(L);
            while (L-- > 0) {
              if (G.isOdd() || S.isOdd()) G.iadd(v), S.isub(k);
              G.iushrn(1), S.iushrn(1);
            }
          }
          if (H.cmp(Z) >= 0) H.isub(Z), W.isub(G), w.isub(S);
          else Z.isub(H), G.isub(W), S.isub(w);
        }
        return { a: G, b: S, gcd: Z.iushln(A) };
      }, O.prototype._invmp = function(j) {
        _(j.negative === 0), _(!j.isZero());
        var H = this, Z = j.clone();
        if (H.negative !== 0) H = H.umod(j);
        else H = H.clone();
        var W = new O(1), w = new O(0), G = Z.clone();
        while (H.cmpn(1) > 0 && Z.cmpn(1) > 0) {
          for (var S = 0, A = 1; (H.words[0] & A) === 0 && S < 26; ++S, A <<= 1) ;
          if (S > 0) {
            H.iushrn(S);
            while (S-- > 0) {
              if (W.isOdd()) W.iadd(G);
              W.iushrn(1);
            }
          }
          for (var v = 0, k = 1; (Z.words[0] & k) === 0 && v < 26; ++v, k <<= 1) ;
          if (v > 0) {
            Z.iushrn(v);
            while (v-- > 0) {
              if (w.isOdd()) w.iadd(G);
              w.iushrn(1);
            }
          }
          if (H.cmp(Z) >= 0) H.isub(Z), W.isub(w);
          else Z.isub(H), w.isub(W);
        }
        var R;
        if (H.cmpn(1) === 0) R = W;
        else R = w;
        if (R.cmpn(0) < 0) R.iadd(j);
        return R;
      }, O.prototype.gcd = function(j) {
        if (this.isZero()) return j.abs();
        if (j.isZero()) return this.abs();
        var H = this.clone(), Z = j.clone();
        H.negative = 0, Z.negative = 0;
        for (var W = 0; H.isEven() && Z.isEven(); W++) H.iushrn(1), Z.iushrn(1);
        do {
          while (H.isEven()) H.iushrn(1);
          while (Z.isEven()) Z.iushrn(1);
          var w = H.cmp(Z);
          if (w < 0) {
            var G = H;
            H = Z, Z = G;
          } else if (w === 0 || Z.cmpn(1) === 0) break;
          H.isub(Z);
        } while (true);
        return Z.iushln(W);
      }, O.prototype.invm = function(j) {
        return this.egcd(j).a.umod(j);
      }, O.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, O.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, O.prototype.andln = function(j) {
        return this.words[0] & j;
      }, O.prototype.bincn = function(j) {
        _(typeof j === "number");
        var H = j % 26, Z = (j - H) / 26, W = 1 << H;
        if (this.length <= Z) return this._expand(Z + 1), this.words[Z] |= W, this;
        var w = W;
        for (var G = Z; w !== 0 && G < this.length; G++) {
          var S = this.words[G] | 0;
          S += w, w = S >>> 26, S &= 67108863, this.words[G] = S;
        }
        if (w !== 0) this.words[G] = w, this.length++;
        return this;
      }, O.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, O.prototype.cmpn = function(j) {
        var H = j < 0;
        if (this.negative !== 0 && !H) return -1;
        if (this.negative === 0 && H) return 1;
        this.strip();
        var Z;
        if (this.length > 1) Z = 1;
        else {
          if (H) j = -j;
          _(j <= 67108863, "Number is too big");
          var W = this.words[0] | 0;
          Z = W === j ? 0 : W < j ? -1 : 1;
        }
        if (this.negative !== 0) return -Z | 0;
        return Z;
      }, O.prototype.cmp = function(j) {
        if (this.negative !== 0 && j.negative === 0) return -1;
        if (this.negative === 0 && j.negative !== 0) return 1;
        var H = this.ucmp(j);
        if (this.negative !== 0) return -H | 0;
        return H;
      }, O.prototype.ucmp = function(j) {
        if (this.length > j.length) return 1;
        if (this.length < j.length) return -1;
        var H = 0;
        for (var Z = this.length - 1; Z >= 0; Z--) {
          var W = this.words[Z] | 0, w = j.words[Z] | 0;
          if (W === w) continue;
          if (W < w) H = -1;
          else if (W > w) H = 1;
          break;
        }
        return H;
      }, O.prototype.gtn = function(j) {
        return this.cmpn(j) === 1;
      }, O.prototype.gt = function(j) {
        return this.cmp(j) === 1;
      }, O.prototype.gten = function(j) {
        return this.cmpn(j) >= 0;
      }, O.prototype.gte = function(j) {
        return this.cmp(j) >= 0;
      }, O.prototype.ltn = function(j) {
        return this.cmpn(j) === -1;
      }, O.prototype.lt = function(j) {
        return this.cmp(j) === -1;
      }, O.prototype.lten = function(j) {
        return this.cmpn(j) <= 0;
      }, O.prototype.lte = function(j) {
        return this.cmp(j) <= 0;
      }, O.prototype.eqn = function(j) {
        return this.cmpn(j) === 0;
      }, O.prototype.eq = function(j) {
        return this.cmp(j) === 0;
      }, O.red = function(j) {
        return new c(j);
      }, O.prototype.toRed = function(j) {
        return _(!this.red, "Already a number in reduction context"), _(this.negative === 0, "red works only with positives"), j.convertTo(this)._forceRed(j);
      }, O.prototype.fromRed = function() {
        return _(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, O.prototype._forceRed = function(j) {
        return this.red = j, this;
      }, O.prototype.forceRed = function(j) {
        return _(!this.red, "Already a number in reduction context"), this._forceRed(j);
      }, O.prototype.redAdd = function(j) {
        return _(this.red, "redAdd works only with red numbers"), this.red.add(this, j);
      }, O.prototype.redIAdd = function(j) {
        return _(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, j);
      }, O.prototype.redSub = function(j) {
        return _(this.red, "redSub works only with red numbers"), this.red.sub(this, j);
      }, O.prototype.redISub = function(j) {
        return _(this.red, "redISub works only with red numbers"), this.red.isub(this, j);
      }, O.prototype.redShl = function(j) {
        return _(this.red, "redShl works only with red numbers"), this.red.shl(this, j);
      }, O.prototype.redMul = function(j) {
        return _(this.red, "redMul works only with red numbers"), this.red._verify2(this, j), this.red.mul(this, j);
      }, O.prototype.redIMul = function(j) {
        return _(this.red, "redMul works only with red numbers"), this.red._verify2(this, j), this.red.imul(this, j);
      }, O.prototype.redSqr = function() {
        return _(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, O.prototype.redISqr = function() {
        return _(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, O.prototype.redSqrt = function() {
        return _(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, O.prototype.redInvm = function() {
        return _(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, O.prototype.redNeg = function() {
        return _(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, O.prototype.redPow = function(j) {
        return _(this.red && !j.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, j);
      };
      var b = { k256: null, p224: null, p192: null, p25519: null };
      function y(j, H) {
        this.name = j, this.p = new O(H, 16), this.n = this.p.bitLength(), this.k = new O(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      y.prototype._tmp = function() {
        var j = new O(null);
        return j.words = Array(Math.ceil(this.n / 13)), j;
      }, y.prototype.ireduce = function(j) {
        var H = j, Z;
        do
          this.split(H, this.tmp), H = this.imulK(H), H = H.iadd(this.tmp), Z = H.bitLength();
        while (Z > this.n);
        var W = Z < this.n ? -1 : H.ucmp(this.p);
        if (W === 0) H.words[0] = 0, H.length = 1;
        else if (W > 0) H.isub(this.p);
        else if (H.strip !== void 0) H.strip();
        else H._strip();
        return H;
      }, y.prototype.split = function(j, H) {
        j.iushrn(this.n, 0, H);
      }, y.prototype.imulK = function(j) {
        return j.imul(this.k);
      };
      function p() {
        y.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
      }
      Y(p, y), p.prototype.split = function(j, H) {
        var Z = 4194303, W = Math.min(j.length, 9);
        for (var w = 0; w < W; w++) H.words[w] = j.words[w];
        if (H.length = W, j.length <= 9) {
          j.words[0] = 0, j.length = 1;
          return;
        }
        var G = j.words[9];
        H.words[H.length++] = G & Z;
        for (w = 10; w < j.length; w++) {
          var S = j.words[w] | 0;
          j.words[w - 10] = (S & Z) << 4 | G >>> 22, G = S;
        }
        if (G >>>= 22, j.words[w - 10] = G, G === 0 && j.length > 10) j.length -= 10;
        else j.length -= 9;
      }, p.prototype.imulK = function(j) {
        j.words[j.length] = 0, j.words[j.length + 1] = 0, j.length += 2;
        var H = 0;
        for (var Z = 0; Z < j.length; Z++) {
          var W = j.words[Z] | 0;
          H += W * 977, j.words[Z] = H & 67108863, H = W * 64 + (H / 67108864 | 0);
        }
        if (j.words[j.length - 1] === 0) {
          if (j.length--, j.words[j.length - 1] === 0) j.length--;
        }
        return j;
      };
      function n() {
        y.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
      }
      Y(n, y);
      function s() {
        y.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
      }
      Y(s, y);
      function q$() {
        y.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
      }
      Y(q$, y), q$.prototype.imulK = function(j) {
        var H = 0;
        for (var Z = 0; Z < j.length; Z++) {
          var W = (j.words[Z] | 0) * 19 + H, w = W & 67108863;
          W >>>= 26, j.words[Z] = w, H = W;
        }
        if (H !== 0) j.words[j.length++] = H;
        return j;
      }, O._prime = function(j) {
        if (b[j]) return b[j];
        var H;
        if (j === "k256") H = new p();
        else if (j === "p224") H = new n();
        else if (j === "p192") H = new s();
        else if (j === "p25519") H = new q$();
        else throw Error("Unknown prime " + j);
        return b[j] = H, H;
      };
      function c(j) {
        if (typeof j === "string") {
          var H = O._prime(j);
          this.m = H.p, this.prime = H;
        } else _(j.gtn(1), "modulus must be greater than 1"), this.m = j, this.prime = null;
      }
      c.prototype._verify1 = function(j) {
        _(j.negative === 0, "red works only with positives"), _(j.red, "red works only with red numbers");
      }, c.prototype._verify2 = function(j, H) {
        _((j.negative | H.negative) === 0, "red works only with positives"), _(j.red && j.red === H.red, "red works only with red numbers");
      }, c.prototype.imod = function(j) {
        if (this.prime) return this.prime.ireduce(j)._forceRed(this);
        return j.umod(this.m)._forceRed(this);
      }, c.prototype.neg = function(j) {
        if (j.isZero()) return j.clone();
        return this.m.sub(j)._forceRed(this);
      }, c.prototype.add = function(j, H) {
        this._verify2(j, H);
        var Z = j.add(H);
        if (Z.cmp(this.m) >= 0) Z.isub(this.m);
        return Z._forceRed(this);
      }, c.prototype.iadd = function(j, H) {
        this._verify2(j, H);
        var Z = j.iadd(H);
        if (Z.cmp(this.m) >= 0) Z.isub(this.m);
        return Z;
      }, c.prototype.sub = function(j, H) {
        this._verify2(j, H);
        var Z = j.sub(H);
        if (Z.cmpn(0) < 0) Z.iadd(this.m);
        return Z._forceRed(this);
      }, c.prototype.isub = function(j, H) {
        this._verify2(j, H);
        var Z = j.isub(H);
        if (Z.cmpn(0) < 0) Z.iadd(this.m);
        return Z;
      }, c.prototype.shl = function(j, H) {
        return this._verify1(j), this.imod(j.ushln(H));
      }, c.prototype.imul = function(j, H) {
        return this._verify2(j, H), this.imod(j.imul(H));
      }, c.prototype.mul = function(j, H) {
        return this._verify2(j, H), this.imod(j.mul(H));
      }, c.prototype.isqr = function(j) {
        return this.imul(j, j.clone());
      }, c.prototype.sqr = function(j) {
        return this.mul(j, j);
      }, c.prototype.sqrt = function(j) {
        if (j.isZero()) return j.clone();
        var H = this.m.andln(3);
        if (_(H % 2 === 1), H === 3) {
          var Z = this.m.add(new O(1)).iushrn(2);
          return this.pow(j, Z);
        }
        var W = this.m.subn(1), w = 0;
        while (!W.isZero() && W.andln(1) === 0) w++, W.iushrn(1);
        _(!W.isZero());
        var G = new O(1).toRed(this), S = G.redNeg(), A = this.m.subn(1).iushrn(1), v = this.m.bitLength();
        v = new O(2 * v * v).toRed(this);
        while (this.pow(v, A).cmp(S) !== 0) v.redIAdd(S);
        var k = this.pow(v, W), R = this.pow(j, W.addn(1).iushrn(1)), C = this.pow(j, W), L = w;
        while (C.cmp(G) !== 0) {
          var x = C;
          for (var l = 0; x.cmp(G) !== 0; l++) x = x.redSqr();
          _(l < L);
          var a = this.pow(k, new O(1).iushln(L - l - 1));
          R = R.redMul(a), k = a.redSqr(), C = C.redMul(k), L = l;
        }
        return R;
      }, c.prototype.invm = function(j) {
        var H = j._invmp(this.m);
        if (H.negative !== 0) return H.negative = 0, this.imod(H).redNeg();
        else return this.imod(H);
      }, c.prototype.pow = function(j, H) {
        if (H.isZero()) return new O(1).toRed(this);
        if (H.cmpn(1) === 0) return j.clone();
        var Z = 4, W = Array(1 << Z);
        W[0] = new O(1).toRed(this), W[1] = j;
        for (var w = 2; w < W.length; w++) W[w] = this.mul(W[w - 1], j);
        var G = W[0], S = 0, A = 0, v = H.bitLength() % 26;
        if (v === 0) v = 26;
        for (w = H.length - 1; w >= 0; w--) {
          var k = H.words[w];
          for (var R = v - 1; R >= 0; R--) {
            var C = k >> R & 1;
            if (G !== W[0]) G = this.sqr(G);
            if (C === 0 && S === 0) {
              A = 0;
              continue;
            }
            if (S <<= 1, S |= C, A++, A !== Z && (w !== 0 || R !== 0)) continue;
            G = this.mul(G, W[S]), A = 0, S = 0;
          }
          v = 26;
        }
        return G;
      }, c.prototype.convertTo = function(j) {
        var H = j.umod(this.m);
        return H === j ? H.clone() : H;
      }, c.prototype.convertFrom = function(j) {
        var H = j.clone();
        return H.red = null, H;
      }, O.mont = function(j) {
        return new U(j);
      };
      function U(j) {
        if (c.call(this, j), this.shift = this.m.bitLength(), this.shift % 26 !== 0) this.shift += 26 - this.shift % 26;
        this.r = new O(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      Y(U, c), U.prototype.convertTo = function(j) {
        return this.imod(j.ushln(this.shift));
      }, U.prototype.convertFrom = function(j) {
        var H = this.imod(j.mul(this.rinv));
        return H.red = null, H;
      }, U.prototype.imul = function(j, H) {
        if (j.isZero() || H.isZero()) return j.words[0] = 0, j.length = 1, j;
        var Z = j.imul(H), W = Z.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), w = Z.isub(W).iushrn(this.shift), G = w;
        if (w.cmp(this.m) >= 0) G = w.isub(this.m);
        else if (w.cmpn(0) < 0) G = w.iadd(this.m);
        return G._forceRed(this);
      }, U.prototype.mul = function(j, H) {
        if (j.isZero() || H.isZero()) return new O(0)._forceRed(this);
        var Z = j.mul(H), W = Z.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), w = Z.isub(W).iushrn(this.shift), G = w;
        if (w.cmp(this.m) >= 0) G = w.isub(this.m);
        else if (w.cmpn(0) < 0) G = w.iadd(this.m);
        return G._forceRed(this);
      }, U.prototype.invm = function(j) {
        var H = this.imod(j._invmp(this.m).mul(this.r2));
        return H._forceRed(this);
      };
    })(typeof q > "u" || q, $18);
  }), f0 = r$(($18, q) => {
    var K = iH(), P = $8().Buffer;
    function _(Y, O) {
      return P.from(Y.toRed(K.mont(O.modulus)).redPow(new K(O.publicExponent)).fromRed().toArray());
    }
    q.exports = _;
  }), Co = r$(($18, q) => {
    (function(K, P) {
      function _(W, w) {
        if (!W) throw Error(w || "Assertion failed");
      }
      function Y(W, w) {
        W.super_ = w;
        var G = function() {
        };
        G.prototype = w.prototype, W.prototype = new G(), W.prototype.constructor = W;
      }
      function O(W, w, G) {
        if (O.isBN(W)) return W;
        if (this.negative = 0, this.words = null, this.length = 0, this.red = null, W !== null) {
          if (w === "le" || w === "be") G = w, w = 10;
          this._init(W || 0, w || 10, G || "be");
        }
      }
      if (typeof K === "object") K.exports = O;
      else P.BN = O;
      O.BN = O, O.wordSize = 26;
      var z;
      try {
        if (typeof window < "u" && typeof window.Buffer < "u") z = window.Buffer;
        else z = (wq(), J6(Tq)).Buffer;
      } catch (W) {
      }
      O.isBN = function(W) {
        if (W instanceof O) return true;
        return W !== null && typeof W === "object" && W.constructor.wordSize === O.wordSize && Array.isArray(W.words);
      }, O.max = function(W, w) {
        if (W.cmp(w) > 0) return W;
        return w;
      }, O.min = function(W, w) {
        if (W.cmp(w) < 0) return W;
        return w;
      }, O.prototype._init = function(W, w, G) {
        if (typeof W === "number") return this._initNumber(W, w, G);
        if (typeof W === "object") return this._initArray(W, w, G);
        if (w === "hex") w = 16;
        _(w === (w | 0) && w >= 2 && w <= 36), W = W.toString().replace(/\s+/g, "");
        var S = 0;
        if (W[0] === "-") S++, this.negative = 1;
        if (S < W.length) {
          if (w === 16) this._parseHex(W, S, G);
          else if (this._parseBase(W, w, S), G === "le") this._initArray(this.toArray(), w, G);
        }
      }, O.prototype._initNumber = function(W, w, G) {
        if (W < 0) this.negative = 1, W = -W;
        if (W < 67108864) this.words = [W & 67108863], this.length = 1;
        else if (W < 4503599627370496) this.words = [W & 67108863, W / 67108864 & 67108863], this.length = 2;
        else _(W < 9007199254740992), this.words = [W & 67108863, W / 67108864 & 67108863, 1], this.length = 3;
        if (G !== "le") return;
        this._initArray(this.toArray(), w, G);
      }, O.prototype._initArray = function(W, w, G) {
        if (_(typeof W.length === "number"), W.length <= 0) return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(W.length / 3), this.words = Array(this.length);
        for (var S = 0; S < this.length; S++) this.words[S] = 0;
        var A, v, k = 0;
        if (G === "be") {
          for (S = W.length - 1, A = 0; S >= 0; S -= 3) if (v = W[S] | W[S - 1] << 8 | W[S - 2] << 16, this.words[A] |= v << k & 67108863, this.words[A + 1] = v >>> 26 - k & 67108863, k += 24, k >= 26) k -= 26, A++;
        } else if (G === "le") {
          for (S = 0, A = 0; S < W.length; S += 3) if (v = W[S] | W[S + 1] << 8 | W[S + 2] << 16, this.words[A] |= v << k & 67108863, this.words[A + 1] = v >>> 26 - k & 67108863, k += 24, k >= 26) k -= 26, A++;
        }
        return this._strip();
      };
      function J(W, w) {
        var G = W.charCodeAt(w);
        if (G >= 48 && G <= 57) return G - 48;
        else if (G >= 65 && G <= 70) return G - 55;
        else if (G >= 97 && G <= 102) return G - 87;
        else _(false, "Invalid character in " + W);
      }
      function T(W, w, G) {
        var S = J(W, G);
        if (G - 1 >= w) S |= J(W, G - 1) << 4;
        return S;
      }
      O.prototype._parseHex = function(W, w, G) {
        this.length = Math.ceil((W.length - w) / 6), this.words = Array(this.length);
        for (var S = 0; S < this.length; S++) this.words[S] = 0;
        var A = 0, v = 0, k;
        if (G === "be") for (S = W.length - 1; S >= w; S -= 2) if (k = T(W, w, S) << A, this.words[v] |= k & 67108863, A >= 18) A -= 18, v += 1, this.words[v] |= k >>> 26;
        else A += 8;
        else {
          var R = W.length - w;
          for (S = R % 2 === 0 ? w + 1 : w; S < W.length; S += 2) if (k = T(W, w, S) << A, this.words[v] |= k & 67108863, A >= 18) A -= 18, v += 1, this.words[v] |= k >>> 26;
          else A += 8;
        }
        this._strip();
      };
      function X(W, w, G, S) {
        var A = 0, v = 0, k = Math.min(W.length, G);
        for (var R = w; R < k; R++) {
          var C = W.charCodeAt(R) - 48;
          if (A *= S, C >= 49) v = C - 49 + 10;
          else if (C >= 17) v = C - 17 + 10;
          else v = C;
          _(C >= 0 && v < S, "Invalid character"), A += v;
        }
        return A;
      }
      O.prototype._parseBase = function(W, w, G) {
        this.words = [0], this.length = 1;
        for (var S = 0, A = 1; A <= 67108863; A *= w) S++;
        S--, A = A / w | 0;
        var v = W.length - G, k = v % S, R = Math.min(v, v - k) + G, C = 0;
        for (var L = G; L < R; L += S) if (C = X(W, L, L + S, w), this.imuln(A), this.words[0] + C < 67108864) this.words[0] += C;
        else this._iaddn(C);
        if (k !== 0) {
          var x = 1;
          C = X(W, L, W.length, w);
          for (L = 0; L < k; L++) x *= w;
          if (this.imuln(x), this.words[0] + C < 67108864) this.words[0] += C;
          else this._iaddn(C);
        }
        this._strip();
      }, O.prototype.copy = function(W) {
        W.words = Array(this.length);
        for (var w = 0; w < this.length; w++) W.words[w] = this.words[w];
        W.length = this.length, W.negative = this.negative, W.red = this.red;
      };
      function f(W, w) {
        W.words = w.words, W.length = w.length, W.negative = w.negative, W.red = w.red;
      }
      if (O.prototype._move = function(W) {
        f(W, this);
      }, O.prototype.clone = function() {
        var W = new O(null);
        return this.copy(W), W;
      }, O.prototype._expand = function(W) {
        while (this.length < W) this.words[this.length++] = 0;
        return this;
      }, O.prototype._strip = function() {
        while (this.length > 1 && this.words[this.length - 1] === 0) this.length--;
        return this._normSign();
      }, O.prototype._normSign = function() {
        if (this.length === 1 && this.words[0] === 0) this.negative = 0;
        return this;
      }, typeof Symbol < "u" && typeof Symbol.for === "function") try {
        O.prototype[Symbol.for("nodejs.util.inspect.custom")] = V;
      } catch (W) {
        O.prototype.inspect = V;
      }
      else O.prototype.inspect = V;
      function V() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      }
      var M = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], N = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], h = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
      if (O.prototype.toString = function(W, w) {
        W = W || 10, w = w | 0 || 1;
        var G;
        if (W === 16 || W === "hex") {
          G = "";
          var S = 0, A = 0;
          for (var v = 0; v < this.length; v++) {
            var k = this.words[v], R = ((k << S | A) & 16777215).toString(16);
            if (A = k >>> 24 - S & 16777215, S += 2, S >= 26) S -= 26, v--;
            if (A !== 0 || v !== this.length - 1) G = M[6 - R.length] + R + G;
            else G = R + G;
          }
          if (A !== 0) G = A.toString(16) + G;
          while (G.length % w !== 0) G = "0" + G;
          if (this.negative !== 0) G = "-" + G;
          return G;
        }
        if (W === (W | 0) && W >= 2 && W <= 36) {
          var C = N[W], L = h[W];
          G = "";
          var x = this.clone();
          x.negative = 0;
          while (!x.isZero()) {
            var l = x.modrn(L).toString(W);
            if (x = x.idivn(L), !x.isZero()) G = M[C - l.length] + l + G;
            else G = l + G;
          }
          if (this.isZero()) G = "0" + G;
          while (G.length % w !== 0) G = "0" + G;
          if (this.negative !== 0) G = "-" + G;
          return G;
        }
        _(false, "Base should be between 2 and 36");
      }, O.prototype.toNumber = function() {
        var W = this.words[0];
        if (this.length === 2) W += this.words[1] * 67108864;
        else if (this.length === 3 && this.words[2] === 1) W += 4503599627370496 + this.words[1] * 67108864;
        else if (this.length > 2) _(false, "Number can only safely store up to 53 bits");
        return this.negative !== 0 ? -W : W;
      }, O.prototype.toJSON = function() {
        return this.toString(16, 2);
      }, z) O.prototype.toBuffer = function(W, w) {
        return this.toArrayLike(z, W, w);
      };
      O.prototype.toArray = function(W, w) {
        return this.toArrayLike(Array, W, w);
      };
      var E = function(W, w) {
        if (W.allocUnsafe) return W.allocUnsafe(w);
        return new W(w);
      };
      if (O.prototype.toArrayLike = function(W, w, G) {
        this._strip();
        var S = this.byteLength(), A = G || Math.max(1, S);
        _(S <= A, "byte array longer than desired length"), _(A > 0, "Requested array length <= 0");
        var v = E(W, A), k = w === "le" ? "LE" : "BE";
        return this["_toArrayLike" + k](v, S), v;
      }, O.prototype._toArrayLikeLE = function(W, w) {
        var G = 0, S = 0;
        for (var A = 0, v = 0; A < this.length; A++) {
          var k = this.words[A] << v | S;
          if (W[G++] = k & 255, G < W.length) W[G++] = k >> 8 & 255;
          if (G < W.length) W[G++] = k >> 16 & 255;
          if (v === 6) {
            if (G < W.length) W[G++] = k >> 24 & 255;
            S = 0, v = 0;
          } else S = k >>> 24, v += 2;
        }
        if (G < W.length) {
          W[G++] = S;
          while (G < W.length) W[G++] = 0;
        }
      }, O.prototype._toArrayLikeBE = function(W, w) {
        var G = W.length - 1, S = 0;
        for (var A = 0, v = 0; A < this.length; A++) {
          var k = this.words[A] << v | S;
          if (W[G--] = k & 255, G >= 0) W[G--] = k >> 8 & 255;
          if (G >= 0) W[G--] = k >> 16 & 255;
          if (v === 6) {
            if (G >= 0) W[G--] = k >> 24 & 255;
            S = 0, v = 0;
          } else S = k >>> 24, v += 2;
        }
        if (G >= 0) {
          W[G--] = S;
          while (G >= 0) W[G--] = 0;
        }
      }, Math.clz32) O.prototype._countBits = function(W) {
        return 32 - Math.clz32(W);
      };
      else O.prototype._countBits = function(W) {
        var w = W, G = 0;
        if (w >= 4096) G += 13, w >>>= 13;
        if (w >= 64) G += 7, w >>>= 7;
        if (w >= 8) G += 4, w >>>= 4;
        if (w >= 2) G += 2, w >>>= 2;
        return G + w;
      };
      O.prototype._zeroBits = function(W) {
        if (W === 0) return 26;
        var w = W, G = 0;
        if ((w & 8191) === 0) G += 13, w >>>= 13;
        if ((w & 127) === 0) G += 7, w >>>= 7;
        if ((w & 15) === 0) G += 4, w >>>= 4;
        if ((w & 3) === 0) G += 2, w >>>= 2;
        if ((w & 1) === 0) G++;
        return G;
      }, O.prototype.bitLength = function() {
        var W = this.words[this.length - 1], w = this._countBits(W);
        return (this.length - 1) * 26 + w;
      };
      function I(W) {
        var w = Array(W.bitLength());
        for (var G = 0; G < w.length; G++) {
          var S = G / 26 | 0, A = G % 26;
          w[G] = W.words[S] >>> A & 1;
        }
        return w;
      }
      O.prototype.zeroBits = function() {
        if (this.isZero()) return 0;
        var W = 0;
        for (var w = 0; w < this.length; w++) {
          var G = this._zeroBits(this.words[w]);
          if (W += G, G !== 26) break;
        }
        return W;
      }, O.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, O.prototype.toTwos = function(W) {
        if (this.negative !== 0) return this.abs().inotn(W).iaddn(1);
        return this.clone();
      }, O.prototype.fromTwos = function(W) {
        if (this.testn(W - 1)) return this.notn(W).iaddn(1).ineg();
        return this.clone();
      }, O.prototype.isNeg = function() {
        return this.negative !== 0;
      }, O.prototype.neg = function() {
        return this.clone().ineg();
      }, O.prototype.ineg = function() {
        if (!this.isZero()) this.negative ^= 1;
        return this;
      }, O.prototype.iuor = function(W) {
        while (this.length < W.length) this.words[this.length++] = 0;
        for (var w = 0; w < W.length; w++) this.words[w] = this.words[w] | W.words[w];
        return this._strip();
      }, O.prototype.ior = function(W) {
        return _((this.negative | W.negative) === 0), this.iuor(W);
      }, O.prototype.or = function(W) {
        if (this.length > W.length) return this.clone().ior(W);
        return W.clone().ior(this);
      }, O.prototype.uor = function(W) {
        if (this.length > W.length) return this.clone().iuor(W);
        return W.clone().iuor(this);
      }, O.prototype.iuand = function(W) {
        var w;
        if (this.length > W.length) w = W;
        else w = this;
        for (var G = 0; G < w.length; G++) this.words[G] = this.words[G] & W.words[G];
        return this.length = w.length, this._strip();
      }, O.prototype.iand = function(W) {
        return _((this.negative | W.negative) === 0), this.iuand(W);
      }, O.prototype.and = function(W) {
        if (this.length > W.length) return this.clone().iand(W);
        return W.clone().iand(this);
      }, O.prototype.uand = function(W) {
        if (this.length > W.length) return this.clone().iuand(W);
        return W.clone().iuand(this);
      }, O.prototype.iuxor = function(W) {
        var w, G;
        if (this.length > W.length) w = this, G = W;
        else w = W, G = this;
        for (var S = 0; S < G.length; S++) this.words[S] = w.words[S] ^ G.words[S];
        if (this !== w) for (; S < w.length; S++) this.words[S] = w.words[S];
        return this.length = w.length, this._strip();
      }, O.prototype.ixor = function(W) {
        return _((this.negative | W.negative) === 0), this.iuxor(W);
      }, O.prototype.xor = function(W) {
        if (this.length > W.length) return this.clone().ixor(W);
        return W.clone().ixor(this);
      }, O.prototype.uxor = function(W) {
        if (this.length > W.length) return this.clone().iuxor(W);
        return W.clone().iuxor(this);
      }, O.prototype.inotn = function(W) {
        _(typeof W === "number" && W >= 0);
        var w = Math.ceil(W / 26) | 0, G = W % 26;
        if (this._expand(w), G > 0) w--;
        for (var S = 0; S < w; S++) this.words[S] = ~this.words[S] & 67108863;
        if (G > 0) this.words[S] = ~this.words[S] & 67108863 >> 26 - G;
        return this._strip();
      }, O.prototype.notn = function(W) {
        return this.clone().inotn(W);
      }, O.prototype.setn = function(W, w) {
        _(typeof W === "number" && W >= 0);
        var G = W / 26 | 0, S = W % 26;
        if (this._expand(G + 1), w) this.words[G] = this.words[G] | 1 << S;
        else this.words[G] = this.words[G] & ~(1 << S);
        return this._strip();
      }, O.prototype.iadd = function(W) {
        var w;
        if (this.negative !== 0 && W.negative === 0) return this.negative = 0, w = this.isub(W), this.negative ^= 1, this._normSign();
        else if (this.negative === 0 && W.negative !== 0) return W.negative = 0, w = this.isub(W), W.negative = 1, w._normSign();
        var G, S;
        if (this.length > W.length) G = this, S = W;
        else G = W, S = this;
        var A = 0;
        for (var v = 0; v < S.length; v++) w = (G.words[v] | 0) + (S.words[v] | 0) + A, this.words[v] = w & 67108863, A = w >>> 26;
        for (; A !== 0 && v < G.length; v++) w = (G.words[v] | 0) + A, this.words[v] = w & 67108863, A = w >>> 26;
        if (this.length = G.length, A !== 0) this.words[this.length] = A, this.length++;
        else if (G !== this) for (; v < G.length; v++) this.words[v] = G.words[v];
        return this;
      }, O.prototype.add = function(W) {
        var w;
        if (W.negative !== 0 && this.negative === 0) return W.negative = 0, w = this.sub(W), W.negative ^= 1, w;
        else if (W.negative === 0 && this.negative !== 0) return this.negative = 0, w = W.sub(this), this.negative = 1, w;
        if (this.length > W.length) return this.clone().iadd(W);
        return W.clone().iadd(this);
      }, O.prototype.isub = function(W) {
        if (W.negative !== 0) {
          W.negative = 0;
          var w = this.iadd(W);
          return W.negative = 1, w._normSign();
        } else if (this.negative !== 0) return this.negative = 0, this.iadd(W), this.negative = 1, this._normSign();
        var G = this.cmp(W);
        if (G === 0) return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var S, A;
        if (G > 0) S = this, A = W;
        else S = W, A = this;
        var v = 0;
        for (var k = 0; k < A.length; k++) w = (S.words[k] | 0) - (A.words[k] | 0) + v, v = w >> 26, this.words[k] = w & 67108863;
        for (; v !== 0 && k < S.length; k++) w = (S.words[k] | 0) + v, v = w >> 26, this.words[k] = w & 67108863;
        if (v === 0 && k < S.length && S !== this) for (; k < S.length; k++) this.words[k] = S.words[k];
        if (this.length = Math.max(this.length, k), S !== this) this.negative = 1;
        return this._strip();
      }, O.prototype.sub = function(W) {
        return this.clone().isub(W);
      };
      function D(W, w, G) {
        G.negative = w.negative ^ W.negative;
        var S = W.length + w.length | 0;
        G.length = S, S = S - 1 | 0;
        var A = W.words[0] | 0, v = w.words[0] | 0, k = A * v, R = k & 67108863, C = k / 67108864 | 0;
        G.words[0] = R;
        for (var L = 1; L < S; L++) {
          var x = C >>> 26, l = C & 67108863, a = Math.min(L, w.length - 1);
          for (var f$ = Math.max(0, L - W.length + 1); f$ <= a; f$++) {
            var $$ = L - f$ | 0;
            A = W.words[$$] | 0, v = w.words[f$] | 0, k = A * v + l, x += k / 67108864 | 0, l = k & 67108863;
          }
          G.words[L] = l | 0, C = x | 0;
        }
        if (C !== 0) G.words[L] = C | 0;
        else G.length--;
        return G._strip();
      }
      var g = function(W, w, G) {
        var S = W.words, A = w.words, v = G.words, k = 0, R, C, L, x = S[0] | 0, l = x & 8191, a = x >>> 13, f$ = S[1] | 0, $$ = f$ & 8191, B = f$ >>> 13, H$ = S[2] | 0, Q = H$ & 8191, v$ = H$ >>> 13, t$ = S[3] | 0, m = t$ & 8191, r = t$ >>> 13, J$ = S[4] | 0, e = J$ & 8191, _$2 = J$ >>> 13, Y$ = S[5] | 0, d = Y$ & 8191, o = Y$ >>> 13, W$ = S[6] | 0, t = W$ & 8191, F = W$ >>> 13, X$ = S[7] | 0, z$ = X$ & 8191, j$ = X$ >>> 13, X6 = S[8] | 0, Z$ = X6 & 8191, A$ = X6 >>> 13, d6 = S[9] | 0, S$ = d6 & 8191, V$ = d6 >>> 13, Sq = A[0] | 0, N$ = Sq & 8191, D$ = Sq >>> 13, Mq = A[1] | 0, L$ = Mq & 8191, C$ = Mq >>> 13, fq = A[2] | 0, g$ = fq & 8191, E$ = fq >>> 13, vq = A[3] | 0, b$ = vq & 8191, y$ = vq >>> 13, zq = A[4] | 0, h$ = zq & 8191, u = zq >>> 13, i = A[5] | 0, K$ = i & 8191, P$ = i >>> 13, i$ = A[6] | 0, k$ = i$ & 8191, G$ = i$ >>> 13, x6 = A[7] | 0, R$ = x6 & 8191, u$ = x6 >>> 13, Zq = A[8] | 0, I$ = Zq & 8191, M$ = Zq >>> 13, p6 = A[9] | 0, H6 = p6 & 8191, v6 = p6 >>> 13;
        G.negative = W.negative ^ w.negative, G.length = 19, R = Math.imul(l, N$), C = Math.imul(l, D$), C = C + Math.imul(a, N$) | 0, L = Math.imul(a, D$);
        var C6 = (k + R | 0) + ((C & 8191) << 13) | 0;
        k = (L + (C >>> 13) | 0) + (C6 >>> 26) | 0, C6 &= 67108863, R = Math.imul($$, N$), C = Math.imul($$, D$), C = C + Math.imul(B, N$) | 0, L = Math.imul(B, D$), R = R + Math.imul(l, L$) | 0, C = C + Math.imul(l, C$) | 0, C = C + Math.imul(a, L$) | 0, L = L + Math.imul(a, C$) | 0;
        var S6 = (k + R | 0) + ((C & 8191) << 13) | 0;
        k = (L + (C >>> 13) | 0) + (S6 >>> 26) | 0, S6 &= 67108863, R = Math.imul(Q, N$), C = Math.imul(Q, D$), C = C + Math.imul(v$, N$) | 0, L = Math.imul(v$, D$), R = R + Math.imul($$, L$) | 0, C = C + Math.imul($$, C$) | 0, C = C + Math.imul(B, L$) | 0, L = L + Math.imul(B, C$) | 0, R = R + Math.imul(l, g$) | 0, C = C + Math.imul(l, E$) | 0, C = C + Math.imul(a, g$) | 0, L = L + Math.imul(a, E$) | 0;
        var i6 = (k + R | 0) + ((C & 8191) << 13) | 0;
        k = (L + (C >>> 13) | 0) + (i6 >>> 26) | 0, i6 &= 67108863, R = Math.imul(m, N$), C = Math.imul(m, D$), C = C + Math.imul(r, N$) | 0, L = Math.imul(r, D$), R = R + Math.imul(Q, L$) | 0, C = C + Math.imul(Q, C$) | 0, C = C + Math.imul(v$, L$) | 0, L = L + Math.imul(v$, C$) | 0, R = R + Math.imul($$, g$) | 0, C = C + Math.imul($$, E$) | 0, C = C + Math.imul(B, g$) | 0, L = L + Math.imul(B, E$) | 0, R = R + Math.imul(l, b$) | 0, C = C + Math.imul(l, y$) | 0, C = C + Math.imul(a, b$) | 0, L = L + Math.imul(a, y$) | 0;
        var B6 = (k + R | 0) + ((C & 8191) << 13) | 0;
        k = (L + (C >>> 13) | 0) + (B6 >>> 26) | 0, B6 &= 67108863, R = Math.imul(e, N$), C = Math.imul(e, D$), C = C + Math.imul(_$2, N$) | 0, L = Math.imul(_$2, D$), R = R + Math.imul(m, L$) | 0, C = C + Math.imul(m, C$) | 0, C = C + Math.imul(r, L$) | 0, L = L + Math.imul(r, C$) | 0, R = R + Math.imul(Q, g$) | 0, C = C + Math.imul(Q, E$) | 0, C = C + Math.imul(v$, g$) | 0, L = L + Math.imul(v$, E$) | 0, R = R + Math.imul($$, b$) | 0, C = C + Math.imul($$, y$) | 0, C = C + Math.imul(B, b$) | 0, L = L + Math.imul(B, y$) | 0, R = R + Math.imul(l, h$) | 0, C = C + Math.imul(l, u) | 0, C = C + Math.imul(a, h$) | 0, L = L + Math.imul(a, u) | 0;
        var t6 = (k + R | 0) + ((C & 8191) << 13) | 0;
        k = (L + (C >>> 13) | 0) + (t6 >>> 26) | 0, t6 &= 67108863, R = Math.imul(d, N$), C = Math.imul(d, D$), C = C + Math.imul(o, N$) | 0, L = Math.imul(o, D$), R = R + Math.imul(e, L$) | 0, C = C + Math.imul(e, C$) | 0, C = C + Math.imul(_$2, L$) | 0, L = L + Math.imul(_$2, C$) | 0, R = R + Math.imul(m, g$) | 0, C = C + Math.imul(m, E$) | 0, C = C + Math.imul(r, g$) | 0, L = L + Math.imul(r, E$) | 0, R = R + Math.imul(Q, b$) | 0, C = C + Math.imul(Q, y$) | 0, C = C + Math.imul(v$, b$) | 0, L = L + Math.imul(v$, y$) | 0, R = R + Math.imul($$, h$) | 0, C = C + Math.imul($$, u) | 0, C = C + Math.imul(B, h$) | 0, L = L + Math.imul(B, u) | 0, R = R + Math.imul(l, K$) | 0, C = C + Math.imul(l, P$) | 0, C = C + Math.imul(a, K$) | 0, L = L + Math.imul(a, P$) | 0;
        var U6 = (k + R | 0) + ((C & 8191) << 13) | 0;
        k = (L + (C >>> 13) | 0) + (U6 >>> 26) | 0, U6 &= 67108863, R = Math.imul(t, N$), C = Math.imul(t, D$), C = C + Math.imul(F, N$) | 0, L = Math.imul(F, D$), R = R + Math.imul(d, L$) | 0, C = C + Math.imul(d, C$) | 0, C = C + Math.imul(o, L$) | 0, L = L + Math.imul(o, C$) | 0, R = R + Math.imul(e, g$) | 0, C = C + Math.imul(e, E$) | 0, C = C + Math.imul(_$2, g$) | 0, L = L + Math.imul(_$2, E$) | 0, R = R + Math.imul(m, b$) | 0, C = C + Math.imul(m, y$) | 0, C = C + Math.imul(r, b$) | 0, L = L + Math.imul(r, y$) | 0, R = R + Math.imul(Q, h$) | 0, C = C + Math.imul(Q, u) | 0, C = C + Math.imul(v$, h$) | 0, L = L + Math.imul(v$, u) | 0, R = R + Math.imul($$, K$) | 0, C = C + Math.imul($$, P$) | 0, C = C + Math.imul(B, K$) | 0, L = L + Math.imul(B, P$) | 0, R = R + Math.imul(l, k$) | 0, C = C + Math.imul(l, G$) | 0, C = C + Math.imul(a, k$) | 0, L = L + Math.imul(a, G$) | 0;
        var F6 = (k + R | 0) + ((C & 8191) << 13) | 0;
        k = (L + (C >>> 13) | 0) + (F6 >>> 26) | 0, F6 &= 67108863, R = Math.imul(z$, N$), C = Math.imul(z$, D$), C = C + Math.imul(j$, N$) | 0, L = Math.imul(j$, D$), R = R + Math.imul(t, L$) | 0, C = C + Math.imul(t, C$) | 0, C = C + Math.imul(F, L$) | 0, L = L + Math.imul(F, C$) | 0, R = R + Math.imul(d, g$) | 0, C = C + Math.imul(d, E$) | 0, C = C + Math.imul(o, g$) | 0, L = L + Math.imul(o, E$) | 0, R = R + Math.imul(e, b$) | 0, C = C + Math.imul(e, y$) | 0, C = C + Math.imul(_$2, b$) | 0, L = L + Math.imul(_$2, y$) | 0, R = R + Math.imul(m, h$) | 0, C = C + Math.imul(m, u) | 0, C = C + Math.imul(r, h$) | 0, L = L + Math.imul(r, u) | 0, R = R + Math.imul(Q, K$) | 0, C = C + Math.imul(Q, P$) | 0, C = C + Math.imul(v$, K$) | 0, L = L + Math.imul(v$, P$) | 0, R = R + Math.imul($$, k$) | 0, C = C + Math.imul($$, G$) | 0, C = C + Math.imul(B, k$) | 0, L = L + Math.imul(B, G$) | 0, R = R + Math.imul(l, R$) | 0, C = C + Math.imul(l, u$) | 0, C = C + Math.imul(a, R$) | 0, L = L + Math.imul(a, u$) | 0;
        var a6 = (k + R | 0) + ((C & 8191) << 13) | 0;
        k = (L + (C >>> 13) | 0) + (a6 >>> 26) | 0, a6 &= 67108863, R = Math.imul(Z$, N$), C = Math.imul(Z$, D$), C = C + Math.imul(A$, N$) | 0, L = Math.imul(A$, D$), R = R + Math.imul(z$, L$) | 0, C = C + Math.imul(z$, C$) | 0, C = C + Math.imul(j$, L$) | 0, L = L + Math.imul(j$, C$) | 0, R = R + Math.imul(t, g$) | 0, C = C + Math.imul(t, E$) | 0, C = C + Math.imul(F, g$) | 0, L = L + Math.imul(F, E$) | 0, R = R + Math.imul(d, b$) | 0, C = C + Math.imul(d, y$) | 0, C = C + Math.imul(o, b$) | 0, L = L + Math.imul(o, y$) | 0, R = R + Math.imul(e, h$) | 0, C = C + Math.imul(e, u) | 0, C = C + Math.imul(_$2, h$) | 0, L = L + Math.imul(_$2, u) | 0, R = R + Math.imul(m, K$) | 0, C = C + Math.imul(m, P$) | 0, C = C + Math.imul(r, K$) | 0, L = L + Math.imul(r, P$) | 0, R = R + Math.imul(Q, k$) | 0, C = C + Math.imul(Q, G$) | 0, C = C + Math.imul(v$, k$) | 0, L = L + Math.imul(v$, G$) | 0, R = R + Math.imul($$, R$) | 0, C = C + Math.imul($$, u$) | 0, C = C + Math.imul(B, R$) | 0, L = L + Math.imul(B, u$) | 0, R = R + Math.imul(l, I$) | 0, C = C + Math.imul(l, M$) | 0, C = C + Math.imul(a, I$) | 0, L = L + Math.imul(a, M$) | 0;
        var Q6 = (k + R | 0) + ((C & 8191) << 13) | 0;
        k = (L + (C >>> 13) | 0) + (Q6 >>> 26) | 0, Q6 &= 67108863, R = Math.imul(S$, N$), C = Math.imul(S$, D$), C = C + Math.imul(V$, N$) | 0, L = Math.imul(V$, D$), R = R + Math.imul(Z$, L$) | 0, C = C + Math.imul(Z$, C$) | 0, C = C + Math.imul(A$, L$) | 0, L = L + Math.imul(A$, C$) | 0, R = R + Math.imul(z$, g$) | 0, C = C + Math.imul(z$, E$) | 0, C = C + Math.imul(j$, g$) | 0, L = L + Math.imul(j$, E$) | 0, R = R + Math.imul(t, b$) | 0, C = C + Math.imul(t, y$) | 0, C = C + Math.imul(F, b$) | 0, L = L + Math.imul(F, y$) | 0, R = R + Math.imul(d, h$) | 0, C = C + Math.imul(d, u) | 0, C = C + Math.imul(o, h$) | 0, L = L + Math.imul(o, u) | 0, R = R + Math.imul(e, K$) | 0, C = C + Math.imul(e, P$) | 0, C = C + Math.imul(_$2, K$) | 0, L = L + Math.imul(_$2, P$) | 0, R = R + Math.imul(m, k$) | 0, C = C + Math.imul(m, G$) | 0, C = C + Math.imul(r, k$) | 0, L = L + Math.imul(r, G$) | 0, R = R + Math.imul(Q, R$) | 0, C = C + Math.imul(Q, u$) | 0, C = C + Math.imul(v$, R$) | 0, L = L + Math.imul(v$, u$) | 0, R = R + Math.imul($$, I$) | 0, C = C + Math.imul($$, M$) | 0, C = C + Math.imul(B, I$) | 0, L = L + Math.imul(B, M$) | 0, R = R + Math.imul(l, H6) | 0, C = C + Math.imul(l, v6) | 0, C = C + Math.imul(a, H6) | 0, L = L + Math.imul(a, v6) | 0;
        var e6 = (k + R | 0) + ((C & 8191) << 13) | 0;
        k = (L + (C >>> 13) | 0) + (e6 >>> 26) | 0, e6 &= 67108863, R = Math.imul(S$, L$), C = Math.imul(S$, C$), C = C + Math.imul(V$, L$) | 0, L = Math.imul(V$, C$), R = R + Math.imul(Z$, g$) | 0, C = C + Math.imul(Z$, E$) | 0, C = C + Math.imul(A$, g$) | 0, L = L + Math.imul(A$, E$) | 0, R = R + Math.imul(z$, b$) | 0, C = C + Math.imul(z$, y$) | 0, C = C + Math.imul(j$, b$) | 0, L = L + Math.imul(j$, y$) | 0, R = R + Math.imul(t, h$) | 0, C = C + Math.imul(t, u) | 0, C = C + Math.imul(F, h$) | 0, L = L + Math.imul(F, u) | 0, R = R + Math.imul(d, K$) | 0, C = C + Math.imul(d, P$) | 0, C = C + Math.imul(o, K$) | 0, L = L + Math.imul(o, P$) | 0, R = R + Math.imul(e, k$) | 0, C = C + Math.imul(e, G$) | 0, C = C + Math.imul(_$2, k$) | 0, L = L + Math.imul(_$2, G$) | 0, R = R + Math.imul(m, R$) | 0, C = C + Math.imul(m, u$) | 0, C = C + Math.imul(r, R$) | 0, L = L + Math.imul(r, u$) | 0, R = R + Math.imul(Q, I$) | 0, C = C + Math.imul(Q, M$) | 0, C = C + Math.imul(v$, I$) | 0, L = L + Math.imul(v$, M$) | 0, R = R + Math.imul($$, H6) | 0, C = C + Math.imul($$, v6) | 0, C = C + Math.imul(B, H6) | 0, L = L + Math.imul(B, v6) | 0;
        var s6 = (k + R | 0) + ((C & 8191) << 13) | 0;
        k = (L + (C >>> 13) | 0) + (s6 >>> 26) | 0, s6 &= 67108863, R = Math.imul(S$, g$), C = Math.imul(S$, E$), C = C + Math.imul(V$, g$) | 0, L = Math.imul(V$, E$), R = R + Math.imul(Z$, b$) | 0, C = C + Math.imul(Z$, y$) | 0, C = C + Math.imul(A$, b$) | 0, L = L + Math.imul(A$, y$) | 0, R = R + Math.imul(z$, h$) | 0, C = C + Math.imul(z$, u) | 0, C = C + Math.imul(j$, h$) | 0, L = L + Math.imul(j$, u) | 0, R = R + Math.imul(t, K$) | 0, C = C + Math.imul(t, P$) | 0, C = C + Math.imul(F, K$) | 0, L = L + Math.imul(F, P$) | 0, R = R + Math.imul(d, k$) | 0, C = C + Math.imul(d, G$) | 0, C = C + Math.imul(o, k$) | 0, L = L + Math.imul(o, G$) | 0, R = R + Math.imul(e, R$) | 0, C = C + Math.imul(e, u$) | 0, C = C + Math.imul(_$2, R$) | 0, L = L + Math.imul(_$2, u$) | 0, R = R + Math.imul(m, I$) | 0, C = C + Math.imul(m, M$) | 0, C = C + Math.imul(r, I$) | 0, L = L + Math.imul(r, M$) | 0, R = R + Math.imul(Q, H6) | 0, C = C + Math.imul(Q, v6) | 0, C = C + Math.imul(v$, H6) | 0, L = L + Math.imul(v$, v6) | 0;
        var $q = (k + R | 0) + ((C & 8191) << 13) | 0;
        k = (L + (C >>> 13) | 0) + ($q >>> 26) | 0, $q &= 67108863, R = Math.imul(S$, b$), C = Math.imul(S$, y$), C = C + Math.imul(V$, b$) | 0, L = Math.imul(V$, y$), R = R + Math.imul(Z$, h$) | 0, C = C + Math.imul(Z$, u) | 0, C = C + Math.imul(A$, h$) | 0, L = L + Math.imul(A$, u) | 0, R = R + Math.imul(z$, K$) | 0, C = C + Math.imul(z$, P$) | 0, C = C + Math.imul(j$, K$) | 0, L = L + Math.imul(j$, P$) | 0, R = R + Math.imul(t, k$) | 0, C = C + Math.imul(t, G$) | 0, C = C + Math.imul(F, k$) | 0, L = L + Math.imul(F, G$) | 0, R = R + Math.imul(d, R$) | 0, C = C + Math.imul(d, u$) | 0, C = C + Math.imul(o, R$) | 0, L = L + Math.imul(o, u$) | 0, R = R + Math.imul(e, I$) | 0, C = C + Math.imul(e, M$) | 0, C = C + Math.imul(_$2, I$) | 0, L = L + Math.imul(_$2, M$) | 0, R = R + Math.imul(m, H6) | 0, C = C + Math.imul(m, v6) | 0, C = C + Math.imul(r, H6) | 0, L = L + Math.imul(r, v6) | 0;
        var qq = (k + R | 0) + ((C & 8191) << 13) | 0;
        k = (L + (C >>> 13) | 0) + (qq >>> 26) | 0, qq &= 67108863, R = Math.imul(S$, h$), C = Math.imul(S$, u), C = C + Math.imul(V$, h$) | 0, L = Math.imul(V$, u), R = R + Math.imul(Z$, K$) | 0, C = C + Math.imul(Z$, P$) | 0, C = C + Math.imul(A$, K$) | 0, L = L + Math.imul(A$, P$) | 0, R = R + Math.imul(z$, k$) | 0, C = C + Math.imul(z$, G$) | 0, C = C + Math.imul(j$, k$) | 0, L = L + Math.imul(j$, G$) | 0, R = R + Math.imul(t, R$) | 0, C = C + Math.imul(t, u$) | 0, C = C + Math.imul(F, R$) | 0, L = L + Math.imul(F, u$) | 0, R = R + Math.imul(d, I$) | 0, C = C + Math.imul(d, M$) | 0, C = C + Math.imul(o, I$) | 0, L = L + Math.imul(o, M$) | 0, R = R + Math.imul(e, H6) | 0, C = C + Math.imul(e, v6) | 0, C = C + Math.imul(_$2, H6) | 0, L = L + Math.imul(_$2, v6) | 0;
        var Kq = (k + R | 0) + ((C & 8191) << 13) | 0;
        k = (L + (C >>> 13) | 0) + (Kq >>> 26) | 0, Kq &= 67108863, R = Math.imul(S$, K$), C = Math.imul(S$, P$), C = C + Math.imul(V$, K$) | 0, L = Math.imul(V$, P$), R = R + Math.imul(Z$, k$) | 0, C = C + Math.imul(Z$, G$) | 0, C = C + Math.imul(A$, k$) | 0, L = L + Math.imul(A$, G$) | 0, R = R + Math.imul(z$, R$) | 0, C = C + Math.imul(z$, u$) | 0, C = C + Math.imul(j$, R$) | 0, L = L + Math.imul(j$, u$) | 0, R = R + Math.imul(t, I$) | 0, C = C + Math.imul(t, M$) | 0, C = C + Math.imul(F, I$) | 0, L = L + Math.imul(F, M$) | 0, R = R + Math.imul(d, H6) | 0, C = C + Math.imul(d, v6) | 0, C = C + Math.imul(o, H6) | 0, L = L + Math.imul(o, v6) | 0;
        var _q = (k + R | 0) + ((C & 8191) << 13) | 0;
        k = (L + (C >>> 13) | 0) + (_q >>> 26) | 0, _q &= 67108863, R = Math.imul(S$, k$), C = Math.imul(S$, G$), C = C + Math.imul(V$, k$) | 0, L = Math.imul(V$, G$), R = R + Math.imul(Z$, R$) | 0, C = C + Math.imul(Z$, u$) | 0, C = C + Math.imul(A$, R$) | 0, L = L + Math.imul(A$, u$) | 0, R = R + Math.imul(z$, I$) | 0, C = C + Math.imul(z$, M$) | 0, C = C + Math.imul(j$, I$) | 0, L = L + Math.imul(j$, M$) | 0, R = R + Math.imul(t, H6) | 0, C = C + Math.imul(t, v6) | 0, C = C + Math.imul(F, H6) | 0, L = L + Math.imul(F, v6) | 0;
        var Pq = (k + R | 0) + ((C & 8191) << 13) | 0;
        k = (L + (C >>> 13) | 0) + (Pq >>> 26) | 0, Pq &= 67108863, R = Math.imul(S$, R$), C = Math.imul(S$, u$), C = C + Math.imul(V$, R$) | 0, L = Math.imul(V$, u$), R = R + Math.imul(Z$, I$) | 0, C = C + Math.imul(Z$, M$) | 0, C = C + Math.imul(A$, I$) | 0, L = L + Math.imul(A$, M$) | 0, R = R + Math.imul(z$, H6) | 0, C = C + Math.imul(z$, v6) | 0, C = C + Math.imul(j$, H6) | 0, L = L + Math.imul(j$, v6) | 0;
        var CO = (k + R | 0) + ((C & 8191) << 13) | 0;
        k = (L + (C >>> 13) | 0) + (CO >>> 26) | 0, CO &= 67108863, R = Math.imul(S$, I$), C = Math.imul(S$, M$), C = C + Math.imul(V$, I$) | 0, L = Math.imul(V$, M$), R = R + Math.imul(Z$, H6) | 0, C = C + Math.imul(Z$, v6) | 0, C = C + Math.imul(A$, H6) | 0, L = L + Math.imul(A$, v6) | 0;
        var EO = (k + R | 0) + ((C & 8191) << 13) | 0;
        k = (L + (C >>> 13) | 0) + (EO >>> 26) | 0, EO &= 67108863, R = Math.imul(S$, H6), C = Math.imul(S$, v6), C = C + Math.imul(V$, H6) | 0, L = Math.imul(V$, v6);
        var hO = (k + R | 0) + ((C & 8191) << 13) | 0;
        if (k = (L + (C >>> 13) | 0) + (hO >>> 26) | 0, hO &= 67108863, v[0] = C6, v[1] = S6, v[2] = i6, v[3] = B6, v[4] = t6, v[5] = U6, v[6] = F6, v[7] = a6, v[8] = Q6, v[9] = e6, v[10] = s6, v[11] = $q, v[12] = qq, v[13] = Kq, v[14] = _q, v[15] = Pq, v[16] = CO, v[17] = EO, v[18] = hO, k !== 0) v[19] = k, G.length++;
        return G;
      };
      if (!Math.imul) g = D;
      function b(W, w, G) {
        G.negative = w.negative ^ W.negative, G.length = W.length + w.length;
        var S = 0, A = 0;
        for (var v = 0; v < G.length - 1; v++) {
          var k = A;
          A = 0;
          var R = S & 67108863, C = Math.min(v, w.length - 1);
          for (var L = Math.max(0, v - W.length + 1); L <= C; L++) {
            var x = v - L, l = W.words[x] | 0, a = w.words[L] | 0, f$ = l * a, $$ = f$ & 67108863;
            k = k + (f$ / 67108864 | 0) | 0, $$ = $$ + R | 0, R = $$ & 67108863, k = k + ($$ >>> 26) | 0, A += k >>> 26, k &= 67108863;
          }
          G.words[v] = R, S = k, k = A;
        }
        if (S !== 0) G.words[v] = S;
        else G.length--;
        return G._strip();
      }
      function y(W, w, G) {
        return b(W, w, G);
      }
      O.prototype.mulTo = function(W, w) {
        var G, S = this.length + W.length;
        if (this.length === 10 && W.length === 10) G = g(this, W, w);
        else if (S < 63) G = D(this, W, w);
        else if (S < 1024) G = b(this, W, w);
        else G = y(this, W, w);
        return G;
      };
      function p(W, w) {
        this.x = W, this.y = w;
      }
      p.prototype.makeRBT = function(W) {
        var w = Array(W), G = O.prototype._countBits(W) - 1;
        for (var S = 0; S < W; S++) w[S] = this.revBin(S, G, W);
        return w;
      }, p.prototype.revBin = function(W, w, G) {
        if (W === 0 || W === G - 1) return W;
        var S = 0;
        for (var A = 0; A < w; A++) S |= (W & 1) << w - A - 1, W >>= 1;
        return S;
      }, p.prototype.permute = function(W, w, G, S, A, v) {
        for (var k = 0; k < v; k++) S[k] = w[W[k]], A[k] = G[W[k]];
      }, p.prototype.transform = function(W, w, G, S, A, v) {
        this.permute(v, W, w, G, S, A);
        for (var k = 1; k < A; k <<= 1) {
          var R = k << 1, C = Math.cos(2 * Math.PI / R), L = Math.sin(2 * Math.PI / R);
          for (var x = 0; x < A; x += R) {
            var l = C, a = L;
            for (var f$ = 0; f$ < k; f$++) {
              var $$ = G[x + f$], B = S[x + f$], H$ = G[x + f$ + k], Q = S[x + f$ + k], v$ = l * H$ - a * Q;
              if (Q = l * Q + a * H$, H$ = v$, G[x + f$] = $$ + H$, S[x + f$] = B + Q, G[x + f$ + k] = $$ - H$, S[x + f$ + k] = B - Q, f$ !== R) v$ = C * l - L * a, a = C * a + L * l, l = v$;
            }
          }
        }
      }, p.prototype.guessLen13b = function(W, w) {
        var G = Math.max(w, W) | 1, S = G & 1, A = 0;
        for (G = G / 2 | 0; G; G = G >>> 1) A++;
        return 1 << A + 1 + S;
      }, p.prototype.conjugate = function(W, w, G) {
        if (G <= 1) return;
        for (var S = 0; S < G / 2; S++) {
          var A = W[S];
          W[S] = W[G - S - 1], W[G - S - 1] = A, A = w[S], w[S] = -w[G - S - 1], w[G - S - 1] = -A;
        }
      }, p.prototype.normalize13b = function(W, w) {
        var G = 0;
        for (var S = 0; S < w / 2; S++) {
          var A = Math.round(W[2 * S + 1] / w) * 8192 + Math.round(W[2 * S] / w) + G;
          if (W[S] = A & 67108863, A < 67108864) G = 0;
          else G = A / 67108864 | 0;
        }
        return W;
      }, p.prototype.convert13b = function(W, w, G, S) {
        var A = 0;
        for (var v = 0; v < w; v++) A = A + (W[v] | 0), G[2 * v] = A & 8191, A = A >>> 13, G[2 * v + 1] = A & 8191, A = A >>> 13;
        for (v = 2 * w; v < S; ++v) G[v] = 0;
        _(A === 0), _((A & -8192) === 0);
      }, p.prototype.stub = function(W) {
        var w = Array(W);
        for (var G = 0; G < W; G++) w[G] = 0;
        return w;
      }, p.prototype.mulp = function(W, w, G) {
        var S = 2 * this.guessLen13b(W.length, w.length), A = this.makeRBT(S), v = this.stub(S), k = Array(S), R = Array(S), C = Array(S), L = Array(S), x = Array(S), l = Array(S), a = G.words;
        a.length = S, this.convert13b(W.words, W.length, k, S), this.convert13b(w.words, w.length, L, S), this.transform(k, v, R, C, S, A), this.transform(L, v, x, l, S, A);
        for (var f$ = 0; f$ < S; f$++) {
          var $$ = R[f$] * x[f$] - C[f$] * l[f$];
          C[f$] = R[f$] * l[f$] + C[f$] * x[f$], R[f$] = $$;
        }
        return this.conjugate(R, C, S), this.transform(R, C, a, v, S, A), this.conjugate(a, v, S), this.normalize13b(a, S), G.negative = W.negative ^ w.negative, G.length = W.length + w.length, G._strip();
      }, O.prototype.mul = function(W) {
        var w = new O(null);
        return w.words = Array(this.length + W.length), this.mulTo(W, w);
      }, O.prototype.mulf = function(W) {
        var w = new O(null);
        return w.words = Array(this.length + W.length), y(this, W, w);
      }, O.prototype.imul = function(W) {
        return this.clone().mulTo(W, this);
      }, O.prototype.imuln = function(W) {
        var w = W < 0;
        if (w) W = -W;
        _(typeof W === "number"), _(W < 67108864);
        var G = 0;
        for (var S = 0; S < this.length; S++) {
          var A = (this.words[S] | 0) * W, v = (A & 67108863) + (G & 67108863);
          G >>= 26, G += A / 67108864 | 0, G += v >>> 26, this.words[S] = v & 67108863;
        }
        if (G !== 0) this.words[S] = G, this.length++;
        return this.length = W === 0 ? 1 : this.length, w ? this.ineg() : this;
      }, O.prototype.muln = function(W) {
        return this.clone().imuln(W);
      }, O.prototype.sqr = function() {
        return this.mul(this);
      }, O.prototype.isqr = function() {
        return this.imul(this.clone());
      }, O.prototype.pow = function(W) {
        var w = I(W);
        if (w.length === 0) return new O(1);
        var G = this;
        for (var S = 0; S < w.length; S++, G = G.sqr()) if (w[S] !== 0) break;
        if (++S < w.length) for (var A = G.sqr(); S < w.length; S++, A = A.sqr()) {
          if (w[S] === 0) continue;
          G = G.mul(A);
        }
        return G;
      }, O.prototype.iushln = function(W) {
        _(typeof W === "number" && W >= 0);
        var w = W % 26, G = (W - w) / 26, S = 67108863 >>> 26 - w << 26 - w, A;
        if (w !== 0) {
          var v = 0;
          for (A = 0; A < this.length; A++) {
            var k = this.words[A] & S, R = (this.words[A] | 0) - k << w;
            this.words[A] = R | v, v = k >>> 26 - w;
          }
          if (v) this.words[A] = v, this.length++;
        }
        if (G !== 0) {
          for (A = this.length - 1; A >= 0; A--) this.words[A + G] = this.words[A];
          for (A = 0; A < G; A++) this.words[A] = 0;
          this.length += G;
        }
        return this._strip();
      }, O.prototype.ishln = function(W) {
        return _(this.negative === 0), this.iushln(W);
      }, O.prototype.iushrn = function(W, w, G) {
        _(typeof W === "number" && W >= 0);
        var S;
        if (w) S = (w - w % 26) / 26;
        else S = 0;
        var A = W % 26, v = Math.min((W - A) / 26, this.length), k = 67108863 ^ 67108863 >>> A << A, R = G;
        if (S -= v, S = Math.max(0, S), R) {
          for (var C = 0; C < v; C++) R.words[C] = this.words[C];
          R.length = v;
        }
        if (v === 0) ;
        else if (this.length > v) {
          this.length -= v;
          for (C = 0; C < this.length; C++) this.words[C] = this.words[C + v];
        } else this.words[0] = 0, this.length = 1;
        var L = 0;
        for (C = this.length - 1; C >= 0 && (L !== 0 || C >= S); C--) {
          var x = this.words[C] | 0;
          this.words[C] = L << 26 - A | x >>> A, L = x & k;
        }
        if (R && L !== 0) R.words[R.length++] = L;
        if (this.length === 0) this.words[0] = 0, this.length = 1;
        return this._strip();
      }, O.prototype.ishrn = function(W, w, G) {
        return _(this.negative === 0), this.iushrn(W, w, G);
      }, O.prototype.shln = function(W) {
        return this.clone().ishln(W);
      }, O.prototype.ushln = function(W) {
        return this.clone().iushln(W);
      }, O.prototype.shrn = function(W) {
        return this.clone().ishrn(W);
      }, O.prototype.ushrn = function(W) {
        return this.clone().iushrn(W);
      }, O.prototype.testn = function(W) {
        _(typeof W === "number" && W >= 0);
        var w = W % 26, G = (W - w) / 26, S = 1 << w;
        if (this.length <= G) return false;
        var A = this.words[G];
        return !!(A & S);
      }, O.prototype.imaskn = function(W) {
        _(typeof W === "number" && W >= 0);
        var w = W % 26, G = (W - w) / 26;
        if (_(this.negative === 0, "imaskn works only with positive numbers"), this.length <= G) return this;
        if (w !== 0) G++;
        if (this.length = Math.min(G, this.length), w !== 0) {
          var S = 67108863 ^ 67108863 >>> w << w;
          this.words[this.length - 1] &= S;
        }
        return this._strip();
      }, O.prototype.maskn = function(W) {
        return this.clone().imaskn(W);
      }, O.prototype.iaddn = function(W) {
        if (_(typeof W === "number"), _(W < 67108864), W < 0) return this.isubn(-W);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) <= W) return this.words[0] = W - (this.words[0] | 0), this.negative = 0, this;
          return this.negative = 0, this.isubn(W), this.negative = 1, this;
        }
        return this._iaddn(W);
      }, O.prototype._iaddn = function(W) {
        this.words[0] += W;
        for (var w = 0; w < this.length && this.words[w] >= 67108864; w++) if (this.words[w] -= 67108864, w === this.length - 1) this.words[w + 1] = 1;
        else this.words[w + 1]++;
        return this.length = Math.max(this.length, w + 1), this;
      }, O.prototype.isubn = function(W) {
        if (_(typeof W === "number"), _(W < 67108864), W < 0) return this.iaddn(-W);
        if (this.negative !== 0) return this.negative = 0, this.iaddn(W), this.negative = 1, this;
        if (this.words[0] -= W, this.length === 1 && this.words[0] < 0) this.words[0] = -this.words[0], this.negative = 1;
        else for (var w = 0; w < this.length && this.words[w] < 0; w++) this.words[w] += 67108864, this.words[w + 1] -= 1;
        return this._strip();
      }, O.prototype.addn = function(W) {
        return this.clone().iaddn(W);
      }, O.prototype.subn = function(W) {
        return this.clone().isubn(W);
      }, O.prototype.iabs = function() {
        return this.negative = 0, this;
      }, O.prototype.abs = function() {
        return this.clone().iabs();
      }, O.prototype._ishlnsubmul = function(W, w, G) {
        var S = W.length + G, A;
        this._expand(S);
        var v, k = 0;
        for (A = 0; A < W.length; A++) {
          v = (this.words[A + G] | 0) + k;
          var R = (W.words[A] | 0) * w;
          v -= R & 67108863, k = (v >> 26) - (R / 67108864 | 0), this.words[A + G] = v & 67108863;
        }
        for (; A < this.length - G; A++) v = (this.words[A + G] | 0) + k, k = v >> 26, this.words[A + G] = v & 67108863;
        if (k === 0) return this._strip();
        _(k === -1), k = 0;
        for (A = 0; A < this.length; A++) v = -(this.words[A] | 0) + k, k = v >> 26, this.words[A] = v & 67108863;
        return this.negative = 1, this._strip();
      }, O.prototype._wordDiv = function(W, w) {
        var G = this.length - W.length, S = this.clone(), A = W, v = A.words[A.length - 1] | 0, k = this._countBits(v);
        if (G = 26 - k, G !== 0) A = A.ushln(G), S.iushln(G), v = A.words[A.length - 1] | 0;
        var R = S.length - A.length, C;
        if (w !== "mod") {
          C = new O(null), C.length = R + 1, C.words = Array(C.length);
          for (var L = 0; L < C.length; L++) C.words[L] = 0;
        }
        var x = S.clone()._ishlnsubmul(A, 1, R);
        if (x.negative === 0) {
          if (S = x, C) C.words[R] = 1;
        }
        for (var l = R - 1; l >= 0; l--) {
          var a = (S.words[A.length + l] | 0) * 67108864 + (S.words[A.length + l - 1] | 0);
          a = Math.min(a / v | 0, 67108863), S._ishlnsubmul(A, a, l);
          while (S.negative !== 0) if (a--, S.negative = 0, S._ishlnsubmul(A, 1, l), !S.isZero()) S.negative ^= 1;
          if (C) C.words[l] = a;
        }
        if (C) C._strip();
        if (S._strip(), w !== "div" && G !== 0) S.iushrn(G);
        return { div: C || null, mod: S };
      }, O.prototype.divmod = function(W, w, G) {
        if (_(!W.isZero()), this.isZero()) return { div: new O(0), mod: new O(0) };
        var S, A, v;
        if (this.negative !== 0 && W.negative === 0) {
          if (v = this.neg().divmod(W, w), w !== "mod") S = v.div.neg();
          if (w !== "div") {
            if (A = v.mod.neg(), G && A.negative !== 0) A.iadd(W);
          }
          return { div: S, mod: A };
        }
        if (this.negative === 0 && W.negative !== 0) {
          if (v = this.divmod(W.neg(), w), w !== "mod") S = v.div.neg();
          return { div: S, mod: v.mod };
        }
        if ((this.negative & W.negative) !== 0) {
          if (v = this.neg().divmod(W.neg(), w), w !== "div") {
            if (A = v.mod.neg(), G && A.negative !== 0) A.isub(W);
          }
          return { div: v.div, mod: A };
        }
        if (W.length > this.length || this.cmp(W) < 0) return { div: new O(0), mod: this };
        if (W.length === 1) {
          if (w === "div") return { div: this.divn(W.words[0]), mod: null };
          if (w === "mod") return { div: null, mod: new O(this.modrn(W.words[0])) };
          return { div: this.divn(W.words[0]), mod: new O(this.modrn(W.words[0])) };
        }
        return this._wordDiv(W, w);
      }, O.prototype.div = function(W) {
        return this.divmod(W, "div", false).div;
      }, O.prototype.mod = function(W) {
        return this.divmod(W, "mod", false).mod;
      }, O.prototype.umod = function(W) {
        return this.divmod(W, "mod", true).mod;
      }, O.prototype.divRound = function(W) {
        var w = this.divmod(W);
        if (w.mod.isZero()) return w.div;
        var G = w.div.negative !== 0 ? w.mod.isub(W) : w.mod, S = W.ushrn(1), A = W.andln(1), v = G.cmp(S);
        if (v < 0 || A === 1 && v === 0) return w.div;
        return w.div.negative !== 0 ? w.div.isubn(1) : w.div.iaddn(1);
      }, O.prototype.modrn = function(W) {
        var w = W < 0;
        if (w) W = -W;
        _(W <= 67108863);
        var G = 67108864 % W, S = 0;
        for (var A = this.length - 1; A >= 0; A--) S = (G * S + (this.words[A] | 0)) % W;
        return w ? -S : S;
      }, O.prototype.modn = function(W) {
        return this.modrn(W);
      }, O.prototype.idivn = function(W) {
        var w = W < 0;
        if (w) W = -W;
        _(W <= 67108863);
        var G = 0;
        for (var S = this.length - 1; S >= 0; S--) {
          var A = (this.words[S] | 0) + G * 67108864;
          this.words[S] = A / W | 0, G = A % W;
        }
        return this._strip(), w ? this.ineg() : this;
      }, O.prototype.divn = function(W) {
        return this.clone().idivn(W);
      }, O.prototype.egcd = function(W) {
        _(W.negative === 0), _(!W.isZero());
        var w = this, G = W.clone();
        if (w.negative !== 0) w = w.umod(W);
        else w = w.clone();
        var S = new O(1), A = new O(0), v = new O(0), k = new O(1), R = 0;
        while (w.isEven() && G.isEven()) w.iushrn(1), G.iushrn(1), ++R;
        var C = G.clone(), L = w.clone();
        while (!w.isZero()) {
          for (var x = 0, l = 1; (w.words[0] & l) === 0 && x < 26; ++x, l <<= 1) ;
          if (x > 0) {
            w.iushrn(x);
            while (x-- > 0) {
              if (S.isOdd() || A.isOdd()) S.iadd(C), A.isub(L);
              S.iushrn(1), A.iushrn(1);
            }
          }
          for (var a = 0, f$ = 1; (G.words[0] & f$) === 0 && a < 26; ++a, f$ <<= 1) ;
          if (a > 0) {
            G.iushrn(a);
            while (a-- > 0) {
              if (v.isOdd() || k.isOdd()) v.iadd(C), k.isub(L);
              v.iushrn(1), k.iushrn(1);
            }
          }
          if (w.cmp(G) >= 0) w.isub(G), S.isub(v), A.isub(k);
          else G.isub(w), v.isub(S), k.isub(A);
        }
        return { a: v, b: k, gcd: G.iushln(R) };
      }, O.prototype._invmp = function(W) {
        _(W.negative === 0), _(!W.isZero());
        var w = this, G = W.clone();
        if (w.negative !== 0) w = w.umod(W);
        else w = w.clone();
        var S = new O(1), A = new O(0), v = G.clone();
        while (w.cmpn(1) > 0 && G.cmpn(1) > 0) {
          for (var k = 0, R = 1; (w.words[0] & R) === 0 && k < 26; ++k, R <<= 1) ;
          if (k > 0) {
            w.iushrn(k);
            while (k-- > 0) {
              if (S.isOdd()) S.iadd(v);
              S.iushrn(1);
            }
          }
          for (var C = 0, L = 1; (G.words[0] & L) === 0 && C < 26; ++C, L <<= 1) ;
          if (C > 0) {
            G.iushrn(C);
            while (C-- > 0) {
              if (A.isOdd()) A.iadd(v);
              A.iushrn(1);
            }
          }
          if (w.cmp(G) >= 0) w.isub(G), S.isub(A);
          else G.isub(w), A.isub(S);
        }
        var x;
        if (w.cmpn(1) === 0) x = S;
        else x = A;
        if (x.cmpn(0) < 0) x.iadd(W);
        return x;
      }, O.prototype.gcd = function(W) {
        if (this.isZero()) return W.abs();
        if (W.isZero()) return this.abs();
        var w = this.clone(), G = W.clone();
        w.negative = 0, G.negative = 0;
        for (var S = 0; w.isEven() && G.isEven(); S++) w.iushrn(1), G.iushrn(1);
        do {
          while (w.isEven()) w.iushrn(1);
          while (G.isEven()) G.iushrn(1);
          var A = w.cmp(G);
          if (A < 0) {
            var v = w;
            w = G, G = v;
          } else if (A === 0 || G.cmpn(1) === 0) break;
          w.isub(G);
        } while (true);
        return G.iushln(S);
      }, O.prototype.invm = function(W) {
        return this.egcd(W).a.umod(W);
      }, O.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, O.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, O.prototype.andln = function(W) {
        return this.words[0] & W;
      }, O.prototype.bincn = function(W) {
        _(typeof W === "number");
        var w = W % 26, G = (W - w) / 26, S = 1 << w;
        if (this.length <= G) return this._expand(G + 1), this.words[G] |= S, this;
        var A = S;
        for (var v = G; A !== 0 && v < this.length; v++) {
          var k = this.words[v] | 0;
          k += A, A = k >>> 26, k &= 67108863, this.words[v] = k;
        }
        if (A !== 0) this.words[v] = A, this.length++;
        return this;
      }, O.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, O.prototype.cmpn = function(W) {
        var w = W < 0;
        if (this.negative !== 0 && !w) return -1;
        if (this.negative === 0 && w) return 1;
        this._strip();
        var G;
        if (this.length > 1) G = 1;
        else {
          if (w) W = -W;
          _(W <= 67108863, "Number is too big");
          var S = this.words[0] | 0;
          G = S === W ? 0 : S < W ? -1 : 1;
        }
        if (this.negative !== 0) return -G | 0;
        return G;
      }, O.prototype.cmp = function(W) {
        if (this.negative !== 0 && W.negative === 0) return -1;
        if (this.negative === 0 && W.negative !== 0) return 1;
        var w = this.ucmp(W);
        if (this.negative !== 0) return -w | 0;
        return w;
      }, O.prototype.ucmp = function(W) {
        if (this.length > W.length) return 1;
        if (this.length < W.length) return -1;
        var w = 0;
        for (var G = this.length - 1; G >= 0; G--) {
          var S = this.words[G] | 0, A = W.words[G] | 0;
          if (S === A) continue;
          if (S < A) w = -1;
          else if (S > A) w = 1;
          break;
        }
        return w;
      }, O.prototype.gtn = function(W) {
        return this.cmpn(W) === 1;
      }, O.prototype.gt = function(W) {
        return this.cmp(W) === 1;
      }, O.prototype.gten = function(W) {
        return this.cmpn(W) >= 0;
      }, O.prototype.gte = function(W) {
        return this.cmp(W) >= 0;
      }, O.prototype.ltn = function(W) {
        return this.cmpn(W) === -1;
      }, O.prototype.lt = function(W) {
        return this.cmp(W) === -1;
      }, O.prototype.lten = function(W) {
        return this.cmpn(W) <= 0;
      }, O.prototype.lte = function(W) {
        return this.cmp(W) <= 0;
      }, O.prototype.eqn = function(W) {
        return this.cmpn(W) === 0;
      }, O.prototype.eq = function(W) {
        return this.cmp(W) === 0;
      }, O.red = function(W) {
        return new H(W);
      }, O.prototype.toRed = function(W) {
        return _(!this.red, "Already a number in reduction context"), _(this.negative === 0, "red works only with positives"), W.convertTo(this)._forceRed(W);
      }, O.prototype.fromRed = function() {
        return _(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, O.prototype._forceRed = function(W) {
        return this.red = W, this;
      }, O.prototype.forceRed = function(W) {
        return _(!this.red, "Already a number in reduction context"), this._forceRed(W);
      }, O.prototype.redAdd = function(W) {
        return _(this.red, "redAdd works only with red numbers"), this.red.add(this, W);
      }, O.prototype.redIAdd = function(W) {
        return _(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, W);
      }, O.prototype.redSub = function(W) {
        return _(this.red, "redSub works only with red numbers"), this.red.sub(this, W);
      }, O.prototype.redISub = function(W) {
        return _(this.red, "redISub works only with red numbers"), this.red.isub(this, W);
      }, O.prototype.redShl = function(W) {
        return _(this.red, "redShl works only with red numbers"), this.red.shl(this, W);
      }, O.prototype.redMul = function(W) {
        return _(this.red, "redMul works only with red numbers"), this.red._verify2(this, W), this.red.mul(this, W);
      }, O.prototype.redIMul = function(W) {
        return _(this.red, "redMul works only with red numbers"), this.red._verify2(this, W), this.red.imul(this, W);
      }, O.prototype.redSqr = function() {
        return _(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, O.prototype.redISqr = function() {
        return _(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, O.prototype.redSqrt = function() {
        return _(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, O.prototype.redInvm = function() {
        return _(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, O.prototype.redNeg = function() {
        return _(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, O.prototype.redPow = function(W) {
        return _(this.red && !W.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, W);
      };
      var n = { k256: null, p224: null, p192: null, p25519: null };
      function s(W, w) {
        this.name = W, this.p = new O(w, 16), this.n = this.p.bitLength(), this.k = new O(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      s.prototype._tmp = function() {
        var W = new O(null);
        return W.words = Array(Math.ceil(this.n / 13)), W;
      }, s.prototype.ireduce = function(W) {
        var w = W, G;
        do
          this.split(w, this.tmp), w = this.imulK(w), w = w.iadd(this.tmp), G = w.bitLength();
        while (G > this.n);
        var S = G < this.n ? -1 : w.ucmp(this.p);
        if (S === 0) w.words[0] = 0, w.length = 1;
        else if (S > 0) w.isub(this.p);
        else if (w.strip !== void 0) w.strip();
        else w._strip();
        return w;
      }, s.prototype.split = function(W, w) {
        W.iushrn(this.n, 0, w);
      }, s.prototype.imulK = function(W) {
        return W.imul(this.k);
      };
      function q$() {
        s.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
      }
      Y(q$, s), q$.prototype.split = function(W, w) {
        var G = 4194303, S = Math.min(W.length, 9);
        for (var A = 0; A < S; A++) w.words[A] = W.words[A];
        if (w.length = S, W.length <= 9) {
          W.words[0] = 0, W.length = 1;
          return;
        }
        var v = W.words[9];
        w.words[w.length++] = v & G;
        for (A = 10; A < W.length; A++) {
          var k = W.words[A] | 0;
          W.words[A - 10] = (k & G) << 4 | v >>> 22, v = k;
        }
        if (v >>>= 22, W.words[A - 10] = v, v === 0 && W.length > 10) W.length -= 10;
        else W.length -= 9;
      }, q$.prototype.imulK = function(W) {
        W.words[W.length] = 0, W.words[W.length + 1] = 0, W.length += 2;
        var w = 0;
        for (var G = 0; G < W.length; G++) {
          var S = W.words[G] | 0;
          w += S * 977, W.words[G] = w & 67108863, w = S * 64 + (w / 67108864 | 0);
        }
        if (W.words[W.length - 1] === 0) {
          if (W.length--, W.words[W.length - 1] === 0) W.length--;
        }
        return W;
      };
      function c() {
        s.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
      }
      Y(c, s);
      function U() {
        s.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
      }
      Y(U, s);
      function j() {
        s.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
      }
      Y(j, s), j.prototype.imulK = function(W) {
        var w = 0;
        for (var G = 0; G < W.length; G++) {
          var S = (W.words[G] | 0) * 19 + w, A = S & 67108863;
          S >>>= 26, W.words[G] = A, w = S;
        }
        if (w !== 0) W.words[W.length++] = w;
        return W;
      }, O._prime = function(W) {
        if (n[W]) return n[W];
        var w;
        if (W === "k256") w = new q$();
        else if (W === "p224") w = new c();
        else if (W === "p192") w = new U();
        else if (W === "p25519") w = new j();
        else throw Error("Unknown prime " + W);
        return n[W] = w, w;
      };
      function H(W) {
        if (typeof W === "string") {
          var w = O._prime(W);
          this.m = w.p, this.prime = w;
        } else _(W.gtn(1), "modulus must be greater than 1"), this.m = W, this.prime = null;
      }
      H.prototype._verify1 = function(W) {
        _(W.negative === 0, "red works only with positives"), _(W.red, "red works only with red numbers");
      }, H.prototype._verify2 = function(W, w) {
        _((W.negative | w.negative) === 0, "red works only with positives"), _(W.red && W.red === w.red, "red works only with red numbers");
      }, H.prototype.imod = function(W) {
        if (this.prime) return this.prime.ireduce(W)._forceRed(this);
        return f(W, W.umod(this.m)._forceRed(this)), W;
      }, H.prototype.neg = function(W) {
        if (W.isZero()) return W.clone();
        return this.m.sub(W)._forceRed(this);
      }, H.prototype.add = function(W, w) {
        this._verify2(W, w);
        var G = W.add(w);
        if (G.cmp(this.m) >= 0) G.isub(this.m);
        return G._forceRed(this);
      }, H.prototype.iadd = function(W, w) {
        this._verify2(W, w);
        var G = W.iadd(w);
        if (G.cmp(this.m) >= 0) G.isub(this.m);
        return G;
      }, H.prototype.sub = function(W, w) {
        this._verify2(W, w);
        var G = W.sub(w);
        if (G.cmpn(0) < 0) G.iadd(this.m);
        return G._forceRed(this);
      }, H.prototype.isub = function(W, w) {
        this._verify2(W, w);
        var G = W.isub(w);
        if (G.cmpn(0) < 0) G.iadd(this.m);
        return G;
      }, H.prototype.shl = function(W, w) {
        return this._verify1(W), this.imod(W.ushln(w));
      }, H.prototype.imul = function(W, w) {
        return this._verify2(W, w), this.imod(W.imul(w));
      }, H.prototype.mul = function(W, w) {
        return this._verify2(W, w), this.imod(W.mul(w));
      }, H.prototype.isqr = function(W) {
        return this.imul(W, W.clone());
      }, H.prototype.sqr = function(W) {
        return this.mul(W, W);
      }, H.prototype.sqrt = function(W) {
        if (W.isZero()) return W.clone();
        var w = this.m.andln(3);
        if (_(w % 2 === 1), w === 3) {
          var G = this.m.add(new O(1)).iushrn(2);
          return this.pow(W, G);
        }
        var S = this.m.subn(1), A = 0;
        while (!S.isZero() && S.andln(1) === 0) A++, S.iushrn(1);
        _(!S.isZero());
        var v = new O(1).toRed(this), k = v.redNeg(), R = this.m.subn(1).iushrn(1), C = this.m.bitLength();
        C = new O(2 * C * C).toRed(this);
        while (this.pow(C, R).cmp(k) !== 0) C.redIAdd(k);
        var L = this.pow(C, S), x = this.pow(W, S.addn(1).iushrn(1)), l = this.pow(W, S), a = A;
        while (l.cmp(v) !== 0) {
          var f$ = l;
          for (var $$ = 0; f$.cmp(v) !== 0; $$++) f$ = f$.redSqr();
          _($$ < a);
          var B = this.pow(L, new O(1).iushln(a - $$ - 1));
          x = x.redMul(B), L = B.redSqr(), l = l.redMul(L), a = $$;
        }
        return x;
      }, H.prototype.invm = function(W) {
        var w = W._invmp(this.m);
        if (w.negative !== 0) return w.negative = 0, this.imod(w).redNeg();
        else return this.imod(w);
      }, H.prototype.pow = function(W, w) {
        if (w.isZero()) return new O(1).toRed(this);
        if (w.cmpn(1) === 0) return W.clone();
        var G = 4, S = Array(1 << G);
        S[0] = new O(1).toRed(this), S[1] = W;
        for (var A = 2; A < S.length; A++) S[A] = this.mul(S[A - 1], W);
        var v = S[0], k = 0, R = 0, C = w.bitLength() % 26;
        if (C === 0) C = 26;
        for (A = w.length - 1; A >= 0; A--) {
          var L = w.words[A];
          for (var x = C - 1; x >= 0; x--) {
            var l = L >> x & 1;
            if (v !== S[0]) v = this.sqr(v);
            if (l === 0 && k === 0) {
              R = 0;
              continue;
            }
            if (k <<= 1, k |= l, R++, R !== G && (A !== 0 || x !== 0)) continue;
            v = this.mul(v, S[k]), R = 0, k = 0;
          }
          C = 26;
        }
        return v;
      }, H.prototype.convertTo = function(W) {
        var w = W.umod(this.m);
        return w === W ? w.clone() : w;
      }, H.prototype.convertFrom = function(W) {
        var w = W.clone();
        return w.red = null, w;
      }, O.mont = function(W) {
        return new Z(W);
      };
      function Z(W) {
        if (H.call(this, W), this.shift = this.m.bitLength(), this.shift % 26 !== 0) this.shift += 26 - this.shift % 26;
        this.r = new O(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      Y(Z, H), Z.prototype.convertTo = function(W) {
        return this.imod(W.ushln(this.shift));
      }, Z.prototype.convertFrom = function(W) {
        var w = this.imod(W.mul(this.rinv));
        return w.red = null, w;
      }, Z.prototype.imul = function(W, w) {
        if (W.isZero() || w.isZero()) return W.words[0] = 0, W.length = 1, W;
        var G = W.imul(w), S = G.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), A = G.isub(S).iushrn(this.shift), v = A;
        if (A.cmp(this.m) >= 0) v = A.isub(this.m);
        else if (A.cmpn(0) < 0) v = A.iadd(this.m);
        return v._forceRed(this);
      }, Z.prototype.mul = function(W, w) {
        if (W.isZero() || w.isZero()) return new O(0)._forceRed(this);
        var G = W.mul(w), S = G.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), A = G.isub(S).iushrn(this.shift), v = A;
        if (A.cmp(this.m) >= 0) v = A.isub(this.m);
        else if (A.cmpn(0) < 0) v = A.iadd(this.m);
        return v._forceRed(this);
      }, Z.prototype.invm = function(W) {
        var w = this.imod(W._invmp(this.m).mul(this.r2));
        return w._forceRed(this);
      };
    })(typeof q > "u" || q, $18);
  }), Z0 = r$(($18, q) => {
    var K = Co(), P = PO(), _ = $8().Buffer;
    function Y(J) {
      var T = J.modulus.byteLength(), X;
      do
        X = new K(P(T));
      while (X.cmp(J.modulus) >= 0 || !X.umod(J.prime1) || !X.umod(J.prime2));
      return X;
    }
    function O(J) {
      var T = Y(J), X = T.toRed(K.mont(J.modulus)).redPow(new K(J.publicExponent)).fromRed();
      return { blinder: X, unblinder: T.invm(J.modulus) };
    }
    function z(J, T) {
      var X = O(T), f = T.modulus.byteLength(), V = new K(J).mul(X.blinder).umod(T.modulus), M = V.toRed(K.mont(T.prime1)), N = V.toRed(K.mont(T.prime2)), h = T.coefficient, E = T.prime1, I = T.prime2, D = M.redPow(T.exponent1).fromRed(), g = N.redPow(T.exponent2).fromRed(), b = D.isub(g).imul(h).umod(E).imul(I);
      return g.iadd(b).imul(X.unblinder).umod(T.modulus).toArrayLike(_, "be", f);
    }
    z.getr = Y, q.exports = z;
  }), Eo = r$(($18, q) => {
    var K = J0(), P = PO(), _ = OO(), Y = T0(), O = w0(), z = iH(), J = f0(), T = Z0(), X = $8().Buffer;
    q.exports = function(N, h, E) {
      var I;
      if (N.padding) I = N.padding;
      else if (E) I = 1;
      else I = 4;
      var D = K(N), g;
      if (I === 4) g = f(D, h);
      else if (I === 1) g = V(D, h, E);
      else if (I === 3) {
        if (g = new z(h), g.cmp(D.modulus) >= 0) throw Error("data too long for modulus");
      } else throw Error("unknown padding");
      if (E) return T(g, D);
      else return J(g, D);
    };
    function f(N, h) {
      var E = N.modulus.byteLength(), I = h.length, D = _("sha1").update(X.alloc(0)).digest(), g = D.length, b = 2 * g;
      if (I > E - b - 2) throw Error("message too long");
      var y = X.alloc(E - I - b - 2), p = E - g - 1, n = P(g), s = O(X.concat([D, y, X.alloc(1, 1), h], p), Y(n, p)), q$ = O(n, Y(s, g));
      return new z(X.concat([X.alloc(1), q$, s], E));
    }
    function V(N, h, E) {
      var I = h.length, D = N.modulus.byteLength();
      if (I > D - 11) throw Error("message too long");
      var g;
      if (E) g = X.alloc(D - I - 3, 255);
      else g = M(D - I - 3);
      return new z(X.concat([X.from([0, E ? 1 : 2]), g, X.alloc(1), h], D));
    }
    function M(N) {
      var h = X.allocUnsafe(N), E = 0, I = P(N * 2), D = 0, g;
      while (E < N) {
        if (D === I.length) I = P(N * 2), D = 0;
        if (g = I[D++], g) h[E++] = g;
      }
      return h;
    }
  }), ho = r$(($18, q) => {
    var K = J0(), P = T0(), _ = w0(), Y = iH(), O = Z0(), z = OO(), J = f0(), T = $8().Buffer;
    q.exports = function(M, N, h) {
      var E;
      if (M.padding) E = M.padding;
      else if (h) E = 1;
      else E = 4;
      var I = K(M), D = I.modulus.byteLength();
      if (N.length > D || new Y(N).cmp(I.modulus) >= 0) throw Error("decryption error");
      var g;
      if (h) g = J(new Y(N), I);
      else g = O(N, I);
      var b = T.alloc(D - g.length);
      if (g = T.concat([b, g], D), E === 4) return X(I, g);
      else if (E === 1) return f(I, g, h);
      else if (E === 3) return g;
      else throw Error("unknown padding");
    };
    function X(M, N) {
      var h = M.modulus.byteLength(), E = z("sha1").update(T.alloc(0)).digest(), I = E.length;
      if (N[0] !== 0) throw Error("decryption error");
      var D = N.slice(1, I + 1), g = N.slice(I + 1), b = _(D, P(g, I)), y = _(g, P(b, h - I - 1));
      if (V(E, y.slice(0, I))) throw Error("decryption error");
      var p = I;
      while (y[p] === 0) p++;
      if (y[p++] !== 1) throw Error("decryption error");
      return y.slice(p);
    }
    function f(M, N, h) {
      var E = N.slice(0, 2), I = 2, D = 0;
      while (N[I++] !== 0) if (I >= N.length) {
        D++;
        break;
      }
      var g = N.slice(2, I - 1);
      if (E.toString("hex") !== "0002" && !h || E.toString("hex") !== "0001" && h) D++;
      if (g.length < 8) D++;
      if (D) throw Error("decryption error");
      return N.slice(I);
    }
    function V(M, N) {
      M = T.from(M), N = T.from(N);
      var h = 0, E = M.length;
      if (M.length !== N.length) h++, E = Math.min(M.length, N.length);
      var I = -1;
      while (++I < E) h += M[I] ^ N[I];
      return h;
    }
  }), mH = r$(($18) => {
    $18.publicEncrypt = Eo(), $18.privateDecrypt = ho(), $18.privateEncrypt = function(q, K) {
      return $18.publicEncrypt(q, K, true);
    }, $18.publicDecrypt = function(q, K) {
      return $18.privateDecrypt(q, K, true);
    };
  }), Ro = r$(($18) => {
    var q = (dq(), J6(mq));
    if (typeof q.publicEncrypt !== "function") q = mH();
    if ($18.publicEncrypt = q.publicEncrypt, $18.privateDecrypt = q.privateDecrypt, typeof q.privateEncrypt !== "function") $18.privateEncrypt = mH().privateEncrypt;
    else $18.privateEncrypt = q.privateEncrypt;
    if (typeof q.publicDecrypt !== "function") $18.publicDecrypt = mH().publicDecrypt;
    else $18.publicDecrypt = q.publicDecrypt;
  }), Io = r$(($18) => {
    var q = $8(), K = PO(), P = q.Buffer, _ = q.kMaxLength, Y = globalThis.crypto || globalThis.msCrypto, O = Math.pow(2, 32) - 1;
    function z(V, M) {
      if (typeof V !== "number" || V !== V) throw TypeError("offset must be a number");
      if (V > O || V < 0) throw TypeError("offset must be a uint32");
      if (V > _ || V > M) throw RangeError("offset out of range");
    }
    function J(V, M, N) {
      if (typeof V !== "number" || V !== V) throw TypeError("size must be a number");
      if (V > O || V < 0) throw TypeError("size must be a uint32");
      if (V + M > N || V > _) throw RangeError("buffer too small");
    }
    Y && Y.getRandomValues, $18.randomFill = T, $18.randomFillSync = f;
    function T(V, M, N, h) {
      if (!P.isBuffer(V) && !(V instanceof globalThis.Uint8Array)) throw TypeError('"buf" argument must be a Buffer or Uint8Array');
      if (typeof M === "function") h = M, M = 0, N = V.length;
      else if (typeof N === "function") h = N, N = V.length - M;
      else if (typeof h !== "function") throw TypeError('"cb" argument must be a function');
      return z(M, V.length), J(N, M, V.length), X(V, M, N, h);
    }
    function X(V, M, N, h) {
      if (false) var E, I;
      if (h) {
        K(N, function(g, b) {
          if (g) return h(g);
          b.copy(V, M), h(null, V);
        });
        return;
      }
      var D = K(N);
      return D.copy(V, M), V;
    }
    function f(V, M, N) {
      if (typeof M > "u") M = 0;
      if (!P.isBuffer(V) && !(V instanceof globalThis.Uint8Array)) throw TypeError('"buf" argument must be a Buffer or Uint8Array');
      if (z(M, V.length), N === void 0) N = V.length - M;
      return J(N, M, V.length), X(V, M, N);
    }
  }), Do = r$(($18, q) => {
    var K = (dq(), J6(mq));
    if (typeof K.randomFill === "function" && typeof K.randomFillSync === "function") $18.randomFill = K.randomFill, $18.randomFillSync = K.randomFillSync;
    else q.exports = Io();
  }), Lo = r$(($18) => {
    $18.randomBytes = $18.rng = $18.pseudoRandomBytes = $18.prng = PO(), $18.createHash = $18.Hash = OO(), $18.createHmac = $18.Hmac = sS();
    var q = ur(), K = Object.keys(q), P = ["sha1", "sha224", "sha256", "sha384", "sha512", "md5", "rmd160"].concat(K);
    $18.getHashes = function() {
      return P;
    };
    var _ = q0();
    $18.pbkdf2 = _.pbkdf2, $18.pbkdf2Sync = _.pbkdf2Sync;
    var Y = pr();
    $18.Cipher = Y.Cipher, $18.createCipher = Y.createCipher, $18.Cipheriv = Y.Cipheriv, $18.createCipheriv = Y.createCipheriv, $18.Decipher = Y.Decipher, $18.createDecipher = Y.createDecipher, $18.Decipheriv = Y.Decipheriv, $18.createDecipheriv = Y.createDecipheriv, $18.getCiphers = Y.getCiphers, $18.listCiphers = Y.listCiphers;
    var O = cr();
    $18.DiffieHellmanGroup = O.DiffieHellmanGroup, $18.createDiffieHellmanGroup = O.createDiffieHellmanGroup, $18.getDiffieHellman = O.getDiffieHellman, $18.createDiffieHellman = O.createDiffieHellman, $18.DiffieHellman = O.DiffieHellman;
    var z = mr();
    $18.createSign = z.createSign, $18.Sign = z.Sign, $18.createVerify = z.createVerify, $18.Verify = z.Verify, $18.createECDH = vo();
    var J = Ro();
    $18.publicEncrypt = J.publicEncrypt, $18.privateEncrypt = J.privateEncrypt, $18.publicDecrypt = J.publicDecrypt, $18.privateDecrypt = J.privateDecrypt;
    var T = Do();
    $18.randomFill = T.randomFill, $18.randomFillSync = T.randomFillSync, $18.createCredentials = function() {
      throw Error(`sorry, createCredentials is not implemented yet
we accept pull requests
https://github.com/browserify/crypto-browserify`);
    }, $18.constants = { DH_CHECK_P_NOT_SAFE_PRIME: 2, DH_CHECK_P_NOT_PRIME: 1, DH_UNABLE_TO_CHECK_GENERATOR: 4, DH_NOT_SUITABLE_GENERATOR: 8, NPN_ENABLED: 1, ALPN_ENABLED: 1, RSA_PKCS1_PADDING: 1, RSA_SSLV23_PADDING: 2, RSA_NO_PADDING: 3, RSA_PKCS1_OAEP_PADDING: 4, RSA_X931_PADDING: 5, RSA_PKCS1_PSS_PADDING: 6, POINT_CONVERSION_COMPRESSED: 2, POINT_CONVERSION_UNCOMPRESSED: 4, POINT_CONVERSION_HYBRID: 6 };
  }), f6 = yr(Lo(), 1), go = f6.prng, bo = f6.pseudoRandomBytes, yo = f6.rng, uo = f6.randomBytes, xo = f6.Hash, po = f6.createHash, co = f6.Hmac, mo = f6.createHmac, lo = f6.getHashes, ro = f6.pbkdf2, oo = f6.pbkdf2Sync, no = f6.Cipher, io = f6.createCipher, Bo = f6.Cipheriv, to = f6.createCipheriv, Uo = f6.Decipher, Fo = f6.createDecipher, ao = f6.Decipheriv, Qo = f6.createDecipheriv, eo = f6.getCiphers, so = f6.listCiphers, $n = f6.DiffieHellmanGroup, qn = f6.createDiffieHellmanGroup, Kn = f6.getDiffieHellman, _n = f6.createDiffieHellman, Pn = f6.DiffieHellman, On = f6.createSign, Yn = f6.Sign, jn = f6.createVerify, vn = f6.Verify, zn = f6.createECDH, Wn = f6.publicEncrypt, Hn = f6.privateEncrypt, Jn = f6.publicDecrypt, Tn = f6.privateDecrypt, wn = f6.randomFill, fn = f6.randomFillSync, Zn = f6.createCredentials, Xn = f6.constants, Vn = ["p192", "p224", "p256", "p384", "p521", "curve25519", "ed25519", "secp256k1", "secp224r1", "prime256v1", "prime192v1", "ed25519", "secp384r1", "secp521r1"];
  Mn = crypto, Nn = crypto;
});
var X0 = x$((TP$, Cn) => {
  Cn.exports = { name: "dotenv", version: "17.2.3", description: "Loads environment variables from .env file", main: "lib/main.js", types: "lib/main.d.ts", exports: { ".": { types: "./lib/main.d.ts", require: "./lib/main.js", default: "./lib/main.js" }, "./config": "./config.js", "./config.js": "./config.js", "./lib/env-options": "./lib/env-options.js", "./lib/env-options.js": "./lib/env-options.js", "./lib/cli-options": "./lib/cli-options.js", "./lib/cli-options.js": "./lib/cli-options.js", "./package.json": "./package.json" }, scripts: { "dts-check": "tsc --project tests/types/tsconfig.json", lint: "standard", pretest: "npm run lint && npm run dts-check", test: "tap run tests/**/*.js --allow-empty-coverage --disable-coverage --timeout=60000", "test:coverage": "tap run tests/**/*.js --show-full-coverage --timeout=60000 --coverage-report=text --coverage-report=lcov", prerelease: "npm test", release: "standard-version" }, repository: { type: "git", url: "git://github.com/motdotla/dotenv.git" }, homepage: "https://github.com/motdotla/dotenv#readme", funding: "https://dotenvx.com", keywords: ["dotenv", "env", ".env", "environment", "variables", "config", "settings"], readmeFilename: "README.md", license: "BSD-2-Clause", devDependencies: { "@types/node": "^18.11.3", decache: "^4.6.2", sinon: "^14.0.1", standard: "^17.0.0", "standard-version": "^9.5.0", tap: "^19.2.0", typescript: "^4.8.4" }, engines: { node: ">=12" }, browser: { fs: false } };
});
var M0 = x$((wP$, NK) => {
  var BH = () => ({}), jO = (HH(), J6(WH)), En = (TH(), J6(JH)), hn = (dq(), J6(mq)), Rn = X0(), tH = Rn.version, A0 = [" encrypt with Dotenvx: https://dotenvx.com", " prevent committing .env to code: https://dotenvx.com/precommit", " prevent building .env in docker: https://dotenvx.com/prebuild", " add observability to secrets: https://dotenvx.com/ops", " sync secrets across teammates & machines: https://dotenvx.com/ops", " backup and recover secrets: https://dotenvx.com/ops", " audit secrets and track compliance: https://dotenvx.com/ops", " add secrets lifecycle management: https://dotenvx.com/ops", " add access controls to secrets: https://dotenvx.com/ops", "  run anywhere with `dotenvx run -- yourcommand`", "  specify custom .env file path with { path: '/custom/path/.env' }", "  enable debug logging with { debug: true }", "  override existing env vars with { override: true }", "  suppress all logs with { quiet: true }", "  write to custom object with { processEnv: myObject }", "  load multiple .env files with { path: ['.env.local', '.env'] }"];
  function In() {
    return A0[Math.floor(Math.random() * A0.length)];
  }
  function m4($18) {
    if (typeof $18 === "string") return !["false", "0", "no", "off", ""].includes($18.toLowerCase());
    return Boolean($18);
  }
  function Dn() {
    return process.stdout.isTTY;
  }
  function Ln($18) {
    return Dn() ? `\x1B[2m${$18}\x1B[0m` : $18;
  }
  var gn = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg;
  function bn($18) {
    let q = {}, K = $18.toString();
    K = K.replace(/\r\n?/mg, `
`);
    let P;
    while ((P = gn.exec(K)) != null) {
      let _ = P[1], Y = P[2] || "";
      Y = Y.trim();
      let O = Y[0];
      if (Y = Y.replace(/^(['"`])([\s\S]*)\1$/mg, "$2"), O === '"') Y = Y.replace(/\\n/g, `
`), Y = Y.replace(/\\r/g, "\r");
      q[_] = Y;
    }
    return q;
  }
  function yn($18) {
    $18 = $18 || {};
    let q = S0($18);
    $18.path = q;
    let K = jq.configDotenv($18);
    if (!K.parsed) {
      let O = Error(`MISSING_DATA: Cannot parse ${q} for an unknown reason`);
      throw O.code = "MISSING_DATA", O;
    }
    let P = V0($18).split(","), _ = P.length, Y;
    for (let O = 0; O < _; O++) try {
      let z = P[O].trim(), J = xn(K, z);
      Y = jq.decrypt(J.ciphertext, J.key);
      break;
    } catch (z) {
      if (O + 1 >= _) throw z;
    }
    return jq.parse(Y);
  }
  function un($18) {
    console.error(`[dotenv@${tH}][WARN] ${$18}`);
  }
  function F7($18) {
    console.log(`[dotenv@${tH}][DEBUG] ${$18}`);
  }
  function G0($18) {
    console.log(`[dotenv@${tH}] ${$18}`);
  }
  function V0($18) {
    if ($18 && $18.DOTENV_KEY && $18.DOTENV_KEY.length > 0) return $18.DOTENV_KEY;
    if (process.env.DOTENV_KEY && process.env.DOTENV_KEY.length > 0) return process.env.DOTENV_KEY;
    return "";
  }
  function xn($18, q) {
    let K;
    try {
      K = new URL(q);
    } catch (z) {
      if (z.code === "ERR_INVALID_URL") {
        let J = Error("INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=development");
        throw J.code = "INVALID_DOTENV_KEY", J;
      }
      throw z;
    }
    let P = K.password;
    if (!P) {
      let z = Error("INVALID_DOTENV_KEY: Missing key part");
      throw z.code = "INVALID_DOTENV_KEY", z;
    }
    let _ = K.searchParams.get("environment");
    if (!_) {
      let z = Error("INVALID_DOTENV_KEY: Missing environment part");
      throw z.code = "INVALID_DOTENV_KEY", z;
    }
    let Y = `DOTENV_VAULT_${_.toUpperCase()}`, O = $18.parsed[Y];
    if (!O) {
      let z = Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${Y} in your .env.vault file.`);
      throw z.code = "NOT_FOUND_DOTENV_ENVIRONMENT", z;
    }
    return { ciphertext: O, key: P };
  }
  function S0($18) {
    let q = null;
    if ($18 && $18.path && $18.path.length > 0) if (Array.isArray($18.path)) {
      for (let K of $18.path) if (BH.existsSync(K)) q = K.endsWith(".vault") ? K : `${K}.vault`;
    } else q = $18.path.endsWith(".vault") ? $18.path : `${$18.path}.vault`;
    else q = jO.resolve(process.cwd(), ".env.vault");
    if (BH.existsSync(q)) return q;
    return null;
  }
  function k0($18) {
    return $18[0] === "~" ? jO.join(En.homedir(), $18.slice(1)) : $18;
  }
  function pn($18) {
    let q = m4(process.env.DOTENV_CONFIG_DEBUG || $18 && $18.debug), K = m4(process.env.DOTENV_CONFIG_QUIET || $18 && $18.quiet);
    if (q || !K) G0("Loading env from encrypted .env.vault");
    let P = jq._parseVault($18), _ = process.env;
    if ($18 && $18.processEnv != null) _ = $18.processEnv;
    return jq.populate(_, P, $18), { parsed: P };
  }
  function cn($18) {
    let q = jO.resolve(process.cwd(), ".env"), K = "utf8", P = process.env;
    if ($18 && $18.processEnv != null) P = $18.processEnv;
    let _ = m4(P.DOTENV_CONFIG_DEBUG || $18 && $18.debug), Y = m4(P.DOTENV_CONFIG_QUIET || $18 && $18.quiet);
    if ($18 && $18.encoding) K = $18.encoding;
    else if (_) F7("No encoding is specified. UTF-8 is used by default");
    let O = [q];
    if ($18 && $18.path) if (!Array.isArray($18.path)) O = [k0($18.path)];
    else {
      O = [];
      for (let X of $18.path) O.push(k0(X));
    }
    let z, J = {};
    for (let X of O) try {
      let f = jq.parse(BH.readFileSync(X, { encoding: K }));
      jq.populate(J, f, $18);
    } catch (f) {
      if (_) F7(`Failed to load ${X} ${f.message}`);
      z = f;
    }
    let T = jq.populate(P, J, $18);
    if (_ = m4(P.DOTENV_CONFIG_DEBUG || _), Y = m4(P.DOTENV_CONFIG_QUIET || Y), _ || !Y) {
      let X = Object.keys(T).length, f = [];
      for (let V of O) try {
        let M = jO.relative(process.cwd(), V);
        f.push(M);
      } catch (M) {
        if (_) F7(`Failed to load ${V} ${M.message}`);
        z = M;
      }
      G0(`injecting env (${X}) from ${f.join(",")} ${Ln(`-- tip: ${In()}`)}`);
    }
    if (z) return { parsed: J, error: z };
    else return { parsed: J };
  }
  function mn($18) {
    if (V0($18).length === 0) return jq.configDotenv($18);
    let q = S0($18);
    if (!q) return un(`You set DOTENV_KEY but you are missing a .env.vault file at ${q}. Did you forget to build it?`), jq.configDotenv($18);
    return jq._configVault($18);
  }
  function dn($18, q) {
    let K = Buffer.from(q.slice(-64), "hex"), P = Buffer.from($18, "base64"), _ = P.subarray(0, 12), Y = P.subarray(-16);
    P = P.subarray(12, -16);
    try {
      let O = hn.createDecipheriv("aes-256-gcm", K, _);
      return O.setAuthTag(Y), `${O.update(P)}${O.final()}`;
    } catch (O) {
      let z = O instanceof RangeError, J = O.message === "Invalid key length", T = O.message === "Unsupported state or unable to authenticate data";
      if (z || J) {
        let X = Error("INVALID_DOTENV_KEY: It must be 64 characters long (or more)");
        throw X.code = "INVALID_DOTENV_KEY", X;
      } else if (T) {
        let X = Error("DECRYPTION_FAILED: Please check your DOTENV_KEY");
        throw X.code = "DECRYPTION_FAILED", X;
      } else throw O;
    }
  }
  function ln($18, q, K = {}) {
    let P = Boolean(K && K.debug), _ = Boolean(K && K.override), Y = {};
    if (typeof q !== "object") {
      let O = Error("OBJECT_REQUIRED: Please check the processEnv argument being passed to populate");
      throw O.code = "OBJECT_REQUIRED", O;
    }
    for (let O of Object.keys(q)) if (Object.prototype.hasOwnProperty.call($18, O)) {
      if (_ === true) $18[O] = q[O], Y[O] = q[O];
      if (P) if (_ === true) F7(`"${O}" is already defined and WAS overwritten`);
      else F7(`"${O}" is already defined and was NOT overwritten`);
    } else $18[O] = q[O], Y[O] = q[O];
    return Y;
  }
  var jq = { configDotenv: cn, _configVault: pn, _parseVault: yn, config: mn, decrypt: dn, parse: bn, populate: ln };
  wP$.configDotenv = jq.configDotenv;
  wP$._configVault = jq._configVault;
  wP$._parseVault = jq._parseVault;
  wP$.config = jq.config;
  wP$.decrypt = jq.decrypt;
  wP$.parse = jq.parse;
  wP$.populate = jq.populate;
  NK.exports = jq;
});
var d0 = x$((xP$, $J) => {
  var W6 = String, m0 = function() {
    return { isColorSupported: false, reset: W6, bold: W6, dim: W6, italic: W6, underline: W6, inverse: W6, hidden: W6, strikethrough: W6, black: W6, red: W6, green: W6, yellow: W6, blue: W6, magenta: W6, cyan: W6, white: W6, gray: W6, bgBlack: W6, bgRed: W6, bgGreen: W6, bgYellow: W6, bgBlue: W6, bgMagenta: W6, bgCyan: W6, bgWhite: W6, blackBright: W6, redBright: W6, greenBright: W6, yellowBright: W6, blueBright: W6, magentaBright: W6, cyanBright: W6, whiteBright: W6, bgBlackBright: W6, bgRedBright: W6, bgGreenBright: W6, bgYellowBright: W6, bgBlueBright: W6, bgMagentaBright: W6, bgCyanBright: W6, bgWhiteBright: W6 };
  };
  $J.exports = m0();
  $J.exports.createColors = m0;
});
function z1($18) {
  if (!$18 || !/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test($18)) throw Error(`Invalid UUID format: ${$18}`);
  return $18;
}
var qP;
((Y) => {
  Y.IMAGE = "image";
  Y.VIDEO = "video";
  Y.AUDIO = "audio";
  Y.DOCUMENT = "document";
  Y.LINK = "link";
})(qP || (qP = {}));
var cM;
((Y) => {
  Y.DOCUMENT = "document";
  Y.FRAGMENT = "fragment";
  Y.MESSAGE = "message";
  Y.DESCRIPTION = "description";
  Y.CUSTOM = "custom";
})(cM || (cM = {}));
var mM;
((P) => {
  P.OWNER = "OWNER";
  P.ADMIN = "ADMIN";
  P.NONE = "NONE";
})(mM || (mM = {}));
var KP;
((X) => {
  X.SELF = "SELF";
  X.DM = "DM";
  X.GROUP = "GROUP";
  X.VOICE_DM = "VOICE_DM";
  X.VOICE_GROUP = "VOICE_GROUP";
  X.FEED = "FEED";
  X.THREAD = "THREAD";
  X.WORLD = "WORLD";
  X.FORUM = "FORUM";
  X.API = "API";
})(KP || (KP = {}));
var dM;
((K) => {
  K.ACTIVE = "active";
  K.INACTIVE = "inactive";
})(dM || (dM = {}));
var DB = { TRANSCRIPTION: "transcription", VIDEO: "video", BROWSER: "browser", PDF: "pdf", REMOTE_FILES: "aws_s3", WEB_SEARCH: "web_search", EMAIL: "email", TEE: "tee", TASK: "task", WALLET: "wallet", LP_POOL: "lp_pool", TOKEN_DATA: "token_data", MESSAGE_SERVICE: "message_service", MESSAGE: "message", POST: "post", UNKNOWN: "unknown" };
var RO = class {
  constructor($18) {
    __publicField(this, "runtime");
    __publicField(this, "config");
    if ($18) this.runtime = $18;
  }
  static async start($18) {
    throw Error("Not implemented");
  }
  static async stop($18) {
    throw Error("Not implemented");
  }
};
__publicField(RO, "serviceType");
function LB($18, q) {
  return $18.getService(q);
}
function gB($18, q = "UNKNOWN_ERROR") {
  if ($18 instanceof Error) return { code: q, message: $18.message, cause: $18 };
  return { code: q, message: String($18) };
}
var M6 = { SMALL: "TEXT_SMALL", MEDIUM: "TEXT_LARGE", LARGE: "TEXT_LARGE", TEXT_SMALL: "TEXT_SMALL", TEXT_LARGE: "TEXT_LARGE", TEXT_EMBEDDING: "TEXT_EMBEDDING", TEXT_TOKENIZER_ENCODE: "TEXT_TOKENIZER_ENCODE", TEXT_TOKENIZER_DECODE: "TEXT_TOKENIZER_DECODE", TEXT_REASONING_SMALL: "REASONING_SMALL", TEXT_REASONING_LARGE: "REASONING_LARGE", TEXT_COMPLETION: "TEXT_COMPLETION", IMAGE: "IMAGE", IMAGE_DESCRIPTION: "IMAGE_DESCRIPTION", TRANSCRIPTION: "TRANSCRIPTION", TEXT_TO_SPEECH: "TEXT_TO_SPEECH", AUDIO: "AUDIO", VIDEO: "VIDEO", OBJECT_SMALL: "OBJECT_SMALL", OBJECT_LARGE: "OBJECT_LARGE" };
var _P = { DEFAULT_MAX_TOKENS: "DEFAULT_MAX_TOKENS", DEFAULT_TEMPERATURE: "DEFAULT_TEMPERATURE", DEFAULT_FREQUENCY_PENALTY: "DEFAULT_FREQUENCY_PENALTY", DEFAULT_PRESENCE_PENALTY: "DEFAULT_PRESENCE_PENALTY", TEXT_SMALL_MAX_TOKENS: "TEXT_SMALL_MAX_TOKENS", TEXT_SMALL_TEMPERATURE: "TEXT_SMALL_TEMPERATURE", TEXT_SMALL_FREQUENCY_PENALTY: "TEXT_SMALL_FREQUENCY_PENALTY", TEXT_SMALL_PRESENCE_PENALTY: "TEXT_SMALL_PRESENCE_PENALTY", TEXT_LARGE_MAX_TOKENS: "TEXT_LARGE_MAX_TOKENS", TEXT_LARGE_TEMPERATURE: "TEXT_LARGE_TEMPERATURE", TEXT_LARGE_FREQUENCY_PENALTY: "TEXT_LARGE_FREQUENCY_PENALTY", TEXT_LARGE_PRESENCE_PENALTY: "TEXT_LARGE_PRESENCE_PENALTY", OBJECT_SMALL_MAX_TOKENS: "OBJECT_SMALL_MAX_TOKENS", OBJECT_SMALL_TEMPERATURE: "OBJECT_SMALL_TEMPERATURE", OBJECT_SMALL_FREQUENCY_PENALTY: "OBJECT_SMALL_FREQUENCY_PENALTY", OBJECT_SMALL_PRESENCE_PENALTY: "OBJECT_SMALL_PRESENCE_PENALTY", OBJECT_LARGE_MAX_TOKENS: "OBJECT_LARGE_MAX_TOKENS", OBJECT_LARGE_TEMPERATURE: "OBJECT_LARGE_TEMPERATURE", OBJECT_LARGE_FREQUENCY_PENALTY: "OBJECT_LARGE_FREQUENCY_PENALTY", OBJECT_LARGE_PRESENCE_PENALTY: "OBJECT_LARGE_PRESENCE_PENALTY", MODEL_MAX_TOKEN: "MODEL_MAX_TOKEN", MODEL_TEMPERATURE: "MODEL_TEMPERATURE", MODEL_FREQ_PENALTY: "MODEL_FREQ_PENALTY", MODEL_PRESENCE_PENALTY: "MODEL_PRESENCE_PENALTY" };
var uB = { SMALL: 384, MEDIUM: 512, LARGE: 768, XL: 1024, XXL: 1536, XXXL: 3072 };
var IO;
((j) => {
  j.WORLD_JOINED = "WORLD_JOINED";
  j.WORLD_CONNECTED = "WORLD_CONNECTED";
  j.WORLD_LEFT = "WORLD_LEFT";
  j.ENTITY_JOINED = "ENTITY_JOINED";
  j.ENTITY_LEFT = "ENTITY_LEFT";
  j.ENTITY_UPDATED = "ENTITY_UPDATED";
  j.ROOM_JOINED = "ROOM_JOINED";
  j.ROOM_LEFT = "ROOM_LEFT";
  j.MESSAGE_RECEIVED = "MESSAGE_RECEIVED";
  j.MESSAGE_SENT = "MESSAGE_SENT";
  j.MESSAGE_DELETED = "MESSAGE_DELETED";
  j.CHANNEL_CLEARED = "CHANNEL_CLEARED";
  j.VOICE_MESSAGE_RECEIVED = "VOICE_MESSAGE_RECEIVED";
  j.VOICE_MESSAGE_SENT = "VOICE_MESSAGE_SENT";
  j.REACTION_RECEIVED = "REACTION_RECEIVED";
  j.POST_GENERATED = "POST_GENERATED";
  j.INTERACTION_RECEIVED = "INTERACTION_RECEIVED";
  j.RUN_STARTED = "RUN_STARTED";
  j.RUN_ENDED = "RUN_ENDED";
  j.RUN_TIMEOUT = "RUN_TIMEOUT";
  j.ACTION_STARTED = "ACTION_STARTED";
  j.ACTION_COMPLETED = "ACTION_COMPLETED";
  j.EVALUATOR_STARTED = "EVALUATOR_STARTED";
  j.EVALUATOR_COMPLETED = "EVALUATOR_COMPLETED";
  j.MODEL_USED = "MODEL_USED";
  j.EMBEDDING_GENERATION_REQUESTED = "EMBEDDING_GENERATION_REQUESTED";
  j.EMBEDDING_GENERATION_COMPLETED = "EMBEDDING_GENERATION_COMPLETED";
  j.EMBEDDING_GENERATION_FAILED = "EMBEDDING_GENERATION_FAILED";
})(IO || (IO = {}));
var lM;
((P) => {
  P.DISCORD = "DISCORD";
  P.TELEGRAM = "TELEGRAM";
  P.TWITTER = "TWITTER";
})(lM || (lM = {}));
var rM;
((_) => {
  _.OFF = "OFF";
  _.LOCAL = "LOCAL";
  _.DOCKER = "DOCKER";
  _.PRODUCTION = "PRODUCTION";
})(rM || (rM = {}));
var oM;
((q) => q.TDX_DSTACK = "tdx_dstack")(oM || (oM = {}));
var nM;
((O) => {
  O[O.ROOM_JOINING = 1] = "ROOM_JOINING";
  O[O.SEND_MESSAGE = 2] = "SEND_MESSAGE";
  O[O.MESSAGE = 3] = "MESSAGE";
  O[O.ACK = 4] = "ACK";
  O[O.THINKING = 5] = "THINKING";
  O[O.CONTROL = 6] = "CONTROL";
})(nM || (nM = {}));
var iM = Object.defineProperty;
var Z6 = ($18, q) => {
  for (var K in q) iM($18, K, { get: q[K], enumerable: true });
};
var W1 = class {
  constructor($18) {
    __publicField(this, "pageContent");
    __publicField(this, "metadata");
    __publicField(this, "id");
    this.pageContent = $18.pageContent !== void 0 ? $18.pageContent.toString() : "", this.metadata = $18.metadata ?? {}, this.id = $18.id;
  }
};
var FJ = q8(lJ(), 1);
var eM = q8(UJ(), 1);
function aJ($18, q) {
  return (q == null ? void 0 : q[$18]) || FJ.default($18);
}
function QJ($18, q, K) {
  let P = {};
  for (let _ in $18) if (Object.hasOwn($18, _)) P[q(_, K)] = $18[_];
  return P;
}
var sM = {};
Z6(sM, { Serializable: () => RK, get_lc_unique_name: () => H1 });
function eJ($18) {
  return Array.isArray($18) ? [...$18] : { ...$18 };
}
function $N($18, q) {
  let K = eJ($18);
  for (let [P, _] of Object.entries(q)) {
    let [Y, ...O] = P.split(".").reverse(), z = K;
    for (let J of O.reverse()) {
      if (z[J] === void 0) break;
      z[J] = eJ(z[J]), z = z[J];
    }
    if (z[Y] !== void 0) z[Y] = { lc: 1, type: "secret", id: [_] };
  }
  return K;
}
function H1($18) {
  let q = Object.getPrototypeOf($18);
  if (typeof $18.lc_name === "function" && (typeof q.lc_name !== "function" || $18.lc_name() !== q.lc_name())) return $18.lc_name();
  else return $18.name;
}
var RK = class $ {
  constructor(q, ...K) {
    __publicField(this, "lc_serializable", false);
    __publicField(this, "lc_kwargs");
    if (this.lc_serializable_keys !== void 0) this.lc_kwargs = Object.fromEntries(Object.entries(q || {}).filter(([P]) => {
      var _a2;
      return (_a2 = this.lc_serializable_keys) == null ? void 0 : _a2.includes(P);
    }));
    else this.lc_kwargs = q ?? {};
  }
  static lc_name() {
    return this.name;
  }
  get lc_id() {
    return [...this.lc_namespace, H1(this.constructor)];
  }
  get lc_secrets() {
    return;
  }
  get lc_attributes() {
    return;
  }
  get lc_aliases() {
    return;
  }
  get lc_serializable_keys() {
    return;
  }
  toJSON() {
    if (!this.lc_serializable) return this.toJSONNotImplemented();
    if (this.lc_kwargs instanceof $ || typeof this.lc_kwargs !== "object" || Array.isArray(this.lc_kwargs)) return this.toJSONNotImplemented();
    let q = {}, K = {}, P = Object.keys(this.lc_kwargs).reduce((_, Y) => {
      return _[Y] = Y in this ? this[Y] : this.lc_kwargs[Y], _;
    }, {});
    for (let _ = Object.getPrototypeOf(this); _; _ = Object.getPrototypeOf(_)) Object.assign(q, Reflect.get(_, "lc_aliases", this)), Object.assign(K, Reflect.get(_, "lc_secrets", this)), Object.assign(P, Reflect.get(_, "lc_attributes", this));
    return Object.keys(K).forEach((_) => {
      let Y = this, O = P, [z, ...J] = _.split(".").reverse();
      for (let T of J.reverse()) {
        if (!(T in Y) || Y[T] === void 0) return;
        if (!(T in O) || O[T] === void 0) {
          if (typeof Y[T] === "object" && Y[T] != null) O[T] = {};
          else if (Array.isArray(Y[T])) O[T] = [];
        }
        Y = Y[T], O = O[T];
      }
      if (z in Y && Y[z] !== void 0) O[z] = O[z] || Y[z];
    }), { lc: 1, type: "constructor", id: this.lc_id, kwargs: QJ(Object.keys(K).length ? $N(P, K) : P, aJ, q) };
  }
  toJSONNotImplemented() {
    return { lc: 1, type: "not_implemented", id: this.lc_id };
  }
};
function LO($18) {
  return !!($18 && typeof $18 === "object" && "type" in $18 && $18.type === "tool_call");
}
var sJ = class extends Error {
  constructor($18, q) {
    super($18);
    __publicField(this, "output");
    this.output = q;
  }
};
var $T = Symbol.for("ls:tracing_async_local_storage");
var IK = Symbol.for("lc:context_variables");
var qT = ($18) => {
  globalThis[$T] = $18;
};
var DK = () => {
  return globalThis[$T];
};
function c_($18) {
  return typeof $18 === "object" && $18 !== null && "type" in $18 && typeof $18.type === "string" && "source_type" in $18 && ($18.source_type === "url" || $18.source_type === "base64" || $18.source_type === "text" || $18.source_type === "id");
}
function KT($18) {
  return c_($18) && $18.source_type === "url" && "url" in $18 && typeof $18.url === "string";
}
function _T($18) {
  return c_($18) && $18.source_type === "base64" && "data" in $18 && typeof $18.data === "string";
}
function PT($18) {
  return c_($18) && $18.source_type === "id" && "id" in $18 && typeof $18.id === "string";
}
function gO({ dataUrl: $18, asTypedArray: q = false }) {
  let K = $18.match(/^data:(\w+\/\w+);base64,([A-Za-z0-9+/]+=*)$/), P;
  if (K) {
    P = K[1].toLowerCase();
    let _ = q ? Uint8Array.from(atob(K[2]), (Y) => Y.charCodeAt(0)) : K[2];
    return { mime_type: P, data: _ };
  }
  return;
}
function e$($18, q) {
  return _6($18) && $18.type === q;
}
function _6($18) {
  return typeof $18 === "object" && $18 !== null;
}
function rq($18) {
  return Array.isArray($18);
}
function U$($18) {
  return typeof $18 === "string";
}
function K8($18) {
  return typeof $18 === "number";
}
function J1($18) {
  return $18 instanceof Uint8Array;
}
function bO($18) {
  try {
    return JSON.parse($18);
  } catch {
    return;
  }
}
var KK = ($18) => $18();
function qN($18) {
  if ($18.type === "char_location" && U$($18.document_title) && K8($18.start_char_index) && K8($18.end_char_index) && U$($18.cited_text)) {
    let { document_title: q, start_char_index: K, end_char_index: P, cited_text: _, ...Y } = $18;
    return { ...Y, type: "citation", source: "char", title: q ?? void 0, startIndex: K, endIndex: P, citedText: _ };
  }
  if ($18.type === "page_location" && U$($18.document_title) && K8($18.start_page_number) && K8($18.end_page_number) && U$($18.cited_text)) {
    let { document_title: q, start_page_number: K, end_page_number: P, cited_text: _, ...Y } = $18;
    return { ...Y, type: "citation", source: "page", title: q ?? void 0, startIndex: K, endIndex: P, citedText: _ };
  }
  if ($18.type === "content_block_location" && U$($18.document_title) && K8($18.start_block_index) && K8($18.end_block_index) && U$($18.cited_text)) {
    let { document_title: q, start_block_index: K, end_block_index: P, cited_text: _, ...Y } = $18;
    return { ...Y, type: "citation", source: "block", title: q ?? void 0, startIndex: K, endIndex: P, citedText: _ };
  }
  if ($18.type === "web_search_result_location" && U$($18.url) && U$($18.title) && U$($18.encrypted_index) && U$($18.cited_text)) {
    let { url: q, title: K, encrypted_index: P, cited_text: _, ...Y } = $18;
    return { ...Y, type: "citation", source: "url", url: q, title: K, startIndex: Number(P), endIndex: Number(P), citedText: _ };
  }
  if ($18.type === "search_result_location" && U$($18.source) && U$($18.title) && K8($18.start_block_index) && K8($18.end_block_index) && U$($18.cited_text)) {
    let { source: q, title: K, start_block_index: P, end_block_index: _, cited_text: Y, ...O } = $18;
    return { ...O, type: "citation", source: "search", url: q, title: K ?? void 0, startIndex: P, endIndex: _, citedText: Y };
  }
  return;
}
function YT($18) {
  if (e$($18, "document") && _6($18.source) && "type" in $18.source) {
    if ($18.source.type === "base64" && U$($18.source.media_type) && U$($18.source.data)) return { type: "file", mimeType: $18.source.media_type, data: $18.source.data };
    else if ($18.source.type === "url" && U$($18.source.url)) return { type: "file", url: $18.source.url };
    else if ($18.source.type === "file" && U$($18.source.file_id)) return { type: "file", fileId: $18.source.file_id };
    else if ($18.source.type === "text" && U$($18.source.data)) return { type: "file", mimeType: String($18.source.media_type ?? "text/plain"), data: $18.source.data };
  } else if (e$($18, "image") && _6($18.source) && "type" in $18.source) {
    if ($18.source.type === "base64" && U$($18.source.media_type) && U$($18.source.data)) return { type: "image", mimeType: $18.source.media_type, data: $18.source.data };
    else if ($18.source.type === "url" && U$($18.source.url)) return { type: "image", url: $18.source.url };
    else if ($18.source.type === "file" && U$($18.source.file_id)) return { type: "image", fileId: $18.source.file_id };
  }
  return;
}
function jT($18) {
  function* q() {
    for (let K of $18) {
      let P = YT(K);
      if (P) yield P;
      else yield K;
    }
  }
  return Array.from(q());
}
function OT($18) {
  function* q() {
    var _a2;
    let K = typeof $18.content === "string" ? [{ type: "text", text: $18.content }] : $18.content;
    for (let P of K) {
      if (e$(P, "text") && U$(P.text)) {
        let { text: _, citations: Y, ...O } = P;
        if (rq(Y) && Y.length) {
          let z = Y.reduce((J, T) => {
            let X = qN(T);
            if (X) return [...J, X];
            return J;
          }, []);
          yield { ...O, type: "text", text: _, annotations: z };
          continue;
        } else {
          yield { ...O, type: "text", text: _ };
          continue;
        }
      } else if (e$(P, "thinking") && U$(P.thinking)) {
        let { thinking: _, signature: Y, ...O } = P;
        yield { ...O, type: "reasoning", reasoning: _, signature: Y };
        continue;
      } else if (e$(P, "redacted_thinking")) {
        yield { type: "non_standard", value: P };
        continue;
      } else if (e$(P, "tool_use") && U$(P.name) && U$(P.id)) {
        yield { type: "tool_call", id: P.id, name: P.name, args: P.input };
        continue;
      } else if (e$(P, "input_json_delta")) {
        if (KN($18) && ((_a2 = $18.tool_call_chunks) == null ? void 0 : _a2.length)) {
          let _ = $18.tool_call_chunks[0];
          yield { type: "tool_call_chunk", id: _.id, name: _.name, args: _.args, index: _.index };
          continue;
        }
      } else if (e$(P, "server_tool_use") && U$(P.name) && U$(P.id)) {
        let { name: _, id: Y } = P;
        if (_ === "web_search") {
          let O = KK(() => {
            if (typeof P.input === "string") return P.input;
            else if (_6(P.input) && U$(P.input.query)) return P.input.query;
            else if (U$(P.partial_json)) {
              let z = bO(P.partial_json);
              if (z == null ? void 0 : z.query) return z.query;
            }
            return "";
          });
          yield { id: Y, type: "server_tool_call", name: "web_search", args: { query: O } };
          continue;
        } else if (P.name === "code_execution") {
          let O = KK(() => {
            if (typeof P.input === "string") return P.input;
            else if (_6(P.input) && U$(P.input.code)) return P.input.code;
            else if (U$(P.partial_json)) {
              let z = bO(P.partial_json);
              if (z == null ? void 0 : z.code) return z.code;
            }
            return "";
          });
          yield { id: Y, type: "server_tool_call", name: "code_execution", args: { code: O } };
          continue;
        }
      } else if (e$(P, "web_search_tool_result") && U$(P.tool_use_id) && rq(P.content)) {
        let { content: _, tool_use_id: Y } = P, O = _.reduce((z, J) => {
          if (e$(J, "web_search_result")) return [...z, J.url];
          return z;
        }, []);
        yield { type: "server_tool_call_result", name: "web_search", toolCallId: Y, status: "success", output: { urls: O } };
        continue;
      } else if (e$(P, "code_execution_tool_result") && U$(P.tool_use_id) && _6(P.content)) {
        yield { type: "server_tool_call_result", name: "code_execution", toolCallId: P.tool_use_id, status: "success", output: P.content };
        continue;
      } else if (e$(P, "mcp_tool_use")) {
        yield { id: P.id, type: "server_tool_call", name: "mcp_tool_use", args: P.input };
        continue;
      } else if (e$(P, "mcp_tool_result") && U$(P.tool_use_id) && _6(P.content)) {
        yield { type: "server_tool_call_result", name: "mcp_tool_use", toolCallId: P.tool_use_id, status: "success", output: P.content };
        continue;
      } else if (e$(P, "container_upload")) {
        yield { type: "server_tool_call", name: "container_upload", args: P.input };
        continue;
      } else if (e$(P, "search_result")) {
        yield { id: P.id, type: "non_standard", value: P };
        continue;
      } else if (e$(P, "tool_result")) {
        yield { id: P.id, type: "non_standard", value: P };
        continue;
      } else {
        let _ = YT(P);
        if (_) {
          yield _;
          continue;
        }
      }
      yield { type: "non_standard", value: P };
    }
  }
  return Array.from(q());
}
var vT = { translateContent: OT, translateContentChunk: OT };
function KN($18) {
  return typeof ($18 == null ? void 0 : $18._getType) === "function" && typeof $18.concat === "function" && $18._getType() === "ai";
}
function _N($18) {
  if (KT($18)) return { type: $18.type, mimeType: $18.mime_type, url: $18.url, metadata: $18.metadata };
  if (_T($18)) return { type: $18.type, mimeType: $18.mime_type ?? "application/octet-stream", data: $18.data, metadata: $18.metadata };
  if (PT($18)) return { type: $18.type, mimeType: $18.mime_type, fileId: $18.id, metadata: $18.metadata };
  return $18;
}
function zT($18) {
  return $18.map(_N);
}
function WT($18) {
  if (e$($18, "image_url") && _6($18.image_url)) return true;
  if (e$($18, "input_audio") && _6($18.input_audio)) return true;
  if (e$($18, "file") && _6($18.file)) return true;
  return false;
}
function HT($18) {
  if (e$($18, "image_url") && _6($18.image_url) && U$($18.image_url.url)) {
    let q = gO({ dataUrl: $18.image_url.url });
    if (q) return { type: "image", mimeType: q.mime_type, data: q.data };
    else return { type: "image", url: $18.image_url.url };
  } else if (e$($18, "input_audio") && _6($18.input_audio) && U$($18.input_audio.data) && U$($18.input_audio.format)) return { type: "audio", data: $18.input_audio.data, mimeType: `audio/${$18.input_audio.format}` };
  else if (e$($18, "file") && _6($18.file) && U$($18.file.data)) {
    let q = gO({ dataUrl: $18.file.data });
    if (q) return { type: "file", data: q.data, mimeType: q.mime_type };
    else if (U$($18.file.file_id)) return { type: "file", fileId: $18.file.file_id };
  }
  return $18;
}
function PN($18) {
  let q = [];
  if (typeof $18.content === "string") q.push({ type: "text", text: $18.content });
  else q.push(...T1($18.content));
  for (let K of $18.tool_calls ?? []) q.push({ type: "tool_call", id: K.id, name: K.name, args: K.args });
  return q;
}
function ON($18) {
  let q = [];
  if (typeof $18.content === "string") q.push({ type: "text", text: $18.content });
  else q.push(...T1($18.content));
  for (let K of $18.tool_calls ?? []) q.push({ type: "tool_call", id: K.id, name: K.name, args: K.args });
  return q;
}
function T1($18) {
  let q = [];
  for (let K of $18) if (WT(K)) q.push(HT(K));
  else q.push(K);
  return q;
}
function YN($18) {
  if ($18.type === "url_citation") {
    let { url: q, title: K, start_index: P, end_index: _ } = $18;
    return { type: "citation", url: q, title: K, startIndex: P, endIndex: _ };
  }
  if ($18.type === "file_citation") {
    let { file_id: q, filename: K, index: P } = $18;
    return { type: "citation", title: K, startIndex: P, endIndex: P, fileId: q };
  }
  return $18;
}
function JT($18) {
  function* q() {
    var _a2;
    if (_6((_a2 = $18.additional_kwargs) == null ? void 0 : _a2.reasoning) && rq($18.additional_kwargs.reasoning.summary)) yield { type: "reasoning", reasoning: $18.additional_kwargs.reasoning.summary.reduce((_, Y) => {
      if (_6(Y) && U$(Y.text)) return `${_}${Y.text}`;
      return _;
    }, "") };
    let K = typeof $18.content === "string" ? [{ type: "text", text: $18.content }] : $18.content;
    for (let P of K) if (e$(P, "text")) {
      let { text: _, annotations: Y, ...O } = P;
      if (Array.isArray(Y)) yield { ...O, type: "text", text: String(_), annotations: Y.map(YN) };
      else yield { ...O, type: "text", text: String(_) };
    }
    for (let P of $18.tool_calls ?? []) yield { type: "tool_call", id: P.id, name: P.name, args: P.args };
    if (_6($18.additional_kwargs) && rq($18.additional_kwargs.tool_outputs)) for (let P of $18.additional_kwargs.tool_outputs) {
      if (e$(P, "web_search_call")) {
        yield { id: P.id, type: "server_tool_call", name: "web_search", args: { query: P.query } };
        continue;
      } else if (e$(P, "file_search_call")) {
        yield { id: P.id, type: "server_tool_call", name: "file_search", args: { query: P.query } };
        continue;
      } else if (e$(P, "computer_call")) {
        yield { type: "non_standard", value: P };
        continue;
      } else if (e$(P, "code_interpreter_call")) {
        if (U$(P.code)) yield { id: P.id, type: "server_tool_call", name: "code_interpreter", args: { code: P.code } };
        if (rq(P.outputs)) {
          let _ = KK(() => {
            if (P.status === "in_progress") return;
            if (P.status === "completed") return 0;
            if (P.status === "incomplete") return 127;
            if (P.status === "interpreting") return;
            if (P.status === "failed") return 1;
            return;
          });
          for (let Y of P.outputs) if (e$(Y, "logs")) {
            yield { type: "server_tool_call_result", toolCallId: P.id ?? "", status: "success", output: { type: "code_interpreter_output", returnCode: _ ?? 0, stderr: [0, void 0].includes(_) ? void 0 : String(Y.logs), stdout: [0, void 0].includes(_) ? String(Y.logs) : void 0 } };
            continue;
          }
        }
        continue;
      } else if (e$(P, "mcp_call")) {
        yield { id: P.id, type: "server_tool_call", name: "mcp_call", args: P.input };
        continue;
      } else if (e$(P, "mcp_list_tools")) {
        yield { id: P.id, type: "server_tool_call", name: "mcp_list_tools", args: P.input };
        continue;
      } else if (e$(P, "mcp_approval_request")) {
        yield { type: "non_standard", value: P };
        continue;
      } else if (e$(P, "image_generation_call")) {
        yield { type: "non_standard", value: P };
        continue;
      }
      if (_6(P)) yield { type: "non_standard", value: P };
    }
  }
  return Array.from(q());
}
function jN($18) {
  function* q() {
    yield* JT($18);
    for (let K of $18.tool_call_chunks ?? []) yield { type: "tool_call_chunk", id: K.id, name: K.name, args: K.args };
  }
  return Array.from(q());
}
var TT = { translateContent: ($18) => {
  if (typeof $18.content === "string") return PN($18);
  return JT($18);
}, translateContentChunk: ($18) => {
  if (typeof $18.content === "string") return ON($18);
  return jN($18);
} };
function wT($18) {
  return typeof $18 === "object" && $18 !== null && "type" in $18 && "content" in $18 && (typeof $18.content === "string" || Array.isArray($18.content));
}
function fT($18, q = "pretty") {
  if (q === "pretty") return vN($18);
  return JSON.stringify($18);
}
function vN($18) {
  let q = [], K = ` ${$18.type.charAt(0).toUpperCase() + $18.type.slice(1)} Message `, P = Math.floor((80 - K.length) / 2), _ = "=".repeat(P), Y = K.length % 2 === 0 ? _ : `${_}=`;
  if (q.push(`${_}${K}${Y}`), $18.type === "ai") {
    let O = $18;
    if (O.tool_calls && O.tool_calls.length > 0) {
      q.push("Tool Calls:");
      for (let z of O.tool_calls) {
        q.push(`  ${z.name} (${z.id})`), q.push(` Call ID: ${z.id}`), q.push("  Args:");
        for (let [J, T] of Object.entries(z.args)) q.push(`    ${J}: ${T}`);
      }
    }
  }
  if ($18.type === "tool") {
    let O = $18;
    if (O.name) q.push(`Name: ${O.name}`);
  }
  if (typeof $18.content === "string" && $18.content.trim()) {
    if (q.length > 1) q.push("");
    q.push($18.content);
  }
  return q.join(`
`);
}
var yO = Symbol.for("langchain.message");
function LK($18, q) {
  if (typeof $18 === "string") {
    if ($18 === "") return q;
    if (typeof q === "string") return $18 + q;
    else if (Array.isArray(q) && q.some((K) => c_(K))) return [{ type: "text", source_type: "text", text: $18 }, ...q];
    else return [{ type: "text", text: $18 }, ...q];
  } else if (Array.isArray(q)) return PP($18, q) ?? [...$18, ...q];
  else if (q === "") return $18;
  else if (Array.isArray($18) && $18.some((K) => c_(K))) return [...$18, { type: "file", source_type: "text", text: q }];
  else return [...$18, { type: "text", text: q }];
}
function ZT($18, q) {
  if ($18 === "error" || q === "error") return "error";
  return "success";
}
function zN($18, q) {
  function K(P, _) {
    if (typeof P !== "object" || P === null || P === void 0) return P;
    if (_ >= q) {
      if (Array.isArray(P)) return "[Array]";
      return "[Object]";
    }
    if (Array.isArray(P)) return P.map((O) => K(O, _ + 1));
    let Y = {};
    for (let O of Object.keys(P)) Y[O] = K(P[O], _ + 1);
    return Y;
  }
  return JSON.stringify(K($18, 0), null, 2);
}
var _a;
var _K = class extends RK {
  constructor($18) {
    let q = typeof $18 === "string" || Array.isArray($18) ? { content: $18 } : $18;
    if (!q.additional_kwargs) q.additional_kwargs = {};
    if (!q.response_metadata) q.response_metadata = {};
    super(q);
    __publicField(this, "lc_namespace", ["langchain_core", "messages"]);
    __publicField(this, "lc_serializable", true);
    __publicField(this, _a, true);
    __publicField(this, "id");
    __publicField(this, "name");
    __publicField(this, "content");
    __publicField(this, "additional_kwargs");
    __publicField(this, "response_metadata");
    if (this.name = q.name, q.content === void 0 && q.contentBlocks !== void 0) this.content = q.contentBlocks, this.response_metadata = { output_version: "v1", ...q.response_metadata };
    else if (q.content !== void 0) this.content = q.content ?? [], this.response_metadata = q.response_metadata;
    else this.content = [], this.response_metadata = q.response_metadata;
    this.additional_kwargs = q.additional_kwargs, this.id = q.id;
  }
  get lc_aliases() {
    return { additional_kwargs: "additional_kwargs", response_metadata: "response_metadata" };
  }
  _getType() {
    return this.type;
  }
  getType() {
    return this._getType();
  }
  get text() {
    if (typeof this.content === "string") return this.content;
    if (!Array.isArray(this.content)) return "";
    return this.content.map(($18) => {
      if (typeof $18 === "string") return $18;
      if ($18.type === "text") return $18.text;
      return "";
    }).join("");
  }
  get contentBlocks() {
    let $18 = typeof this.content === "string" ? [{ type: "text", text: this.content }] : this.content;
    return [zT, T1, jT].reduce((P, _) => _(P), $18);
  }
  toDict() {
    return { type: this.getType(), data: this.toJSON().kwargs };
  }
  static lc_name() {
    return "BaseMessage";
  }
  get _printableFields() {
    return { id: this.id, content: this.content, name: this.name, additional_kwargs: this.additional_kwargs, response_metadata: this.response_metadata };
  }
  static isInstance($18) {
    return typeof $18 === "object" && $18 !== null && yO in $18 && $18[yO] === true && wT($18);
  }
  _updateId($18) {
    this.id = $18, this.lc_kwargs.id = $18;
  }
  get [(_a = yO, Symbol.toStringTag)]() {
    return this.constructor.lc_name();
  }
  [Symbol.for("nodejs.util.inspect.custom")]($18) {
    if ($18 === null) return this;
    let q = zN(this._printableFields, Math.max(4, $18));
    return `${this.constructor.lc_name()} ${q}`;
  }
  toFormattedString($18 = "pretty") {
    return fT(this, $18);
  }
};
function oq($18 = {}, q = {}) {
  let K = { ...$18 };
  for (let [P, _] of Object.entries(q)) if (K[P] == null) K[P] = _;
  else if (_ == null) continue;
  else if (typeof K[P] !== typeof _ || Array.isArray(K[P]) !== Array.isArray(_)) throw Error(`field[${P}] already exists in the message chunk, but with a different type.`);
  else if (typeof K[P] === "string") if (P === "type") continue;
  else if (["id", "name", "output_version", "model_provider"].includes(P)) K[P] = _;
  else K[P] += _;
  else if (typeof K[P] === "object" && !Array.isArray(K[P])) K[P] = oq(K[P], _);
  else if (Array.isArray(K[P])) K[P] = PP(K[P], _);
  else if (K[P] === _) continue;
  else console.warn(`field[${P}] already exists in this message chunk and value has unsupported type.`);
  return K;
}
function PP($18, q) {
  if ($18 === void 0 && q === void 0) return;
  else if ($18 === void 0 || q === void 0) return $18 || q;
  else {
    let K = [...$18];
    for (let P of q) if (typeof P === "object" && P !== null && "index" in P && typeof P.index === "number") {
      let _ = K.findIndex((Y) => {
        let O = typeof Y === "object", z = "index" in Y && Y.index === P.index, J = "id" in Y && "id" in P && (Y == null ? void 0 : Y.id) === (P == null ? void 0 : P.id), T = !("id" in Y) || !(Y == null ? void 0 : Y.id) || !("id" in P) || !(P == null ? void 0 : P.id);
        return O && z && (J || T);
      });
      if (_ !== -1 && typeof K[_] === "object" && K[_] !== null) K[_] = oq(K[_], P);
      else K.push(P);
    } else if (typeof P === "object" && P !== null && "text" in P && P.text === "") continue;
    else K.push(P);
    return K;
  }
}
function XT($18, q) {
  if (!$18 && !q) throw Error("Cannot merge two undefined objects.");
  if (!$18 || !q) return $18 || q;
  else if (typeof $18 !== typeof q) throw Error(`Cannot merge objects of different types.
Left ${typeof $18}
Right ${typeof q}`);
  else if (typeof $18 === "string" && typeof q === "string") return $18 + q;
  else if (Array.isArray($18) && Array.isArray(q)) return PP($18, q);
  else if (typeof $18 === "object" && typeof q === "object") return oq($18, q);
  else if ($18 === q) return $18;
  else throw Error(`Can not merge objects of different types.
Left ${$18}
Right ${q}`);
}
var gK = class extends _K {
  static isInstance($18) {
    return super.isInstance($18) && "concat" in $18 && typeof $18.concat === "function";
  }
};
var WN = {};
Z6(WN, { ToolMessage: () => AT, ToolMessageChunk: () => JN, defaultToolCallParser: () => kT, isDirectToolOutput: () => HN, isToolMessage: () => TN, isToolMessageChunk: () => wN });
function HN($18) {
  return $18 != null && typeof $18 === "object" && "lc_direct_tool_output" in $18 && $18.lc_direct_tool_output === true;
}
var AT = class extends _K {
  constructor($18, q, K) {
    let P = typeof $18 === "string" || Array.isArray($18) ? { content: $18, name: K, tool_call_id: q } : $18;
    super(P);
    __publicField(this, "lc_direct_tool_output", true);
    __publicField(this, "type", "tool");
    __publicField(this, "status");
    __publicField(this, "tool_call_id");
    __publicField(this, "metadata");
    __publicField(this, "artifact");
    this.tool_call_id = P.tool_call_id, this.artifact = P.artifact, this.status = P.status, this.metadata = P.metadata;
  }
  static lc_name() {
    return "ToolMessage";
  }
  get lc_aliases() {
    return { tool_call_id: "tool_call_id" };
  }
  static isInstance($18) {
    return super.isInstance($18) && $18.type === "tool";
  }
  get _printableFields() {
    return { ...super._printableFields, tool_call_id: this.tool_call_id, artifact: this.artifact };
  }
};
var JN = class extends gK {
  constructor($18) {
    super($18);
    __publicField(this, "type", "tool");
    __publicField(this, "tool_call_id");
    __publicField(this, "status");
    __publicField(this, "artifact");
    this.tool_call_id = $18.tool_call_id, this.artifact = $18.artifact, this.status = $18.status;
  }
  static lc_name() {
    return "ToolMessageChunk";
  }
  concat($18) {
    return new this.constructor({ content: LK(this.content, $18.content), additional_kwargs: oq(this.additional_kwargs, $18.additional_kwargs), response_metadata: oq(this.response_metadata, $18.response_metadata), artifact: XT(this.artifact, $18.artifact), tool_call_id: this.tool_call_id, id: this.id ?? $18.id, status: ZT(this.status, $18.status) });
  }
  get _printableFields() {
    return { ...super._printableFields, tool_call_id: this.tool_call_id, artifact: this.artifact };
  }
};
function kT($18) {
  let q = [], K = [];
  for (let P of $18) if (!P.function) continue;
  else {
    let _ = P.function.name;
    try {
      let Y = JSON.parse(P.function.arguments);
      q.push({ name: _ || "", args: Y || {}, id: P.id });
    } catch {
      K.push({ name: _, args: P.function.arguments, id: P.id, error: "Malformed args." });
    }
  }
  return [q, K];
}
function TN($18) {
  return typeof $18 === "object" && $18 !== null && "getType" in $18 && typeof $18.getType === "function" && $18.getType() === "tool";
}
function wN($18) {
  return $18._getType() === "tool";
}
function GT($18) {
  if (typeof $18 > "u") return null;
  try {
    return JSON.parse($18);
  } catch {
  }
  let q = "", K = [], P = false, _ = false;
  for (let Y of $18) {
    if (P) if (Y === '"' && !_) P = false;
    else if (Y === `
` && !_) Y = "\\n";
    else if (Y === "\\") _ = !_;
    else _ = false;
    else if (Y === '"') P = true, _ = false;
    else if (Y === "{") K.push("}");
    else if (Y === "[") K.push("]");
    else if (Y === "}" || Y === "]") if (K && K[K.length - 1] === Y) K.pop();
    else return null;
    q += Y;
  }
  if (P) q += '"';
  for (let Y = K.length - 1; Y >= 0; Y -= 1) q += K[Y];
  try {
    return JSON.parse(q);
  } catch {
    return null;
  }
}
function uO($18) {
  switch ($18) {
    case "csv":
      return "text/csv";
    case "doc":
      return "application/vnd.openxmlformats-officedocument.wordprocessingml.document";
    case "docx":
      return "application/vnd.openxmlformats-officedocument.wordprocessingml.document";
    case "html":
      return "text/html";
    case "md":
      return "text/markdown";
    case "pdf":
      return "application/pdf";
    case "txt":
      return "text/plain";
    case "xls":
      return "application/vnd.ms-excel";
    case "xlsx":
      return "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet";
    case "gif":
      return "image/gif";
    case "jpeg":
      return "image/jpeg";
    case "jpg":
      return "image/jpeg";
    case "png":
      return "image/png";
    case "webp":
      return "image/webp";
    case "flv":
      return "video/flv";
    case "mkv":
      return "video/mkv";
    case "mov":
      return "video/mov";
    case "mp4":
      return "video/mp4";
    case "mpeg":
      return "video/mpeg";
    case "mpg":
      return "video/mpg";
    case "three_gp":
      return "video/three_gp";
    case "webm":
      return "video/webm";
    case "wmv":
      return "video/wmv";
    default:
      return "application/octet-stream";
  }
}
function fN($18) {
  if (_6($18.document) && _6($18.document.source)) {
    let q = _6($18.document) && U$($18.document.format) ? $18.document.format : "", K = uO(q);
    if (_6($18.document.source)) {
      if (_6($18.document.source.s3Location) && U$($18.document.source.s3Location.uri)) return { type: "file", mimeType: K, fileId: $18.document.source.s3Location.uri };
      if (J1($18.document.source.bytes)) return { type: "file", mimeType: K, data: $18.document.source.bytes };
      if (U$($18.document.source.text)) return { type: "file", mimeType: K, data: Buffer.from($18.document.source.text).toString("base64") };
      if (rq($18.document.source.content)) {
        let P = $18.document.source.content.reduce((_, Y) => {
          if (_6(Y) && U$(Y.text)) return _ + Y.text;
          return _;
        }, "");
        return { type: "file", mimeType: K, data: P };
      }
    }
  }
  return { type: "non_standard", value: $18 };
}
function ZN($18) {
  if (e$($18, "image") && _6($18.image)) {
    let q = _6($18.image) && U$($18.image.format) ? $18.image.format : "", K = uO(q);
    if (_6($18.image.source)) {
      if (_6($18.image.source.s3Location) && U$($18.image.source.s3Location.uri)) return { type: "image", mimeType: K, fileId: $18.image.source.s3Location.uri };
      if (J1($18.image.source.bytes)) return { type: "image", mimeType: K, data: $18.image.source.bytes };
    }
  }
  return { type: "non_standard", value: $18 };
}
function XN($18) {
  if (e$($18, "video") && _6($18.video)) {
    let q = _6($18.video) && U$($18.video.format) ? $18.video.format : "", K = uO(q);
    if (_6($18.video.source)) {
      if (_6($18.video.source.s3Location) && U$($18.video.source.s3Location.uri)) return { type: "video", mimeType: K, fileId: $18.video.source.s3Location.uri };
      if (J1($18.video.source.bytes)) return { type: "video", mimeType: K, data: $18.video.source.bytes };
    }
  }
  return { type: "non_standard", value: $18 };
}
function VT($18) {
  function* q() {
    let K = typeof $18.content === "string" ? [{ type: "text", text: $18.content }] : $18.content;
    for (let P of K) {
      if (e$(P, "cache_point")) {
        yield { type: "non_standard", value: P };
        continue;
      } else if (e$(P, "citations_content") && _6(P.citationsContent)) {
        let _ = rq(P.citationsContent.content) ? P.citationsContent.content.reduce((O, z) => {
          if (_6(z) && U$(z.text)) return O + z.text;
          return O;
        }, "") : "", Y = rq(P.citationsContent.citations) ? P.citationsContent.citations.reduce((O, z) => {
          if (_6(z)) {
            let J = rq(z.sourceContent) ? z.sourceContent.reduce((X, f) => {
              if (_6(f) && U$(f.text)) return X + f.text;
              return X;
            }, "") : "", T = KK(() => {
              if (_6(z.location)) {
                let X = z.location.documentChar || z.location.documentPage || z.location.documentChunk;
                if (_6(X)) return { source: K8(X.documentIndex) ? X.documentIndex.toString() : void 0, startIndex: K8(X.start) ? X.start : void 0, endIndex: K8(X.end) ? X.end : void 0 };
              }
              return {};
            });
            O.push({ type: "citation", citedText: J, ...T });
          }
          return O;
        }, []) : [];
        yield { type: "text", text: _, annotations: Y };
        continue;
      } else if (e$(P, "document") && _6(P.document)) {
        yield fN(P);
        continue;
      } else if (e$(P, "guard_content")) {
        yield { type: "non_standard", value: P };
        continue;
      } else if (e$(P, "image") && _6(P.image)) {
        yield ZN(P);
        continue;
      } else if (e$(P, "reasoning_content") && U$(P.reasoningText)) {
        yield { type: "reasoning", reasoning: P.reasoningText };
        continue;
      } else if (e$(P, "text") && U$(P.text)) {
        yield { type: "text", text: P.text };
        continue;
      } else if (e$(P, "tool_result")) {
        yield { type: "non_standard", value: P };
        continue;
      } else if (e$(P, "tool_call")) continue;
      else if (e$(P, "video") && _6(P.video)) {
        yield XN(P);
        continue;
      }
      yield { type: "non_standard", value: P };
    }
  }
  return Array.from(q());
}
var ST = { translateContent: VT, translateContentChunk: VT };
function MT($18) {
  function* q() {
    let K = typeof $18.content === "string" ? [{ type: "text", text: $18.content }] : $18.content;
    for (let P of K) {
      if (e$(P, "text") && U$(P.text)) {
        yield { type: "text", text: P.text };
        continue;
      } else if (e$(P, "inlineData") && _6(P.inlineData) && U$(P.inlineData.mimeType) && U$(P.inlineData.data)) {
        yield { type: "file", mimeType: P.inlineData.mimeType, data: P.inlineData.data };
        continue;
      } else if (e$(P, "functionCall") && _6(P.functionCall) && U$(P.functionCall.name) && _6(P.functionCall.args)) {
        yield { type: "tool_call", id: $18.id, name: P.functionCall.name, args: P.functionCall.args };
        continue;
      } else if (e$(P, "functionResponse")) {
        yield { type: "non_standard", value: P };
        continue;
      } else if (e$(P, "fileData") && _6(P.fileData) && U$(P.fileData.mimeType) && U$(P.fileData.fileUri)) {
        yield { type: "file", mimeType: P.fileData.mimeType, fileId: P.fileData.fileUri };
        continue;
      } else if (e$(P, "executableCode")) {
        yield { type: "non_standard", value: P };
        continue;
      } else if (e$(P, "codeExecutionResult")) {
        yield { type: "non_standard", value: P };
        continue;
      }
      yield { type: "non_standard", value: P };
    }
  }
  return Array.from(q());
}
var NT = { translateContent: MT, translateContentChunk: MT };
function CT($18) {
  function* q() {
    let K = typeof $18.content === "string" ? [{ type: "text", text: $18.content }] : $18.content;
    for (let P of K) {
      if (e$(P, "reasoning") && U$(P.reasoning)) {
        let _ = KK(() => {
          var _a2;
          let Y = K.indexOf(P);
          if (rq((_a2 = $18.additional_kwargs) == null ? void 0 : _a2.signatures) && Y >= 0) return $18.additional_kwargs.signatures.at(Y);
          return;
        });
        if (U$(_)) yield { type: "reasoning", reasoning: P.reasoning, signature: _ };
        else yield { type: "reasoning", reasoning: P.reasoning };
        continue;
      } else if (e$(P, "text") && U$(P.text)) {
        yield { type: "text", text: P.text };
        continue;
      } else if (e$(P, "image_url")) {
        if (U$(P.image_url)) if (P.image_url.startsWith("data:")) {
          let _ = /^data:([^;]+);base64,(.+)$/, Y = P.image_url.match(_);
          if (Y) yield { type: "image", data: Y[2], mimeType: Y[1] };
          else yield { type: "image", url: P.image_url };
        } else yield { type: "image", url: P.image_url };
        continue;
      } else if (e$(P, "media") && U$(P.mimeType) && U$(P.data)) {
        yield { type: "file", mimeType: P.mimeType, data: P.data };
        continue;
      }
      yield { type: "non_standard", value: P };
    }
  }
  return Array.from(q());
}
var ET = { translateContent: CT, translateContentChunk: CT };
globalThis.lc_block_translators_registry ?? (globalThis.lc_block_translators_registry = /* @__PURE__ */ new Map([["anthropic", vT], ["bedrock-converse", ST], ["google-genai", NT], ["google-vertexai", ET], ["openai", TT]]));
function hT($18) {
  return globalThis.lc_block_translators_registry.get($18);
}
function RT($18, q) {
  return oq($18 ?? {}, q ?? {});
}
function IT($18, q) {
  let K = {};
  if (($18 == null ? void 0 : $18.audio) !== void 0 || (q == null ? void 0 : q.audio) !== void 0) K.audio = (($18 == null ? void 0 : $18.audio) ?? 0) + ((q == null ? void 0 : q.audio) ?? 0);
  if (($18 == null ? void 0 : $18.image) !== void 0 || (q == null ? void 0 : q.image) !== void 0) K.image = (($18 == null ? void 0 : $18.image) ?? 0) + ((q == null ? void 0 : q.image) ?? 0);
  if (($18 == null ? void 0 : $18.video) !== void 0 || (q == null ? void 0 : q.video) !== void 0) K.video = (($18 == null ? void 0 : $18.video) ?? 0) + ((q == null ? void 0 : q.video) ?? 0);
  if (($18 == null ? void 0 : $18.document) !== void 0 || (q == null ? void 0 : q.document) !== void 0) K.document = (($18 == null ? void 0 : $18.document) ?? 0) + ((q == null ? void 0 : q.document) ?? 0);
  if (($18 == null ? void 0 : $18.text) !== void 0 || (q == null ? void 0 : q.text) !== void 0) K.text = (($18 == null ? void 0 : $18.text) ?? 0) + ((q == null ? void 0 : q.text) ?? 0);
  return K;
}
function AN($18, q) {
  let K = { ...IT($18, q) };
  if (($18 == null ? void 0 : $18.cache_read) !== void 0 || (q == null ? void 0 : q.cache_read) !== void 0) K.cache_read = (($18 == null ? void 0 : $18.cache_read) ?? 0) + ((q == null ? void 0 : q.cache_read) ?? 0);
  if (($18 == null ? void 0 : $18.cache_creation) !== void 0 || (q == null ? void 0 : q.cache_creation) !== void 0) K.cache_creation = (($18 == null ? void 0 : $18.cache_creation) ?? 0) + ((q == null ? void 0 : q.cache_creation) ?? 0);
  return K;
}
function kN($18, q) {
  let K = { ...IT($18, q) };
  if (($18 == null ? void 0 : $18.reasoning) !== void 0 || (q == null ? void 0 : q.reasoning) !== void 0) K.reasoning = (($18 == null ? void 0 : $18.reasoning) ?? 0) + ((q == null ? void 0 : q.reasoning) ?? 0);
  return K;
}
function DT($18, q) {
  return { input_tokens: (($18 == null ? void 0 : $18.input_tokens) ?? 0) + ((q == null ? void 0 : q.input_tokens) ?? 0), output_tokens: (($18 == null ? void 0 : $18.output_tokens) ?? 0) + ((q == null ? void 0 : q.output_tokens) ?? 0), total_tokens: (($18 == null ? void 0 : $18.total_tokens) ?? 0) + ((q == null ? void 0 : q.total_tokens) ?? 0), input_token_details: AN($18 == null ? void 0 : $18.input_token_details, q == null ? void 0 : q.input_token_details), output_token_details: kN($18 == null ? void 0 : $18.output_token_details, q == null ? void 0 : q.output_token_details) };
}
var OP = class extends gK {
  constructor($18) {
    var _a2, _b2;
    let q;
    if (typeof $18 === "string" || Array.isArray($18)) q = { content: $18, tool_calls: [], invalid_tool_calls: [], tool_call_chunks: [] };
    else if ($18.tool_call_chunks === void 0 || $18.tool_call_chunks.length === 0) q = { ...$18, tool_calls: $18.tool_calls ?? [], invalid_tool_calls: [], tool_call_chunks: [], usage_metadata: $18.usage_metadata !== void 0 ? $18.usage_metadata : void 0 };
    else {
      let P = ($18.tool_call_chunks ?? []).reduce((O, z) => {
        let J = O.findIndex(([T]) => {
          if ("id" in z && z.id && "index" in z && z.index !== void 0) return z.id === T.id && z.index === T.index;
          if ("id" in z && z.id) return z.id === T.id;
          if ("index" in z && z.index !== void 0) return z.index === T.index;
          return false;
        });
        if (J !== -1) O[J].push(z);
        else O.push([z]);
        return O;
      }, []), _ = [], Y = [];
      for (let O of P) {
        let z = null, J = ((_a2 = O[0]) == null ? void 0 : _a2.name) ?? "", T = O.map((V) => V.args || "").join(""), X = T.length ? T : "{}", f = (_b2 = O[0]) == null ? void 0 : _b2.id;
        try {
          if (z = GT(X), !f || z === null || typeof z !== "object" || Array.isArray(z)) throw Error("Malformed tool call chunk args.");
          _.push({ name: J, args: z, id: f, type: "tool_call" });
        } catch {
          Y.push({ name: J, args: X, id: f, error: "Malformed args.", type: "invalid_tool_call" });
        }
      }
      q = { ...$18, tool_calls: _, invalid_tool_calls: Y, usage_metadata: $18.usage_metadata !== void 0 ? $18.usage_metadata : void 0 };
    }
    super(q);
    __publicField(this, "type", "ai");
    __publicField(this, "tool_calls", []);
    __publicField(this, "invalid_tool_calls", []);
    __publicField(this, "tool_call_chunks", []);
    __publicField(this, "usage_metadata");
    this.tool_call_chunks = q.tool_call_chunks ?? this.tool_call_chunks, this.tool_calls = q.tool_calls ?? this.tool_calls, this.invalid_tool_calls = q.invalid_tool_calls ?? this.invalid_tool_calls, this.usage_metadata = q.usage_metadata;
  }
  get lc_aliases() {
    return { ...super.lc_aliases, tool_calls: "tool_calls", invalid_tool_calls: "invalid_tool_calls", tool_call_chunks: "tool_call_chunks" };
  }
  static lc_name() {
    return "AIMessageChunk";
  }
  get contentBlocks() {
    if (this.response_metadata && "output_version" in this.response_metadata && this.response_metadata.output_version === "v1") return this.content;
    if (this.response_metadata && "model_provider" in this.response_metadata && typeof this.response_metadata.model_provider === "string") {
      let q = hT(this.response_metadata.model_provider);
      if (q) return q.translateContent(this);
    }
    let $18 = super.contentBlocks;
    if (this.tool_calls) {
      if (typeof this.content !== "string") {
        let q = this.content.filter((K) => K.type === "tool_call").map((K) => K.id);
        for (let K of this.tool_calls) if (K.id && !q.includes(K.id)) $18.push({ ...K, type: "tool_call", id: K.id, name: K.name, args: K.args });
      }
    }
    return $18;
  }
  get _printableFields() {
    return { ...super._printableFields, tool_calls: this.tool_calls, tool_call_chunks: this.tool_call_chunks, invalid_tool_calls: this.invalid_tool_calls, usage_metadata: this.usage_metadata };
  }
  concat($18) {
    let q = { content: LK(this.content, $18.content), additional_kwargs: oq(this.additional_kwargs, $18.additional_kwargs), response_metadata: RT(this.response_metadata, $18.response_metadata), tool_call_chunks: [], id: this.id ?? $18.id };
    if (this.tool_call_chunks !== void 0 || $18.tool_call_chunks !== void 0) {
      let P = PP(this.tool_call_chunks, $18.tool_call_chunks);
      if (P !== void 0 && P.length > 0) q.tool_call_chunks = P;
    }
    if (this.usage_metadata !== void 0 || $18.usage_metadata !== void 0) q.usage_metadata = DT(this.usage_metadata, $18.usage_metadata);
    return new this.constructor(q);
  }
  static isInstance($18) {
    return super.isInstance($18) && $18.type === "ai";
  }
};
function LT($18, q = "Human", K = "AI") {
  let P = [];
  for (let _ of $18) {
    let Y;
    if (_._getType() === "human") Y = q;
    else if (_._getType() === "ai") Y = K;
    else if (_._getType() === "system") Y = "System";
    else if (_._getType() === "tool") Y = "Tool";
    else if (_._getType() === "generic") Y = _.role;
    else throw Error(`Got unsupported message type: ${_._getType()}`);
    let O = _.name ? `${_.name}, ` : "", z = typeof _.content === "string" ? _.content : JSON.stringify(_.content, null, 2);
    P.push(`${Y}: ${O}${z}`);
  }
  return P.join(`
`);
}
var GN = {};
Z6(GN, { getEnv: () => xT, getEnvironmentVariable: () => M8, getRuntimeEnvironment: () => pO, isBrowser: () => gT, isDeno: () => w1, isJsDom: () => yT, isNode: () => uT, isWebWorker: () => bT });
var gT = () => typeof window < "u" && typeof window.document < "u";
var bT = () => typeof globalThis === "object" && globalThis.constructor && globalThis.constructor.name === "DedicatedWorkerGlobalScope";
var yT = () => typeof window < "u" && window.name === "nodejs" || typeof navigator < "u" && navigator.userAgent.includes("jsdom");
var w1 = () => typeof Deno < "u";
var uT = () => typeof process < "u" && typeof process.versions < "u" && typeof process.versions.node < "u" && !w1();
var xT = () => {
  let $18;
  if (gT()) $18 = "browser";
  else if (uT()) $18 = "node";
  else if (bT()) $18 = "webworker";
  else if (yT()) $18 = "jsdom";
  else if (w1()) $18 = "deno";
  else $18 = "other";
  return $18;
};
var xO;
function pO() {
  if (xO === void 0) xO = { library: "langchain-js", runtime: xT() };
  return xO;
}
function M8($18) {
  var _a2;
  try {
    if (typeof process < "u") return (_a2 = process.env) == null ? void 0 : _a2[$18];
    else if (w1()) return Deno == null ? void 0 : Deno.env.get($18);
    else return;
  } catch {
    return;
  }
}
var pT = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;
function VN($18) {
  return typeof $18 === "string" && pT.test($18);
}
var m_ = VN;
var Xq = [];
for (YP = 0; YP < 256; ++YP) Xq.push((YP + 256).toString(16).slice(1));
var YP;
function cT($18, q = 0) {
  return (Xq[$18[q + 0]] + Xq[$18[q + 1]] + Xq[$18[q + 2]] + Xq[$18[q + 3]] + "-" + Xq[$18[q + 4]] + Xq[$18[q + 5]] + "-" + Xq[$18[q + 6]] + Xq[$18[q + 7]] + "-" + Xq[$18[q + 8]] + Xq[$18[q + 9]] + "-" + Xq[$18[q + 10]] + Xq[$18[q + 11]] + Xq[$18[q + 12]] + Xq[$18[q + 13]] + Xq[$18[q + 14]] + Xq[$18[q + 15]]).toLowerCase();
}
var f1;
var SN = new Uint8Array(16);
function cO() {
  if (!f1) {
    if (f1 = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto), !f1) throw Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
  }
  return f1(SN);
}
var MN = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var mO = { randomUUID: MN };
function NN($18, q, K) {
  if (mO.randomUUID && !q && !$18) return mO.randomUUID();
  $18 = $18 || {};
  var P = $18.random || ($18.rng || cO)();
  if (P[6] = P[6] & 15 | 64, P[8] = P[8] & 63 | 128, q) {
    K = K || 0;
    for (var _ = 0; _ < 16; ++_) q[K + _] = P[_];
    return q;
  }
  return cT(P);
}
var nq = NN;
var EN = {};
Z6(EN, { BaseCallbackHandler: () => P_, callbackHandlerPrefersStreaming: () => RN, isBaseCallbackHandler: () => dO });
var hN = class {
};
function RN($18) {
  return "lc_prefer_streaming" in $18 && $18.lc_prefer_streaming;
}
var P_ = class extends hN {
  constructor($18) {
    super();
    __publicField(this, "lc_serializable", false);
    __publicField(this, "lc_kwargs");
    __publicField(this, "ignoreLLM", false);
    __publicField(this, "ignoreChain", false);
    __publicField(this, "ignoreAgent", false);
    __publicField(this, "ignoreRetriever", false);
    __publicField(this, "ignoreCustomEvent", false);
    __publicField(this, "raiseError", false);
    __publicField(this, "awaitHandlers", M8("LANGCHAIN_CALLBACKS_BACKGROUND") === "false");
    if (this.lc_kwargs = $18 || {}, $18) this.ignoreLLM = $18.ignoreLLM ?? this.ignoreLLM, this.ignoreChain = $18.ignoreChain ?? this.ignoreChain, this.ignoreAgent = $18.ignoreAgent ?? this.ignoreAgent, this.ignoreRetriever = $18.ignoreRetriever ?? this.ignoreRetriever, this.ignoreCustomEvent = $18.ignoreCustomEvent ?? this.ignoreCustomEvent, this.raiseError = $18.raiseError ?? this.raiseError, this.awaitHandlers = this.raiseError || ($18._awaitHandler ?? this.awaitHandlers);
  }
  get lc_namespace() {
    return ["langchain_core", "callbacks", this.name];
  }
  get lc_secrets() {
    return;
  }
  get lc_attributes() {
    return;
  }
  get lc_aliases() {
    return;
  }
  get lc_serializable_keys() {
    return;
  }
  static lc_name() {
    return this.name;
  }
  get lc_id() {
    return [...this.lc_namespace, H1(this.constructor)];
  }
  copy() {
    return new this.constructor(this);
  }
  toJSON() {
    return RK.prototype.toJSON.call(this);
  }
  toJSONNotImplemented() {
    return RK.prototype.toJSONNotImplemented.call(this);
  }
  static fromMethods($18) {
    class q extends P_ {
      constructor() {
        super();
        __publicField(this, "name", nq());
        Object.assign(this, $18);
      }
    }
    return new q();
  }
};
var dO = ($18) => {
  let q = $18;
  return q !== void 0 && typeof q.copy === "function" && typeof q.name === "string" && typeof q.awaitHandlers === "boolean";
};
var Aq = [];
for (jP = 0; jP < 256; ++jP) Aq.push((jP + 256).toString(16).slice(1));
var jP;
function Z1($18, q = 0) {
  return (Aq[$18[q + 0]] + Aq[$18[q + 1]] + Aq[$18[q + 2]] + Aq[$18[q + 3]] + "-" + Aq[$18[q + 4]] + Aq[$18[q + 5]] + "-" + Aq[$18[q + 6]] + Aq[$18[q + 7]] + "-" + Aq[$18[q + 8]] + Aq[$18[q + 9]] + "-" + Aq[$18[q + 10]] + Aq[$18[q + 11]] + Aq[$18[q + 12]] + Aq[$18[q + 13]] + Aq[$18[q + 14]] + Aq[$18[q + 15]]).toLowerCase();
}
var X1;
var IN = new Uint8Array(16);
function vP() {
  if (!X1) {
    if (X1 = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto), !X1) throw Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
  }
  return X1(IN);
}
var DN = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var lO = { randomUUID: DN };
function LN($18, q, K) {
  if (lO.randomUUID && !q && !$18) return lO.randomUUID();
  $18 = $18 || {};
  var P = $18.random || ($18.rng || vP)();
  if (P[6] = P[6] & 15 | 64, P[8] = P[8] & 63 | 128, q) {
    K = K || 0;
    for (var _ = 0; _ < 16; ++_) q[K + _] = P[_];
    return q;
  }
  return Z1(P);
}
var O_ = LN;
var mT = null;
var dT = null;
var N8 = 0;
function gN($18, q, K) {
  $18 = $18 || {};
  var P = q && K || 0, _ = q || new Uint8Array(16), Y = $18.random || ($18.rng || vP)(), O = $18.msecs !== void 0 ? $18.msecs : Date.now(), z = $18.seq !== void 0 ? $18.seq : null, J = dT, T = mT;
  if (O > N8 && $18.msecs === void 0) {
    if (N8 = O, z !== null) J = null, T = null;
  }
  if (z !== null) {
    if (z > 2147483647) z = 2147483647;
    J = z >>> 19 & 4095, T = z & 524287;
  }
  if (J === null || T === null) J = Y[6] & 127, J = J << 8 | Y[7], T = Y[8] & 63, T = T << 8 | Y[9], T = T << 5 | Y[10] >>> 3;
  if (O + 1e4 > N8 && z === null) {
    if (++T > 524287) {
      if (T = 0, ++J > 4095) J = 0, N8++;
    }
  } else N8 = O;
  return dT = J, mT = T, _[P++] = N8 / 1099511627776 & 255, _[P++] = N8 / 4294967296 & 255, _[P++] = N8 / 16777216 & 255, _[P++] = N8 / 65536 & 255, _[P++] = N8 / 256 & 255, _[P++] = N8 & 255, _[P++] = J >>> 4 & 15 | 112, _[P++] = J & 255, _[P++] = T >>> 13 & 63 | 128, _[P++] = T >>> 5 & 255, _[P++] = T << 3 & 255 | Y[10] & 7, _[P++] = Y[11], _[P++] = Y[12], _[P++] = Y[13], _[P++] = Y[14], _[P++] = Y[15], q || Z1(_);
}
var rO = gN;
var lT = "gen_ai.operation.name";
var rT = "gen_ai.system";
var oO = "gen_ai.request.model";
var oT = "gen_ai.response.model";
var nO = "gen_ai.usage.input_tokens";
var iO = "gen_ai.usage.output_tokens";
var BO = "gen_ai.usage.total_tokens";
var nT = "gen_ai.request.max_tokens";
var iT = "gen_ai.request.temperature";
var BT = "gen_ai.request.top_p";
var tT = "gen_ai.request.frequency_penalty";
var UT = "gen_ai.request.presence_penalty";
var FT = "gen_ai.response.finish_reasons";
var aT = "gen_ai.prompt";
var QT = "gen_ai.completion";
var eT = "gen_ai.request.extra_query";
var sT = "gen_ai.request.extra_body";
var $w = "gen_ai.serialized.name";
var qw = "gen_ai.serialized.signature";
var Kw = "gen_ai.serialized.doc";
var _w = "gen_ai.response.id";
var Pw = "gen_ai.response.service_tier";
var Ow = "gen_ai.response.system_fingerprint";
var Yw = "gen_ai.usage.input_token_details";
var jw = "gen_ai.usage.output_token_details";
var vw = "langsmith.trace.session_id";
var zw = "langsmith.trace.session_name";
var Ww = "langsmith.span.kind";
var Hw = "langsmith.trace.name";
var Jw = "langsmith.metadata";
var tO = "langsmith.span.tags";
var Tw = "langsmith.request.streaming";
var ww = "langsmith.request.headers";
var uN = (...$18) => fetch(...$18);
var fw = Symbol.for("ls:fetch_implementation");
var Zw = () => {
  let $18 = globalThis[fw];
  if (!$18) return false;
  return typeof $18 === "function" && "Headers" in $18 && "Request" in $18 && "Response" in $18;
};
var Xw = ($18) => {
  return async (...q) => {
    if ($18 || l6("DEBUG") === "true") {
      let [P, _] = q;
      console.log(` ${(_ == null ? void 0 : _.method) || "GET"} ${P}`);
    }
    let K = await (globalThis[fw] ?? uN)(...q);
    if ($18 || l6("DEBUG") === "true") console.log(` ${K.status} ${K.statusText} ${K.url}`);
    return K;
  };
};
var zP = () => {
  return l6("PROJECT") ?? _8("LANGCHAIN_SESSION") ?? "default";
};
var Aw = {};
function Y_($18) {
  if (!Aw[$18]) console.warn($18), Aw[$18] = true;
}
var Gw = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
var kw = false;
function O6($18, q) {
  if (!Gw.test($18)) {
    let K = q !== void 0 ? `Invalid UUID for ${q}: ${$18}` : `Invalid UUID: ${$18}`;
    throw Error(K);
  }
  return $18;
}
function A1($18) {
  let q = typeof $18 === "string" ? Date.parse($18) : $18;
  return rO({ msecs: q, seq: 0 });
}
function xN($18) {
  if (!Gw.test($18)) return null;
  let q = $18[14];
  return parseInt(q, 16);
}
function k1($18, q) {
  let K = xN($18);
  if (K !== null && K !== 7 && !kw) kw = true, Y_("LangSmith now uses UUID v7 for run and trace identifiers. This warning appears when passing custom IDs. Please use: import { uuidv7 } from 'langsmith'; const id = uuidv7(); Future versions will require UUID v7.");
}
var G1 = "0.3.80";
var p8;
var pN = () => typeof window < "u" && typeof window.document < "u";
var cN = () => typeof globalThis === "object" && globalThis.constructor && globalThis.constructor.name === "DedicatedWorkerGlobalScope";
var mN = () => typeof window < "u" && window.name === "nodejs" || typeof navigator < "u" && navigator.userAgent.includes("jsdom");
var Vw = () => typeof Deno < "u";
var dN = () => typeof process < "u" && typeof process.versions < "u" && typeof process.versions.node < "u" && !Vw();
var aO = () => {
  if (p8) return p8;
  if (typeof Bun < "u") p8 = "bun";
  else if (pN()) p8 = "browser";
  else if (dN()) p8 = "node";
  else if (cN()) p8 = "webworker";
  else if (mN()) p8 = "jsdom";
  else if (Vw()) p8 = "deno";
  else p8 = "other";
  return p8;
};
var UO;
function V1() {
  if (UO === void 0) {
    let $18 = aO(), q = rN();
    UO = { library: "langsmith", runtime: $18, sdk: "langsmith-js", sdk_version: G1, ...q };
  }
  return UO;
}
function QO() {
  let $18 = lN(), q = {}, K = ["LANGCHAIN_API_KEY", "LANGCHAIN_ENDPOINT", "LANGCHAIN_TRACING_V2", "LANGCHAIN_PROJECT", "LANGCHAIN_SESSION", "LANGSMITH_API_KEY", "LANGSMITH_ENDPOINT", "LANGSMITH_TRACING_V2", "LANGSMITH_PROJECT", "LANGSMITH_SESSION"];
  for (let [P, _] of Object.entries($18)) if (typeof _ === "string" && !K.includes(P) && !P.toLowerCase().includes("key") && !P.toLowerCase().includes("secret") && !P.toLowerCase().includes("token")) if (P === "LANGCHAIN_REVISION_ID") q.revision_id = _;
  else q[P] = _;
  return q;
}
function lN() {
  let $18 = {};
  try {
    if (typeof process < "u" && process.env) {
      for (let [q, K] of Object.entries(process.env)) if ((q.startsWith("LANGCHAIN_") || q.startsWith("LANGSMITH_")) && K != null) if ((q.toLowerCase().includes("key") || q.toLowerCase().includes("secret") || q.toLowerCase().includes("token")) && typeof K === "string") $18[q] = K.slice(0, 2) + "*".repeat(K.length - 4) + K.slice(-2);
      else $18[q] = K;
    }
  } catch (q) {
  }
  return $18;
}
function _8($18) {
  var _a2;
  try {
    return typeof process < "u" ? (_a2 = process.env) == null ? void 0 : _a2[$18] : void 0;
  } catch (q) {
    return;
  }
}
function l6($18) {
  return _8(`LANGSMITH_${$18}`) || _8(`LANGCHAIN_${$18}`);
}
var FO;
function rN() {
  if (FO !== void 0) return FO;
  let $18 = ["VERCEL_GIT_COMMIT_SHA", "NEXT_PUBLIC_VERCEL_GIT_COMMIT_SHA", "COMMIT_REF", "RENDER_GIT_COMMIT", "CI_COMMIT_SHA", "CIRCLE_SHA1", "CF_PAGES_COMMIT_SHA", "REACT_APP_GIT_SHA", "SOURCE_VERSION", "GITHUB_SHA", "TRAVIS_COMMIT", "GIT_COMMIT", "BUILD_VCS_NUMBER", "bamboo_planRepository_revision", "Build.SourceVersion", "BITBUCKET_COMMIT", "DRONE_COMMIT_SHA", "SEMAPHORE_GIT_SHA", "BUILDKITE_COMMIT"], q = {};
  for (let K of $18) {
    let P = _8(K);
    if (P !== void 0) q[K] = P;
  }
  return FO = q, q;
}
function S1() {
  return _8("OTEL_ENABLED") === "true" || l6("OTEL_ENABLED") === "true";
}
var Mw = class {
  constructor() {
    Object.defineProperty(this, "hasWarned", { enumerable: true, configurable: true, writable: true, value: false });
  }
  startActiveSpan($18, ...q) {
    if (!this.hasWarned && S1()) console.warn('You have enabled OTEL export via the `OTEL_ENABLED` or `LANGSMITH_OTEL_ENABLED` environment variable, but have not initialized the required OTEL instances. Please add:\n```\nimport { initializeOTEL } from "langsmith/experimental/otel/setup";\ninitializeOTEL();\n```\nat the beginning of your code.'), this.hasWarned = true;
    let K;
    if (q.length === 1 && typeof q[0] === "function") K = q[0];
    else if (q.length === 2 && typeof q[1] === "function") K = q[1];
    else if (q.length === 3 && typeof q[2] === "function") K = q[2];
    if (typeof K === "function") return K();
    return;
  }
};
var Nw = class {
  constructor() {
    Object.defineProperty(this, "mockTracer", { enumerable: true, configurable: true, writable: true, value: new Mw() });
  }
  getTracer($18, q) {
    return this.mockTracer;
  }
  getActiveSpan() {
    return;
  }
  setSpan($18, q) {
    return $18;
  }
  getSpan($18) {
    return;
  }
  setSpanContext($18, q) {
    return $18;
  }
  getTracerProvider() {
    return;
  }
  setGlobalTracerProvider($18) {
    return false;
  }
};
var Cw = class {
  active() {
    return {};
  }
  with($18, q) {
    return q();
  }
};
var eO = Symbol.for("ls:otel_trace");
var sO = Symbol.for("ls:otel_context");
var Sw = Symbol.for("ls:otel_get_default_otlp_tracer_provider");
var oN = new Nw();
var nN = new Cw();
var Ew = class {
  getTraceInstance() {
    return globalThis[eO] ?? oN;
  }
  getContextInstance() {
    return globalThis[sO] ?? nN;
  }
  initializeGlobalInstances($18) {
    if (globalThis[eO] === void 0) globalThis[eO] = $18.trace;
    if (globalThis[sO] === void 0) globalThis[sO] = $18.context;
  }
  setDefaultOTLPTracerComponents($18) {
    globalThis[Sw] = $18;
  }
  getDefaultOTLPTracerComponents() {
    return globalThis[Sw] ?? void 0;
  }
};
var $Y = new Ew();
function M1() {
  return $Y.getTraceInstance();
}
function hw() {
  return $Y.getContextInstance();
}
function Rw() {
  return $Y.getDefaultOTLPTracerComponents();
}
var iN = { llm: "chat", tool: "execute_tool", retriever: "embeddings", embedding: "embeddings", prompt: "chat" };
function BN($18) {
  return iN[$18] || $18;
}
var qY = class {
  constructor() {
    Object.defineProperty(this, "spans", { enumerable: true, configurable: true, writable: true, value: /* @__PURE__ */ new Map() });
  }
  exportBatch($18, q) {
    for (let K of $18) try {
      if (!K.run) continue;
      if (K.operation === "post") {
        let P = this.createSpanForRun(K, K.run, q.get(K.id));
        if (P && !K.run.end_time) this.spans.set(K.id, P);
      } else this.updateSpanForRun(K, K.run);
    } catch (P) {
      console.error(`Error processing operation ${K.id}:`, P);
    }
  }
  createSpanForRun($18, q, K) {
    let P = K && M1().getSpan(K);
    if (!P) return;
    try {
      return this.finishSpanSetup(P, q, $18);
    } catch (_) {
      console.error(`Failed to create span for run ${$18.id}:`, _);
      return;
    }
  }
  finishSpanSetup($18, q, K) {
    if (this.setSpanAttributes($18, q, K), q.error) $18.setStatus({ code: 2 }), $18.recordException(Error(q.error));
    else $18.setStatus({ code: 1 });
    if (q.end_time) $18.end(new Date(q.end_time));
    return $18;
  }
  updateSpanForRun($18, q) {
    try {
      let K = this.spans.get($18.id);
      if (!K) {
        console.debug(`No span found for run ${$18.id} during update`);
        return;
      }
      if (this.setSpanAttributes(K, q, $18), q.error) K.setStatus({ code: 2 }), K.recordException(Error(q.error));
      else K.setStatus({ code: 1 });
      let P = q.end_time;
      if (P) K.end(new Date(P)), this.spans.delete($18.id);
    } catch (K) {
      console.error(`Failed to update span for run ${$18.id}:`, K);
    }
  }
  extractModelName($18) {
    var _a2;
    if ((_a2 = $18.extra) == null ? void 0 : _a2.metadata) {
      let q = $18.extra.metadata;
      if (q.ls_model_name) return q.ls_model_name;
      if (q.invocation_params) {
        let K = q.invocation_params;
        if (K.model) return K.model;
        else if (K.model_name) return K.model_name;
      }
    }
    return;
  }
  setSpanAttributes($18, q, K) {
    var _a2;
    if ("run_type" in q && q.run_type) {
      $18.setAttribute(Ww, q.run_type);
      let O = BN(q.run_type || "chain");
      $18.setAttribute(lT, O);
    }
    if ("name" in q && q.name) $18.setAttribute(Hw, q.name);
    if ("session_id" in q && q.session_id) $18.setAttribute(vw, q.session_id);
    if ("session_name" in q && q.session_name) $18.setAttribute(zw, q.session_name);
    this.setGenAiSystem($18, q);
    let P = this.extractModelName(q);
    if (P) $18.setAttribute(oO, P);
    if ("prompt_tokens" in q && typeof q.prompt_tokens === "number") $18.setAttribute(nO, q.prompt_tokens);
    if ("completion_tokens" in q && typeof q.completion_tokens === "number") $18.setAttribute(iO, q.completion_tokens);
    if ("total_tokens" in q && typeof q.total_tokens === "number") $18.setAttribute(BO, q.total_tokens);
    this.setInvocationParameters($18, q);
    let _ = ((_a2 = q.extra) == null ? void 0 : _a2.metadata) || {};
    for (let [O, z] of Object.entries(_)) if (z !== null && z !== void 0) $18.setAttribute(`${Jw}.${O}`, String(z));
    let Y = q.tags;
    if (Y && Array.isArray(Y)) $18.setAttribute(tO, Y.join(", "));
    else if (Y) $18.setAttribute(tO, String(Y));
    if ("serialized" in q && typeof q.serialized === "object") {
      let O = q.serialized;
      if (O.name) $18.setAttribute($w, String(O.name));
      if (O.signature) $18.setAttribute(qw, String(O.signature));
      if (O.doc) $18.setAttribute(Kw, String(O.doc));
    }
    this.setIOAttributes($18, K);
  }
  setGenAiSystem($18, q) {
    let K = "langchain", P = this.extractModelName(q);
    if (P) {
      let _ = P.toLowerCase();
      if (_.includes("anthropic") || _.startsWith("claude")) K = "anthropic";
      else if (_.includes("bedrock")) K = "aws.bedrock";
      else if (_.includes("azure") && _.includes("openai")) K = "az.ai.openai";
      else if (_.includes("azure") && _.includes("inference")) K = "az.ai.inference";
      else if (_.includes("cohere")) K = "cohere";
      else if (_.includes("deepseek")) K = "deepseek";
      else if (_.includes("gemini")) K = "gemini";
      else if (_.includes("groq")) K = "groq";
      else if (_.includes("watson") || _.includes("ibm")) K = "ibm.watsonx.ai";
      else if (_.includes("mistral")) K = "mistral_ai";
      else if (_.includes("gpt") || _.includes("openai")) K = "openai";
      else if (_.includes("perplexity") || _.includes("sonar")) K = "perplexity";
      else if (_.includes("vertex")) K = "vertex_ai";
      else if (_.includes("xai") || _.includes("grok")) K = "xai";
    }
    $18.setAttribute(rT, K);
  }
  setInvocationParameters($18, q) {
    var _a2, _b2;
    if (!((_b2 = (_a2 = q.extra) == null ? void 0 : _a2.metadata) == null ? void 0 : _b2.invocation_params)) return;
    let K = q.extra.metadata.invocation_params;
    if (K.max_tokens !== void 0) $18.setAttribute(nT, K.max_tokens);
    if (K.temperature !== void 0) $18.setAttribute(iT, K.temperature);
    if (K.top_p !== void 0) $18.setAttribute(BT, K.top_p);
    if (K.frequency_penalty !== void 0) $18.setAttribute(tT, K.frequency_penalty);
    if (K.presence_penalty !== void 0) $18.setAttribute(UT, K.presence_penalty);
  }
  setIOAttributes($18, q) {
    if (q.run.inputs) try {
      let K = q.run.inputs;
      if (typeof K === "object" && K !== null) {
        if (K.model && Array.isArray(K.messages)) $18.setAttribute(oO, K.model);
        if (K.stream !== void 0) $18.setAttribute(Tw, K.stream);
        if (K.extra_headers) $18.setAttribute(ww, JSON.stringify(K.extra_headers));
        if (K.extra_query) $18.setAttribute(eT, JSON.stringify(K.extra_query));
        if (K.extra_body) $18.setAttribute(sT, JSON.stringify(K.extra_body));
      }
      $18.setAttribute(aT, JSON.stringify(K));
    } catch (K) {
      console.debug(`Failed to process inputs for run ${q.id}`, K);
    }
    if (q.run.outputs) try {
      let K = q.run.outputs, P = this.getUnifiedRunTokens(K);
      if (P) $18.setAttribute(nO, P[0]), $18.setAttribute(iO, P[1]), $18.setAttribute(BO, P[0] + P[1]);
      if (K && typeof K === "object") {
        if (K.model) $18.setAttribute(oT, String(K.model));
        if (K.id) $18.setAttribute(_w, K.id);
        if (K.choices && Array.isArray(K.choices)) {
          let _ = K.choices.map((Y) => Y.finish_reason).filter((Y) => Y).map(String);
          if (_.length > 0) $18.setAttribute(FT, _.join(", "));
        }
        if (K.service_tier) $18.setAttribute(Pw, K.service_tier);
        if (K.system_fingerprint) $18.setAttribute(Ow, K.system_fingerprint);
        if (K.usage_metadata && typeof K.usage_metadata === "object") {
          let _ = K.usage_metadata;
          if (_.input_token_details) $18.setAttribute(Yw, JSON.stringify(_.input_token_details));
          if (_.output_token_details) $18.setAttribute(jw, JSON.stringify(_.output_token_details));
        }
      }
      $18.setAttribute(QT, JSON.stringify(K));
    } catch (K) {
      console.debug(`Failed to process outputs for run ${q.id}`, K);
    }
  }
  getUnifiedRunTokens($18) {
    if (!$18) return null;
    let q = this.extractUnifiedRunTokens($18.usage_metadata);
    if (q) return q;
    let K = Object.keys($18);
    for (let Y of K) {
      let O = $18[Y];
      if (!O || typeof O !== "object") continue;
      if (q = this.extractUnifiedRunTokens(O.usage_metadata), q) return q;
      if (O.lc === 1 && O.kwargs && typeof O.kwargs === "object") {
        if (q = this.extractUnifiedRunTokens(O.kwargs.usage_metadata), q) return q;
      }
    }
    let P = $18.generations || [];
    if (!Array.isArray(P)) return null;
    let _ = Array.isArray(P[0]) ? P.flat() : P;
    for (let Y of _) if (typeof Y === "object" && Y.message && typeof Y.message === "object" && Y.message.kwargs && typeof Y.message.kwargs === "object") {
      if (q = this.extractUnifiedRunTokens(Y.message.kwargs.usage_metadata), q) return q;
    }
    return null;
  }
  extractUnifiedRunTokens($18) {
    if (!$18 || typeof $18 !== "object") return null;
    if (typeof $18.input_tokens !== "number" || typeof $18.output_tokens !== "number") return null;
    return [$18.input_tokens, $18.output_tokens];
  }
};
var Uw = q8(C1(), 1);
var D1 = q8(I1(), 1);
var TC = [429, 500, 502, 503, 504];
var L1 = class {
  constructor($18) {
    if (Object.defineProperty(this, "maxConcurrency", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "maxRetries", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "maxQueueSizeBytes", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "queue", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "onFailedResponseHook", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "queueSizeBytes", { enumerable: true, configurable: true, writable: true, value: 0 }), this.maxConcurrency = $18.maxConcurrency ?? 1 / 0, this.maxRetries = $18.maxRetries ?? 6, this.maxQueueSizeBytes = $18.maxQueueSizeBytes, "default" in D1.default) this.queue = new D1.default.default({ concurrency: this.maxConcurrency });
    else this.queue = new D1.default({ concurrency: this.maxConcurrency });
    this.onFailedResponseHook = $18 == null ? void 0 : $18.onFailedResponseHook;
  }
  call($18, ...q) {
    return this.callWithOptions({}, $18, ...q);
  }
  callWithOptions($18, q, ...K) {
    let P = $18.sizeBytes ?? 0;
    if (this.maxQueueSizeBytes !== void 0 && P > 0 && this.queueSizeBytes + P > this.maxQueueSizeBytes) return Promise.reject(Error(`Queue size limit (${this.maxQueueSizeBytes} bytes) exceeded. Current queue size: ${this.queueSizeBytes} bytes, attempted addition: ${P} bytes.`));
    if (P > 0) this.queueSizeBytes += P;
    let _ = this.onFailedResponseHook, Y = this.queue.add(() => Uw.default(() => q(...K).catch((O) => {
      if (O instanceof Error) throw O;
      else throw Error(O);
    }), { async onFailedAttempt(O) {
      if (O.message.startsWith("Cancel") || O.message.startsWith("TimeoutError") || O.name === "TimeoutError" || O.message.startsWith("AbortError")) throw O;
      if ((O == null ? void 0 : O.code) === "ECONNABORTED") throw O;
      let z = O == null ? void 0 : O.response;
      if (_) {
        if (await _(z)) return;
      }
      let J = (z == null ? void 0 : z.status) ?? (O == null ? void 0 : O.status);
      if (J) {
        if (!TC.includes(+J)) throw O;
      }
    }, retries: this.maxRetries, randomize: true }), { throwOnTimeout: true });
    if (P > 0) Y = Y.finally(() => {
      this.queueSizeBytes -= P;
    });
    if ($18.signal) return Promise.race([Y, new Promise((O, z) => {
      var _a2;
      (_a2 = $18.signal) == null ? void 0 : _a2.addEventListener("abort", () => {
        z(Error("AbortError"));
      });
    })]);
    return Y;
  }
};
function OY($18) {
  return typeof ($18 == null ? void 0 : $18._getType) === "function";
}
function YY($18) {
  let q = { type: $18._getType(), data: { content: $18.content } };
  if (($18 == null ? void 0 : $18.additional_kwargs) && Object.keys($18.additional_kwargs).length > 0) q.data.additional_kwargs = { ...$18.additional_kwargs };
  return q;
}
var YR = q8(mZ(), 1);
function PK($18) {
  if (!$18 || $18.split("/").length > 2 || $18.startsWith("/") || $18.endsWith("/") || $18.split(":").length > 2) throw Error(`Invalid identifier format: ${$18}`);
  let [q, K] = $18.split(":"), P = K || "latest";
  if (q.includes("/")) {
    let [_, Y] = q.split("/", 2);
    if (!_ || !Y) throw Error(`Invalid identifier format: ${$18}`);
    return [_, Y, P];
  } else {
    if (!q) throw Error(`Invalid identifier format: ${$18}`);
    return ["-", q, P];
  }
}
var dZ = class extends Error {
  constructor($18) {
    super($18);
    Object.defineProperty(this, "status", { enumerable: true, configurable: true, writable: true, value: void 0 }), this.name = "LangSmithConflictError", this.status = 409;
  }
};
async function $6($18, q, K) {
  var _a2;
  let P;
  if ($18.ok) {
    if (K) P = await $18.text();
    return;
  }
  if ($18.status === 403) try {
    if (((_a2 = await $18.json()) == null ? void 0 : _a2.error) === "org_scoped_key_requires_workspace") P = "This API key is org-scoped and requires workspace specification. Please provide 'workspaceId' parameter, or set LANGSMITH_WORKSPACE_ID environment variable.";
  } catch (O) {
    let z = Error(`${$18.status} ${$18.statusText}`);
    throw z.status = $18 == null ? void 0 : $18.status, z;
  }
  if (P === void 0) try {
    P = await $18.text();
  } catch (O) {
    P = "";
  }
  let _ = `Failed to ${q}. Received status [${$18.status}]: ${$18.statusText}. Message: ${P}`;
  if ($18.status === 409) throw new dZ(_);
  let Y = Error(_);
  throw Y.status = $18.status, Y;
}
var lZ = "ERR_CONFLICTING_ENDPOINTS";
var SY = class extends Error {
  constructor() {
    super("You cannot provide both LANGSMITH_ENDPOINT / LANGCHAIN_ENDPOINT and LANGSMITH_RUNS_ENDPOINTS.");
    Object.defineProperty(this, "code", { enumerable: true, configurable: true, writable: true, value: lZ }), this.name = "ConflictingEndpointsError";
  }
};
function rZ($18) {
  return typeof $18 === "object" && $18 !== null && $18.code === lZ;
}
var oZ = "[...]";
var jR = { result: "[Circular]" };
var B1 = [];
var l_ = [];
var vR = new TextEncoder();
function zR() {
  return { depthLimit: Number.MAX_SAFE_INTEGER, edgesLimit: Number.MAX_SAFE_INTEGER };
}
function i1($18) {
  return vR.encode($18);
}
function nZ($18) {
  if ($18 && typeof $18 === "object" && $18 !== null) {
    if ($18 instanceof Map) return Object.fromEntries($18);
    else if ($18 instanceof Set) return Array.from($18);
    else if ($18 instanceof Date) return $18.toISOString();
    else if ($18 instanceof RegExp) return $18.toString();
    else if ($18 instanceof Error) return { name: $18.name, message: $18.message };
  } else if (typeof $18 === "bigint") return $18.toString();
  return $18;
}
function WR($18) {
  return function(q, K) {
    if ($18) {
      let P = $18.call(this, q, K);
      if (P !== void 0) return P;
    }
    return nZ(K);
  };
}
function iq($18, q, K, P, _) {
  var _a2;
  try {
    let Y = JSON.stringify($18, WR(K), P);
    return i1(Y);
  } catch (Y) {
    if (!((_a2 = Y.message) == null ? void 0 : _a2.includes("Converting circular structure to JSON"))) return console.warn(`[WARNING]: LangSmith received unserializable value.${q ? `
Context: ${q}` : ""}`), i1("[Unserializable]");
    if (l6("SUPPRESS_CIRCULAR_JSON_WARNINGS") !== "true" && console.warn(`[WARNING]: LangSmith received circular JSON. This will decrease tracer performance. ${q ? `
Context: ${q}` : ""}`), typeof _ > "u") _ = zR();
    NY($18, "", 0, [], void 0, 0, _);
    let O;
    try {
      if (l_.length === 0) O = JSON.stringify($18, K, P);
      else O = JSON.stringify($18, HR(K), P);
    } catch (z) {
      return i1("[unable to serialize, circular reference is too complex to analyze]");
    } finally {
      while (B1.length !== 0) {
        let z = B1.pop();
        if (z.length === 4) Object.defineProperty(z[0], z[1], z[3]);
        else z[0][z[1]] = z[2];
      }
    }
    return i1(O);
  }
}
function MY($18, q, K, P) {
  var _ = Object.getOwnPropertyDescriptor(P, K);
  if (_.get !== void 0) if (_.configurable) Object.defineProperty(P, K, { value: $18 }), B1.push([P, K, q, _]);
  else l_.push([q, K, $18]);
  else P[K] = $18, B1.push([P, K, q]);
}
function NY($18, q, K, P, _, Y, O) {
  Y += 1;
  var z;
  if (typeof $18 === "object" && $18 !== null) {
    for (z = 0; z < P.length; z++) if (P[z] === $18) {
      MY(jR, $18, q, _);
      return;
    }
    if (typeof O.depthLimit < "u" && Y > O.depthLimit) {
      MY(oZ, $18, q, _);
      return;
    }
    if (typeof O.edgesLimit < "u" && K + 1 > O.edgesLimit) {
      MY(oZ, $18, q, _);
      return;
    }
    if (P.push($18), Array.isArray($18)) for (z = 0; z < $18.length; z++) NY($18[z], z, z, P, $18, Y, O);
    else {
      $18 = nZ($18);
      var J = Object.keys($18);
      for (z = 0; z < J.length; z++) {
        var T = J[z];
        NY($18[T], T, z, P, $18, Y, O);
      }
    }
    P.pop();
  }
}
function HR($18) {
  return $18 = typeof $18 < "u" ? $18 : function(q, K) {
    return K;
  }, function(q, K) {
    if (l_.length > 0) for (var P = 0; P < l_.length; P++) {
      var _ = l_[P];
      if (_[1] === q && _[0] === K) {
        K = _[2], l_.splice(P, 1);
        break;
      }
    }
    return $18.call(this, q, K);
  };
}
function iZ($18, q) {
  let K = V1(), P = q ?? QO(), _ = $18.extra ?? {}, Y = _.metadata;
  return $18.extra = { ..._, runtime: { ...K, ..._ == null ? void 0 : _.runtime }, metadata: { ...P, ...P.revision_id || "revision_id" in $18 && $18.revision_id ? { revision_id: ("revision_id" in $18 ? $18.revision_id : void 0) ?? P.revision_id } : {}, ...Y } }, $18;
}
var JR = ($18) => {
  let q = ($18 == null ? void 0 : $18.toString()) ?? l6("TRACING_SAMPLING_RATE");
  if (q === void 0) return;
  let K = parseFloat(q);
  if (K < 0 || K > 1) throw Error(`LANGSMITH_TRACING_SAMPLING_RATE must be between 0 and 1 if set. Got: ${K}`);
  return K;
};
var TR = ($18) => {
  let K = $18.replace("http://", "").replace("https://", "").split("/")[0].split(":")[0];
  return K === "localhost" || K === "127.0.0.1" || K === "::1";
};
async function wR($18) {
  let q = [];
  for await (let K of $18) q.push(K);
  return q;
}
function t1($18) {
  if ($18 === void 0) return;
  return $18.trim().replace(/^"(.*)"$/, "$1").replace(/^'(.*)'$/, "$1");
}
var fR = async ($18) => {
  if (($18 == null ? void 0 : $18.status) === 429) {
    let q = parseInt($18.headers.get("retry-after") ?? "10", 10) * 1e3;
    if (q > 0) return await new Promise((K) => setTimeout(K, q)), true;
  }
  return false;
};
function BZ($18) {
  if (typeof $18 === "number") return Number($18.toFixed(4));
  return $18;
}
var ZR = 25165824;
var FZ = 1073741824;
var XR = 1e4;
var AR = 100;
var tZ = "https://api.smith.langchain.com";
var aZ = class {
  constructor($18) {
    Object.defineProperty(this, "items", { enumerable: true, configurable: true, writable: true, value: [] }), Object.defineProperty(this, "sizeBytes", { enumerable: true, configurable: true, writable: true, value: 0 }), Object.defineProperty(this, "maxSizeBytes", { enumerable: true, configurable: true, writable: true, value: void 0 }), this.maxSizeBytes = $18 ?? FZ;
  }
  peek() {
    return this.items[0];
  }
  push($18) {
    let q, K = new Promise((_) => {
      q = _;
    }), P = iq($18.item, `Serializing run with id: ${$18.item.id}`).length;
    if (this.sizeBytes + P > this.maxSizeBytes && this.items.length > 0) return console.warn(`AutoBatchQueue size limit (${this.maxSizeBytes} bytes) exceeded. Dropping run with id: ${$18.item.id}. Current queue size: ${this.sizeBytes} bytes, attempted addition: ${P} bytes.`), q(), K;
    return this.items.push({ action: $18.action, payload: $18.item, otelContext: $18.otelContext, apiKey: $18.apiKey, apiUrl: $18.apiUrl, itemPromiseResolve: q, itemPromise: K, size: P }), this.sizeBytes += P, K;
  }
  pop({ upToSizeBytes: $18, upToSize: q }) {
    var _a2;
    if ($18 < 1) throw Error("Number of bytes to pop off may not be less than 1.");
    let K = [], P = 0;
    while (P + (((_a2 = this.peek()) == null ? void 0 : _a2.size) ?? 0) < $18 && this.items.length > 0 && K.length < q) {
      let _ = this.items.shift();
      if (_) K.push(_), P += _.size, this.sizeBytes -= _.size;
    }
    if (K.length === 0 && this.items.length > 0) {
      let _ = this.items.shift();
      K.push(_), P += _.size, this.sizeBytes -= _.size;
    }
    return [K.map((_) => ({ action: _.action, item: _.payload, otelContext: _.otelContext, apiKey: _.apiKey, apiUrl: _.apiUrl, size: _.size })), () => K.forEach((_) => _.itemPromiseResolve())];
  }
};
var bK = class _bK {
  get _fetch() {
    return this.fetchImplementation || Xw(this.debug);
  }
  constructor($18 = {}) {
    var _a2;
    Object.defineProperty(this, "apiKey", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "apiUrl", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "webUrl", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "workspaceId", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "caller", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "batchIngestCaller", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "timeout_ms", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "_tenantId", { enumerable: true, configurable: true, writable: true, value: null }), Object.defineProperty(this, "hideInputs", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "hideOutputs", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "tracingSampleRate", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "filteredPostUuids", { enumerable: true, configurable: true, writable: true, value: /* @__PURE__ */ new Set() }), Object.defineProperty(this, "autoBatchTracing", { enumerable: true, configurable: true, writable: true, value: true }), Object.defineProperty(this, "autoBatchQueue", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "autoBatchTimeout", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "autoBatchAggregationDelayMs", { enumerable: true, configurable: true, writable: true, value: 250 }), Object.defineProperty(this, "batchSizeBytesLimit", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "batchSizeLimit", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "fetchOptions", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "settings", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "blockOnRootRunFinalization", { enumerable: true, configurable: true, writable: true, value: _8("LANGSMITH_TRACING_BACKGROUND") === "false" }), Object.defineProperty(this, "traceBatchConcurrency", { enumerable: true, configurable: true, writable: true, value: 5 }), Object.defineProperty(this, "_serverInfo", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "_getServerInfoPromise", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "manualFlushMode", { enumerable: true, configurable: true, writable: true, value: false }), Object.defineProperty(this, "langSmithToOTELTranslator", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "fetchImplementation", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "cachedLSEnvVarsForMetadata", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "multipartStreamingDisabled", { enumerable: true, configurable: true, writable: true, value: false }), Object.defineProperty(this, "debug", { enumerable: true, configurable: true, writable: true, value: _8("LANGSMITH_DEBUG") === "true" });
    let q = _bK.getDefaultClientConfig();
    if (this.tracingSampleRate = JR($18.tracingSamplingRate), this.apiUrl = t1($18.apiUrl ?? q.apiUrl) ?? "", this.apiUrl.endsWith("/")) this.apiUrl = this.apiUrl.slice(0, -1);
    if (this.apiKey = t1($18.apiKey ?? q.apiKey), this.webUrl = t1($18.webUrl ?? q.webUrl), (_a2 = this.webUrl) == null ? void 0 : _a2.endsWith("/")) this.webUrl = this.webUrl.slice(0, -1);
    if (this.workspaceId = t1($18.workspaceId ?? l6("WORKSPACE_ID")), this.timeout_ms = $18.timeout_ms ?? 9e4, this.caller = new L1({ ...$18.callerOptions ?? {}, maxRetries: 4, debug: $18.debug ?? this.debug }), this.traceBatchConcurrency = $18.traceBatchConcurrency ?? this.traceBatchConcurrency, this.traceBatchConcurrency < 1) throw Error("Trace batch concurrency must be positive.");
    this.debug = $18.debug ?? this.debug, this.fetchImplementation = $18.fetchImplementation;
    let K = $18.maxIngestMemoryBytes ?? FZ;
    if (this.batchIngestCaller = new L1({ maxRetries: 4, maxConcurrency: this.traceBatchConcurrency, maxQueueSizeBytes: K, ...$18.callerOptions ?? {}, onFailedResponseHook: fR, debug: $18.debug ?? this.debug }), this.hideInputs = $18.hideInputs ?? $18.anonymizer ?? q.hideInputs, this.hideOutputs = $18.hideOutputs ?? $18.anonymizer ?? q.hideOutputs, this.autoBatchTracing = $18.autoBatchTracing ?? this.autoBatchTracing, this.autoBatchQueue = new aZ(K), this.blockOnRootRunFinalization = $18.blockOnRootRunFinalization ?? this.blockOnRootRunFinalization, this.batchSizeBytesLimit = $18.batchSizeBytesLimit, this.batchSizeLimit = $18.batchSizeLimit, this.fetchOptions = $18.fetchOptions || {}, this.manualFlushMode = $18.manualFlushMode ?? this.manualFlushMode, S1()) this.langSmithToOTELTranslator = new qY();
    this.cachedLSEnvVarsForMetadata = QO();
  }
  static getDefaultClientConfig() {
    let $18 = l6("API_KEY"), q = l6("ENDPOINT") ?? tZ, K = l6("HIDE_INPUTS") === "true", P = l6("HIDE_OUTPUTS") === "true";
    return { apiUrl: q, apiKey: $18, webUrl: void 0, hideInputs: K, hideOutputs: P };
  }
  getHostUrl() {
    if (this.webUrl) return this.webUrl;
    else if (TR(this.apiUrl)) return this.webUrl = "http://localhost:3000", this.webUrl;
    else if (this.apiUrl.endsWith("/api/v1")) return this.webUrl = this.apiUrl.replace("/api/v1", ""), this.webUrl;
    else if (this.apiUrl.includes("/api") && !this.apiUrl.split(".", 1)[0].endsWith("api")) return this.webUrl = this.apiUrl.replace("/api", ""), this.webUrl;
    else if (this.apiUrl.split(".", 1)[0].includes("dev")) return this.webUrl = "https://dev.smith.langchain.com", this.webUrl;
    else if (this.apiUrl.split(".", 1)[0].includes("eu")) return this.webUrl = "https://eu.smith.langchain.com", this.webUrl;
    else if (this.apiUrl.split(".", 1)[0].includes("beta")) return this.webUrl = "https://beta.smith.langchain.com", this.webUrl;
    else return this.webUrl = "https://smith.langchain.com", this.webUrl;
  }
  get headers() {
    let $18 = { "User-Agent": `langsmith-js/${G1}` };
    if (this.apiKey) $18["x-api-key"] = `${this.apiKey}`;
    if (this.workspaceId) $18["x-tenant-id"] = this.workspaceId;
    return $18;
  }
  _getPlatformEndpointPath($18) {
    return this.apiUrl.slice(-3) !== "/v1" && this.apiUrl.slice(-4) !== "/v1/" ? `/v1/platform/${$18}` : `/platform/${$18}`;
  }
  async processInputs($18) {
    if (this.hideInputs === false) return $18;
    if (this.hideInputs === true) return {};
    if (typeof this.hideInputs === "function") return this.hideInputs($18);
    return $18;
  }
  async processOutputs($18) {
    if (this.hideOutputs === false) return $18;
    if (this.hideOutputs === true) return {};
    if (typeof this.hideOutputs === "function") return this.hideOutputs($18);
    return $18;
  }
  async prepareRunCreateOrUpdateInputs($18) {
    let q = { ...$18 };
    if (q.inputs !== void 0) q.inputs = await this.processInputs(q.inputs);
    if (q.outputs !== void 0) q.outputs = await this.processOutputs(q.outputs);
    return q;
  }
  async _getResponse($18, q) {
    let K = (q == null ? void 0 : q.toString()) ?? "", P = `${this.apiUrl}${$18}?${K}`;
    return await this.caller.call(async () => {
      let Y = await this._fetch(P, { method: "GET", headers: this.headers, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions });
      return await $6(Y, `fetch ${$18}`), Y;
    });
  }
  async _get($18, q) {
    return (await this._getResponse($18, q)).json();
  }
  async *_getPaginated($18, q = new URLSearchParams(), K) {
    let P = Number(q.get("offset")) || 0, _ = Number(q.get("limit")) || 100;
    while (true) {
      q.set("offset", String(P)), q.set("limit", String(_));
      let Y = `${this.apiUrl}${$18}?${q}`, O = await this.caller.call(async () => {
        let J = await this._fetch(Y, { method: "GET", headers: this.headers, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions });
        return await $6(J, `fetch ${$18}`), J;
      }), z = K ? K(await O.json()) : await O.json();
      if (z.length === 0) break;
      if (yield z, z.length < _) break;
      P += z.length;
    }
  }
  async *_getCursorPaginatedList($18, q = null, K = "POST", P = "runs") {
    let _ = q ? { ...q } : {};
    while (true) {
      let Y = JSON.stringify(_), z = await (await this.caller.call(async () => {
        let T = await this._fetch(`${this.apiUrl}${$18}`, { method: K, headers: { ...this.headers, "Content-Type": "application/json" }, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions, body: Y });
        return await $6(T, `fetch ${$18}`), T;
      })).json();
      if (!z) break;
      if (!z[P]) break;
      yield z[P];
      let J = z.cursors;
      if (!J) break;
      if (!J.next) break;
      _.cursor = J.next;
    }
  }
  _shouldSample() {
    if (this.tracingSampleRate === void 0) return true;
    return Math.random() < this.tracingSampleRate;
  }
  _filterForSampling($18, q = false) {
    if (this.tracingSampleRate === void 0) return $18;
    if (q) {
      let K = [];
      for (let P of $18) if (!this.filteredPostUuids.has(P.trace_id)) K.push(P);
      else if (P.id === P.trace_id) this.filteredPostUuids.delete(P.trace_id);
      return K;
    } else {
      let K = [];
      for (let P of $18) {
        let _ = P.trace_id ?? P.id;
        if (this.filteredPostUuids.has(_)) continue;
        if (P.id === _) if (this._shouldSample()) K.push(P);
        else this.filteredPostUuids.add(_);
        else K.push(P);
      }
      return K;
    }
  }
  async _getBatchSizeLimitBytes() {
    var _a2;
    let $18 = await this._ensureServerInfo();
    return this.batchSizeBytesLimit ?? ((_a2 = $18.batch_ingest_config) == null ? void 0 : _a2.size_limit_bytes) ?? ZR;
  }
  async _getBatchSizeLimit() {
    var _a2;
    let $18 = await this._ensureServerInfo();
    return this.batchSizeLimit ?? ((_a2 = $18.batch_ingest_config) == null ? void 0 : _a2.size_limit) ?? AR;
  }
  async _getDatasetExamplesMultiPartSupport() {
    var _a2;
    return ((_a2 = (await this._ensureServerInfo()).instance_flags) == null ? void 0 : _a2.dataset_examples_multipart_enabled) ?? false;
  }
  drainAutoBatchQueue({ batchSizeLimitBytes: $18, batchSizeLimit: q }) {
    let K = [];
    while (this.autoBatchQueue.items.length > 0) {
      let [P, _] = this.autoBatchQueue.pop({ upToSizeBytes: $18, upToSize: q });
      if (!P.length) {
        _();
        break;
      }
      let Y = P.reduce((J, T) => {
        let X = T.apiUrl ?? this.apiUrl, f = T.apiKey ?? this.apiKey, M = T.apiKey === this.apiKey && T.apiUrl === this.apiUrl ? "default" : `${X}|${f}`;
        if (!J[M]) J[M] = [];
        return J[M].push(T), J;
      }, {}), O = [];
      for (let [J, T] of Object.entries(Y)) {
        let X = this._processBatch(T, { apiUrl: J === "default" ? void 0 : J.split("|")[0], apiKey: J === "default" ? void 0 : J.split("|")[1] });
        O.push(X);
      }
      let z = Promise.all(O).finally(_);
      K.push(z);
    }
    return Promise.all(K);
  }
  async _processBatch($18, q) {
    var _a2, _b2;
    if (!$18.length) return;
    let K = $18.reduce((P, _) => P + (_.size ?? 0), 0);
    try {
      if (this.langSmithToOTELTranslator !== void 0) this._sendBatchToOTELTranslator($18);
      else {
        let P = { runCreates: $18.filter((Y) => Y.action === "create").map((Y) => Y.item), runUpdates: $18.filter((Y) => Y.action === "update").map((Y) => Y.item) }, _ = await this._ensureServerInfo();
        if ((_a2 = _ == null ? void 0 : _.batch_ingest_config) == null ? void 0 : _a2.use_multipart_endpoint) {
          let Y = (_b2 = _ == null ? void 0 : _.instance_flags) == null ? void 0 : _b2.gzip_body_enabled;
          await this.multipartIngestRuns(P, { ...q, useGzip: Y, sizeBytes: K });
        } else await this.batchIngestRuns(P, { ...q, sizeBytes: K });
      }
    } catch (P) {
      console.error("Error exporting batch:", P);
    }
  }
  _sendBatchToOTELTranslator($18) {
    if (this.langSmithToOTELTranslator !== void 0) {
      let q = /* @__PURE__ */ new Map(), K = [];
      for (let P of $18) if (P.item.id && P.otelContext) if (q.set(P.item.id, P.otelContext), P.action === "create") K.push({ operation: "post", id: P.item.id, trace_id: P.item.trace_id ?? P.item.id, run: P.item });
      else K.push({ operation: "patch", id: P.item.id, trace_id: P.item.trace_id ?? P.item.id, run: P.item });
      this.langSmithToOTELTranslator.exportBatch(K, q);
    }
  }
  async processRunOperation($18) {
    clearTimeout(this.autoBatchTimeout), this.autoBatchTimeout = void 0, $18.item = iZ($18.item, this.cachedLSEnvVarsForMetadata);
    let q = this.autoBatchQueue.push($18);
    if (this.manualFlushMode) return q;
    let K = await this._getBatchSizeLimitBytes(), P = await this._getBatchSizeLimit();
    if (this.autoBatchQueue.sizeBytes > K || this.autoBatchQueue.items.length > P) this.drainAutoBatchQueue({ batchSizeLimitBytes: K, batchSizeLimit: P });
    if (this.autoBatchQueue.items.length > 0) this.autoBatchTimeout = setTimeout(() => {
      this.autoBatchTimeout = void 0, this.drainAutoBatchQueue({ batchSizeLimitBytes: K, batchSizeLimit: P });
    }, this.autoBatchAggregationDelayMs);
    return q;
  }
  async _getServerInfo() {
    let q = await (await this.caller.call(async () => {
      let K = await this._fetch(`${this.apiUrl}/info`, { method: "GET", headers: { Accept: "application/json" }, signal: AbortSignal.timeout(XR), ...this.fetchOptions });
      return await $6(K, "get server info"), K;
    })).json();
    if (this.debug) console.log(`
=== LangSmith Server Configuration ===
` + JSON.stringify(q, null, 2) + `
`);
    return q;
  }
  async _ensureServerInfo() {
    if (this._getServerInfoPromise === void 0) this._getServerInfoPromise = (async () => {
      if (this._serverInfo === void 0) try {
        this._serverInfo = await this._getServerInfo();
      } catch ($18) {
        console.warn(`[LANGSMITH]: Failed to fetch info on supported operations. Falling back to batch operations and default limits. Info: ${$18.status ?? "Unspecified status code"} ${$18.message}`);
      }
      return this._serverInfo ?? {};
    })();
    return this._getServerInfoPromise.then(($18) => {
      if (this._serverInfo === void 0) this._getServerInfoPromise = void 0;
      return $18;
    });
  }
  async _getSettings() {
    if (!this.settings) this.settings = this._get("/settings");
    return await this.settings;
  }
  async flush() {
    let $18 = await this._getBatchSizeLimitBytes(), q = await this._getBatchSizeLimit();
    await this.drainAutoBatchQueue({ batchSizeLimitBytes: $18, batchSizeLimit: q });
  }
  _cloneCurrentOTELContext() {
    let $18 = M1(), q = hw();
    if (this.langSmithToOTELTranslator !== void 0) {
      let K = $18.getActiveSpan();
      if (K) return $18.setSpan(q.active(), K);
    }
    return;
  }
  async createRun($18, q) {
    if (!this._filterForSampling([$18]).length) return;
    let K = { ...this.headers, "Content-Type": "application/json" }, P = $18.project_name;
    delete $18.project_name;
    let _ = await this.prepareRunCreateOrUpdateInputs({ session_name: P, ...$18, start_time: $18.start_time ?? Date.now() });
    if (this.autoBatchTracing && _.trace_id !== void 0 && _.dotted_order !== void 0) {
      let z = this._cloneCurrentOTELContext();
      this.processRunOperation({ action: "create", item: _, otelContext: z, apiKey: q == null ? void 0 : q.apiKey, apiUrl: q == null ? void 0 : q.apiUrl }).catch(console.error);
      return;
    }
    let Y = iZ(_, this.cachedLSEnvVarsForMetadata);
    if ((q == null ? void 0 : q.apiKey) !== void 0) K["x-api-key"] = q.apiKey;
    if ((q == null ? void 0 : q.workspaceId) !== void 0) K["x-tenant-id"] = q.workspaceId;
    let O = iq(Y, `Creating run with id: ${Y.id}`);
    await this.caller.call(async () => {
      let z = await this._fetch(`${(q == null ? void 0 : q.apiUrl) ?? this.apiUrl}/runs`, { method: "POST", headers: K, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions, body: O });
      return await $6(z, "create run", true), z;
    });
  }
  async batchIngestRuns({ runCreates: $18, runUpdates: q }, K) {
    if ($18 === void 0 && q === void 0) return;
    let P = await Promise.all(($18 == null ? void 0 : $18.map((z) => this.prepareRunCreateOrUpdateInputs(z))) ?? []), _ = await Promise.all((q == null ? void 0 : q.map((z) => this.prepareRunCreateOrUpdateInputs(z))) ?? []);
    if (P.length > 0 && _.length > 0) {
      let z = P.reduce((T, X) => {
        if (!X.id) return T;
        return T[X.id] = X, T;
      }, {}), J = [];
      for (let T of _) if (T.id !== void 0 && z[T.id]) z[T.id] = { ...z[T.id], ...T };
      else J.push(T);
      P = Object.values(z), _ = J;
    }
    let Y = { post: P, patch: _ };
    if (!Y.post.length && !Y.patch.length) return;
    let O = { post: [], patch: [] };
    for (let z of ["post", "patch"]) {
      let J = z, T = Y[J].reverse(), X = T.pop();
      while (X !== void 0) O[J].push(X), X = T.pop();
    }
    if (O.post.length > 0 || O.patch.length > 0) {
      let z = O.post.map((J) => J.id).concat(O.patch.map((J) => J.id)).join(",");
      await this._postBatchIngestRuns(iq(O, `Ingesting runs with ids: ${z}`), K);
    }
  }
  async _postBatchIngestRuns($18, q) {
    let K = { ...this.headers, "Content-Type": "application/json", Accept: "application/json" };
    if ((q == null ? void 0 : q.apiKey) !== void 0) K["x-api-key"] = q.apiKey;
    await this.batchIngestCaller.callWithOptions({ sizeBytes: q == null ? void 0 : q.sizeBytes }, async () => {
      let P = await this._fetch(`${(q == null ? void 0 : q.apiUrl) ?? this.apiUrl}/runs/batch`, { method: "POST", headers: K, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions, body: $18 });
      return await $6(P, "batch create run", true), P;
    });
  }
  async multipartIngestRuns({ runCreates: $18, runUpdates: q }, K) {
    if ($18 === void 0 && q === void 0) return;
    let P = {}, _ = [];
    for (let X of $18 ?? []) {
      let f = await this.prepareRunCreateOrUpdateInputs(X);
      if (f.id !== void 0 && f.attachments !== void 0) P[f.id] = f.attachments;
      delete f.attachments, _.push(f);
    }
    let Y = [];
    for (let X of q ?? []) Y.push(await this.prepareRunCreateOrUpdateInputs(X));
    if (_.find((X) => {
      return X.trace_id === void 0 || X.dotted_order === void 0;
    }) !== void 0) throw Error('Multipart ingest requires "trace_id" and "dotted_order" to be set when creating a run');
    if (Y.find((X) => {
      return X.trace_id === void 0 || X.dotted_order === void 0;
    }) !== void 0) throw Error('Multipart ingest requires "trace_id" and "dotted_order" to be set when updating a run');
    if (_.length > 0 && Y.length > 0) {
      let X = _.reduce((V, M) => {
        if (!M.id) return V;
        return V[M.id] = M, V;
      }, {}), f = [];
      for (let V of Y) if (V.id !== void 0 && X[V.id]) X[V.id] = { ...X[V.id], ...V };
      else f.push(V);
      _ = Object.values(X), Y = f;
    }
    if (_.length === 0 && Y.length === 0) return;
    let J = [], T = [];
    for (let [X, f] of [["post", _], ["patch", Y]]) for (let V of f) {
      let { inputs: M, outputs: N, events: h, extra: E, error: I, serialized: D, attachments: g, ...b } = V, y = { inputs: M, outputs: N, events: h, extra: E, error: I, serialized: D }, p = iq(b, `Serializing for multipart ingestion of run with id: ${b.id}`);
      T.push({ name: `${X}.${b.id}`, payload: new Blob([p], { type: `application/json; length=${p.length}` }) });
      for (let [n, s] of Object.entries(y)) {
        if (s === void 0) continue;
        let q$ = iq(s, `Serializing ${n} for multipart ingestion of run with id: ${b.id}`);
        T.push({ name: `${X}.${b.id}.${n}`, payload: new Blob([q$], { type: `application/json; length=${q$.length}` }) });
      }
      if (b.id !== void 0) {
        let n = P[b.id];
        if (n) {
          delete P[b.id];
          for (let [s, q$] of Object.entries(n)) {
            let c, U;
            if (Array.isArray(q$)) [c, U] = q$;
            else c = q$.mimeType, U = q$.data;
            if (s.includes(".")) {
              console.warn(`Skipping attachment '${s}' for run ${b.id}: Invalid attachment name. Attachment names must not contain periods ('.'). Please rename the attachment and try again.`);
              continue;
            }
            T.push({ name: `attachment.${b.id}.${s}`, payload: new Blob([U], { type: `${c}; length=${U.byteLength}` }) });
          }
        }
      }
      J.push(`trace=${b.trace_id},id=${b.id}`);
    }
    await this._sendMultipartRequest(T, J.join("; "), K);
  }
  async _createNodeFetchBody($18, q) {
    let K = [];
    for (let Y of $18) K.push(new Blob([`--${q}\r
`])), K.push(new Blob([`Content-Disposition: form-data; name="${Y.name}"\r
`, `Content-Type: ${Y.payload.type}\r
\r
`])), K.push(Y.payload), K.push(new Blob([`\r
`]));
    return K.push(new Blob([`--${q}--\r
`])), await new Blob(K).arrayBuffer();
  }
  async _createMultipartStream($18, q) {
    let K = new TextEncoder();
    return new ReadableStream({ async start(_) {
      let Y = async (O) => {
        if (typeof O === "string") _.enqueue(K.encode(O));
        else _.enqueue(O);
      };
      for (let O of $18) {
        await Y(`--${q}\r
`), await Y(`Content-Disposition: form-data; name="${O.name}"\r
`), await Y(`Content-Type: ${O.payload.type}\r
\r
`);
        let J = O.payload.stream().getReader();
        try {
          let T;
          while (!(T = await J.read()).done) _.enqueue(T.value);
        } finally {
          J.releaseLock();
        }
        await Y(`\r
`);
      }
      await Y(`--${q}--\r
`), _.close();
    } });
  }
  async _sendMultipartRequest($18, q, K) {
    let P = "----LangSmithFormBoundary" + Math.random().toString(36).slice(2), _ = Zw(), Y = () => this._createNodeFetchBody($18, P), O = () => this._createMultipartStream($18, P), z = async (J) => {
      return this.batchIngestCaller.callWithOptions({ sizeBytes: K == null ? void 0 : K.sizeBytes }, async () => {
        let T = await J(), X = { ...this.headers, "Content-Type": `multipart/form-data; boundary=${P}` };
        if ((K == null ? void 0 : K.apiKey) !== void 0) X["x-api-key"] = K.apiKey;
        let f = T;
        if ((K == null ? void 0 : K.useGzip) && typeof T === "object" && "pipeThrough" in T) f = T.pipeThrough(new CompressionStream("gzip")), X["Content-Encoding"] = "gzip";
        let V = await this._fetch(`${(K == null ? void 0 : K.apiUrl) ?? this.apiUrl}/runs/multipart`, { method: "POST", headers: X, body: f, duplex: "half", signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions });
        return await $6(V, "Failed to send multipart request", true), V;
      });
    };
    try {
      let J, T = false;
      if (!_ && !this.multipartStreamingDisabled && aO() !== "bun") T = true, J = await z(O);
      else J = await z(Y);
      if ((!this.multipartStreamingDisabled || T) && J.status === 422 && ((K == null ? void 0 : K.apiUrl) ?? this.apiUrl) !== tZ) console.warn(`Streaming multipart upload to ${(K == null ? void 0 : K.apiUrl) ?? this.apiUrl}/runs/multipart failed. This usually means the host does not support chunked uploads. Retrying with a buffered upload for operation "${q}".`), this.multipartStreamingDisabled = true, J = await z(Y);
    } catch (J) {
      console.warn(`${J.message.trim()}

Context: ${q}`);
    }
  }
  async updateRun($18, q, K) {
    if (O6($18), q.inputs) q.inputs = await this.processInputs(q.inputs);
    if (q.outputs) q.outputs = await this.processOutputs(q.outputs);
    let P = { ...q, id: $18 };
    if (!this._filterForSampling([P], true).length) return;
    if (this.autoBatchTracing && P.trace_id !== void 0 && P.dotted_order !== void 0) {
      let O = this._cloneCurrentOTELContext();
      if (q.end_time !== void 0 && P.parent_run_id === void 0 && this.blockOnRootRunFinalization && !this.manualFlushMode) {
        await this.processRunOperation({ action: "update", item: P, otelContext: O, apiKey: K == null ? void 0 : K.apiKey, apiUrl: K == null ? void 0 : K.apiUrl }).catch(console.error);
        return;
      } else this.processRunOperation({ action: "update", item: P, otelContext: O, apiKey: K == null ? void 0 : K.apiKey, apiUrl: K == null ? void 0 : K.apiUrl }).catch(console.error);
      return;
    }
    let _ = { ...this.headers, "Content-Type": "application/json" };
    if ((K == null ? void 0 : K.apiKey) !== void 0) _["x-api-key"] = K.apiKey;
    if ((K == null ? void 0 : K.workspaceId) !== void 0) _["x-tenant-id"] = K.workspaceId;
    let Y = iq(q, `Serializing payload to update run with id: ${$18}`);
    await this.caller.call(async () => {
      let O = await this._fetch(`${(K == null ? void 0 : K.apiUrl) ?? this.apiUrl}/runs/${$18}`, { method: "PATCH", headers: _, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions, body: Y });
      return await $6(O, "update run", true), O;
    });
  }
  async readRun($18, { loadChildRuns: q } = { loadChildRuns: false }) {
    O6($18);
    let K = await this._get(`/runs/${$18}`);
    if (q) K = await this._loadChildRuns(K);
    return K;
  }
  async getRunUrl({ runId: $18, run: q, projectOpts: K }) {
    if (q !== void 0) {
      let P;
      if (q.session_id) P = q.session_id;
      else if (K == null ? void 0 : K.projectName) P = (await this.readProject({ projectName: K == null ? void 0 : K.projectName })).id;
      else if (K == null ? void 0 : K.projectId) P = K == null ? void 0 : K.projectId;
      else P = (await this.readProject({ projectName: l6("PROJECT") || "default" })).id;
      let _ = await this._getTenantId();
      return `${this.getHostUrl()}/o/${_}/projects/p/${P}/r/${q.id}?poll=true`;
    } else if ($18 !== void 0) {
      let P = await this.readRun($18);
      if (!P.app_path) throw Error(`Run ${$18} has no app_path`);
      return `${this.getHostUrl()}${P.app_path}`;
    } else throw Error("Must provide either runId or run");
  }
  async _loadChildRuns($18) {
    var _a2;
    let q = await wR(this.listRuns({ isRoot: false, projectId: $18.session_id, traceId: $18.trace_id })), K = {}, P = {};
    q.sort((_, Y) => ((_ == null ? void 0 : _.dotted_order) ?? "").localeCompare((Y == null ? void 0 : Y.dotted_order) ?? ""));
    for (let _ of q) {
      if (_.parent_run_id === null || _.parent_run_id === void 0) throw Error(`Child run ${_.id} has no parent`);
      if (((_a2 = _.dotted_order) == null ? void 0 : _a2.startsWith($18.dotted_order ?? "")) && _.id !== $18.id) {
        if (!(_.parent_run_id in K)) K[_.parent_run_id] = [];
        K[_.parent_run_id].push(_), P[_.id] = _;
      }
    }
    $18.child_runs = K[$18.id] || [];
    for (let _ in K) if (_ !== $18.id) P[_].child_runs = K[_];
    return $18;
  }
  async *listRuns($18) {
    let { projectId: q, projectName: K, parentRunId: P, traceId: _, referenceExampleId: Y, startTime: O, executionOrder: z, isRoot: J, runType: T, error: X, id: f, query: V, filter: M, traceFilter: N, treeFilter: h, limit: E, select: I, order: D } = $18, g = [];
    if (q) g = Array.isArray(q) ? q : [q];
    if (K) {
      let n = Array.isArray(K) ? K : [K], s = await Promise.all(n.map((q$) => this.readProject({ projectName: q$ }).then((c) => c.id)));
      g.push(...s);
    }
    let b = ["app_path", "completion_cost", "completion_tokens", "dotted_order", "end_time", "error", "events", "extra", "feedback_stats", "first_token_time", "id", "inputs", "name", "outputs", "parent_run_id", "parent_run_ids", "prompt_cost", "prompt_tokens", "reference_example_id", "run_type", "session_id", "start_time", "status", "tags", "total_cost", "total_tokens", "trace_id"], y = { session: g.length ? g : null, run_type: T, reference_example: Y, query: V, filter: M, trace_filter: N, tree_filter: h, execution_order: z, parent_run: P, start_time: O ? O.toISOString() : null, error: X, id: f, limit: E, trace: _, select: I ? I : b, is_root: J, order: D };
    if (y.select.includes("child_run_ids")) Y_("Deprecated: 'child_run_ids' in the listRuns select parameter is deprecated and will be removed in a future version.");
    let p = 0;
    for await (let n of this._getCursorPaginatedList("/runs/query", y)) if (E) {
      if (p >= E) break;
      if (n.length + p > E) {
        yield* n.slice(0, E - p);
        break;
      }
      p += n.length, yield* n;
    } else yield* n;
  }
  async *listGroupRuns($18) {
    let { projectId: q, projectName: K, groupBy: P, filter: _, startTime: Y, endTime: O, limit: z, offset: J } = $18, X = { session_id: q || (await this.readProject({ projectName: K })).id, group_by: P, filter: _, start_time: Y ? Y.toISOString() : null, end_time: O ? O.toISOString() : null, limit: Number(z) || 100 }, f = Number(J) || 0, V = "/runs/group", M = `${this.apiUrl}${V}`;
    while (true) {
      let N = { ...X, offset: f }, h = Object.fromEntries(Object.entries(N).filter(([y, p]) => p !== void 0)), E = JSON.stringify(h), D = await (await this.caller.call(async () => {
        let y = await this._fetch(M, { method: "POST", headers: { ...this.headers, "Content-Type": "application/json" }, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions, body: E });
        return await $6(y, `Failed to fetch ${V}`), y;
      })).json(), { groups: g, total: b } = D;
      if (g.length === 0) break;
      for (let y of g) yield y;
      if (f += g.length, f >= b) break;
    }
  }
  async getRunStats({ id: $18, trace: q, parentRun: K, runType: P, projectNames: _, projectIds: Y, referenceExampleIds: O, startTime: z, endTime: J, error: T, query: X, filter: f, traceFilter: V, treeFilter: M, isRoot: N, dataSourceType: h }) {
    let E = Y || [];
    if (_) E = [...Y || [], ...await Promise.all(_.map((p) => this.readProject({ projectName: p }).then((n) => n.id)))];
    let D = Object.fromEntries(Object.entries({ id: $18, trace: q, parent_run: K, run_type: P, session: E, reference_example: O, start_time: z, end_time: J, error: T, query: X, filter: f, trace_filter: V, tree_filter: M, is_root: N, data_source_type: h }).filter(([p, n]) => n !== void 0)), g = JSON.stringify(D);
    return await (await this.caller.call(async () => {
      let p = await this._fetch(`${this.apiUrl}/runs/stats`, { method: "POST", headers: { ...this.headers, "Content-Type": "application/json" }, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions, body: g });
      return await $6(p, "get run stats"), p;
    })).json();
  }
  async shareRun($18, { shareId: q } = {}) {
    let K = { run_id: $18, share_token: q || O_() };
    O6($18);
    let P = JSON.stringify(K), Y = await (await this.caller.call(async () => {
      let O = await this._fetch(`${this.apiUrl}/runs/${$18}/share`, { method: "PUT", headers: this.headers, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions, body: P });
      return await $6(O, "share run"), O;
    })).json();
    if (Y === null || !("share_token" in Y)) throw Error("Invalid response from server");
    return `${this.getHostUrl()}/public/${Y.share_token}/r`;
  }
  async unshareRun($18) {
    O6($18), await this.caller.call(async () => {
      let q = await this._fetch(`${this.apiUrl}/runs/${$18}/share`, { method: "DELETE", headers: this.headers, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions });
      return await $6(q, "unshare run", true), q;
    });
  }
  async readRunSharedLink($18) {
    O6($18);
    let K = await (await this.caller.call(async () => {
      let P = await this._fetch(`${this.apiUrl}/runs/${$18}/share`, { method: "GET", headers: this.headers, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions });
      return await $6(P, "read run shared link"), P;
    })).json();
    if (K === null || !("share_token" in K)) return;
    return `${this.getHostUrl()}/public/${K.share_token}/r`;
  }
  async listSharedRuns($18, { runIds: q } = {}) {
    let K = new URLSearchParams({ share_token: $18 });
    if (q !== void 0) for (let Y of q) K.append("id", Y);
    return O6($18), await (await this.caller.call(async () => {
      let Y = await this._fetch(`${this.apiUrl}/public/${$18}/runs${K}`, { method: "GET", headers: this.headers, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions });
      return await $6(Y, "list shared runs"), Y;
    })).json();
  }
  async readDatasetSharedSchema($18, q) {
    if (!$18 && !q) throw Error("Either datasetId or datasetName must be given");
    if (!$18) $18 = (await this.readDataset({ datasetName: q })).id;
    O6($18);
    let P = await (await this.caller.call(async () => {
      let _ = await this._fetch(`${this.apiUrl}/datasets/${$18}/share`, { method: "GET", headers: this.headers, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions });
      return await $6(_, "read dataset shared schema"), _;
    })).json();
    return P.url = `${this.getHostUrl()}/public/${P.share_token}/d`, P;
  }
  async shareDataset($18, q) {
    if (!$18 && !q) throw Error("Either datasetId or datasetName must be given");
    if (!$18) $18 = (await this.readDataset({ datasetName: q })).id;
    let K = { dataset_id: $18 };
    O6($18);
    let P = JSON.stringify(K), Y = await (await this.caller.call(async () => {
      let O = await this._fetch(`${this.apiUrl}/datasets/${$18}/share`, { method: "PUT", headers: this.headers, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions, body: P });
      return await $6(O, "share dataset"), O;
    })).json();
    return Y.url = `${this.getHostUrl()}/public/${Y.share_token}/d`, Y;
  }
  async unshareDataset($18) {
    O6($18), await this.caller.call(async () => {
      let q = await this._fetch(`${this.apiUrl}/datasets/${$18}/share`, { method: "DELETE", headers: this.headers, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions });
      return await $6(q, "unshare dataset", true), q;
    });
  }
  async readSharedDataset($18) {
    return O6($18), await (await this.caller.call(async () => {
      let P = await this._fetch(`${this.apiUrl}/public/${$18}/datasets`, { method: "GET", headers: this.headers, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions });
      return await $6(P, "read shared dataset"), P;
    })).json();
  }
  async listSharedExamples($18, q) {
    let K = {};
    if (q == null ? void 0 : q.exampleIds) K.id = q.exampleIds;
    let P = new URLSearchParams();
    Object.entries(K).forEach(([O, z]) => {
      if (Array.isArray(z)) z.forEach((J) => P.append(O, J));
      else P.append(O, z);
    });
    let _ = await this.caller.call(async () => {
      let O = await this._fetch(`${this.apiUrl}/public/${$18}/examples?${P.toString()}`, { method: "GET", headers: this.headers, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions });
      return await $6(O, "list shared examples"), O;
    }), Y = await _.json();
    if (!_.ok) {
      if ("detail" in Y) throw Error(`Failed to list shared examples.
Status: ${_.status}
Message: ${Array.isArray(Y.detail) ? Y.detail.join(`
`) : "Unspecified error"}`);
      throw Error(`Failed to list shared examples: ${_.status} ${_.statusText}`);
    }
    return Y.map((O) => ({ ...O, _hostUrl: this.getHostUrl() }));
  }
  async createProject({ projectName: $18, description: q = null, metadata: K = null, upsert: P = false, projectExtra: _ = null, referenceDatasetId: Y = null }) {
    let O = P ? "?upsert=true" : "", z = `${this.apiUrl}/sessions${O}`, J = _ || {};
    if (K) J.metadata = K;
    let T = { name: $18, extra: J, description: q };
    if (Y !== null) T.reference_dataset_id = Y;
    let X = JSON.stringify(T);
    return await (await this.caller.call(async () => {
      let M = await this._fetch(z, { method: "POST", headers: { ...this.headers, "Content-Type": "application/json" }, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions, body: X });
      return await $6(M, "create project"), M;
    })).json();
  }
  async updateProject($18, { name: q = null, description: K = null, metadata: P = null, projectExtra: _ = null, endTime: Y = null }) {
    let O = `${this.apiUrl}/sessions/${$18}`, z = _;
    if (P) z = { ...z || {}, metadata: P };
    let J = JSON.stringify({ name: q, extra: z, description: K, end_time: Y ? new Date(Y).toISOString() : null });
    return await (await this.caller.call(async () => {
      let f = await this._fetch(O, { method: "PATCH", headers: { ...this.headers, "Content-Type": "application/json" }, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions, body: J });
      return await $6(f, "update project"), f;
    })).json();
  }
  async hasProject({ projectId: $18, projectName: q }) {
    let K = "/sessions", P = new URLSearchParams();
    if ($18 !== void 0 && q !== void 0) throw Error("Must provide either projectName or projectId, not both");
    else if ($18 !== void 0) O6($18), K += `/${$18}`;
    else if (q !== void 0) P.append("name", q);
    else throw Error("Must provide projectName or projectId");
    let _ = await this.caller.call(async () => {
      let Y = await this._fetch(`${this.apiUrl}${K}?${P}`, { method: "GET", headers: this.headers, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions });
      return await $6(Y, "has project"), Y;
    });
    try {
      let Y = await _.json();
      if (!_.ok) return false;
      if (Array.isArray(Y)) return Y.length > 0;
      return true;
    } catch (Y) {
      return false;
    }
  }
  async readProject({ projectId: $18, projectName: q, includeStats: K }) {
    let P = "/sessions", _ = new URLSearchParams();
    if ($18 !== void 0 && q !== void 0) throw Error("Must provide either projectName or projectId, not both");
    else if ($18 !== void 0) O6($18), P += `/${$18}`;
    else if (q !== void 0) _.append("name", q);
    else throw Error("Must provide projectName or projectId");
    if (K !== void 0) _.append("include_stats", K.toString());
    let Y = await this._get(P, _), O;
    if (Array.isArray(Y)) {
      if (Y.length === 0) throw Error(`Project[id=${$18}, name=${q}] not found`);
      O = Y[0];
    } else O = Y;
    return O;
  }
  async getProjectUrl({ projectId: $18, projectName: q }) {
    if ($18 === void 0 && q === void 0) throw Error("Must provide either projectName or projectId");
    let K = await this.readProject({ projectId: $18, projectName: q }), P = await this._getTenantId();
    return `${this.getHostUrl()}/o/${P}/projects/p/${K.id}`;
  }
  async getDatasetUrl({ datasetId: $18, datasetName: q }) {
    if ($18 === void 0 && q === void 0) throw Error("Must provide either datasetName or datasetId");
    let K = await this.readDataset({ datasetId: $18, datasetName: q }), P = await this._getTenantId();
    return `${this.getHostUrl()}/o/${P}/datasets/${K.id}`;
  }
  async _getTenantId() {
    if (this._tenantId !== null) return this._tenantId;
    let $18 = new URLSearchParams({ limit: "1" });
    for await (let q of this._getPaginated("/sessions", $18)) return this._tenantId = q[0].tenant_id, q[0].tenant_id;
    throw Error("No projects found to resolve tenant.");
  }
  async *listProjects({ projectIds: $18, name: q, nameContains: K, referenceDatasetId: P, referenceDatasetName: _, includeStats: Y, datasetVersion: O, referenceFree: z, metadata: J } = {}) {
    let T = new URLSearchParams();
    if ($18 !== void 0) for (let X of $18) T.append("id", X);
    if (q !== void 0) T.append("name", q);
    if (K !== void 0) T.append("name_contains", K);
    if (P !== void 0) T.append("reference_dataset", P);
    else if (_ !== void 0) {
      let X = await this.readDataset({ datasetName: _ });
      T.append("reference_dataset", X.id);
    }
    if (Y !== void 0) T.append("include_stats", Y.toString());
    if (O !== void 0) T.append("dataset_version", O);
    if (z !== void 0) T.append("reference_free", z.toString());
    if (J !== void 0) T.append("metadata", JSON.stringify(J));
    for await (let X of this._getPaginated("/sessions", T)) yield* X;
  }
  async deleteProject({ projectId: $18, projectName: q }) {
    let K;
    if ($18 === void 0 && q === void 0) throw Error("Must provide projectName or projectId");
    else if ($18 !== void 0 && q !== void 0) throw Error("Must provide either projectName or projectId, not both");
    else if ($18 === void 0) K = (await this.readProject({ projectName: q })).id;
    else K = $18;
    O6(K), await this.caller.call(async () => {
      let P = await this._fetch(`${this.apiUrl}/sessions/${K}`, { method: "DELETE", headers: this.headers, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions });
      return await $6(P, `delete session ${K} (${q})`, true), P;
    });
  }
  async uploadCsv({ csvFile: $18, fileName: q, inputKeys: K, outputKeys: P, description: _, dataType: Y, name: O }) {
    let z = `${this.apiUrl}/datasets/upload`, J = new FormData();
    if (J.append("file", $18, q), K.forEach((f) => {
      J.append("input_keys", f);
    }), P.forEach((f) => {
      J.append("output_keys", f);
    }), _) J.append("description", _);
    if (Y) J.append("data_type", Y);
    if (O) J.append("name", O);
    return await (await this.caller.call(async () => {
      let f = await this._fetch(z, { method: "POST", headers: this.headers, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions, body: J });
      return await $6(f, "upload CSV"), f;
    })).json();
  }
  async createDataset($18, { description: q, dataType: K, inputsSchema: P, outputsSchema: _, metadata: Y } = {}) {
    let O = { name: $18, description: q, extra: Y ? { metadata: Y } : void 0 };
    if (K) O.data_type = K;
    if (P) O.inputs_schema_definition = P;
    if (_) O.outputs_schema_definition = _;
    let z = JSON.stringify(O);
    return await (await this.caller.call(async () => {
      let X = await this._fetch(`${this.apiUrl}/datasets`, { method: "POST", headers: { ...this.headers, "Content-Type": "application/json" }, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions, body: z });
      return await $6(X, "create dataset"), X;
    })).json();
  }
  async readDataset({ datasetId: $18, datasetName: q }) {
    let K = "/datasets", P = new URLSearchParams({ limit: "1" });
    if ($18 && q) throw Error("Must provide either datasetName or datasetId, not both");
    else if ($18) O6($18), K += `/${$18}`;
    else if (q) P.append("name", q);
    else throw Error("Must provide datasetName or datasetId");
    let _ = await this._get(K, P), Y;
    if (Array.isArray(_)) {
      if (_.length === 0) throw Error(`Dataset[id=${$18}, name=${q}] not found`);
      Y = _[0];
    } else Y = _;
    return Y;
  }
  async hasDataset({ datasetId: $18, datasetName: q }) {
    try {
      return await this.readDataset({ datasetId: $18, datasetName: q }), true;
    } catch (K) {
      if (K instanceof Error && K.message.toLocaleLowerCase().includes("not found")) return false;
      throw K;
    }
  }
  async diffDatasetVersions({ datasetId: $18, datasetName: q, fromVersion: K, toVersion: P }) {
    let _ = $18;
    if (_ === void 0 && q === void 0) throw Error("Must provide either datasetName or datasetId");
    else if (_ !== void 0 && q !== void 0) throw Error("Must provide either datasetName or datasetId, not both");
    else if (_ === void 0) _ = (await this.readDataset({ datasetName: q })).id;
    let Y = new URLSearchParams({ from_version: typeof K === "string" ? K : K.toISOString(), to_version: typeof P === "string" ? P : P.toISOString() });
    return await this._get(`/datasets/${_}/versions/diff`, Y);
  }
  async readDatasetOpenaiFinetuning({ datasetId: $18, datasetName: q }) {
    if ($18 !== void 0) ;
    else if (q !== void 0) $18 = (await this.readDataset({ datasetName: q })).id;
    else throw Error("Must provide either datasetName or datasetId");
    return (await (await this._getResponse(`/datasets/${$18}/openai_ft`)).text()).trim().split(`
`).map((O) => JSON.parse(O));
  }
  async *listDatasets({ limit: $18 = 100, offset: q = 0, datasetIds: K, datasetName: P, datasetNameContains: _, metadata: Y } = {}) {
    let z = new URLSearchParams({ limit: $18.toString(), offset: q.toString() });
    if (K !== void 0) for (let J of K) z.append("id", J);
    if (P !== void 0) z.append("name", P);
    if (_ !== void 0) z.append("name_contains", _);
    if (Y !== void 0) z.append("metadata", JSON.stringify(Y));
    for await (let J of this._getPaginated("/datasets", z)) yield* J;
  }
  async updateDataset($18) {
    let { datasetId: q, datasetName: K, ...P } = $18;
    if (!q && !K) throw Error("Must provide either datasetName or datasetId");
    let _ = q ?? (await this.readDataset({ datasetName: K })).id;
    O6(_);
    let Y = JSON.stringify(P);
    return await (await this.caller.call(async () => {
      let z = await this._fetch(`${this.apiUrl}/datasets/${_}`, { method: "PATCH", headers: { ...this.headers, "Content-Type": "application/json" }, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions, body: Y });
      return await $6(z, "update dataset"), z;
    })).json();
  }
  async updateDatasetTag($18) {
    let { datasetId: q, datasetName: K, asOf: P, tag: _ } = $18;
    if (!q && !K) throw Error("Must provide either datasetName or datasetId");
    let Y = q ?? (await this.readDataset({ datasetName: K })).id;
    O6(Y);
    let O = JSON.stringify({ as_of: typeof P === "string" ? P : P.toISOString(), tag: _ });
    await this.caller.call(async () => {
      let z = await this._fetch(`${this.apiUrl}/datasets/${Y}/tags`, { method: "PUT", headers: { ...this.headers, "Content-Type": "application/json" }, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions, body: O });
      return await $6(z, "update dataset tags", true), z;
    });
  }
  async deleteDataset({ datasetId: $18, datasetName: q }) {
    let K = "/datasets", P = $18;
    if ($18 !== void 0 && q !== void 0) throw Error("Must provide either datasetName or datasetId, not both");
    else if (q !== void 0) P = (await this.readDataset({ datasetName: q })).id;
    if (P !== void 0) O6(P), K += `/${P}`;
    else throw Error("Must provide datasetName or datasetId");
    await this.caller.call(async () => {
      let _ = await this._fetch(this.apiUrl + K, { method: "DELETE", headers: this.headers, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions });
      return await $6(_, `delete ${K}`, true), _;
    });
  }
  async indexDataset({ datasetId: $18, datasetName: q, tag: K }) {
    let P = $18;
    if (!P && !q) throw Error("Must provide either datasetName or datasetId");
    else if (P && q) throw Error("Must provide either datasetName or datasetId, not both");
    else if (!P) P = (await this.readDataset({ datasetName: q })).id;
    O6(P);
    let Y = JSON.stringify({ tag: K });
    await (await this.caller.call(async () => {
      let z = await this._fetch(`${this.apiUrl}/datasets/${P}/index`, { method: "POST", headers: { ...this.headers, "Content-Type": "application/json" }, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions, body: Y });
      return await $6(z, "index dataset"), z;
    })).json();
  }
  async similarExamples($18, q, K, { filter: P } = {}) {
    let _ = { limit: K, inputs: $18 };
    if (P !== void 0) _.filter = P;
    O6(q);
    let Y = JSON.stringify(_);
    return (await (await this.caller.call(async () => {
      let J = await this._fetch(`${this.apiUrl}/datasets/${q}/search`, { headers: { ...this.headers, "Content-Type": "application/json" }, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions, method: "POST", body: Y });
      return await $6(J, "fetch similar examples"), J;
    })).json()).examples;
  }
  async createExample($18, q, K) {
    var _a2;
    if (UZ($18)) {
      if (q !== void 0 || K !== void 0) throw Error("Cannot provide outputs or options when using ExampleCreate object");
    }
    let P = q ? K == null ? void 0 : K.datasetId : $18.dataset_id, _ = q ? K == null ? void 0 : K.datasetName : $18.dataset_name;
    if (P === void 0 && _ === void 0) throw Error("Must provide either datasetName or datasetId");
    else if (P !== void 0 && _ !== void 0) throw Error("Must provide either datasetName or datasetId, not both");
    else if (P === void 0) P = (await this.readDataset({ datasetName: _ })).id;
    let Y = (q ? K == null ? void 0 : K.createdAt : $18.created_at) || /* @__PURE__ */ new Date(), O;
    if (!UZ($18)) O = { inputs: $18, outputs: q, created_at: Y == null ? void 0 : Y.toISOString(), id: K == null ? void 0 : K.exampleId, metadata: K == null ? void 0 : K.metadata, split: K == null ? void 0 : K.split, source_run_id: K == null ? void 0 : K.sourceRunId, use_source_run_io: K == null ? void 0 : K.useSourceRunIO, use_source_run_attachments: K == null ? void 0 : K.useSourceRunAttachments, attachments: K == null ? void 0 : K.attachments };
    else O = $18;
    let z = await this._uploadExamplesMultipart(P, [O]);
    return await this.readExample(((_a2 = z.example_ids) == null ? void 0 : _a2[0]) ?? O_());
  }
  async createExamples($18) {
    if (Array.isArray($18)) {
      if ($18.length === 0) return [];
      let I = $18, D = I[0].dataset_id, g = I[0].dataset_name;
      if (D === void 0 && g === void 0) throw Error("Must provide either datasetName or datasetId");
      else if (D !== void 0 && g !== void 0) throw Error("Must provide either datasetName or datasetId, not both");
      else if (D === void 0) D = (await this.readDataset({ datasetName: g })).id;
      let b = await this._uploadExamplesMultipart(D, I);
      return await Promise.all(b.example_ids.map((p) => this.readExample(p)));
    }
    let { inputs: q, outputs: K, metadata: P, splits: _, sourceRunIds: Y, useSourceRunIOs: O, useSourceRunAttachments: z, attachments: J, exampleIds: T, datasetId: X, datasetName: f } = $18;
    if (q === void 0) throw Error("Must provide inputs when using legacy parameters");
    let V = X, M = f;
    if (V === void 0 && M === void 0) throw Error("Must provide either datasetName or datasetId");
    else if (V !== void 0 && M !== void 0) throw Error("Must provide either datasetName or datasetId, not both");
    else if (V === void 0) V = (await this.readDataset({ datasetName: M })).id;
    let N = q.map((I, D) => {
      return { dataset_id: V, inputs: I, outputs: K == null ? void 0 : K[D], metadata: P == null ? void 0 : P[D], split: _ == null ? void 0 : _[D], id: T == null ? void 0 : T[D], attachments: J == null ? void 0 : J[D], source_run_id: Y == null ? void 0 : Y[D], use_source_run_io: O == null ? void 0 : O[D], use_source_run_attachments: z == null ? void 0 : z[D] };
    }), h = await this._uploadExamplesMultipart(V, N);
    return await Promise.all(h.example_ids.map((I) => this.readExample(I)));
  }
  async createLLMExample($18, q, K) {
    return this.createExample({ input: $18 }, { output: q }, K);
  }
  async createChatExample($18, q, K) {
    let P = $18.map((Y) => {
      if (OY(Y)) return YY(Y);
      return Y;
    }), _ = OY(q) ? YY(q) : q;
    return this.createExample({ input: P }, { output: _ }, K);
  }
  async readExample($18) {
    O6($18);
    let q = `/examples/${$18}`, K = await this._get(q), { attachment_urls: P, ..._ } = K, Y = _;
    if (P) Y.attachments = Object.entries(P).reduce((O, [z, J]) => {
      return O[z.slice(11)] = { presigned_url: J.presigned_url, mime_type: J.mime_type }, O;
    }, {});
    return Y;
  }
  async *listExamples({ datasetId: $18, datasetName: q, exampleIds: K, asOf: P, splits: _, inlineS3Urls: Y, metadata: O, limit: z, offset: J, filter: T, includeAttachments: X } = {}) {
    let f;
    if ($18 !== void 0 && q !== void 0) throw Error("Must provide either datasetName or datasetId, not both");
    else if ($18 !== void 0) f = $18;
    else if (q !== void 0) f = (await this.readDataset({ datasetName: q })).id;
    else throw Error("Must provide a datasetName or datasetId");
    let V = new URLSearchParams({ dataset: f }), M = P ? typeof P === "string" ? P : P == null ? void 0 : P.toISOString() : void 0;
    if (M) V.append("as_of", M);
    let N = Y ?? true;
    if (V.append("inline_s3_urls", N.toString()), K !== void 0) for (let E of K) V.append("id", E);
    if (_ !== void 0) for (let E of _) V.append("splits", E);
    if (O !== void 0) {
      let E = JSON.stringify(O);
      V.append("metadata", E);
    }
    if (z !== void 0) V.append("limit", z.toString());
    if (J !== void 0) V.append("offset", J.toString());
    if (T !== void 0) V.append("filter", T);
    if (X === true) ["attachment_urls", "outputs", "metadata"].forEach((E) => V.append("select", E));
    let h = 0;
    for await (let E of this._getPaginated("/examples", V)) {
      for (let I of E) {
        let { attachment_urls: D, ...g } = I, b = g;
        if (D) b.attachments = Object.entries(D).reduce((y, [p, n]) => {
          return y[p.slice(11)] = { presigned_url: n.presigned_url, mime_type: n.mime_type || void 0 }, y;
        }, {});
        yield b, h++;
      }
      if (z !== void 0 && h >= z) break;
    }
  }
  async deleteExample($18) {
    O6($18);
    let q = `/examples/${$18}`;
    await this.caller.call(async () => {
      let K = await this._fetch(this.apiUrl + q, { method: "DELETE", headers: this.headers, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions });
      return await $6(K, `delete ${q}`, true), K;
    });
  }
  async updateExample($18, q) {
    let K;
    if (q) K = $18;
    else K = $18.id;
    O6(K);
    let P;
    if (q) P = { id: K, ...q };
    else P = $18;
    let _;
    if (P.dataset_id !== void 0) _ = P.dataset_id;
    else _ = (await this.readExample(K)).dataset_id;
    return this._updateExamplesMultipart(_, [P]);
  }
  async updateExamples($18) {
    let q;
    if ($18[0].dataset_id === void 0) q = (await this.readExample($18[0].id)).dataset_id;
    else q = $18[0].dataset_id;
    return this._updateExamplesMultipart(q, $18);
  }
  async readDatasetVersion({ datasetId: $18, datasetName: q, asOf: K, tag: P }) {
    let _;
    if (!$18) _ = (await this.readDataset({ datasetName: q })).id;
    else _ = $18;
    if (O6(_), K && P || !K && !P) throw Error("Exactly one of asOf and tag must be specified.");
    let Y = new URLSearchParams();
    if (K !== void 0) Y.append("as_of", typeof K === "string" ? K : K.toISOString());
    if (P !== void 0) Y.append("tag", P);
    return await (await this.caller.call(async () => {
      let z = await this._fetch(`${this.apiUrl}/datasets/${_}/version?${Y.toString()}`, { method: "GET", headers: { ...this.headers }, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions });
      return await $6(z, "read dataset version"), z;
    })).json();
  }
  async listDatasetSplits({ datasetId: $18, datasetName: q, asOf: K }) {
    let P;
    if ($18 === void 0 && q === void 0) throw Error("Must provide dataset name or ID");
    else if ($18 !== void 0 && q !== void 0) throw Error("Must provide either datasetName or datasetId, not both");
    else if ($18 === void 0) P = (await this.readDataset({ datasetName: q })).id;
    else P = $18;
    O6(P);
    let _ = new URLSearchParams(), Y = K ? typeof K === "string" ? K : K == null ? void 0 : K.toISOString() : void 0;
    if (Y) _.append("as_of", Y);
    return await this._get(`/datasets/${P}/splits`, _);
  }
  async updateDatasetSplits({ datasetId: $18, datasetName: q, splitName: K, exampleIds: P, remove: _ = false }) {
    let Y;
    if ($18 === void 0 && q === void 0) throw Error("Must provide dataset name or ID");
    else if ($18 !== void 0 && q !== void 0) throw Error("Must provide either datasetName or datasetId, not both");
    else if ($18 === void 0) Y = (await this.readDataset({ datasetName: q })).id;
    else Y = $18;
    O6(Y);
    let O = { split_name: K, examples: P.map((J) => {
      return O6(J), J;
    }), remove: _ }, z = JSON.stringify(O);
    await this.caller.call(async () => {
      let J = await this._fetch(`${this.apiUrl}/datasets/${Y}/splits`, { method: "PUT", headers: { ...this.headers, "Content-Type": "application/json" }, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions, body: z });
      return await $6(J, "update dataset splits", true), J;
    });
  }
  async evaluateRun($18, q, { sourceInfo: K, loadChildRuns: P, referenceExample: _ } = { loadChildRuns: false }) {
    Y_("This method is deprecated and will be removed in future LangSmith versions, use `evaluate` from `langsmith/evaluation` instead.");
    let Y;
    if (typeof $18 === "string") Y = await this.readRun($18, { loadChildRuns: P });
    else if (typeof $18 === "object" && "id" in $18) Y = $18;
    else throw Error(`Invalid run type: ${typeof $18}`);
    if (Y.reference_example_id !== null && Y.reference_example_id !== void 0) _ = await this.readExample(Y.reference_example_id);
    let O = await q.evaluateRun(Y, _), [z, J] = await this._logEvaluationFeedback(O, Y, K);
    return J[0];
  }
  async createFeedback($18, q, { score: K, value: P, correction: _, comment: Y, sourceInfo: O, feedbackSourceType: z = "api", sourceRunId: J, feedbackId: T, feedbackConfig: X, projectId: f, comparativeExperimentId: V }) {
    var _a2;
    if (!$18 && !f) throw Error("One of runId or projectId must be provided");
    if ($18 && f) throw Error("Only one of runId or projectId can be provided");
    let M = { type: z ?? "api", metadata: O ?? {} };
    if (J !== void 0 && (M == null ? void 0 : M.metadata) !== void 0 && !M.metadata.__run) M.metadata.__run = { run_id: J };
    if ((M == null ? void 0 : M.metadata) !== void 0 && ((_a2 = M.metadata.__run) == null ? void 0 : _a2.run_id) !== void 0) O6(M.metadata.__run.run_id);
    let N = { id: T ?? O_(), run_id: $18, key: q, score: BZ(K), value: P, correction: _, comment: Y, feedback_source: M, comparative_experiment_id: V, feedbackConfig: X, session_id: f }, h = JSON.stringify(N), E = `${this.apiUrl}/feedback`;
    return await this.caller.call(async () => {
      let I = await this._fetch(E, { method: "POST", headers: { ...this.headers, "Content-Type": "application/json" }, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions, body: h });
      return await $6(I, "create feedback", true), I;
    }), N;
  }
  async updateFeedback($18, { score: q, value: K, correction: P, comment: _ }) {
    let Y = {};
    if (q !== void 0 && q !== null) Y.score = BZ(q);
    if (K !== void 0 && K !== null) Y.value = K;
    if (P !== void 0 && P !== null) Y.correction = P;
    if (_ !== void 0 && _ !== null) Y.comment = _;
    O6($18);
    let O = JSON.stringify(Y);
    await this.caller.call(async () => {
      let z = await this._fetch(`${this.apiUrl}/feedback/${$18}`, { method: "PATCH", headers: { ...this.headers, "Content-Type": "application/json" }, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions, body: O });
      return await $6(z, "update feedback", true), z;
    });
  }
  async readFeedback($18) {
    O6($18);
    let q = `/feedback/${$18}`;
    return await this._get(q);
  }
  async deleteFeedback($18) {
    O6($18);
    let q = `/feedback/${$18}`;
    await this.caller.call(async () => {
      let K = await this._fetch(this.apiUrl + q, { method: "DELETE", headers: this.headers, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions });
      return await $6(K, `delete ${q}`, true), K;
    });
  }
  async *listFeedback({ runIds: $18, feedbackKeys: q, feedbackSourceTypes: K } = {}) {
    let P = new URLSearchParams();
    if ($18) for (let _ of $18) O6(_), P.append("run", _);
    if (q) for (let _ of q) P.append("key", _);
    if (K) for (let _ of K) P.append("source", _);
    for await (let _ of this._getPaginated("/feedback", P)) yield* _;
  }
  async createPresignedFeedbackToken($18, q, { expiration: K, feedbackConfig: P } = {}) {
    let _ = { run_id: $18, feedback_key: q, feedback_config: P };
    if (K) {
      if (typeof K === "string") _.expires_at = K;
      else if ((K == null ? void 0 : K.hours) || (K == null ? void 0 : K.minutes) || (K == null ? void 0 : K.days)) _.expires_in = K;
    } else _.expires_in = { hours: 3 };
    let Y = JSON.stringify(_);
    return await (await this.caller.call(async () => {
      let z = await this._fetch(`${this.apiUrl}/feedback/tokens`, { method: "POST", headers: { ...this.headers, "Content-Type": "application/json" }, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions, body: Y });
      return await $6(z, "create presigned feedback token"), z;
    })).json();
  }
  async createComparativeExperiment({ name: $18, experimentIds: q, referenceDatasetId: K, createdAt: P, description: _, metadata: Y, id: O }) {
    var _a2;
    if (q.length === 0) throw Error("At least one experiment is required");
    if (!K) K = (await this.readProject({ projectId: q[0] })).reference_dataset_id;
    if (!K == null) throw Error("A reference dataset is required");
    let z = { id: O, name: $18, experiment_ids: q, reference_dataset_id: K, description: _, created_at: (_a2 = P ?? /* @__PURE__ */ new Date()) == null ? void 0 : _a2.toISOString(), extra: {} };
    if (Y) z.extra.metadata = Y;
    let J = JSON.stringify(z);
    return (await this.caller.call(async () => {
      let X = await this._fetch(`${this.apiUrl}/datasets/comparative`, { method: "POST", headers: { ...this.headers, "Content-Type": "application/json" }, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions, body: J });
      return await $6(X, "create comparative experiment"), X;
    })).json();
  }
  async *listPresignedFeedbackTokens($18) {
    O6($18);
    let q = new URLSearchParams({ run_id: $18 });
    for await (let K of this._getPaginated("/feedback/tokens", q)) yield* K;
  }
  _selectEvalResults($18) {
    let q;
    if ("results" in $18) q = $18.results;
    else if (Array.isArray($18)) q = $18;
    else q = [$18];
    return q;
  }
  async _logEvaluationFeedback($18, q, K) {
    let P = this._selectEvalResults($18), _ = [];
    for (let Y of P) {
      let O = K || {};
      if (Y.evaluatorInfo) O = { ...Y.evaluatorInfo, ...O };
      let z = null;
      if (Y.targetRunId) z = Y.targetRunId;
      else if (q) z = q.id;
      _.push(await this.createFeedback(z, Y.key, { score: Y.score, value: Y.value, comment: Y.comment, correction: Y.correction, sourceInfo: O, sourceRunId: Y.sourceRunId, feedbackConfig: Y.feedbackConfig, feedbackSourceType: "model" }));
    }
    return [P, _];
  }
  async logEvaluationFeedback($18, q, K) {
    let [P] = await this._logEvaluationFeedback($18, q, K);
    return P;
  }
  async *listAnnotationQueues($18 = {}) {
    let { queueIds: q, name: K, nameContains: P, limit: _ } = $18, Y = new URLSearchParams();
    if (q) q.forEach((z, J) => {
      O6(z, `queueIds[${J}]`), Y.append("ids", z);
    });
    if (K) Y.append("name", K);
    if (P) Y.append("name_contains", P);
    Y.append("limit", (_ !== void 0 ? Math.min(_, 100) : 100).toString());
    let O = 0;
    for await (let z of this._getPaginated("/annotation-queues", Y)) if (yield* z, O++, _ !== void 0 && O >= _) break;
  }
  async createAnnotationQueue($18) {
    let { name: q, description: K, queueId: P, rubricInstructions: _ } = $18, Y = { name: q, description: K, id: P || O_(), rubric_instructions: _ }, O = JSON.stringify(Object.fromEntries(Object.entries(Y).filter(([J, T]) => T !== void 0)));
    return (await this.caller.call(async () => {
      let J = await this._fetch(`${this.apiUrl}/annotation-queues`, { method: "POST", headers: { ...this.headers, "Content-Type": "application/json" }, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions, body: O });
      return await $6(J, "create annotation queue"), J;
    })).json();
  }
  async readAnnotationQueue($18) {
    return (await this.caller.call(async () => {
      let K = await this._fetch(`${this.apiUrl}/annotation-queues/${O6($18, "queueId")}`, { method: "GET", headers: this.headers, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions });
      return await $6(K, "read annotation queue"), K;
    })).json();
  }
  async updateAnnotationQueue($18, q) {
    let { name: K, description: P, rubricInstructions: _ } = q, Y = JSON.stringify({ name: K, description: P, rubric_instructions: _ });
    await this.caller.call(async () => {
      let O = await this._fetch(`${this.apiUrl}/annotation-queues/${O6($18, "queueId")}`, { method: "PATCH", headers: { ...this.headers, "Content-Type": "application/json" }, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions, body: Y });
      return await $6(O, "update annotation queue", true), O;
    });
  }
  async deleteAnnotationQueue($18) {
    await this.caller.call(async () => {
      let q = await this._fetch(`${this.apiUrl}/annotation-queues/${O6($18, "queueId")}`, { method: "DELETE", headers: { ...this.headers, Accept: "application/json" }, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions });
      return await $6(q, "delete annotation queue", true), q;
    });
  }
  async addRunsToAnnotationQueue($18, q) {
    let K = JSON.stringify(q.map((P, _) => O6(P, `runIds[${_}]`).toString()));
    await this.caller.call(async () => {
      let P = await this._fetch(`${this.apiUrl}/annotation-queues/${O6($18, "queueId")}/runs`, { method: "POST", headers: { ...this.headers, "Content-Type": "application/json" }, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions, body: K });
      return await $6(P, "add runs to annotation queue", true), P;
    });
  }
  async getRunFromAnnotationQueue($18, q) {
    let K = `/annotation-queues/${O6($18, "queueId")}/run`;
    return (await this.caller.call(async () => {
      let _ = await this._fetch(`${this.apiUrl}${K}/${q}`, { method: "GET", headers: this.headers, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions });
      return await $6(_, "get run from annotation queue"), _;
    })).json();
  }
  async deleteRunFromAnnotationQueue($18, q) {
    await this.caller.call(async () => {
      let K = await this._fetch(`${this.apiUrl}/annotation-queues/${O6($18, "queueId")}/runs/${O6(q, "queueRunId")}`, { method: "DELETE", headers: { ...this.headers, Accept: "application/json" }, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions });
      return await $6(K, "delete run from annotation queue", true), K;
    });
  }
  async getSizeFromAnnotationQueue($18) {
    return (await this.caller.call(async () => {
      let K = await this._fetch(`${this.apiUrl}/annotation-queues/${O6($18, "queueId")}/size`, { method: "GET", headers: this.headers, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions });
      return await $6(K, "get size from annotation queue"), K;
    })).json();
  }
  async _currentTenantIsOwner($18) {
    let q = await this._getSettings();
    return $18 == "-" || q.tenant_handle === $18;
  }
  async _ownerConflictError($18, q) {
    let K = await this._getSettings();
    return Error(`Cannot ${$18} for another tenant.

      Current tenant: ${K.tenant_handle}

      Requested tenant: ${q}`);
  }
  async _getLatestCommitHash($18) {
    let K = await (await this.caller.call(async () => {
      let P = await this._fetch(`${this.apiUrl}/commits/${$18}/?limit=1&offset=0`, { method: "GET", headers: this.headers, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions });
      return await $6(P, "get latest commit hash"), P;
    })).json();
    if (K.commits.length === 0) return;
    return K.commits[0].commit_hash;
  }
  async _likeOrUnlikePrompt($18, q) {
    let [K, P, _] = PK($18), Y = JSON.stringify({ like: q });
    return (await this.caller.call(async () => {
      let z = await this._fetch(`${this.apiUrl}/likes/${K}/${P}`, { method: "POST", headers: { ...this.headers, "Content-Type": "application/json" }, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions, body: Y });
      return await $6(z, `${q ? "like" : "unlike"} prompt`), z;
    })).json();
  }
  async _getPromptUrl($18) {
    let [q, K, P] = PK($18);
    if (!await this._currentTenantIsOwner(q)) if (P !== "latest") return `${this.getHostUrl()}/hub/${q}/${K}/${P.substring(0, 8)}`;
    else return `${this.getHostUrl()}/hub/${q}/${K}`;
    else {
      let _ = await this._getSettings();
      if (P !== "latest") return `${this.getHostUrl()}/prompts/${K}/${P.substring(0, 8)}?organizationId=${_.id}`;
      else return `${this.getHostUrl()}/prompts/${K}?organizationId=${_.id}`;
    }
  }
  async promptExists($18) {
    return !!await this.getPrompt($18);
  }
  async likePrompt($18) {
    return this._likeOrUnlikePrompt($18, true);
  }
  async unlikePrompt($18) {
    return this._likeOrUnlikePrompt($18, false);
  }
  async *listCommits($18) {
    for await (let q of this._getPaginated(`/commits/${$18}/`, new URLSearchParams(), (K) => K.commits)) yield* q;
  }
  async *listPrompts($18) {
    let q = new URLSearchParams();
    if (q.append("sort_field", ($18 == null ? void 0 : $18.sortField) ?? "updated_at"), q.append("sort_direction", "desc"), q.append("is_archived", (!!($18 == null ? void 0 : $18.isArchived)).toString()), ($18 == null ? void 0 : $18.isPublic) !== void 0) q.append("is_public", $18.isPublic.toString());
    if ($18 == null ? void 0 : $18.query) q.append("query", $18.query);
    for await (let K of this._getPaginated("/repos", q, (P) => P.repos)) yield* K;
  }
  async getPrompt($18) {
    var _a2;
    let [q, K, P] = PK($18), Y = await ((_a2 = await this.caller.call(async () => {
      let O = await this._fetch(`${this.apiUrl}/repos/${q}/${K}`, { method: "GET", headers: this.headers, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions });
      if ((O == null ? void 0 : O.status) === 404) return null;
      return await $6(O, "get prompt"), O;
    })) == null ? void 0 : _a2.json());
    if (Y == null ? void 0 : Y.repo) return Y.repo;
    else return null;
  }
  async createPrompt($18, q) {
    let K = await this._getSettings();
    if ((q == null ? void 0 : q.isPublic) && !K.tenant_handle) throw Error(`Cannot create a public prompt without first

        creating a LangChain Hub handle.
        You can add a handle by creating a public prompt at:

        https://smith.langchain.com/prompts`);
    let [P, _, Y] = PK($18);
    if (!await this._currentTenantIsOwner(P)) throw await this._ownerConflictError("create a prompt", P);
    let O = { repo_handle: _, ...(q == null ? void 0 : q.description) && { description: q.description }, ...(q == null ? void 0 : q.readme) && { readme: q.readme }, ...(q == null ? void 0 : q.tags) && { tags: q.tags }, is_public: !!(q == null ? void 0 : q.isPublic) }, z = JSON.stringify(O), J = await this.caller.call(async () => {
      let X = await this._fetch(`${this.apiUrl}/repos/`, { method: "POST", headers: { ...this.headers, "Content-Type": "application/json" }, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions, body: z });
      return await $6(X, "create prompt"), X;
    }), { repo: T } = await J.json();
    return T;
  }
  async createCommit($18, q, K) {
    if (!await this.promptExists($18)) throw Error("Prompt does not exist, you must create it first.");
    let [P, _, Y] = PK($18), O = (K == null ? void 0 : K.parentCommitHash) === "latest" || !(K == null ? void 0 : K.parentCommitHash) ? await this._getLatestCommitHash(`${P}/${_}`) : K == null ? void 0 : K.parentCommitHash, z = { manifest: JSON.parse(JSON.stringify(q)), parent_commit: O }, J = JSON.stringify(z), X = await (await this.caller.call(async () => {
      let f = await this._fetch(`${this.apiUrl}/commits/${P}/${_}`, { method: "POST", headers: { ...this.headers, "Content-Type": "application/json" }, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions, body: J });
      return await $6(f, "create commit"), f;
    })).json();
    return this._getPromptUrl(`${P}/${_}${X.commit_hash ? `:${X.commit_hash}` : ""}`);
  }
  async updateExamplesMultipart($18, q = []) {
    return this._updateExamplesMultipart($18, q);
  }
  async _updateExamplesMultipart($18, q = []) {
    var _a2;
    if (!await this._getDatasetExamplesMultiPartSupport()) throw Error("Your LangSmith deployment does not allow using the multipart examples endpoint, please upgrade your deployment to the latest version.");
    let K = new FormData();
    for (let Y of q) {
      let O = Y.id, z = { ...Y.metadata && { metadata: Y.metadata }, ...Y.split && { split: Y.split } }, J = iq(z, `Serializing body for example with id: ${O}`), T = new Blob([J], { type: "application/json" });
      if (K.append(O, T), Y.inputs) {
        let X = iq(Y.inputs, `Serializing inputs for example with id: ${O}`), f = new Blob([X], { type: "application/json" });
        K.append(`${O}.inputs`, f);
      }
      if (Y.outputs) {
        let X = iq(Y.outputs, `Serializing outputs whle updating example with id: ${O}`), f = new Blob([X], { type: "application/json" });
        K.append(`${O}.outputs`, f);
      }
      if (Y.attachments) for (let [X, f] of Object.entries(Y.attachments)) {
        let V, M;
        if (Array.isArray(f)) [V, M] = f;
        else V = f.mimeType, M = f.data;
        let N = new Blob([M], { type: `${V}; length=${M.byteLength}` });
        K.append(`${O}.attachment.${X}`, N);
      }
      if (Y.attachments_operations) {
        let X = iq(Y.attachments_operations, `Serializing attachments while updating example with id: ${O}`), f = new Blob([X], { type: "application/json" });
        K.append(`${O}.attachments_operations`, f);
      }
    }
    let P = $18 ?? ((_a2 = q[0]) == null ? void 0 : _a2.dataset_id);
    return (await this.caller.call(async () => {
      let Y = await this._fetch(`${this.apiUrl}${this._getPlatformEndpointPath(`datasets/${P}/examples`)}`, { method: "PATCH", headers: this.headers, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions, body: K });
      return await $6(Y, "update examples"), Y;
    })).json();
  }
  async uploadExamplesMultipart($18, q = []) {
    return this._uploadExamplesMultipart($18, q);
  }
  async _uploadExamplesMultipart($18, q = []) {
    if (!await this._getDatasetExamplesMultiPartSupport()) throw Error("Your LangSmith deployment does not allow using the multipart examples endpoint, please upgrade your deployment to the latest version.");
    let K = new FormData();
    for (let _ of q) {
      let Y = (_.id ?? O_()).toString(), O = { created_at: _.created_at, ..._.metadata && { metadata: _.metadata }, ..._.split && { split: _.split }, ..._.source_run_id && { source_run_id: _.source_run_id }, ..._.use_source_run_io && { use_source_run_io: _.use_source_run_io }, ..._.use_source_run_attachments && { use_source_run_attachments: _.use_source_run_attachments } }, z = iq(O, `Serializing body for uploaded example with id: ${Y}`), J = new Blob([z], { type: "application/json" });
      if (K.append(Y, J), _.inputs) {
        let T = iq(_.inputs, `Serializing inputs for uploaded example with id: ${Y}`), X = new Blob([T], { type: "application/json" });
        K.append(`${Y}.inputs`, X);
      }
      if (_.outputs) {
        let T = iq(_.outputs, `Serializing outputs for uploaded example with id: ${Y}`), X = new Blob([T], { type: "application/json" });
        K.append(`${Y}.outputs`, X);
      }
      if (_.attachments) for (let [T, X] of Object.entries(_.attachments)) {
        let f, V;
        if (Array.isArray(X)) [f, V] = X;
        else f = X.mimeType, V = X.data;
        let M = new Blob([V], { type: `${f}; length=${V.byteLength}` });
        K.append(`${Y}.attachment.${T}`, M);
      }
    }
    return (await this.caller.call(async () => {
      let _ = await this._fetch(`${this.apiUrl}${this._getPlatformEndpointPath(`datasets/${$18}/examples`)}`, { method: "POST", headers: this.headers, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions, body: K });
      return await $6(_, "upload examples"), _;
    })).json();
  }
  async updatePrompt($18, q) {
    if (!await this.promptExists($18)) throw Error("Prompt does not exist, you must create it first.");
    let [K, P] = PK($18);
    if (!await this._currentTenantIsOwner(K)) throw await this._ownerConflictError("update a prompt", K);
    let _ = {};
    if ((q == null ? void 0 : q.description) !== void 0) _.description = q.description;
    if ((q == null ? void 0 : q.readme) !== void 0) _.readme = q.readme;
    if ((q == null ? void 0 : q.tags) !== void 0) _.tags = q.tags;
    if ((q == null ? void 0 : q.isPublic) !== void 0) _.is_public = q.isPublic;
    if ((q == null ? void 0 : q.isArchived) !== void 0) _.is_archived = q.isArchived;
    if (Object.keys(_).length === 0) throw Error("No valid update options provided");
    let Y = JSON.stringify(_);
    return (await this.caller.call(async () => {
      let z = await this._fetch(`${this.apiUrl}/repos/${K}/${P}`, { method: "PATCH", headers: { ...this.headers, "Content-Type": "application/json" }, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions, body: Y });
      return await $6(z, "update prompt"), z;
    })).json();
  }
  async deletePrompt($18) {
    if (!await this.promptExists($18)) throw Error("Prompt does not exist, you must create it first.");
    let [q, K, P] = PK($18);
    if (!await this._currentTenantIsOwner(q)) throw await this._ownerConflictError("delete a prompt", q);
    return (await this.caller.call(async () => {
      let Y = await this._fetch(`${this.apiUrl}/repos/${q}/${K}`, { method: "DELETE", headers: this.headers, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions });
      return await $6(Y, "delete prompt"), Y;
    })).json();
  }
  async pullPromptCommit($18, q) {
    let [K, P, _] = PK($18), O = await (await this.caller.call(async () => {
      let z = await this._fetch(`${this.apiUrl}/commits/${K}/${P}/${_}${(q == null ? void 0 : q.includeModel) ? "?include_model=true" : ""}`, { method: "GET", headers: this.headers, signal: AbortSignal.timeout(this.timeout_ms), ...this.fetchOptions });
      return await $6(z, "pull prompt commit"), z;
    })).json();
    return { owner: K, repo: P, commit_hash: O.commit_hash, manifest: O.manifest, examples: O.examples };
  }
  async _pullPrompt($18, q) {
    let K = await this.pullPromptCommit($18, { includeModel: q == null ? void 0 : q.includeModel });
    return JSON.stringify(K.manifest);
  }
  async pushPrompt($18, q) {
    if (await this.promptExists($18)) {
      if (q && Object.keys(q).some((P) => P !== "object")) await this.updatePrompt($18, { description: q == null ? void 0 : q.description, readme: q == null ? void 0 : q.readme, tags: q == null ? void 0 : q.tags, isPublic: q == null ? void 0 : q.isPublic });
    } else await this.createPrompt($18, { description: q == null ? void 0 : q.description, readme: q == null ? void 0 : q.readme, tags: q == null ? void 0 : q.tags, isPublic: q == null ? void 0 : q.isPublic });
    if (!(q == null ? void 0 : q.object)) return await this._getPromptUrl($18);
    return await this.createCommit($18, q == null ? void 0 : q.object, { parentCommitHash: q == null ? void 0 : q.parentCommitHash });
  }
  async clonePublicDataset($18, q = {}) {
    let { sourceApiUrl: K = this.apiUrl, datasetName: P } = q, [_, Y] = this.parseTokenOrUrl($18, K), O = new _bK({ apiUrl: _, apiKey: "placeholder" }), z = await O.readSharedDataset(Y), J = P || z.name;
    try {
      if (await this.hasDataset({ datasetId: J })) {
        console.log(`Dataset ${J} already exists in your tenant. Skipping.`);
        return;
      }
    } catch (f) {
    }
    let T = await O.listSharedExamples(Y), X = await this.createDataset(J, { description: z.description, dataType: z.data_type || "kv", inputsSchema: z.inputs_schema_definition ?? void 0, outputsSchema: z.outputs_schema_definition ?? void 0 });
    try {
      await this.createExamples({ inputs: T.map((f) => f.inputs), outputs: T.flatMap((f) => f.outputs ? [f.outputs] : []), datasetId: X.id });
    } catch (f) {
      throw console.error(`An error occurred while creating dataset ${J}. You should delete it manually.`), f;
    }
  }
  parseTokenOrUrl($18, q, K = 2, P = "dataset") {
    try {
      return O6($18), [q, $18];
    } catch (_) {
    }
    try {
      let Y = new URL($18).pathname.split("/").filter((O) => O !== "");
      if (Y.length >= K) {
        let O = Y[Y.length - K];
        return [q, O];
      } else throw Error(`Invalid public ${P} URL: ${$18}`);
    } catch (_) {
      throw Error(`Invalid public ${P} URL or token: ${$18}`);
    }
  }
  async awaitPendingTraceBatches() {
    var _a2, _b2;
    if (this.manualFlushMode) return console.warn("[WARNING]: When tracing in manual flush mode, you must call `await client.flush()` manually to submit trace batches."), Promise.resolve();
    if (await Promise.all([...this.autoBatchQueue.items.map(({ itemPromise: $18 }) => $18), this.batchIngestCaller.queue.onIdle()]), this.langSmithToOTELTranslator !== void 0) await ((_b2 = (_a2 = Rw()) == null ? void 0 : _a2.DEFAULT_LANGSMITH_SPAN_PROCESSOR) == null ? void 0 : _b2.forceFlush());
  }
};
function UZ($18) {
  return "dataset_id" in $18 || "dataset_name" in $18;
}
var QZ = ($18) => {
  if ($18 !== void 0) return $18;
  return !!["TRACING_V2", "TRACING"].find((K) => l6(K) === "true");
};
var U1 = Symbol.for("lc:context_variables");
function kR($18) {
  return $18.replace(/[-:.]/g, "");
}
function sZ($18, q = 1) {
  let K = q.toFixed(0).slice(0, 3).padStart(3, "0");
  return `${new Date($18).toISOString().slice(0, -1)}${K}Z`;
}
function CY($18, q, K = 1) {
  let P = sZ($18, K);
  return { dottedOrder: kR(P) + q, microsecondPrecisionDatestring: P };
}
var F1 = class _F1 {
  constructor($18, q, K, P) {
    Object.defineProperty(this, "metadata", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "tags", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "project_name", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "replicas", { enumerable: true, configurable: true, writable: true, value: void 0 }), this.metadata = $18, this.tags = q, this.project_name = K, this.replicas = P;
  }
  static fromHeader($18) {
    let q = $18.split(","), K = {}, P = [], _, Y;
    for (let O of q) {
      let [z, J] = O.split("="), T = decodeURIComponent(J);
      if (z === "langsmith-metadata") K = JSON.parse(T);
      else if (z === "langsmith-tags") P = T.split(",");
      else if (z === "langsmith-project") _ = T;
      else if (z === "langsmith-replicas") Y = JSON.parse(T);
    }
    return new _F1(K, P, _, Y);
  }
  toHeader() {
    let $18 = [];
    if (this.metadata && Object.keys(this.metadata).length > 0) $18.push(`langsmith-metadata=${encodeURIComponent(JSON.stringify(this.metadata))}`);
    if (this.tags && this.tags.length > 0) $18.push(`langsmith-tags=${encodeURIComponent(this.tags.join(","))}`);
    if (this.project_name) $18.push(`langsmith-project=${encodeURIComponent(this.project_name)}`);
    return $18.join(",");
  }
};
var Oq = class _Oq {
  constructor($18) {
    var _a2;
    if (Object.defineProperty(this, "id", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "name", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "run_type", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "project_name", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "parent_run", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "parent_run_id", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "child_runs", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "start_time", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "end_time", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "extra", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "tags", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "error", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "serialized", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "inputs", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "outputs", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "reference_example_id", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "client", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "events", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "trace_id", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "dotted_order", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "tracingEnabled", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "execution_order", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "child_execution_order", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "attachments", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "replicas", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "_serialized_start_time", { enumerable: true, configurable: true, writable: true, value: void 0 }), $X($18)) {
      Object.assign(this, { ...$18 });
      return;
    }
    let q = _Oq.getDefaultConfig(), { metadata: K, ...P } = $18, _ = P.client ?? _Oq.getSharedClient(), Y = { ...K, ...(_a2 = P == null ? void 0 : P.extra) == null ? void 0 : _a2.metadata };
    if (P.extra = { ...P.extra, metadata: Y }, "id" in P && P.id == null) delete P.id;
    if (Object.assign(this, { ...q, ...P, client: _ }), this.execution_order ?? (this.execution_order = 1), this.child_execution_order ?? (this.child_execution_order = 1), !this.dotted_order) this._serialized_start_time = sZ(this.start_time, this.execution_order);
    if (!this.id) this.id = A1(this._serialized_start_time ?? this.start_time);
    if (P.id) k1(P.id, "run_id");
    if (!this.trace_id) if (this.parent_run) this.trace_id = this.parent_run.trace_id ?? this.id;
    else this.trace_id = this.id;
    else if (P.trace_id) k1(P.trace_id, "trace_id");
    if (P.parent_run_id) k1(P.parent_run_id, "parent_run_id");
    if (this.replicas = MR(this.replicas), !this.dotted_order) {
      let { dottedOrder: O } = CY(this.start_time, this.id, this.execution_order);
      if (this.parent_run) this.dotted_order = this.parent_run.dotted_order + "." + O;
      else this.dotted_order = O;
    }
  }
  set metadata($18) {
    var _a2;
    this.extra = { ...this.extra, metadata: { ...(_a2 = this.extra) == null ? void 0 : _a2.metadata, ...$18 } };
  }
  get metadata() {
    var _a2;
    return (_a2 = this.extra) == null ? void 0 : _a2.metadata;
  }
  static getDefaultConfig() {
    let $18 = Date.now();
    return { run_type: "chain", project_name: zP(), child_runs: [], api_url: _8("LANGCHAIN_ENDPOINT") ?? "http://localhost:1984", api_key: _8("LANGCHAIN_API_KEY"), caller_options: {}, start_time: $18, serialized: {}, inputs: {}, extra: {} };
  }
  static getSharedClient() {
    if (!_Oq.sharedClient) _Oq.sharedClient = new bK();
    return _Oq.sharedClient;
  }
  createChild($18) {
    var _a2, _b2, _c, _d2, _e, _f;
    let q = this.child_execution_order + 1, K = new _Oq({ ...$18, parent_run: this, project_name: this.project_name, replicas: this.replicas, client: this.client, tracingEnabled: this.tracingEnabled, execution_order: q, child_execution_order: q });
    if (U1 in this) K[U1] = this[U1];
    let P = Symbol.for("lc:child_config"), _ = ((_a2 = $18.extra) == null ? void 0 : _a2[P]) ?? this.extra[P];
    if (VR(_)) {
      let z = { ..._ }, J = GR(z.callbacks) ? (_c = (_b2 = z.callbacks).copy) == null ? void 0 : _c.call(_b2) : void 0;
      if (J) Object.assign(J, { _parentRunId: K.id }), (_f = (_e = (_d2 = J.handlers) == null ? void 0 : _d2.find(qX)) == null ? void 0 : _e.updateFromRunTree) == null ? void 0 : _f.call(_e, K), z.callbacks = J;
      K.extra[P] = z;
    }
    let Y = /* @__PURE__ */ new Set(), O = this;
    while (O != null && !Y.has(O.id)) Y.add(O.id), O.child_execution_order = Math.max(O.child_execution_order, q), O = O.parent_run;
    return this.child_runs.push(K), K;
  }
  async end($18, q, K = Date.now(), P) {
    if (this.outputs = this.outputs ?? $18, this.error = this.error ?? q, this.end_time = this.end_time ?? K, P && Object.keys(P).length > 0) this.extra = this.extra ? { ...this.extra, metadata: { ...this.extra.metadata, ...P } } : { metadata: P };
  }
  _convertToCreate($18, q, K = true) {
    var _a2, _b2;
    let P = $18.extra ?? {};
    if (((_a2 = P == null ? void 0 : P.runtime) == null ? void 0 : _a2.library) === void 0) {
      if (!P.runtime) P.runtime = {};
      if (q) {
        for (let [O, z] of Object.entries(q)) if (!P.runtime[O]) P.runtime[O] = z;
      }
    }
    let _, Y;
    if (!K) _ = $18.child_runs.map((O) => this._convertToCreate(O, q, K)), Y = void 0;
    else Y = ((_b2 = $18.parent_run) == null ? void 0 : _b2.id) ?? $18.parent_run_id, _ = [];
    return { id: $18.id, name: $18.name, start_time: $18._serialized_start_time ?? $18.start_time, end_time: $18.end_time, run_type: $18.run_type, reference_example_id: $18.reference_example_id, extra: P, serialized: $18.serialized, error: $18.error, inputs: $18.inputs, outputs: $18.outputs, session_name: $18.project_name, child_runs: _, parent_run_id: Y, trace_id: $18.trace_id, dotted_order: $18.dotted_order, tags: $18.tags, attachments: $18.attachments, events: $18.events };
  }
  _remapForProject($18, q, K = true) {
    return { ...this._convertToCreate(this, q, K), session_name: $18 };
  }
  async postRun($18 = true) {
    try {
      let q = V1();
      if (this.replicas && this.replicas.length > 0) for (let { projectName: K, apiKey: P, apiUrl: _, workspaceId: Y } of this.replicas) {
        let O = this._remapForProject(K ?? this.project_name, q, true);
        await this.client.createRun(O, { apiKey: P, apiUrl: _, workspaceId: Y });
      }
      else {
        let K = this._convertToCreate(this, q, $18);
        await this.client.createRun(K);
      }
      if (!$18) {
        Y_("Posting with excludeChildRuns=false is deprecated and will be removed in a future version.");
        for (let K of this.child_runs) await K.postRun(false);
      }
    } catch (q) {
      console.error(`Error in postRun for run ${this.id}:`, q);
    }
  }
  async patchRun($18) {
    var _a2;
    if (this.replicas && this.replicas.length > 0) for (let { projectName: q, apiKey: K, apiUrl: P, workspaceId: _, updates: Y } of this.replicas) {
      let O = this._remapForProject(q ?? this.project_name), z = { id: O.id, name: O.name, run_type: O.run_type, start_time: O.start_time, outputs: O.outputs, error: O.error, parent_run_id: O.parent_run_id, session_name: O.session_name, reference_example_id: O.reference_example_id, end_time: O.end_time, dotted_order: O.dotted_order, trace_id: O.trace_id, events: O.events, tags: O.tags, extra: O.extra, attachments: this.attachments, ...Y };
      if (!($18 == null ? void 0 : $18.excludeInputs)) z.inputs = O.inputs;
      await this.client.updateRun(O.id, z, { apiKey: K, apiUrl: P, workspaceId: _ });
    }
    else try {
      let q = { name: this.name, run_type: this.run_type, start_time: this._serialized_start_time ?? this.start_time, end_time: this.end_time, error: this.error, outputs: this.outputs, parent_run_id: ((_a2 = this.parent_run) == null ? void 0 : _a2.id) ?? this.parent_run_id, reference_example_id: this.reference_example_id, extra: this.extra, events: this.events, dotted_order: this.dotted_order, trace_id: this.trace_id, tags: this.tags, attachments: this.attachments, session_name: this.project_name };
      if (!($18 == null ? void 0 : $18.excludeInputs)) q.inputs = this.inputs;
      await this.client.updateRun(this.id, q);
    } catch (q) {
      console.error(`Error in patchRun for run ${this.id}`, q);
    }
  }
  toJSON() {
    return this._convertToCreate(this, void 0, false);
  }
  addEvent($18) {
    if (!this.events) this.events = [];
    if (typeof $18 === "string") this.events.push({ name: "event", time: (/* @__PURE__ */ new Date()).toISOString(), message: $18 });
    else this.events.push({ ...$18, time: $18.time ?? (/* @__PURE__ */ new Date()).toISOString() });
  }
  static fromRunnableConfig($18, q) {
    var _a2, _b2, _c, _d2;
    let K = $18 == null ? void 0 : $18.callbacks, P, _, Y, O = QZ();
    if (K) {
      let J = ((_a2 = K == null ? void 0 : K.getParentRunId) == null ? void 0 : _a2.call(K)) ?? "", T = (_b2 = K == null ? void 0 : K.handlers) == null ? void 0 : _b2.find((X) => (X == null ? void 0 : X.name) == "langchain_tracer");
      P = (_c = T == null ? void 0 : T.getRun) == null ? void 0 : _c.call(T, J), _ = T == null ? void 0 : T.projectName, Y = T == null ? void 0 : T.client, O = O || !!T;
    }
    if (!P) return new _Oq({ ...q, client: Y, tracingEnabled: O, project_name: _ });
    return new _Oq({ name: P.name, id: P.id, trace_id: P.trace_id, dotted_order: P.dotted_order, client: Y, tracingEnabled: O, project_name: _, tags: [...new Set(((P == null ? void 0 : P.tags) ?? []).concat(($18 == null ? void 0 : $18.tags) ?? []))], extra: { metadata: { ...(_d2 = P == null ? void 0 : P.extra) == null ? void 0 : _d2.metadata, ...$18 == null ? void 0 : $18.metadata } } }).createChild(q);
  }
  static fromDottedOrder($18) {
    return this.fromHeaders({ "langsmith-trace": $18 });
  }
  static fromHeaders($18, q) {
    var _a2;
    let K = "get" in $18 && typeof $18.get === "function" ? { "langsmith-trace": $18.get("langsmith-trace"), baggage: $18.get("baggage") } : $18, P = K["langsmith-trace"];
    if (!P || typeof P !== "string") return;
    let _ = P.trim(), Y = _.split(".").map((J) => {
      let [T, X] = J.split("Z");
      return { strTime: T, time: Date.parse(T + "Z"), uuid: X };
    }), O = Y[0].uuid, z = { ...q, name: (q == null ? void 0 : q.name) ?? "parent", run_type: (q == null ? void 0 : q.run_type) ?? "chain", start_time: (q == null ? void 0 : q.start_time) ?? Date.now(), id: (_a2 = Y.at(-1)) == null ? void 0 : _a2.uuid, trace_id: O, dotted_order: _ };
    if (K.baggage && typeof K.baggage === "string") {
      let J = F1.fromHeader(K.baggage);
      z.metadata = J.metadata, z.tags = J.tags, z.project_name = J.project_name, z.replicas = J.replicas;
    }
    return new _Oq(z);
  }
  toHeaders($18) {
    var _a2;
    let q = { "langsmith-trace": this.dotted_order, baggage: new F1((_a2 = this.extra) == null ? void 0 : _a2.metadata, this.tags, this.project_name, this.replicas).toHeader() };
    if ($18) for (let [K, P] of Object.entries(q)) $18.set(K, P);
    return q;
  }
};
Object.defineProperty(Oq, "sharedClient", { enumerable: true, configurable: true, writable: true, value: null });
function $X($18) {
  return $18 != null && typeof $18.createChild === "function" && typeof $18.postRun === "function";
}
function qX($18) {
  return typeof $18 === "object" && $18 != null && typeof $18.name === "string" && $18.name === "langchain_tracer";
}
function eZ($18) {
  return Array.isArray($18) && $18.some((q) => qX(q));
}
function GR($18) {
  return typeof $18 === "object" && $18 != null && Array.isArray($18.handlers);
}
function VR($18) {
  var _a2;
  return $18 != null && typeof $18.callbacks === "object" && (eZ((_a2 = $18.callbacks) == null ? void 0 : _a2.handlers) || eZ($18.callbacks));
}
function SR() {
  let $18 = _8("LANGSMITH_RUNS_ENDPOINTS");
  if (!$18) return [];
  try {
    let q = JSON.parse($18);
    if (Array.isArray(q)) {
      let K = [];
      for (let P of q) {
        if (typeof P !== "object" || P === null) {
          console.warn(`Invalid item type in LANGSMITH_RUNS_ENDPOINTS: expected object, got ${typeof P}`);
          continue;
        }
        if (typeof P.api_url !== "string") {
          console.warn(`Invalid api_url type in LANGSMITH_RUNS_ENDPOINTS: expected string, got ${typeof P.api_url}`);
          continue;
        }
        if (typeof P.api_key !== "string") {
          console.warn(`Invalid api_key type in LANGSMITH_RUNS_ENDPOINTS: expected string, got ${typeof P.api_key}`);
          continue;
        }
        K.push({ apiUrl: P.api_url.replace(/\/$/, ""), apiKey: P.api_key });
      }
      return K;
    } else if (typeof q === "object" && q !== null) {
      NR(q);
      let K = [];
      for (let [P, _] of Object.entries(q)) {
        let Y = P.replace(/\/$/, "");
        if (typeof _ === "string") K.push({ apiUrl: Y, apiKey: _ });
        else {
          console.warn(`Invalid value type in LANGSMITH_RUNS_ENDPOINTS for URL ${P}: expected string, got ${typeof _}`);
          continue;
        }
      }
      return K;
    } else return console.warn(`Invalid LANGSMITH_RUNS_ENDPOINTS  must be valid JSON array of objects with api_url and api_key properties, or object mapping url->apiKey, got ${typeof q}`), [];
  } catch (q) {
    if (rZ(q)) throw q;
    return console.warn("Invalid LANGSMITH_RUNS_ENDPOINTS  must be valid JSON array of objects with api_url and api_key properties, or object mapping url->apiKey"), [];
  }
}
function MR($18) {
  if ($18) return $18.map((q) => {
    if (Array.isArray(q)) return { projectName: q[0], updates: q[1] };
    return q;
  });
  return SR();
}
function NR($18) {
  if (Object.keys($18).length > 0 && l6("ENDPOINT")) throw new SY();
}
var CR = {};
Z6(CR, { BaseTracer: () => E8, isBaseTracer: () => v_ });
var ER = ($18) => {
  if (!$18) return;
  return $18.events = $18.events ?? [], $18.child_runs = $18.child_runs ?? [], $18;
};
function hY($18, q) {
  if (!$18) return;
  return new Oq({ ...$18, start_time: $18._serialized_start_time ?? $18.start_time, parent_run: hY(q), child_runs: $18.child_runs.map((K) => hY(K)).filter((K) => K !== void 0), extra: { ...$18.extra, runtime: pO() }, tracingEnabled: false });
}
function EY($18, q) {
  return $18 && !Array.isArray($18) && typeof $18 === "object" ? $18 : { [q]: $18 };
}
function v_($18) {
  return typeof $18._addRunToRunMap === "function";
}
var E8 = class extends P_ {
  constructor($18) {
    super(...arguments);
    __publicField(this, "runMap", /* @__PURE__ */ new Map());
    __publicField(this, "runTreeMap", /* @__PURE__ */ new Map());
    __publicField(this, "usesRunTreeMap", false);
  }
  copy() {
    return this;
  }
  getRunById($18) {
    if ($18 === void 0) return;
    return this.usesRunTreeMap ? ER(this.runTreeMap.get($18)) : this.runMap.get($18);
  }
  stringifyError($18) {
    if ($18 instanceof Error) return $18.message + (($18 == null ? void 0 : $18.stack) ? `

${$18.stack}` : "");
    if (typeof $18 === "string") return $18;
    return `${$18}`;
  }
  _addChildRun($18, q) {
    $18.child_runs.push(q);
  }
  _addRunToRunMap($18) {
    let { dottedOrder: q, microsecondPrecisionDatestring: K } = CY(new Date($18.start_time).getTime(), $18.id, $18.execution_order), P = { ...$18 }, _ = this.getRunById(P.parent_run_id);
    if (P.parent_run_id !== void 0) {
      if (_) {
        if (this._addChildRun(_, P), _.child_execution_order = Math.max(_.child_execution_order, P.child_execution_order), P.trace_id = _.trace_id, _.dotted_order !== void 0) P.dotted_order = [_.dotted_order, q].join("."), P._serialized_start_time = K;
      }
    } else P.trace_id = P.id, P.dotted_order = q, P._serialized_start_time = K;
    if (this.usesRunTreeMap) {
      let Y = hY(P, _);
      if (Y !== void 0) this.runTreeMap.set(P.id, Y);
    } else this.runMap.set(P.id, P);
    return P;
  }
  async _endTrace($18) {
    var _a2;
    let q = $18.parent_run_id !== void 0 && this.getRunById($18.parent_run_id);
    if (q) q.child_execution_order = Math.max(q.child_execution_order, $18.child_execution_order);
    else await this.persistRun($18);
    if (await ((_a2 = this.onRunUpdate) == null ? void 0 : _a2.call(this, $18)), this.usesRunTreeMap) this.runTreeMap.delete($18.id);
    else this.runMap.delete($18.id);
  }
  _getExecutionOrder($18) {
    let q = $18 !== void 0 && this.getRunById($18);
    if (!q) return 1;
    return q.child_execution_order + 1;
  }
  _createRunForLLMStart($18, q, K, P, _, Y, O, z) {
    let J = this._getExecutionOrder(P), T = Date.now(), X = O ? { ..._, metadata: O } : _, f = { id: K, name: z ?? $18.id[$18.id.length - 1], parent_run_id: P, start_time: T, serialized: $18, events: [{ name: "start", time: new Date(T).toISOString() }], inputs: { prompts: q }, execution_order: J, child_runs: [], child_execution_order: J, run_type: "llm", extra: X ?? {}, tags: Y || [] };
    return this._addRunToRunMap(f);
  }
  async handleLLMStart($18, q, K, P, _, Y, O, z) {
    var _a2, _b2;
    let J = this.getRunById(K) ?? this._createRunForLLMStart($18, q, K, P, _, Y, O, z);
    return await ((_a2 = this.onRunCreate) == null ? void 0 : _a2.call(this, J)), await ((_b2 = this.onLLMStart) == null ? void 0 : _b2.call(this, J)), J;
  }
  _createRunForChatModelStart($18, q, K, P, _, Y, O, z) {
    let J = this._getExecutionOrder(P), T = Date.now(), X = O ? { ..._, metadata: O } : _, f = { id: K, name: z ?? $18.id[$18.id.length - 1], parent_run_id: P, start_time: T, serialized: $18, events: [{ name: "start", time: new Date(T).toISOString() }], inputs: { messages: q }, execution_order: J, child_runs: [], child_execution_order: J, run_type: "llm", extra: X ?? {}, tags: Y || [] };
    return this._addRunToRunMap(f);
  }
  async handleChatModelStart($18, q, K, P, _, Y, O, z) {
    var _a2, _b2;
    let J = this.getRunById(K) ?? this._createRunForChatModelStart($18, q, K, P, _, Y, O, z);
    return await ((_a2 = this.onRunCreate) == null ? void 0 : _a2.call(this, J)), await ((_b2 = this.onLLMStart) == null ? void 0 : _b2.call(this, J)), J;
  }
  async handleLLMEnd($18, q, K, P, _) {
    var _a2;
    let Y = this.getRunById(q);
    if (!Y || (Y == null ? void 0 : Y.run_type) !== "llm") throw Error("No LLM run to end.");
    return Y.end_time = Date.now(), Y.outputs = $18, Y.events.push({ name: "end", time: new Date(Y.end_time).toISOString() }), Y.extra = { ...Y.extra, ..._ }, await ((_a2 = this.onLLMEnd) == null ? void 0 : _a2.call(this, Y)), await this._endTrace(Y), Y;
  }
  async handleLLMError($18, q, K, P, _) {
    var _a2;
    let Y = this.getRunById(q);
    if (!Y || (Y == null ? void 0 : Y.run_type) !== "llm") throw Error("No LLM run to end.");
    return Y.end_time = Date.now(), Y.error = this.stringifyError($18), Y.events.push({ name: "error", time: new Date(Y.end_time).toISOString() }), Y.extra = { ...Y.extra, ..._ }, await ((_a2 = this.onLLMError) == null ? void 0 : _a2.call(this, Y)), await this._endTrace(Y), Y;
  }
  _createRunForChainStart($18, q, K, P, _, Y, O, z) {
    let J = this._getExecutionOrder(P), T = Date.now(), X = { id: K, name: z ?? $18.id[$18.id.length - 1], parent_run_id: P, start_time: T, serialized: $18, events: [{ name: "start", time: new Date(T).toISOString() }], inputs: q, execution_order: J, child_execution_order: J, run_type: O ?? "chain", child_runs: [], extra: Y ? { metadata: Y } : {}, tags: _ || [] };
    return this._addRunToRunMap(X);
  }
  async handleChainStart($18, q, K, P, _, Y, O, z) {
    var _a2, _b2;
    let J = this.getRunById(K) ?? this._createRunForChainStart($18, q, K, P, _, Y, O, z);
    return await ((_a2 = this.onRunCreate) == null ? void 0 : _a2.call(this, J)), await ((_b2 = this.onChainStart) == null ? void 0 : _b2.call(this, J)), J;
  }
  async handleChainEnd($18, q, K, P, _) {
    var _a2;
    let Y = this.getRunById(q);
    if (!Y) throw Error("No chain run to end.");
    if (Y.end_time = Date.now(), Y.outputs = EY($18, "output"), Y.events.push({ name: "end", time: new Date(Y.end_time).toISOString() }), (_ == null ? void 0 : _.inputs) !== void 0) Y.inputs = EY(_.inputs, "input");
    return await ((_a2 = this.onChainEnd) == null ? void 0 : _a2.call(this, Y)), await this._endTrace(Y), Y;
  }
  async handleChainError($18, q, K, P, _) {
    var _a2;
    let Y = this.getRunById(q);
    if (!Y) throw Error("No chain run to end.");
    if (Y.end_time = Date.now(), Y.error = this.stringifyError($18), Y.events.push({ name: "error", time: new Date(Y.end_time).toISOString() }), (_ == null ? void 0 : _.inputs) !== void 0) Y.inputs = EY(_.inputs, "input");
    return await ((_a2 = this.onChainError) == null ? void 0 : _a2.call(this, Y)), await this._endTrace(Y), Y;
  }
  _createRunForToolStart($18, q, K, P, _, Y, O) {
    let z = this._getExecutionOrder(P), J = Date.now(), T = { id: K, name: O ?? $18.id[$18.id.length - 1], parent_run_id: P, start_time: J, serialized: $18, events: [{ name: "start", time: new Date(J).toISOString() }], inputs: { input: q }, execution_order: z, child_execution_order: z, run_type: "tool", child_runs: [], extra: Y ? { metadata: Y } : {}, tags: _ || [] };
    return this._addRunToRunMap(T);
  }
  async handleToolStart($18, q, K, P, _, Y, O) {
    var _a2, _b2;
    let z = this.getRunById(K) ?? this._createRunForToolStart($18, q, K, P, _, Y, O);
    return await ((_a2 = this.onRunCreate) == null ? void 0 : _a2.call(this, z)), await ((_b2 = this.onToolStart) == null ? void 0 : _b2.call(this, z)), z;
  }
  async handleToolEnd($18, q) {
    var _a2;
    let K = this.getRunById(q);
    if (!K || (K == null ? void 0 : K.run_type) !== "tool") throw Error("No tool run to end");
    return K.end_time = Date.now(), K.outputs = { output: $18 }, K.events.push({ name: "end", time: new Date(K.end_time).toISOString() }), await ((_a2 = this.onToolEnd) == null ? void 0 : _a2.call(this, K)), await this._endTrace(K), K;
  }
  async handleToolError($18, q) {
    var _a2;
    let K = this.getRunById(q);
    if (!K || (K == null ? void 0 : K.run_type) !== "tool") throw Error("No tool run to end");
    return K.end_time = Date.now(), K.error = this.stringifyError($18), K.events.push({ name: "error", time: new Date(K.end_time).toISOString() }), await ((_a2 = this.onToolError) == null ? void 0 : _a2.call(this, K)), await this._endTrace(K), K;
  }
  async handleAgentAction($18, q) {
    var _a2;
    let K = this.getRunById(q);
    if (!K || (K == null ? void 0 : K.run_type) !== "chain") return;
    let P = K;
    P.actions = P.actions || [], P.actions.push($18), P.events.push({ name: "agent_action", time: (/* @__PURE__ */ new Date()).toISOString(), kwargs: { action: $18 } }), await ((_a2 = this.onAgentAction) == null ? void 0 : _a2.call(this, K));
  }
  async handleAgentEnd($18, q) {
    var _a2;
    let K = this.getRunById(q);
    if (!K || (K == null ? void 0 : K.run_type) !== "chain") return;
    K.events.push({ name: "agent_end", time: (/* @__PURE__ */ new Date()).toISOString(), kwargs: { action: $18 } }), await ((_a2 = this.onAgentEnd) == null ? void 0 : _a2.call(this, K));
  }
  _createRunForRetrieverStart($18, q, K, P, _, Y, O) {
    let z = this._getExecutionOrder(P), J = Date.now(), T = { id: K, name: O ?? $18.id[$18.id.length - 1], parent_run_id: P, start_time: J, serialized: $18, events: [{ name: "start", time: new Date(J).toISOString() }], inputs: { query: q }, execution_order: z, child_execution_order: z, run_type: "retriever", child_runs: [], extra: Y ? { metadata: Y } : {}, tags: _ || [] };
    return this._addRunToRunMap(T);
  }
  async handleRetrieverStart($18, q, K, P, _, Y, O) {
    var _a2, _b2;
    let z = this.getRunById(K) ?? this._createRunForRetrieverStart($18, q, K, P, _, Y, O);
    return await ((_a2 = this.onRunCreate) == null ? void 0 : _a2.call(this, z)), await ((_b2 = this.onRetrieverStart) == null ? void 0 : _b2.call(this, z)), z;
  }
  async handleRetrieverEnd($18, q) {
    var _a2;
    let K = this.getRunById(q);
    if (!K || (K == null ? void 0 : K.run_type) !== "retriever") throw Error("No retriever run to end");
    return K.end_time = Date.now(), K.outputs = { documents: $18 }, K.events.push({ name: "end", time: new Date(K.end_time).toISOString() }), await ((_a2 = this.onRetrieverEnd) == null ? void 0 : _a2.call(this, K)), await this._endTrace(K), K;
  }
  async handleRetrieverError($18, q) {
    var _a2;
    let K = this.getRunById(q);
    if (!K || (K == null ? void 0 : K.run_type) !== "retriever") throw Error("No retriever run to end");
    return K.end_time = Date.now(), K.error = this.stringifyError($18), K.events.push({ name: "error", time: new Date(K.end_time).toISOString() }), await ((_a2 = this.onRetrieverError) == null ? void 0 : _a2.call(this, K)), await this._endTrace(K), K;
  }
  async handleText($18, q) {
    var _a2;
    let K = this.getRunById(q);
    if (!K || (K == null ? void 0 : K.run_type) !== "chain") return;
    K.events.push({ name: "text", time: (/* @__PURE__ */ new Date()).toISOString(), kwargs: { text: $18 } }), await ((_a2 = this.onText) == null ? void 0 : _a2.call(this, K));
  }
  async handleLLMNewToken($18, q, K, P, _, Y) {
    var _a2;
    let O = this.getRunById(K);
    if (!O || (O == null ? void 0 : O.run_type) !== "llm") throw Error('Invalid "runId" provided to "handleLLMNewToken" callback.');
    return O.events.push({ name: "new_token", time: (/* @__PURE__ */ new Date()).toISOString(), kwargs: { token: $18, idx: q, chunk: Y == null ? void 0 : Y.chunk } }), await ((_a2 = this.onLLMNewToken) == null ? void 0 : _a2.call(this, O, $18, { chunk: Y == null ? void 0 : Y.chunk })), O;
  }
};
var RY = q8(OX(), 1);
var RR = {};
Z6(RR, { ConsoleCallbackHandler: () => a1 });
function bq($18, q) {
  return `${$18.open}${q}${$18.close}`;
}
function T8($18, q) {
  try {
    return JSON.stringify($18, null, 2);
  } catch {
    return q;
  }
}
function YX($18) {
  if (typeof $18 === "string") return $18.trim();
  if ($18 === null || $18 === void 0) return $18;
  return T8($18, $18.toString());
}
function yK($18) {
  if (!$18.end_time) return "";
  let q = $18.end_time - $18.start_time;
  if (q < 1e3) return `${q}ms`;
  return `${(q / 1e3).toFixed(2)}s`;
}
var { color: Bq } = RY.default;
var a1 = class extends E8 {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "console_callback_handler");
  }
  persistRun($18) {
    return Promise.resolve();
  }
  getParents($18) {
    let q = [], K = $18;
    while (K.parent_run_id) {
      let P = this.runMap.get(K.parent_run_id);
      if (P) q.push(P), K = P;
      else break;
    }
    return q;
  }
  getBreadcrumbs($18) {
    let K = [...this.getParents($18).reverse(), $18].map((P, _, Y) => {
      let O = `${P.execution_order}:${P.run_type}:${P.name}`;
      return _ === Y.length - 1 ? bq(RY.default.bold, O) : O;
    }).join(" > ");
    return bq(Bq.grey, K);
  }
  onChainStart($18) {
    let q = this.getBreadcrumbs($18);
    console.log(`${bq(Bq.green, "[chain/start]")} [${q}] Entering Chain run with input: ${T8($18.inputs, "[inputs]")}`);
  }
  onChainEnd($18) {
    let q = this.getBreadcrumbs($18);
    console.log(`${bq(Bq.cyan, "[chain/end]")} [${q}] [${yK($18)}] Exiting Chain run with output: ${T8($18.outputs, "[outputs]")}`);
  }
  onChainError($18) {
    let q = this.getBreadcrumbs($18);
    console.log(`${bq(Bq.red, "[chain/error]")} [${q}] [${yK($18)}] Chain run errored with error: ${T8($18.error, "[error]")}`);
  }
  onLLMStart($18) {
    let q = this.getBreadcrumbs($18), K = "prompts" in $18.inputs ? { prompts: $18.inputs.prompts.map((P) => P.trim()) } : $18.inputs;
    console.log(`${bq(Bq.green, "[llm/start]")} [${q}] Entering LLM run with input: ${T8(K, "[inputs]")}`);
  }
  onLLMEnd($18) {
    let q = this.getBreadcrumbs($18);
    console.log(`${bq(Bq.cyan, "[llm/end]")} [${q}] [${yK($18)}] Exiting LLM run with output: ${T8($18.outputs, "[response]")}`);
  }
  onLLMError($18) {
    let q = this.getBreadcrumbs($18);
    console.log(`${bq(Bq.red, "[llm/error]")} [${q}] [${yK($18)}] LLM run errored with error: ${T8($18.error, "[error]")}`);
  }
  onToolStart($18) {
    let q = this.getBreadcrumbs($18);
    console.log(`${bq(Bq.green, "[tool/start]")} [${q}] Entering Tool run with input: "${YX($18.inputs.input)}"`);
  }
  onToolEnd($18) {
    var _a2;
    let q = this.getBreadcrumbs($18);
    console.log(`${bq(Bq.cyan, "[tool/end]")} [${q}] [${yK($18)}] Exiting Tool run with output: "${YX((_a2 = $18.outputs) == null ? void 0 : _a2.output)}"`);
  }
  onToolError($18) {
    let q = this.getBreadcrumbs($18);
    console.log(`${bq(Bq.red, "[tool/error]")} [${q}] [${yK($18)}] Tool run errored with error: ${T8($18.error, "[error]")}`);
  }
  onRetrieverStart($18) {
    let q = this.getBreadcrumbs($18);
    console.log(`${bq(Bq.green, "[retriever/start]")} [${q}] Entering Retriever run with input: ${T8($18.inputs, "[inputs]")}`);
  }
  onRetrieverEnd($18) {
    let q = this.getBreadcrumbs($18);
    console.log(`${bq(Bq.cyan, "[retriever/end]")} [${q}] [${yK($18)}] Exiting Retriever run with output: ${T8($18.outputs, "[outputs]")}`);
  }
  onRetrieverError($18) {
    let q = this.getBreadcrumbs($18);
    console.log(`${bq(Bq.red, "[retriever/error]")} [${q}] [${yK($18)}] Retriever run errored with error: ${T8($18.error, "[error]")}`);
  }
  onAgentAction($18) {
    let q = $18, K = this.getBreadcrumbs($18);
    console.log(`${bq(Bq.blue, "[agent/action]")} [${K}] Agent selected action: ${T8(q.actions[q.actions.length - 1], "[action]")}`);
  }
};
var IY;
var Q1 = () => {
  if (IY === void 0) {
    let $18 = M8("LANGCHAIN_CALLBACKS_BACKGROUND") === "false" ? { blockOnRootRunFinalization: true } : {};
    IY = new bK($18);
  }
  return IY;
};
var jX = class {
  getStore() {
    return;
  }
  run($18, q) {
    return q();
  }
};
var DY = Symbol.for("ls:tracing_async_local_storage");
var IR = new jX();
var vX = class {
  getInstance() {
    return globalThis[DY] ?? IR;
  }
  initializeGlobalInstance($18) {
    if (globalThis[DY] === void 0) globalThis[DY] = $18;
  }
};
var DR = new vX();
function zX($18 = false) {
  let q = DR.getInstance().getStore();
  if (!$18 && q === void 0) throw Error(`Could not get the current run tree.

Please make sure you are calling this method within a traceable function and that tracing is enabled.`);
  return q;
}
function e1($18) {
  return typeof $18 === "function" && "langsmith:traceable" in $18;
}
var LR = {};
Z6(LR, { LangChainTracer: () => kP });
var kP = class $2 extends E8 {
  constructor(q = {}) {
    super(q);
    __publicField(this, "name", "langchain_tracer");
    __publicField(this, "projectName");
    __publicField(this, "exampleId");
    __publicField(this, "client");
    __publicField(this, "replicas");
    __publicField(this, "usesRunTreeMap", true);
    let { exampleId: K, projectName: P, client: _, replicas: Y } = q;
    this.projectName = P ?? zP(), this.replicas = Y, this.exampleId = K, this.client = _ ?? Q1();
    let O = $2.getTraceableRunTree();
    if (O) this.updateFromRunTree(O);
  }
  async persistRun(q) {
  }
  async onRunCreate(q) {
    var _a2;
    await ((_a2 = this.getRunTreeWithTracingConfig(q.id)) == null ? void 0 : _a2.postRun());
  }
  async onRunUpdate(q) {
    var _a2;
    await ((_a2 = this.getRunTreeWithTracingConfig(q.id)) == null ? void 0 : _a2.patchRun());
  }
  getRun(q) {
    return this.runTreeMap.get(q);
  }
  updateFromRunTree(q) {
    this.runTreeMap.set(q.id, q);
    let K = q, P = /* @__PURE__ */ new Set();
    while (K.parent_run) {
      if (P.has(K.id)) break;
      if (P.add(K.id), !K.parent_run) break;
      K = K.parent_run;
    }
    P.clear();
    let _ = [K];
    while (_.length > 0) {
      let Y = _.shift();
      if (!Y || P.has(Y.id)) continue;
      if (P.add(Y.id), this.runTreeMap.set(Y.id, Y), Y.child_runs) _.push(...Y.child_runs);
    }
    this.client = q.client ?? this.client, this.replicas = q.replicas ?? this.replicas, this.projectName = q.project_name ?? this.projectName, this.exampleId = q.reference_example_id ?? this.exampleId;
  }
  getRunTreeWithTracingConfig(q) {
    let K = this.runTreeMap.get(q);
    if (!K) return;
    return new Oq({ ...K, client: this.client, project_name: this.projectName, replicas: this.replicas, reference_example_id: this.exampleId, tracingEnabled: true });
  }
  static getTraceableRunTree() {
    try {
      return zX(true);
    } catch {
      return;
    }
  }
};
var s1 = q8(I1(), 1);
var z_;
function gR() {
  return new ("default" in s1.default ? s1.default.default : s1.default)({ autoStart: true, concurrency: 1 });
}
function bR() {
  if (typeof z_ > "u") z_ = gR();
  return z_;
}
async function c6($18, q) {
  if (q === true) {
    let K = DK();
    if (K !== void 0) await K.run(void 0, async () => $18());
    else await $18();
  } else z_ = bR(), z_.add(async () => {
    let K = DK();
    if (K !== void 0) await K.run(void 0, async () => $18());
    else await $18();
  });
}
async function WX() {
  let $18 = Q1();
  await Promise.allSettled([typeof z_ < "u" ? z_.onIdle() : Promise.resolve(), $18.awaitPendingTraceBatches()]);
}
var yR = {};
Z6(yR, { awaitAllCallbacks: () => WX, consumeCallback: () => c6 });
var HX = ($18) => {
  if ($18 !== void 0) return $18;
  return !!["LANGSMITH_TRACING_V2", "LANGCHAIN_TRACING_V2", "LANGSMITH_TRACING", "LANGCHAIN_TRACING"].find((K) => M8(K) === "true");
};
function LY($18) {
  var _a2, _b2;
  let q = DK();
  if (q === void 0) return;
  return (_b2 = (_a2 = q.getStore()) == null ? void 0 : _a2[IK]) == null ? void 0 : _b2[$18];
}
var uR = Symbol("lc:configure_hooks");
var JX = () => LY(uR) || [];
var xR = {};
Z6(xR, { BaseCallbackManager: () => TX, BaseRunManager: () => GP, CallbackManager: () => OK, CallbackManagerForChainRun: () => fX, CallbackManagerForLLMRun: () => gY, CallbackManagerForRetrieverRun: () => wX, CallbackManagerForToolRun: () => ZX, ensureHandler: () => r_, parseCallbackConfigArg: () => pR });
function pR($18) {
  if (!$18) return {};
  else if (Array.isArray($18) || "name" in $18) return { callbacks: $18 };
  else return $18;
}
var TX = class {
  setHandler($18) {
    return this.setHandlers([$18]);
  }
};
var GP = class {
  constructor($18, q, K, P, _, Y, O, z) {
    this.runId = $18, this.handlers = q, this.inheritableHandlers = K, this.tags = P, this.inheritableTags = _, this.metadata = Y, this.inheritableMetadata = O, this._parentRunId = z;
  }
  get parentRunId() {
    return this._parentRunId;
  }
  async handleText($18) {
    await Promise.all(this.handlers.map((q) => c6(async () => {
      var _a2;
      try {
        await ((_a2 = q.handleText) == null ? void 0 : _a2.call(q, $18, this.runId, this._parentRunId, this.tags));
      } catch (K) {
        if ((q.raiseError ? console.error : console.warn)(`Error in handler ${q.constructor.name}, handleText: ${K}`), q.raiseError) throw K;
      }
    }, q.awaitHandlers)));
  }
  async handleCustomEvent($18, q, K, P, _) {
    await Promise.all(this.handlers.map((Y) => c6(async () => {
      var _a2;
      try {
        await ((_a2 = Y.handleCustomEvent) == null ? void 0 : _a2.call(Y, $18, q, this.runId, this.tags, this.metadata));
      } catch (O) {
        if ((Y.raiseError ? console.error : console.warn)(`Error in handler ${Y.constructor.name}, handleCustomEvent: ${O}`), Y.raiseError) throw O;
      }
    }, Y.awaitHandlers)));
  }
};
var wX = class extends GP {
  getChild($18) {
    let q = new OK(this.runId);
    if (q.setHandlers(this.inheritableHandlers), q.addTags(this.inheritableTags), q.addMetadata(this.inheritableMetadata), $18) q.addTags([$18], false);
    return q;
  }
  async handleRetrieverEnd($18) {
    await Promise.all(this.handlers.map((q) => c6(async () => {
      var _a2;
      if (!q.ignoreRetriever) try {
        await ((_a2 = q.handleRetrieverEnd) == null ? void 0 : _a2.call(q, $18, this.runId, this._parentRunId, this.tags));
      } catch (K) {
        if ((q.raiseError ? console.error : console.warn)(`Error in handler ${q.constructor.name}, handleRetriever`), q.raiseError) throw K;
      }
    }, q.awaitHandlers)));
  }
  async handleRetrieverError($18) {
    await Promise.all(this.handlers.map((q) => c6(async () => {
      var _a2;
      if (!q.ignoreRetriever) try {
        await ((_a2 = q.handleRetrieverError) == null ? void 0 : _a2.call(q, $18, this.runId, this._parentRunId, this.tags));
      } catch (K) {
        if ((q.raiseError ? console.error : console.warn)(`Error in handler ${q.constructor.name}, handleRetrieverError: ${K}`), q.raiseError) throw $18;
      }
    }, q.awaitHandlers)));
  }
};
var gY = class extends GP {
  async handleLLMNewToken($18, q, K, P, _, Y) {
    await Promise.all(this.handlers.map((O) => c6(async () => {
      var _a2;
      if (!O.ignoreLLM) try {
        await ((_a2 = O.handleLLMNewToken) == null ? void 0 : _a2.call(O, $18, q ?? { prompt: 0, completion: 0 }, this.runId, this._parentRunId, this.tags, Y));
      } catch (z) {
        if ((O.raiseError ? console.error : console.warn)(`Error in handler ${O.constructor.name}, handleLLMNewToken: ${z}`), O.raiseError) throw z;
      }
    }, O.awaitHandlers)));
  }
  async handleLLMError($18, q, K, P, _) {
    await Promise.all(this.handlers.map((Y) => c6(async () => {
      var _a2;
      if (!Y.ignoreLLM) try {
        await ((_a2 = Y.handleLLMError) == null ? void 0 : _a2.call(Y, $18, this.runId, this._parentRunId, this.tags, _));
      } catch (O) {
        if ((Y.raiseError ? console.error : console.warn)(`Error in handler ${Y.constructor.name}, handleLLMError: ${O}`), Y.raiseError) throw O;
      }
    }, Y.awaitHandlers)));
  }
  async handleLLMEnd($18, q, K, P, _) {
    await Promise.all(this.handlers.map((Y) => c6(async () => {
      var _a2;
      if (!Y.ignoreLLM) try {
        await ((_a2 = Y.handleLLMEnd) == null ? void 0 : _a2.call(Y, $18, this.runId, this._parentRunId, this.tags, _));
      } catch (O) {
        if ((Y.raiseError ? console.error : console.warn)(`Error in handler ${Y.constructor.name}, handleLLMEnd: ${O}`), Y.raiseError) throw O;
      }
    }, Y.awaitHandlers)));
  }
};
var fX = class extends GP {
  getChild($18) {
    let q = new OK(this.runId);
    if (q.setHandlers(this.inheritableHandlers), q.addTags(this.inheritableTags), q.addMetadata(this.inheritableMetadata), $18) q.addTags([$18], false);
    return q;
  }
  async handleChainError($18, q, K, P, _) {
    await Promise.all(this.handlers.map((Y) => c6(async () => {
      var _a2;
      if (!Y.ignoreChain) try {
        await ((_a2 = Y.handleChainError) == null ? void 0 : _a2.call(Y, $18, this.runId, this._parentRunId, this.tags, _));
      } catch (O) {
        if ((Y.raiseError ? console.error : console.warn)(`Error in handler ${Y.constructor.name}, handleChainError: ${O}`), Y.raiseError) throw O;
      }
    }, Y.awaitHandlers)));
  }
  async handleChainEnd($18, q, K, P, _) {
    await Promise.all(this.handlers.map((Y) => c6(async () => {
      var _a2;
      if (!Y.ignoreChain) try {
        await ((_a2 = Y.handleChainEnd) == null ? void 0 : _a2.call(Y, $18, this.runId, this._parentRunId, this.tags, _));
      } catch (O) {
        if ((Y.raiseError ? console.error : console.warn)(`Error in handler ${Y.constructor.name}, handleChainEnd: ${O}`), Y.raiseError) throw O;
      }
    }, Y.awaitHandlers)));
  }
  async handleAgentAction($18) {
    await Promise.all(this.handlers.map((q) => c6(async () => {
      var _a2;
      if (!q.ignoreAgent) try {
        await ((_a2 = q.handleAgentAction) == null ? void 0 : _a2.call(q, $18, this.runId, this._parentRunId, this.tags));
      } catch (K) {
        if ((q.raiseError ? console.error : console.warn)(`Error in handler ${q.constructor.name}, handleAgentAction: ${K}`), q.raiseError) throw K;
      }
    }, q.awaitHandlers)));
  }
  async handleAgentEnd($18) {
    await Promise.all(this.handlers.map((q) => c6(async () => {
      var _a2;
      if (!q.ignoreAgent) try {
        await ((_a2 = q.handleAgentEnd) == null ? void 0 : _a2.call(q, $18, this.runId, this._parentRunId, this.tags));
      } catch (K) {
        if ((q.raiseError ? console.error : console.warn)(`Error in handler ${q.constructor.name}, handleAgentEnd: ${K}`), q.raiseError) throw K;
      }
    }, q.awaitHandlers)));
  }
};
var ZX = class extends GP {
  getChild($18) {
    let q = new OK(this.runId);
    if (q.setHandlers(this.inheritableHandlers), q.addTags(this.inheritableTags), q.addMetadata(this.inheritableMetadata), $18) q.addTags([$18], false);
    return q;
  }
  async handleToolError($18) {
    await Promise.all(this.handlers.map((q) => c6(async () => {
      var _a2;
      if (!q.ignoreAgent) try {
        await ((_a2 = q.handleToolError) == null ? void 0 : _a2.call(q, $18, this.runId, this._parentRunId, this.tags));
      } catch (K) {
        if ((q.raiseError ? console.error : console.warn)(`Error in handler ${q.constructor.name}, handleToolError: ${K}`), q.raiseError) throw K;
      }
    }, q.awaitHandlers)));
  }
  async handleToolEnd($18) {
    await Promise.all(this.handlers.map((q) => c6(async () => {
      var _a2;
      if (!q.ignoreAgent) try {
        await ((_a2 = q.handleToolEnd) == null ? void 0 : _a2.call(q, $18, this.runId, this._parentRunId, this.tags));
      } catch (K) {
        if ((q.raiseError ? console.error : console.warn)(`Error in handler ${q.constructor.name}, handleToolEnd: ${K}`), q.raiseError) throw K;
      }
    }, q.awaitHandlers)));
  }
};
var OK = class $3 extends TX {
  constructor(q, K) {
    super();
    __publicField(this, "handlers", []);
    __publicField(this, "inheritableHandlers", []);
    __publicField(this, "tags", []);
    __publicField(this, "inheritableTags", []);
    __publicField(this, "metadata", {});
    __publicField(this, "inheritableMetadata", {});
    __publicField(this, "name", "callback_manager");
    __publicField(this, "_parentRunId");
    this.handlers = (K == null ? void 0 : K.handlers) ?? this.handlers, this.inheritableHandlers = (K == null ? void 0 : K.inheritableHandlers) ?? this.inheritableHandlers, this.tags = (K == null ? void 0 : K.tags) ?? this.tags, this.inheritableTags = (K == null ? void 0 : K.inheritableTags) ?? this.inheritableTags, this.metadata = (K == null ? void 0 : K.metadata) ?? this.metadata, this.inheritableMetadata = (K == null ? void 0 : K.inheritableMetadata) ?? this.inheritableMetadata, this._parentRunId = q;
  }
  getParentRunId() {
    return this._parentRunId;
  }
  async handleLLMStart(q, K, P = void 0, _ = void 0, Y = void 0, O = void 0, z = void 0, J = void 0) {
    return Promise.all(K.map(async (T, X) => {
      let f = X === 0 && P ? P : nq();
      return await Promise.all(this.handlers.map((V) => {
        if (V.ignoreLLM) return;
        if (v_(V)) V._createRunForLLMStart(q, [T], f, this._parentRunId, Y, this.tags, this.metadata, J);
        return c6(async () => {
          var _a2;
          try {
            await ((_a2 = V.handleLLMStart) == null ? void 0 : _a2.call(V, q, [T], f, this._parentRunId, Y, this.tags, this.metadata, J));
          } catch (M) {
            if ((V.raiseError ? console.error : console.warn)(`Error in handler ${V.constructor.name}, handleLLMStart: ${M}`), V.raiseError) throw M;
          }
        }, V.awaitHandlers);
      })), new gY(f, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);
    }));
  }
  async handleChatModelStart(q, K, P = void 0, _ = void 0, Y = void 0, O = void 0, z = void 0, J = void 0) {
    return Promise.all(K.map(async (T, X) => {
      let f = X === 0 && P ? P : nq();
      return await Promise.all(this.handlers.map((V) => {
        if (V.ignoreLLM) return;
        if (v_(V)) V._createRunForChatModelStart(q, [T], f, this._parentRunId, Y, this.tags, this.metadata, J);
        return c6(async () => {
          var _a2, _b2;
          try {
            if (V.handleChatModelStart) await ((_a2 = V.handleChatModelStart) == null ? void 0 : _a2.call(V, q, [T], f, this._parentRunId, Y, this.tags, this.metadata, J));
            else if (V.handleLLMStart) {
              let M = LT(T);
              await ((_b2 = V.handleLLMStart) == null ? void 0 : _b2.call(V, q, [M], f, this._parentRunId, Y, this.tags, this.metadata, J));
            }
          } catch (M) {
            if ((V.raiseError ? console.error : console.warn)(`Error in handler ${V.constructor.name}, handleLLMStart: ${M}`), V.raiseError) throw M;
          }
        }, V.awaitHandlers);
      })), new gY(f, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);
    }));
  }
  async handleChainStart(q, K, P = nq(), _ = void 0, Y = void 0, O = void 0, z = void 0) {
    return await Promise.all(this.handlers.map((J) => {
      if (J.ignoreChain) return;
      if (v_(J)) J._createRunForChainStart(q, K, P, this._parentRunId, this.tags, this.metadata, _, z);
      return c6(async () => {
        var _a2;
        try {
          await ((_a2 = J.handleChainStart) == null ? void 0 : _a2.call(J, q, K, P, this._parentRunId, this.tags, this.metadata, _, z));
        } catch (T) {
          if ((J.raiseError ? console.error : console.warn)(`Error in handler ${J.constructor.name}, handleChainStart: ${T}`), J.raiseError) throw T;
        }
      }, J.awaitHandlers);
    })), new fX(P, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);
  }
  async handleToolStart(q, K, P = nq(), _ = void 0, Y = void 0, O = void 0, z = void 0) {
    return await Promise.all(this.handlers.map((J) => {
      if (J.ignoreAgent) return;
      if (v_(J)) J._createRunForToolStart(q, K, P, this._parentRunId, this.tags, this.metadata, z);
      return c6(async () => {
        var _a2;
        try {
          await ((_a2 = J.handleToolStart) == null ? void 0 : _a2.call(J, q, K, P, this._parentRunId, this.tags, this.metadata, z));
        } catch (T) {
          if ((J.raiseError ? console.error : console.warn)(`Error in handler ${J.constructor.name}, handleToolStart: ${T}`), J.raiseError) throw T;
        }
      }, J.awaitHandlers);
    })), new ZX(P, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);
  }
  async handleRetrieverStart(q, K, P = nq(), _ = void 0, Y = void 0, O = void 0, z = void 0) {
    return await Promise.all(this.handlers.map((J) => {
      if (J.ignoreRetriever) return;
      if (v_(J)) J._createRunForRetrieverStart(q, K, P, this._parentRunId, this.tags, this.metadata, z);
      return c6(async () => {
        var _a2;
        try {
          await ((_a2 = J.handleRetrieverStart) == null ? void 0 : _a2.call(J, q, K, P, this._parentRunId, this.tags, this.metadata, z));
        } catch (T) {
          if ((J.raiseError ? console.error : console.warn)(`Error in handler ${J.constructor.name}, handleRetrieverStart: ${T}`), J.raiseError) throw T;
        }
      }, J.awaitHandlers);
    })), new wX(P, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);
  }
  async handleCustomEvent(q, K, P, _, Y) {
    await Promise.all(this.handlers.map((O) => c6(async () => {
      var _a2;
      if (!O.ignoreCustomEvent) try {
        await ((_a2 = O.handleCustomEvent) == null ? void 0 : _a2.call(O, q, K, P, this.tags, this.metadata));
      } catch (z) {
        if ((O.raiseError ? console.error : console.warn)(`Error in handler ${O.constructor.name}, handleCustomEvent: ${z}`), O.raiseError) throw z;
      }
    }, O.awaitHandlers)));
  }
  addHandler(q, K = true) {
    if (this.handlers.push(q), K) this.inheritableHandlers.push(q);
  }
  removeHandler(q) {
    this.handlers = this.handlers.filter((K) => K !== q), this.inheritableHandlers = this.inheritableHandlers.filter((K) => K !== q);
  }
  setHandlers(q, K = true) {
    this.handlers = [], this.inheritableHandlers = [];
    for (let P of q) this.addHandler(P, K);
  }
  addTags(q, K = true) {
    if (this.removeTags(q), this.tags.push(...q), K) this.inheritableTags.push(...q);
  }
  removeTags(q) {
    this.tags = this.tags.filter((K) => !q.includes(K)), this.inheritableTags = this.inheritableTags.filter((K) => !q.includes(K));
  }
  addMetadata(q, K = true) {
    if (this.metadata = { ...this.metadata, ...q }, K) this.inheritableMetadata = { ...this.inheritableMetadata, ...q };
  }
  removeMetadata(q) {
    for (let K of Object.keys(q)) delete this.metadata[K], delete this.inheritableMetadata[K];
  }
  copy(q = [], K = true) {
    let P = new $3(this._parentRunId);
    for (let _ of this.handlers) {
      let Y = this.inheritableHandlers.includes(_);
      P.addHandler(_, Y);
    }
    for (let _ of this.tags) {
      let Y = this.inheritableTags.includes(_);
      P.addTags([_], Y);
    }
    for (let _ of Object.keys(this.metadata)) {
      let Y = Object.keys(this.inheritableMetadata).includes(_);
      P.addMetadata({ [_]: this.metadata[_] }, Y);
    }
    for (let _ of q) {
      if (P.handlers.filter((Y) => Y.name === "console_callback_handler").some((Y) => Y.name === _.name)) continue;
      P.addHandler(_, K);
    }
    return P;
  }
  static fromHandlers(q) {
    class K extends P_ {
      constructor() {
        super();
        __publicField(this, "name", nq());
        Object.assign(this, q);
      }
    }
    let P = new this();
    return P.addHandler(new K()), P;
  }
  static configure(q, K, P, _, Y, O, z) {
    return this._configureSync(q, K, P, _, Y, O, z);
  }
  static _configureSync(q, K, P, _, Y, O, z) {
    var _a2, _b2;
    let J;
    if (q || K) {
      if (Array.isArray(q) || !q) J = new $3(), J.setHandlers((q == null ? void 0 : q.map(r_)) ?? [], true);
      else J = q;
      J = J.copy(Array.isArray(K) ? K.map(r_) : K == null ? void 0 : K.handlers, false);
    }
    let T = M8("LANGCHAIN_VERBOSE") === "true" || (z == null ? void 0 : z.verbose), X = ((_a2 = kP.getTraceableRunTree()) == null ? void 0 : _a2.tracingEnabled) || HX(), f = X || (M8("LANGCHAIN_TRACING") ?? false);
    if (T || f) {
      if (!J) J = new $3();
      if (T && !J.handlers.some((V) => V.name === a1.prototype.name)) {
        let V = new a1();
        J.addHandler(V, true);
      }
      if (f && !J.handlers.some((V) => V.name === "langchain_tracer")) {
        if (X) {
          let V = new kP();
          J.addHandler(V, true);
        }
      }
      if (X) {
        let V = kP.getTraceableRunTree();
        if (V && J._parentRunId === void 0) J._parentRunId = V.id, (_b2 = J.handlers.find((N) => N.name === "langchain_tracer")) == null ? void 0 : _b2.updateFromRunTree(V);
      }
    }
    for (let { contextVar: V, inheritable: M = true, handlerClass: N, envVar: h } of JX()) {
      let E = h && M8(h) === "true" && N, I, D = V !== void 0 ? LY(V) : void 0;
      if (D && dO(D)) I = D;
      else if (E) I = new N({});
      if (I !== void 0) {
        if (!J) J = new $3();
        if (!J.handlers.some((g) => g.name === I.name)) J.addHandler(I, M);
      }
    }
    if (P || _) {
      if (J) J.addTags(P ?? []), J.addTags(_ ?? [], false);
    }
    if (Y || O) {
      if (J) J.addMetadata(Y ?? {}), J.addMetadata(O ?? {}, false);
    }
    return J;
  }
};
function r_($18) {
  if ("name" in $18) return $18;
  return P_.fromMethods($18);
}
var bY = class {
  getStore() {
    return;
  }
  run($18, q) {
    return q();
  }
  enterWith($18) {
    return;
  }
};
var cR = new bY();
var XX = Symbol.for("lc:child_config");
var mR = class {
  getInstance() {
    return DK() ?? cR;
  }
  getRunnableConfig() {
    var _a2, _b2;
    return (_b2 = (_a2 = this.getInstance().getStore()) == null ? void 0 : _a2.extra) == null ? void 0 : _b2[XX];
  }
  runWithConfig($18, q, K) {
    var _a2;
    let P = OK._configureSync($18 == null ? void 0 : $18.callbacks, void 0, $18 == null ? void 0 : $18.tags, void 0, $18 == null ? void 0 : $18.metadata), _ = this.getInstance(), Y = _.getStore(), O = P == null ? void 0 : P.getParentRunId(), z = (_a2 = P == null ? void 0 : P.handlers) == null ? void 0 : _a2.find((T) => (T == null ? void 0 : T.name) === "langchain_tracer"), J;
    if (z && O) J = z.getRunTreeWithTracingConfig(O);
    else if (!K) J = new Oq({ name: "<runnable_lambda>", tracingEnabled: false });
    if (J) J.extra = { ...J.extra, [XX]: $18 };
    if (Y !== void 0 && Y[IK] !== void 0) {
      if (J === void 0) J = {};
      J[IK] = Y[IK];
    }
    return _.run(J, q);
  }
  initializeGlobalInstance($18) {
    if (DK() === void 0) qT($18);
  }
};
var tq = new mR();
var dR = {};
Z6(dR, { AsyncLocalStorageProviderSingleton: () => tq, MockAsyncLocalStorage: () => bY, _CONTEXT_VARIABLES_KEY: () => IK });
var $9 = 25;
async function w8($18) {
  return OK._configureSync($18 == null ? void 0 : $18.callbacks, void 0, $18 == null ? void 0 : $18.tags, void 0, $18 == null ? void 0 : $18.metadata);
}
function yY(...$18) {
  let q = {};
  for (let K of $18.filter((P) => !!P)) for (let P of Object.keys(K)) if (P === "metadata") q[P] = { ...q[P], ...K[P] };
  else if (P === "tags") {
    let _ = q[P] ?? [];
    q[P] = [...new Set(_.concat(K[P] ?? []))];
  } else if (P === "configurable") q[P] = { ...q[P], ...K[P] };
  else if (P === "timeout") {
    if (q.timeout === void 0) q.timeout = K.timeout;
    else if (K.timeout !== void 0) q.timeout = Math.min(q.timeout, K.timeout);
  } else if (P === "signal") {
    if (q.signal === void 0) q.signal = K.signal;
    else if (K.signal !== void 0) if ("any" in AbortSignal) q.signal = AbortSignal.any([q.signal, K.signal]);
    else q.signal = K.signal;
  } else if (P === "callbacks") {
    let _ = q.callbacks, Y = K.callbacks;
    if (Array.isArray(Y)) if (!_) q.callbacks = Y;
    else if (Array.isArray(_)) q.callbacks = _.concat(Y);
    else {
      let O = _.copy();
      for (let z of Y) O.addHandler(r_(z), true);
      q.callbacks = O;
    }
    else if (Y) if (!_) q.callbacks = Y;
    else if (Array.isArray(_)) {
      let O = Y.copy();
      for (let z of _) O.addHandler(r_(z), true);
      q.callbacks = O;
    } else q.callbacks = new OK(Y._parentRunId, { handlers: _.handlers.concat(Y.handlers), inheritableHandlers: _.inheritableHandlers.concat(Y.inheritableHandlers), tags: Array.from(new Set(_.tags.concat(Y.tags))), inheritableTags: Array.from(new Set(_.inheritableTags.concat(Y.inheritableTags))), metadata: { ..._.metadata, ...Y.metadata } });
  } else {
    let _ = P;
    q[_] = K[_] ?? q[_];
  }
  return q;
}
var lR = /* @__PURE__ */ new Set(["string", "number", "boolean"]);
function N6($18) {
  var _a2;
  let q = tq.getRunnableConfig(), K = { tags: [], metadata: {}, recursionLimit: 25, runId: void 0 };
  if (q) {
    let { runId: P, runName: _, ...Y } = q;
    K = Object.entries(Y).reduce((O, [z, J]) => {
      if (J !== void 0) O[z] = J;
      return O;
    }, K);
  }
  if ($18) K = Object.entries($18).reduce((P, [_, Y]) => {
    if (Y !== void 0) P[_] = Y;
    return P;
  }, K);
  if (K == null ? void 0 : K.configurable) {
    for (let P of Object.keys(K.configurable)) if (lR.has(typeof K.configurable[P]) && !((_a2 = K.metadata) == null ? void 0 : _a2[P])) {
      if (!K.metadata) K.metadata = {};
      K.metadata[P] = K.configurable[P];
    }
  }
  if (K.timeout !== void 0) {
    if (K.timeout <= 0) throw Error("Timeout must be a positive number");
    let P = AbortSignal.timeout(K.timeout);
    if (K.signal !== void 0) {
      if ("any" in AbortSignal) K.signal = AbortSignal.any([K.signal, P]);
    } else K.signal = P;
    delete K.timeout;
  }
  return K;
}
function hq($18 = {}, { callbacks: q, maxConcurrency: K, recursionLimit: P, runName: _, configurable: Y, runId: O } = {}) {
  let z = N6($18);
  if (q !== void 0) delete z.runName, z.callbacks = q;
  if (P !== void 0) z.recursionLimit = P;
  if (K !== void 0) z.maxConcurrency = K;
  if (_ !== void 0) z.runName = _;
  if (Y !== void 0) z.configurable = { ...z.configurable, ...Y };
  if (O !== void 0) delete z.runId;
  return z;
}
function YK($18) {
  if (!$18) return;
  return { configurable: $18.configurable, recursionLimit: $18.recursionLimit, callbacks: $18.callbacks, tags: $18.tags, metadata: $18.metadata, maxConcurrency: $18.maxConcurrency, timeout: $18.timeout, signal: $18.signal, store: $18.store };
}
async function m8($18, q) {
  if (q === void 0) return $18;
  let K;
  return Promise.race([$18.catch((P) => {
    if (!(q == null ? void 0 : q.aborted)) throw P;
    else return;
  }), new Promise((P, _) => {
    if (K = () => {
      _(o_(q));
    }, q.addEventListener("abort", K), q.aborted) _(o_(q));
  })]).finally(() => q.removeEventListener("abort", K));
}
function o_($18) {
  if (($18 == null ? void 0 : $18.reason) instanceof Error) return $18.reason;
  if (typeof ($18 == null ? void 0 : $18.reason) === "string") return Error($18.reason);
  return Error("Aborted");
}
var rR = {};
Z6(rR, { AsyncGeneratorWithSetup: () => uK, IterableReadableStream: () => yq, atee: () => q9, concat: () => K9, pipeGeneratorWithSetup: () => uY });
var yq = class $4 extends ReadableStream {
  constructor() {
    super(...arguments);
    __publicField(this, "reader");
  }
  ensureReader() {
    if (!this.reader) this.reader = this.getReader();
  }
  async next() {
    this.ensureReader();
    try {
      let q = await this.reader.read();
      if (q.done) return this.reader.releaseLock(), { done: true, value: void 0 };
      else return { done: false, value: q.value };
    } catch (q) {
      throw this.reader.releaseLock(), q;
    }
  }
  async return() {
    if (this.ensureReader(), this.locked) {
      let q = this.reader.cancel();
      this.reader.releaseLock(), await q;
    }
    return { done: true, value: void 0 };
  }
  async throw(q) {
    if (this.ensureReader(), this.locked) {
      let K = this.reader.cancel();
      this.reader.releaseLock(), await K;
    }
    throw q;
  }
  [Symbol.asyncIterator]() {
    return this;
  }
  async [Symbol.asyncDispose]() {
    await this.return();
  }
  static fromReadableStream(q) {
    let K = q.getReader();
    return new $4({ start(P) {
      return _();
      function _() {
        return K.read().then(({ done: Y, value: O }) => {
          if (Y) {
            P.close();
            return;
          }
          return P.enqueue(O), _();
        });
      }
    }, cancel() {
      K.releaseLock();
    } });
  }
  static fromAsyncGenerator(q) {
    return new $4({ async pull(K) {
      let { value: P, done: _ } = await q.next();
      if (_) K.close();
      K.enqueue(P);
    }, async cancel(K) {
      await q.return(K);
    } });
  }
};
function q9($18, q = 2) {
  let K = Array.from({ length: q }, () => []);
  return K.map(async function* (_) {
    while (true) if (_.length === 0) {
      let Y = await $18.next();
      for (let O of K) O.push(Y);
    } else if (_[0].done) return;
    else yield _.shift().value;
  });
}
function K9($18, q) {
  if (Array.isArray($18) && Array.isArray(q)) return $18.concat(q);
  else if (typeof $18 === "string" && typeof q === "string") return $18 + q;
  else if (typeof $18 === "number" && typeof q === "number") return $18 + q;
  else if ("concat" in $18 && typeof $18.concat === "function") return $18.concat(q);
  else if (typeof $18 === "object" && typeof q === "object") {
    let K = { ...$18 };
    for (let [P, _] of Object.entries(q)) if (P in K && !Array.isArray(K[P])) K[P] = K9(K[P], _);
    else K[P] = _;
    return K;
  } else throw Error(`Cannot concat ${typeof $18} and ${typeof q}`);
}
var uK = class {
  constructor($18) {
    __publicField(this, "generator");
    __publicField(this, "setup");
    __publicField(this, "config");
    __publicField(this, "signal");
    __publicField(this, "firstResult");
    __publicField(this, "firstResultUsed", false);
    var _a2;
    this.generator = $18.generator, this.config = $18.config, this.signal = $18.signal ?? ((_a2 = this.config) == null ? void 0 : _a2.signal), this.setup = new Promise((q, K) => {
      tq.runWithConfig(YK($18.config), async () => {
        if (this.firstResult = $18.generator.next(), $18.startSetup) this.firstResult.then($18.startSetup).then(q, K);
        else this.firstResult.then((P) => q(void 0), K);
      }, true);
    });
  }
  async next(...$18) {
    var _a2;
    if ((_a2 = this.signal) == null ? void 0 : _a2.throwIfAborted(), !this.firstResultUsed) return this.firstResultUsed = true, this.firstResult;
    return tq.runWithConfig(YK(this.config), this.signal ? async () => {
      return m8(this.generator.next(...$18), this.signal);
    } : async () => {
      return this.generator.next(...$18);
    }, true);
  }
  async return($18) {
    return this.generator.return($18);
  }
  async throw($18) {
    return this.generator.throw($18);
  }
  [Symbol.asyncIterator]() {
    return this;
  }
  async [Symbol.asyncDispose]() {
    await this.return();
  }
};
async function uY($18, q, K, P, ..._) {
  let Y = new uK({ generator: q, startSetup: K, signal: P }), O = await Y.setup;
  return { output: $18(Y, O, ..._), setup: O };
}
var oR = Object.prototype.hasOwnProperty;
function kX($18, q) {
  return oR.call($18, q);
}
function GX($18) {
  if (Array.isArray($18)) {
    let K = Array($18.length);
    for (let P = 0; P < K.length; P++) K[P] = "" + P;
    return K;
  }
  if (Object.keys) return Object.keys($18);
  let q = [];
  for (let K in $18) if (kX($18, K)) q.push(K);
  return q;
}
function h8($18) {
  switch (typeof $18) {
    case "object":
      return JSON.parse(JSON.stringify($18));
    case "undefined":
      return null;
    default:
      return $18;
  }
}
function P9($18) {
  let q = 0, K = $18.length, P;
  while (q < K) {
    if (P = $18.charCodeAt(q), P >= 48 && P <= 57) {
      q++;
      continue;
    }
    return false;
  }
  return true;
}
function xY($18) {
  if ($18.indexOf("/") === -1 && $18.indexOf("~") === -1) return $18;
  return $18.replace(/~/g, "~0").replace(/\//g, "~1");
}
function O9($18) {
  return $18.replace(/~1/g, "/").replace(/~0/g, "~");
}
function _9($18) {
  if ($18 === void 0) return true;
  if ($18) {
    if (Array.isArray($18)) {
      for (let K = 0, P = $18.length; K < P; K++) if (_9($18[K])) return true;
    } else if (typeof $18 === "object") {
      let K = GX($18), P = K.length;
      for (var q = 0; q < P; q++) if (_9($18[K[q]])) return true;
    }
  }
  return false;
}
function AX($18, q) {
  let K = [$18];
  for (let P in q) {
    let _ = typeof q[P] === "object" ? JSON.stringify(q[P], null, 2) : q[P];
    if (typeof _ < "u") K.push(`${P}: ${_}`);
  }
  return K.join(`
`);
}
var Y9 = class extends Error {
  constructor($18, q, K, P, _) {
    super(AX($18, { name: q, index: K, operation: P, tree: _ }));
    this.name = q, this.index = K, this.operation = P, this.tree = _, Object.setPrototypeOf(this, new.target.prototype), this.message = AX($18, { name: q, index: K, operation: P, tree: _ });
  }
};
var pY = {};
Z6(pY, { JsonPatchError: () => m6, _areEquals: () => i_, applyOperation: () => xK, applyPatch: () => W_, applyReducer: () => VX, deepClone: () => nR, getValueByPointer: () => VP, validate: () => cY, validator: () => SP });
var m6 = Y9;
var nR = h8;
var n_ = { add: function($18, q, K) {
  return $18[q] = this.value, { newDocument: K };
}, remove: function($18, q, K) {
  var P = $18[q];
  return delete $18[q], { newDocument: K, removed: P };
}, replace: function($18, q, K) {
  var P = $18[q];
  return $18[q] = this.value, { newDocument: K, removed: P };
}, move: function($18, q, K) {
  let P = VP(K, this.path);
  if (P) P = h8(P);
  let _ = xK(K, { op: "remove", path: this.from }).removed;
  return xK(K, { op: "add", path: this.path, value: _ }), { newDocument: K, removed: P };
}, copy: function($18, q, K) {
  let P = VP(K, this.from);
  return xK(K, { op: "add", path: this.path, value: h8(P) }), { newDocument: K };
}, test: function($18, q, K) {
  return { newDocument: K, test: i_($18[q], this.value) };
}, _get: function($18, q, K) {
  return this.value = $18[q], { newDocument: K };
} };
var iR = { add: function($18, q, K) {
  if (P9(q)) $18.splice(q, 0, this.value);
  else $18[q] = this.value;
  return { newDocument: K, index: q };
}, remove: function($18, q, K) {
  var P = $18.splice(q, 1);
  return { newDocument: K, removed: P[0] };
}, replace: function($18, q, K) {
  var P = $18[q];
  return $18[q] = this.value, { newDocument: K, removed: P };
}, move: n_.move, copy: n_.copy, test: n_.test, _get: n_._get };
function VP($18, q) {
  if (q == "") return $18;
  var K = { op: "_get", path: q };
  return xK($18, K), K.value;
}
function xK($18, q, K = false, P = true, _ = true, Y = 0) {
  if (K) if (typeof K == "function") K(q, 0, $18, q.path);
  else SP(q, 0);
  if (q.path === "") {
    let O = { newDocument: $18 };
    if (q.op === "add") return O.newDocument = q.value, O;
    else if (q.op === "replace") return O.newDocument = q.value, O.removed = $18, O;
    else if (q.op === "move" || q.op === "copy") {
      if (O.newDocument = VP($18, q.from), q.op === "move") O.removed = $18;
      return O;
    } else if (q.op === "test") {
      if (O.test = i_($18, q.value), O.test === false) throw new m6("Test operation failed", "TEST_OPERATION_FAILED", Y, q, $18);
      return O.newDocument = $18, O;
    } else if (q.op === "remove") return O.removed = $18, O.newDocument = null, O;
    else if (q.op === "_get") return q.value = $18, O;
    else if (K) throw new m6("Operation `op` property is not one of operations defined in RFC-6902", "OPERATION_OP_INVALID", Y, q, $18);
    else return O;
  } else {
    if (!P) $18 = h8($18);
    let z = (q.path || "").split("/"), J = $18, T = 1, X = z.length, f = void 0, V, M;
    if (typeof K == "function") M = K;
    else M = SP;
    while (true) {
      if (V = z[T], V && V.indexOf("~") != -1) V = O9(V);
      if (_ && (V == "__proto__" || V == "prototype" && T > 0 && z[T - 1] == "constructor")) throw TypeError("JSON-Patch: modifying `__proto__` or `constructor/prototype` prop is banned for security reasons, if this was on purpose, please set `banPrototypeModifications` flag false and pass it to this function. More info in fast-json-patch README");
      if (K) {
        if (f === void 0) {
          if (J[V] === void 0) f = z.slice(0, T).join("/");
          else if (T == X - 1) f = q.path;
          if (f !== void 0) M(q, 0, $18, f);
        }
      }
      if (T++, Array.isArray(J)) {
        if (V === "-") V = J.length;
        else if (K && !P9(V)) throw new m6("Expected an unsigned base-10 integer value, making the new referenced value the array element with the zero-based index", "OPERATION_PATH_ILLEGAL_ARRAY_INDEX", Y, q, $18);
        else if (P9(V)) V = ~~V;
        if (T >= X) {
          if (K && q.op === "add" && V > J.length) throw new m6("The specified index MUST NOT be greater than the number of elements in the array", "OPERATION_VALUE_OUT_OF_BOUNDS", Y, q, $18);
          let N = iR[q.op].call(q, J, V, $18);
          if (N.test === false) throw new m6("Test operation failed", "TEST_OPERATION_FAILED", Y, q, $18);
          return N;
        }
      } else if (T >= X) {
        let N = n_[q.op].call(q, J, V, $18);
        if (N.test === false) throw new m6("Test operation failed", "TEST_OPERATION_FAILED", Y, q, $18);
        return N;
      }
      if (J = J[V], K && T < X && (!J || typeof J !== "object")) throw new m6("Cannot perform operation at the desired path", "OPERATION_PATH_UNRESOLVABLE", Y, q, $18);
    }
  }
}
function W_($18, q, K, P = true, _ = true) {
  if (K) {
    if (!Array.isArray(q)) throw new m6("Patch sequence must be an array", "SEQUENCE_NOT_AN_ARRAY");
  }
  if (!P) $18 = h8($18);
  let Y = Array(q.length);
  for (let O = 0, z = q.length; O < z; O++) Y[O] = xK($18, q[O], K, true, _, O), $18 = Y[O].newDocument;
  return Y.newDocument = $18, Y;
}
function VX($18, q, K) {
  let P = xK($18, q);
  if (P.test === false) throw new m6("Test operation failed", "TEST_OPERATION_FAILED", K, q, $18);
  return P.newDocument;
}
function SP($18, q, K, P) {
  if (typeof $18 !== "object" || $18 === null || Array.isArray($18)) throw new m6("Operation is not an object", "OPERATION_NOT_AN_OBJECT", q, $18, K);
  else if (!n_[$18.op]) throw new m6("Operation `op` property is not one of operations defined in RFC-6902", "OPERATION_OP_INVALID", q, $18, K);
  else if (typeof $18.path !== "string") throw new m6("Operation `path` property is not a string", "OPERATION_PATH_INVALID", q, $18, K);
  else if ($18.path.indexOf("/") !== 0 && $18.path.length > 0) throw new m6('Operation `path` property must start with "/"', "OPERATION_PATH_INVALID", q, $18, K);
  else if (($18.op === "move" || $18.op === "copy") && typeof $18.from !== "string") throw new m6("Operation `from` property is not present (applicable in `move` and `copy` operations)", "OPERATION_FROM_REQUIRED", q, $18, K);
  else if (($18.op === "add" || $18.op === "replace" || $18.op === "test") && $18.value === void 0) throw new m6("Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)", "OPERATION_VALUE_REQUIRED", q, $18, K);
  else if (($18.op === "add" || $18.op === "replace" || $18.op === "test") && _9($18.value)) throw new m6("Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)", "OPERATION_VALUE_CANNOT_CONTAIN_UNDEFINED", q, $18, K);
  else if (K) {
    if ($18.op == "add") {
      var _ = $18.path.split("/").length, Y = P.split("/").length;
      if (_ !== Y + 1 && _ !== Y) throw new m6("Cannot perform an `add` operation at the desired path", "OPERATION_PATH_CANNOT_ADD", q, $18, K);
    } else if ($18.op === "replace" || $18.op === "remove" || $18.op === "_get") {
      if ($18.path !== P) throw new m6("Cannot perform the operation at a path that does not exist", "OPERATION_PATH_UNRESOLVABLE", q, $18, K);
    } else if ($18.op === "move" || $18.op === "copy") {
      var O = { op: "_get", path: $18.from, value: void 0 }, z = cY([O], K);
      if (z && z.name === "OPERATION_PATH_UNRESOLVABLE") throw new m6("Cannot perform the operation from a path that does not exist", "OPERATION_FROM_UNRESOLVABLE", q, $18, K);
    }
  }
}
function cY($18, q, K) {
  try {
    if (!Array.isArray($18)) throw new m6("Patch sequence must be an array", "SEQUENCE_NOT_AN_ARRAY");
    if (q) W_(h8(q), h8($18), K || true);
    else {
      K = K || SP;
      for (var P = 0; P < $18.length; P++) K($18[P], P, q, void 0);
    }
  } catch (_) {
    if (_ instanceof m6) return _;
    else throw _;
  }
}
function i_($18, q) {
  if ($18 === q) return true;
  if ($18 && q && typeof $18 == "object" && typeof q == "object") {
    var K = Array.isArray($18), P = Array.isArray(q), _, Y, O;
    if (K && P) {
      if (Y = $18.length, Y != q.length) return false;
      for (_ = Y; _-- !== 0; ) if (!i_($18[_], q[_])) return false;
      return true;
    }
    if (K != P) return false;
    var z = Object.keys($18);
    if (Y = z.length, Y !== Object.keys(q).length) return false;
    for (_ = Y; _-- !== 0; ) if (!q.hasOwnProperty(z[_])) return false;
    for (_ = Y; _-- !== 0; ) if (O = z[_], !i_($18[O], q[O])) return false;
    return true;
  }
  return $18 !== $18 && q !== q;
}
var ie = { ...pY, JsonPatchError: Y9, deepClone: h8, escapePathComponent: xY, unescapePathComponent: O9 };
var BR = {};
Z6(BR, { LogStreamCallbackHandler: () => v9, RunLog: () => j9, RunLogPatch: () => d8, isLogStreamHandler: () => mY });
var d8 = class {
  constructor($18) {
    __publicField(this, "ops");
    this.ops = $18.ops ?? [];
  }
  concat($18) {
    let q = this.ops.concat($18.ops), K = W_({}, q);
    return new j9({ ops: q, state: K[K.length - 1].newDocument });
  }
};
var j9 = class $5 extends d8 {
  constructor(q) {
    super(q);
    __publicField(this, "state");
    this.state = q.state;
  }
  concat(q) {
    let K = this.ops.concat(q.ops), P = W_(this.state, q.ops);
    return new $5({ ops: K, state: P[P.length - 1].newDocument });
  }
  static fromRunLogPatch(q) {
    let K = W_({}, q.ops);
    return new $5({ ops: q.ops, state: K[K.length - 1].newDocument });
  }
};
var mY = ($18) => $18.name === "log_stream_tracer";
async function SX($18, q) {
  if (q === "original") throw Error("Do not assign inputs with original schema drop the key for now. When inputs are added to streamLog they should be added with standardized schema for streaming events.");
  let { inputs: K } = $18;
  if (["retriever", "llm", "prompt"].includes($18.run_type)) return K;
  if (Object.keys(K).length === 1 && (K == null ? void 0 : K.input) === "") return;
  return K.input;
}
async function MX($18, q) {
  let { outputs: K } = $18;
  if (q === "original") return K;
  if (["retriever", "llm", "prompt"].includes($18.run_type)) return K;
  if (K !== void 0 && Object.keys(K).length === 1 && (K == null ? void 0 : K.output) !== void 0) return K.output;
  return K;
}
function tR($18) {
  return $18 !== void 0 && $18.message !== void 0;
}
var v9 = class extends E8 {
  constructor($18) {
    super({ _awaitHandler: true, ...$18 });
    __publicField(this, "autoClose", true);
    __publicField(this, "includeNames");
    __publicField(this, "includeTypes");
    __publicField(this, "includeTags");
    __publicField(this, "excludeNames");
    __publicField(this, "excludeTypes");
    __publicField(this, "excludeTags");
    __publicField(this, "_schemaFormat", "original");
    __publicField(this, "rootId");
    __publicField(this, "keyMapByRunId", {});
    __publicField(this, "counterMapByRunName", {});
    __publicField(this, "transformStream");
    __publicField(this, "writer");
    __publicField(this, "receiveStream");
    __publicField(this, "name", "log_stream_tracer");
    __publicField(this, "lc_prefer_streaming", true);
    this.autoClose = ($18 == null ? void 0 : $18.autoClose) ?? true, this.includeNames = $18 == null ? void 0 : $18.includeNames, this.includeTypes = $18 == null ? void 0 : $18.includeTypes, this.includeTags = $18 == null ? void 0 : $18.includeTags, this.excludeNames = $18 == null ? void 0 : $18.excludeNames, this.excludeTypes = $18 == null ? void 0 : $18.excludeTypes, this.excludeTags = $18 == null ? void 0 : $18.excludeTags, this._schemaFormat = ($18 == null ? void 0 : $18._schemaFormat) ?? this._schemaFormat, this.transformStream = new TransformStream(), this.writer = this.transformStream.writable.getWriter(), this.receiveStream = yq.fromReadableStream(this.transformStream.readable);
  }
  [Symbol.asyncIterator]() {
    return this.receiveStream;
  }
  async persistRun($18) {
  }
  _includeRun($18) {
    if ($18.id === this.rootId) return false;
    let q = $18.tags ?? [], K = this.includeNames === void 0 && this.includeTags === void 0 && this.includeTypes === void 0;
    if (this.includeNames !== void 0) K = K || this.includeNames.includes($18.name);
    if (this.includeTypes !== void 0) K = K || this.includeTypes.includes($18.run_type);
    if (this.includeTags !== void 0) K = K || q.find((P) => {
      var _a2;
      return (_a2 = this.includeTags) == null ? void 0 : _a2.includes(P);
    }) !== void 0;
    if (this.excludeNames !== void 0) K = K && !this.excludeNames.includes($18.name);
    if (this.excludeTypes !== void 0) K = K && !this.excludeTypes.includes($18.run_type);
    if (this.excludeTags !== void 0) K = K && q.every((P) => {
      var _a2;
      return !((_a2 = this.excludeTags) == null ? void 0 : _a2.includes(P));
    });
    return K;
  }
  async *tapOutputIterable($18, q) {
    for await (let K of q) {
      if ($18 !== this.rootId) {
        let P = this.keyMapByRunId[$18];
        if (P) await this.writer.write(new d8({ ops: [{ op: "add", path: `/logs/${P}/streamed_output/-`, value: K }] }));
      }
      yield K;
    }
  }
  async onRunCreate($18) {
    var _a2;
    if (this.rootId === void 0) this.rootId = $18.id, await this.writer.write(new d8({ ops: [{ op: "replace", path: "", value: { id: $18.id, name: $18.name, type: $18.run_type, streamed_output: [], final_output: void 0, logs: {} } }] }));
    if (!this._includeRun($18)) return;
    if (this.counterMapByRunName[$18.name] === void 0) this.counterMapByRunName[$18.name] = 0;
    this.counterMapByRunName[$18.name] += 1;
    let q = this.counterMapByRunName[$18.name];
    this.keyMapByRunId[$18.id] = q === 1 ? $18.name : `${$18.name}:${q}`;
    let K = { id: $18.id, name: $18.name, type: $18.run_type, tags: $18.tags ?? [], metadata: ((_a2 = $18.extra) == null ? void 0 : _a2.metadata) ?? {}, start_time: new Date($18.start_time).toISOString(), streamed_output: [], streamed_output_str: [], final_output: void 0, end_time: void 0 };
    if (this._schemaFormat === "streaming_events") K.inputs = await SX($18, this._schemaFormat);
    await this.writer.write(new d8({ ops: [{ op: "add", path: `/logs/${this.keyMapByRunId[$18.id]}`, value: K }] }));
  }
  async onRunUpdate($18) {
    try {
      let q = this.keyMapByRunId[$18.id];
      if (q === void 0) return;
      let K = [];
      if (this._schemaFormat === "streaming_events") K.push({ op: "replace", path: `/logs/${q}/inputs`, value: await SX($18, this._schemaFormat) });
      if (K.push({ op: "add", path: `/logs/${q}/final_output`, value: await MX($18, this._schemaFormat) }), $18.end_time !== void 0) K.push({ op: "add", path: `/logs/${q}/end_time`, value: new Date($18.end_time).toISOString() });
      let P = new d8({ ops: K });
      await this.writer.write(P);
    } finally {
      if ($18.id === this.rootId) {
        let q = new d8({ ops: [{ op: "replace", path: "/final_output", value: await MX($18, this._schemaFormat) }] });
        if (await this.writer.write(q), this.autoClose) await this.writer.close();
      }
    }
  }
  async onLLMNewToken($18, q, K) {
    let P = this.keyMapByRunId[$18.id];
    if (P === void 0) return;
    let _ = $18.inputs.messages !== void 0, Y;
    if (_) if (tR(K == null ? void 0 : K.chunk)) Y = K == null ? void 0 : K.chunk;
    else Y = new OP({ id: `run-${$18.id}`, content: q });
    else Y = q;
    let O = new d8({ ops: [{ op: "add", path: `/logs/${P}/streamed_output_str/-`, value: q }, { op: "add", path: `/logs/${P}/streamed_output/-`, value: Y }] });
    await this.writer.write(O);
  }
};
var UR = {};
Z6(UR, { ChatGenerationChunk: () => aR, GenerationChunk: () => MP, RUN_KEY: () => FR });
var FR = "__run";
var MP = class $7 {
  constructor(q) {
    __publicField(this, "text");
    __publicField(this, "generationInfo");
    this.text = q.text, this.generationInfo = q.generationInfo;
  }
  concat(q) {
    return new $7({ text: this.text + q.text, generationInfo: { ...this.generationInfo, ...q.generationInfo } });
  }
};
var aR = class $10 extends MP {
  constructor(q) {
    super(q);
    __publicField(this, "message");
    this.message = q.message;
  }
  concat(q) {
    return new $10({ text: this.text + q.text, generationInfo: { ...this.generationInfo, ...q.generationInfo }, message: this.message.concat(q.message) });
  }
};
function z9({ name: $18, serialized: q }) {
  if ($18 !== void 0) return $18;
  if ((q == null ? void 0 : q.name) !== void 0) return q.name;
  else if ((q == null ? void 0 : q.id) !== void 0 && Array.isArray(q == null ? void 0 : q.id)) return q.id[q.id.length - 1];
  return "Unnamed";
}
var NX = ($18) => $18.name === "event_stream_tracer";
var CX = class extends E8 {
  constructor($18) {
    super({ _awaitHandler: true, ...$18 });
    __publicField(this, "autoClose", true);
    __publicField(this, "includeNames");
    __publicField(this, "includeTypes");
    __publicField(this, "includeTags");
    __publicField(this, "excludeNames");
    __publicField(this, "excludeTypes");
    __publicField(this, "excludeTags");
    __publicField(this, "runInfoMap", /* @__PURE__ */ new Map());
    __publicField(this, "tappedPromises", /* @__PURE__ */ new Map());
    __publicField(this, "transformStream");
    __publicField(this, "writer");
    __publicField(this, "receiveStream");
    __publicField(this, "name", "event_stream_tracer");
    __publicField(this, "lc_prefer_streaming", true);
    this.autoClose = ($18 == null ? void 0 : $18.autoClose) ?? true, this.includeNames = $18 == null ? void 0 : $18.includeNames, this.includeTypes = $18 == null ? void 0 : $18.includeTypes, this.includeTags = $18 == null ? void 0 : $18.includeTags, this.excludeNames = $18 == null ? void 0 : $18.excludeNames, this.excludeTypes = $18 == null ? void 0 : $18.excludeTypes, this.excludeTags = $18 == null ? void 0 : $18.excludeTags, this.transformStream = new TransformStream(), this.writer = this.transformStream.writable.getWriter(), this.receiveStream = yq.fromReadableStream(this.transformStream.readable);
  }
  [Symbol.asyncIterator]() {
    return this.receiveStream;
  }
  async persistRun($18) {
  }
  _includeRun($18) {
    let q = $18.tags ?? [], K = this.includeNames === void 0 && this.includeTags === void 0 && this.includeTypes === void 0;
    if (this.includeNames !== void 0) K = K || this.includeNames.includes($18.name);
    if (this.includeTypes !== void 0) K = K || this.includeTypes.includes($18.runType);
    if (this.includeTags !== void 0) K = K || q.find((P) => {
      var _a2;
      return (_a2 = this.includeTags) == null ? void 0 : _a2.includes(P);
    }) !== void 0;
    if (this.excludeNames !== void 0) K = K && !this.excludeNames.includes($18.name);
    if (this.excludeTypes !== void 0) K = K && !this.excludeTypes.includes($18.runType);
    if (this.excludeTags !== void 0) K = K && q.every((P) => {
      var _a2;
      return !((_a2 = this.excludeTags) == null ? void 0 : _a2.includes(P));
    });
    return K;
  }
  async *tapOutputIterable($18, q) {
    let K = await q.next();
    if (K.done) return;
    let P = this.runInfoMap.get($18);
    if (P === void 0) {
      yield K.value;
      return;
    }
    function _(O, z) {
      if (O === "llm" && typeof z === "string") return new MP({ text: z });
      return z;
    }
    let Y = this.tappedPromises.get($18);
    if (Y === void 0) {
      let O;
      Y = new Promise((z) => {
        O = z;
      }), this.tappedPromises.set($18, Y);
      try {
        let z = { event: `on_${P.runType}_stream`, run_id: $18, name: P.name, tags: P.tags, metadata: P.metadata, data: {} };
        await this.send({ ...z, data: { chunk: _(P.runType, K.value) } }, P), yield K.value;
        for await (let J of q) {
          if (P.runType !== "tool" && P.runType !== "retriever") await this.send({ ...z, data: { chunk: _(P.runType, J) } }, P);
          yield J;
        }
      } finally {
        O == null ? void 0 : O();
      }
    } else {
      yield K.value;
      for await (let O of q) yield O;
    }
  }
  async send($18, q) {
    if (this._includeRun(q)) await this.writer.write($18);
  }
  async sendEndEvent($18, q) {
    let K = this.tappedPromises.get($18.run_id);
    if (K !== void 0) K.then(() => {
      this.send($18, q);
    });
    else await this.send($18, q);
  }
  async onLLMStart($18) {
    var _a2, _b2;
    let q = z9($18), K = $18.inputs.messages !== void 0 ? "chat_model" : "llm", P = { tags: $18.tags ?? [], metadata: ((_a2 = $18.extra) == null ? void 0 : _a2.metadata) ?? {}, name: q, runType: K, inputs: $18.inputs };
    this.runInfoMap.set($18.id, P);
    let _ = `on_${K}_start`;
    await this.send({ event: _, data: { input: $18.inputs }, name: q, tags: $18.tags ?? [], run_id: $18.id, metadata: ((_b2 = $18.extra) == null ? void 0 : _b2.metadata) ?? {} }, P);
  }
  async onLLMNewToken($18, q, K) {
    let P = this.runInfoMap.get($18.id), _, Y;
    if (P === void 0) throw Error(`onLLMNewToken: Run ID ${$18.id} not found in run map.`);
    if (this.runInfoMap.size === 1) return;
    if (P.runType === "chat_model") if (Y = "on_chat_model_stream", (K == null ? void 0 : K.chunk) === void 0) _ = new OP({ content: q, id: `run-${$18.id}` });
    else _ = K.chunk.message;
    else if (P.runType === "llm") if (Y = "on_llm_stream", (K == null ? void 0 : K.chunk) === void 0) _ = new MP({ text: q });
    else _ = K.chunk;
    else throw Error(`Unexpected run type ${P.runType}`);
    await this.send({ event: Y, data: { chunk: _ }, run_id: $18.id, name: P.name, tags: P.tags, metadata: P.metadata }, P);
  }
  async onLLMEnd($18) {
    var _a2, _b2, _c;
    let q = this.runInfoMap.get($18.id);
    this.runInfoMap.delete($18.id);
    let K;
    if (q === void 0) throw Error(`onLLMEnd: Run ID ${$18.id} not found in run map.`);
    let P = (_a2 = $18.outputs) == null ? void 0 : _a2.generations, _;
    if (q.runType === "chat_model") {
      for (let Y of P ?? []) {
        if (_ !== void 0) break;
        _ = (_b2 = Y[0]) == null ? void 0 : _b2.message;
      }
      K = "on_chat_model_end";
    } else if (q.runType === "llm") _ = { generations: P == null ? void 0 : P.map((Y) => {
      return Y.map((O) => {
        return { text: O.text, generationInfo: O.generationInfo };
      });
    }), llmOutput: ((_c = $18.outputs) == null ? void 0 : _c.llmOutput) ?? {} }, K = "on_llm_end";
    else throw Error(`onLLMEnd: Unexpected run type: ${q.runType}`);
    await this.sendEndEvent({ event: K, data: { output: _, input: q.inputs }, run_id: $18.id, name: q.name, tags: q.tags, metadata: q.metadata }, q);
  }
  async onChainStart($18) {
    var _a2, _b2;
    let q = z9($18), K = $18.run_type ?? "chain", P = { tags: $18.tags ?? [], metadata: ((_a2 = $18.extra) == null ? void 0 : _a2.metadata) ?? {}, name: q, runType: $18.run_type }, _ = {};
    if ($18.inputs.input === "" && Object.keys($18.inputs).length === 1) _ = {}, P.inputs = {};
    else if ($18.inputs.input !== void 0) _.input = $18.inputs.input, P.inputs = $18.inputs.input;
    else _.input = $18.inputs, P.inputs = $18.inputs;
    this.runInfoMap.set($18.id, P), await this.send({ event: `on_${K}_start`, data: _, name: q, tags: $18.tags ?? [], run_id: $18.id, metadata: ((_b2 = $18.extra) == null ? void 0 : _b2.metadata) ?? {} }, P);
  }
  async onChainEnd($18) {
    var _a2;
    let q = this.runInfoMap.get($18.id);
    if (this.runInfoMap.delete($18.id), q === void 0) throw Error(`onChainEnd: Run ID ${$18.id} not found in run map.`);
    let K = `on_${$18.run_type}_end`, P = $18.inputs ?? q.inputs ?? {}, Y = { output: ((_a2 = $18.outputs) == null ? void 0 : _a2.output) ?? $18.outputs, input: P };
    if (P.input && Object.keys(P).length === 1) Y.input = P.input, q.inputs = P.input;
    await this.sendEndEvent({ event: K, data: Y, run_id: $18.id, name: q.name, tags: q.tags, metadata: q.metadata ?? {} }, q);
  }
  async onToolStart($18) {
    var _a2, _b2;
    let q = z9($18), K = { tags: $18.tags ?? [], metadata: ((_a2 = $18.extra) == null ? void 0 : _a2.metadata) ?? {}, name: q, runType: "tool", inputs: $18.inputs ?? {} };
    this.runInfoMap.set($18.id, K), await this.send({ event: "on_tool_start", data: { input: $18.inputs ?? {} }, name: q, run_id: $18.id, tags: $18.tags ?? [], metadata: ((_b2 = $18.extra) == null ? void 0 : _b2.metadata) ?? {} }, K);
  }
  async onToolEnd($18) {
    var _a2;
    let q = this.runInfoMap.get($18.id);
    if (this.runInfoMap.delete($18.id), q === void 0) throw Error(`onToolEnd: Run ID ${$18.id} not found in run map.`);
    if (q.inputs === void 0) throw Error(`onToolEnd: Run ID ${$18.id} is a tool call, and is expected to have traced inputs.`);
    let K = ((_a2 = $18.outputs) == null ? void 0 : _a2.output) === void 0 ? $18.outputs : $18.outputs.output;
    await this.sendEndEvent({ event: "on_tool_end", data: { output: K, input: q.inputs }, run_id: $18.id, name: q.name, tags: q.tags, metadata: q.metadata }, q);
  }
  async onRetrieverStart($18) {
    var _a2, _b2;
    let q = z9($18), K = "retriever", P = { tags: $18.tags ?? [], metadata: ((_a2 = $18.extra) == null ? void 0 : _a2.metadata) ?? {}, name: q, runType: "retriever", inputs: { query: $18.inputs.query } };
    this.runInfoMap.set($18.id, P), await this.send({ event: "on_retriever_start", data: { input: { query: $18.inputs.query } }, name: q, tags: $18.tags ?? [], run_id: $18.id, metadata: ((_b2 = $18.extra) == null ? void 0 : _b2.metadata) ?? {} }, P);
  }
  async onRetrieverEnd($18) {
    var _a2;
    let q = this.runInfoMap.get($18.id);
    if (this.runInfoMap.delete($18.id), q === void 0) throw Error(`onRetrieverEnd: Run ID ${$18.id} not found in run map.`);
    await this.sendEndEvent({ event: "on_retriever_end", data: { output: ((_a2 = $18.outputs) == null ? void 0 : _a2.documents) ?? $18.outputs, input: q.inputs }, run_id: $18.id, name: q.name, tags: q.tags, metadata: q.metadata }, q);
  }
  async handleCustomEvent($18, q, K) {
    let P = this.runInfoMap.get(K);
    if (P === void 0) throw Error(`handleCustomEvent: Run ID ${K} not found in run map.`);
    await this.send({ event: "on_custom_event", run_id: K, name: $18, tags: P.tags, metadata: P.metadata, data: q }, P);
  }
  async finish() {
    let $18 = [...this.tappedPromises.values()];
    Promise.all($18).finally(() => {
      this.writer.close();
    });
  }
};
var EX = q8(C1(), 1);
var W9 = q8(I1(), 1);
var QR = {};
Z6(QR, { AsyncCaller: () => NP });
var eR = [400, 401, 402, 403, 404, 405, 406, 407, 409];
var sR = ($18) => {
  var _a2, _b2;
  if ($18.message.startsWith("Cancel") || $18.message.startsWith("AbortError") || $18.name === "AbortError") throw $18;
  if (($18 == null ? void 0 : $18.code) === "ECONNABORTED") throw $18;
  let q = ((_a2 = $18 == null ? void 0 : $18.response) == null ? void 0 : _a2.status) ?? ($18 == null ? void 0 : $18.status);
  if (q && eR.includes(+q)) throw $18;
  if (((_b2 = $18 == null ? void 0 : $18.error) == null ? void 0 : _b2.code) === "insufficient_quota") {
    let K = Error($18 == null ? void 0 : $18.message);
    throw K.name = "InsufficientQuotaError", K;
  }
};
var NP = class {
  constructor($18) {
    __publicField(this, "maxConcurrency");
    __publicField(this, "maxRetries");
    __publicField(this, "onFailedAttempt");
    __publicField(this, "queue");
    this.maxConcurrency = $18.maxConcurrency ?? 1 / 0, this.maxRetries = $18.maxRetries ?? 6, this.onFailedAttempt = $18.onFailedAttempt ?? sR;
    let q = "default" in W9.default ? W9.default.default : W9.default;
    this.queue = new q({ concurrency: this.maxConcurrency });
  }
  call($18, ...q) {
    return this.queue.add(() => EX.default(() => $18(...q).catch((K) => {
      if (K instanceof Error) throw K;
      else throw Error(K);
    }), { onFailedAttempt: this.onFailedAttempt, retries: this.maxRetries, randomize: true }), { throwOnTimeout: true });
  }
  callWithOptions($18, q, ...K) {
    if ($18.signal) {
      let P;
      return Promise.race([this.call(q, ...K), new Promise((_, Y) => {
        var _a2;
        P = () => {
          Y(o_($18.signal));
        }, (_a2 = $18.signal) == null ? void 0 : _a2.addEventListener("abort", P);
      })]).finally(() => {
        if ($18.signal && P) $18.signal.removeEventListener("abort", P);
      });
    }
    return this.call(q, ...K);
  }
  fetch(...$18) {
    return this.call(() => fetch(...$18).then((q) => q.ok ? q : Promise.reject(q)));
  }
};
var dY = class extends E8 {
  constructor({ config: $18, onStart: q, onEnd: K, onError: P }) {
    super({ _awaitHandler: true });
    __publicField(this, "name", "RootListenersTracer");
    __publicField(this, "rootId");
    __publicField(this, "config");
    __publicField(this, "argOnStart");
    __publicField(this, "argOnEnd");
    __publicField(this, "argOnError");
    this.config = $18, this.argOnStart = q, this.argOnEnd = K, this.argOnError = P;
  }
  persistRun($18) {
    return Promise.resolve();
  }
  async onRunCreate($18) {
    if (this.rootId) return;
    if (this.rootId = $18.id, this.argOnStart) await this.argOnStart($18, this.config);
  }
  async onRunUpdate($18) {
    if ($18.id !== this.rootId) return;
    if (!$18.error) {
      if (this.argOnEnd) await this.argOnEnd($18, this.config);
    } else if (this.argOnError) await this.argOnError($18, this.config);
  }
};
function CP($18) {
  return $18 ? $18.lc_runnable : false;
}
var hX = class {
  constructor($18) {
    __publicField(this, "includeNames");
    __publicField(this, "includeTypes");
    __publicField(this, "includeTags");
    __publicField(this, "excludeNames");
    __publicField(this, "excludeTypes");
    __publicField(this, "excludeTags");
    this.includeNames = $18.includeNames, this.includeTypes = $18.includeTypes, this.includeTags = $18.includeTags, this.excludeNames = $18.excludeNames, this.excludeTypes = $18.excludeTypes, this.excludeTags = $18.excludeTags;
  }
  includeEvent($18, q) {
    let K = this.includeNames === void 0 && this.includeTypes === void 0 && this.includeTags === void 0, P = $18.tags ?? [];
    if (this.includeNames !== void 0) K = K || this.includeNames.includes($18.name);
    if (this.includeTypes !== void 0) K = K || this.includeTypes.includes(q);
    if (this.includeTags !== void 0) K = K || P.some((_) => {
      var _a2;
      return (_a2 = this.includeTags) == null ? void 0 : _a2.includes(_);
    });
    if (this.excludeNames !== void 0) K = K && !this.excludeNames.includes($18.name);
    if (this.excludeTypes !== void 0) K = K && !this.excludeTypes.includes(q);
    if (this.excludeTags !== void 0) K = K && P.every((_) => {
      var _a2;
      return !((_a2 = this.excludeTags) == null ? void 0 : _a2.includes(_));
    });
    return K;
  }
};
var WK = {};
lq(WK, { version: () => U2, util: () => l$, treeifyError: () => QY, toJSONSchema: () => O4, toDotPath: () => bX, safeParseAsync: () => $22, safeParse: () => sY, safeEncodeAsync: () => gI, safeEncode: () => DI, safeDecodeAsync: () => bI, safeDecode: () => LI, registry: () => x9, regexes: () => f8, prettifyError: () => eY, parseAsync: () => Q_, parse: () => xP, locales: () => tP, isValidJWT: () => QX, isValidBase64URL: () => aX, isValidBase64: () => fj, globalRegistry: () => Wq, globalConfig: () => EP, formatError: () => uP, flattenError: () => yP, encodeAsync: () => RI, encode: () => EI, decodeAsync: () => II, decode: () => hI, config: () => r6, clone: () => o6, _xid: () => t9, _void: () => fv, _uuidv7: () => l9, _uuidv6: () => d9, _uuidv4: () => m9, _uuid: () => c9, _url: () => aP, _uppercase: () => q7, _unknown: () => _5, _union: () => KL, _undefined: () => Jv, _ulid: () => B9, _uint64: () => Wv, _uint32: () => Pv, _tuple: () => OL, _trim: () => j7, _transform: () => JL, _toUpperCase: () => z7, _toLowerCase: () => v7, _templateLiteral: () => VL, _symbol: () => Hv, _superRefine: () => Rv, _success: () => XL, _stringbool: () => Iv, _stringFormat: () => P4, _string: () => i3, _startsWith: () => _7, _size: () => eP, _set: () => vL, _safeParseAsync: () => s_, _safeParse: () => e_, _safeEncodeAsync: () => k9, _safeEncode: () => X9, _safeDecodeAsync: () => G9, _safeDecode: () => A9, _regex: () => sP, _refine: () => hv, _record: () => YL, _readonly: () => GL, _property: () => Mv, _promise: () => ML, _positive: () => kv, _pipe: () => kL, _parseAsync: () => a_, _parse: () => F_, _overwrite: () => zK, _optional: () => TL, _number: () => e3, _nullable: () => wL, _null: () => Tv, _normalize: () => Y7, _nonpositive: () => Vv, _nonoptional: () => ZL, _nonnegative: () => Sv, _never: () => QP, _negative: () => Gv, _nativeEnum: () => WL, _nanoid: () => o9, _nan: () => Av, _multipleOf: () => f_, _minSize: () => Z_, _minLength: () => rK, _min: () => Fq, _mime: () => O7, _maxSize: () => q4, _maxLength: () => K4, _max: () => Z8, _map: () => jL, _lte: () => Z8, _lt: () => jK, _lowercase: () => $72, _literal: () => HL, _length: () => _4, _lazy: () => SL, _ksuid: () => U9, _jwt: () => K5, _isoTime: () => a3, _isoDuration: () => Q3, _isoDateTime: () => U3, _isoDate: () => F3, _ipv6: () => a9, _ipv4: () => F9, _intersection: () => PL, _int64: () => zv, _int32: () => _v, _int: () => $v, _includes: () => K7, _guid: () => FP, _gte: () => Fq, _gt: () => vK, _float64: () => Kv, _float32: () => qv, _file: () => Cv, _enum: () => zL, _endsWith: () => P7, _encodeAsync: () => f9, _encode: () => T9, _emoji: () => r9, _email: () => p9, _e164: () => q5, _discriminatedUnion: () => _L, _default: () => fL, _decodeAsync: () => Z9, _decode: () => w9, _date: () => Zv, _custom: () => Ev, _cuid2: () => i9, _cuid: () => n9, _coercedString: () => B3, _coercedNumber: () => s3, _coercedDate: () => Xv, _coercedBoolean: () => Yv, _coercedBigint: () => vv, _cidrv6: () => e9, _cidrv4: () => Q9, _check: () => PA, _catch: () => AL, _boolean: () => Ov, _bigint: () => jv, _base64url: () => $52, _base64: () => s9, _array: () => Nv, _any: () => wv, TimePrecision: () => t3, NEVER: () => lY, JSONSchemaGenerator: () => P5, JSONSchema: () => OA, Doc: () => N9, $output: () => o3, $input: () => n3, $constructor: () => O$, $brand: () => rY, $ZodXID: () => Oj, $ZodVoid: () => hj, $ZodUnknown: () => g9, $ZodUnion: () => b9, $ZodUndefined: () => Nj, $ZodUUID: () => Q2, $ZodURL: () => s2, $ZodULID: () => Pj, $ZodType: () => P6, $ZodTuple: () => y9, $ZodTransform: () => mj, $ZodTemplateLiteral: () => Fj, $ZodSymbol: () => Mj, $ZodSuccess: () => nj, $ZodStringFormat: () => E6, $ZodString: () => w_, $ZodSet: () => uj, $ZodRegistry: () => UP, $ZodRecord: () => bj, $ZodRealError: () => Uq, $ZodReadonly: () => Uj, $ZodPromise: () => Qj, $ZodPrefault: () => rj, $ZodPipe: () => tj, $ZodOptional: () => u9, $ZodObjectJIT: () => Dj, $ZodObject: () => $A, $ZodNumberFormat: () => Vj, $ZodNumber: () => D9, $ZodNullable: () => dj, $ZodNull: () => Cj, $ZodNonOptional: () => oj, $ZodNever: () => dP, $ZodNanoID: () => qj, $ZodNaN: () => Bj, $ZodMap: () => yj, $ZodLiteral: () => pj, $ZodLazy: () => ej, $ZodKSUID: () => Yj, $ZodJWT: () => kj, $ZodIntersection: () => gj, $ZodISOTime: () => zj, $ZodISODuration: () => Wj, $ZodISODateTime: () => jj, $ZodISODate: () => vj, $ZodIPv6: () => Jj, $ZodIPv4: () => Hj, $ZodGUID: () => a2, $ZodFunction: () => aj, $ZodFile: () => cj, $ZodError: () => bP, $ZodEnum: () => xj, $ZodEncodeError: () => H_, $ZodEmoji: () => $j, $ZodEmail: () => e2, $ZodE164: () => Aj, $ZodDiscriminatedUnion: () => Lj, $ZodDefault: () => lj, $ZodDate: () => Rj, $ZodCustomStringFormat: () => Gj, $ZodCustom: () => sj, $ZodCodec: () => lP, $ZodCheckUpperCase: () => l2, $ZodCheckStringFormat: () => $42, $ZodCheckStartsWith: () => o2, $ZodCheckSizeEquals: () => u2, $ZodCheckRegex: () => m2, $ZodCheckProperty: () => i2, $ZodCheckOverwrite: () => t2, $ZodCheckNumberFormat: () => L2, $ZodCheckMultipleOf: () => D2, $ZodCheckMinSize: () => y2, $ZodCheckMinLength: () => p2, $ZodCheckMimeType: () => B2, $ZodCheckMaxSize: () => b2, $ZodCheckMaxLength: () => x2, $ZodCheckLowerCase: () => d2, $ZodCheckLessThan: () => S9, $ZodCheckLengthEquals: () => c2, $ZodCheckIncludes: () => r2, $ZodCheckGreaterThan: () => M9, $ZodCheckEndsWith: () => n2, $ZodCheckBigIntFormat: () => g2, $ZodCheck: () => I6, $ZodCatch: () => ij, $ZodCUID2: () => _j, $ZodCUID: () => Kj, $ZodCIDRv6: () => wj, $ZodCIDRv4: () => Tj, $ZodBoolean: () => mP, $ZodBigIntFormat: () => Sj, $ZodBigInt: () => L9, $ZodBase64URL: () => Xj, $ZodBase64: () => Zj, $ZodAsyncError: () => l8, $ZodArray: () => Ij, $ZodAny: () => Ej });
var lY = Object.freeze({ status: "aborted" });
function O$($18, q, K) {
  function P(z, J) {
    var T;
    Object.defineProperty(z, "_zod", { value: z._zod ?? {}, enumerable: false }), (T = z._zod).traits ?? (T.traits = /* @__PURE__ */ new Set()), z._zod.traits.add($18), q(z, J);
    for (let X in O.prototype) if (!(X in z)) Object.defineProperty(z, X, { value: O.prototype[X].bind(z) });
    z._zod.constr = O, z._zod.def = J;
  }
  let _ = (K == null ? void 0 : K.Parent) ?? Object;
  class Y extends _ {
  }
  Object.defineProperty(Y, "name", { value: $18 });
  function O(z) {
    var J;
    let T = (K == null ? void 0 : K.Parent) ? new Y() : this;
    P(T, z), (J = T._zod).deferred ?? (J.deferred = []);
    for (let X of T._zod.deferred) X();
    return T;
  }
  return Object.defineProperty(O, "init", { value: P }), Object.defineProperty(O, Symbol.hasInstance, { value: (z) => {
    var _a2, _b2;
    if ((K == null ? void 0 : K.Parent) && z instanceof K.Parent) return true;
    return (_b2 = (_a2 = z == null ? void 0 : z._zod) == null ? void 0 : _a2.traits) == null ? void 0 : _b2.has($18);
  } }), Object.defineProperty(O, "name", { value: $18 }), O;
}
var rY = Symbol("zod_brand");
var l8 = class extends Error {
  constructor() {
    super("Encountered Promise during synchronous parse. Use .parseAsync() instead.");
  }
};
var H_ = class extends Error {
  constructor($18) {
    super(`Encountered unidirectional transform during encode: ${$18}`);
    this.name = "ZodEncodeError";
  }
};
var EP = {};
function r6($18) {
  if ($18) Object.assign(EP, $18);
  return EP;
}
var l$ = {};
lq(l$, { unwrapMessage: () => hP, uint8ArrayToHex: () => NI, uint8ArrayToBase64url: () => SI, uint8ArrayToBase64: () => DX, stringifyPrimitive: () => m$, shallowClone: () => BY, safeExtend: () => ZI, required: () => kI, randomString: () => zI, propertyKeyTypes: () => DP, promiseAllObject: () => vI, primitiveTypes: () => tY, prefixIssues: () => P8, pick: () => TI, partial: () => AI, optionalKeys: () => UY, omit: () => wI, objectClone: () => OI, numKeys: () => WI, nullish: () => pK, normalizeParams: () => d$, mergeDefs: () => mK, merge: () => XI, jsonStringifyReplacer: () => B_, joinValues: () => T$, issue: () => U_, isPlainObject: () => dK, isObject: () => J_, hexToUint8Array: () => MI, getSizableOrigin: () => LP, getParsedType: () => HI, getLengthableOrigin: () => gP, getEnumValues: () => RP, getElementAtPath: () => jI, floatSafeRemainder: () => nY, finalizeIssue: () => O8, extend: () => fI, escapeRegex: () => r8, esc: () => H9, defineLazy: () => A6, createTransparentProxy: () => JI, cloneDef: () => YI, clone: () => o6, cleanRegex: () => IP, cleanEnum: () => GI, captureStackTrace: () => J9, cached: () => t_, base64urlToUint8Array: () => VI, base64ToUint8Array: () => IX, assignProp: () => cK, assertNotEqual: () => qI, assertNever: () => _I, assertIs: () => KI, assertEqual: () => $I, assert: () => PI, allowsEval: () => iY, aborted: () => lK, NUMBER_FORMAT_RANGES: () => FY, Class: () => LX, BIGINT_FORMAT_RANGES: () => aY });
function $I($18) {
  return $18;
}
function qI($18) {
  return $18;
}
function KI($18) {
}
function _I($18) {
  throw Error();
}
function PI($18) {
}
function RP($18) {
  let q = Object.values($18).filter((P) => typeof P === "number");
  return Object.entries($18).filter(([P, _]) => q.indexOf(+P) === -1).map(([P, _]) => _);
}
function T$($18, q = "|") {
  return $18.map((K) => m$(K)).join(q);
}
function B_($18, q) {
  if (typeof q === "bigint") return q.toString();
  return q;
}
function t_($18) {
  return { get value() {
    {
      let K = $18();
      return Object.defineProperty(this, "value", { value: K }), K;
    }
    throw Error("cached value already set");
  } };
}
function pK($18) {
  return $18 === null || $18 === void 0;
}
function IP($18) {
  let q = $18.startsWith("^") ? 1 : 0, K = $18.endsWith("$") ? $18.length - 1 : $18.length;
  return $18.slice(q, K);
}
function nY($18, q) {
  let K = ($18.toString().split(".")[1] || "").length, P = q.toString(), _ = (P.split(".")[1] || "").length;
  if (_ === 0 && /\d?e-\d?/.test(P)) {
    let J = P.match(/\d?e-(\d?)/);
    if (J == null ? void 0 : J[1]) _ = Number.parseInt(J[1]);
  }
  let Y = K > _ ? K : _, O = Number.parseInt($18.toFixed(Y).replace(".", "")), z = Number.parseInt(q.toFixed(Y).replace(".", ""));
  return O % z / 10 ** Y;
}
var RX = Symbol("evaluating");
function A6($18, q, K) {
  let P = void 0;
  Object.defineProperty($18, q, { get() {
    if (P === RX) return;
    if (P === void 0) P = RX, P = K();
    return P;
  }, set(_) {
    Object.defineProperty($18, q, { value: _ });
  }, configurable: true });
}
function OI($18) {
  return Object.create(Object.getPrototypeOf($18), Object.getOwnPropertyDescriptors($18));
}
function cK($18, q, K) {
  Object.defineProperty($18, q, { value: K, writable: true, enumerable: true, configurable: true });
}
function mK(...$18) {
  let q = {};
  for (let K of $18) {
    let P = Object.getOwnPropertyDescriptors(K);
    Object.assign(q, P);
  }
  return Object.defineProperties({}, q);
}
function YI($18) {
  return mK($18._zod.def);
}
function jI($18, q) {
  if (!q) return $18;
  return q.reduce((K, P) => K == null ? void 0 : K[P], $18);
}
function vI($18) {
  let q = Object.keys($18), K = q.map((P) => $18[P]);
  return Promise.all(K).then((P) => {
    let _ = {};
    for (let Y = 0; Y < q.length; Y++) _[q[Y]] = P[Y];
    return _;
  });
}
function zI($18 = 10) {
  let K = "";
  for (let P = 0; P < $18; P++) K += "abcdefghijklmnopqrstuvwxyz"[Math.floor(Math.random() * 26)];
  return K;
}
function H9($18) {
  return JSON.stringify($18);
}
var J9 = "captureStackTrace" in Error ? Error.captureStackTrace : (...$18) => {
};
function J_($18) {
  return typeof $18 === "object" && $18 !== null && !Array.isArray($18);
}
var iY = t_(() => {
  var _a2;
  if (typeof navigator < "u" && ((_a2 = navigator == null ? void 0 : navigator.userAgent) == null ? void 0 : _a2.includes("Cloudflare"))) return false;
  try {
    return new Function(""), true;
  } catch ($18) {
    return false;
  }
});
function dK($18) {
  if (J_($18) === false) return false;
  let q = $18.constructor;
  if (q === void 0) return true;
  let K = q.prototype;
  if (J_(K) === false) return false;
  if (Object.prototype.hasOwnProperty.call(K, "isPrototypeOf") === false) return false;
  return true;
}
function BY($18) {
  if (dK($18)) return { ...$18 };
  if (Array.isArray($18)) return [...$18];
  return $18;
}
function WI($18) {
  let q = 0;
  for (let K in $18) if (Object.prototype.hasOwnProperty.call($18, K)) q++;
  return q;
}
var HI = ($18) => {
  let q = typeof $18;
  switch (q) {
    case "undefined":
      return "undefined";
    case "string":
      return "string";
    case "number":
      return Number.isNaN($18) ? "nan" : "number";
    case "boolean":
      return "boolean";
    case "function":
      return "function";
    case "bigint":
      return "bigint";
    case "symbol":
      return "symbol";
    case "object":
      if (Array.isArray($18)) return "array";
      if ($18 === null) return "null";
      if ($18.then && typeof $18.then === "function" && $18.catch && typeof $18.catch === "function") return "promise";
      if (typeof Map < "u" && $18 instanceof Map) return "map";
      if (typeof Set < "u" && $18 instanceof Set) return "set";
      if (typeof Date < "u" && $18 instanceof Date) return "date";
      if (typeof File < "u" && $18 instanceof File) return "file";
      return "object";
    default:
      throw Error(`Unknown data type: ${q}`);
  }
};
var DP = /* @__PURE__ */ new Set(["string", "number", "symbol"]);
var tY = /* @__PURE__ */ new Set(["string", "number", "bigint", "boolean", "symbol", "undefined"]);
function r8($18) {
  return $18.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function o6($18, q, K) {
  let P = new $18._zod.constr(q ?? $18._zod.def);
  if (!q || (K == null ? void 0 : K.parent)) P._zod.parent = $18;
  return P;
}
function d$($18) {
  let q = $18;
  if (!q) return {};
  if (typeof q === "string") return { error: () => q };
  if ((q == null ? void 0 : q.message) !== void 0) {
    if ((q == null ? void 0 : q.error) !== void 0) throw Error("Cannot specify both `message` and `error` params");
    q.error = q.message;
  }
  if (delete q.message, typeof q.error === "string") return { ...q, error: () => q.error };
  return q;
}
function JI($18) {
  let q;
  return new Proxy({}, { get(K, P, _) {
    return q ?? (q = $18()), Reflect.get(q, P, _);
  }, set(K, P, _, Y) {
    return q ?? (q = $18()), Reflect.set(q, P, _, Y);
  }, has(K, P) {
    return q ?? (q = $18()), Reflect.has(q, P);
  }, deleteProperty(K, P) {
    return q ?? (q = $18()), Reflect.deleteProperty(q, P);
  }, ownKeys(K) {
    return q ?? (q = $18()), Reflect.ownKeys(q);
  }, getOwnPropertyDescriptor(K, P) {
    return q ?? (q = $18()), Reflect.getOwnPropertyDescriptor(q, P);
  }, defineProperty(K, P, _) {
    return q ?? (q = $18()), Reflect.defineProperty(q, P, _);
  } });
}
function m$($18) {
  if (typeof $18 === "bigint") return $18.toString() + "n";
  if (typeof $18 === "string") return `"${$18}"`;
  return `${$18}`;
}
function UY($18) {
  return Object.keys($18).filter((q) => {
    return $18[q]._zod.optin === "optional" && $18[q]._zod.optout === "optional";
  });
}
var FY = { safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER], int32: [-2147483648, 2147483647], uint32: [0, 4294967295], float32: [-34028234663852886e22, 34028234663852886e22], float64: [-Number.MAX_VALUE, Number.MAX_VALUE] };
var aY = { int64: [BigInt("-9223372036854775808"), BigInt("9223372036854775807")], uint64: [BigInt(0), BigInt("18446744073709551615")] };
function TI($18, q) {
  let K = $18._zod.def, P = mK($18._zod.def, { get shape() {
    let _ = {};
    for (let Y in q) {
      if (!(Y in K.shape)) throw Error(`Unrecognized key: "${Y}"`);
      if (!q[Y]) continue;
      _[Y] = K.shape[Y];
    }
    return cK(this, "shape", _), _;
  }, checks: [] });
  return o6($18, P);
}
function wI($18, q) {
  let K = $18._zod.def, P = mK($18._zod.def, { get shape() {
    let _ = { ...$18._zod.def.shape };
    for (let Y in q) {
      if (!(Y in K.shape)) throw Error(`Unrecognized key: "${Y}"`);
      if (!q[Y]) continue;
      delete _[Y];
    }
    return cK(this, "shape", _), _;
  }, checks: [] });
  return o6($18, P);
}
function fI($18, q) {
  if (!dK(q)) throw Error("Invalid input to extend: expected a plain object");
  let K = $18._zod.def.checks;
  if (K && K.length > 0) throw Error("Object schemas containing refinements cannot be extended. Use `.safeExtend()` instead.");
  let _ = mK($18._zod.def, { get shape() {
    let Y = { ...$18._zod.def.shape, ...q };
    return cK(this, "shape", Y), Y;
  }, checks: [] });
  return o6($18, _);
}
function ZI($18, q) {
  if (!dK(q)) throw Error("Invalid input to safeExtend: expected a plain object");
  let K = { ...$18._zod.def, get shape() {
    let P = { ...$18._zod.def.shape, ...q };
    return cK(this, "shape", P), P;
  }, checks: $18._zod.def.checks };
  return o6($18, K);
}
function XI($18, q) {
  let K = mK($18._zod.def, { get shape() {
    let P = { ...$18._zod.def.shape, ...q._zod.def.shape };
    return cK(this, "shape", P), P;
  }, get catchall() {
    return q._zod.def.catchall;
  }, checks: [] });
  return o6($18, K);
}
function AI($18, q, K) {
  let P = mK(q._zod.def, { get shape() {
    let _ = q._zod.def.shape, Y = { ..._ };
    if (K) for (let O in K) {
      if (!(O in _)) throw Error(`Unrecognized key: "${O}"`);
      if (!K[O]) continue;
      Y[O] = $18 ? new $18({ type: "optional", innerType: _[O] }) : _[O];
    }
    else for (let O in _) Y[O] = $18 ? new $18({ type: "optional", innerType: _[O] }) : _[O];
    return cK(this, "shape", Y), Y;
  }, checks: [] });
  return o6(q, P);
}
function kI($18, q, K) {
  let P = mK(q._zod.def, { get shape() {
    let _ = q._zod.def.shape, Y = { ..._ };
    if (K) for (let O in K) {
      if (!(O in Y)) throw Error(`Unrecognized key: "${O}"`);
      if (!K[O]) continue;
      Y[O] = new $18({ type: "nonoptional", innerType: _[O] });
    }
    else for (let O in _) Y[O] = new $18({ type: "nonoptional", innerType: _[O] });
    return cK(this, "shape", Y), Y;
  }, checks: [] });
  return o6(q, P);
}
function lK($18, q = 0) {
  var _a2;
  if ($18.aborted === true) return true;
  for (let K = q; K < $18.issues.length; K++) if (((_a2 = $18.issues[K]) == null ? void 0 : _a2.continue) !== true) return true;
  return false;
}
function P8($18, q) {
  return q.map((K) => {
    var P;
    return (P = K).path ?? (P.path = []), K.path.unshift($18), K;
  });
}
function hP($18) {
  return typeof $18 === "string" ? $18 : $18 == null ? void 0 : $18.message;
}
function O8($18, q, K) {
  var _a2, _b2, _c, _d2, _e, _f;
  let P = { ...$18, path: $18.path ?? [] };
  if (!$18.message) {
    let _ = hP((_c = (_b2 = (_a2 = $18.inst) == null ? void 0 : _a2._zod.def) == null ? void 0 : _b2.error) == null ? void 0 : _c.call(_b2, $18)) ?? hP((_d2 = q == null ? void 0 : q.error) == null ? void 0 : _d2.call(q, $18)) ?? hP((_e = K.customError) == null ? void 0 : _e.call(K, $18)) ?? hP((_f = K.localeError) == null ? void 0 : _f.call(K, $18)) ?? "Invalid input";
    P.message = _;
  }
  if (delete P.inst, delete P.continue, !(q == null ? void 0 : q.reportInput)) delete P.input;
  return P;
}
function LP($18) {
  if ($18 instanceof Set) return "set";
  if ($18 instanceof Map) return "map";
  if ($18 instanceof File) return "file";
  return "unknown";
}
function gP($18) {
  if (Array.isArray($18)) return "array";
  if (typeof $18 === "string") return "string";
  return "unknown";
}
function U_(...$18) {
  let [q, K, P] = $18;
  if (typeof q === "string") return { message: q, code: "custom", input: K, inst: P };
  return { ...q };
}
function GI($18) {
  return Object.entries($18).filter(([q, K]) => {
    return Number.isNaN(Number.parseInt(q, 10));
  }).map((q) => q[1]);
}
function IX($18) {
  let q = atob($18), K = new Uint8Array(q.length);
  for (let P = 0; P < q.length; P++) K[P] = q.charCodeAt(P);
  return K;
}
function DX($18) {
  let q = "";
  for (let K = 0; K < $18.length; K++) q += String.fromCharCode($18[K]);
  return btoa(q);
}
function VI($18) {
  let q = $18.replace(/-/g, "+").replace(/_/g, "/"), K = "=".repeat((4 - q.length % 4) % 4);
  return IX(q + K);
}
function SI($18) {
  return DX($18).replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}
function MI($18) {
  let q = $18.replace(/^0x/, "");
  if (q.length % 2 !== 0) throw Error("Invalid hex string length");
  let K = new Uint8Array(q.length / 2);
  for (let P = 0; P < q.length; P += 2) K[P / 2] = Number.parseInt(q.slice(P, P + 2), 16);
  return K;
}
function NI($18) {
  return Array.from($18).map((q) => q.toString(16).padStart(2, "0")).join("");
}
var LX = class {
  constructor(...$18) {
  }
};
var gX = ($18, q) => {
  $18.name = "$ZodError", Object.defineProperty($18, "_zod", { value: $18._zod, enumerable: false }), Object.defineProperty($18, "issues", { value: q, enumerable: false }), $18.message = JSON.stringify(q, B_, 2), Object.defineProperty($18, "toString", { value: () => $18.message, enumerable: false });
};
var bP = O$("$ZodError", gX);
var Uq = O$("$ZodError", gX, { Parent: Error });
function yP($18, q = (K) => K.message) {
  let K = {}, P = [];
  for (let _ of $18.issues) if (_.path.length > 0) K[_.path[0]] = K[_.path[0]] || [], K[_.path[0]].push(q(_));
  else P.push(q(_));
  return { formErrors: P, fieldErrors: K };
}
function uP($18, q) {
  let K = q || function(Y) {
    return Y.message;
  }, P = { _errors: [] }, _ = (Y) => {
    for (let O of Y.issues) if (O.code === "invalid_union" && O.errors.length) O.errors.map((z) => _({ issues: z }));
    else if (O.code === "invalid_key") _({ issues: O.issues });
    else if (O.code === "invalid_element") _({ issues: O.issues });
    else if (O.path.length === 0) P._errors.push(K(O));
    else {
      let z = P, J = 0;
      while (J < O.path.length) {
        let T = O.path[J];
        if (J !== O.path.length - 1) z[T] = z[T] || { _errors: [] };
        else z[T] = z[T] || { _errors: [] }, z[T]._errors.push(K(O));
        z = z[T], J++;
      }
    }
  };
  return _($18), P;
}
function QY($18, q) {
  let K = q || function(Y) {
    return Y.message;
  }, P = { errors: [] }, _ = (Y, O = []) => {
    var z, J;
    for (let T of Y.issues) if (T.code === "invalid_union" && T.errors.length) T.errors.map((X) => _({ issues: X }, T.path));
    else if (T.code === "invalid_key") _({ issues: T.issues }, T.path);
    else if (T.code === "invalid_element") _({ issues: T.issues }, T.path);
    else {
      let X = [...O, ...T.path];
      if (X.length === 0) {
        P.errors.push(K(T));
        continue;
      }
      let f = P, V = 0;
      while (V < X.length) {
        let M = X[V], N = V === X.length - 1;
        if (typeof M === "string") f.properties ?? (f.properties = {}), (z = f.properties)[M] ?? (z[M] = { errors: [] }), f = f.properties[M];
        else f.items ?? (f.items = []), (J = f.items)[M] ?? (J[M] = { errors: [] }), f = f.items[M];
        if (N) f.errors.push(K(T));
        V++;
      }
    }
  };
  return _($18), P;
}
function bX($18) {
  let q = [], K = $18.map((P) => typeof P === "object" ? P.key : P);
  for (let P of K) if (typeof P === "number") q.push(`[${P}]`);
  else if (typeof P === "symbol") q.push(`[${JSON.stringify(String(P))}]`);
  else if (/[^\w$]/.test(P)) q.push(`[${JSON.stringify(P)}]`);
  else {
    if (q.length) q.push(".");
    q.push(P);
  }
  return q.join("");
}
function eY($18) {
  var _a2;
  let q = [], K = [...$18.issues].sort((P, _) => (P.path ?? []).length - (_.path ?? []).length);
  for (let P of K) if (q.push(` ${P.message}`), (_a2 = P.path) == null ? void 0 : _a2.length) q.push(`   at ${bX(P.path)}`);
  return q.join(`
`);
}
var F_ = ($18) => (q, K, P, _) => {
  let Y = P ? Object.assign(P, { async: false }) : { async: false }, O = q._zod.run({ value: K, issues: [] }, Y);
  if (O instanceof Promise) throw new l8();
  if (O.issues.length) {
    let z = new ((_ == null ? void 0 : _.Err) ?? $18)(O.issues.map((J) => O8(J, Y, r6())));
    throw J9(z, _ == null ? void 0 : _.callee), z;
  }
  return O.value;
};
var xP = F_(Uq);
var a_ = ($18) => async (q, K, P, _) => {
  let Y = P ? Object.assign(P, { async: true }) : { async: true }, O = q._zod.run({ value: K, issues: [] }, Y);
  if (O instanceof Promise) O = await O;
  if (O.issues.length) {
    let z = new ((_ == null ? void 0 : _.Err) ?? $18)(O.issues.map((J) => O8(J, Y, r6())));
    throw J9(z, _ == null ? void 0 : _.callee), z;
  }
  return O.value;
};
var Q_ = a_(Uq);
var e_ = ($18) => (q, K, P) => {
  let _ = P ? { ...P, async: false } : { async: false }, Y = q._zod.run({ value: K, issues: [] }, _);
  if (Y instanceof Promise) throw new l8();
  return Y.issues.length ? { success: false, error: new ($18 ?? bP)(Y.issues.map((O) => O8(O, _, r6()))) } : { success: true, data: Y.value };
};
var sY = e_(Uq);
var s_ = ($18) => async (q, K, P) => {
  let _ = P ? Object.assign(P, { async: true }) : { async: true }, Y = q._zod.run({ value: K, issues: [] }, _);
  if (Y instanceof Promise) Y = await Y;
  return Y.issues.length ? { success: false, error: new $18(Y.issues.map((O) => O8(O, _, r6()))) } : { success: true, data: Y.value };
};
var $22 = s_(Uq);
var T9 = ($18) => (q, K, P) => {
  let _ = P ? Object.assign(P, { direction: "backward" }) : { direction: "backward" };
  return F_($18)(q, K, _);
};
var EI = T9(Uq);
var w9 = ($18) => (q, K, P) => {
  return F_($18)(q, K, P);
};
var hI = w9(Uq);
var f9 = ($18) => async (q, K, P) => {
  let _ = P ? Object.assign(P, { direction: "backward" }) : { direction: "backward" };
  return a_($18)(q, K, _);
};
var RI = f9(Uq);
var Z9 = ($18) => async (q, K, P) => {
  return a_($18)(q, K, P);
};
var II = Z9(Uq);
var X9 = ($18) => (q, K, P) => {
  let _ = P ? Object.assign(P, { direction: "backward" }) : { direction: "backward" };
  return e_($18)(q, K, _);
};
var DI = X9(Uq);
var A9 = ($18) => (q, K, P) => {
  return e_($18)(q, K, P);
};
var LI = A9(Uq);
var k9 = ($18) => async (q, K, P) => {
  let _ = P ? Object.assign(P, { direction: "backward" }) : { direction: "backward" };
  return s_($18)(q, K, _);
};
var gI = k9(Uq);
var G9 = ($18) => async (q, K, P) => {
  return s_($18)(q, K, P);
};
var bI = G9(Uq);
var f8 = {};
lq(f8, { xid: () => P2, uuid7: () => pI, uuid6: () => xI, uuid4: () => uI, uuid: () => T_, uppercase: () => I2, unicodeEmail: () => yX, undefined: () => h2, ulid: () => _2, time: () => k2, string: () => V2, sha512_hex: () => KD, sha512_base64url: () => PD, sha512_base64: () => _D, sha384_hex: () => sI, sha384_base64url: () => qD, sha384_base64: () => $D, sha256_hex: () => aI, sha256_base64url: () => eI, sha256_base64: () => QI, sha1_hex: () => tI, sha1_base64url: () => FI, sha1_base64: () => UI, rfc5322Email: () => mI, number: () => N2, null: () => E2, nanoid: () => Y2, md5_hex: () => nI, md5_base64url: () => BI, md5_base64: () => iI, lowercase: () => R2, ksuid: () => O2, ipv6: () => J2, ipv4: () => H2, integer: () => M2, idnEmail: () => dI, html5Email: () => cI, hostname: () => Z2, hex: () => oI, guid: () => v2, extendedDuration: () => yI, emoji: () => W2, email: () => z2, e164: () => X2, duration: () => j2, domain: () => rI, datetime: () => G2, date: () => A2, cuid2: () => K2, cuid: () => q2, cidrv6: () => w2, cidrv4: () => T2, browserEmail: () => lI, boolean: () => C2, bigint: () => S2, base64url: () => V9, base64: () => f2 });
var q2 = /^[cC][^\s-]{8,}$/;
var K2 = /^[0-9a-z]+$/;
var _2 = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/;
var P2 = /^[0-9a-vA-V]{20}$/;
var O2 = /^[A-Za-z0-9]{27}$/;
var Y2 = /^[a-zA-Z0-9_-]{21}$/;
var j2 = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/;
var yI = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
var v2 = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/;
var T_ = ($18) => {
  if (!$18) return /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/;
  return new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${$18}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`);
};
var uI = T_(4);
var xI = T_(6);
var pI = T_(7);
var z2 = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/;
var cI = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
var mI = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
var yX = /^[^\s@"]{1,64}@[^\s@]{1,255}$/u;
var dI = yX;
var lI = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
function W2() {
  return new RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", "u");
}
var H2 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
var J2 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$/;
var T2 = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/;
var w2 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
var f2 = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/;
var V9 = /^[A-Za-z0-9_-]*$/;
var Z2 = /^(?=.{1,253}\.?$)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[-0-9a-zA-Z]{0,61}[0-9a-zA-Z])?)*\.?$/;
var rI = /^([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$/;
var X2 = /^\+(?:[0-9]){6,14}[0-9]$/;
var uX = "(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))";
var A2 = new RegExp(`^${uX}$`);
function xX($18) {
  return typeof $18.precision === "number" ? $18.precision === -1 ? "(?:[01]\\d|2[0-3]):[0-5]\\d" : $18.precision === 0 ? "(?:[01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d" : `(?:[01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d\\.\\d{${$18.precision}}` : "(?:[01]\\d|2[0-3]):[0-5]\\d(?::[0-5]\\d(?:\\.\\d+)?)?";
}
function k2($18) {
  return new RegExp(`^${xX($18)}$`);
}
function G2($18) {
  let q = xX({ precision: $18.precision }), K = ["Z"];
  if ($18.local) K.push("");
  if ($18.offset) K.push("([+-](?:[01]\\d|2[0-3]):[0-5]\\d)");
  let P = `${q}(?:${K.join("|")})`;
  return new RegExp(`^${uX}T(?:${P})$`);
}
var V2 = ($18) => {
  let q = $18 ? `[\\s\\S]{${($18 == null ? void 0 : $18.minimum) ?? 0},${($18 == null ? void 0 : $18.maximum) ?? ""}}` : "[\\s\\S]*";
  return new RegExp(`^${q}$`);
};
var S2 = /^-?\d+n?$/;
var M2 = /^-?\d+$/;
var N2 = /^-?\d+(?:\.\d+)?/;
var C2 = /^(?:true|false)$/i;
var E2 = /^null$/i;
var h2 = /^undefined$/i;
var R2 = /^[^A-Z]*$/;
var I2 = /^[^a-z]*$/;
var oI = /^[0-9a-fA-F]*$/;
function pP($18, q) {
  return new RegExp(`^[A-Za-z0-9+/]{${$18}}${q}$`);
}
function cP($18) {
  return new RegExp(`^[A-Za-z0-9_-]{${$18}}$`);
}
var nI = /^[0-9a-fA-F]{32}$/;
var iI = pP(22, "==");
var BI = cP(22);
var tI = /^[0-9a-fA-F]{40}$/;
var UI = pP(27, "=");
var FI = cP(27);
var aI = /^[0-9a-fA-F]{64}$/;
var QI = pP(43, "=");
var eI = cP(43);
var sI = /^[0-9a-fA-F]{96}$/;
var $D = pP(64, "");
var qD = cP(64);
var KD = /^[0-9a-fA-F]{128}$/;
var _D = pP(86, "==");
var PD = cP(86);
var I6 = O$("$ZodCheck", ($18, q) => {
  var K;
  $18._zod ?? ($18._zod = {}), $18._zod.def = q, (K = $18._zod).onattach ?? (K.onattach = []);
});
var cX = { number: "number", bigint: "bigint", object: "date" };
var S9 = O$("$ZodCheckLessThan", ($18, q) => {
  I6.init($18, q);
  let K = cX[typeof q.value];
  $18._zod.onattach.push((P) => {
    let _ = P._zod.bag, Y = (q.inclusive ? _.maximum : _.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;
    if (q.value < Y) if (q.inclusive) _.maximum = q.value;
    else _.exclusiveMaximum = q.value;
  }), $18._zod.check = (P) => {
    if (q.inclusive ? P.value <= q.value : P.value < q.value) return;
    P.issues.push({ origin: K, code: "too_big", maximum: q.value, input: P.value, inclusive: q.inclusive, inst: $18, continue: !q.abort });
  };
});
var M9 = O$("$ZodCheckGreaterThan", ($18, q) => {
  I6.init($18, q);
  let K = cX[typeof q.value];
  $18._zod.onattach.push((P) => {
    let _ = P._zod.bag, Y = (q.inclusive ? _.minimum : _.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;
    if (q.value > Y) if (q.inclusive) _.minimum = q.value;
    else _.exclusiveMinimum = q.value;
  }), $18._zod.check = (P) => {
    if (q.inclusive ? P.value >= q.value : P.value > q.value) return;
    P.issues.push({ origin: K, code: "too_small", minimum: q.value, input: P.value, inclusive: q.inclusive, inst: $18, continue: !q.abort });
  };
});
var D2 = O$("$ZodCheckMultipleOf", ($18, q) => {
  I6.init($18, q), $18._zod.onattach.push((K) => {
    var P;
    (P = K._zod.bag).multipleOf ?? (P.multipleOf = q.value);
  }), $18._zod.check = (K) => {
    if (typeof K.value !== typeof q.value) throw Error("Cannot mix number and bigint in multiple_of check.");
    if (typeof K.value === "bigint" ? K.value % q.value === BigInt(0) : nY(K.value, q.value) === 0) return;
    K.issues.push({ origin: typeof K.value, code: "not_multiple_of", divisor: q.value, input: K.value, inst: $18, continue: !q.abort });
  };
});
var L2 = O$("$ZodCheckNumberFormat", ($18, q) => {
  var _a2;
  I6.init($18, q), q.format = q.format || "float64";
  let K = (_a2 = q.format) == null ? void 0 : _a2.includes("int"), P = K ? "int" : "number", [_, Y] = FY[q.format];
  $18._zod.onattach.push((O) => {
    let z = O._zod.bag;
    if (z.format = q.format, z.minimum = _, z.maximum = Y, K) z.pattern = M2;
  }), $18._zod.check = (O) => {
    let z = O.value;
    if (K) {
      if (!Number.isInteger(z)) {
        O.issues.push({ expected: P, format: q.format, code: "invalid_type", continue: false, input: z, inst: $18 });
        return;
      }
      if (!Number.isSafeInteger(z)) {
        if (z > 0) O.issues.push({ input: z, code: "too_big", maximum: Number.MAX_SAFE_INTEGER, note: "Integers must be within the safe integer range.", inst: $18, origin: P, continue: !q.abort });
        else O.issues.push({ input: z, code: "too_small", minimum: Number.MIN_SAFE_INTEGER, note: "Integers must be within the safe integer range.", inst: $18, origin: P, continue: !q.abort });
        return;
      }
    }
    if (z < _) O.issues.push({ origin: "number", input: z, code: "too_small", minimum: _, inclusive: true, inst: $18, continue: !q.abort });
    if (z > Y) O.issues.push({ origin: "number", input: z, code: "too_big", maximum: Y, inst: $18 });
  };
});
var g2 = O$("$ZodCheckBigIntFormat", ($18, q) => {
  I6.init($18, q);
  let [K, P] = aY[q.format];
  $18._zod.onattach.push((_) => {
    let Y = _._zod.bag;
    Y.format = q.format, Y.minimum = K, Y.maximum = P;
  }), $18._zod.check = (_) => {
    let Y = _.value;
    if (Y < K) _.issues.push({ origin: "bigint", input: Y, code: "too_small", minimum: K, inclusive: true, inst: $18, continue: !q.abort });
    if (Y > P) _.issues.push({ origin: "bigint", input: Y, code: "too_big", maximum: P, inst: $18 });
  };
});
var b2 = O$("$ZodCheckMaxSize", ($18, q) => {
  var K;
  I6.init($18, q), (K = $18._zod.def).when ?? (K.when = (P) => {
    let _ = P.value;
    return !pK(_) && _.size !== void 0;
  }), $18._zod.onattach.push((P) => {
    let _ = P._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    if (q.maximum < _) P._zod.bag.maximum = q.maximum;
  }), $18._zod.check = (P) => {
    let _ = P.value;
    if (_.size <= q.maximum) return;
    P.issues.push({ origin: LP(_), code: "too_big", maximum: q.maximum, inclusive: true, input: _, inst: $18, continue: !q.abort });
  };
});
var y2 = O$("$ZodCheckMinSize", ($18, q) => {
  var K;
  I6.init($18, q), (K = $18._zod.def).when ?? (K.when = (P) => {
    let _ = P.value;
    return !pK(_) && _.size !== void 0;
  }), $18._zod.onattach.push((P) => {
    let _ = P._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    if (q.minimum > _) P._zod.bag.minimum = q.minimum;
  }), $18._zod.check = (P) => {
    let _ = P.value;
    if (_.size >= q.minimum) return;
    P.issues.push({ origin: LP(_), code: "too_small", minimum: q.minimum, inclusive: true, input: _, inst: $18, continue: !q.abort });
  };
});
var u2 = O$("$ZodCheckSizeEquals", ($18, q) => {
  var K;
  I6.init($18, q), (K = $18._zod.def).when ?? (K.when = (P) => {
    let _ = P.value;
    return !pK(_) && _.size !== void 0;
  }), $18._zod.onattach.push((P) => {
    let _ = P._zod.bag;
    _.minimum = q.size, _.maximum = q.size, _.size = q.size;
  }), $18._zod.check = (P) => {
    let _ = P.value, Y = _.size;
    if (Y === q.size) return;
    let O = Y > q.size;
    P.issues.push({ origin: LP(_), ...O ? { code: "too_big", maximum: q.size } : { code: "too_small", minimum: q.size }, inclusive: true, exact: true, input: P.value, inst: $18, continue: !q.abort });
  };
});
var x2 = O$("$ZodCheckMaxLength", ($18, q) => {
  var K;
  I6.init($18, q), (K = $18._zod.def).when ?? (K.when = (P) => {
    let _ = P.value;
    return !pK(_) && _.length !== void 0;
  }), $18._zod.onattach.push((P) => {
    let _ = P._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    if (q.maximum < _) P._zod.bag.maximum = q.maximum;
  }), $18._zod.check = (P) => {
    let _ = P.value;
    if (_.length <= q.maximum) return;
    let O = gP(_);
    P.issues.push({ origin: O, code: "too_big", maximum: q.maximum, inclusive: true, input: _, inst: $18, continue: !q.abort });
  };
});
var p2 = O$("$ZodCheckMinLength", ($18, q) => {
  var K;
  I6.init($18, q), (K = $18._zod.def).when ?? (K.when = (P) => {
    let _ = P.value;
    return !pK(_) && _.length !== void 0;
  }), $18._zod.onattach.push((P) => {
    let _ = P._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    if (q.minimum > _) P._zod.bag.minimum = q.minimum;
  }), $18._zod.check = (P) => {
    let _ = P.value;
    if (_.length >= q.minimum) return;
    let O = gP(_);
    P.issues.push({ origin: O, code: "too_small", minimum: q.minimum, inclusive: true, input: _, inst: $18, continue: !q.abort });
  };
});
var c2 = O$("$ZodCheckLengthEquals", ($18, q) => {
  var K;
  I6.init($18, q), (K = $18._zod.def).when ?? (K.when = (P) => {
    let _ = P.value;
    return !pK(_) && _.length !== void 0;
  }), $18._zod.onattach.push((P) => {
    let _ = P._zod.bag;
    _.minimum = q.length, _.maximum = q.length, _.length = q.length;
  }), $18._zod.check = (P) => {
    let _ = P.value, Y = _.length;
    if (Y === q.length) return;
    let O = gP(_), z = Y > q.length;
    P.issues.push({ origin: O, ...z ? { code: "too_big", maximum: q.length } : { code: "too_small", minimum: q.length }, inclusive: true, exact: true, input: P.value, inst: $18, continue: !q.abort });
  };
});
var $42 = O$("$ZodCheckStringFormat", ($18, q) => {
  var K, P;
  if (I6.init($18, q), $18._zod.onattach.push((_) => {
    let Y = _._zod.bag;
    if (Y.format = q.format, q.pattern) Y.patterns ?? (Y.patterns = /* @__PURE__ */ new Set()), Y.patterns.add(q.pattern);
  }), q.pattern) (K = $18._zod).check ?? (K.check = (_) => {
    if (q.pattern.lastIndex = 0, q.pattern.test(_.value)) return;
    _.issues.push({ origin: "string", code: "invalid_format", format: q.format, input: _.value, ...q.pattern ? { pattern: q.pattern.toString() } : {}, inst: $18, continue: !q.abort });
  });
  else (P = $18._zod).check ?? (P.check = () => {
  });
});
var m2 = O$("$ZodCheckRegex", ($18, q) => {
  $42.init($18, q), $18._zod.check = (K) => {
    if (q.pattern.lastIndex = 0, q.pattern.test(K.value)) return;
    K.issues.push({ origin: "string", code: "invalid_format", format: "regex", input: K.value, pattern: q.pattern.toString(), inst: $18, continue: !q.abort });
  };
});
var d2 = O$("$ZodCheckLowerCase", ($18, q) => {
  q.pattern ?? (q.pattern = R2), $42.init($18, q);
});
var l2 = O$("$ZodCheckUpperCase", ($18, q) => {
  q.pattern ?? (q.pattern = I2), $42.init($18, q);
});
var r2 = O$("$ZodCheckIncludes", ($18, q) => {
  I6.init($18, q);
  let K = r8(q.includes), P = new RegExp(typeof q.position === "number" ? `^.{${q.position}}${K}` : K);
  q.pattern = P, $18._zod.onattach.push((_) => {
    let Y = _._zod.bag;
    Y.patterns ?? (Y.patterns = /* @__PURE__ */ new Set()), Y.patterns.add(P);
  }), $18._zod.check = (_) => {
    if (_.value.includes(q.includes, q.position)) return;
    _.issues.push({ origin: "string", code: "invalid_format", format: "includes", includes: q.includes, input: _.value, inst: $18, continue: !q.abort });
  };
});
var o2 = O$("$ZodCheckStartsWith", ($18, q) => {
  I6.init($18, q);
  let K = new RegExp(`^${r8(q.prefix)}.*`);
  q.pattern ?? (q.pattern = K), $18._zod.onattach.push((P) => {
    let _ = P._zod.bag;
    _.patterns ?? (_.patterns = /* @__PURE__ */ new Set()), _.patterns.add(K);
  }), $18._zod.check = (P) => {
    if (P.value.startsWith(q.prefix)) return;
    P.issues.push({ origin: "string", code: "invalid_format", format: "starts_with", prefix: q.prefix, input: P.value, inst: $18, continue: !q.abort });
  };
});
var n2 = O$("$ZodCheckEndsWith", ($18, q) => {
  I6.init($18, q);
  let K = new RegExp(`.*${r8(q.suffix)}$`);
  q.pattern ?? (q.pattern = K), $18._zod.onattach.push((P) => {
    let _ = P._zod.bag;
    _.patterns ?? (_.patterns = /* @__PURE__ */ new Set()), _.patterns.add(K);
  }), $18._zod.check = (P) => {
    if (P.value.endsWith(q.suffix)) return;
    P.issues.push({ origin: "string", code: "invalid_format", format: "ends_with", suffix: q.suffix, input: P.value, inst: $18, continue: !q.abort });
  };
});
function pX($18, q, K) {
  if ($18.issues.length) q.issues.push(...P8(K, $18.issues));
}
var i2 = O$("$ZodCheckProperty", ($18, q) => {
  I6.init($18, q), $18._zod.check = (K) => {
    let P = q.schema._zod.run({ value: K.value[q.property], issues: [] }, {});
    if (P instanceof Promise) return P.then((_) => pX(_, K, q.property));
    pX(P, K, q.property);
    return;
  };
});
var B2 = O$("$ZodCheckMimeType", ($18, q) => {
  I6.init($18, q);
  let K = new Set(q.mime);
  $18._zod.onattach.push((P) => {
    P._zod.bag.mime = q.mime;
  }), $18._zod.check = (P) => {
    if (K.has(P.value.type)) return;
    P.issues.push({ code: "invalid_value", values: q.mime, input: P.value.type, inst: $18, continue: !q.abort });
  };
});
var t2 = O$("$ZodCheckOverwrite", ($18, q) => {
  I6.init($18, q), $18._zod.check = (K) => {
    K.value = q.tx(K.value);
  };
});
var N9 = class {
  constructor($18 = []) {
    if (this.content = [], this.indent = 0, this) this.args = $18;
  }
  indented($18) {
    this.indent += 1, $18(this), this.indent -= 1;
  }
  write($18) {
    if (typeof $18 === "function") {
      $18(this, { execution: "sync" }), $18(this, { execution: "async" });
      return;
    }
    let K = $18.split(`
`).filter((Y) => Y), P = Math.min(...K.map((Y) => Y.length - Y.trimStart().length)), _ = K.map((Y) => Y.slice(P)).map((Y) => " ".repeat(this.indent * 2) + Y);
    for (let Y of _) this.content.push(Y);
  }
  compile() {
    let $18 = Function, q = this == null ? void 0 : this.args, P = [...((this == null ? void 0 : this.content) ?? [""]).map((_) => `  ${_}`)];
    return new $18(...q, P.join(`
`));
  }
};
var U2 = { major: 4, minor: 1, patch: 11 };
var P6 = O$("$ZodType", ($18, q) => {
  var _a2;
  var K;
  $18 ?? ($18 = {}), $18._zod.def = q, $18._zod.bag = $18._zod.bag || {}, $18._zod.version = U2;
  let P = [...$18._zod.def.checks ?? []];
  if ($18._zod.traits.has("$ZodCheck")) P.unshift($18);
  for (let _ of P) for (let Y of _._zod.onattach) Y($18);
  if (P.length === 0) (K = $18._zod).deferred ?? (K.deferred = []), (_a2 = $18._zod.deferred) == null ? void 0 : _a2.push(() => {
    $18._zod.run = $18._zod.parse;
  });
  else {
    let _ = (O, z, J) => {
      let T = lK(O), X;
      for (let f of z) {
        if (f._zod.def.when) {
          if (!f._zod.def.when(O)) continue;
        } else if (T) continue;
        let V = O.issues.length, M = f._zod.check(O);
        if (M instanceof Promise && (J == null ? void 0 : J.async) === false) throw new l8();
        if (X || M instanceof Promise) X = (X ?? Promise.resolve()).then(async () => {
          if (await M, O.issues.length === V) return;
          if (!T) T = lK(O, V);
        });
        else {
          if (O.issues.length === V) continue;
          if (!T) T = lK(O, V);
        }
      }
      if (X) return X.then(() => {
        return O;
      });
      return O;
    }, Y = (O, z, J) => {
      if (lK(O)) return O.aborted = true, O;
      let T = _(z, P, J);
      if (T instanceof Promise) {
        if (J.async === false) throw new l8();
        return T.then((X) => $18._zod.parse(X, J));
      }
      return $18._zod.parse(T, J);
    };
    $18._zod.run = (O, z) => {
      if (z.skipChecks) return $18._zod.parse(O, z);
      if (z.direction === "backward") {
        let T = $18._zod.parse({ value: O.value, issues: [] }, { ...z, skipChecks: true });
        if (T instanceof Promise) return T.then((X) => {
          return Y(X, O, z);
        });
        return Y(T, O, z);
      }
      let J = $18._zod.parse(O, z);
      if (J instanceof Promise) {
        if (z.async === false) throw new l8();
        return J.then((T) => _(T, P, z));
      }
      return _(J, P, z);
    };
  }
  $18["~standard"] = { validate: (_) => {
    var _a3;
    try {
      let Y = sY($18, _);
      return Y.success ? { value: Y.data } : { issues: (_a3 = Y.error) == null ? void 0 : _a3.issues };
    } catch (Y) {
      return $22($18, _).then((O) => {
        var _a4;
        return O.success ? { value: O.data } : { issues: (_a4 = O.error) == null ? void 0 : _a4.issues };
      });
    }
  }, vendor: "zod", version: 1 };
});
var w_ = O$("$ZodString", ($18, q) => {
  var _a2;
  P6.init($18, q), $18._zod.pattern = [...((_a2 = $18 == null ? void 0 : $18._zod.bag) == null ? void 0 : _a2.patterns) ?? []].pop() ?? V2($18._zod.bag), $18._zod.parse = (K, P) => {
    if (q.coerce) try {
      K.value = String(K.value);
    } catch (_) {
    }
    if (typeof K.value === "string") return K;
    return K.issues.push({ expected: "string", code: "invalid_type", input: K.value, inst: $18 }), K;
  };
});
var E6 = O$("$ZodStringFormat", ($18, q) => {
  $42.init($18, q), w_.init($18, q);
});
var a2 = O$("$ZodGUID", ($18, q) => {
  q.pattern ?? (q.pattern = v2), E6.init($18, q);
});
var Q2 = O$("$ZodUUID", ($18, q) => {
  if (q.version) {
    let P = { v1: 1, v2: 2, v3: 3, v4: 4, v5: 5, v6: 6, v7: 7, v8: 8 }[q.version];
    if (P === void 0) throw Error(`Invalid UUID version: "${q.version}"`);
    q.pattern ?? (q.pattern = T_(P));
  } else q.pattern ?? (q.pattern = T_());
  E6.init($18, q);
});
var e2 = O$("$ZodEmail", ($18, q) => {
  q.pattern ?? (q.pattern = z2), E6.init($18, q);
});
var s2 = O$("$ZodURL", ($18, q) => {
  E6.init($18, q), $18._zod.check = (K) => {
    try {
      let P = K.value.trim(), _ = new URL(P);
      if (q.hostname) {
        if (q.hostname.lastIndex = 0, !q.hostname.test(_.hostname)) K.issues.push({ code: "invalid_format", format: "url", note: "Invalid hostname", pattern: Z2.source, input: K.value, inst: $18, continue: !q.abort });
      }
      if (q.protocol) {
        if (q.protocol.lastIndex = 0, !q.protocol.test(_.protocol.endsWith(":") ? _.protocol.slice(0, -1) : _.protocol)) K.issues.push({ code: "invalid_format", format: "url", note: "Invalid protocol", pattern: q.protocol.source, input: K.value, inst: $18, continue: !q.abort });
      }
      if (q.normalize) K.value = _.href;
      else K.value = P;
      return;
    } catch (P) {
      K.issues.push({ code: "invalid_format", format: "url", input: K.value, inst: $18, continue: !q.abort });
    }
  };
});
var $j = O$("$ZodEmoji", ($18, q) => {
  q.pattern ?? (q.pattern = W2()), E6.init($18, q);
});
var qj = O$("$ZodNanoID", ($18, q) => {
  q.pattern ?? (q.pattern = Y2), E6.init($18, q);
});
var Kj = O$("$ZodCUID", ($18, q) => {
  q.pattern ?? (q.pattern = q2), E6.init($18, q);
});
var _j = O$("$ZodCUID2", ($18, q) => {
  q.pattern ?? (q.pattern = K2), E6.init($18, q);
});
var Pj = O$("$ZodULID", ($18, q) => {
  q.pattern ?? (q.pattern = _2), E6.init($18, q);
});
var Oj = O$("$ZodXID", ($18, q) => {
  q.pattern ?? (q.pattern = P2), E6.init($18, q);
});
var Yj = O$("$ZodKSUID", ($18, q) => {
  q.pattern ?? (q.pattern = O2), E6.init($18, q);
});
var jj = O$("$ZodISODateTime", ($18, q) => {
  q.pattern ?? (q.pattern = G2(q)), E6.init($18, q);
});
var vj = O$("$ZodISODate", ($18, q) => {
  q.pattern ?? (q.pattern = A2), E6.init($18, q);
});
var zj = O$("$ZodISOTime", ($18, q) => {
  q.pattern ?? (q.pattern = k2(q)), E6.init($18, q);
});
var Wj = O$("$ZodISODuration", ($18, q) => {
  q.pattern ?? (q.pattern = j2), E6.init($18, q);
});
var Hj = O$("$ZodIPv4", ($18, q) => {
  q.pattern ?? (q.pattern = H2), E6.init($18, q), $18._zod.onattach.push((K) => {
    let P = K._zod.bag;
    P.format = "ipv4";
  });
});
var Jj = O$("$ZodIPv6", ($18, q) => {
  q.pattern ?? (q.pattern = J2), E6.init($18, q), $18._zod.onattach.push((K) => {
    let P = K._zod.bag;
    P.format = "ipv6";
  }), $18._zod.check = (K) => {
    try {
      new URL(`http://[${K.value}]`);
    } catch {
      K.issues.push({ code: "invalid_format", format: "ipv6", input: K.value, inst: $18, continue: !q.abort });
    }
  };
});
var Tj = O$("$ZodCIDRv4", ($18, q) => {
  q.pattern ?? (q.pattern = T2), E6.init($18, q);
});
var wj = O$("$ZodCIDRv6", ($18, q) => {
  q.pattern ?? (q.pattern = w2), E6.init($18, q), $18._zod.check = (K) => {
    let P = K.value.split("/");
    try {
      if (P.length !== 2) throw Error();
      let [_, Y] = P;
      if (!Y) throw Error();
      let O = Number(Y);
      if (`${O}` !== Y) throw Error();
      if (O < 0 || O > 128) throw Error();
      new URL(`http://[${_}]`);
    } catch {
      K.issues.push({ code: "invalid_format", format: "cidrv6", input: K.value, inst: $18, continue: !q.abort });
    }
  };
});
function fj($18) {
  if ($18 === "") return true;
  if ($18.length % 4 !== 0) return false;
  try {
    return atob($18), true;
  } catch {
    return false;
  }
}
var Zj = O$("$ZodBase64", ($18, q) => {
  q.pattern ?? (q.pattern = f2), E6.init($18, q), $18._zod.onattach.push((K) => {
    K._zod.bag.contentEncoding = "base64";
  }), $18._zod.check = (K) => {
    if (fj(K.value)) return;
    K.issues.push({ code: "invalid_format", format: "base64", input: K.value, inst: $18, continue: !q.abort });
  };
});
function aX($18) {
  if (!V9.test($18)) return false;
  let q = $18.replace(/[-_]/g, (P) => P === "-" ? "+" : "/"), K = q.padEnd(Math.ceil(q.length / 4) * 4, "=");
  return fj(K);
}
var Xj = O$("$ZodBase64URL", ($18, q) => {
  q.pattern ?? (q.pattern = V9), E6.init($18, q), $18._zod.onattach.push((K) => {
    K._zod.bag.contentEncoding = "base64url";
  }), $18._zod.check = (K) => {
    if (aX(K.value)) return;
    K.issues.push({ code: "invalid_format", format: "base64url", input: K.value, inst: $18, continue: !q.abort });
  };
});
var Aj = O$("$ZodE164", ($18, q) => {
  q.pattern ?? (q.pattern = X2), E6.init($18, q);
});
function QX($18, q = null) {
  try {
    let K = $18.split(".");
    if (K.length !== 3) return false;
    let [P] = K;
    if (!P) return false;
    let _ = JSON.parse(atob(P));
    if ("typ" in _ && (_ == null ? void 0 : _.typ) !== "JWT") return false;
    if (!_.alg) return false;
    if (q && (!("alg" in _) || _.alg !== q)) return false;
    return true;
  } catch {
    return false;
  }
}
var kj = O$("$ZodJWT", ($18, q) => {
  E6.init($18, q), $18._zod.check = (K) => {
    if (QX(K.value, q.alg)) return;
    K.issues.push({ code: "invalid_format", format: "jwt", input: K.value, inst: $18, continue: !q.abort });
  };
});
var Gj = O$("$ZodCustomStringFormat", ($18, q) => {
  E6.init($18, q), $18._zod.check = (K) => {
    if (q.fn(K.value)) return;
    K.issues.push({ code: "invalid_format", format: q.format, input: K.value, inst: $18, continue: !q.abort });
  };
});
var D9 = O$("$ZodNumber", ($18, q) => {
  P6.init($18, q), $18._zod.pattern = $18._zod.bag.pattern ?? N2, $18._zod.parse = (K, P) => {
    if (q.coerce) try {
      K.value = Number(K.value);
    } catch (O) {
    }
    let _ = K.value;
    if (typeof _ === "number" && !Number.isNaN(_) && Number.isFinite(_)) return K;
    let Y = typeof _ === "number" ? Number.isNaN(_) ? "NaN" : !Number.isFinite(_) ? "Infinity" : void 0 : void 0;
    return K.issues.push({ expected: "number", code: "invalid_type", input: _, inst: $18, ...Y ? { received: Y } : {} }), K;
  };
});
var Vj = O$("$ZodNumber", ($18, q) => {
  L2.init($18, q), D9.init($18, q);
});
var mP = O$("$ZodBoolean", ($18, q) => {
  P6.init($18, q), $18._zod.pattern = C2, $18._zod.parse = (K, P) => {
    if (q.coerce) try {
      K.value = Boolean(K.value);
    } catch (Y) {
    }
    let _ = K.value;
    if (typeof _ === "boolean") return K;
    return K.issues.push({ expected: "boolean", code: "invalid_type", input: _, inst: $18 }), K;
  };
});
var L9 = O$("$ZodBigInt", ($18, q) => {
  P6.init($18, q), $18._zod.pattern = S2, $18._zod.parse = (K, P) => {
    if (q.coerce) try {
      K.value = BigInt(K.value);
    } catch (_) {
    }
    if (typeof K.value === "bigint") return K;
    return K.issues.push({ expected: "bigint", code: "invalid_type", input: K.value, inst: $18 }), K;
  };
});
var Sj = O$("$ZodBigInt", ($18, q) => {
  g2.init($18, q), L9.init($18, q);
});
var Mj = O$("$ZodSymbol", ($18, q) => {
  P6.init($18, q), $18._zod.parse = (K, P) => {
    let _ = K.value;
    if (typeof _ === "symbol") return K;
    return K.issues.push({ expected: "symbol", code: "invalid_type", input: _, inst: $18 }), K;
  };
});
var Nj = O$("$ZodUndefined", ($18, q) => {
  P6.init($18, q), $18._zod.pattern = h2, $18._zod.values = /* @__PURE__ */ new Set([void 0]), $18._zod.optin = "optional", $18._zod.optout = "optional", $18._zod.parse = (K, P) => {
    let _ = K.value;
    if (typeof _ > "u") return K;
    return K.issues.push({ expected: "undefined", code: "invalid_type", input: _, inst: $18 }), K;
  };
});
var Cj = O$("$ZodNull", ($18, q) => {
  P6.init($18, q), $18._zod.pattern = E2, $18._zod.values = /* @__PURE__ */ new Set([null]), $18._zod.parse = (K, P) => {
    let _ = K.value;
    if (_ === null) return K;
    return K.issues.push({ expected: "null", code: "invalid_type", input: _, inst: $18 }), K;
  };
});
var Ej = O$("$ZodAny", ($18, q) => {
  P6.init($18, q), $18._zod.parse = (K) => K;
});
var g9 = O$("$ZodUnknown", ($18, q) => {
  P6.init($18, q), $18._zod.parse = (K) => K;
});
var dP = O$("$ZodNever", ($18, q) => {
  P6.init($18, q), $18._zod.parse = (K, P) => {
    return K.issues.push({ expected: "never", code: "invalid_type", input: K.value, inst: $18 }), K;
  };
});
var hj = O$("$ZodVoid", ($18, q) => {
  P6.init($18, q), $18._zod.parse = (K, P) => {
    let _ = K.value;
    if (typeof _ > "u") return K;
    return K.issues.push({ expected: "void", code: "invalid_type", input: _, inst: $18 }), K;
  };
});
var Rj = O$("$ZodDate", ($18, q) => {
  P6.init($18, q), $18._zod.parse = (K, P) => {
    if (q.coerce) try {
      K.value = new Date(K.value);
    } catch (z) {
    }
    let _ = K.value, Y = _ instanceof Date;
    if (Y && !Number.isNaN(_.getTime())) return K;
    return K.issues.push({ expected: "date", code: "invalid_type", input: _, ...Y ? { received: "Invalid Date" } : {}, inst: $18 }), K;
  };
});
function dX($18, q, K) {
  if ($18.issues.length) q.issues.push(...P8(K, $18.issues));
  q.value[K] = $18.value;
}
var Ij = O$("$ZodArray", ($18, q) => {
  P6.init($18, q), $18._zod.parse = (K, P) => {
    let _ = K.value;
    if (!Array.isArray(_)) return K.issues.push({ expected: "array", code: "invalid_type", input: _, inst: $18 }), K;
    K.value = Array(_.length);
    let Y = [];
    for (let O = 0; O < _.length; O++) {
      let z = _[O], J = q.element._zod.run({ value: z, issues: [] }, P);
      if (J instanceof Promise) Y.push(J.then((T) => dX(T, K, O)));
      else dX(J, K, O);
    }
    if (Y.length) return Promise.all(Y).then(() => K);
    return K;
  };
});
function I9($18, q, K, P) {
  if ($18.issues.length) q.issues.push(...P8(K, $18.issues));
  if ($18.value === void 0) {
    if (K in P) q.value[K] = void 0;
  } else q.value[K] = $18.value;
}
function eX($18) {
  var _a2, _b2, _c, _d2;
  let q = Object.keys($18.shape);
  for (let P of q) if (!((_d2 = (_c = (_b2 = (_a2 = $18.shape) == null ? void 0 : _a2[P]) == null ? void 0 : _b2._zod) == null ? void 0 : _c.traits) == null ? void 0 : _d2.has("$ZodType"))) throw Error(`Invalid element at key "${P}": expected a Zod schema`);
  let K = UY($18.shape);
  return { ...$18, keys: q, keySet: new Set(q), numKeys: q.length, optionalKeys: new Set(K) };
}
function sX($18, q, K, P, _, Y) {
  let O = [], z = _.keySet, J = _.catchall._zod, T = J.def.type;
  for (let X of Object.keys(q)) {
    if (z.has(X)) continue;
    if (T === "never") {
      O.push(X);
      continue;
    }
    let f = J.run({ value: q[X], issues: [] }, P);
    if (f instanceof Promise) $18.push(f.then((V) => I9(V, K, X, q)));
    else I9(f, K, X, q);
  }
  if (O.length) K.issues.push({ code: "unrecognized_keys", keys: O, input: q, inst: Y });
  if (!$18.length) return K;
  return Promise.all($18).then(() => {
    return K;
  });
}
var $A = O$("$ZodObject", ($18, q) => {
  var _a2;
  if (P6.init($18, q), !((_a2 = Object.getOwnPropertyDescriptor(q, "shape")) == null ? void 0 : _a2.get)) {
    let z = q.shape;
    Object.defineProperty(q, "shape", { get: () => {
      let J = { ...z };
      return Object.defineProperty(q, "shape", { value: J }), J;
    } });
  }
  let P = t_(() => eX(q));
  A6($18._zod, "propValues", () => {
    let z = q.shape, J = {};
    for (let T in z) {
      let X = z[T]._zod;
      if (X.values) {
        J[T] ?? (J[T] = /* @__PURE__ */ new Set());
        for (let f of X.values) J[T].add(f);
      }
    }
    return J;
  });
  let _ = J_, Y = q.catchall, O;
  $18._zod.parse = (z, J) => {
    O ?? (O = P.value);
    let T = z.value;
    if (!_(T)) return z.issues.push({ expected: "object", code: "invalid_type", input: T, inst: $18 }), z;
    z.value = {};
    let X = [], f = O.shape;
    for (let V of O.keys) {
      let N = f[V]._zod.run({ value: T[V], issues: [] }, J);
      if (N instanceof Promise) X.push(N.then((h) => I9(h, z, V, T)));
      else I9(N, z, V, T);
    }
    if (!Y) return X.length ? Promise.all(X).then(() => z) : z;
    return sX(X, T, z, J, P.value, $18);
  };
});
var Dj = O$("$ZodObjectJIT", ($18, q) => {
  $A.init($18, q);
  let K = $18._zod.parse, P = t_(() => eX(q)), _ = (V) => {
    let M = new N9(["shape", "payload", "ctx"]), N = P.value, h = (g) => {
      let b = H9(g);
      return `shape[${b}]._zod.run({ value: input[${b}], issues: [] }, ctx)`;
    };
    M.write("const input = payload.value;");
    let E = /* @__PURE__ */ Object.create(null), I = 0;
    for (let g of N.keys) E[g] = `key_${I++}`;
    M.write("const newResult = {};");
    for (let g of N.keys) {
      let b = E[g], y = H9(g);
      M.write(`const ${b} = ${h(g)};`), M.write(`
        if (${b}.issues.length) {
          payload.issues = payload.issues.concat(${b}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${y}, ...iss.path] : [${y}]
          })));
        }
        
        
        if (${b}.value === undefined) {
          if (${y} in input) {
            newResult[${y}] = undefined;
          }
        } else {
          newResult[${y}] = ${b}.value;
        }
        
      `);
    }
    M.write("payload.value = newResult;"), M.write("return payload;");
    let D = M.compile();
    return (g, b) => D(V, g, b);
  }, Y, O = J_, z = !EP.jitless, T = z && iY.value, X = q.catchall, f;
  $18._zod.parse = (V, M) => {
    f ?? (f = P.value);
    let N = V.value;
    if (!O(N)) return V.issues.push({ expected: "object", code: "invalid_type", input: N, inst: $18 }), V;
    if (z && T && (M == null ? void 0 : M.async) === false && M.jitless !== true) {
      if (!Y) Y = _(q.shape);
      if (V = Y(V, M), !X) return V;
      return sX([], N, V, M, f, $18);
    }
    return K(V, M);
  };
});
function lX($18, q, K, P) {
  for (let Y of $18) if (Y.issues.length === 0) return q.value = Y.value, q;
  let _ = $18.filter((Y) => !lK(Y));
  if (_.length === 1) return q.value = _[0].value, _[0];
  return q.issues.push({ code: "invalid_union", input: q.value, inst: K, errors: $18.map((Y) => Y.issues.map((O) => O8(O, P, r6()))) }), q;
}
var b9 = O$("$ZodUnion", ($18, q) => {
  P6.init($18, q), A6($18._zod, "optin", () => q.options.some((_) => _._zod.optin === "optional") ? "optional" : void 0), A6($18._zod, "optout", () => q.options.some((_) => _._zod.optout === "optional") ? "optional" : void 0), A6($18._zod, "values", () => {
    if (q.options.every((_) => _._zod.values)) return new Set(q.options.flatMap((_) => Array.from(_._zod.values)));
    return;
  }), A6($18._zod, "pattern", () => {
    if (q.options.every((_) => _._zod.pattern)) {
      let _ = q.options.map((Y) => Y._zod.pattern);
      return new RegExp(`^(${_.map((Y) => IP(Y.source)).join("|")})$`);
    }
    return;
  });
  let K = q.options.length === 1, P = q.options[0]._zod.run;
  $18._zod.parse = (_, Y) => {
    if (K) return P(_, Y);
    let O = false, z = [];
    for (let J of q.options) {
      let T = J._zod.run({ value: _.value, issues: [] }, Y);
      if (T instanceof Promise) z.push(T), O = true;
      else {
        if (T.issues.length === 0) return T;
        z.push(T);
      }
    }
    if (!O) return lX(z, _, $18, Y);
    return Promise.all(z).then((J) => {
      return lX(J, _, $18, Y);
    });
  };
});
var Lj = O$("$ZodDiscriminatedUnion", ($18, q) => {
  b9.init($18, q);
  let K = $18._zod.parse;
  A6($18._zod, "propValues", () => {
    let _ = {};
    for (let Y of q.options) {
      let O = Y._zod.propValues;
      if (!O || Object.keys(O).length === 0) throw Error(`Invalid discriminated union option at index "${q.options.indexOf(Y)}"`);
      for (let [z, J] of Object.entries(O)) {
        if (!_[z]) _[z] = /* @__PURE__ */ new Set();
        for (let T of J) _[z].add(T);
      }
    }
    return _;
  });
  let P = t_(() => {
    var _a2;
    let _ = q.options, Y = /* @__PURE__ */ new Map();
    for (let O of _) {
      let z = (_a2 = O._zod.propValues) == null ? void 0 : _a2[q.discriminator];
      if (!z || z.size === 0) throw Error(`Invalid discriminated union option at index "${q.options.indexOf(O)}"`);
      for (let J of z) {
        if (Y.has(J)) throw Error(`Duplicate discriminator value "${String(J)}"`);
        Y.set(J, O);
      }
    }
    return Y;
  });
  $18._zod.parse = (_, Y) => {
    let O = _.value;
    if (!J_(O)) return _.issues.push({ code: "invalid_type", expected: "object", input: O, inst: $18 }), _;
    let z = P.value.get(O == null ? void 0 : O[q.discriminator]);
    if (z) return z._zod.run(_, Y);
    if (q.unionFallback) return K(_, Y);
    return _.issues.push({ code: "invalid_union", errors: [], note: "No matching discriminator", discriminator: q.discriminator, input: O, path: [q.discriminator], inst: $18 }), _;
  };
});
var gj = O$("$ZodIntersection", ($18, q) => {
  P6.init($18, q), $18._zod.parse = (K, P) => {
    let _ = K.value, Y = q.left._zod.run({ value: _, issues: [] }, P), O = q.right._zod.run({ value: _, issues: [] }, P);
    if (Y instanceof Promise || O instanceof Promise) return Promise.all([Y, O]).then(([J, T]) => {
      return rX(K, J, T);
    });
    return rX(K, Y, O);
  };
});
function F2($18, q) {
  if ($18 === q) return { valid: true, data: $18 };
  if ($18 instanceof Date && q instanceof Date && +$18 === +q) return { valid: true, data: $18 };
  if (dK($18) && dK(q)) {
    let K = Object.keys(q), P = Object.keys($18).filter((Y) => K.indexOf(Y) !== -1), _ = { ...$18, ...q };
    for (let Y of P) {
      let O = F2($18[Y], q[Y]);
      if (!O.valid) return { valid: false, mergeErrorPath: [Y, ...O.mergeErrorPath] };
      _[Y] = O.data;
    }
    return { valid: true, data: _ };
  }
  if (Array.isArray($18) && Array.isArray(q)) {
    if ($18.length !== q.length) return { valid: false, mergeErrorPath: [] };
    let K = [];
    for (let P = 0; P < $18.length; P++) {
      let _ = $18[P], Y = q[P], O = F2(_, Y);
      if (!O.valid) return { valid: false, mergeErrorPath: [P, ...O.mergeErrorPath] };
      K.push(O.data);
    }
    return { valid: true, data: K };
  }
  return { valid: false, mergeErrorPath: [] };
}
function rX($18, q, K) {
  if (q.issues.length) $18.issues.push(...q.issues);
  if (K.issues.length) $18.issues.push(...K.issues);
  if (lK($18)) return $18;
  let P = F2(q.value, K.value);
  if (!P.valid) throw Error(`Unmergable intersection. Error path: ${JSON.stringify(P.mergeErrorPath)}`);
  return $18.value = P.data, $18;
}
var y9 = O$("$ZodTuple", ($18, q) => {
  P6.init($18, q);
  let K = q.items, P = K.length - [...K].reverse().findIndex((_) => _._zod.optin !== "optional");
  $18._zod.parse = (_, Y) => {
    let O = _.value;
    if (!Array.isArray(O)) return _.issues.push({ input: O, inst: $18, expected: "tuple", code: "invalid_type" }), _;
    _.value = [];
    let z = [];
    if (!q.rest) {
      let T = O.length > K.length, X = O.length < P - 1;
      if (T || X) return _.issues.push({ ...T ? { code: "too_big", maximum: K.length } : { code: "too_small", minimum: K.length }, input: O, inst: $18, origin: "array" }), _;
    }
    let J = -1;
    for (let T of K) {
      if (J++, J >= O.length) {
        if (J >= P) continue;
      }
      let X = T._zod.run({ value: O[J], issues: [] }, Y);
      if (X instanceof Promise) z.push(X.then((f) => C9(f, _, J)));
      else C9(X, _, J);
    }
    if (q.rest) {
      let T = O.slice(K.length);
      for (let X of T) {
        J++;
        let f = q.rest._zod.run({ value: X, issues: [] }, Y);
        if (f instanceof Promise) z.push(f.then((V) => C9(V, _, J)));
        else C9(f, _, J);
      }
    }
    if (z.length) return Promise.all(z).then(() => _);
    return _;
  };
});
function C9($18, q, K) {
  if ($18.issues.length) q.issues.push(...P8(K, $18.issues));
  q.value[K] = $18.value;
}
var bj = O$("$ZodRecord", ($18, q) => {
  P6.init($18, q), $18._zod.parse = (K, P) => {
    let _ = K.value;
    if (!dK(_)) return K.issues.push({ expected: "record", code: "invalid_type", input: _, inst: $18 }), K;
    let Y = [];
    if (q.keyType._zod.values) {
      let O = q.keyType._zod.values;
      K.value = {};
      for (let J of O) if (typeof J === "string" || typeof J === "number" || typeof J === "symbol") {
        let T = q.valueType._zod.run({ value: _[J], issues: [] }, P);
        if (T instanceof Promise) Y.push(T.then((X) => {
          if (X.issues.length) K.issues.push(...P8(J, X.issues));
          K.value[J] = X.value;
        }));
        else {
          if (T.issues.length) K.issues.push(...P8(J, T.issues));
          K.value[J] = T.value;
        }
      }
      let z;
      for (let J in _) if (!O.has(J)) z = z ?? [], z.push(J);
      if (z && z.length > 0) K.issues.push({ code: "unrecognized_keys", input: _, inst: $18, keys: z });
    } else {
      K.value = {};
      for (let O of Reflect.ownKeys(_)) {
        if (O === "__proto__") continue;
        let z = q.keyType._zod.run({ value: O, issues: [] }, P);
        if (z instanceof Promise) throw Error("Async schemas not supported in object keys currently");
        if (z.issues.length) {
          K.issues.push({ code: "invalid_key", origin: "record", issues: z.issues.map((T) => O8(T, P, r6())), input: O, path: [O], inst: $18 }), K.value[z.value] = z.value;
          continue;
        }
        let J = q.valueType._zod.run({ value: _[O], issues: [] }, P);
        if (J instanceof Promise) Y.push(J.then((T) => {
          if (T.issues.length) K.issues.push(...P8(O, T.issues));
          K.value[z.value] = T.value;
        }));
        else {
          if (J.issues.length) K.issues.push(...P8(O, J.issues));
          K.value[z.value] = J.value;
        }
      }
    }
    if (Y.length) return Promise.all(Y).then(() => K);
    return K;
  };
});
var yj = O$("$ZodMap", ($18, q) => {
  P6.init($18, q), $18._zod.parse = (K, P) => {
    let _ = K.value;
    if (!(_ instanceof Map)) return K.issues.push({ expected: "map", code: "invalid_type", input: _, inst: $18 }), K;
    let Y = [];
    K.value = /* @__PURE__ */ new Map();
    for (let [O, z] of _) {
      let J = q.keyType._zod.run({ value: O, issues: [] }, P), T = q.valueType._zod.run({ value: z, issues: [] }, P);
      if (J instanceof Promise || T instanceof Promise) Y.push(Promise.all([J, T]).then(([X, f]) => {
        oX(X, f, K, O, _, $18, P);
      }));
      else oX(J, T, K, O, _, $18, P);
    }
    if (Y.length) return Promise.all(Y).then(() => K);
    return K;
  };
});
function oX($18, q, K, P, _, Y, O) {
  if ($18.issues.length) if (DP.has(typeof P)) K.issues.push(...P8(P, $18.issues));
  else K.issues.push({ code: "invalid_key", origin: "map", input: _, inst: Y, issues: $18.issues.map((z) => O8(z, O, r6())) });
  if (q.issues.length) if (DP.has(typeof P)) K.issues.push(...P8(P, q.issues));
  else K.issues.push({ origin: "map", code: "invalid_element", input: _, inst: Y, key: P, issues: q.issues.map((z) => O8(z, O, r6())) });
  K.value.set($18.value, q.value);
}
var uj = O$("$ZodSet", ($18, q) => {
  P6.init($18, q), $18._zod.parse = (K, P) => {
    let _ = K.value;
    if (!(_ instanceof Set)) return K.issues.push({ input: _, inst: $18, expected: "set", code: "invalid_type" }), K;
    let Y = [];
    K.value = /* @__PURE__ */ new Set();
    for (let O of _) {
      let z = q.valueType._zod.run({ value: O, issues: [] }, P);
      if (z instanceof Promise) Y.push(z.then((J) => nX(J, K)));
      else nX(z, K);
    }
    if (Y.length) return Promise.all(Y).then(() => K);
    return K;
  };
});
function nX($18, q) {
  if ($18.issues.length) q.issues.push(...$18.issues);
  q.value.add($18.value);
}
var xj = O$("$ZodEnum", ($18, q) => {
  P6.init($18, q);
  let K = RP(q.entries), P = new Set(K);
  $18._zod.values = P, $18._zod.pattern = new RegExp(`^(${K.filter((_) => DP.has(typeof _)).map((_) => typeof _ === "string" ? r8(_) : _.toString()).join("|")})$`), $18._zod.parse = (_, Y) => {
    let O = _.value;
    if (P.has(O)) return _;
    return _.issues.push({ code: "invalid_value", values: K, input: O, inst: $18 }), _;
  };
});
var pj = O$("$ZodLiteral", ($18, q) => {
  if (P6.init($18, q), q.values.length === 0) throw Error("Cannot create literal schema with no valid values");
  $18._zod.values = new Set(q.values), $18._zod.pattern = new RegExp(`^(${q.values.map((K) => typeof K === "string" ? r8(K) : K ? r8(K.toString()) : String(K)).join("|")})$`), $18._zod.parse = (K, P) => {
    let _ = K.value;
    if ($18._zod.values.has(_)) return K;
    return K.issues.push({ code: "invalid_value", values: q.values, input: _, inst: $18 }), K;
  };
});
var cj = O$("$ZodFile", ($18, q) => {
  P6.init($18, q), $18._zod.parse = (K, P) => {
    let _ = K.value;
    if (_ instanceof File) return K;
    return K.issues.push({ expected: "file", code: "invalid_type", input: _, inst: $18 }), K;
  };
});
var mj = O$("$ZodTransform", ($18, q) => {
  P6.init($18, q), $18._zod.parse = (K, P) => {
    if (P.direction === "backward") throw new H_($18.constructor.name);
    let _ = q.transform(K.value, K);
    if (P.async) return (_ instanceof Promise ? _ : Promise.resolve(_)).then((O) => {
      return K.value = O, K;
    });
    if (_ instanceof Promise) throw new l8();
    return K.value = _, K;
  };
});
function iX($18, q) {
  if ($18.issues.length && q === void 0) return { issues: [], value: void 0 };
  return $18;
}
var u9 = O$("$ZodOptional", ($18, q) => {
  P6.init($18, q), $18._zod.optin = "optional", $18._zod.optout = "optional", A6($18._zod, "values", () => {
    return q.innerType._zod.values ? /* @__PURE__ */ new Set([...q.innerType._zod.values, void 0]) : void 0;
  }), A6($18._zod, "pattern", () => {
    let K = q.innerType._zod.pattern;
    return K ? new RegExp(`^(${IP(K.source)})?$`) : void 0;
  }), $18._zod.parse = (K, P) => {
    if (q.innerType._zod.optin === "optional") {
      let _ = q.innerType._zod.run(K, P);
      if (_ instanceof Promise) return _.then((Y) => iX(Y, K.value));
      return iX(_, K.value);
    }
    if (K.value === void 0) return K;
    return q.innerType._zod.run(K, P);
  };
});
var dj = O$("$ZodNullable", ($18, q) => {
  P6.init($18, q), A6($18._zod, "optin", () => q.innerType._zod.optin), A6($18._zod, "optout", () => q.innerType._zod.optout), A6($18._zod, "pattern", () => {
    let K = q.innerType._zod.pattern;
    return K ? new RegExp(`^(${IP(K.source)}|null)$`) : void 0;
  }), A6($18._zod, "values", () => {
    return q.innerType._zod.values ? /* @__PURE__ */ new Set([...q.innerType._zod.values, null]) : void 0;
  }), $18._zod.parse = (K, P) => {
    if (K.value === null) return K;
    return q.innerType._zod.run(K, P);
  };
});
var lj = O$("$ZodDefault", ($18, q) => {
  P6.init($18, q), $18._zod.optin = "optional", A6($18._zod, "values", () => q.innerType._zod.values), $18._zod.parse = (K, P) => {
    if (P.direction === "backward") return q.innerType._zod.run(K, P);
    if (K.value === void 0) return K.value = q.defaultValue, K;
    let _ = q.innerType._zod.run(K, P);
    if (_ instanceof Promise) return _.then((Y) => BX(Y, q));
    return BX(_, q);
  };
});
function BX($18, q) {
  if ($18.value === void 0) $18.value = q.defaultValue;
  return $18;
}
var rj = O$("$ZodPrefault", ($18, q) => {
  P6.init($18, q), $18._zod.optin = "optional", A6($18._zod, "values", () => q.innerType._zod.values), $18._zod.parse = (K, P) => {
    if (P.direction === "backward") return q.innerType._zod.run(K, P);
    if (K.value === void 0) K.value = q.defaultValue;
    return q.innerType._zod.run(K, P);
  };
});
var oj = O$("$ZodNonOptional", ($18, q) => {
  P6.init($18, q), A6($18._zod, "values", () => {
    let K = q.innerType._zod.values;
    return K ? new Set([...K].filter((P) => P !== void 0)) : void 0;
  }), $18._zod.parse = (K, P) => {
    let _ = q.innerType._zod.run(K, P);
    if (_ instanceof Promise) return _.then((Y) => tX(Y, $18));
    return tX(_, $18);
  };
});
function tX($18, q) {
  if (!$18.issues.length && $18.value === void 0) $18.issues.push({ code: "invalid_type", expected: "nonoptional", input: $18.value, inst: q });
  return $18;
}
var nj = O$("$ZodSuccess", ($18, q) => {
  P6.init($18, q), $18._zod.parse = (K, P) => {
    if (P.direction === "backward") throw new H_("ZodSuccess");
    let _ = q.innerType._zod.run(K, P);
    if (_ instanceof Promise) return _.then((Y) => {
      return K.value = Y.issues.length === 0, K;
    });
    return K.value = _.issues.length === 0, K;
  };
});
var ij = O$("$ZodCatch", ($18, q) => {
  P6.init($18, q), A6($18._zod, "optin", () => q.innerType._zod.optin), A6($18._zod, "optout", () => q.innerType._zod.optout), A6($18._zod, "values", () => q.innerType._zod.values), $18._zod.parse = (K, P) => {
    if (P.direction === "backward") return q.innerType._zod.run(K, P);
    let _ = q.innerType._zod.run(K, P);
    if (_ instanceof Promise) return _.then((Y) => {
      if (K.value = Y.value, Y.issues.length) K.value = q.catchValue({ ...K, error: { issues: Y.issues.map((O) => O8(O, P, r6())) }, input: K.value }), K.issues = [];
      return K;
    });
    if (K.value = _.value, _.issues.length) K.value = q.catchValue({ ...K, error: { issues: _.issues.map((Y) => O8(Y, P, r6())) }, input: K.value }), K.issues = [];
    return K;
  };
});
var Bj = O$("$ZodNaN", ($18, q) => {
  P6.init($18, q), $18._zod.parse = (K, P) => {
    if (typeof K.value !== "number" || !Number.isNaN(K.value)) return K.issues.push({ input: K.value, inst: $18, expected: "nan", code: "invalid_type" }), K;
    return K;
  };
});
var tj = O$("$ZodPipe", ($18, q) => {
  P6.init($18, q), A6($18._zod, "values", () => q.in._zod.values), A6($18._zod, "optin", () => q.in._zod.optin), A6($18._zod, "optout", () => q.out._zod.optout), A6($18._zod, "propValues", () => q.in._zod.propValues), $18._zod.parse = (K, P) => {
    if (P.direction === "backward") {
      let Y = q.out._zod.run(K, P);
      if (Y instanceof Promise) return Y.then((O) => E9(O, q.in, P));
      return E9(Y, q.in, P);
    }
    let _ = q.in._zod.run(K, P);
    if (_ instanceof Promise) return _.then((Y) => E9(Y, q.out, P));
    return E9(_, q.out, P);
  };
});
function E9($18, q, K) {
  if ($18.issues.length) return $18.aborted = true, $18;
  return q._zod.run({ value: $18.value, issues: $18.issues }, K);
}
var lP = O$("$ZodCodec", ($18, q) => {
  P6.init($18, q), A6($18._zod, "values", () => q.in._zod.values), A6($18._zod, "optin", () => q.in._zod.optin), A6($18._zod, "optout", () => q.out._zod.optout), A6($18._zod, "propValues", () => q.in._zod.propValues), $18._zod.parse = (K, P) => {
    if ((P.direction || "forward") === "forward") {
      let Y = q.in._zod.run(K, P);
      if (Y instanceof Promise) return Y.then((O) => h9(O, q, P));
      return h9(Y, q, P);
    } else {
      let Y = q.out._zod.run(K, P);
      if (Y instanceof Promise) return Y.then((O) => h9(O, q, P));
      return h9(Y, q, P);
    }
  };
});
function h9($18, q, K) {
  if ($18.issues.length) return $18.aborted = true, $18;
  if ((K.direction || "forward") === "forward") {
    let _ = q.transform($18.value, $18);
    if (_ instanceof Promise) return _.then((Y) => R9($18, Y, q.out, K));
    return R9($18, _, q.out, K);
  } else {
    let _ = q.reverseTransform($18.value, $18);
    if (_ instanceof Promise) return _.then((Y) => R9($18, Y, q.in, K));
    return R9($18, _, q.in, K);
  }
}
function R9($18, q, K, P) {
  if ($18.issues.length) return $18.aborted = true, $18;
  return K._zod.run({ value: q, issues: $18.issues }, P);
}
var Uj = O$("$ZodReadonly", ($18, q) => {
  P6.init($18, q), A6($18._zod, "propValues", () => q.innerType._zod.propValues), A6($18._zod, "values", () => q.innerType._zod.values), A6($18._zod, "optin", () => q.innerType._zod.optin), A6($18._zod, "optout", () => q.innerType._zod.optout), $18._zod.parse = (K, P) => {
    if (P.direction === "backward") return q.innerType._zod.run(K, P);
    let _ = q.innerType._zod.run(K, P);
    if (_ instanceof Promise) return _.then(UX);
    return UX(_);
  };
});
function UX($18) {
  return $18.value = Object.freeze($18.value), $18;
}
var Fj = O$("$ZodTemplateLiteral", ($18, q) => {
  P6.init($18, q);
  let K = [];
  for (let P of q.parts) if (typeof P === "object" && P !== null) {
    if (!P._zod.pattern) throw Error(`Invalid template literal part, no pattern found: ${[...P._zod.traits].shift()}`);
    let _ = P._zod.pattern instanceof RegExp ? P._zod.pattern.source : P._zod.pattern;
    if (!_) throw Error(`Invalid template literal part: ${P._zod.traits}`);
    let Y = _.startsWith("^") ? 1 : 0, O = _.endsWith("$") ? _.length - 1 : _.length;
    K.push(_.slice(Y, O));
  } else if (P === null || tY.has(typeof P)) K.push(r8(`${P}`));
  else throw Error(`Invalid template literal part: ${P}`);
  $18._zod.pattern = new RegExp(`^${K.join("")}$`), $18._zod.parse = (P, _) => {
    if (typeof P.value !== "string") return P.issues.push({ input: P.value, inst: $18, expected: "template_literal", code: "invalid_type" }), P;
    if ($18._zod.pattern.lastIndex = 0, !$18._zod.pattern.test(P.value)) return P.issues.push({ input: P.value, inst: $18, code: "invalid_format", format: q.format ?? "template_literal", pattern: $18._zod.pattern.source }), P;
    return P;
  };
});
var aj = O$("$ZodFunction", ($18, q) => {
  return P6.init($18, q), $18._def = q, $18._zod.def = q, $18.implement = (K) => {
    if (typeof K !== "function") throw Error("implement() must be called with a function");
    return function(...P) {
      let _ = $18._def.input ? xP($18._def.input, P) : P, Y = Reflect.apply(K, this, _);
      if ($18._def.output) return xP($18._def.output, Y);
      return Y;
    };
  }, $18.implementAsync = (K) => {
    if (typeof K !== "function") throw Error("implementAsync() must be called with a function");
    return async function(...P) {
      let _ = $18._def.input ? await Q_($18._def.input, P) : P, Y = await Reflect.apply(K, this, _);
      if ($18._def.output) return await Q_($18._def.output, Y);
      return Y;
    };
  }, $18._zod.parse = (K, P) => {
    if (typeof K.value !== "function") return K.issues.push({ code: "invalid_type", expected: "function", input: K.value, inst: $18 }), K;
    if ($18._def.output && $18._def.output._zod.def.type === "promise") K.value = $18.implementAsync(K.value);
    else K.value = $18.implement(K.value);
    return K;
  }, $18.input = (...K) => {
    let P = $18.constructor;
    if (Array.isArray(K[0])) return new P({ type: "function", input: new y9({ type: "tuple", items: K[0], rest: K[1] }), output: $18._def.output });
    return new P({ type: "function", input: K[0], output: $18._def.output });
  }, $18.output = (K) => {
    return new $18.constructor({ type: "function", input: $18._def.input, output: K });
  }, $18;
});
var Qj = O$("$ZodPromise", ($18, q) => {
  P6.init($18, q), $18._zod.parse = (K, P) => {
    return Promise.resolve(K.value).then((_) => q.innerType._zod.run({ value: _, issues: [] }, P));
  };
});
var ej = O$("$ZodLazy", ($18, q) => {
  P6.init($18, q), A6($18._zod, "innerType", () => q.getter()), A6($18._zod, "pattern", () => $18._zod.innerType._zod.pattern), A6($18._zod, "propValues", () => $18._zod.innerType._zod.propValues), A6($18._zod, "optin", () => $18._zod.innerType._zod.optin ?? void 0), A6($18._zod, "optout", () => $18._zod.innerType._zod.optout ?? void 0), $18._zod.parse = (K, P) => {
    return $18._zod.innerType._zod.run(K, P);
  };
});
var sj = O$("$ZodCustom", ($18, q) => {
  I6.init($18, q), P6.init($18, q), $18._zod.parse = (K, P) => {
    return K;
  }, $18._zod.check = (K) => {
    let P = K.value, _ = q.fn(P);
    if (_ instanceof Promise) return _.then((Y) => FX(Y, K, P, $18));
    FX(_, K, P, $18);
    return;
  };
});
function FX($18, q, K, P) {
  if (!$18) {
    let _ = { code: "custom", input: K, inst: P, path: [...P._zod.def.path ?? []], continue: !P._zod.def.abort };
    if (P._zod.def.params) _.params = P._zod.def.params;
    q.issues.push(U_(_));
  }
}
var tP = {};
lq(tP, { zhTW: () => l3, zhCN: () => d3, yo: () => r3, vi: () => m3, ur: () => c3, uk: () => BP, ua: () => p3, tr: () => x3, th: () => u3, ta: () => y3, sv: () => b3, sl: () => g3, ru: () => L3, pt: () => D3, ps: () => R3, pl: () => I3, ota: () => h3, no: () => E3, nl: () => C3, ms: () => N3, mk: () => M3, lt: () => S3, ko: () => V3, km: () => oP, kh: () => G3, ka: () => k3, ja: () => A3, it: () => X3, is: () => Z3, id: () => f3, hu: () => w3, he: () => T3, frCA: () => J3, fr: () => H3, fi: () => W3, fa: () => z3, es: () => v3, eo: () => j3, en: () => rP, de: () => Y3, da: () => O3, cs: () => P3, ca: () => _3, be: () => K3, az: () => q3, ar: () => $32 });
var YD = () => {
  let $18 = { string: { unit: "", verb: " " }, file: { unit: "", verb: " " }, array: { unit: "", verb: " " }, set: { unit: "", verb: " " } };
  function q(_) {
    return $18[_] ?? null;
  }
  let K = (_) => {
    let Y = typeof _;
    switch (Y) {
      case "number":
        return Number.isNaN(_) ? "NaN" : "number";
      case "object": {
        if (Array.isArray(_)) return "array";
        if (_ === null) return "null";
        if (Object.getPrototypeOf(_) !== Object.prototype && _.constructor) return _.constructor.name;
      }
    }
    return Y;
  }, P = { regex: "", email: " ", url: "", emoji: "", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "   ISO", date: "  ISO", time: "  ISO", duration: "  ISO", ipv4: " IPv4", ipv6: " IPv6", cidrv4: "   IPv4", cidrv6: "   IPv6", base64: "  base64-encoded", base64url: "  base64url-encoded", json_string: "   JSON", e164: "   E.164", jwt: "JWT", template_literal: "" };
  return (_) => {
    switch (_.code) {
      case "invalid_type":
        return `  :   ${_.expected}    ${K(_.input)}`;
      case "invalid_value":
        if (_.values.length === 1) return `  :   ${m$(_.values[0])}`;
        return `  :     : ${T$(_.values, "|")}`;
      case "too_big": {
        let Y = _.inclusive ? "<=" : "<", O = q(_.origin);
        if (O) return `   :    ${_.origin ?? ""} ${Y} ${_.maximum.toString()} ${O.unit ?? ""}`;
        return `  :    ${_.origin ?? ""} ${Y} ${_.maximum.toString()}`;
      }
      case "too_small": {
        let Y = _.inclusive ? ">=" : ">", O = q(_.origin);
        if (O) return `  :   ${_.origin}   ${Y} ${_.minimum.toString()} ${O.unit}`;
        return `  :   ${_.origin}   ${Y} ${_.minimum.toString()}`;
      }
      case "invalid_format": {
        let Y = _;
        if (Y.format === "starts_with") return `  :     "${_.prefix}"`;
        if (Y.format === "ends_with") return `  :     "${Y.suffix}"`;
        if (Y.format === "includes") return `  :    "${Y.includes}"`;
        if (Y.format === "regex") return `  :     ${Y.pattern}`;
        return `${P[Y.format] ?? _.format}  `;
      }
      case "not_multiple_of":
        return `  :      ${_.divisor}`;
      case "unrecognized_keys":
        return `${_.keys.length > 1 ? "" : ""} ${_.keys.length > 1 ? "" : ""}: ${T$(_.keys, " ")}`;
      case "invalid_key":
        return `    ${_.origin}`;
      case "invalid_union":
        return "  ";
      case "invalid_element":
        return `    ${_.origin}`;
      default:
        return "  ";
    }
  };
};
function $32() {
  return { localeError: YD() };
}
var jD = () => {
  let $18 = { string: { unit: "simvol", verb: "olmaldr" }, file: { unit: "bayt", verb: "olmaldr" }, array: { unit: "element", verb: "olmaldr" }, set: { unit: "element", verb: "olmaldr" } };
  function q(_) {
    return $18[_] ?? null;
  }
  let K = (_) => {
    let Y = typeof _;
    switch (Y) {
      case "number":
        return Number.isNaN(_) ? "NaN" : "number";
      case "object": {
        if (Array.isArray(_)) return "array";
        if (_ === null) return "null";
        if (Object.getPrototypeOf(_) !== Object.prototype && _.constructor) return _.constructor.name;
      }
    }
    return Y;
  }, P = { regex: "input", email: "email address", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO datetime", date: "ISO date", time: "ISO time", duration: "ISO duration", ipv4: "IPv4 address", ipv6: "IPv6 address", cidrv4: "IPv4 range", cidrv6: "IPv6 range", base64: "base64-encoded string", base64url: "base64url-encoded string", json_string: "JSON string", e164: "E.164 number", jwt: "JWT", template_literal: "input" };
  return (_) => {
    switch (_.code) {
      case "invalid_type":
        return `Yanl dyr: gzlniln ${_.expected}, daxil olan ${K(_.input)}`;
      case "invalid_value":
        if (_.values.length === 1) return `Yanl dyr: gzlniln ${m$(_.values[0])}`;
        return `Yanl seim: aadaklardan biri olmaldr: ${T$(_.values, "|")}`;
      case "too_big": {
        let Y = _.inclusive ? "<=" : "<", O = q(_.origin);
        if (O) return `ox byk: gzlniln ${_.origin ?? "dyr"} ${Y}${_.maximum.toString()} ${O.unit ?? "element"}`;
        return `ox byk: gzlniln ${_.origin ?? "dyr"} ${Y}${_.maximum.toString()}`;
      }
      case "too_small": {
        let Y = _.inclusive ? ">=" : ">", O = q(_.origin);
        if (O) return `ox kiik: gzlniln ${_.origin} ${Y}${_.minimum.toString()} ${O.unit}`;
        return `ox kiik: gzlniln ${_.origin} ${Y}${_.minimum.toString()}`;
      }
      case "invalid_format": {
        let Y = _;
        if (Y.format === "starts_with") return `Yanl mtn: "${Y.prefix}" il balamaldr`;
        if (Y.format === "ends_with") return `Yanl mtn: "${Y.suffix}" il bitmlidir`;
        if (Y.format === "includes") return `Yanl mtn: "${Y.includes}" daxil olmaldr`;
        if (Y.format === "regex") return `Yanl mtn: ${Y.pattern} ablonuna uyun olmaldr`;
        return `Yanl ${P[Y.format] ?? _.format}`;
      }
      case "not_multiple_of":
        return `Yanl dd: ${_.divisor} il bln biln olmaldr`;
      case "unrecognized_keys":
        return `Tannmayan aar${_.keys.length > 1 ? "lar" : ""}: ${T$(_.keys, ", ")}`;
      case "invalid_key":
        return `${_.origin} daxilind yanl aar`;
      case "invalid_union":
        return "Yanl dyr";
      case "invalid_element":
        return `${_.origin} daxilind yanl dyr`;
      default:
        return "Yanl dyr";
    }
  };
};
function q3() {
  return { localeError: jD() };
}
function qA($18, q, K, P) {
  let _ = Math.abs($18), Y = _ % 10, O = _ % 100;
  if (O >= 11 && O <= 19) return P;
  if (Y === 1) return q;
  if (Y >= 2 && Y <= 4) return K;
  return P;
}
var vD = () => {
  let $18 = { string: { unit: { one: "", few: "", many: "" }, verb: "" }, array: { unit: { one: "", few: "", many: "" }, verb: "" }, set: { unit: { one: "", few: "", many: "" }, verb: "" }, file: { unit: { one: "", few: "", many: "" }, verb: "" } };
  function q(_) {
    return $18[_] ?? null;
  }
  let K = (_) => {
    let Y = typeof _;
    switch (Y) {
      case "number":
        return Number.isNaN(_) ? "NaN" : "";
      case "object": {
        if (Array.isArray(_)) return "";
        if (_ === null) return "null";
        if (Object.getPrototypeOf(_) !== Object.prototype && _.constructor) return _.constructor.name;
      }
    }
    return Y;
  }, P = { regex: "", email: "email ", url: "URL", emoji: "", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO   ", date: "ISO ", time: "ISO ", duration: "ISO ", ipv4: "IPv4 ", ipv6: "IPv6 ", cidrv4: "IPv4 ", cidrv6: "IPv6 ", base64: "   base64", base64url: "   base64url", json_string: "JSON ", e164: " E.164", jwt: "JWT", template_literal: "" };
  return (_) => {
    switch (_.code) {
      case "invalid_type":
        return ` :  ${_.expected},  ${K(_.input)}`;
      case "invalid_value":
        if (_.values.length === 1) return ` :  ${m$(_.values[0])}`;
        return ` :    ${T$(_.values, "|")}`;
      case "too_big": {
        let Y = _.inclusive ? "<=" : "<", O = q(_.origin);
        if (O) {
          let z = Number(_.maximum), J = qA(z, O.unit.one, O.unit.few, O.unit.many);
          return ` : ,  ${_.origin ?? ""}  ${O.verb} ${Y}${_.maximum.toString()} ${J}`;
        }
        return ` : ,  ${_.origin ?? ""}   ${Y}${_.maximum.toString()}`;
      }
      case "too_small": {
        let Y = _.inclusive ? ">=" : ">", O = q(_.origin);
        if (O) {
          let z = Number(_.minimum), J = qA(z, O.unit.one, O.unit.few, O.unit.many);
          return ` : ,  ${_.origin}  ${O.verb} ${Y}${_.minimum.toString()} ${J}`;
        }
        return ` : ,  ${_.origin}   ${Y}${_.minimum.toString()}`;
      }
      case "invalid_format": {
        let Y = _;
        if (Y.format === "starts_with") return ` :    "${Y.prefix}"`;
        if (Y.format === "ends_with") return ` :    "${Y.suffix}"`;
        if (Y.format === "includes") return ` :   "${Y.includes}"`;
        if (Y.format === "regex") return ` :    ${Y.pattern}`;
        return ` ${P[Y.format] ?? _.format}`;
      }
      case "not_multiple_of":
        return ` :    ${_.divisor}`;
      case "unrecognized_keys":
        return ` ${_.keys.length > 1 ? "" : ""}: ${T$(_.keys, ", ")}`;
      case "invalid_key":
        return `   ${_.origin}`;
      case "invalid_union":
        return " ";
      case "invalid_element":
        return `   ${_.origin}`;
      default:
        return " ";
    }
  };
};
function K3() {
  return { localeError: vD() };
}
var zD = () => {
  let $18 = { string: { unit: "carcters", verb: "contenir" }, file: { unit: "bytes", verb: "contenir" }, array: { unit: "elements", verb: "contenir" }, set: { unit: "elements", verb: "contenir" } };
  function q(_) {
    return $18[_] ?? null;
  }
  let K = (_) => {
    let Y = typeof _;
    switch (Y) {
      case "number":
        return Number.isNaN(_) ? "NaN" : "number";
      case "object": {
        if (Array.isArray(_)) return "array";
        if (_ === null) return "null";
        if (Object.getPrototypeOf(_) !== Object.prototype && _.constructor) return _.constructor.name;
      }
    }
    return Y;
  }, P = { regex: "entrada", email: "adrea electrnica", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "data i hora ISO", date: "data ISO", time: "hora ISO", duration: "durada ISO", ipv4: "adrea IPv4", ipv6: "adrea IPv6", cidrv4: "rang IPv4", cidrv6: "rang IPv6", base64: "cadena codificada en base64", base64url: "cadena codificada en base64url", json_string: "cadena JSON", e164: "nmero E.164", jwt: "JWT", template_literal: "entrada" };
  return (_) => {
    switch (_.code) {
      case "invalid_type":
        return `Tipus invlid: s'esperava ${_.expected}, s'ha rebut ${K(_.input)}`;
      case "invalid_value":
        if (_.values.length === 1) return `Valor invlid: s'esperava ${m$(_.values[0])}`;
        return `Opci invlida: s'esperava una de ${T$(_.values, " o ")}`;
      case "too_big": {
        let Y = _.inclusive ? "com a mxim" : "menys de", O = q(_.origin);
        if (O) return `Massa gran: s'esperava que ${_.origin ?? "el valor"} contingus ${Y} ${_.maximum.toString()} ${O.unit ?? "elements"}`;
        return `Massa gran: s'esperava que ${_.origin ?? "el valor"} fos ${Y} ${_.maximum.toString()}`;
      }
      case "too_small": {
        let Y = _.inclusive ? "com a mnim" : "ms de", O = q(_.origin);
        if (O) return `Massa petit: s'esperava que ${_.origin} contingus ${Y} ${_.minimum.toString()} ${O.unit}`;
        return `Massa petit: s'esperava que ${_.origin} fos ${Y} ${_.minimum.toString()}`;
      }
      case "invalid_format": {
        let Y = _;
        if (Y.format === "starts_with") return `Format invlid: ha de comenar amb "${Y.prefix}"`;
        if (Y.format === "ends_with") return `Format invlid: ha d'acabar amb "${Y.suffix}"`;
        if (Y.format === "includes") return `Format invlid: ha d'incloure "${Y.includes}"`;
        if (Y.format === "regex") return `Format invlid: ha de coincidir amb el patr ${Y.pattern}`;
        return `Format invlid per a ${P[Y.format] ?? _.format}`;
      }
      case "not_multiple_of":
        return `Nmero invlid: ha de ser mltiple de ${_.divisor}`;
      case "unrecognized_keys":
        return `Clau${_.keys.length > 1 ? "s" : ""} no reconeguda${_.keys.length > 1 ? "s" : ""}: ${T$(_.keys, ", ")}`;
      case "invalid_key":
        return `Clau invlida a ${_.origin}`;
      case "invalid_union":
        return "Entrada invlida";
      case "invalid_element":
        return `Element invlid a ${_.origin}`;
      default:
        return "Entrada invlida";
    }
  };
};
function _3() {
  return { localeError: zD() };
}
var WD = () => {
  let $18 = { string: { unit: "znak", verb: "mt" }, file: { unit: "bajt", verb: "mt" }, array: { unit: "prvk", verb: "mt" }, set: { unit: "prvk", verb: "mt" } };
  function q(_) {
    return $18[_] ?? null;
  }
  let K = (_) => {
    let Y = typeof _;
    switch (Y) {
      case "number":
        return Number.isNaN(_) ? "NaN" : "slo";
      case "string":
        return "etzec";
      case "boolean":
        return "boolean";
      case "bigint":
        return "bigint";
      case "function":
        return "funkce";
      case "symbol":
        return "symbol";
      case "undefined":
        return "undefined";
      case "object": {
        if (Array.isArray(_)) return "pole";
        if (_ === null) return "null";
        if (Object.getPrototypeOf(_) !== Object.prototype && _.constructor) return _.constructor.name;
      }
    }
    return Y;
  }, P = { regex: "regulrn vraz", email: "e-mailov adresa", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "datum a as ve formtu ISO", date: "datum ve formtu ISO", time: "as ve formtu ISO", duration: "doba trvn ISO", ipv4: "IPv4 adresa", ipv6: "IPv6 adresa", cidrv4: "rozsah IPv4", cidrv6: "rozsah IPv6", base64: "etzec zakdovan ve formtu base64", base64url: "etzec zakdovan ve formtu base64url", json_string: "etzec ve formtu JSON", e164: "slo E.164", jwt: "JWT", template_literal: "vstup" };
  return (_) => {
    switch (_.code) {
      case "invalid_type":
        return `Neplatn vstup: oekvno ${_.expected}, obdreno ${K(_.input)}`;
      case "invalid_value":
        if (_.values.length === 1) return `Neplatn vstup: oekvno ${m$(_.values[0])}`;
        return `Neplatn monost: oekvna jedna z hodnot ${T$(_.values, "|")}`;
      case "too_big": {
        let Y = _.inclusive ? "<=" : "<", O = q(_.origin);
        if (O) return `Hodnota je pli velk: ${_.origin ?? "hodnota"} mus mt ${Y}${_.maximum.toString()} ${O.unit ?? "prvk"}`;
        return `Hodnota je pli velk: ${_.origin ?? "hodnota"} mus bt ${Y}${_.maximum.toString()}`;
      }
      case "too_small": {
        let Y = _.inclusive ? ">=" : ">", O = q(_.origin);
        if (O) return `Hodnota je pli mal: ${_.origin ?? "hodnota"} mus mt ${Y}${_.minimum.toString()} ${O.unit ?? "prvk"}`;
        return `Hodnota je pli mal: ${_.origin ?? "hodnota"} mus bt ${Y}${_.minimum.toString()}`;
      }
      case "invalid_format": {
        let Y = _;
        if (Y.format === "starts_with") return `Neplatn etzec: mus zanat na "${Y.prefix}"`;
        if (Y.format === "ends_with") return `Neplatn etzec: mus konit na "${Y.suffix}"`;
        if (Y.format === "includes") return `Neplatn etzec: mus obsahovat "${Y.includes}"`;
        if (Y.format === "regex") return `Neplatn etzec: mus odpovdat vzoru ${Y.pattern}`;
        return `Neplatn formt ${P[Y.format] ?? _.format}`;
      }
      case "not_multiple_of":
        return `Neplatn slo: mus bt nsobkem ${_.divisor}`;
      case "unrecognized_keys":
        return `Neznm kle: ${T$(_.keys, ", ")}`;
      case "invalid_key":
        return `Neplatn kl v ${_.origin}`;
      case "invalid_union":
        return "Neplatn vstup";
      case "invalid_element":
        return `Neplatn hodnota v ${_.origin}`;
      default:
        return "Neplatn vstup";
    }
  };
};
function P3() {
  return { localeError: WD() };
}
var HD = () => {
  let $18 = { string: { unit: "tegn", verb: "havde" }, file: { unit: "bytes", verb: "havde" }, array: { unit: "elementer", verb: "indeholdt" }, set: { unit: "elementer", verb: "indeholdt" } }, q = { string: "streng", number: "tal", boolean: "boolean", array: "liste", object: "objekt", set: "st", file: "fil" };
  function K(O) {
    return $18[O] ?? null;
  }
  function P(O) {
    return q[O] ?? O;
  }
  let _ = (O) => {
    let z = typeof O;
    switch (z) {
      case "number":
        return Number.isNaN(O) ? "NaN" : "tal";
      case "object": {
        if (Array.isArray(O)) return "liste";
        if (O === null) return "null";
        if (Object.getPrototypeOf(O) !== Object.prototype && O.constructor) return O.constructor.name;
        return "objekt";
      }
    }
    return z;
  }, Y = { regex: "input", email: "e-mailadresse", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO dato- og klokkeslt", date: "ISO-dato", time: "ISO-klokkeslt", duration: "ISO-varighed", ipv4: "IPv4-omrde", ipv6: "IPv6-omrde", cidrv4: "IPv4-spektrum", cidrv6: "IPv6-spektrum", base64: "base64-kodet streng", base64url: "base64url-kodet streng", json_string: "JSON-streng", e164: "E.164-nummer", jwt: "JWT", template_literal: "input" };
  return (O) => {
    switch (O.code) {
      case "invalid_type":
        return `Ugyldigt input: forventede ${P(O.expected)}, fik ${P(_(O.input))}`;
      case "invalid_value":
        if (O.values.length === 1) return `Ugyldig vrdi: forventede ${m$(O.values[0])}`;
        return `Ugyldigt valg: forventede en af flgende ${T$(O.values, "|")}`;
      case "too_big": {
        let z = O.inclusive ? "<=" : "<", J = K(O.origin), T = P(O.origin);
        if (J) return `For stor: forventede ${T ?? "value"} ${J.verb} ${z} ${O.maximum.toString()} ${J.unit ?? "elementer"}`;
        return `For stor: forventede ${T ?? "value"} havde ${z} ${O.maximum.toString()}`;
      }
      case "too_small": {
        let z = O.inclusive ? ">=" : ">", J = K(O.origin), T = P(O.origin);
        if (J) return `For lille: forventede ${T} ${J.verb} ${z} ${O.minimum.toString()} ${J.unit}`;
        return `For lille: forventede ${T} havde ${z} ${O.minimum.toString()}`;
      }
      case "invalid_format": {
        let z = O;
        if (z.format === "starts_with") return `Ugyldig streng: skal starte med "${z.prefix}"`;
        if (z.format === "ends_with") return `Ugyldig streng: skal ende med "${z.suffix}"`;
        if (z.format === "includes") return `Ugyldig streng: skal indeholde "${z.includes}"`;
        if (z.format === "regex") return `Ugyldig streng: skal matche mnsteret ${z.pattern}`;
        return `Ugyldig ${Y[z.format] ?? O.format}`;
      }
      case "not_multiple_of":
        return `Ugyldigt tal: skal vre deleligt med ${O.divisor}`;
      case "unrecognized_keys":
        return `${O.keys.length > 1 ? "Ukendte ngler" : "Ukendt ngle"}: ${T$(O.keys, ", ")}`;
      case "invalid_key":
        return `Ugyldig ngle i ${O.origin}`;
      case "invalid_union":
        return "Ugyldigt input: matcher ingen af de tilladte typer";
      case "invalid_element":
        return `Ugyldig vrdi i ${O.origin}`;
      default:
        return "Ugyldigt input";
    }
  };
};
function O3() {
  return { localeError: HD() };
}
var JD = () => {
  let $18 = { string: { unit: "Zeichen", verb: "zu haben" }, file: { unit: "Bytes", verb: "zu haben" }, array: { unit: "Elemente", verb: "zu haben" }, set: { unit: "Elemente", verb: "zu haben" } };
  function q(_) {
    return $18[_] ?? null;
  }
  let K = (_) => {
    let Y = typeof _;
    switch (Y) {
      case "number":
        return Number.isNaN(_) ? "NaN" : "Zahl";
      case "object": {
        if (Array.isArray(_)) return "Array";
        if (_ === null) return "null";
        if (Object.getPrototypeOf(_) !== Object.prototype && _.constructor) return _.constructor.name;
      }
    }
    return Y;
  }, P = { regex: "Eingabe", email: "E-Mail-Adresse", url: "URL", emoji: "Emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO-Datum und -Uhrzeit", date: "ISO-Datum", time: "ISO-Uhrzeit", duration: "ISO-Dauer", ipv4: "IPv4-Adresse", ipv6: "IPv6-Adresse", cidrv4: "IPv4-Bereich", cidrv6: "IPv6-Bereich", base64: "Base64-codierter String", base64url: "Base64-URL-codierter String", json_string: "JSON-String", e164: "E.164-Nummer", jwt: "JWT", template_literal: "Eingabe" };
  return (_) => {
    switch (_.code) {
      case "invalid_type":
        return `Ungltige Eingabe: erwartet ${_.expected}, erhalten ${K(_.input)}`;
      case "invalid_value":
        if (_.values.length === 1) return `Ungltige Eingabe: erwartet ${m$(_.values[0])}`;
        return `Ungltige Option: erwartet eine von ${T$(_.values, "|")}`;
      case "too_big": {
        let Y = _.inclusive ? "<=" : "<", O = q(_.origin);
        if (O) return `Zu gro: erwartet, dass ${_.origin ?? "Wert"} ${Y}${_.maximum.toString()} ${O.unit ?? "Elemente"} hat`;
        return `Zu gro: erwartet, dass ${_.origin ?? "Wert"} ${Y}${_.maximum.toString()} ist`;
      }
      case "too_small": {
        let Y = _.inclusive ? ">=" : ">", O = q(_.origin);
        if (O) return `Zu klein: erwartet, dass ${_.origin} ${Y}${_.minimum.toString()} ${O.unit} hat`;
        return `Zu klein: erwartet, dass ${_.origin} ${Y}${_.minimum.toString()} ist`;
      }
      case "invalid_format": {
        let Y = _;
        if (Y.format === "starts_with") return `Ungltiger String: muss mit "${Y.prefix}" beginnen`;
        if (Y.format === "ends_with") return `Ungltiger String: muss mit "${Y.suffix}" enden`;
        if (Y.format === "includes") return `Ungltiger String: muss "${Y.includes}" enthalten`;
        if (Y.format === "regex") return `Ungltiger String: muss dem Muster ${Y.pattern} entsprechen`;
        return `Ungltig: ${P[Y.format] ?? _.format}`;
      }
      case "not_multiple_of":
        return `Ungltige Zahl: muss ein Vielfaches von ${_.divisor} sein`;
      case "unrecognized_keys":
        return `${_.keys.length > 1 ? "Unbekannte Schlssel" : "Unbekannter Schlssel"}: ${T$(_.keys, ", ")}`;
      case "invalid_key":
        return `Ungltiger Schlssel in ${_.origin}`;
      case "invalid_union":
        return "Ungltige Eingabe";
      case "invalid_element":
        return `Ungltiger Wert in ${_.origin}`;
      default:
        return "Ungltige Eingabe";
    }
  };
};
function Y3() {
  return { localeError: JD() };
}
var TD = ($18) => {
  let q = typeof $18;
  switch (q) {
    case "number":
      return Number.isNaN($18) ? "NaN" : "number";
    case "object": {
      if (Array.isArray($18)) return "array";
      if ($18 === null) return "null";
      if (Object.getPrototypeOf($18) !== Object.prototype && $18.constructor) return $18.constructor.name;
    }
  }
  return q;
};
var wD = () => {
  let $18 = { string: { unit: "characters", verb: "to have" }, file: { unit: "bytes", verb: "to have" }, array: { unit: "items", verb: "to have" }, set: { unit: "items", verb: "to have" } };
  function q(P) {
    return $18[P] ?? null;
  }
  let K = { regex: "input", email: "email address", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO datetime", date: "ISO date", time: "ISO time", duration: "ISO duration", ipv4: "IPv4 address", ipv6: "IPv6 address", cidrv4: "IPv4 range", cidrv6: "IPv6 range", base64: "base64-encoded string", base64url: "base64url-encoded string", json_string: "JSON string", e164: "E.164 number", jwt: "JWT", template_literal: "input" };
  return (P) => {
    switch (P.code) {
      case "invalid_type":
        return `Invalid input: expected ${P.expected}, received ${TD(P.input)}`;
      case "invalid_value":
        if (P.values.length === 1) return `Invalid input: expected ${m$(P.values[0])}`;
        return `Invalid option: expected one of ${T$(P.values, "|")}`;
      case "too_big": {
        let _ = P.inclusive ? "<=" : "<", Y = q(P.origin);
        if (Y) return `Too big: expected ${P.origin ?? "value"} to have ${_}${P.maximum.toString()} ${Y.unit ?? "elements"}`;
        return `Too big: expected ${P.origin ?? "value"} to be ${_}${P.maximum.toString()}`;
      }
      case "too_small": {
        let _ = P.inclusive ? ">=" : ">", Y = q(P.origin);
        if (Y) return `Too small: expected ${P.origin} to have ${_}${P.minimum.toString()} ${Y.unit}`;
        return `Too small: expected ${P.origin} to be ${_}${P.minimum.toString()}`;
      }
      case "invalid_format": {
        let _ = P;
        if (_.format === "starts_with") return `Invalid string: must start with "${_.prefix}"`;
        if (_.format === "ends_with") return `Invalid string: must end with "${_.suffix}"`;
        if (_.format === "includes") return `Invalid string: must include "${_.includes}"`;
        if (_.format === "regex") return `Invalid string: must match pattern ${_.pattern}`;
        return `Invalid ${K[_.format] ?? P.format}`;
      }
      case "not_multiple_of":
        return `Invalid number: must be a multiple of ${P.divisor}`;
      case "unrecognized_keys":
        return `Unrecognized key${P.keys.length > 1 ? "s" : ""}: ${T$(P.keys, ", ")}`;
      case "invalid_key":
        return `Invalid key in ${P.origin}`;
      case "invalid_union":
        return "Invalid input";
      case "invalid_element":
        return `Invalid value in ${P.origin}`;
      default:
        return "Invalid input";
    }
  };
};
function rP() {
  return { localeError: wD() };
}
var fD = ($18) => {
  let q = typeof $18;
  switch (q) {
    case "number":
      return Number.isNaN($18) ? "NaN" : "nombro";
    case "object": {
      if (Array.isArray($18)) return "tabelo";
      if ($18 === null) return "senvalora";
      if (Object.getPrototypeOf($18) !== Object.prototype && $18.constructor) return $18.constructor.name;
    }
  }
  return q;
};
var ZD = () => {
  let $18 = { string: { unit: "karaktrojn", verb: "havi" }, file: { unit: "bajtojn", verb: "havi" }, array: { unit: "elementojn", verb: "havi" }, set: { unit: "elementojn", verb: "havi" } };
  function q(P) {
    return $18[P] ?? null;
  }
  let K = { regex: "enigo", email: "retadreso", url: "URL", emoji: "emoio", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO-datotempo", date: "ISO-dato", time: "ISO-tempo", duration: "ISO-daro", ipv4: "IPv4-adreso", ipv6: "IPv6-adreso", cidrv4: "IPv4-rango", cidrv6: "IPv6-rango", base64: "64-ume kodita karaktraro", base64url: "URL-64-ume kodita karaktraro", json_string: "JSON-karaktraro", e164: "E.164-nombro", jwt: "JWT", template_literal: "enigo" };
  return (P) => {
    switch (P.code) {
      case "invalid_type":
        return `Nevalida enigo: atendiis ${P.expected}, riceviis ${fD(P.input)}`;
      case "invalid_value":
        if (P.values.length === 1) return `Nevalida enigo: atendiis ${m$(P.values[0])}`;
        return `Nevalida opcio: atendiis unu el ${T$(P.values, "|")}`;
      case "too_big": {
        let _ = P.inclusive ? "<=" : "<", Y = q(P.origin);
        if (Y) return `Tro granda: atendiis ke ${P.origin ?? "valoro"} havu ${_}${P.maximum.toString()} ${Y.unit ?? "elementojn"}`;
        return `Tro granda: atendiis ke ${P.origin ?? "valoro"} havu ${_}${P.maximum.toString()}`;
      }
      case "too_small": {
        let _ = P.inclusive ? ">=" : ">", Y = q(P.origin);
        if (Y) return `Tro malgranda: atendiis ke ${P.origin} havu ${_}${P.minimum.toString()} ${Y.unit}`;
        return `Tro malgranda: atendiis ke ${P.origin} estu ${_}${P.minimum.toString()}`;
      }
      case "invalid_format": {
        let _ = P;
        if (_.format === "starts_with") return `Nevalida karaktraro: devas komencii per "${_.prefix}"`;
        if (_.format === "ends_with") return `Nevalida karaktraro: devas finii per "${_.suffix}"`;
        if (_.format === "includes") return `Nevalida karaktraro: devas inkluzivi "${_.includes}"`;
        if (_.format === "regex") return `Nevalida karaktraro: devas kongrui kun la modelo ${_.pattern}`;
        return `Nevalida ${K[_.format] ?? P.format}`;
      }
      case "not_multiple_of":
        return `Nevalida nombro: devas esti oblo de ${P.divisor}`;
      case "unrecognized_keys":
        return `Nekonata${P.keys.length > 1 ? "j" : ""} losilo${P.keys.length > 1 ? "j" : ""}: ${T$(P.keys, ", ")}`;
      case "invalid_key":
        return `Nevalida losilo en ${P.origin}`;
      case "invalid_union":
        return "Nevalida enigo";
      case "invalid_element":
        return `Nevalida valoro en ${P.origin}`;
      default:
        return "Nevalida enigo";
    }
  };
};
function j3() {
  return { localeError: ZD() };
}
var XD = () => {
  let $18 = { string: { unit: "caracteres", verb: "tener" }, file: { unit: "bytes", verb: "tener" }, array: { unit: "elementos", verb: "tener" }, set: { unit: "elementos", verb: "tener" } }, q = { string: "texto", number: "nmero", boolean: "booleano", array: "arreglo", object: "objeto", set: "conjunto", file: "archivo", date: "fecha", bigint: "nmero grande", symbol: "smbolo", undefined: "indefinido", null: "nulo", function: "funcin", map: "mapa", record: "registro", tuple: "tupla", enum: "enumeracin", union: "unin", literal: "literal", promise: "promesa", void: "vaco", never: "nunca", unknown: "desconocido", any: "cualquiera" };
  function K(O) {
    return $18[O] ?? null;
  }
  function P(O) {
    return q[O] ?? O;
  }
  let _ = (O) => {
    let z = typeof O;
    switch (z) {
      case "number":
        return Number.isNaN(O) ? "NaN" : "number";
      case "object": {
        if (Array.isArray(O)) return "array";
        if (O === null) return "null";
        if (Object.getPrototypeOf(O) !== Object.prototype) return O.constructor.name;
        return "object";
      }
    }
    return z;
  }, Y = { regex: "entrada", email: "direccin de correo electrnico", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "fecha y hora ISO", date: "fecha ISO", time: "hora ISO", duration: "duracin ISO", ipv4: "direccin IPv4", ipv6: "direccin IPv6", cidrv4: "rango IPv4", cidrv6: "rango IPv6", base64: "cadena codificada en base64", base64url: "URL codificada en base64", json_string: "cadena JSON", e164: "nmero E.164", jwt: "JWT", template_literal: "entrada" };
  return (O) => {
    switch (O.code) {
      case "invalid_type":
        return `Entrada invlida: se esperaba ${P(O.expected)}, recibido ${P(_(O.input))}`;
      case "invalid_value":
        if (O.values.length === 1) return `Entrada invlida: se esperaba ${m$(O.values[0])}`;
        return `Opcin invlida: se esperaba una de ${T$(O.values, "|")}`;
      case "too_big": {
        let z = O.inclusive ? "<=" : "<", J = K(O.origin), T = P(O.origin);
        if (J) return `Demasiado grande: se esperaba que ${T ?? "valor"} tuviera ${z}${O.maximum.toString()} ${J.unit ?? "elementos"}`;
        return `Demasiado grande: se esperaba que ${T ?? "valor"} fuera ${z}${O.maximum.toString()}`;
      }
      case "too_small": {
        let z = O.inclusive ? ">=" : ">", J = K(O.origin), T = P(O.origin);
        if (J) return `Demasiado pequeo: se esperaba que ${T} tuviera ${z}${O.minimum.toString()} ${J.unit}`;
        return `Demasiado pequeo: se esperaba que ${T} fuera ${z}${O.minimum.toString()}`;
      }
      case "invalid_format": {
        let z = O;
        if (z.format === "starts_with") return `Cadena invlida: debe comenzar con "${z.prefix}"`;
        if (z.format === "ends_with") return `Cadena invlida: debe terminar en "${z.suffix}"`;
        if (z.format === "includes") return `Cadena invlida: debe incluir "${z.includes}"`;
        if (z.format === "regex") return `Cadena invlida: debe coincidir con el patrn ${z.pattern}`;
        return `Invlido ${Y[z.format] ?? O.format}`;
      }
      case "not_multiple_of":
        return `Nmero invlido: debe ser mltiplo de ${O.divisor}`;
      case "unrecognized_keys":
        return `Llave${O.keys.length > 1 ? "s" : ""} desconocida${O.keys.length > 1 ? "s" : ""}: ${T$(O.keys, ", ")}`;
      case "invalid_key":
        return `Llave invlida en ${P(O.origin)}`;
      case "invalid_union":
        return "Entrada invlida";
      case "invalid_element":
        return `Valor invlido en ${P(O.origin)}`;
      default:
        return "Entrada invlida";
    }
  };
};
function v3() {
  return { localeError: XD() };
}
var AD = () => {
  let $18 = { string: { unit: "", verb: " " }, file: { unit: "", verb: " " }, array: { unit: "", verb: " " }, set: { unit: "", verb: " " } };
  function q(_) {
    return $18[_] ?? null;
  }
  let K = (_) => {
    let Y = typeof _;
    switch (Y) {
      case "number":
        return Number.isNaN(_) ? "NaN" : "";
      case "object": {
        if (Array.isArray(_)) return "";
        if (_ === null) return "null";
        if (Object.getPrototypeOf(_) !== Object.prototype && _.constructor) return _.constructor.name;
      }
    }
    return Y;
  }, P = { regex: "", email: " ", url: "URL", emoji: "", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "   ", date: " ", time: " ", duration: "  ", ipv4: "IPv4 ", ipv6: "IPv6 ", cidrv4: "IPv4 ", cidrv6: "IPv6 ", base64: "base64-encoded ", base64url: "base64url-encoded ", json_string: "JSON ", e164: "E.164 ", jwt: "JWT", template_literal: "" };
  return (_) => {
    switch (_.code) {
      case "invalid_type":
        return ` :  ${_.expected}  ${K(_.input)}  `;
      case "invalid_value":
        if (_.values.length === 1) return ` :  ${m$(_.values[0])} `;
        return ` :    ${T$(_.values, "|")} `;
      case "too_big": {
        let Y = _.inclusive ? "<=" : "<", O = q(_.origin);
        if (O) return ` : ${_.origin ?? ""}  ${Y}${_.maximum.toString()} ${O.unit ?? ""} `;
        return ` : ${_.origin ?? ""}  ${Y}${_.maximum.toString()} `;
      }
      case "too_small": {
        let Y = _.inclusive ? ">=" : ">", O = q(_.origin);
        if (O) return ` : ${_.origin}  ${Y}${_.minimum.toString()} ${O.unit} `;
        return ` : ${_.origin}  ${Y}${_.minimum.toString()} `;
      }
      case "invalid_format": {
        let Y = _;
        if (Y.format === "starts_with") return ` :   "${Y.prefix}"  `;
        if (Y.format === "ends_with") return ` :   "${Y.suffix}"  `;
        if (Y.format === "includes") return ` :   "${Y.includes}" `;
        if (Y.format === "regex") return ` :    ${Y.pattern}   `;
        return `${P[Y.format] ?? _.format} `;
      }
      case "not_multiple_of":
        return ` :   ${_.divisor} `;
      case "unrecognized_keys":
        return `${_.keys.length > 1 ? "" : ""} : ${T$(_.keys, ", ")}`;
      case "invalid_key":
        return `   ${_.origin}`;
      case "invalid_union":
        return " ";
      case "invalid_element":
        return `   ${_.origin}`;
      default:
        return " ";
    }
  };
};
function z3() {
  return { localeError: AD() };
}
var kD = () => {
  let $18 = { string: { unit: "merkki", subject: "merkkijonon" }, file: { unit: "tavua", subject: "tiedoston" }, array: { unit: "alkiota", subject: "listan" }, set: { unit: "alkiota", subject: "joukon" }, number: { unit: "", subject: "luvun" }, bigint: { unit: "", subject: "suuren kokonaisluvun" }, int: { unit: "", subject: "kokonaisluvun" }, date: { unit: "", subject: "pivmrn" } };
  function q(_) {
    return $18[_] ?? null;
  }
  let K = (_) => {
    let Y = typeof _;
    switch (Y) {
      case "number":
        return Number.isNaN(_) ? "NaN" : "number";
      case "object": {
        if (Array.isArray(_)) return "array";
        if (_ === null) return "null";
        if (Object.getPrototypeOf(_) !== Object.prototype && _.constructor) return _.constructor.name;
      }
    }
    return Y;
  }, P = { regex: "snnllinen lauseke", email: "shkpostiosoite", url: "URL-osoite", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO-aikaleima", date: "ISO-pivmr", time: "ISO-aika", duration: "ISO-kesto", ipv4: "IPv4-osoite", ipv6: "IPv6-osoite", cidrv4: "IPv4-alue", cidrv6: "IPv6-alue", base64: "base64-koodattu merkkijono", base64url: "base64url-koodattu merkkijono", json_string: "JSON-merkkijono", e164: "E.164-luku", jwt: "JWT", template_literal: "templaattimerkkijono" };
  return (_) => {
    switch (_.code) {
      case "invalid_type":
        return `Virheellinen tyyppi: odotettiin ${_.expected}, oli ${K(_.input)}`;
      case "invalid_value":
        if (_.values.length === 1) return `Virheellinen syte: tytyy olla ${m$(_.values[0])}`;
        return `Virheellinen valinta: tytyy olla yksi seuraavista: ${T$(_.values, "|")}`;
      case "too_big": {
        let Y = _.inclusive ? "<=" : "<", O = q(_.origin);
        if (O) return `Liian suuri: ${O.subject} tytyy olla ${Y}${_.maximum.toString()} ${O.unit}`.trim();
        return `Liian suuri: arvon tytyy olla ${Y}${_.maximum.toString()}`;
      }
      case "too_small": {
        let Y = _.inclusive ? ">=" : ">", O = q(_.origin);
        if (O) return `Liian pieni: ${O.subject} tytyy olla ${Y}${_.minimum.toString()} ${O.unit}`.trim();
        return `Liian pieni: arvon tytyy olla ${Y}${_.minimum.toString()}`;
      }
      case "invalid_format": {
        let Y = _;
        if (Y.format === "starts_with") return `Virheellinen syte: tytyy alkaa "${Y.prefix}"`;
        if (Y.format === "ends_with") return `Virheellinen syte: tytyy loppua "${Y.suffix}"`;
        if (Y.format === "includes") return `Virheellinen syte: tytyy sislt "${Y.includes}"`;
        if (Y.format === "regex") return `Virheellinen syte: tytyy vastata snnllist lauseketta ${Y.pattern}`;
        return `Virheellinen ${P[Y.format] ?? _.format}`;
      }
      case "not_multiple_of":
        return `Virheellinen luku: tytyy olla luvun ${_.divisor} monikerta`;
      case "unrecognized_keys":
        return `${_.keys.length > 1 ? "Tuntemattomat avaimet" : "Tuntematon avain"}: ${T$(_.keys, ", ")}`;
      case "invalid_key":
        return "Virheellinen avain tietueessa";
      case "invalid_union":
        return "Virheellinen unioni";
      case "invalid_element":
        return "Virheellinen arvo joukossa";
      default:
        return "Virheellinen syte";
    }
  };
};
function W3() {
  return { localeError: kD() };
}
var GD = () => {
  let $18 = { string: { unit: "caractres", verb: "avoir" }, file: { unit: "octets", verb: "avoir" }, array: { unit: "lments", verb: "avoir" }, set: { unit: "lments", verb: "avoir" } };
  function q(_) {
    return $18[_] ?? null;
  }
  let K = (_) => {
    let Y = typeof _;
    switch (Y) {
      case "number":
        return Number.isNaN(_) ? "NaN" : "nombre";
      case "object": {
        if (Array.isArray(_)) return "tableau";
        if (_ === null) return "null";
        if (Object.getPrototypeOf(_) !== Object.prototype && _.constructor) return _.constructor.name;
      }
    }
    return Y;
  }, P = { regex: "entre", email: "adresse e-mail", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "date et heure ISO", date: "date ISO", time: "heure ISO", duration: "dure ISO", ipv4: "adresse IPv4", ipv6: "adresse IPv6", cidrv4: "plage IPv4", cidrv6: "plage IPv6", base64: "chane encode en base64", base64url: "chane encode en base64url", json_string: "chane JSON", e164: "numro E.164", jwt: "JWT", template_literal: "entre" };
  return (_) => {
    switch (_.code) {
      case "invalid_type":
        return `Entre invalide : ${_.expected} attendu, ${K(_.input)} reu`;
      case "invalid_value":
        if (_.values.length === 1) return `Entre invalide : ${m$(_.values[0])} attendu`;
        return `Option invalide : une valeur parmi ${T$(_.values, "|")} attendue`;
      case "too_big": {
        let Y = _.inclusive ? "<=" : "<", O = q(_.origin);
        if (O) return `Trop grand : ${_.origin ?? "valeur"} doit ${O.verb} ${Y}${_.maximum.toString()} ${O.unit ?? "lment(s)"}`;
        return `Trop grand : ${_.origin ?? "valeur"} doit tre ${Y}${_.maximum.toString()}`;
      }
      case "too_small": {
        let Y = _.inclusive ? ">=" : ">", O = q(_.origin);
        if (O) return `Trop petit : ${_.origin} doit ${O.verb} ${Y}${_.minimum.toString()} ${O.unit}`;
        return `Trop petit : ${_.origin} doit tre ${Y}${_.minimum.toString()}`;
      }
      case "invalid_format": {
        let Y = _;
        if (Y.format === "starts_with") return `Chane invalide : doit commencer par "${Y.prefix}"`;
        if (Y.format === "ends_with") return `Chane invalide : doit se terminer par "${Y.suffix}"`;
        if (Y.format === "includes") return `Chane invalide : doit inclure "${Y.includes}"`;
        if (Y.format === "regex") return `Chane invalide : doit correspondre au modle ${Y.pattern}`;
        return `${P[Y.format] ?? _.format} invalide`;
      }
      case "not_multiple_of":
        return `Nombre invalide : doit tre un multiple de ${_.divisor}`;
      case "unrecognized_keys":
        return `Cl${_.keys.length > 1 ? "s" : ""} non reconnue${_.keys.length > 1 ? "s" : ""} : ${T$(_.keys, ", ")}`;
      case "invalid_key":
        return `Cl invalide dans ${_.origin}`;
      case "invalid_union":
        return "Entre invalide";
      case "invalid_element":
        return `Valeur invalide dans ${_.origin}`;
      default:
        return "Entre invalide";
    }
  };
};
function H3() {
  return { localeError: GD() };
}
var VD = () => {
  let $18 = { string: { unit: "caractres", verb: "avoir" }, file: { unit: "octets", verb: "avoir" }, array: { unit: "lments", verb: "avoir" }, set: { unit: "lments", verb: "avoir" } };
  function q(_) {
    return $18[_] ?? null;
  }
  let K = (_) => {
    let Y = typeof _;
    switch (Y) {
      case "number":
        return Number.isNaN(_) ? "NaN" : "number";
      case "object": {
        if (Array.isArray(_)) return "array";
        if (_ === null) return "null";
        if (Object.getPrototypeOf(_) !== Object.prototype && _.constructor) return _.constructor.name;
      }
    }
    return Y;
  }, P = { regex: "entre", email: "adresse courriel", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "date-heure ISO", date: "date ISO", time: "heure ISO", duration: "dure ISO", ipv4: "adresse IPv4", ipv6: "adresse IPv6", cidrv4: "plage IPv4", cidrv6: "plage IPv6", base64: "chane encode en base64", base64url: "chane encode en base64url", json_string: "chane JSON", e164: "numro E.164", jwt: "JWT", template_literal: "entre" };
  return (_) => {
    switch (_.code) {
      case "invalid_type":
        return `Entre invalide : attendu ${_.expected}, reu ${K(_.input)}`;
      case "invalid_value":
        if (_.values.length === 1) return `Entre invalide : attendu ${m$(_.values[0])}`;
        return `Option invalide : attendu l'une des valeurs suivantes ${T$(_.values, "|")}`;
      case "too_big": {
        let Y = _.inclusive ? "" : "<", O = q(_.origin);
        if (O) return `Trop grand : attendu que ${_.origin ?? "la valeur"} ait ${Y}${_.maximum.toString()} ${O.unit}`;
        return `Trop grand : attendu que ${_.origin ?? "la valeur"} soit ${Y}${_.maximum.toString()}`;
      }
      case "too_small": {
        let Y = _.inclusive ? "" : ">", O = q(_.origin);
        if (O) return `Trop petit : attendu que ${_.origin} ait ${Y}${_.minimum.toString()} ${O.unit}`;
        return `Trop petit : attendu que ${_.origin} soit ${Y}${_.minimum.toString()}`;
      }
      case "invalid_format": {
        let Y = _;
        if (Y.format === "starts_with") return `Chane invalide : doit commencer par "${Y.prefix}"`;
        if (Y.format === "ends_with") return `Chane invalide : doit se terminer par "${Y.suffix}"`;
        if (Y.format === "includes") return `Chane invalide : doit inclure "${Y.includes}"`;
        if (Y.format === "regex") return `Chane invalide : doit correspondre au motif ${Y.pattern}`;
        return `${P[Y.format] ?? _.format} invalide`;
      }
      case "not_multiple_of":
        return `Nombre invalide : doit tre un multiple de ${_.divisor}`;
      case "unrecognized_keys":
        return `Cl${_.keys.length > 1 ? "s" : ""} non reconnue${_.keys.length > 1 ? "s" : ""} : ${T$(_.keys, ", ")}`;
      case "invalid_key":
        return `Cl invalide dans ${_.origin}`;
      case "invalid_union":
        return "Entre invalide";
      case "invalid_element":
        return `Valeur invalide dans ${_.origin}`;
      default:
        return "Entre invalide";
    }
  };
};
function J3() {
  return { localeError: VD() };
}
var SD = () => {
  let $18 = { string: { unit: "", verb: "" }, file: { unit: "", verb: "" }, array: { unit: "", verb: "" }, set: { unit: "", verb: "" } };
  function q(_) {
    return $18[_] ?? null;
  }
  let K = (_) => {
    let Y = typeof _;
    switch (Y) {
      case "number":
        return Number.isNaN(_) ? "NaN" : "number";
      case "object": {
        if (Array.isArray(_)) return "array";
        if (_ === null) return "null";
        if (Object.getPrototypeOf(_) !== Object.prototype && _.constructor) return _.constructor.name;
      }
    }
    return Y;
  }, P = { regex: "", email: " ", url: " ", emoji: "'", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "  ISO", date: " ISO", time: " ISO", duration: "  ISO", ipv4: " IPv4", ipv6: " IPv6", cidrv4: " IPv4", cidrv6: " IPv6", base64: "  64", base64url: "  64  ", json_string: " JSON", e164: " E.164", jwt: "JWT", template_literal: "" };
  return (_) => {
    switch (_.code) {
      case "invalid_type":
        return `  :  ${_.expected},  ${K(_.input)}`;
      case "invalid_value":
        if (_.values.length === 1) return `  :  ${m$(_.values[0])}`;
        return `  :     ${T$(_.values, "|")}`;
      case "too_big": {
        let Y = _.inclusive ? "<=" : "<", O = q(_.origin);
        if (O) return ` : ${_.origin ?? "value"}   ${Y}${_.maximum.toString()} ${O.unit ?? "elements"}`;
        return ` : ${_.origin ?? "value"}   ${Y}${_.maximum.toString()}`;
      }
      case "too_small": {
        let Y = _.inclusive ? ">=" : ">", O = q(_.origin);
        if (O) return ` : ${_.origin}   ${Y}${_.minimum.toString()} ${O.unit}`;
        return ` : ${_.origin}   ${Y}${_.minimum.toString()}`;
      }
      case "invalid_format": {
        let Y = _;
        if (Y.format === "starts_with") return `  :   "${Y.prefix}"`;
        if (Y.format === "ends_with") return `  :    "${Y.suffix}"`;
        if (Y.format === "includes") return `  :   "${Y.includes}"`;
        if (Y.format === "regex") return `  :    ${Y.pattern}`;
        return `${P[Y.format] ?? _.format}  `;
      }
      case "not_multiple_of":
        return `  :     ${_.divisor}`;
      case "unrecognized_keys":
        return `${_.keys.length > 1 ? "" : ""}  ${_.keys.length > 1 ? "" : ""}: ${T$(_.keys, ", ")}`;
      case "invalid_key":
        return `   ${_.origin}`;
      case "invalid_union":
        return "  ";
      case "invalid_element":
        return `   ${_.origin}`;
      default:
        return "  ";
    }
  };
};
function T3() {
  return { localeError: SD() };
}
var MD = () => {
  let $18 = { string: { unit: "karakter", verb: "legyen" }, file: { unit: "byte", verb: "legyen" }, array: { unit: "elem", verb: "legyen" }, set: { unit: "elem", verb: "legyen" } };
  function q(_) {
    return $18[_] ?? null;
  }
  let K = (_) => {
    let Y = typeof _;
    switch (Y) {
      case "number":
        return Number.isNaN(_) ? "NaN" : "szm";
      case "object": {
        if (Array.isArray(_)) return "tmb";
        if (_ === null) return "null";
        if (Object.getPrototypeOf(_) !== Object.prototype && _.constructor) return _.constructor.name;
      }
    }
    return Y;
  }, P = { regex: "bemenet", email: "email cm", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO idblyeg", date: "ISO dtum", time: "ISO id", duration: "ISO idintervallum", ipv4: "IPv4 cm", ipv6: "IPv6 cm", cidrv4: "IPv4 tartomny", cidrv6: "IPv6 tartomny", base64: "base64-kdolt string", base64url: "base64url-kdolt string", json_string: "JSON string", e164: "E.164 szm", jwt: "JWT", template_literal: "bemenet" };
  return (_) => {
    switch (_.code) {
      case "invalid_type":
        return `rvnytelen bemenet: a vrt rtk ${_.expected}, a kapott rtk ${K(_.input)}`;
      case "invalid_value":
        if (_.values.length === 1) return `rvnytelen bemenet: a vrt rtk ${m$(_.values[0])}`;
        return `rvnytelen opci: valamelyik rtk vrt ${T$(_.values, "|")}`;
      case "too_big": {
        let Y = _.inclusive ? "<=" : "<", O = q(_.origin);
        if (O) return `Tl nagy: ${_.origin ?? "rtk"} mrete tl nagy ${Y}${_.maximum.toString()} ${O.unit ?? "elem"}`;
        return `Tl nagy: a bemeneti rtk ${_.origin ?? "rtk"} tl nagy: ${Y}${_.maximum.toString()}`;
      }
      case "too_small": {
        let Y = _.inclusive ? ">=" : ">", O = q(_.origin);
        if (O) return `Tl kicsi: a bemeneti rtk ${_.origin} mrete tl kicsi ${Y}${_.minimum.toString()} ${O.unit}`;
        return `Tl kicsi: a bemeneti rtk ${_.origin} tl kicsi ${Y}${_.minimum.toString()}`;
      }
      case "invalid_format": {
        let Y = _;
        if (Y.format === "starts_with") return `rvnytelen string: "${Y.prefix}" rtkkel kell kezddnie`;
        if (Y.format === "ends_with") return `rvnytelen string: "${Y.suffix}" rtkkel kell vgzdnie`;
        if (Y.format === "includes") return `rvnytelen string: "${Y.includes}" rtket kell tartalmaznia`;
        if (Y.format === "regex") return `rvnytelen string: ${Y.pattern} mintnak kell megfelelnie`;
        return `rvnytelen ${P[Y.format] ?? _.format}`;
      }
      case "not_multiple_of":
        return `rvnytelen szm: ${_.divisor} tbbszrsnek kell lennie`;
      case "unrecognized_keys":
        return `Ismeretlen kulcs${_.keys.length > 1 ? "s" : ""}: ${T$(_.keys, ", ")}`;
      case "invalid_key":
        return `rvnytelen kulcs ${_.origin}`;
      case "invalid_union":
        return "rvnytelen bemenet";
      case "invalid_element":
        return `rvnytelen rtk: ${_.origin}`;
      default:
        return "rvnytelen bemenet";
    }
  };
};
function w3() {
  return { localeError: MD() };
}
var ND = () => {
  let $18 = { string: { unit: "karakter", verb: "memiliki" }, file: { unit: "byte", verb: "memiliki" }, array: { unit: "item", verb: "memiliki" }, set: { unit: "item", verb: "memiliki" } };
  function q(_) {
    return $18[_] ?? null;
  }
  let K = (_) => {
    let Y = typeof _;
    switch (Y) {
      case "number":
        return Number.isNaN(_) ? "NaN" : "number";
      case "object": {
        if (Array.isArray(_)) return "array";
        if (_ === null) return "null";
        if (Object.getPrototypeOf(_) !== Object.prototype && _.constructor) return _.constructor.name;
      }
    }
    return Y;
  }, P = { regex: "input", email: "alamat email", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "tanggal dan waktu format ISO", date: "tanggal format ISO", time: "jam format ISO", duration: "durasi format ISO", ipv4: "alamat IPv4", ipv6: "alamat IPv6", cidrv4: "rentang alamat IPv4", cidrv6: "rentang alamat IPv6", base64: "string dengan enkode base64", base64url: "string dengan enkode base64url", json_string: "string JSON", e164: "angka E.164", jwt: "JWT", template_literal: "input" };
  return (_) => {
    switch (_.code) {
      case "invalid_type":
        return `Input tidak valid: diharapkan ${_.expected}, diterima ${K(_.input)}`;
      case "invalid_value":
        if (_.values.length === 1) return `Input tidak valid: diharapkan ${m$(_.values[0])}`;
        return `Pilihan tidak valid: diharapkan salah satu dari ${T$(_.values, "|")}`;
      case "too_big": {
        let Y = _.inclusive ? "<=" : "<", O = q(_.origin);
        if (O) return `Terlalu besar: diharapkan ${_.origin ?? "value"} memiliki ${Y}${_.maximum.toString()} ${O.unit ?? "elemen"}`;
        return `Terlalu besar: diharapkan ${_.origin ?? "value"} menjadi ${Y}${_.maximum.toString()}`;
      }
      case "too_small": {
        let Y = _.inclusive ? ">=" : ">", O = q(_.origin);
        if (O) return `Terlalu kecil: diharapkan ${_.origin} memiliki ${Y}${_.minimum.toString()} ${O.unit}`;
        return `Terlalu kecil: diharapkan ${_.origin} menjadi ${Y}${_.minimum.toString()}`;
      }
      case "invalid_format": {
        let Y = _;
        if (Y.format === "starts_with") return `String tidak valid: harus dimulai dengan "${Y.prefix}"`;
        if (Y.format === "ends_with") return `String tidak valid: harus berakhir dengan "${Y.suffix}"`;
        if (Y.format === "includes") return `String tidak valid: harus menyertakan "${Y.includes}"`;
        if (Y.format === "regex") return `String tidak valid: harus sesuai pola ${Y.pattern}`;
        return `${P[Y.format] ?? _.format} tidak valid`;
      }
      case "not_multiple_of":
        return `Angka tidak valid: harus kelipatan dari ${_.divisor}`;
      case "unrecognized_keys":
        return `Kunci tidak dikenali ${_.keys.length > 1 ? "s" : ""}: ${T$(_.keys, ", ")}`;
      case "invalid_key":
        return `Kunci tidak valid di ${_.origin}`;
      case "invalid_union":
        return "Input tidak valid";
      case "invalid_element":
        return `Nilai tidak valid di ${_.origin}`;
      default:
        return "Input tidak valid";
    }
  };
};
function f3() {
  return { localeError: ND() };
}
var CD = ($18) => {
  let q = typeof $18;
  switch (q) {
    case "number":
      return Number.isNaN($18) ? "NaN" : "nmer";
    case "object": {
      if (Array.isArray($18)) return "fylki";
      if ($18 === null) return "null";
      if (Object.getPrototypeOf($18) !== Object.prototype && $18.constructor) return $18.constructor.name;
    }
  }
  return q;
};
var ED = () => {
  let $18 = { string: { unit: "stafi", verb: "a hafa" }, file: { unit: "bti", verb: "a hafa" }, array: { unit: "hluti", verb: "a hafa" }, set: { unit: "hluti", verb: "a hafa" } };
  function q(P) {
    return $18[P] ?? null;
  }
  let K = { regex: "gildi", email: "netfang", url: "vefsl", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO dagsetning og tmi", date: "ISO dagsetning", time: "ISO tmi", duration: "ISO tmalengd", ipv4: "IPv4 address", ipv6: "IPv6 address", cidrv4: "IPv4 range", cidrv6: "IPv6 range", base64: "base64-encoded strengur", base64url: "base64url-encoded strengur", json_string: "JSON strengur", e164: "E.164 tlugildi", jwt: "JWT", template_literal: "gildi" };
  return (P) => {
    switch (P.code) {
      case "invalid_type":
        return `Rangt gildi:  slst inn ${CD(P.input)} ar sem  a vera ${P.expected}`;
      case "invalid_value":
        if (P.values.length === 1) return `Rangt gildi: gert r fyrir ${m$(P.values[0])}`;
        return `gilt val: m vera eitt af eftirfarandi ${T$(P.values, "|")}`;
      case "too_big": {
        let _ = P.inclusive ? "<=" : "<", Y = q(P.origin);
        if (Y) return `Of strt: gert er r fyrir a ${P.origin ?? "gildi"} hafi ${_}${P.maximum.toString()} ${Y.unit ?? "hluti"}`;
        return `Of strt: gert er r fyrir a ${P.origin ?? "gildi"} s ${_}${P.maximum.toString()}`;
      }
      case "too_small": {
        let _ = P.inclusive ? ">=" : ">", Y = q(P.origin);
        if (Y) return `Of lti: gert er r fyrir a ${P.origin} hafi ${_}${P.minimum.toString()} ${Y.unit}`;
        return `Of lti: gert er r fyrir a ${P.origin} s ${_}${P.minimum.toString()}`;
      }
      case "invalid_format": {
        let _ = P;
        if (_.format === "starts_with") return `gildur strengur: verur a byrja  "${_.prefix}"`;
        if (_.format === "ends_with") return `gildur strengur: verur a enda  "${_.suffix}"`;
        if (_.format === "includes") return `gildur strengur: verur a innihalda "${_.includes}"`;
        if (_.format === "regex") return `gildur strengur: verur a fylgja mynstri ${_.pattern}`;
        return `Rangt ${K[_.format] ?? P.format}`;
      }
      case "not_multiple_of":
        return `Rng tala: verur a vera margfeldi af ${P.divisor}`;
      case "unrecognized_keys":
        return `ekkt ${P.keys.length > 1 ? "ir lyklar" : "ur lykill"}: ${T$(P.keys, ", ")}`;
      case "invalid_key":
        return `Rangur lykill  ${P.origin}`;
      case "invalid_union":
        return "Rangt gildi";
      case "invalid_element":
        return `Rangt gildi  ${P.origin}`;
      default:
        return "Rangt gildi";
    }
  };
};
function Z3() {
  return { localeError: ED() };
}
var hD = () => {
  let $18 = { string: { unit: "caratteri", verb: "avere" }, file: { unit: "byte", verb: "avere" }, array: { unit: "elementi", verb: "avere" }, set: { unit: "elementi", verb: "avere" } };
  function q(_) {
    return $18[_] ?? null;
  }
  let K = (_) => {
    let Y = typeof _;
    switch (Y) {
      case "number":
        return Number.isNaN(_) ? "NaN" : "numero";
      case "object": {
        if (Array.isArray(_)) return "vettore";
        if (_ === null) return "null";
        if (Object.getPrototypeOf(_) !== Object.prototype && _.constructor) return _.constructor.name;
      }
    }
    return Y;
  }, P = { regex: "input", email: "indirizzo email", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "data e ora ISO", date: "data ISO", time: "ora ISO", duration: "durata ISO", ipv4: "indirizzo IPv4", ipv6: "indirizzo IPv6", cidrv4: "intervallo IPv4", cidrv6: "intervallo IPv6", base64: "stringa codificata in base64", base64url: "URL codificata in base64", json_string: "stringa JSON", e164: "numero E.164", jwt: "JWT", template_literal: "input" };
  return (_) => {
    switch (_.code) {
      case "invalid_type":
        return `Input non valido: atteso ${_.expected}, ricevuto ${K(_.input)}`;
      case "invalid_value":
        if (_.values.length === 1) return `Input non valido: atteso ${m$(_.values[0])}`;
        return `Opzione non valida: atteso uno tra ${T$(_.values, "|")}`;
      case "too_big": {
        let Y = _.inclusive ? "<=" : "<", O = q(_.origin);
        if (O) return `Troppo grande: ${_.origin ?? "valore"} deve avere ${Y}${_.maximum.toString()} ${O.unit ?? "elementi"}`;
        return `Troppo grande: ${_.origin ?? "valore"} deve essere ${Y}${_.maximum.toString()}`;
      }
      case "too_small": {
        let Y = _.inclusive ? ">=" : ">", O = q(_.origin);
        if (O) return `Troppo piccolo: ${_.origin} deve avere ${Y}${_.minimum.toString()} ${O.unit}`;
        return `Troppo piccolo: ${_.origin} deve essere ${Y}${_.minimum.toString()}`;
      }
      case "invalid_format": {
        let Y = _;
        if (Y.format === "starts_with") return `Stringa non valida: deve iniziare con "${Y.prefix}"`;
        if (Y.format === "ends_with") return `Stringa non valida: deve terminare con "${Y.suffix}"`;
        if (Y.format === "includes") return `Stringa non valida: deve includere "${Y.includes}"`;
        if (Y.format === "regex") return `Stringa non valida: deve corrispondere al pattern ${Y.pattern}`;
        return `Invalid ${P[Y.format] ?? _.format}`;
      }
      case "not_multiple_of":
        return `Numero non valido: deve essere un multiplo di ${_.divisor}`;
      case "unrecognized_keys":
        return `Chiav${_.keys.length > 1 ? "i" : "e"} non riconosciut${_.keys.length > 1 ? "e" : "a"}: ${T$(_.keys, ", ")}`;
      case "invalid_key":
        return `Chiave non valida in ${_.origin}`;
      case "invalid_union":
        return "Input non valido";
      case "invalid_element":
        return `Valore non valido in ${_.origin}`;
      default:
        return "Input non valido";
    }
  };
};
function X3() {
  return { localeError: hD() };
}
var RD = () => {
  let $18 = { string: { unit: "", verb: "" }, file: { unit: "", verb: "" }, array: { unit: "", verb: "" }, set: { unit: "", verb: "" } };
  function q(_) {
    return $18[_] ?? null;
  }
  let K = (_) => {
    let Y = typeof _;
    switch (Y) {
      case "number":
        return Number.isNaN(_) ? "NaN" : "";
      case "object": {
        if (Array.isArray(_)) return "";
        if (_ === null) return "null";
        if (Object.getPrototypeOf(_) !== Object.prototype && _.constructor) return _.constructor.name;
      }
    }
    return Y;
  }, P = { regex: "", email: "", url: "URL", emoji: "", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO", date: "ISO", time: "ISO", duration: "ISO", ipv4: "IPv4", ipv6: "IPv6", cidrv4: "IPv4", cidrv6: "IPv6", base64: "base64", base64url: "base64url", json_string: "JSON", e164: "E.164", jwt: "JWT", template_literal: "" };
  return (_) => {
    switch (_.code) {
      case "invalid_type":
        return `: ${_.expected}${K(_.input)}`;
      case "invalid_value":
        if (_.values.length === 1) return `: ${m$(_.values[0])}`;
        return `: ${T$(_.values, "")}`;
      case "too_big": {
        let Y = _.inclusive ? "" : "", O = q(_.origin);
        if (O) return `: ${_.origin ?? ""}${_.maximum.toString()}${O.unit ?? ""}${Y}`;
        return `: ${_.origin ?? ""}${_.maximum.toString()}${Y}`;
      }
      case "too_small": {
        let Y = _.inclusive ? "" : "", O = q(_.origin);
        if (O) return `: ${_.origin}${_.minimum.toString()}${O.unit}${Y}`;
        return `: ${_.origin}${_.minimum.toString()}${Y}`;
      }
      case "invalid_format": {
        let Y = _;
        if (Y.format === "starts_with") return `: "${Y.prefix}"`;
        if (Y.format === "ends_with") return `: "${Y.suffix}"`;
        if (Y.format === "includes") return `: "${Y.includes}"`;
        if (Y.format === "regex") return `: ${Y.pattern}`;
        return `${P[Y.format] ?? _.format}`;
      }
      case "not_multiple_of":
        return `: ${_.divisor}`;
      case "unrecognized_keys":
        return `${_.keys.length > 1 ? "" : ""}: ${T$(_.keys, "")}`;
      case "invalid_key":
        return `${_.origin}`;
      case "invalid_union":
        return "";
      case "invalid_element":
        return `${_.origin}`;
      default:
        return "";
    }
  };
};
function A3() {
  return { localeError: RD() };
}
var ID = ($18) => {
  let q = typeof $18;
  switch (q) {
    case "number":
      return Number.isNaN($18) ? "NaN" : "";
    case "object": {
      if (Array.isArray($18)) return "";
      if ($18 === null) return "null";
      if (Object.getPrototypeOf($18) !== Object.prototype && $18.constructor) return $18.constructor.name;
    }
  }
  return { string: "", boolean: "", undefined: "undefined", bigint: "bigint", symbol: "symbol", function: "" }[q] ?? q;
};
var DD = () => {
  let $18 = { string: { unit: "", verb: " " }, file: { unit: "", verb: " " }, array: { unit: "", verb: " " }, set: { unit: "", verb: " " } };
  function q(P) {
    return $18[P] ?? null;
  }
  let K = { regex: "", email: "- ", url: "URL", emoji: "", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "-", date: "", time: "", duration: "", ipv4: "IPv4 ", ipv6: "IPv6 ", cidrv4: "IPv4 ", cidrv6: "IPv6 ", base64: "base64- ", base64url: "base64url- ", json_string: "JSON ", e164: "E.164 ", jwt: "JWT", template_literal: "" };
  return (P) => {
    switch (P.code) {
      case "invalid_type":
        return ` :  ${P.expected},  ${ID(P.input)}`;
      case "invalid_value":
        if (P.values.length === 1) return ` :  ${m$(P.values[0])}`;
        return ` :  - ${T$(P.values, "|")}-`;
      case "too_big": {
        let _ = P.inclusive ? "<=" : "<", Y = q(P.origin);
        if (Y) return ` :  ${P.origin ?? ""} ${Y.verb} ${_}${P.maximum.toString()} ${Y.unit}`;
        return ` :  ${P.origin ?? ""}  ${_}${P.maximum.toString()}`;
      }
      case "too_small": {
        let _ = P.inclusive ? ">=" : ">", Y = q(P.origin);
        if (Y) return ` :  ${P.origin} ${Y.verb} ${_}${P.minimum.toString()} ${Y.unit}`;
        return ` :  ${P.origin}  ${_}${P.minimum.toString()}`;
      }
      case "invalid_format": {
        let _ = P;
        if (_.format === "starts_with") return ` :   "${_.prefix}"-`;
        if (_.format === "ends_with") return ` :   "${_.suffix}"-`;
        if (_.format === "includes") return ` :   "${_.includes}"-`;
        if (_.format === "regex") return ` :    ${_.pattern}`;
        return ` ${K[_.format] ?? P.format}`;
      }
      case "not_multiple_of":
        return ` :   ${P.divisor}- `;
      case "unrecognized_keys":
        return ` ${P.keys.length > 1 ? "" : ""}: ${T$(P.keys, ", ")}`;
      case "invalid_key":
        return `  ${P.origin}-`;
      case "invalid_union":
        return " ";
      case "invalid_element":
        return `  ${P.origin}-`;
      default:
        return " ";
    }
  };
};
function k3() {
  return { localeError: DD() };
}
var LD = () => {
  let $18 = { string: { unit: "", verb: "" }, file: { unit: "", verb: "" }, array: { unit: "", verb: "" }, set: { unit: "", verb: "" } };
  function q(_) {
    return $18[_] ?? null;
  }
  let K = (_) => {
    let Y = typeof _;
    switch (Y) {
      case "number":
        return Number.isNaN(_) ? " (NaN)" : "";
      case "object": {
        if (Array.isArray(_)) return " (Array)";
        if (_ === null) return " (null)";
        if (Object.getPrototypeOf(_) !== Object.prototype && _.constructor) return _.constructor.name;
      }
    }
    return Y;
  }, P = { regex: "", email: "", url: "URL", emoji: "", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "  ISO", date: " ISO", time: " ISO", duration: " ISO", ipv4: " IPv4", ipv6: " IPv6", cidrv4: " IPv4", cidrv6: " IPv6", base64: " base64", base64url: " base64url", json_string: " JSON", e164: " E.164", jwt: "JWT", template_literal: "" };
  return (_) => {
    switch (_.code) {
      case "invalid_type":
        return `  ${_.expected}  ${K(_.input)}`;
      case "invalid_value":
        if (_.values.length === 1) return `  ${m$(_.values[0])}`;
        return `  ${T$(_.values, "|")}`;
      case "too_big": {
        let Y = _.inclusive ? "<=" : "<", O = q(_.origin);
        if (O) return `  ${_.origin ?? ""} ${Y} ${_.maximum.toString()} ${O.unit ?? ""}`;
        return `  ${_.origin ?? ""} ${Y} ${_.maximum.toString()}`;
      }
      case "too_small": {
        let Y = _.inclusive ? ">=" : ">", O = q(_.origin);
        if (O) return `  ${_.origin} ${Y} ${_.minimum.toString()} ${O.unit}`;
        return `  ${_.origin} ${Y} ${_.minimum.toString()}`;
      }
      case "invalid_format": {
        let Y = _;
        if (Y.format === "starts_with") return `  "${Y.prefix}"`;
        if (Y.format === "ends_with") return `  "${Y.suffix}"`;
        if (Y.format === "includes") return `  "${Y.includes}"`;
        if (Y.format === "regex") return `  ${Y.pattern}`;
        return ` ${P[Y.format] ?? _.format}`;
      }
      case "not_multiple_of":
        return `  ${_.divisor}`;
      case "unrecognized_keys":
        return ` ${T$(_.keys, ", ")}`;
      case "invalid_key":
        return ` ${_.origin}`;
      case "invalid_union":
        return "";
      case "invalid_element":
        return ` ${_.origin}`;
      default:
        return "";
    }
  };
};
function oP() {
  return { localeError: LD() };
}
function G3() {
  return oP();
}
var gD = () => {
  let $18 = { string: { unit: "", verb: "to have" }, file: { unit: "", verb: "to have" }, array: { unit: "", verb: "to have" }, set: { unit: "", verb: "to have" } };
  function q(_) {
    return $18[_] ?? null;
  }
  let K = (_) => {
    let Y = typeof _;
    switch (Y) {
      case "number":
        return Number.isNaN(_) ? "NaN" : "number";
      case "object": {
        if (Array.isArray(_)) return "array";
        if (_ === null) return "null";
        if (Object.getPrototypeOf(_) !== Object.prototype && _.constructor) return _.constructor.name;
      }
    }
    return Y;
  }, P = { regex: "", email: " ", url: "URL", emoji: "", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO ", date: "ISO ", time: "ISO ", duration: "ISO ", ipv4: "IPv4 ", ipv6: "IPv6 ", cidrv4: "IPv4 ", cidrv6: "IPv6 ", base64: "base64  ", base64url: "base64url  ", json_string: "JSON ", e164: "E.164 ", jwt: "JWT", template_literal: "" };
  return (_) => {
    switch (_.code) {
      case "invalid_type":
        return ` :   ${_.expected},   ${K(_.input)}`;
      case "invalid_value":
        if (_.values.length === 1) return ` :  ${m$(_.values[0])}  `;
        return ` : ${T$(_.values, " ")}   `;
      case "too_big": {
        let Y = _.inclusive ? "" : "", O = Y === "" ? " " : " ", z = q(_.origin), J = (z == null ? void 0 : z.unit) ?? "";
        if (z) return `${_.origin ?? ""}  : ${_.maximum.toString()}${J} ${Y}${O}`;
        return `${_.origin ?? ""}  : ${_.maximum.toString()} ${Y}${O}`;
      }
      case "too_small": {
        let Y = _.inclusive ? "" : "", O = Y === "" ? " " : " ", z = q(_.origin), J = (z == null ? void 0 : z.unit) ?? "";
        if (z) return `${_.origin ?? ""}  : ${_.minimum.toString()}${J} ${Y}${O}`;
        return `${_.origin ?? ""}  : ${_.minimum.toString()} ${Y}${O}`;
      }
      case "invalid_format": {
        let Y = _;
        if (Y.format === "starts_with") return ` : "${Y.prefix}"()  `;
        if (Y.format === "ends_with") return ` : "${Y.suffix}"()  `;
        if (Y.format === "includes") return ` : "${Y.includes}"()  `;
        if (Y.format === "regex") return ` :  ${Y.pattern}   `;
        return ` ${P[Y.format] ?? _.format}`;
      }
      case "not_multiple_of":
        return ` : ${_.divisor}  `;
      case "unrecognized_keys":
        return `   : ${T$(_.keys, ", ")}`;
      case "invalid_key":
        return ` : ${_.origin}`;
      case "invalid_union":
        return " ";
      case "invalid_element":
        return ` : ${_.origin}`;
      default:
        return " ";
    }
  };
};
function V3() {
  return { localeError: gD() };
}
var bD = ($18) => {
  return iP(typeof $18, $18);
};
var iP = ($18, q = void 0) => {
  switch ($18) {
    case "number":
      return Number.isNaN(q) ? "NaN" : "skaiius";
    case "bigint":
      return "sveikasis skaiius";
    case "string":
      return "eilut";
    case "boolean":
      return "login reikm";
    case "undefined":
    case "void":
      return "neapibrta reikm";
    case "function":
      return "funkcija";
    case "symbol":
      return "simbolis";
    case "object": {
      if (q === void 0) return "neinomas objektas";
      if (q === null) return "nulin reikm";
      if (Array.isArray(q)) return "masyvas";
      if (Object.getPrototypeOf(q) !== Object.prototype && q.constructor) return q.constructor.name;
      return "objektas";
    }
    case "null":
      return "nulin reikm";
  }
  return $18;
};
var nP = ($18) => {
  return $18.charAt(0).toUpperCase() + $18.slice(1);
};
function KA($18) {
  let q = Math.abs($18), K = q % 10, P = q % 100;
  if (P >= 11 && P <= 19 || K === 0) return "many";
  if (K === 1) return "one";
  return "few";
}
var yD = () => {
  let $18 = { string: { unit: { one: "simbolis", few: "simboliai", many: "simboli" }, verb: { smaller: { inclusive: "turi bti ne ilgesn kaip", notInclusive: "turi bti trumpesn kaip" }, bigger: { inclusive: "turi bti ne trumpesn kaip", notInclusive: "turi bti ilgesn kaip" } } }, file: { unit: { one: "baitas", few: "baitai", many: "bait" }, verb: { smaller: { inclusive: "turi bti ne didesnis kaip", notInclusive: "turi bti maesnis kaip" }, bigger: { inclusive: "turi bti ne maesnis kaip", notInclusive: "turi bti didesnis kaip" } } }, array: { unit: { one: "element", few: "elementus", many: "element" }, verb: { smaller: { inclusive: "turi turti ne daugiau kaip", notInclusive: "turi turti maiau kaip" }, bigger: { inclusive: "turi turti ne maiau kaip", notInclusive: "turi turti daugiau kaip" } } }, set: { unit: { one: "element", few: "elementus", many: "element" }, verb: { smaller: { inclusive: "turi turti ne daugiau kaip", notInclusive: "turi turti maiau kaip" }, bigger: { inclusive: "turi turti ne maiau kaip", notInclusive: "turi turti daugiau kaip" } } } };
  function q(P, _, Y, O) {
    let z = $18[P] ?? null;
    if (z === null) return z;
    return { unit: z.unit[_], verb: z.verb[O][Y ? "inclusive" : "notInclusive"] };
  }
  let K = { regex: "vestis", email: "el. pato adresas", url: "URL", emoji: "jaustukas", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO data ir laikas", date: "ISO data", time: "ISO laikas", duration: "ISO trukm", ipv4: "IPv4 adresas", ipv6: "IPv6 adresas", cidrv4: "IPv4 tinklo prefiksas (CIDR)", cidrv6: "IPv6 tinklo prefiksas (CIDR)", base64: "base64 ukoduota eilut", base64url: "base64url ukoduota eilut", json_string: "JSON eilut", e164: "E.164 numeris", jwt: "JWT", template_literal: "vestis" };
  return (P) => {
    switch (P.code) {
      case "invalid_type":
        return `Gautas tipas ${bD(P.input)}, o tiktasi - ${iP(P.expected)}`;
      case "invalid_value":
        if (P.values.length === 1) return `Privalo bti ${m$(P.values[0])}`;
        return `Privalo bti vienas i ${T$(P.values, "|")} pasirinkim`;
      case "too_big": {
        let _ = iP(P.origin), Y = q(P.origin, KA(Number(P.maximum)), P.inclusive ?? false, "smaller");
        if (Y == null ? void 0 : Y.verb) return `${nP(_ ?? P.origin ?? "reikm")} ${Y.verb} ${P.maximum.toString()} ${Y.unit ?? "element"}`;
        let O = P.inclusive ? "ne didesnis kaip" : "maesnis kaip";
        return `${nP(_ ?? P.origin ?? "reikm")} turi bti ${O} ${P.maximum.toString()} ${Y == null ? void 0 : Y.unit}`;
      }
      case "too_small": {
        let _ = iP(P.origin), Y = q(P.origin, KA(Number(P.minimum)), P.inclusive ?? false, "bigger");
        if (Y == null ? void 0 : Y.verb) return `${nP(_ ?? P.origin ?? "reikm")} ${Y.verb} ${P.minimum.toString()} ${Y.unit ?? "element"}`;
        let O = P.inclusive ? "ne maesnis kaip" : "didesnis kaip";
        return `${nP(_ ?? P.origin ?? "reikm")} turi bti ${O} ${P.minimum.toString()} ${Y == null ? void 0 : Y.unit}`;
      }
      case "invalid_format": {
        let _ = P;
        if (_.format === "starts_with") return `Eilut privalo prasidti "${_.prefix}"`;
        if (_.format === "ends_with") return `Eilut privalo pasibaigti "${_.suffix}"`;
        if (_.format === "includes") return `Eilut privalo traukti "${_.includes}"`;
        if (_.format === "regex") return `Eilut privalo atitikti ${_.pattern}`;
        return `Neteisingas ${K[_.format] ?? P.format}`;
      }
      case "not_multiple_of":
        return `Skaiius privalo bti ${P.divisor} kartotinis.`;
      case "unrecognized_keys":
        return `Neatpaint${P.keys.length > 1 ? "i" : "as"} rakt${P.keys.length > 1 ? "ai" : "as"}: ${T$(P.keys, ", ")}`;
      case "invalid_key":
        return "Rastas klaidingas raktas";
      case "invalid_union":
        return "Klaidinga vestis";
      case "invalid_element": {
        let _ = iP(P.origin);
        return `${nP(_ ?? P.origin ?? "reikm")} turi klaiding vest`;
      }
      default:
        return "Klaidinga vestis";
    }
  };
};
function S3() {
  return { localeError: yD() };
}
var uD = () => {
  let $18 = { string: { unit: "", verb: " " }, file: { unit: "", verb: " " }, array: { unit: "", verb: " " }, set: { unit: "", verb: " " } };
  function q(_) {
    return $18[_] ?? null;
  }
  let K = (_) => {
    let Y = typeof _;
    switch (Y) {
      case "number":
        return Number.isNaN(_) ? "NaN" : "";
      case "object": {
        if (Array.isArray(_)) return "";
        if (_ === null) return "null";
        if (Object.getPrototypeOf(_) !== Object.prototype && _.constructor) return _.constructor.name;
      }
    }
    return Y;
  }, P = { regex: "", email: "  -", url: "URL", emoji: "", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO   ", date: "ISO ", time: "ISO ", duration: "ISO ", ipv4: "IPv4 ", ipv6: "IPv6 ", cidrv4: "IPv4 ", cidrv6: "IPv6 ", base64: "base64- ", base64url: "base64url- ", json_string: "JSON ", e164: "E.164 ", jwt: "JWT", template_literal: "" };
  return (_) => {
    switch (_.code) {
      case "invalid_type":
        return ` :   ${_.expected},  ${K(_.input)}`;
      case "invalid_value":
        if (_.values.length === 1) return `Invalid input: expected ${m$(_.values[0])}`;
        return ` :    ${T$(_.values, "|")}`;
      case "too_big": {
        let Y = _.inclusive ? "<=" : "<", O = q(_.origin);
        if (O) return ` :   ${_.origin ?? ""}   ${Y}${_.maximum.toString()} ${O.unit ?? ""}`;
        return ` :   ${_.origin ?? ""}   ${Y}${_.maximum.toString()}`;
      }
      case "too_small": {
        let Y = _.inclusive ? ">=" : ">", O = q(_.origin);
        if (O) return ` :   ${_.origin}   ${Y}${_.minimum.toString()} ${O.unit}`;
        return ` :   ${_.origin}   ${Y}${_.minimum.toString()}`;
      }
      case "invalid_format": {
        let Y = _;
        if (Y.format === "starts_with") return ` :     "${Y.prefix}"`;
        if (Y.format === "ends_with") return ` :     "${Y.suffix}"`;
        if (Y.format === "includes") return ` :    "${Y.includes}"`;
        if (Y.format === "regex") return ` :      ${Y.pattern}`;
        return `Invalid ${P[Y.format] ?? _.format}`;
      }
      case "not_multiple_of":
        return ` :      ${_.divisor}`;
      case "unrecognized_keys":
        return `${_.keys.length > 1 ? " " : " "}: ${T$(_.keys, ", ")}`;
      case "invalid_key":
        return `   ${_.origin}`;
      case "invalid_union":
        return " ";
      case "invalid_element":
        return `   ${_.origin}`;
      default:
        return " ";
    }
  };
};
function M3() {
  return { localeError: uD() };
}
var xD = () => {
  let $18 = { string: { unit: "aksara", verb: "mempunyai" }, file: { unit: "bait", verb: "mempunyai" }, array: { unit: "elemen", verb: "mempunyai" }, set: { unit: "elemen", verb: "mempunyai" } };
  function q(_) {
    return $18[_] ?? null;
  }
  let K = (_) => {
    let Y = typeof _;
    switch (Y) {
      case "number":
        return Number.isNaN(_) ? "NaN" : "nombor";
      case "object": {
        if (Array.isArray(_)) return "array";
        if (_ === null) return "null";
        if (Object.getPrototypeOf(_) !== Object.prototype && _.constructor) return _.constructor.name;
      }
    }
    return Y;
  }, P = { regex: "input", email: "alamat e-mel", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "tarikh masa ISO", date: "tarikh ISO", time: "masa ISO", duration: "tempoh ISO", ipv4: "alamat IPv4", ipv6: "alamat IPv6", cidrv4: "julat IPv4", cidrv6: "julat IPv6", base64: "string dikodkan base64", base64url: "string dikodkan base64url", json_string: "string JSON", e164: "nombor E.164", jwt: "JWT", template_literal: "input" };
  return (_) => {
    switch (_.code) {
      case "invalid_type":
        return `Input tidak sah: dijangka ${_.expected}, diterima ${K(_.input)}`;
      case "invalid_value":
        if (_.values.length === 1) return `Input tidak sah: dijangka ${m$(_.values[0])}`;
        return `Pilihan tidak sah: dijangka salah satu daripada ${T$(_.values, "|")}`;
      case "too_big": {
        let Y = _.inclusive ? "<=" : "<", O = q(_.origin);
        if (O) return `Terlalu besar: dijangka ${_.origin ?? "nilai"} ${O.verb} ${Y}${_.maximum.toString()} ${O.unit ?? "elemen"}`;
        return `Terlalu besar: dijangka ${_.origin ?? "nilai"} adalah ${Y}${_.maximum.toString()}`;
      }
      case "too_small": {
        let Y = _.inclusive ? ">=" : ">", O = q(_.origin);
        if (O) return `Terlalu kecil: dijangka ${_.origin} ${O.verb} ${Y}${_.minimum.toString()} ${O.unit}`;
        return `Terlalu kecil: dijangka ${_.origin} adalah ${Y}${_.minimum.toString()}`;
      }
      case "invalid_format": {
        let Y = _;
        if (Y.format === "starts_with") return `String tidak sah: mesti bermula dengan "${Y.prefix}"`;
        if (Y.format === "ends_with") return `String tidak sah: mesti berakhir dengan "${Y.suffix}"`;
        if (Y.format === "includes") return `String tidak sah: mesti mengandungi "${Y.includes}"`;
        if (Y.format === "regex") return `String tidak sah: mesti sepadan dengan corak ${Y.pattern}`;
        return `${P[Y.format] ?? _.format} tidak sah`;
      }
      case "not_multiple_of":
        return `Nombor tidak sah: perlu gandaan ${_.divisor}`;
      case "unrecognized_keys":
        return `Kunci tidak dikenali: ${T$(_.keys, ", ")}`;
      case "invalid_key":
        return `Kunci tidak sah dalam ${_.origin}`;
      case "invalid_union":
        return "Input tidak sah";
      case "invalid_element":
        return `Nilai tidak sah dalam ${_.origin}`;
      default:
        return "Input tidak sah";
    }
  };
};
function N3() {
  return { localeError: xD() };
}
var pD = () => {
  let $18 = { string: { unit: "tekens" }, file: { unit: "bytes" }, array: { unit: "elementen" }, set: { unit: "elementen" } };
  function q(_) {
    return $18[_] ?? null;
  }
  let K = (_) => {
    let Y = typeof _;
    switch (Y) {
      case "number":
        return Number.isNaN(_) ? "NaN" : "getal";
      case "object": {
        if (Array.isArray(_)) return "array";
        if (_ === null) return "null";
        if (Object.getPrototypeOf(_) !== Object.prototype && _.constructor) return _.constructor.name;
      }
    }
    return Y;
  }, P = { regex: "invoer", email: "emailadres", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO datum en tijd", date: "ISO datum", time: "ISO tijd", duration: "ISO duur", ipv4: "IPv4-adres", ipv6: "IPv6-adres", cidrv4: "IPv4-bereik", cidrv6: "IPv6-bereik", base64: "base64-gecodeerde tekst", base64url: "base64 URL-gecodeerde tekst", json_string: "JSON string", e164: "E.164-nummer", jwt: "JWT", template_literal: "invoer" };
  return (_) => {
    switch (_.code) {
      case "invalid_type":
        return `Ongeldige invoer: verwacht ${_.expected}, ontving ${K(_.input)}`;
      case "invalid_value":
        if (_.values.length === 1) return `Ongeldige invoer: verwacht ${m$(_.values[0])}`;
        return `Ongeldige optie: verwacht n van ${T$(_.values, "|")}`;
      case "too_big": {
        let Y = _.inclusive ? "<=" : "<", O = q(_.origin);
        if (O) return `Te lang: verwacht dat ${_.origin ?? "waarde"} ${Y}${_.maximum.toString()} ${O.unit ?? "elementen"} bevat`;
        return `Te lang: verwacht dat ${_.origin ?? "waarde"} ${Y}${_.maximum.toString()} is`;
      }
      case "too_small": {
        let Y = _.inclusive ? ">=" : ">", O = q(_.origin);
        if (O) return `Te kort: verwacht dat ${_.origin} ${Y}${_.minimum.toString()} ${O.unit} bevat`;
        return `Te kort: verwacht dat ${_.origin} ${Y}${_.minimum.toString()} is`;
      }
      case "invalid_format": {
        let Y = _;
        if (Y.format === "starts_with") return `Ongeldige tekst: moet met "${Y.prefix}" beginnen`;
        if (Y.format === "ends_with") return `Ongeldige tekst: moet op "${Y.suffix}" eindigen`;
        if (Y.format === "includes") return `Ongeldige tekst: moet "${Y.includes}" bevatten`;
        if (Y.format === "regex") return `Ongeldige tekst: moet overeenkomen met patroon ${Y.pattern}`;
        return `Ongeldig: ${P[Y.format] ?? _.format}`;
      }
      case "not_multiple_of":
        return `Ongeldig getal: moet een veelvoud van ${_.divisor} zijn`;
      case "unrecognized_keys":
        return `Onbekende key${_.keys.length > 1 ? "s" : ""}: ${T$(_.keys, ", ")}`;
      case "invalid_key":
        return `Ongeldige key in ${_.origin}`;
      case "invalid_union":
        return "Ongeldige invoer";
      case "invalid_element":
        return `Ongeldige waarde in ${_.origin}`;
      default:
        return "Ongeldige invoer";
    }
  };
};
function C3() {
  return { localeError: pD() };
}
var cD = () => {
  let $18 = { string: { unit: "tegn", verb: " ha" }, file: { unit: "bytes", verb: " ha" }, array: { unit: "elementer", verb: " inneholde" }, set: { unit: "elementer", verb: " inneholde" } };
  function q(_) {
    return $18[_] ?? null;
  }
  let K = (_) => {
    let Y = typeof _;
    switch (Y) {
      case "number":
        return Number.isNaN(_) ? "NaN" : "tall";
      case "object": {
        if (Array.isArray(_)) return "liste";
        if (_ === null) return "null";
        if (Object.getPrototypeOf(_) !== Object.prototype && _.constructor) return _.constructor.name;
      }
    }
    return Y;
  }, P = { regex: "input", email: "e-postadresse", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO dato- og klokkeslett", date: "ISO-dato", time: "ISO-klokkeslett", duration: "ISO-varighet", ipv4: "IPv4-omrde", ipv6: "IPv6-omrde", cidrv4: "IPv4-spekter", cidrv6: "IPv6-spekter", base64: "base64-enkodet streng", base64url: "base64url-enkodet streng", json_string: "JSON-streng", e164: "E.164-nummer", jwt: "JWT", template_literal: "input" };
  return (_) => {
    switch (_.code) {
      case "invalid_type":
        return `Ugyldig input: forventet ${_.expected}, fikk ${K(_.input)}`;
      case "invalid_value":
        if (_.values.length === 1) return `Ugyldig verdi: forventet ${m$(_.values[0])}`;
        return `Ugyldig valg: forventet en av ${T$(_.values, "|")}`;
      case "too_big": {
        let Y = _.inclusive ? "<=" : "<", O = q(_.origin);
        if (O) return `For stor(t): forventet ${_.origin ?? "value"} til  ha ${Y}${_.maximum.toString()} ${O.unit ?? "elementer"}`;
        return `For stor(t): forventet ${_.origin ?? "value"} til  ha ${Y}${_.maximum.toString()}`;
      }
      case "too_small": {
        let Y = _.inclusive ? ">=" : ">", O = q(_.origin);
        if (O) return `For lite(n): forventet ${_.origin} til  ha ${Y}${_.minimum.toString()} ${O.unit}`;
        return `For lite(n): forventet ${_.origin} til  ha ${Y}${_.minimum.toString()}`;
      }
      case "invalid_format": {
        let Y = _;
        if (Y.format === "starts_with") return `Ugyldig streng: m starte med "${Y.prefix}"`;
        if (Y.format === "ends_with") return `Ugyldig streng: m ende med "${Y.suffix}"`;
        if (Y.format === "includes") return `Ugyldig streng: m inneholde "${Y.includes}"`;
        if (Y.format === "regex") return `Ugyldig streng: m matche mnsteret ${Y.pattern}`;
        return `Ugyldig ${P[Y.format] ?? _.format}`;
      }
      case "not_multiple_of":
        return `Ugyldig tall: m vre et multiplum av ${_.divisor}`;
      case "unrecognized_keys":
        return `${_.keys.length > 1 ? "Ukjente nkler" : "Ukjent nkkel"}: ${T$(_.keys, ", ")}`;
      case "invalid_key":
        return `Ugyldig nkkel i ${_.origin}`;
      case "invalid_union":
        return "Ugyldig input";
      case "invalid_element":
        return `Ugyldig verdi i ${_.origin}`;
      default:
        return "Ugyldig input";
    }
  };
};
function E3() {
  return { localeError: cD() };
}
var mD = () => {
  let $18 = { string: { unit: "harf", verb: "olmaldr" }, file: { unit: "bayt", verb: "olmaldr" }, array: { unit: "unsur", verb: "olmaldr" }, set: { unit: "unsur", verb: "olmaldr" } };
  function q(_) {
    return $18[_] ?? null;
  }
  let K = (_) => {
    let Y = typeof _;
    switch (Y) {
      case "number":
        return Number.isNaN(_) ? "NaN" : "numara";
      case "object": {
        if (Array.isArray(_)) return "saf";
        if (_ === null) return "gayb";
        if (Object.getPrototypeOf(_) !== Object.prototype && _.constructor) return _.constructor.name;
      }
    }
    return Y;
  }, P = { regex: "giren", email: "epostagh", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO hengm", date: "ISO tarihi", time: "ISO zaman", duration: "ISO mddeti", ipv4: "IPv4 nin", ipv6: "IPv6 nin", cidrv4: "IPv4 menzili", cidrv6: "IPv6 menzili", base64: "base64-ifreli metin", base64url: "base64url-ifreli metin", json_string: "JSON metin", e164: "E.164 says", jwt: "JWT", template_literal: "giren" };
  return (_) => {
    switch (_.code) {
      case "invalid_type":
        return `Fsit giren: umulan ${_.expected}, alnan ${K(_.input)}`;
      case "invalid_value":
        if (_.values.length === 1) return `Fsit giren: umulan ${m$(_.values[0])}`;
        return `Fsit tercih: mteberler ${T$(_.values, "|")}`;
      case "too_big": {
        let Y = _.inclusive ? "<=" : "<", O = q(_.origin);
        if (O) return `Fazla byk: ${_.origin ?? "value"}, ${Y}${_.maximum.toString()} ${O.unit ?? "elements"} sahip olmalyd.`;
        return `Fazla byk: ${_.origin ?? "value"}, ${Y}${_.maximum.toString()} olmalyd.`;
      }
      case "too_small": {
        let Y = _.inclusive ? ">=" : ">", O = q(_.origin);
        if (O) return `Fazla kk: ${_.origin}, ${Y}${_.minimum.toString()} ${O.unit} sahip olmalyd.`;
        return `Fazla kk: ${_.origin}, ${Y}${_.minimum.toString()} olmalyd.`;
      }
      case "invalid_format": {
        let Y = _;
        if (Y.format === "starts_with") return `Fsit metin: "${Y.prefix}" ile balamal.`;
        if (Y.format === "ends_with") return `Fsit metin: "${Y.suffix}" ile bitmeli.`;
        if (Y.format === "includes") return `Fsit metin: "${Y.includes}" ihtiv etmeli.`;
        if (Y.format === "regex") return `Fsit metin: ${Y.pattern} nakna uymal.`;
        return `Fsit ${P[Y.format] ?? _.format}`;
      }
      case "not_multiple_of":
        return `Fsit say: ${_.divisor} kat olmalyd.`;
      case "unrecognized_keys":
        return `Tannmayan anahtar ${_.keys.length > 1 ? "s" : ""}: ${T$(_.keys, ", ")}`;
      case "invalid_key":
        return `${_.origin} iin tannmayan anahtar var.`;
      case "invalid_union":
        return "Giren tannamad.";
      case "invalid_element":
        return `${_.origin} iin tannmayan kymet var.`;
      default:
        return "Kymet tannamad.";
    }
  };
};
function h3() {
  return { localeError: mD() };
}
var dD = () => {
  let $18 = { string: { unit: "", verb: "" }, file: { unit: "", verb: "" }, array: { unit: "", verb: "" }, set: { unit: "", verb: "" } };
  function q(_) {
    return $18[_] ?? null;
  }
  let K = (_) => {
    let Y = typeof _;
    switch (Y) {
      case "number":
        return Number.isNaN(_) ? "NaN" : "";
      case "object": {
        if (Array.isArray(_)) return "";
        if (_ === null) return "null";
        if (Object.getPrototypeOf(_) !== Object.prototype && _.constructor) return _.constructor.name;
      }
    }
    return Y;
  }, P = { regex: "", email: "", url: "  ", emoji: "", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "  ", date: "", time: "", duration: "", ipv4: " IPv4 ", ipv6: " IPv6 ", cidrv4: " IPv4 ", cidrv6: " IPv6 ", base64: "base64-encoded ", base64url: "base64url-encoded ", json_string: "JSON ", e164: " E.164 ", jwt: "JWT", template_literal: "" };
  return (_) => {
    switch (_.code) {
      case "invalid_type":
        return ` :  ${_.expected} ,  ${K(_.input)}  `;
      case "invalid_value":
        if (_.values.length === 1) return ` :  ${m$(_.values[0])} `;
        return ` :    ${T$(_.values, "|")}  `;
      case "too_big": {
        let Y = _.inclusive ? "<=" : "<", O = q(_.origin);
        if (O) return ` : ${_.origin ?? ""}  ${Y}${_.maximum.toString()} ${O.unit ?? ""} `;
        return ` : ${_.origin ?? ""}  ${Y}${_.maximum.toString()} `;
      }
      case "too_small": {
        let Y = _.inclusive ? ">=" : ">", O = q(_.origin);
        if (O) return ` : ${_.origin}  ${Y}${_.minimum.toString()} ${O.unit} `;
        return ` : ${_.origin}  ${Y}${_.minimum.toString()} `;
      }
      case "invalid_format": {
        let Y = _;
        if (Y.format === "starts_with") return ` :   "${Y.prefix}"   `;
        if (Y.format === "ends_with") return ` :   "${Y.suffix}"    `;
        if (Y.format === "includes") return ` :  "${Y.includes}" `;
        if (Y.format === "regex") return ` :   ${Y.pattern}   `;
        return `${P[Y.format] ?? _.format}  `;
      }
      case "not_multiple_of":
        return ` :   ${_.divisor}  `;
      case "unrecognized_keys":
        return ` ${_.keys.length > 1 ? "" : ""}: ${T$(_.keys, ", ")}`;
      case "invalid_key":
        return `   ${_.origin} `;
      case "invalid_union":
        return " ";
      case "invalid_element":
        return `   ${_.origin} `;
      default:
        return " ";
    }
  };
};
function R3() {
  return { localeError: dD() };
}
var lD = () => {
  let $18 = { string: { unit: "znakw", verb: "mie" }, file: { unit: "bajtw", verb: "mie" }, array: { unit: "elementw", verb: "mie" }, set: { unit: "elementw", verb: "mie" } };
  function q(_) {
    return $18[_] ?? null;
  }
  let K = (_) => {
    let Y = typeof _;
    switch (Y) {
      case "number":
        return Number.isNaN(_) ? "NaN" : "liczba";
      case "object": {
        if (Array.isArray(_)) return "tablica";
        if (_ === null) return "null";
        if (Object.getPrototypeOf(_) !== Object.prototype && _.constructor) return _.constructor.name;
      }
    }
    return Y;
  }, P = { regex: "wyraenie", email: "adres email", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "data i godzina w formacie ISO", date: "data w formacie ISO", time: "godzina w formacie ISO", duration: "czas trwania ISO", ipv4: "adres IPv4", ipv6: "adres IPv6", cidrv4: "zakres IPv4", cidrv6: "zakres IPv6", base64: "cig znakw zakodowany w formacie base64", base64url: "cig znakw zakodowany w formacie base64url", json_string: "cig znakw w formacie JSON", e164: "liczba E.164", jwt: "JWT", template_literal: "wejcie" };
  return (_) => {
    switch (_.code) {
      case "invalid_type":
        return `Nieprawidowe dane wejciowe: oczekiwano ${_.expected}, otrzymano ${K(_.input)}`;
      case "invalid_value":
        if (_.values.length === 1) return `Nieprawidowe dane wejciowe: oczekiwano ${m$(_.values[0])}`;
        return `Nieprawidowa opcja: oczekiwano jednej z wartoci ${T$(_.values, "|")}`;
      case "too_big": {
        let Y = _.inclusive ? "<=" : "<", O = q(_.origin);
        if (O) return `Za dua warto: oczekiwano, e ${_.origin ?? "warto"} bdzie mie ${Y}${_.maximum.toString()} ${O.unit ?? "elementw"}`;
        return `Zbyt du(y/a/e): oczekiwano, e ${_.origin ?? "warto"} bdzie wynosi ${Y}${_.maximum.toString()}`;
      }
      case "too_small": {
        let Y = _.inclusive ? ">=" : ">", O = q(_.origin);
        if (O) return `Za maa warto: oczekiwano, e ${_.origin ?? "warto"} bdzie mie ${Y}${_.minimum.toString()} ${O.unit ?? "elementw"}`;
        return `Zbyt ma(y/a/e): oczekiwano, e ${_.origin ?? "warto"} bdzie wynosi ${Y}${_.minimum.toString()}`;
      }
      case "invalid_format": {
        let Y = _;
        if (Y.format === "starts_with") return `Nieprawidowy cig znakw: musi zaczyna si od "${Y.prefix}"`;
        if (Y.format === "ends_with") return `Nieprawidowy cig znakw: musi koczy si na "${Y.suffix}"`;
        if (Y.format === "includes") return `Nieprawidowy cig znakw: musi zawiera "${Y.includes}"`;
        if (Y.format === "regex") return `Nieprawidowy cig znakw: musi odpowiada wzorcowi ${Y.pattern}`;
        return `Nieprawidow(y/a/e) ${P[Y.format] ?? _.format}`;
      }
      case "not_multiple_of":
        return `Nieprawidowa liczba: musi by wielokrotnoci ${_.divisor}`;
      case "unrecognized_keys":
        return `Nierozpoznane klucze${_.keys.length > 1 ? "s" : ""}: ${T$(_.keys, ", ")}`;
      case "invalid_key":
        return `Nieprawidowy klucz w ${_.origin}`;
      case "invalid_union":
        return "Nieprawidowe dane wejciowe";
      case "invalid_element":
        return `Nieprawidowa warto w ${_.origin}`;
      default:
        return "Nieprawidowe dane wejciowe";
    }
  };
};
function I3() {
  return { localeError: lD() };
}
var rD = () => {
  let $18 = { string: { unit: "caracteres", verb: "ter" }, file: { unit: "bytes", verb: "ter" }, array: { unit: "itens", verb: "ter" }, set: { unit: "itens", verb: "ter" } };
  function q(_) {
    return $18[_] ?? null;
  }
  let K = (_) => {
    let Y = typeof _;
    switch (Y) {
      case "number":
        return Number.isNaN(_) ? "NaN" : "nmero";
      case "object": {
        if (Array.isArray(_)) return "array";
        if (_ === null) return "nulo";
        if (Object.getPrototypeOf(_) !== Object.prototype && _.constructor) return _.constructor.name;
      }
    }
    return Y;
  }, P = { regex: "padro", email: "endereo de e-mail", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "data e hora ISO", date: "data ISO", time: "hora ISO", duration: "durao ISO", ipv4: "endereo IPv4", ipv6: "endereo IPv6", cidrv4: "faixa de IPv4", cidrv6: "faixa de IPv6", base64: "texto codificado em base64", base64url: "URL codificada em base64", json_string: "texto JSON", e164: "nmero E.164", jwt: "JWT", template_literal: "entrada" };
  return (_) => {
    switch (_.code) {
      case "invalid_type":
        return `Tipo invlido: esperado ${_.expected}, recebido ${K(_.input)}`;
      case "invalid_value":
        if (_.values.length === 1) return `Entrada invlida: esperado ${m$(_.values[0])}`;
        return `Opo invlida: esperada uma das ${T$(_.values, "|")}`;
      case "too_big": {
        let Y = _.inclusive ? "<=" : "<", O = q(_.origin);
        if (O) return `Muito grande: esperado que ${_.origin ?? "valor"} tivesse ${Y}${_.maximum.toString()} ${O.unit ?? "elementos"}`;
        return `Muito grande: esperado que ${_.origin ?? "valor"} fosse ${Y}${_.maximum.toString()}`;
      }
      case "too_small": {
        let Y = _.inclusive ? ">=" : ">", O = q(_.origin);
        if (O) return `Muito pequeno: esperado que ${_.origin} tivesse ${Y}${_.minimum.toString()} ${O.unit}`;
        return `Muito pequeno: esperado que ${_.origin} fosse ${Y}${_.minimum.toString()}`;
      }
      case "invalid_format": {
        let Y = _;
        if (Y.format === "starts_with") return `Texto invlido: deve comear com "${Y.prefix}"`;
        if (Y.format === "ends_with") return `Texto invlido: deve terminar com "${Y.suffix}"`;
        if (Y.format === "includes") return `Texto invlido: deve incluir "${Y.includes}"`;
        if (Y.format === "regex") return `Texto invlido: deve corresponder ao padro ${Y.pattern}`;
        return `${P[Y.format] ?? _.format} invlido`;
      }
      case "not_multiple_of":
        return `Nmero invlido: deve ser mltiplo de ${_.divisor}`;
      case "unrecognized_keys":
        return `Chave${_.keys.length > 1 ? "s" : ""} desconhecida${_.keys.length > 1 ? "s" : ""}: ${T$(_.keys, ", ")}`;
      case "invalid_key":
        return `Chave invlida em ${_.origin}`;
      case "invalid_union":
        return "Entrada invlida";
      case "invalid_element":
        return `Valor invlido em ${_.origin}`;
      default:
        return "Campo invlido";
    }
  };
};
function D3() {
  return { localeError: rD() };
}
function _A($18, q, K, P) {
  let _ = Math.abs($18), Y = _ % 10, O = _ % 100;
  if (O >= 11 && O <= 19) return P;
  if (Y === 1) return q;
  if (Y >= 2 && Y <= 4) return K;
  return P;
}
var oD = () => {
  let $18 = { string: { unit: { one: "", few: "", many: "" }, verb: "" }, file: { unit: { one: "", few: "", many: "" }, verb: "" }, array: { unit: { one: "", few: "", many: "" }, verb: "" }, set: { unit: { one: "", few: "", many: "" }, verb: "" } };
  function q(_) {
    return $18[_] ?? null;
  }
  let K = (_) => {
    let Y = typeof _;
    switch (Y) {
      case "number":
        return Number.isNaN(_) ? "NaN" : "";
      case "object": {
        if (Array.isArray(_)) return "";
        if (_ === null) return "null";
        if (Object.getPrototypeOf(_) !== Object.prototype && _.constructor) return _.constructor.name;
      }
    }
    return Y;
  }, P = { regex: "", email: "email ", url: "URL", emoji: "", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO   ", date: "ISO ", time: "ISO ", duration: "ISO ", ipv4: "IPv4 ", ipv6: "IPv6 ", cidrv4: "IPv4 ", cidrv6: "IPv6 ", base64: "   base64", base64url: "   base64url", json_string: "JSON ", e164: " E.164", jwt: "JWT", template_literal: "" };
  return (_) => {
    switch (_.code) {
      case "invalid_type":
        return ` :  ${_.expected},  ${K(_.input)}`;
      case "invalid_value":
        if (_.values.length === 1) return ` :  ${m$(_.values[0])}`;
        return ` :    ${T$(_.values, "|")}`;
      case "too_big": {
        let Y = _.inclusive ? "<=" : "<", O = q(_.origin);
        if (O) {
          let z = Number(_.maximum), J = _A(z, O.unit.one, O.unit.few, O.unit.many);
          return `  : ,  ${_.origin ?? ""}   ${Y}${_.maximum.toString()} ${J}`;
        }
        return `  : ,  ${_.origin ?? ""}  ${Y}${_.maximum.toString()}`;
      }
      case "too_small": {
        let Y = _.inclusive ? ">=" : ">", O = q(_.origin);
        if (O) {
          let z = Number(_.minimum), J = _A(z, O.unit.one, O.unit.few, O.unit.many);
          return `  : ,  ${_.origin}   ${Y}${_.minimum.toString()} ${J}`;
        }
        return `  : ,  ${_.origin}  ${Y}${_.minimum.toString()}`;
      }
      case "invalid_format": {
        let Y = _;
        if (Y.format === "starts_with") return ` :    "${Y.prefix}"`;
        if (Y.format === "ends_with") return ` :    "${Y.suffix}"`;
        if (Y.format === "includes") return ` :   "${Y.includes}"`;
        if (Y.format === "regex") return ` :    ${Y.pattern}`;
        return ` ${P[Y.format] ?? _.format}`;
      }
      case "not_multiple_of":
        return ` :    ${_.divisor}`;
      case "unrecognized_keys":
        return `${_.keys.length > 1 ? "" : ""} ${_.keys.length > 1 ? "" : ""}: ${T$(_.keys, ", ")}`;
      case "invalid_key":
        return `   ${_.origin}`;
      case "invalid_union":
        return "  ";
      case "invalid_element":
        return `   ${_.origin}`;
      default:
        return "  ";
    }
  };
};
function L3() {
  return { localeError: oD() };
}
var nD = () => {
  let $18 = { string: { unit: "znakov", verb: "imeti" }, file: { unit: "bajtov", verb: "imeti" }, array: { unit: "elementov", verb: "imeti" }, set: { unit: "elementov", verb: "imeti" } };
  function q(_) {
    return $18[_] ?? null;
  }
  let K = (_) => {
    let Y = typeof _;
    switch (Y) {
      case "number":
        return Number.isNaN(_) ? "NaN" : "tevilo";
      case "object": {
        if (Array.isArray(_)) return "tabela";
        if (_ === null) return "null";
        if (Object.getPrototypeOf(_) !== Object.prototype && _.constructor) return _.constructor.name;
      }
    }
    return Y;
  }, P = { regex: "vnos", email: "e-potni naslov", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO datum in as", date: "ISO datum", time: "ISO as", duration: "ISO trajanje", ipv4: "IPv4 naslov", ipv6: "IPv6 naslov", cidrv4: "obseg IPv4", cidrv6: "obseg IPv6", base64: "base64 kodiran niz", base64url: "base64url kodiran niz", json_string: "JSON niz", e164: "E.164 tevilka", jwt: "JWT", template_literal: "vnos" };
  return (_) => {
    switch (_.code) {
      case "invalid_type":
        return `Neveljaven vnos: priakovano ${_.expected}, prejeto ${K(_.input)}`;
      case "invalid_value":
        if (_.values.length === 1) return `Neveljaven vnos: priakovano ${m$(_.values[0])}`;
        return `Neveljavna monost: priakovano eno izmed ${T$(_.values, "|")}`;
      case "too_big": {
        let Y = _.inclusive ? "<=" : "<", O = q(_.origin);
        if (O) return `Preveliko: priakovano, da bo ${_.origin ?? "vrednost"} imelo ${Y}${_.maximum.toString()} ${O.unit ?? "elementov"}`;
        return `Preveliko: priakovano, da bo ${_.origin ?? "vrednost"} ${Y}${_.maximum.toString()}`;
      }
      case "too_small": {
        let Y = _.inclusive ? ">=" : ">", O = q(_.origin);
        if (O) return `Premajhno: priakovano, da bo ${_.origin} imelo ${Y}${_.minimum.toString()} ${O.unit}`;
        return `Premajhno: priakovano, da bo ${_.origin} ${Y}${_.minimum.toString()}`;
      }
      case "invalid_format": {
        let Y = _;
        if (Y.format === "starts_with") return `Neveljaven niz: mora se zaeti z "${Y.prefix}"`;
        if (Y.format === "ends_with") return `Neveljaven niz: mora se konati z "${Y.suffix}"`;
        if (Y.format === "includes") return `Neveljaven niz: mora vsebovati "${Y.includes}"`;
        if (Y.format === "regex") return `Neveljaven niz: mora ustrezati vzorcu ${Y.pattern}`;
        return `Neveljaven ${P[Y.format] ?? _.format}`;
      }
      case "not_multiple_of":
        return `Neveljavno tevilo: mora biti vekratnik ${_.divisor}`;
      case "unrecognized_keys":
        return `Neprepoznan${_.keys.length > 1 ? "i kljui" : " klju"}: ${T$(_.keys, ", ")}`;
      case "invalid_key":
        return `Neveljaven klju v ${_.origin}`;
      case "invalid_union":
        return "Neveljaven vnos";
      case "invalid_element":
        return `Neveljavna vrednost v ${_.origin}`;
      default:
        return "Neveljaven vnos";
    }
  };
};
function g3() {
  return { localeError: nD() };
}
var iD = () => {
  let $18 = { string: { unit: "tecken", verb: "att ha" }, file: { unit: "bytes", verb: "att ha" }, array: { unit: "objekt", verb: "att innehlla" }, set: { unit: "objekt", verb: "att innehlla" } };
  function q(_) {
    return $18[_] ?? null;
  }
  let K = (_) => {
    let Y = typeof _;
    switch (Y) {
      case "number":
        return Number.isNaN(_) ? "NaN" : "antal";
      case "object": {
        if (Array.isArray(_)) return "lista";
        if (_ === null) return "null";
        if (Object.getPrototypeOf(_) !== Object.prototype && _.constructor) return _.constructor.name;
      }
    }
    return Y;
  }, P = { regex: "reguljrt uttryck", email: "e-postadress", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO-datum och tid", date: "ISO-datum", time: "ISO-tid", duration: "ISO-varaktighet", ipv4: "IPv4-intervall", ipv6: "IPv6-intervall", cidrv4: "IPv4-spektrum", cidrv6: "IPv6-spektrum", base64: "base64-kodad strng", base64url: "base64url-kodad strng", json_string: "JSON-strng", e164: "E.164-nummer", jwt: "JWT", template_literal: "mall-literal" };
  return (_) => {
    switch (_.code) {
      case "invalid_type":
        return `Ogiltig inmatning: frvntat ${_.expected}, fick ${K(_.input)}`;
      case "invalid_value":
        if (_.values.length === 1) return `Ogiltig inmatning: frvntat ${m$(_.values[0])}`;
        return `Ogiltigt val: frvntade en av ${T$(_.values, "|")}`;
      case "too_big": {
        let Y = _.inclusive ? "<=" : "<", O = q(_.origin);
        if (O) return `Fr stor(t): frvntade ${_.origin ?? "vrdet"} att ha ${Y}${_.maximum.toString()} ${O.unit ?? "element"}`;
        return `Fr stor(t): frvntat ${_.origin ?? "vrdet"} att ha ${Y}${_.maximum.toString()}`;
      }
      case "too_small": {
        let Y = _.inclusive ? ">=" : ">", O = q(_.origin);
        if (O) return `Fr lite(t): frvntade ${_.origin ?? "vrdet"} att ha ${Y}${_.minimum.toString()} ${O.unit}`;
        return `Fr lite(t): frvntade ${_.origin ?? "vrdet"} att ha ${Y}${_.minimum.toString()}`;
      }
      case "invalid_format": {
        let Y = _;
        if (Y.format === "starts_with") return `Ogiltig strng: mste brja med "${Y.prefix}"`;
        if (Y.format === "ends_with") return `Ogiltig strng: mste sluta med "${Y.suffix}"`;
        if (Y.format === "includes") return `Ogiltig strng: mste innehlla "${Y.includes}"`;
        if (Y.format === "regex") return `Ogiltig strng: mste matcha mnstret "${Y.pattern}"`;
        return `Ogiltig(t) ${P[Y.format] ?? _.format}`;
      }
      case "not_multiple_of":
        return `Ogiltigt tal: mste vara en multipel av ${_.divisor}`;
      case "unrecognized_keys":
        return `${_.keys.length > 1 ? "Oknda nycklar" : "Oknd nyckel"}: ${T$(_.keys, ", ")}`;
      case "invalid_key":
        return `Ogiltig nyckel i ${_.origin ?? "vrdet"}`;
      case "invalid_union":
        return "Ogiltig input";
      case "invalid_element":
        return `Ogiltigt vrde i ${_.origin ?? "vrdet"}`;
      default:
        return "Ogiltig input";
    }
  };
};
function b3() {
  return { localeError: iD() };
}
var BD = () => {
  let $18 = { string: { unit: "", verb: " " }, file: { unit: "", verb: " " }, array: { unit: "", verb: " " }, set: { unit: "", verb: " " } };
  function q(_) {
    return $18[_] ?? null;
  }
  let K = (_) => {
    let Y = typeof _;
    switch (Y) {
      case "number":
        return Number.isNaN(_) ? " " : "";
      case "object": {
        if (Array.isArray(_)) return "";
        if (_ === null) return "";
        if (Object.getPrototypeOf(_) !== Object.prototype && _.constructor) return _.constructor.name;
      }
    }
    return Y;
  }, P = { regex: "", email: " ", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO  ", date: "ISO ", time: "ISO ", duration: "ISO  ", ipv4: "IPv4 ", ipv6: "IPv6 ", cidrv4: "IPv4 ", cidrv6: "IPv6 ", base64: "base64-encoded ", base64url: "base64url-encoded ", json_string: "JSON ", e164: "E.164 ", jwt: "JWT", template_literal: "input" };
  return (_) => {
    switch (_.code) {
      case "invalid_type":
        return ` :  ${_.expected},  ${K(_.input)}`;
      case "invalid_value":
        if (_.values.length === 1) return ` :  ${m$(_.values[0])}`;
        return ` :  ${T$(_.values, "|")}  `;
      case "too_big": {
        let Y = _.inclusive ? "<=" : "<", O = q(_.origin);
        if (O) return ` :  ${_.origin ?? ""} ${Y}${_.maximum.toString()} ${O.unit ?? ""}   `;
        return ` :  ${_.origin ?? ""} ${Y}${_.maximum.toString()}   `;
      }
      case "too_small": {
        let Y = _.inclusive ? ">=" : ">", O = q(_.origin);
        if (O) return ` :  ${_.origin} ${Y}${_.minimum.toString()} ${O.unit}   `;
        return ` :  ${_.origin} ${Y}${_.minimum.toString()}   `;
      }
      case "invalid_format": {
        let Y = _;
        if (Y.format === "starts_with") return ` : "${Y.prefix}"   `;
        if (Y.format === "ends_with") return ` : "${Y.suffix}"   `;
        if (Y.format === "includes") return ` : "${Y.includes}"   `;
        if (Y.format === "regex") return ` : ${Y.pattern}   `;
        return ` ${P[Y.format] ?? _.format}`;
      }
      case "not_multiple_of":
        return ` : ${_.divisor}    `;
      case "unrecognized_keys":
        return `  ${_.keys.length > 1 ? "" : ""}: ${T$(_.keys, ", ")}`;
      case "invalid_key":
        return `${_.origin}   `;
      case "invalid_union":
        return " ";
      case "invalid_element":
        return `${_.origin}   `;
      default:
        return " ";
    }
  };
};
function y3() {
  return { localeError: BD() };
}
var tD = () => {
  let $18 = { string: { unit: "", verb: "" }, file: { unit: "", verb: "" }, array: { unit: "", verb: "" }, set: { unit: "", verb: "" } };
  function q(_) {
    return $18[_] ?? null;
  }
  let K = (_) => {
    let Y = typeof _;
    switch (Y) {
      case "number":
        return Number.isNaN(_) ? " (NaN)" : "";
      case "object": {
        if (Array.isArray(_)) return " (Array)";
        if (_ === null) return " (null)";
        if (Object.getPrototypeOf(_) !== Object.prototype && _.constructor) return _.constructor.name;
      }
    }
    return Y;
  }, P = { regex: "", email: "", url: "URL", emoji: "", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: " ISO", date: " ISO", time: " ISO", duration: " ISO", ipv4: " IPv4", ipv6: " IPv6", cidrv4: " IP  IPv4", cidrv6: " IP  IPv6", base64: " Base64", base64url: " Base64  URL", json_string: " JSON", e164: " (E.164)", jwt: " JWT", template_literal: "" };
  return (_) => {
    switch (_.code) {
      case "invalid_type":
        return `:  ${_.expected}  ${K(_.input)}`;
      case "invalid_value":
        if (_.values.length === 1) return `:  ${m$(_.values[0])}`;
        return `:  ${T$(_.values, "|")}`;
      case "too_big": {
        let Y = _.inclusive ? "" : "", O = q(_.origin);
        if (O) return `: ${_.origin ?? ""} ${Y} ${_.maximum.toString()} ${O.unit ?? ""}`;
        return `: ${_.origin ?? ""} ${Y} ${_.maximum.toString()}`;
      }
      case "too_small": {
        let Y = _.inclusive ? "" : "", O = q(_.origin);
        if (O) return `: ${_.origin} ${Y} ${_.minimum.toString()} ${O.unit}`;
        return `: ${_.origin} ${Y} ${_.minimum.toString()}`;
      }
      case "invalid_format": {
        let Y = _;
        if (Y.format === "starts_with") return `:  "${Y.prefix}"`;
        if (Y.format === "ends_with") return `:  "${Y.suffix}"`;
        if (Y.format === "includes") return `:  "${Y.includes}" `;
        if (Y.format === "regex") return `:  ${Y.pattern}`;
        return `: ${P[Y.format] ?? _.format}`;
      }
      case "not_multiple_of":
        return `:  ${_.divisor} `;
      case "unrecognized_keys":
        return `: ${T$(_.keys, ", ")}`;
      case "invalid_key":
        return ` ${_.origin}`;
      case "invalid_union":
        return ": ";
      case "invalid_element":
        return ` ${_.origin}`;
      default:
        return "";
    }
  };
};
function u3() {
  return { localeError: tD() };
}
var UD = ($18) => {
  let q = typeof $18;
  switch (q) {
    case "number":
      return Number.isNaN($18) ? "NaN" : "number";
    case "object": {
      if (Array.isArray($18)) return "array";
      if ($18 === null) return "null";
      if (Object.getPrototypeOf($18) !== Object.prototype && $18.constructor) return $18.constructor.name;
    }
  }
  return q;
};
var FD = () => {
  let $18 = { string: { unit: "karakter", verb: "olmal" }, file: { unit: "bayt", verb: "olmal" }, array: { unit: "e", verb: "olmal" }, set: { unit: "e", verb: "olmal" } };
  function q(P) {
    return $18[P] ?? null;
  }
  let K = { regex: "girdi", email: "e-posta adresi", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO tarih ve saat", date: "ISO tarih", time: "ISO saat", duration: "ISO sre", ipv4: "IPv4 adresi", ipv6: "IPv6 adresi", cidrv4: "IPv4 aral", cidrv6: "IPv6 aral", base64: "base64 ile ifrelenmi metin", base64url: "base64url ile ifrelenmi metin", json_string: "JSON dizesi", e164: "E.164 says", jwt: "JWT", template_literal: "ablon dizesi" };
  return (P) => {
    switch (P.code) {
      case "invalid_type":
        return `Geersiz deer: beklenen ${P.expected}, alnan ${UD(P.input)}`;
      case "invalid_value":
        if (P.values.length === 1) return `Geersiz deer: beklenen ${m$(P.values[0])}`;
        return `Geersiz seenek: aadakilerden biri olmal: ${T$(P.values, "|")}`;
      case "too_big": {
        let _ = P.inclusive ? "<=" : "<", Y = q(P.origin);
        if (Y) return `ok byk: beklenen ${P.origin ?? "deer"} ${_}${P.maximum.toString()} ${Y.unit ?? "e"}`;
        return `ok byk: beklenen ${P.origin ?? "deer"} ${_}${P.maximum.toString()}`;
      }
      case "too_small": {
        let _ = P.inclusive ? ">=" : ">", Y = q(P.origin);
        if (Y) return `ok kk: beklenen ${P.origin} ${_}${P.minimum.toString()} ${Y.unit}`;
        return `ok kk: beklenen ${P.origin} ${_}${P.minimum.toString()}`;
      }
      case "invalid_format": {
        let _ = P;
        if (_.format === "starts_with") return `Geersiz metin: "${_.prefix}" ile balamal`;
        if (_.format === "ends_with") return `Geersiz metin: "${_.suffix}" ile bitmeli`;
        if (_.format === "includes") return `Geersiz metin: "${_.includes}" iermeli`;
        if (_.format === "regex") return `Geersiz metin: ${_.pattern} desenine uymal`;
        return `Geersiz ${K[_.format] ?? P.format}`;
      }
      case "not_multiple_of":
        return `Geersiz say: ${P.divisor} ile tam blnebilmeli`;
      case "unrecognized_keys":
        return `Tannmayan anahtar${P.keys.length > 1 ? "lar" : ""}: ${T$(P.keys, ", ")}`;
      case "invalid_key":
        return `${P.origin} iinde geersiz anahtar`;
      case "invalid_union":
        return "Geersiz deer";
      case "invalid_element":
        return `${P.origin} iinde geersiz deer`;
      default:
        return "Geersiz deer";
    }
  };
};
function x3() {
  return { localeError: FD() };
}
var aD = () => {
  let $18 = { string: { unit: "", verb: "" }, file: { unit: "", verb: "" }, array: { unit: "", verb: "" }, set: { unit: "", verb: "" } };
  function q(_) {
    return $18[_] ?? null;
  }
  let K = (_) => {
    let Y = typeof _;
    switch (Y) {
      case "number":
        return Number.isNaN(_) ? "NaN" : "";
      case "object": {
        if (Array.isArray(_)) return "";
        if (_ === null) return "null";
        if (Object.getPrototypeOf(_) !== Object.prototype && _.constructor) return _.constructor.name;
      }
    }
    return Y;
  }, P = { regex: " ", email: "  ", url: "URL", emoji: "", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "   ISO", date: " ISO", time: " ISO", duration: " ISO", ipv4: " IPv4", ipv6: " IPv6", cidrv4: " IPv4", cidrv6: " IPv6", base64: "   base64", base64url: "   base64url", json_string: " JSON", e164: " E.164", jwt: "JWT", template_literal: " " };
  return (_) => {
    switch (_.code) {
      case "invalid_type":
        return `  :  ${_.expected},  ${K(_.input)}`;
      case "invalid_value":
        if (_.values.length === 1) return `  :  ${m$(_.values[0])}`;
        return ` :    ${T$(_.values, "|")}`;
      case "too_big": {
        let Y = _.inclusive ? "<=" : "<", O = q(_.origin);
        if (O) return ` : ,  ${_.origin ?? ""} ${O.verb} ${Y}${_.maximum.toString()} ${O.unit ?? ""}`;
        return ` : ,  ${_.origin ?? ""}  ${Y}${_.maximum.toString()}`;
      }
      case "too_small": {
        let Y = _.inclusive ? ">=" : ">", O = q(_.origin);
        if (O) return ` : ,  ${_.origin} ${O.verb} ${Y}${_.minimum.toString()} ${O.unit}`;
        return ` : ,  ${_.origin}  ${Y}${_.minimum.toString()}`;
      }
      case "invalid_format": {
        let Y = _;
        if (Y.format === "starts_with") return ` :    "${Y.prefix}"`;
        if (Y.format === "ends_with") return ` :    "${Y.suffix}"`;
        if (Y.format === "includes") return ` :   "${Y.includes}"`;
        if (Y.format === "regex") return ` :    ${Y.pattern}`;
        return ` ${P[Y.format] ?? _.format}`;
      }
      case "not_multiple_of":
        return ` :    ${_.divisor}`;
      case "unrecognized_keys":
        return ` ${_.keys.length > 1 ? "" : ""}: ${T$(_.keys, ", ")}`;
      case "invalid_key":
        return `   ${_.origin}`;
      case "invalid_union":
        return "  ";
      case "invalid_element":
        return `   ${_.origin}`;
      default:
        return "  ";
    }
  };
};
function BP() {
  return { localeError: aD() };
}
function p3() {
  return BP();
}
var QD = () => {
  let $18 = { string: { unit: "", verb: "" }, file: { unit: "", verb: "" }, array: { unit: "", verb: "" }, set: { unit: "", verb: "" } };
  function q(_) {
    return $18[_] ?? null;
  }
  let K = (_) => {
    let Y = typeof _;
    switch (Y) {
      case "number":
        return Number.isNaN(_) ? "NaN" : "";
      case "object": {
        if (Array.isArray(_)) return "";
        if (_ === null) return "";
        if (Object.getPrototypeOf(_) !== Object.prototype && _.constructor) return _.constructor.name;
      }
    }
    return Y;
  }, P = { regex: " ", email: "  ", url: "  ", emoji: "", uuid: "   ", uuidv4: "     4", uuidv6: "     6", nanoid: "  ", guid: "   ", cuid: "   ", cuid2: "    2", ulid: "   ", xid: "  ", ksuid: "    ", datetime: "    ", date: "   ", time: "   ", duration: "   ", ipv4: "   4 ", ipv6: "   6 ", cidrv4: "   4 ", cidrv6: "   6 ", base64: " 64   ", base64url: " 64      ", json_string: "    ", e164: " 164 ", jwt: "  ", template_literal: " " };
  return (_) => {
    switch (_.code) {
      case "invalid_type":
        return `  : ${_.expected}   ${K(_.input)}  `;
      case "invalid_value":
        if (_.values.length === 1) return `  : ${m$(_.values[0])}  `;
        return ` : ${T$(_.values, "|")}     `;
      case "too_big": {
        let Y = _.inclusive ? "<=" : "<", O = q(_.origin);
        if (O) return ` : ${_.origin ?? ""}  ${Y}${_.maximum.toString()} ${O.unit ?? ""}   `;
        return ` : ${_.origin ?? ""}  ${Y}${_.maximum.toString()}   `;
      }
      case "too_small": {
        let Y = _.inclusive ? ">=" : ">", O = q(_.origin);
        if (O) return ` : ${_.origin}  ${Y}${_.minimum.toString()} ${O.unit}   `;
        return ` : ${_.origin}  ${Y}${_.minimum.toString()}   `;
      }
      case "invalid_format": {
        let Y = _;
        if (Y.format === "starts_with") return ` : "${Y.prefix}"    `;
        if (Y.format === "ends_with") return ` : "${Y.suffix}"    `;
        if (Y.format === "includes") return ` : "${Y.includes}"   `;
        if (Y.format === "regex") return ` :  ${Y.pattern}    `;
        return ` ${P[Y.format] ?? _.format}`;
      }
      case "not_multiple_of":
        return ` : ${_.divisor}    `;
      case "unrecognized_keys":
        return `   ${_.keys.length > 1 ? "" : ""}: ${T$(_.keys, " ")}`;
      case "invalid_key":
        return `${_.origin}   `;
      case "invalid_union":
        return "  ";
      case "invalid_element":
        return `${_.origin}   `;
      default:
        return "  ";
    }
  };
};
function c3() {
  return { localeError: QD() };
}
var eD = () => {
  let $18 = { string: { unit: "k t", verb: "c" }, file: { unit: "byte", verb: "c" }, array: { unit: "phn t", verb: "c" }, set: { unit: "phn t", verb: "c" } };
  function q(_) {
    return $18[_] ?? null;
  }
  let K = (_) => {
    let Y = typeof _;
    switch (Y) {
      case "number":
        return Number.isNaN(_) ? "NaN" : "s";
      case "object": {
        if (Array.isArray(_)) return "mng";
        if (_ === null) return "null";
        if (Object.getPrototypeOf(_) !== Object.prototype && _.constructor) return _.constructor.name;
      }
    }
    return Y;
  }, P = { regex: "u vo", email: "a ch email", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ngy gi ISO", date: "ngy ISO", time: "gi ISO", duration: "khong thi gian ISO", ipv4: "a ch IPv4", ipv6: "a ch IPv6", cidrv4: "di IPv4", cidrv6: "di IPv6", base64: "chui m ha base64", base64url: "chui m ha base64url", json_string: "chui JSON", e164: "s E.164", jwt: "JWT", template_literal: "u vo" };
  return (_) => {
    switch (_.code) {
      case "invalid_type":
        return `u vo khng hp l: mong i ${_.expected}, nhn c ${K(_.input)}`;
      case "invalid_value":
        if (_.values.length === 1) return `u vo khng hp l: mong i ${m$(_.values[0])}`;
        return `Ty chn khng hp l: mong i mt trong cc gi tr ${T$(_.values, "|")}`;
      case "too_big": {
        let Y = _.inclusive ? "<=" : "<", O = q(_.origin);
        if (O) return `Qu ln: mong i ${_.origin ?? "gi tr"} ${O.verb} ${Y}${_.maximum.toString()} ${O.unit ?? "phn t"}`;
        return `Qu ln: mong i ${_.origin ?? "gi tr"} ${Y}${_.maximum.toString()}`;
      }
      case "too_small": {
        let Y = _.inclusive ? ">=" : ">", O = q(_.origin);
        if (O) return `Qu nh: mong i ${_.origin} ${O.verb} ${Y}${_.minimum.toString()} ${O.unit}`;
        return `Qu nh: mong i ${_.origin} ${Y}${_.minimum.toString()}`;
      }
      case "invalid_format": {
        let Y = _;
        if (Y.format === "starts_with") return `Chui khng hp l: phi bt u bng "${Y.prefix}"`;
        if (Y.format === "ends_with") return `Chui khng hp l: phi kt thc bng "${Y.suffix}"`;
        if (Y.format === "includes") return `Chui khng hp l: phi bao gm "${Y.includes}"`;
        if (Y.format === "regex") return `Chui khng hp l: phi khp vi mu ${Y.pattern}`;
        return `${P[Y.format] ?? _.format} khng hp l`;
      }
      case "not_multiple_of":
        return `S khng hp l: phi l bi s ca ${_.divisor}`;
      case "unrecognized_keys":
        return `Kha khng c nhn dng: ${T$(_.keys, ", ")}`;
      case "invalid_key":
        return `Kha khng hp l trong ${_.origin}`;
      case "invalid_union":
        return "u vo khng hp l";
      case "invalid_element":
        return `Gi tr khng hp l trong ${_.origin}`;
      default:
        return "u vo khng hp l";
    }
  };
};
function m3() {
  return { localeError: eD() };
}
var sD = () => {
  let $18 = { string: { unit: "", verb: "" }, file: { unit: "", verb: "" }, array: { unit: "", verb: "" }, set: { unit: "", verb: "" } };
  function q(_) {
    return $18[_] ?? null;
  }
  let K = (_) => {
    let Y = typeof _;
    switch (Y) {
      case "number":
        return Number.isNaN(_) ? "(NaN)" : "";
      case "object": {
        if (Array.isArray(_)) return "";
        if (_ === null) return "(null)";
        if (Object.getPrototypeOf(_) !== Object.prototype && _.constructor) return _.constructor.name;
      }
    }
    return Y;
  }, P = { regex: "", email: "", url: "URL", emoji: "", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO", date: "ISO", time: "ISO", duration: "ISO", ipv4: "IPv4", ipv6: "IPv6", cidrv4: "IPv4", cidrv6: "IPv6", base64: "base64", base64url: "base64url", json_string: "JSON", e164: "E.164", jwt: "JWT", template_literal: "" };
  return (_) => {
    switch (_.code) {
      case "invalid_type":
        return ` ${_.expected} ${K(_.input)}`;
      case "invalid_value":
        if (_.values.length === 1) return ` ${m$(_.values[0])}`;
        return ` ${T$(_.values, "|")}`;
      case "too_big": {
        let Y = _.inclusive ? "<=" : "<", O = q(_.origin);
        if (O) return ` ${_.origin ?? ""} ${Y}${_.maximum.toString()} ${O.unit ?? ""}`;
        return ` ${_.origin ?? ""} ${Y}${_.maximum.toString()}`;
      }
      case "too_small": {
        let Y = _.inclusive ? ">=" : ">", O = q(_.origin);
        if (O) return ` ${_.origin} ${Y}${_.minimum.toString()} ${O.unit}`;
        return ` ${_.origin} ${Y}${_.minimum.toString()}`;
      }
      case "invalid_format": {
        let Y = _;
        if (Y.format === "starts_with") return ` "${Y.prefix}" `;
        if (Y.format === "ends_with") return ` "${Y.suffix}" `;
        if (Y.format === "includes") return ` "${Y.includes}"`;
        if (Y.format === "regex") return ` ${Y.pattern}`;
        return `${P[Y.format] ?? _.format}`;
      }
      case "not_multiple_of":
        return ` ${_.divisor} `;
      case "unrecognized_keys":
        return `(key): ${T$(_.keys, ", ")}`;
      case "invalid_key":
        return `${_.origin} (key)`;
      case "invalid_union":
        return "";
      case "invalid_element":
        return `${_.origin} (value)`;
      default:
        return "";
    }
  };
};
function d3() {
  return { localeError: sD() };
}
var $L = () => {
  let $18 = { string: { unit: "", verb: "" }, file: { unit: "", verb: "" }, array: { unit: "", verb: "" }, set: { unit: "", verb: "" } };
  function q(_) {
    return $18[_] ?? null;
  }
  let K = (_) => {
    let Y = typeof _;
    switch (Y) {
      case "number":
        return Number.isNaN(_) ? "NaN" : "number";
      case "object": {
        if (Array.isArray(_)) return "array";
        if (_ === null) return "null";
        if (Object.getPrototypeOf(_) !== Object.prototype && _.constructor) return _.constructor.name;
      }
    }
    return Y;
  }, P = { regex: "", email: "", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO ", date: "ISO ", time: "ISO ", duration: "ISO ", ipv4: "IPv4 ", ipv6: "IPv6 ", cidrv4: "IPv4 ", cidrv6: "IPv6 ", base64: "base64 ", base64url: "base64url ", json_string: "JSON ", e164: "E.164 ", jwt: "JWT", template_literal: "" };
  return (_) => {
    switch (_.code) {
      case "invalid_type":
        return ` ${_.expected} ${K(_.input)}`;
      case "invalid_value":
        if (_.values.length === 1) return ` ${m$(_.values[0])}`;
        return ` ${T$(_.values, "|")}`;
      case "too_big": {
        let Y = _.inclusive ? "<=" : "<", O = q(_.origin);
        if (O) return ` ${_.origin ?? ""}  ${Y}${_.maximum.toString()} ${O.unit ?? ""}`;
        return ` ${_.origin ?? ""}  ${Y}${_.maximum.toString()}`;
      }
      case "too_small": {
        let Y = _.inclusive ? ">=" : ">", O = q(_.origin);
        if (O) return ` ${_.origin}  ${Y}${_.minimum.toString()} ${O.unit}`;
        return ` ${_.origin}  ${Y}${_.minimum.toString()}`;
      }
      case "invalid_format": {
        let Y = _;
        if (Y.format === "starts_with") return ` "${Y.prefix}" `;
        if (Y.format === "ends_with") return ` "${Y.suffix}" `;
        if (Y.format === "includes") return ` "${Y.includes}"`;
        if (Y.format === "regex") return ` ${Y.pattern}`;
        return ` ${P[Y.format] ?? _.format}`;
      }
      case "not_multiple_of":
        return ` ${_.divisor} `;
      case "unrecognized_keys":
        return `${_.keys.length > 1 ? "" : ""}${T$(_.keys, "")}`;
      case "invalid_key":
        return `${_.origin} `;
      case "invalid_union":
        return "";
      case "invalid_element":
        return `${_.origin} `;
      default:
        return "";
    }
  };
};
function l3() {
  return { localeError: $L() };
}
var qL = () => {
  let $18 = { string: { unit: "mi", verb: "n" }, file: { unit: "bytes", verb: "n" }, array: { unit: "nkan", verb: "n" }, set: { unit: "nkan", verb: "n" } };
  function q(_) {
    return $18[_] ?? null;
  }
  let K = (_) => {
    let Y = typeof _;
    switch (Y) {
      case "number":
        return Number.isNaN(_) ? "NaN" : "nmb";
      case "object": {
        if (Array.isArray(_)) return "akop";
        if (_ === null) return "null";
        if (Object.getPrototypeOf(_) !== Object.prototype && _.constructor) return _.constructor.name;
      }
    }
    return Y;
  }, P = { regex: "r bwl", email: "drs ml", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "kk ISO", date: "j ISO", time: "kk ISO", duration: "kk t p ISO", ipv4: "drs IPv4", ipv6: "drs IPv6", cidrv4: "gbgb IPv4", cidrv6: "gbgb IPv6", base64: "r t a k n base64", base64url: "r base64url", json_string: "r JSON", e164: "nmb E.164", jwt: "JWT", template_literal: "r bwl" };
  return (_) => {
    switch (_.code) {
      case "invalid_type":
        return `bwl ae: a n lti fi ${_.expected}, m a r ${K(_.input)}`;
      case "invalid_value":
        if (_.values.length === 1) return `bwl ae: a n lti fi ${m$(_.values[0])}`;
        return `yn ae: yan kan lra ${T$(_.values, "|")}`;
      case "too_big": {
        let Y = _.inclusive ? "<=" : "<", O = q(_.origin);
        if (O) return `T p j: a n lti j p ${_.origin ?? "iye"} ${O.verb} ${Y}${_.maximum} ${O.unit}`;
        return `T p j: a n lti j ${Y}${_.maximum}`;
      }
      case "too_small": {
        let Y = _.inclusive ? ">=" : ">", O = q(_.origin);
        if (O) return `Kr ju: a n lti j p ${_.origin} ${O.verb} ${Y}${_.minimum} ${O.unit}`;
        return `Kr ju: a n lti j ${Y}${_.minimum}`;
      }
      case "invalid_format": {
        let Y = _;
        if (Y.format === "starts_with") return `r ae: gbd br pl "${Y.prefix}"`;
        if (Y.format === "ends_with") return `r ae: gbd par pl "${Y.suffix}"`;
        if (Y.format === "includes") return `r ae: gbd n "${Y.includes}"`;
        if (Y.format === "regex") return `r ae: gbd b pr mu ${Y.pattern}`;
        return `Ae: ${P[Y.format] ?? _.format}`;
      }
      case "not_multiple_of":
        return `Nmb ae: gbd j y ppn ti ${_.divisor}`;
      case "unrecognized_keys":
        return `Btn m: ${T$(_.keys, ", ")}`;
      case "invalid_key":
        return `Btn ae nn ${_.origin}`;
      case "invalid_union":
        return "bwl ae";
      case "invalid_element":
        return `Iye ae nn ${_.origin}`;
      default:
        return "bwl ae";
    }
  };
};
function r3() {
  return { localeError: qL() };
}
var o3 = Symbol("ZodOutput");
var n3 = Symbol("ZodInput");
var UP = class {
  constructor() {
    this._map = /* @__PURE__ */ new WeakMap(), this._idmap = /* @__PURE__ */ new Map();
  }
  add($18, ...q) {
    let K = q[0];
    if (this._map.set($18, K), K && typeof K === "object" && "id" in K) {
      if (this._idmap.has(K.id)) throw Error(`ID ${K.id} already exists in the registry`);
      this._idmap.set(K.id, $18);
    }
    return this;
  }
  clear() {
    return this._map = /* @__PURE__ */ new WeakMap(), this._idmap = /* @__PURE__ */ new Map(), this;
  }
  remove($18) {
    let q = this._map.get($18);
    if (q && typeof q === "object" && "id" in q) this._idmap.delete(q.id);
    return this._map.delete($18), this;
  }
  get($18) {
    let q = $18._zod.parent;
    if (q) {
      let K = { ...this.get(q) ?? {} };
      delete K.id;
      let P = { ...K, ...this._map.get($18) };
      return Object.keys(P).length ? P : void 0;
    }
    return this._map.get($18);
  }
  has($18) {
    return this._map.has($18);
  }
};
function x9() {
  return new UP();
}
var Wq = x9();
function i3($18, q) {
  return new $18({ type: "string", ...d$(q) });
}
function B3($18, q) {
  return new $18({ type: "string", coerce: true, ...d$(q) });
}
function p9($18, q) {
  return new $18({ type: "string", format: "email", check: "string_format", abort: false, ...d$(q) });
}
function FP($18, q) {
  return new $18({ type: "string", format: "guid", check: "string_format", abort: false, ...d$(q) });
}
function c9($18, q) {
  return new $18({ type: "string", format: "uuid", check: "string_format", abort: false, ...d$(q) });
}
function m9($18, q) {
  return new $18({ type: "string", format: "uuid", check: "string_format", abort: false, version: "v4", ...d$(q) });
}
function d9($18, q) {
  return new $18({ type: "string", format: "uuid", check: "string_format", abort: false, version: "v6", ...d$(q) });
}
function l9($18, q) {
  return new $18({ type: "string", format: "uuid", check: "string_format", abort: false, version: "v7", ...d$(q) });
}
function aP($18, q) {
  return new $18({ type: "string", format: "url", check: "string_format", abort: false, ...d$(q) });
}
function r9($18, q) {
  return new $18({ type: "string", format: "emoji", check: "string_format", abort: false, ...d$(q) });
}
function o9($18, q) {
  return new $18({ type: "string", format: "nanoid", check: "string_format", abort: false, ...d$(q) });
}
function n9($18, q) {
  return new $18({ type: "string", format: "cuid", check: "string_format", abort: false, ...d$(q) });
}
function i9($18, q) {
  return new $18({ type: "string", format: "cuid2", check: "string_format", abort: false, ...d$(q) });
}
function B9($18, q) {
  return new $18({ type: "string", format: "ulid", check: "string_format", abort: false, ...d$(q) });
}
function t9($18, q) {
  return new $18({ type: "string", format: "xid", check: "string_format", abort: false, ...d$(q) });
}
function U9($18, q) {
  return new $18({ type: "string", format: "ksuid", check: "string_format", abort: false, ...d$(q) });
}
function F9($18, q) {
  return new $18({ type: "string", format: "ipv4", check: "string_format", abort: false, ...d$(q) });
}
function a9($18, q) {
  return new $18({ type: "string", format: "ipv6", check: "string_format", abort: false, ...d$(q) });
}
function Q9($18, q) {
  return new $18({ type: "string", format: "cidrv4", check: "string_format", abort: false, ...d$(q) });
}
function e9($18, q) {
  return new $18({ type: "string", format: "cidrv6", check: "string_format", abort: false, ...d$(q) });
}
function s9($18, q) {
  return new $18({ type: "string", format: "base64", check: "string_format", abort: false, ...d$(q) });
}
function $52($18, q) {
  return new $18({ type: "string", format: "base64url", check: "string_format", abort: false, ...d$(q) });
}
function q5($18, q) {
  return new $18({ type: "string", format: "e164", check: "string_format", abort: false, ...d$(q) });
}
function K5($18, q) {
  return new $18({ type: "string", format: "jwt", check: "string_format", abort: false, ...d$(q) });
}
var t3 = { Any: null, Minute: -1, Second: 0, Millisecond: 3, Microsecond: 6 };
function U3($18, q) {
  return new $18({ type: "string", format: "datetime", check: "string_format", offset: false, local: false, precision: null, ...d$(q) });
}
function F3($18, q) {
  return new $18({ type: "string", format: "date", check: "string_format", ...d$(q) });
}
function a3($18, q) {
  return new $18({ type: "string", format: "time", check: "string_format", precision: null, ...d$(q) });
}
function Q3($18, q) {
  return new $18({ type: "string", format: "duration", check: "string_format", ...d$(q) });
}
function e3($18, q) {
  return new $18({ type: "number", checks: [], ...d$(q) });
}
function s3($18, q) {
  return new $18({ type: "number", coerce: true, checks: [], ...d$(q) });
}
function $v($18, q) {
  return new $18({ type: "number", check: "number_format", abort: false, format: "safeint", ...d$(q) });
}
function qv($18, q) {
  return new $18({ type: "number", check: "number_format", abort: false, format: "float32", ...d$(q) });
}
function Kv($18, q) {
  return new $18({ type: "number", check: "number_format", abort: false, format: "float64", ...d$(q) });
}
function _v($18, q) {
  return new $18({ type: "number", check: "number_format", abort: false, format: "int32", ...d$(q) });
}
function Pv($18, q) {
  return new $18({ type: "number", check: "number_format", abort: false, format: "uint32", ...d$(q) });
}
function Ov($18, q) {
  return new $18({ type: "boolean", ...d$(q) });
}
function Yv($18, q) {
  return new $18({ type: "boolean", coerce: true, ...d$(q) });
}
function jv($18, q) {
  return new $18({ type: "bigint", ...d$(q) });
}
function vv($18, q) {
  return new $18({ type: "bigint", coerce: true, ...d$(q) });
}
function zv($18, q) {
  return new $18({ type: "bigint", check: "bigint_format", abort: false, format: "int64", ...d$(q) });
}
function Wv($18, q) {
  return new $18({ type: "bigint", check: "bigint_format", abort: false, format: "uint64", ...d$(q) });
}
function Hv($18, q) {
  return new $18({ type: "symbol", ...d$(q) });
}
function Jv($18, q) {
  return new $18({ type: "undefined", ...d$(q) });
}
function Tv($18, q) {
  return new $18({ type: "null", ...d$(q) });
}
function wv($18) {
  return new $18({ type: "any" });
}
function _5($18) {
  return new $18({ type: "unknown" });
}
function QP($18, q) {
  return new $18({ type: "never", ...d$(q) });
}
function fv($18, q) {
  return new $18({ type: "void", ...d$(q) });
}
function Zv($18, q) {
  return new $18({ type: "date", ...d$(q) });
}
function Xv($18, q) {
  return new $18({ type: "date", coerce: true, ...d$(q) });
}
function Av($18, q) {
  return new $18({ type: "nan", ...d$(q) });
}
function jK($18, q) {
  return new S9({ check: "less_than", ...d$(q), value: $18, inclusive: false });
}
function Z8($18, q) {
  return new S9({ check: "less_than", ...d$(q), value: $18, inclusive: true });
}
function vK($18, q) {
  return new M9({ check: "greater_than", ...d$(q), value: $18, inclusive: false });
}
function Fq($18, q) {
  return new M9({ check: "greater_than", ...d$(q), value: $18, inclusive: true });
}
function kv($18) {
  return vK(0, $18);
}
function Gv($18) {
  return jK(0, $18);
}
function Vv($18) {
  return Z8(0, $18);
}
function Sv($18) {
  return Fq(0, $18);
}
function f_($18, q) {
  return new D2({ check: "multiple_of", ...d$(q), value: $18 });
}
function q4($18, q) {
  return new b2({ check: "max_size", ...d$(q), maximum: $18 });
}
function Z_($18, q) {
  return new y2({ check: "min_size", ...d$(q), minimum: $18 });
}
function eP($18, q) {
  return new u2({ check: "size_equals", ...d$(q), size: $18 });
}
function K4($18, q) {
  return new x2({ check: "max_length", ...d$(q), maximum: $18 });
}
function rK($18, q) {
  return new p2({ check: "min_length", ...d$(q), minimum: $18 });
}
function _4($18, q) {
  return new c2({ check: "length_equals", ...d$(q), length: $18 });
}
function sP($18, q) {
  return new m2({ check: "string_format", format: "regex", ...d$(q), pattern: $18 });
}
function $72($18) {
  return new d2({ check: "string_format", format: "lowercase", ...d$($18) });
}
function q7($18) {
  return new l2({ check: "string_format", format: "uppercase", ...d$($18) });
}
function K7($18, q) {
  return new r2({ check: "string_format", format: "includes", ...d$(q), includes: $18 });
}
function _7($18, q) {
  return new o2({ check: "string_format", format: "starts_with", ...d$(q), prefix: $18 });
}
function P7($18, q) {
  return new n2({ check: "string_format", format: "ends_with", ...d$(q), suffix: $18 });
}
function Mv($18, q, K) {
  return new i2({ check: "property", property: $18, schema: q, ...d$(K) });
}
function O7($18, q) {
  return new B2({ check: "mime_type", mime: $18, ...d$(q) });
}
function zK($18) {
  return new t2({ check: "overwrite", tx: $18 });
}
function Y7($18) {
  return zK((q) => q.normalize($18));
}
function j7() {
  return zK(($18) => $18.trim());
}
function v7() {
  return zK(($18) => $18.toLowerCase());
}
function z7() {
  return zK(($18) => $18.toUpperCase());
}
function Nv($18, q, K) {
  return new $18({ type: "array", element: q, ...d$(K) });
}
function KL($18, q, K) {
  return new $18({ type: "union", options: q, ...d$(K) });
}
function _L($18, q, K, P) {
  return new $18({ type: "union", options: K, discriminator: q, ...d$(P) });
}
function PL($18, q, K) {
  return new $18({ type: "intersection", left: q, right: K });
}
function OL($18, q, K, P) {
  let _ = K instanceof P6;
  return new $18({ type: "tuple", items: q, rest: _ ? K : null, ...d$(_ ? P : K) });
}
function YL($18, q, K, P) {
  return new $18({ type: "record", keyType: q, valueType: K, ...d$(P) });
}
function jL($18, q, K, P) {
  return new $18({ type: "map", keyType: q, valueType: K, ...d$(P) });
}
function vL($18, q, K) {
  return new $18({ type: "set", valueType: q, ...d$(K) });
}
function zL($18, q, K) {
  let P = Array.isArray(q) ? Object.fromEntries(q.map((_) => [_, _])) : q;
  return new $18({ type: "enum", entries: P, ...d$(K) });
}
function WL($18, q, K) {
  return new $18({ type: "enum", entries: q, ...d$(K) });
}
function HL($18, q, K) {
  return new $18({ type: "literal", values: Array.isArray(q) ? q : [q], ...d$(K) });
}
function Cv($18, q) {
  return new $18({ type: "file", ...d$(q) });
}
function JL($18, q) {
  return new $18({ type: "transform", transform: q });
}
function TL($18, q) {
  return new $18({ type: "optional", innerType: q });
}
function wL($18, q) {
  return new $18({ type: "nullable", innerType: q });
}
function fL($18, q, K) {
  return new $18({ type: "default", innerType: q, get defaultValue() {
    return typeof K === "function" ? K() : BY(K);
  } });
}
function ZL($18, q, K) {
  return new $18({ type: "nonoptional", innerType: q, ...d$(K) });
}
function XL($18, q) {
  return new $18({ type: "success", innerType: q });
}
function AL($18, q, K) {
  return new $18({ type: "catch", innerType: q, catchValue: typeof K === "function" ? K : () => K });
}
function kL($18, q, K) {
  return new $18({ type: "pipe", in: q, out: K });
}
function GL($18, q) {
  return new $18({ type: "readonly", innerType: q });
}
function VL($18, q, K) {
  return new $18({ type: "template_literal", parts: q, ...d$(K) });
}
function SL($18, q) {
  return new $18({ type: "lazy", getter: q });
}
function ML($18, q) {
  return new $18({ type: "promise", innerType: q });
}
function Ev($18, q, K) {
  let P = d$(K);
  return P.abort ?? (P.abort = true), new $18({ type: "custom", check: "custom", fn: q, ...P });
}
function hv($18, q, K) {
  return new $18({ type: "custom", check: "custom", fn: q, ...d$(K) });
}
function Rv($18) {
  let q = PA((K) => {
    return K.addIssue = (P) => {
      if (typeof P === "string") K.issues.push(U_(P, K.value, q._zod.def));
      else {
        let _ = P;
        if (_.fatal) _.continue = false;
        _.code ?? (_.code = "custom"), _.input ?? (_.input = K.value), _.inst ?? (_.inst = q), _.continue ?? (_.continue = !q._zod.def.abort), K.issues.push(U_(_));
      }
    }, $18(K.value, K);
  });
  return q;
}
function PA($18, q) {
  let K = new I6({ check: "custom", ...d$(q) });
  return K._zod.check = $18, K;
}
function Iv($18, q) {
  let K = d$(q), P = K.truthy ?? ["true", "1", "yes", "on", "y", "enabled"], _ = K.falsy ?? ["false", "0", "no", "off", "n", "disabled"];
  if (K.case !== "sensitive") P = P.map((M) => typeof M === "string" ? M.toLowerCase() : M), _ = _.map((M) => typeof M === "string" ? M.toLowerCase() : M);
  let Y = new Set(P), O = new Set(_), z = $18.Codec ?? lP, J = $18.Boolean ?? mP, X = new ($18.String ?? w_)({ type: "string", error: K.error }), f = new J({ type: "boolean", error: K.error }), V = new z({ type: "pipe", in: X, out: f, transform: (M, N) => {
    let h = M;
    if (K.case !== "sensitive") h = h.toLowerCase();
    if (Y.has(h)) return true;
    else if (O.has(h)) return false;
    else return N.issues.push({ code: "invalid_value", expected: "stringbool", values: [...Y, ...O], input: N.value, inst: V, continue: false }), {};
  }, reverseTransform: (M, N) => {
    if (M === true) return P[0] || "true";
    else return _[0] || "false";
  }, error: K.error });
  return V;
}
function P4($18, q, K, P = {}) {
  let _ = d$(P), Y = { ...d$(P), check: "string_format", type: "string", format: q, fn: typeof K === "function" ? K : (z) => K.test(z), ..._ };
  if (K instanceof RegExp) Y.pattern = K;
  return new $18(Y);
}
var P5 = class {
  constructor($18) {
    this.counter = 0, this.metadataRegistry = ($18 == null ? void 0 : $18.metadata) ?? Wq, this.target = ($18 == null ? void 0 : $18.target) ?? "draft-2020-12", this.unrepresentable = ($18 == null ? void 0 : $18.unrepresentable) ?? "throw", this.override = ($18 == null ? void 0 : $18.override) ?? (() => {
    }), this.io = ($18 == null ? void 0 : $18.io) ?? "output", this.seen = /* @__PURE__ */ new Map();
  }
  process($18, q = { path: [], schemaPath: [] }) {
    var _a2, _b2, _c;
    var K;
    let P = $18._zod.def, _ = { guid: "uuid", url: "uri", datetime: "date-time", json_string: "json-string", regex: "" }, Y = this.seen.get($18);
    if (Y) {
      if (Y.count++, q.schemaPath.includes($18)) Y.cycle = q.path;
      return Y.schema;
    }
    let O = { schema: {}, count: 1, cycle: void 0, path: q.path };
    this.seen.set($18, O);
    let z = (_b2 = (_a2 = $18._zod).toJSONSchema) == null ? void 0 : _b2.call(_a2);
    if (z) O.schema = z;
    else {
      let X = { ...q, schemaPath: [...q.schemaPath, $18], path: q.path }, f = $18._zod.parent;
      if (f) O.ref = f, this.process(f, X), this.seen.get(f).isParent = true;
      else {
        let V = O.schema;
        switch (P.type) {
          case "string": {
            let M = V;
            M.type = "string";
            let { minimum: N, maximum: h, format: E, patterns: I, contentEncoding: D } = $18._zod.bag;
            if (typeof N === "number") M.minLength = N;
            if (typeof h === "number") M.maxLength = h;
            if (E) {
              if (M.format = _[E] ?? E, M.format === "") delete M.format;
            }
            if (D) M.contentEncoding = D;
            if (I && I.size > 0) {
              let g = [...I];
              if (g.length === 1) M.pattern = g[0].source;
              else if (g.length > 1) O.schema.allOf = [...g.map((b) => ({ ...this.target === "draft-7" || this.target === "draft-4" || this.target === "openapi-3.0" ? { type: "string" } : {}, pattern: b.source }))];
            }
            break;
          }
          case "number": {
            let M = V, { minimum: N, maximum: h, format: E, multipleOf: I, exclusiveMaximum: D, exclusiveMinimum: g } = $18._zod.bag;
            if (typeof E === "string" && E.includes("int")) M.type = "integer";
            else M.type = "number";
            if (typeof g === "number") if (this.target === "draft-4" || this.target === "openapi-3.0") M.minimum = g, M.exclusiveMinimum = true;
            else M.exclusiveMinimum = g;
            if (typeof N === "number") {
              if (M.minimum = N, typeof g === "number" && this.target !== "draft-4") if (g >= N) delete M.minimum;
              else delete M.exclusiveMinimum;
            }
            if (typeof D === "number") if (this.target === "draft-4" || this.target === "openapi-3.0") M.maximum = D, M.exclusiveMaximum = true;
            else M.exclusiveMaximum = D;
            if (typeof h === "number") {
              if (M.maximum = h, typeof D === "number" && this.target !== "draft-4") if (D <= h) delete M.maximum;
              else delete M.exclusiveMaximum;
            }
            if (typeof I === "number") M.multipleOf = I;
            break;
          }
          case "boolean": {
            let M = V;
            M.type = "boolean";
            break;
          }
          case "bigint": {
            if (this.unrepresentable === "throw") throw Error("BigInt cannot be represented in JSON Schema");
            break;
          }
          case "symbol": {
            if (this.unrepresentable === "throw") throw Error("Symbols cannot be represented in JSON Schema");
            break;
          }
          case "null": {
            if (this.target === "openapi-3.0") V.type = "string", V.nullable = true, V.enum = [null];
            else V.type = "null";
            break;
          }
          case "any":
            break;
          case "unknown":
            break;
          case "undefined": {
            if (this.unrepresentable === "throw") throw Error("Undefined cannot be represented in JSON Schema");
            break;
          }
          case "void": {
            if (this.unrepresentable === "throw") throw Error("Void cannot be represented in JSON Schema");
            break;
          }
          case "never": {
            V.not = {};
            break;
          }
          case "date": {
            if (this.unrepresentable === "throw") throw Error("Date cannot be represented in JSON Schema");
            break;
          }
          case "array": {
            let M = V, { minimum: N, maximum: h } = $18._zod.bag;
            if (typeof N === "number") M.minItems = N;
            if (typeof h === "number") M.maxItems = h;
            M.type = "array", M.items = this.process(P.element, { ...X, path: [...X.path, "items"] });
            break;
          }
          case "object": {
            let M = V;
            M.type = "object", M.properties = {};
            let N = P.shape;
            for (let I in N) M.properties[I] = this.process(N[I], { ...X, path: [...X.path, "properties", I] });
            let h = new Set(Object.keys(N)), E = new Set([...h].filter((I) => {
              let D = P.shape[I]._zod;
              if (this.io === "input") return D.optin === void 0;
              else return D.optout === void 0;
            }));
            if (E.size > 0) M.required = Array.from(E);
            if (((_c = P.catchall) == null ? void 0 : _c._zod.def.type) === "never") M.additionalProperties = false;
            else if (!P.catchall) {
              if (this.io === "output") M.additionalProperties = false;
            } else if (P.catchall) M.additionalProperties = this.process(P.catchall, { ...X, path: [...X.path, "additionalProperties"] });
            break;
          }
          case "union": {
            let M = V, N = P.options.map((h, E) => this.process(h, { ...X, path: [...X.path, "anyOf", E] }));
            M.anyOf = N;
            break;
          }
          case "intersection": {
            let M = V, N = this.process(P.left, { ...X, path: [...X.path, "allOf", 0] }), h = this.process(P.right, { ...X, path: [...X.path, "allOf", 1] }), E = (D) => "allOf" in D && Object.keys(D).length === 1, I = [...E(N) ? N.allOf : [N], ...E(h) ? h.allOf : [h]];
            M.allOf = I;
            break;
          }
          case "tuple": {
            let M = V;
            M.type = "array";
            let N = this.target === "draft-2020-12" ? "prefixItems" : "items", h = this.target === "draft-2020-12" ? "items" : this.target === "openapi-3.0" ? "items" : "additionalItems", E = P.items.map((b, y) => this.process(b, { ...X, path: [...X.path, N, y] })), I = P.rest ? this.process(P.rest, { ...X, path: [...X.path, h, ...this.target === "openapi-3.0" ? [P.items.length] : []] }) : null;
            if (this.target === "draft-2020-12") {
              if (M.prefixItems = E, I) M.items = I;
            } else if (this.target === "openapi-3.0") {
              if (M.items = { anyOf: E }, I) M.items.anyOf.push(I);
              if (M.minItems = E.length, !I) M.maxItems = E.length;
            } else if (M.items = E, I) M.additionalItems = I;
            let { minimum: D, maximum: g } = $18._zod.bag;
            if (typeof D === "number") M.minItems = D;
            if (typeof g === "number") M.maxItems = g;
            break;
          }
          case "record": {
            let M = V;
            if (M.type = "object", this.target === "draft-7" || this.target === "draft-2020-12") M.propertyNames = this.process(P.keyType, { ...X, path: [...X.path, "propertyNames"] });
            M.additionalProperties = this.process(P.valueType, { ...X, path: [...X.path, "additionalProperties"] });
            break;
          }
          case "map": {
            if (this.unrepresentable === "throw") throw Error("Map cannot be represented in JSON Schema");
            break;
          }
          case "set": {
            if (this.unrepresentable === "throw") throw Error("Set cannot be represented in JSON Schema");
            break;
          }
          case "enum": {
            let M = V, N = RP(P.entries);
            if (N.every((h) => typeof h === "number")) M.type = "number";
            if (N.every((h) => typeof h === "string")) M.type = "string";
            M.enum = N;
            break;
          }
          case "literal": {
            let M = V, N = [];
            for (let h of P.values) if (h === void 0) {
              if (this.unrepresentable === "throw") throw Error("Literal `undefined` cannot be represented in JSON Schema");
            } else if (typeof h === "bigint") if (this.unrepresentable === "throw") throw Error("BigInt literals cannot be represented in JSON Schema");
            else N.push(Number(h));
            else N.push(h);
            if (N.length === 0) ;
            else if (N.length === 1) {
              let h = N[0];
              if (M.type = h === null ? "null" : typeof h, this.target === "draft-4" || this.target === "openapi-3.0") M.enum = [h];
              else M.const = h;
            } else {
              if (N.every((h) => typeof h === "number")) M.type = "number";
              if (N.every((h) => typeof h === "string")) M.type = "string";
              if (N.every((h) => typeof h === "boolean")) M.type = "string";
              if (N.every((h) => h === null)) M.type = "null";
              M.enum = N;
            }
            break;
          }
          case "file": {
            let M = V, N = { type: "string", format: "binary", contentEncoding: "binary" }, { minimum: h, maximum: E, mime: I } = $18._zod.bag;
            if (h !== void 0) N.minLength = h;
            if (E !== void 0) N.maxLength = E;
            if (I) if (I.length === 1) N.contentMediaType = I[0], Object.assign(M, N);
            else M.anyOf = I.map((D) => {
              return { ...N, contentMediaType: D };
            });
            else Object.assign(M, N);
            break;
          }
          case "transform": {
            if (this.unrepresentable === "throw") throw Error("Transforms cannot be represented in JSON Schema");
            break;
          }
          case "nullable": {
            let M = this.process(P.innerType, X);
            if (this.target === "openapi-3.0") O.ref = P.innerType, V.nullable = true;
            else V.anyOf = [M, { type: "null" }];
            break;
          }
          case "nonoptional": {
            this.process(P.innerType, X), O.ref = P.innerType;
            break;
          }
          case "success": {
            let M = V;
            M.type = "boolean";
            break;
          }
          case "default": {
            this.process(P.innerType, X), O.ref = P.innerType, V.default = JSON.parse(JSON.stringify(P.defaultValue));
            break;
          }
          case "prefault": {
            if (this.process(P.innerType, X), O.ref = P.innerType, this.io === "input") V._prefault = JSON.parse(JSON.stringify(P.defaultValue));
            break;
          }
          case "catch": {
            this.process(P.innerType, X), O.ref = P.innerType;
            let M;
            try {
              M = P.catchValue(void 0);
            } catch {
              throw Error("Dynamic catch values are not supported in JSON Schema");
            }
            V.default = M;
            break;
          }
          case "nan": {
            if (this.unrepresentable === "throw") throw Error("NaN cannot be represented in JSON Schema");
            break;
          }
          case "template_literal": {
            let M = V, N = $18._zod.pattern;
            if (!N) throw Error("Pattern not found in template literal");
            M.type = "string", M.pattern = N.source;
            break;
          }
          case "pipe": {
            let M = this.io === "input" ? P.in._zod.def.type === "transform" ? P.out : P.in : P.out;
            this.process(M, X), O.ref = M;
            break;
          }
          case "readonly": {
            this.process(P.innerType, X), O.ref = P.innerType, V.readOnly = true;
            break;
          }
          case "promise": {
            this.process(P.innerType, X), O.ref = P.innerType;
            break;
          }
          case "optional": {
            this.process(P.innerType, X), O.ref = P.innerType;
            break;
          }
          case "lazy": {
            let M = $18._zod.innerType;
            this.process(M, X), O.ref = M;
            break;
          }
          case "custom": {
            if (this.unrepresentable === "throw") throw Error("Custom types cannot be represented in JSON Schema");
            break;
          }
          case "function": {
            if (this.unrepresentable === "throw") throw Error("Function types cannot be represented in JSON Schema");
            break;
          }
          default:
        }
      }
    }
    let J = this.metadataRegistry.get($18);
    if (J) Object.assign(O.schema, J);
    if (this.io === "input" && Yq($18)) delete O.schema.examples, delete O.schema.default;
    if (this.io === "input" && O.schema._prefault) (K = O.schema).default ?? (K.default = O.schema._prefault);
    return delete O.schema._prefault, this.seen.get($18).schema;
  }
  emit($18, q) {
    var _a2, _b2, _c, _d2, _e, _f;
    let K = { cycles: (q == null ? void 0 : q.cycles) ?? "ref", reused: (q == null ? void 0 : q.reused) ?? "inline", external: (q == null ? void 0 : q.external) ?? void 0 }, P = this.seen.get($18);
    if (!P) throw Error("Unprocessed schema. This is a bug in Zod.");
    let _ = (T) => {
      var _a3;
      let X = this.target === "draft-2020-12" ? "$defs" : "definitions";
      if (K.external) {
        let N = (_a3 = K.external.registry.get(T[0])) == null ? void 0 : _a3.id, h = K.external.uri ?? ((I) => I);
        if (N) return { ref: h(N) };
        let E = T[1].defId ?? T[1].schema.id ?? `schema${this.counter++}`;
        return T[1].defId = E, { defId: E, ref: `${h("__shared")}#/${X}/${E}` };
      }
      if (T[1] === P) return { ref: "#" };
      let V = `${"#"}/${X}/`, M = T[1].schema.id ?? `__schema${this.counter++}`;
      return { defId: M, ref: V + M };
    }, Y = (T) => {
      if (T[1].schema.$ref) return;
      let X = T[1], { ref: f, defId: V } = _(T);
      if (X.def = { ...X.schema }, V) X.defId = V;
      let M = X.schema;
      for (let N in M) delete M[N];
      M.$ref = f;
    };
    if (K.cycles === "throw") for (let T of this.seen.entries()) {
      let X = T[1];
      if (X.cycle) throw Error(`Cycle detected: #/${(_a2 = X.cycle) == null ? void 0 : _a2.join("/")}/<root>

Set the \`cycles\` parameter to \`"ref"\` to resolve cyclical schemas with defs.`);
    }
    for (let T of this.seen.entries()) {
      let X = T[1];
      if ($18 === T[0]) {
        Y(T);
        continue;
      }
      if (K.external) {
        let V = (_b2 = K.external.registry.get(T[0])) == null ? void 0 : _b2.id;
        if ($18 !== T[0] && V) {
          Y(T);
          continue;
        }
      }
      if ((_c = this.metadataRegistry.get(T[0])) == null ? void 0 : _c.id) {
        Y(T);
        continue;
      }
      if (X.cycle) {
        Y(T);
        continue;
      }
      if (X.count > 1) {
        if (K.reused === "ref") {
          Y(T);
          continue;
        }
      }
    }
    let O = (T, X) => {
      let f = this.seen.get(T), V = f.def ?? f.schema, M = { ...V };
      if (f.ref === null) return;
      let N = f.ref;
      if (f.ref = null, N) {
        O(N, X);
        let h = this.seen.get(N).schema;
        if (h.$ref && (X.target === "draft-7" || X.target === "draft-4" || X.target === "openapi-3.0")) V.allOf = V.allOf ?? [], V.allOf.push(h);
        else Object.assign(V, h), Object.assign(V, M);
      }
      if (!f.isParent) this.override({ zodSchema: T, jsonSchema: V, path: f.path ?? [] });
    };
    for (let T of [...this.seen.entries()].reverse()) O(T[0], { target: this.target });
    let z = {};
    if (this.target === "draft-2020-12") z.$schema = "https://json-schema.org/draft/2020-12/schema";
    else if (this.target === "draft-7") z.$schema = "http://json-schema.org/draft-07/schema#";
    else if (this.target === "draft-4") z.$schema = "http://json-schema.org/draft-04/schema#";
    else if (this.target === "openapi-3.0") ;
    else console.warn(`Invalid target: ${this.target}`);
    if ((_d2 = K.external) == null ? void 0 : _d2.uri) {
      let T = (_e = K.external.registry.get($18)) == null ? void 0 : _e.id;
      if (!T) throw Error("Schema is missing an `id` property");
      z.$id = K.external.uri(T);
    }
    Object.assign(z, P.def);
    let J = ((_f = K.external) == null ? void 0 : _f.defs) ?? {};
    for (let T of this.seen.entries()) {
      let X = T[1];
      if (X.def && X.defId) J[X.defId] = X.def;
    }
    if (K.external) ;
    else if (Object.keys(J).length > 0) if (this.target === "draft-2020-12") z.$defs = J;
    else z.definitions = J;
    try {
      return JSON.parse(JSON.stringify(z));
    } catch (T) {
      throw Error("Error converting schema to JSON.");
    }
  }
};
function O4($18, q) {
  if ($18 instanceof UP) {
    let P = new P5(q), _ = {};
    for (let z of $18._idmap.entries()) {
      let [J, T] = z;
      P.process(T);
    }
    let Y = {}, O = { registry: $18, uri: q == null ? void 0 : q.uri, defs: _ };
    for (let z of $18._idmap.entries()) {
      let [J, T] = z;
      Y[J] = P.emit(T, { ...q, external: O });
    }
    if (Object.keys(_).length > 0) {
      let z = P.target === "draft-2020-12" ? "$defs" : "definitions";
      Y.__shared = { [z]: _ };
    }
    return { schemas: Y };
  }
  let K = new P5(q);
  return K.process($18), K.emit($18, q);
}
function Yq($18, q) {
  let K = q ?? { seen: /* @__PURE__ */ new Set() };
  if (K.seen.has($18)) return false;
  K.seen.add($18);
  let _ = $18._zod.def;
  switch (_.type) {
    case "string":
    case "number":
    case "bigint":
    case "boolean":
    case "date":
    case "symbol":
    case "undefined":
    case "null":
    case "any":
    case "unknown":
    case "never":
    case "void":
    case "literal":
    case "enum":
    case "nan":
    case "file":
    case "template_literal":
      return false;
    case "array":
      return Yq(_.element, K);
    case "object": {
      for (let Y in _.shape) if (Yq(_.shape[Y], K)) return true;
      return false;
    }
    case "union": {
      for (let Y of _.options) if (Yq(Y, K)) return true;
      return false;
    }
    case "intersection":
      return Yq(_.left, K) || Yq(_.right, K);
    case "tuple": {
      for (let Y of _.items) if (Yq(Y, K)) return true;
      if (_.rest && Yq(_.rest, K)) return true;
      return false;
    }
    case "record":
      return Yq(_.keyType, K) || Yq(_.valueType, K);
    case "map":
      return Yq(_.keyType, K) || Yq(_.valueType, K);
    case "set":
      return Yq(_.valueType, K);
    case "promise":
    case "optional":
    case "nonoptional":
    case "nullable":
    case "readonly":
      return Yq(_.innerType, K);
    case "lazy":
      return Yq(_.getter(), K);
    case "default":
      return Yq(_.innerType, K);
    case "prefault":
      return Yq(_.innerType, K);
    case "custom":
      return false;
    case "transform":
      return true;
    case "pipe":
      return Yq(_.in, K) || Yq(_.out, K);
    case "success":
      return false;
    case "catch":
      return false;
    case "function":
      return false;
    default:
  }
  throw Error(`Unknown schema type: ${_.type}`);
}
var OA = {};
function o8($18) {
  if (typeof $18 !== "object" || $18 === null) return false;
  let q = $18;
  if (!("_zod" in q)) return false;
  let K = q._zod;
  return typeof K === "object" && K !== null && "def" in K;
}
function HK($18) {
  if (typeof $18 !== "object" || $18 === null) return false;
  let q = $18;
  if (!("_def" in q) || "_zod" in q) return false;
  let K = q._def;
  return typeof K === "object" && K != null && "typeName" in K;
}
function NL($18) {
  if (!$18) return false;
  if (typeof $18 !== "object") return false;
  if (Array.isArray($18)) return false;
  if (o8($18) || HK($18)) return true;
  return false;
}
async function YA($18, q) {
  if (o8($18)) return await Q_($18, q);
  if (HK($18)) return await $18.parseAsync(q);
  throw Error("Schema must be an instance of z3.ZodType or z4.$ZodType");
}
function jA($18) {
  var _a2;
  if (o8($18)) return (_a2 = Wq.get($18)) == null ? void 0 : _a2.description;
  if (HK($18)) return $18.description;
  if ("description" in $18 && typeof $18.description === "string") return $18.description;
  return;
}
function vA($18) {
  if (!NL($18)) return false;
  if (HK($18)) return $18._def.typeName === "ZodString";
  if (o8($18)) return $18._zod.def.type === "string";
  return false;
}
function Y4($18) {
  if (!o8($18)) return false;
  if (typeof $18 === "object" && $18 !== null && "_zod" in $18 && typeof $18._zod === "object" && $18._zod !== null && "def" in $18._zod && typeof $18._zod.def === "object" && $18._zod.def !== null && "type" in $18._zod.def && $18._zod.def.type === "object") return true;
  return false;
}
function zA($18) {
  if (!o8($18)) return false;
  if (typeof $18 === "object" && $18 !== null && "_zod" in $18 && typeof $18._zod === "object" && $18._zod !== null && "def" in $18._zod && typeof $18._zod.def === "object" && $18._zod.def !== null && "type" in $18._zod.def && $18._zod.def.type === "array") return true;
  return false;
}
function O5($18, q = false) {
  if (HK($18)) return $18.strict();
  if (Y4($18)) {
    let K = $18._zod.def.shape;
    if (q) for (let [Y, O] of Object.entries($18._zod.def.shape)) {
      if (Y4(O)) {
        let J = O5(O, q);
        K[Y] = J;
      } else if (zA(O)) {
        let J = O._zod.def.element;
        if (Y4(J)) J = O5(J, q);
        K[Y] = o6(O, { ...O._zod.def, element: J });
      } else K[Y] = O;
      let z = Wq.get(O);
      if (z) Wq.add(K[Y], z);
    }
    let P = o6($18, { ...$18._zod.def, shape: K, catchall: QP(dP) }), _ = Wq.get($18);
    if (_) Wq.add(P, _);
    return P;
  }
  throw Error("Schema must be an instance of z3.ZodObject or z4.$ZodObject");
}
function CL($18) {
  return HK($18) && "typeName" in $18._def && $18._def.typeName === "ZodEffects";
}
function EL($18) {
  return o8($18) && $18._zod.def.type === "pipe";
}
function W7($18, q, K) {
  let P = K.get($18);
  if (P !== void 0) return P;
  if (HK($18)) {
    if (CL($18)) return W7($18._def.schema, q, K);
    return $18;
  }
  if (o8($18)) {
    let _ = $18;
    if (EL($18)) _ = W7($18._zod.def.in, q, K);
    if (q) {
      if (Y4(_)) {
        let O = _._zod.def.shape;
        for (let [z, J] of Object.entries(_._zod.def.shape)) O[z] = W7(J, q, K);
        _ = o6(_, { ..._._zod.def, shape: O });
      } else if (zA(_)) {
        let O = W7(_._zod.def.element, q, K);
        _ = o6(_, { ..._._zod.def, element: O });
      }
    }
    let Y = Wq.get($18);
    if (Y) Wq.add(_, Y);
    return K.set($18, _), _;
  }
  throw Error("Schema must be an instance of z3.ZodType or z4.$ZodType");
}
function WA($18, q = false) {
  return W7($18, q, /* @__PURE__ */ new WeakMap());
}
function Dv($18) {
  return $18.replace(/[^a-zA-Z-_0-9]/g, "_");
}
var hL = ["*", "_", "`"];
function RL($18) {
  let q = "";
  for (let [K, P] of Object.entries($18)) q += `	classDef ${K} ${P};
`;
  return q;
}
function HA($18, q, K) {
  let { firstNode: P, lastNode: _, nodeColors: Y, withStyles: O = true, curveStyle: z = "linear", wrapLabelNWords: J = 9 } = K ?? {}, T = O ? `%%{init: {'flowchart': {'curve': '${z}'}}}%%
graph TD;
` : `graph TD;
`;
  if (O) {
    let N = { ["default"]: "{0}({1})" };
    if (P !== void 0) N[P] = "{0}([{1}]):::first";
    if (_ !== void 0) N[_] = "{0}([{1}]):::last";
    for (let [h, E] of Object.entries($18)) {
      let I = E.name.split(":").pop() ?? "", g = hL.some((y) => I.startsWith(y) && I.endsWith(y)) ? `<p>${I}</p>` : I;
      if (Object.keys(E.metadata ?? {}).length) g += `<hr/><small><em>${Object.entries(E.metadata ?? {}).map(([y, p]) => `${y} = ${p}`).join(`
`)}</em></small>`;
      let b = (N[h] ?? N.default).replace("{0}", Dv(h)).replace("{1}", g);
      T += `	${b}
`;
    }
  }
  let X = {};
  for (let M of q) {
    let N = M.source.split(":"), h = M.target.split(":"), E = N.filter((I, D) => I === h[D]).join(":");
    if (!X[E]) X[E] = [];
    X[E].push(M);
  }
  let f = /* @__PURE__ */ new Set();
  function V(M, N) {
    let h = M.length === 1 && M[0].source === M[0].target;
    if (N && !h) {
      let E = N.split(":").pop();
      if (f.has(E)) throw Error(`Found duplicate subgraph '${E}' -- this likely means that you're reusing a subgraph node with the same name. Please adjust your graph to have subgraph nodes with unique names.`);
      f.add(E), T += `	subgraph ${E}
`;
    }
    for (let E of M) {
      let { source: I, target: D, data: g, conditional: b } = E, y = "";
      if (g !== void 0) {
        let p = g, n = p.split(" ");
        if (n.length > J) p = Array.from({ length: Math.ceil(n.length / J) }, (s, q$) => n.slice(q$ * J, (q$ + 1) * J).join(" ")).join("&nbsp;<br>&nbsp;");
        y = b ? ` -. &nbsp;${p}&nbsp; .-> ` : ` -- &nbsp;${p}&nbsp; --> `;
      } else y = b ? " -.-> " : " --> ";
      T += `	${Dv(I)}${y}${Dv(D)};
`;
    }
    for (let E in X) if (E.startsWith(`${N}:`) && E !== N) V(X[E], E);
    if (N && !h) T += `	end
`;
  }
  V(X[""] ?? [], "");
  for (let M in X) if (!M.includes(":") && M !== "") V(X[M], M);
  if (O) T += RL(Y ?? {});
  return T;
}
async function JA($18, q) {
  let K = (q == null ? void 0 : q.backgroundColor) ?? "white", P = (q == null ? void 0 : q.imageType) ?? "png", _ = btoa($18);
  if (K !== void 0) {
    if (!/^#(?:[0-9a-fA-F]{3}){1,2}$/.test(K)) K = `!${K}`;
  }
  let Y = `https://mermaid.ink/img/${_}?bgColor=${K}&type=${P}`, O = await fetch(Y);
  if (!O.ok) throw Error(["Failed to render the graph using the Mermaid.INK API.", `Status code: ${O.status}`, `Status text: ${O.statusText}`].join(`
`));
  return await O.blob();
}
var gv = Symbol("Let zodToJsonSchema decide on which parser to use");
var Lv = { name: void 0, $refStrategy: "root", basePath: ["#"], effectStrategy: "input", pipeStrategy: "all", dateStrategy: "format:date-time", mapStrategy: "entries", removeAdditionalStrategy: "passthrough", allowedAdditionalProperties: true, rejectedAdditionalProperties: false, definitionPath: "definitions", target: "jsonSchema7", strictUnions: false, definitions: {}, errorMessages: false, markdownDescription: false, patternStrategy: "escape", applyRegexFlags: false, emailStrategy: "format:email", base64Strategy: "contentEncoding:base64", nameStrategy: "ref", openAiAnyTypeName: "OpenAiAnyType" };
var bv = ($18) => typeof $18 === "string" ? { ...Lv, name: $18 } : { ...Lv, ...$18 };
var yv = ($18) => {
  let q = bv($18), K = q.name !== void 0 ? [...q.basePath, q.definitionPath, q.name] : q.basePath;
  return { ...q, flags: { hasReferencedOpenAiAnyType: false }, currentPath: K, propertyPath: void 0, seen: new Map(Object.entries(q.definitions).map(([P, _]) => [_._def, { def: _._def, path: [...q.basePath, q.definitionPath, P], jsonSchema: void 0 }])) };
};
var H7 = ($18, q) => {
  let K = 0;
  for (; K < $18.length && K < q.length; K++) if ($18[K] !== q[K]) break;
  return [($18.length - K).toString(), ...q.slice(K)].join("/");
};
function D6($18) {
  if ($18.target !== "openAi") return {};
  let q = [...$18.basePath, $18.definitionPath, $18.openAiAnyTypeName];
  return $18.flags.hasReferencedOpenAiAnyType = true, { $ref: $18.$refStrategy === "relative" ? H7(q, $18.currentPath) : q.join("/") };
}
function Y5($18, q, K, P) {
  if (!(P == null ? void 0 : P.errorMessages)) return;
  if (K) $18.errorMessage = { ...$18.errorMessage, [q]: K };
}
function G6($18, q, K, P, _) {
  $18[q] = K, Y5($18, q, P, _);
}
var S_ = {};
lq(S_, { void: () => Jg, util: () => k6, unknown: () => Wg, union: () => Zg, undefined: () => jg, tuple: () => kg, transformer: () => Ig, symbol: () => Yg, string: () => VA, strictObject: () => fg, setErrorMap: () => LL, set: () => Sg, record: () => Gg, quotelessJson: () => IL, promise: () => Rg, preprocess: () => gg, pipeline: () => bg, ostring: () => yg, optional: () => Dg, onumber: () => ug, oboolean: () => xg, objectUtil: () => uv, object: () => wg, number: () => SA, nullable: () => Lg, null: () => vg, never: () => Hg, nativeEnum: () => hg, nan: () => _g, map: () => Vg, makeIssue: () => J7, literal: () => Cg, lazy: () => Ng, late: () => qg, isValid: () => oK, isDirty: () => v5, isAsync: () => v4, isAborted: () => j5, intersection: () => Ag, instanceof: () => Kg, getParsedType: () => n8, getErrorMap: () => j4, function: () => Mg, enum: () => Eg, effect: () => Ig, discriminatedUnion: () => Xg, defaultErrorMap: () => JK, datetimeRegex: () => AA, date: () => Og, custom: () => GA, coerce: () => pg, boolean: () => MA, bigint: () => Pg, array: () => Tg, any: () => zg, addIssueToContext: () => B$, ZodVoid: () => w7, ZodUnknown: () => nK, ZodUnion: () => w4, ZodUndefined: () => J4, ZodType: () => w6, ZodTuple: () => B8, ZodTransformer: () => g8, ZodSymbol: () => T7, ZodString: () => R8, ZodSet: () => G_, ZodSchema: () => w6, ZodRecord: () => f7, ZodReadonly: () => V4, ZodPromise: () => V_, ZodPipeline: () => A7, ZodParsedType: () => o$, ZodOptional: () => D8, ZodObject: () => y6, ZodNumber: () => iK, ZodNullable: () => wK, ZodNull: () => T4, ZodNever: () => i8, ZodNativeEnum: () => A4, ZodNaN: () => X7, ZodMap: () => Z7, ZodLiteral: () => X4, ZodLazy: () => Z4, ZodIssueCode: () => p$, ZodIntersection: () => f4, ZodFunction: () => W4, ZodFirstPartyTypeKind: () => c$, ZodError: () => aq, ZodEnum: () => tK, ZodEffects: () => g8, ZodDiscriminatedUnion: () => z5, ZodDefault: () => k4, ZodDate: () => A_, ZodCatch: () => G4, ZodBranded: () => W5, ZodBoolean: () => H4, ZodBigInt: () => BK, ZodArray: () => I8, ZodAny: () => k_, Schema: () => w6, ParseStatus: () => kq, OK: () => Rq, NEVER: () => cg, INVALID: () => q6, EMPTY_PATH: () => gL, DIRTY: () => X_, BRAND: () => $g });
var k6;
(function($18) {
  $18.assertEqual = (_) => {
  };
  function q(_) {
  }
  $18.assertIs = q;
  function K(_) {
    throw Error();
  }
  $18.assertNever = K, $18.arrayToEnum = (_) => {
    let Y = {};
    for (let O of _) Y[O] = O;
    return Y;
  }, $18.getValidEnumValues = (_) => {
    let Y = $18.objectKeys(_).filter((z) => typeof _[_[z]] !== "number"), O = {};
    for (let z of Y) O[z] = _[z];
    return $18.objectValues(O);
  }, $18.objectValues = (_) => {
    return $18.objectKeys(_).map(function(Y) {
      return _[Y];
    });
  }, $18.objectKeys = typeof Object.keys === "function" ? (_) => Object.keys(_) : (_) => {
    let Y = [];
    for (let O in _) if (Object.prototype.hasOwnProperty.call(_, O)) Y.push(O);
    return Y;
  }, $18.find = (_, Y) => {
    for (let O of _) if (Y(O)) return O;
    return;
  }, $18.isInteger = typeof Number.isInteger === "function" ? (_) => Number.isInteger(_) : (_) => typeof _ === "number" && Number.isFinite(_) && Math.floor(_) === _;
  function P(_, Y = " | ") {
    return _.map((O) => typeof O === "string" ? `'${O}'` : O).join(Y);
  }
  $18.joinValues = P, $18.jsonStringifyReplacer = (_, Y) => {
    if (typeof Y === "bigint") return Y.toString();
    return Y;
  };
})(k6 || (k6 = {}));
var uv;
(function($18) {
  $18.mergeShapes = (q, K) => {
    return { ...q, ...K };
  };
})(uv || (uv = {}));
var o$ = k6.arrayToEnum(["string", "nan", "number", "integer", "float", "boolean", "date", "bigint", "symbol", "function", "undefined", "null", "array", "object", "unknown", "promise", "void", "never", "map", "set"]);
var n8 = ($18) => {
  switch (typeof $18) {
    case "undefined":
      return o$.undefined;
    case "string":
      return o$.string;
    case "number":
      return Number.isNaN($18) ? o$.nan : o$.number;
    case "boolean":
      return o$.boolean;
    case "function":
      return o$.function;
    case "bigint":
      return o$.bigint;
    case "symbol":
      return o$.symbol;
    case "object":
      if (Array.isArray($18)) return o$.array;
      if ($18 === null) return o$.null;
      if ($18.then && typeof $18.then === "function" && $18.catch && typeof $18.catch === "function") return o$.promise;
      if (typeof Map < "u" && $18 instanceof Map) return o$.map;
      if (typeof Set < "u" && $18 instanceof Set) return o$.set;
      if (typeof Date < "u" && $18 instanceof Date) return o$.date;
      return o$.object;
    default:
      return o$.unknown;
  }
};
var p$ = k6.arrayToEnum(["invalid_type", "invalid_literal", "custom", "invalid_union", "invalid_union_discriminator", "invalid_enum_value", "unrecognized_keys", "invalid_arguments", "invalid_return_type", "invalid_date", "invalid_string", "too_small", "too_big", "invalid_intersection_types", "not_multiple_of", "not_finite"]);
var IL = ($18) => {
  return JSON.stringify($18, null, 2).replace(/"([^"]+)":/g, "$1:");
};
var aq = class _aq extends Error {
  get errors() {
    return this.issues;
  }
  constructor($18) {
    super();
    this.issues = [], this.addIssue = (K) => {
      this.issues = [...this.issues, K];
    }, this.addIssues = (K = []) => {
      this.issues = [...this.issues, ...K];
    };
    let q = new.target.prototype;
    if (Object.setPrototypeOf) Object.setPrototypeOf(this, q);
    else this.__proto__ = q;
    this.name = "ZodError", this.issues = $18;
  }
  format($18) {
    let q = $18 || function(_) {
      return _.message;
    }, K = { _errors: [] }, P = (_) => {
      for (let Y of _.issues) if (Y.code === "invalid_union") Y.unionErrors.map(P);
      else if (Y.code === "invalid_return_type") P(Y.returnTypeError);
      else if (Y.code === "invalid_arguments") P(Y.argumentsError);
      else if (Y.path.length === 0) K._errors.push(q(Y));
      else {
        let O = K, z = 0;
        while (z < Y.path.length) {
          let J = Y.path[z];
          if (z !== Y.path.length - 1) O[J] = O[J] || { _errors: [] };
          else O[J] = O[J] || { _errors: [] }, O[J]._errors.push(q(Y));
          O = O[J], z++;
        }
      }
    };
    return P(this), K;
  }
  static assert($18) {
    if (!($18 instanceof _aq)) throw Error(`Not a ZodError: ${$18}`);
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, k6.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten($18 = (q) => q.message) {
    let q = {}, K = [];
    for (let P of this.issues) if (P.path.length > 0) {
      let _ = P.path[0];
      q[_] = q[_] || [], q[_].push($18(P));
    } else K.push($18(P));
    return { formErrors: K, fieldErrors: q };
  }
  get formErrors() {
    return this.flatten();
  }
};
aq.create = ($18) => {
  return new aq($18);
};
var DL = ($18, q) => {
  let K;
  switch ($18.code) {
    case p$.invalid_type:
      if ($18.received === o$.undefined) K = "Required";
      else K = `Expected ${$18.expected}, received ${$18.received}`;
      break;
    case p$.invalid_literal:
      K = `Invalid literal value, expected ${JSON.stringify($18.expected, k6.jsonStringifyReplacer)}`;
      break;
    case p$.unrecognized_keys:
      K = `Unrecognized key(s) in object: ${k6.joinValues($18.keys, ", ")}`;
      break;
    case p$.invalid_union:
      K = "Invalid input";
      break;
    case p$.invalid_union_discriminator:
      K = `Invalid discriminator value. Expected ${k6.joinValues($18.options)}`;
      break;
    case p$.invalid_enum_value:
      K = `Invalid enum value. Expected ${k6.joinValues($18.options)}, received '${$18.received}'`;
      break;
    case p$.invalid_arguments:
      K = "Invalid function arguments";
      break;
    case p$.invalid_return_type:
      K = "Invalid function return type";
      break;
    case p$.invalid_date:
      K = "Invalid date";
      break;
    case p$.invalid_string:
      if (typeof $18.validation === "object") if ("includes" in $18.validation) {
        if (K = `Invalid input: must include "${$18.validation.includes}"`, typeof $18.validation.position === "number") K = `${K} at one or more positions greater than or equal to ${$18.validation.position}`;
      } else if ("startsWith" in $18.validation) K = `Invalid input: must start with "${$18.validation.startsWith}"`;
      else if ("endsWith" in $18.validation) K = `Invalid input: must end with "${$18.validation.endsWith}"`;
      else k6.assertNever($18.validation);
      else if ($18.validation !== "regex") K = `Invalid ${$18.validation}`;
      else K = "Invalid";
      break;
    case p$.too_small:
      if ($18.type === "array") K = `Array must contain ${$18.exact ? "exactly" : $18.inclusive ? "at least" : "more than"} ${$18.minimum} element(s)`;
      else if ($18.type === "string") K = `String must contain ${$18.exact ? "exactly" : $18.inclusive ? "at least" : "over"} ${$18.minimum} character(s)`;
      else if ($18.type === "number") K = `Number must be ${$18.exact ? "exactly equal to " : $18.inclusive ? "greater than or equal to " : "greater than "}${$18.minimum}`;
      else if ($18.type === "bigint") K = `Number must be ${$18.exact ? "exactly equal to " : $18.inclusive ? "greater than or equal to " : "greater than "}${$18.minimum}`;
      else if ($18.type === "date") K = `Date must be ${$18.exact ? "exactly equal to " : $18.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number($18.minimum))}`;
      else K = "Invalid input";
      break;
    case p$.too_big:
      if ($18.type === "array") K = `Array must contain ${$18.exact ? "exactly" : $18.inclusive ? "at most" : "less than"} ${$18.maximum} element(s)`;
      else if ($18.type === "string") K = `String must contain ${$18.exact ? "exactly" : $18.inclusive ? "at most" : "under"} ${$18.maximum} character(s)`;
      else if ($18.type === "number") K = `Number must be ${$18.exact ? "exactly" : $18.inclusive ? "less than or equal to" : "less than"} ${$18.maximum}`;
      else if ($18.type === "bigint") K = `BigInt must be ${$18.exact ? "exactly" : $18.inclusive ? "less than or equal to" : "less than"} ${$18.maximum}`;
      else if ($18.type === "date") K = `Date must be ${$18.exact ? "exactly" : $18.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number($18.maximum))}`;
      else K = "Invalid input";
      break;
    case p$.custom:
      K = "Invalid input";
      break;
    case p$.invalid_intersection_types:
      K = "Intersection results could not be merged";
      break;
    case p$.not_multiple_of:
      K = `Number must be a multiple of ${$18.multipleOf}`;
      break;
    case p$.not_finite:
      K = "Number must be finite";
      break;
    default:
      K = q.defaultError, k6.assertNever($18);
  }
  return { message: K };
};
var JK = DL;
var TA = JK;
function LL($18) {
  TA = $18;
}
function j4() {
  return TA;
}
var J7 = ($18) => {
  let { data: q, path: K, errorMaps: P, issueData: _ } = $18, Y = [...K, ..._.path || []], O = { ..._, path: Y };
  if (_.message !== void 0) return { ..._, path: Y, message: _.message };
  let z = "", J = P.filter((T) => !!T).slice().reverse();
  for (let T of J) z = T(O, { data: q, defaultError: z }).message;
  return { ..._, path: Y, message: z };
};
var gL = [];
function B$($18, q) {
  let K = j4(), P = J7({ issueData: q, data: $18.data, path: $18.path, errorMaps: [$18.common.contextualErrorMap, $18.schemaErrorMap, K, K === JK ? void 0 : JK].filter((_) => !!_) });
  $18.common.issues.push(P);
}
var kq = class _kq {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid") this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted") this.value = "aborted";
  }
  static mergeArray($18, q) {
    let K = [];
    for (let P of q) {
      if (P.status === "aborted") return q6;
      if (P.status === "dirty") $18.dirty();
      K.push(P.value);
    }
    return { status: $18.value, value: K };
  }
  static async mergeObjectAsync($18, q) {
    let K = [];
    for (let P of q) {
      let _ = await P.key, Y = await P.value;
      K.push({ key: _, value: Y });
    }
    return _kq.mergeObjectSync($18, K);
  }
  static mergeObjectSync($18, q) {
    let K = {};
    for (let P of q) {
      let { key: _, value: Y } = P;
      if (_.status === "aborted") return q6;
      if (Y.status === "aborted") return q6;
      if (_.status === "dirty") $18.dirty();
      if (Y.status === "dirty") $18.dirty();
      if (_.value !== "__proto__" && (typeof Y.value < "u" || P.alwaysSet)) K[_.value] = Y.value;
    }
    return { status: $18.value, value: K };
  }
};
var q6 = Object.freeze({ status: "aborted" });
var X_ = ($18) => ({ status: "dirty", value: $18 });
var Rq = ($18) => ({ status: "valid", value: $18 });
var j5 = ($18) => $18.status === "aborted";
var v5 = ($18) => $18.status === "dirty";
var oK = ($18) => $18.status === "valid";
var v4 = ($18) => typeof Promise < "u" && $18 instanceof Promise;
var s$;
(function($18) {
  $18.errToObj = (q) => typeof q === "string" ? { message: q } : q || {}, $18.toString = (q) => typeof q === "string" ? q : q == null ? void 0 : q.message;
})(s$ || (s$ = {}));
var L8 = class {
  constructor($18, q, K, P) {
    this._cachedPath = [], this.parent = $18, this.data = q, this._path = K, this._key = P;
  }
  get path() {
    if (!this._cachedPath.length) if (Array.isArray(this._key)) this._cachedPath.push(...this._path, ...this._key);
    else this._cachedPath.push(...this._path, this._key);
    return this._cachedPath;
  }
};
var wA = ($18, q) => {
  if (oK(q)) return { success: true, data: q.value };
  else {
    if (!$18.common.issues.length) throw Error("Validation failed but no issues detected.");
    return { success: false, get error() {
      if (this._error) return this._error;
      let K = new aq($18.common.issues);
      return this._error = K, this._error;
    } };
  }
};
function z6($18) {
  if (!$18) return {};
  let { errorMap: q, invalid_type_error: K, required_error: P, description: _ } = $18;
  if (q && (K || P)) throw Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  if (q) return { errorMap: q, description: _ };
  return { errorMap: (O, z) => {
    let { message: J } = $18;
    if (O.code === "invalid_enum_value") return { message: J ?? z.defaultError };
    if (typeof z.data > "u") return { message: J ?? P ?? z.defaultError };
    if (O.code !== "invalid_type") return { message: z.defaultError };
    return { message: J ?? K ?? z.defaultError };
  }, description: _ };
}
var w6 = class {
  get description() {
    return this._def.description;
  }
  _getType($18) {
    return n8($18.data);
  }
  _getOrReturnCtx($18, q) {
    return q || { common: $18.parent.common, data: $18.data, parsedType: n8($18.data), schemaErrorMap: this._def.errorMap, path: $18.path, parent: $18.parent };
  }
  _processInputParams($18) {
    return { status: new kq(), ctx: { common: $18.parent.common, data: $18.data, parsedType: n8($18.data), schemaErrorMap: this._def.errorMap, path: $18.path, parent: $18.parent } };
  }
  _parseSync($18) {
    let q = this._parse($18);
    if (v4(q)) throw Error("Synchronous parse encountered promise.");
    return q;
  }
  _parseAsync($18) {
    let q = this._parse($18);
    return Promise.resolve(q);
  }
  parse($18, q) {
    let K = this.safeParse($18, q);
    if (K.success) return K.data;
    throw K.error;
  }
  safeParse($18, q) {
    let K = { common: { issues: [], async: (q == null ? void 0 : q.async) ?? false, contextualErrorMap: q == null ? void 0 : q.errorMap }, path: (q == null ? void 0 : q.path) || [], schemaErrorMap: this._def.errorMap, parent: null, data: $18, parsedType: n8($18) }, P = this._parseSync({ data: $18, path: K.path, parent: K });
    return wA(K, P);
  }
  "~validate"($18) {
    var _a2, _b2;
    let q = { common: { issues: [], async: !!this["~standard"].async }, path: [], schemaErrorMap: this._def.errorMap, parent: null, data: $18, parsedType: n8($18) };
    if (!this["~standard"].async) try {
      let K = this._parseSync({ data: $18, path: [], parent: q });
      return oK(K) ? { value: K.value } : { issues: q.common.issues };
    } catch (K) {
      if ((_b2 = (_a2 = K == null ? void 0 : K.message) == null ? void 0 : _a2.toLowerCase()) == null ? void 0 : _b2.includes("encountered")) this["~standard"].async = true;
      q.common = { issues: [], async: true };
    }
    return this._parseAsync({ data: $18, path: [], parent: q }).then((K) => oK(K) ? { value: K.value } : { issues: q.common.issues });
  }
  async parseAsync($18, q) {
    let K = await this.safeParseAsync($18, q);
    if (K.success) return K.data;
    throw K.error;
  }
  async safeParseAsync($18, q) {
    let K = { common: { issues: [], contextualErrorMap: q == null ? void 0 : q.errorMap, async: true }, path: (q == null ? void 0 : q.path) || [], schemaErrorMap: this._def.errorMap, parent: null, data: $18, parsedType: n8($18) }, P = this._parse({ data: $18, path: K.path, parent: K }), _ = await (v4(P) ? P : Promise.resolve(P));
    return wA(K, _);
  }
  refine($18, q) {
    let K = (P) => {
      if (typeof q === "string" || typeof q > "u") return { message: q };
      else if (typeof q === "function") return q(P);
      else return q;
    };
    return this._refinement((P, _) => {
      let Y = $18(P), O = () => _.addIssue({ code: p$.custom, ...K(P) });
      if (typeof Promise < "u" && Y instanceof Promise) return Y.then((z) => {
        if (!z) return O(), false;
        else return true;
      });
      if (!Y) return O(), false;
      else return true;
    });
  }
  refinement($18, q) {
    return this._refinement((K, P) => {
      if (!$18(K)) return P.addIssue(typeof q === "function" ? q(K, P) : q), false;
      else return true;
    });
  }
  _refinement($18) {
    return new g8({ schema: this, typeName: c$.ZodEffects, effect: { type: "refinement", refinement: $18 } });
  }
  superRefine($18) {
    return this._refinement($18);
  }
  constructor($18) {
    this.spa = this.safeParseAsync, this._def = $18, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.readonly = this.readonly.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this), this["~standard"] = { version: 1, vendor: "zod", validate: (q) => this["~validate"](q) };
  }
  optional() {
    return D8.create(this, this._def);
  }
  nullable() {
    return wK.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return I8.create(this);
  }
  promise() {
    return V_.create(this, this._def);
  }
  or($18) {
    return w4.create([this, $18], this._def);
  }
  and($18) {
    return f4.create(this, $18, this._def);
  }
  transform($18) {
    return new g8({ ...z6(this._def), schema: this, typeName: c$.ZodEffects, effect: { type: "transform", transform: $18 } });
  }
  default($18) {
    let q = typeof $18 === "function" ? $18 : () => $18;
    return new k4({ ...z6(this._def), innerType: this, defaultValue: q, typeName: c$.ZodDefault });
  }
  brand() {
    return new W5({ typeName: c$.ZodBranded, type: this, ...z6(this._def) });
  }
  catch($18) {
    let q = typeof $18 === "function" ? $18 : () => $18;
    return new G4({ ...z6(this._def), innerType: this, catchValue: q, typeName: c$.ZodCatch });
  }
  describe($18) {
    return new this.constructor({ ...this._def, description: $18 });
  }
  pipe($18) {
    return A7.create(this, $18);
  }
  readonly() {
    return V4.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
};
var bL = /^c[^\s-]{8,}$/i;
var yL = /^[0-9a-z]+$/;
var uL = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
var xL = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
var pL = /^[a-z0-9_-]{21}$/i;
var cL = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
var mL = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
var dL = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
var lL = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
var xv;
var rL = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
var oL = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
var nL = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
var iL = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
var BL = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
var tL = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
var ZA = "((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))";
var UL = new RegExp(`^${ZA}$`);
function XA($18) {
  let q = "[0-5]\\d";
  if ($18.precision) q = `${q}\\.\\d{${$18.precision}}`;
  else if ($18.precision == null) q = `${q}(\\.\\d+)?`;
  let K = $18.precision ? "+" : "?";
  return `([01]\\d|2[0-3]):[0-5]\\d(:${q})${K}`;
}
function FL($18) {
  return new RegExp(`^${XA($18)}$`);
}
function AA($18) {
  let q = `${ZA}T${XA($18)}`, K = [];
  if (K.push($18.local ? "Z?" : "Z"), $18.offset) K.push("([+-]\\d{2}:?\\d{2})");
  return q = `${q}(${K.join("|")})`, new RegExp(`^${q}$`);
}
function aL($18, q) {
  if ((q === "v4" || !q) && rL.test($18)) return true;
  if ((q === "v6" || !q) && nL.test($18)) return true;
  return false;
}
function QL($18, q) {
  if (!cL.test($18)) return false;
  try {
    let [K] = $18.split(".");
    if (!K) return false;
    let P = K.replace(/-/g, "+").replace(/_/g, "/").padEnd(K.length + (4 - K.length % 4) % 4, "="), _ = JSON.parse(atob(P));
    if (typeof _ !== "object" || _ === null) return false;
    if ("typ" in _ && (_ == null ? void 0 : _.typ) !== "JWT") return false;
    if (!_.alg) return false;
    if (q && _.alg !== q) return false;
    return true;
  } catch {
    return false;
  }
}
function eL($18, q) {
  if ((q === "v4" || !q) && oL.test($18)) return true;
  if ((q === "v6" || !q) && iL.test($18)) return true;
  return false;
}
var R8 = class _R8 extends w6 {
  _parse($18) {
    if (this._def.coerce) $18.data = String($18.data);
    if (this._getType($18) !== o$.string) {
      let _ = this._getOrReturnCtx($18);
      return B$(_, { code: p$.invalid_type, expected: o$.string, received: _.parsedType }), q6;
    }
    let K = new kq(), P = void 0;
    for (let _ of this._def.checks) if (_.kind === "min") {
      if ($18.data.length < _.value) P = this._getOrReturnCtx($18, P), B$(P, { code: p$.too_small, minimum: _.value, type: "string", inclusive: true, exact: false, message: _.message }), K.dirty();
    } else if (_.kind === "max") {
      if ($18.data.length > _.value) P = this._getOrReturnCtx($18, P), B$(P, { code: p$.too_big, maximum: _.value, type: "string", inclusive: true, exact: false, message: _.message }), K.dirty();
    } else if (_.kind === "length") {
      let Y = $18.data.length > _.value, O = $18.data.length < _.value;
      if (Y || O) {
        if (P = this._getOrReturnCtx($18, P), Y) B$(P, { code: p$.too_big, maximum: _.value, type: "string", inclusive: true, exact: true, message: _.message });
        else if (O) B$(P, { code: p$.too_small, minimum: _.value, type: "string", inclusive: true, exact: true, message: _.message });
        K.dirty();
      }
    } else if (_.kind === "email") {
      if (!dL.test($18.data)) P = this._getOrReturnCtx($18, P), B$(P, { validation: "email", code: p$.invalid_string, message: _.message }), K.dirty();
    } else if (_.kind === "emoji") {
      if (!xv) xv = new RegExp(lL, "u");
      if (!xv.test($18.data)) P = this._getOrReturnCtx($18, P), B$(P, { validation: "emoji", code: p$.invalid_string, message: _.message }), K.dirty();
    } else if (_.kind === "uuid") {
      if (!xL.test($18.data)) P = this._getOrReturnCtx($18, P), B$(P, { validation: "uuid", code: p$.invalid_string, message: _.message }), K.dirty();
    } else if (_.kind === "nanoid") {
      if (!pL.test($18.data)) P = this._getOrReturnCtx($18, P), B$(P, { validation: "nanoid", code: p$.invalid_string, message: _.message }), K.dirty();
    } else if (_.kind === "cuid") {
      if (!bL.test($18.data)) P = this._getOrReturnCtx($18, P), B$(P, { validation: "cuid", code: p$.invalid_string, message: _.message }), K.dirty();
    } else if (_.kind === "cuid2") {
      if (!yL.test($18.data)) P = this._getOrReturnCtx($18, P), B$(P, { validation: "cuid2", code: p$.invalid_string, message: _.message }), K.dirty();
    } else if (_.kind === "ulid") {
      if (!uL.test($18.data)) P = this._getOrReturnCtx($18, P), B$(P, { validation: "ulid", code: p$.invalid_string, message: _.message }), K.dirty();
    } else if (_.kind === "url") try {
      new URL($18.data);
    } catch {
      P = this._getOrReturnCtx($18, P), B$(P, { validation: "url", code: p$.invalid_string, message: _.message }), K.dirty();
    }
    else if (_.kind === "regex") {
      if (_.regex.lastIndex = 0, !_.regex.test($18.data)) P = this._getOrReturnCtx($18, P), B$(P, { validation: "regex", code: p$.invalid_string, message: _.message }), K.dirty();
    } else if (_.kind === "trim") $18.data = $18.data.trim();
    else if (_.kind === "includes") {
      if (!$18.data.includes(_.value, _.position)) P = this._getOrReturnCtx($18, P), B$(P, { code: p$.invalid_string, validation: { includes: _.value, position: _.position }, message: _.message }), K.dirty();
    } else if (_.kind === "toLowerCase") $18.data = $18.data.toLowerCase();
    else if (_.kind === "toUpperCase") $18.data = $18.data.toUpperCase();
    else if (_.kind === "startsWith") {
      if (!$18.data.startsWith(_.value)) P = this._getOrReturnCtx($18, P), B$(P, { code: p$.invalid_string, validation: { startsWith: _.value }, message: _.message }), K.dirty();
    } else if (_.kind === "endsWith") {
      if (!$18.data.endsWith(_.value)) P = this._getOrReturnCtx($18, P), B$(P, { code: p$.invalid_string, validation: { endsWith: _.value }, message: _.message }), K.dirty();
    } else if (_.kind === "datetime") {
      if (!AA(_).test($18.data)) P = this._getOrReturnCtx($18, P), B$(P, { code: p$.invalid_string, validation: "datetime", message: _.message }), K.dirty();
    } else if (_.kind === "date") {
      if (!UL.test($18.data)) P = this._getOrReturnCtx($18, P), B$(P, { code: p$.invalid_string, validation: "date", message: _.message }), K.dirty();
    } else if (_.kind === "time") {
      if (!FL(_).test($18.data)) P = this._getOrReturnCtx($18, P), B$(P, { code: p$.invalid_string, validation: "time", message: _.message }), K.dirty();
    } else if (_.kind === "duration") {
      if (!mL.test($18.data)) P = this._getOrReturnCtx($18, P), B$(P, { validation: "duration", code: p$.invalid_string, message: _.message }), K.dirty();
    } else if (_.kind === "ip") {
      if (!aL($18.data, _.version)) P = this._getOrReturnCtx($18, P), B$(P, { validation: "ip", code: p$.invalid_string, message: _.message }), K.dirty();
    } else if (_.kind === "jwt") {
      if (!QL($18.data, _.alg)) P = this._getOrReturnCtx($18, P), B$(P, { validation: "jwt", code: p$.invalid_string, message: _.message }), K.dirty();
    } else if (_.kind === "cidr") {
      if (!eL($18.data, _.version)) P = this._getOrReturnCtx($18, P), B$(P, { validation: "cidr", code: p$.invalid_string, message: _.message }), K.dirty();
    } else if (_.kind === "base64") {
      if (!BL.test($18.data)) P = this._getOrReturnCtx($18, P), B$(P, { validation: "base64", code: p$.invalid_string, message: _.message }), K.dirty();
    } else if (_.kind === "base64url") {
      if (!tL.test($18.data)) P = this._getOrReturnCtx($18, P), B$(P, { validation: "base64url", code: p$.invalid_string, message: _.message }), K.dirty();
    } else k6.assertNever(_);
    return { status: K.value, value: $18.data };
  }
  _regex($18, q, K) {
    return this.refinement((P) => $18.test(P), { validation: q, code: p$.invalid_string, ...s$.errToObj(K) });
  }
  _addCheck($18) {
    return new _R8({ ...this._def, checks: [...this._def.checks, $18] });
  }
  email($18) {
    return this._addCheck({ kind: "email", ...s$.errToObj($18) });
  }
  url($18) {
    return this._addCheck({ kind: "url", ...s$.errToObj($18) });
  }
  emoji($18) {
    return this._addCheck({ kind: "emoji", ...s$.errToObj($18) });
  }
  uuid($18) {
    return this._addCheck({ kind: "uuid", ...s$.errToObj($18) });
  }
  nanoid($18) {
    return this._addCheck({ kind: "nanoid", ...s$.errToObj($18) });
  }
  cuid($18) {
    return this._addCheck({ kind: "cuid", ...s$.errToObj($18) });
  }
  cuid2($18) {
    return this._addCheck({ kind: "cuid2", ...s$.errToObj($18) });
  }
  ulid($18) {
    return this._addCheck({ kind: "ulid", ...s$.errToObj($18) });
  }
  base64($18) {
    return this._addCheck({ kind: "base64", ...s$.errToObj($18) });
  }
  base64url($18) {
    return this._addCheck({ kind: "base64url", ...s$.errToObj($18) });
  }
  jwt($18) {
    return this._addCheck({ kind: "jwt", ...s$.errToObj($18) });
  }
  ip($18) {
    return this._addCheck({ kind: "ip", ...s$.errToObj($18) });
  }
  cidr($18) {
    return this._addCheck({ kind: "cidr", ...s$.errToObj($18) });
  }
  datetime($18) {
    if (typeof $18 === "string") return this._addCheck({ kind: "datetime", precision: null, offset: false, local: false, message: $18 });
    return this._addCheck({ kind: "datetime", precision: typeof ($18 == null ? void 0 : $18.precision) > "u" ? null : $18 == null ? void 0 : $18.precision, offset: ($18 == null ? void 0 : $18.offset) ?? false, local: ($18 == null ? void 0 : $18.local) ?? false, ...s$.errToObj($18 == null ? void 0 : $18.message) });
  }
  date($18) {
    return this._addCheck({ kind: "date", message: $18 });
  }
  time($18) {
    if (typeof $18 === "string") return this._addCheck({ kind: "time", precision: null, message: $18 });
    return this._addCheck({ kind: "time", precision: typeof ($18 == null ? void 0 : $18.precision) > "u" ? null : $18 == null ? void 0 : $18.precision, ...s$.errToObj($18 == null ? void 0 : $18.message) });
  }
  duration($18) {
    return this._addCheck({ kind: "duration", ...s$.errToObj($18) });
  }
  regex($18, q) {
    return this._addCheck({ kind: "regex", regex: $18, ...s$.errToObj(q) });
  }
  includes($18, q) {
    return this._addCheck({ kind: "includes", value: $18, position: q == null ? void 0 : q.position, ...s$.errToObj(q == null ? void 0 : q.message) });
  }
  startsWith($18, q) {
    return this._addCheck({ kind: "startsWith", value: $18, ...s$.errToObj(q) });
  }
  endsWith($18, q) {
    return this._addCheck({ kind: "endsWith", value: $18, ...s$.errToObj(q) });
  }
  min($18, q) {
    return this._addCheck({ kind: "min", value: $18, ...s$.errToObj(q) });
  }
  max($18, q) {
    return this._addCheck({ kind: "max", value: $18, ...s$.errToObj(q) });
  }
  length($18, q) {
    return this._addCheck({ kind: "length", value: $18, ...s$.errToObj(q) });
  }
  nonempty($18) {
    return this.min(1, s$.errToObj($18));
  }
  trim() {
    return new _R8({ ...this._def, checks: [...this._def.checks, { kind: "trim" }] });
  }
  toLowerCase() {
    return new _R8({ ...this._def, checks: [...this._def.checks, { kind: "toLowerCase" }] });
  }
  toUpperCase() {
    return new _R8({ ...this._def, checks: [...this._def.checks, { kind: "toUpperCase" }] });
  }
  get isDatetime() {
    return !!this._def.checks.find(($18) => $18.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find(($18) => $18.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find(($18) => $18.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find(($18) => $18.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find(($18) => $18.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find(($18) => $18.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find(($18) => $18.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find(($18) => $18.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find(($18) => $18.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find(($18) => $18.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find(($18) => $18.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find(($18) => $18.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find(($18) => $18.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find(($18) => $18.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find(($18) => $18.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find(($18) => $18.kind === "base64url");
  }
  get minLength() {
    let $18 = null;
    for (let q of this._def.checks) if (q.kind === "min") {
      if ($18 === null || q.value > $18) $18 = q.value;
    }
    return $18;
  }
  get maxLength() {
    let $18 = null;
    for (let q of this._def.checks) if (q.kind === "max") {
      if ($18 === null || q.value < $18) $18 = q.value;
    }
    return $18;
  }
};
R8.create = ($18) => {
  return new R8({ checks: [], typeName: c$.ZodString, coerce: ($18 == null ? void 0 : $18.coerce) ?? false, ...z6($18) });
};
function sL($18, q) {
  let K = ($18.toString().split(".")[1] || "").length, P = (q.toString().split(".")[1] || "").length, _ = K > P ? K : P, Y = Number.parseInt($18.toFixed(_).replace(".", "")), O = Number.parseInt(q.toFixed(_).replace(".", ""));
  return Y % O / 10 ** _;
}
var iK = class _iK extends w6 {
  constructor() {
    super(...arguments);
    this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
  }
  _parse($18) {
    if (this._def.coerce) $18.data = Number($18.data);
    if (this._getType($18) !== o$.number) {
      let _ = this._getOrReturnCtx($18);
      return B$(_, { code: p$.invalid_type, expected: o$.number, received: _.parsedType }), q6;
    }
    let K = void 0, P = new kq();
    for (let _ of this._def.checks) if (_.kind === "int") {
      if (!k6.isInteger($18.data)) K = this._getOrReturnCtx($18, K), B$(K, { code: p$.invalid_type, expected: "integer", received: "float", message: _.message }), P.dirty();
    } else if (_.kind === "min") {
      if (_.inclusive ? $18.data < _.value : $18.data <= _.value) K = this._getOrReturnCtx($18, K), B$(K, { code: p$.too_small, minimum: _.value, type: "number", inclusive: _.inclusive, exact: false, message: _.message }), P.dirty();
    } else if (_.kind === "max") {
      if (_.inclusive ? $18.data > _.value : $18.data >= _.value) K = this._getOrReturnCtx($18, K), B$(K, { code: p$.too_big, maximum: _.value, type: "number", inclusive: _.inclusive, exact: false, message: _.message }), P.dirty();
    } else if (_.kind === "multipleOf") {
      if (sL($18.data, _.value) !== 0) K = this._getOrReturnCtx($18, K), B$(K, { code: p$.not_multiple_of, multipleOf: _.value, message: _.message }), P.dirty();
    } else if (_.kind === "finite") {
      if (!Number.isFinite($18.data)) K = this._getOrReturnCtx($18, K), B$(K, { code: p$.not_finite, message: _.message }), P.dirty();
    } else k6.assertNever(_);
    return { status: P.value, value: $18.data };
  }
  gte($18, q) {
    return this.setLimit("min", $18, true, s$.toString(q));
  }
  gt($18, q) {
    return this.setLimit("min", $18, false, s$.toString(q));
  }
  lte($18, q) {
    return this.setLimit("max", $18, true, s$.toString(q));
  }
  lt($18, q) {
    return this.setLimit("max", $18, false, s$.toString(q));
  }
  setLimit($18, q, K, P) {
    return new _iK({ ...this._def, checks: [...this._def.checks, { kind: $18, value: q, inclusive: K, message: s$.toString(P) }] });
  }
  _addCheck($18) {
    return new _iK({ ...this._def, checks: [...this._def.checks, $18] });
  }
  int($18) {
    return this._addCheck({ kind: "int", message: s$.toString($18) });
  }
  positive($18) {
    return this._addCheck({ kind: "min", value: 0, inclusive: false, message: s$.toString($18) });
  }
  negative($18) {
    return this._addCheck({ kind: "max", value: 0, inclusive: false, message: s$.toString($18) });
  }
  nonpositive($18) {
    return this._addCheck({ kind: "max", value: 0, inclusive: true, message: s$.toString($18) });
  }
  nonnegative($18) {
    return this._addCheck({ kind: "min", value: 0, inclusive: true, message: s$.toString($18) });
  }
  multipleOf($18, q) {
    return this._addCheck({ kind: "multipleOf", value: $18, message: s$.toString(q) });
  }
  finite($18) {
    return this._addCheck({ kind: "finite", message: s$.toString($18) });
  }
  safe($18) {
    return this._addCheck({ kind: "min", inclusive: true, value: Number.MIN_SAFE_INTEGER, message: s$.toString($18) })._addCheck({ kind: "max", inclusive: true, value: Number.MAX_SAFE_INTEGER, message: s$.toString($18) });
  }
  get minValue() {
    let $18 = null;
    for (let q of this._def.checks) if (q.kind === "min") {
      if ($18 === null || q.value > $18) $18 = q.value;
    }
    return $18;
  }
  get maxValue() {
    let $18 = null;
    for (let q of this._def.checks) if (q.kind === "max") {
      if ($18 === null || q.value < $18) $18 = q.value;
    }
    return $18;
  }
  get isInt() {
    return !!this._def.checks.find(($18) => $18.kind === "int" || $18.kind === "multipleOf" && k6.isInteger($18.value));
  }
  get isFinite() {
    let $18 = null, q = null;
    for (let K of this._def.checks) if (K.kind === "finite" || K.kind === "int" || K.kind === "multipleOf") return true;
    else if (K.kind === "min") {
      if (q === null || K.value > q) q = K.value;
    } else if (K.kind === "max") {
      if ($18 === null || K.value < $18) $18 = K.value;
    }
    return Number.isFinite(q) && Number.isFinite($18);
  }
};
iK.create = ($18) => {
  return new iK({ checks: [], typeName: c$.ZodNumber, coerce: ($18 == null ? void 0 : $18.coerce) || false, ...z6($18) });
};
var BK = class _BK extends w6 {
  constructor() {
    super(...arguments);
    this.min = this.gte, this.max = this.lte;
  }
  _parse($18) {
    if (this._def.coerce) try {
      $18.data = BigInt($18.data);
    } catch {
      return this._getInvalidInput($18);
    }
    if (this._getType($18) !== o$.bigint) return this._getInvalidInput($18);
    let K = void 0, P = new kq();
    for (let _ of this._def.checks) if (_.kind === "min") {
      if (_.inclusive ? $18.data < _.value : $18.data <= _.value) K = this._getOrReturnCtx($18, K), B$(K, { code: p$.too_small, type: "bigint", minimum: _.value, inclusive: _.inclusive, message: _.message }), P.dirty();
    } else if (_.kind === "max") {
      if (_.inclusive ? $18.data > _.value : $18.data >= _.value) K = this._getOrReturnCtx($18, K), B$(K, { code: p$.too_big, type: "bigint", maximum: _.value, inclusive: _.inclusive, message: _.message }), P.dirty();
    } else if (_.kind === "multipleOf") {
      if ($18.data % _.value !== BigInt(0)) K = this._getOrReturnCtx($18, K), B$(K, { code: p$.not_multiple_of, multipleOf: _.value, message: _.message }), P.dirty();
    } else k6.assertNever(_);
    return { status: P.value, value: $18.data };
  }
  _getInvalidInput($18) {
    let q = this._getOrReturnCtx($18);
    return B$(q, { code: p$.invalid_type, expected: o$.bigint, received: q.parsedType }), q6;
  }
  gte($18, q) {
    return this.setLimit("min", $18, true, s$.toString(q));
  }
  gt($18, q) {
    return this.setLimit("min", $18, false, s$.toString(q));
  }
  lte($18, q) {
    return this.setLimit("max", $18, true, s$.toString(q));
  }
  lt($18, q) {
    return this.setLimit("max", $18, false, s$.toString(q));
  }
  setLimit($18, q, K, P) {
    return new _BK({ ...this._def, checks: [...this._def.checks, { kind: $18, value: q, inclusive: K, message: s$.toString(P) }] });
  }
  _addCheck($18) {
    return new _BK({ ...this._def, checks: [...this._def.checks, $18] });
  }
  positive($18) {
    return this._addCheck({ kind: "min", value: BigInt(0), inclusive: false, message: s$.toString($18) });
  }
  negative($18) {
    return this._addCheck({ kind: "max", value: BigInt(0), inclusive: false, message: s$.toString($18) });
  }
  nonpositive($18) {
    return this._addCheck({ kind: "max", value: BigInt(0), inclusive: true, message: s$.toString($18) });
  }
  nonnegative($18) {
    return this._addCheck({ kind: "min", value: BigInt(0), inclusive: true, message: s$.toString($18) });
  }
  multipleOf($18, q) {
    return this._addCheck({ kind: "multipleOf", value: $18, message: s$.toString(q) });
  }
  get minValue() {
    let $18 = null;
    for (let q of this._def.checks) if (q.kind === "min") {
      if ($18 === null || q.value > $18) $18 = q.value;
    }
    return $18;
  }
  get maxValue() {
    let $18 = null;
    for (let q of this._def.checks) if (q.kind === "max") {
      if ($18 === null || q.value < $18) $18 = q.value;
    }
    return $18;
  }
};
BK.create = ($18) => {
  return new BK({ checks: [], typeName: c$.ZodBigInt, coerce: ($18 == null ? void 0 : $18.coerce) ?? false, ...z6($18) });
};
var H4 = class extends w6 {
  _parse($18) {
    if (this._def.coerce) $18.data = Boolean($18.data);
    if (this._getType($18) !== o$.boolean) {
      let K = this._getOrReturnCtx($18);
      return B$(K, { code: p$.invalid_type, expected: o$.boolean, received: K.parsedType }), q6;
    }
    return Rq($18.data);
  }
};
H4.create = ($18) => {
  return new H4({ typeName: c$.ZodBoolean, coerce: ($18 == null ? void 0 : $18.coerce) || false, ...z6($18) });
};
var A_ = class _A_ extends w6 {
  _parse($18) {
    if (this._def.coerce) $18.data = new Date($18.data);
    if (this._getType($18) !== o$.date) {
      let _ = this._getOrReturnCtx($18);
      return B$(_, { code: p$.invalid_type, expected: o$.date, received: _.parsedType }), q6;
    }
    if (Number.isNaN($18.data.getTime())) {
      let _ = this._getOrReturnCtx($18);
      return B$(_, { code: p$.invalid_date }), q6;
    }
    let K = new kq(), P = void 0;
    for (let _ of this._def.checks) if (_.kind === "min") {
      if ($18.data.getTime() < _.value) P = this._getOrReturnCtx($18, P), B$(P, { code: p$.too_small, message: _.message, inclusive: true, exact: false, minimum: _.value, type: "date" }), K.dirty();
    } else if (_.kind === "max") {
      if ($18.data.getTime() > _.value) P = this._getOrReturnCtx($18, P), B$(P, { code: p$.too_big, message: _.message, inclusive: true, exact: false, maximum: _.value, type: "date" }), K.dirty();
    } else k6.assertNever(_);
    return { status: K.value, value: new Date($18.data.getTime()) };
  }
  _addCheck($18) {
    return new _A_({ ...this._def, checks: [...this._def.checks, $18] });
  }
  min($18, q) {
    return this._addCheck({ kind: "min", value: $18.getTime(), message: s$.toString(q) });
  }
  max($18, q) {
    return this._addCheck({ kind: "max", value: $18.getTime(), message: s$.toString(q) });
  }
  get minDate() {
    let $18 = null;
    for (let q of this._def.checks) if (q.kind === "min") {
      if ($18 === null || q.value > $18) $18 = q.value;
    }
    return $18 != null ? new Date($18) : null;
  }
  get maxDate() {
    let $18 = null;
    for (let q of this._def.checks) if (q.kind === "max") {
      if ($18 === null || q.value < $18) $18 = q.value;
    }
    return $18 != null ? new Date($18) : null;
  }
};
A_.create = ($18) => {
  return new A_({ checks: [], coerce: ($18 == null ? void 0 : $18.coerce) || false, typeName: c$.ZodDate, ...z6($18) });
};
var T7 = class extends w6 {
  _parse($18) {
    if (this._getType($18) !== o$.symbol) {
      let K = this._getOrReturnCtx($18);
      return B$(K, { code: p$.invalid_type, expected: o$.symbol, received: K.parsedType }), q6;
    }
    return Rq($18.data);
  }
};
T7.create = ($18) => {
  return new T7({ typeName: c$.ZodSymbol, ...z6($18) });
};
var J4 = class extends w6 {
  _parse($18) {
    if (this._getType($18) !== o$.undefined) {
      let K = this._getOrReturnCtx($18);
      return B$(K, { code: p$.invalid_type, expected: o$.undefined, received: K.parsedType }), q6;
    }
    return Rq($18.data);
  }
};
J4.create = ($18) => {
  return new J4({ typeName: c$.ZodUndefined, ...z6($18) });
};
var T4 = class extends w6 {
  _parse($18) {
    if (this._getType($18) !== o$.null) {
      let K = this._getOrReturnCtx($18);
      return B$(K, { code: p$.invalid_type, expected: o$.null, received: K.parsedType }), q6;
    }
    return Rq($18.data);
  }
};
T4.create = ($18) => {
  return new T4({ typeName: c$.ZodNull, ...z6($18) });
};
var k_ = class extends w6 {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse($18) {
    return Rq($18.data);
  }
};
k_.create = ($18) => {
  return new k_({ typeName: c$.ZodAny, ...z6($18) });
};
var nK = class extends w6 {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse($18) {
    return Rq($18.data);
  }
};
nK.create = ($18) => {
  return new nK({ typeName: c$.ZodUnknown, ...z6($18) });
};
var i8 = class extends w6 {
  _parse($18) {
    let q = this._getOrReturnCtx($18);
    return B$(q, { code: p$.invalid_type, expected: o$.never, received: q.parsedType }), q6;
  }
};
i8.create = ($18) => {
  return new i8({ typeName: c$.ZodNever, ...z6($18) });
};
var w7 = class extends w6 {
  _parse($18) {
    if (this._getType($18) !== o$.undefined) {
      let K = this._getOrReturnCtx($18);
      return B$(K, { code: p$.invalid_type, expected: o$.void, received: K.parsedType }), q6;
    }
    return Rq($18.data);
  }
};
w7.create = ($18) => {
  return new w7({ typeName: c$.ZodVoid, ...z6($18) });
};
var I8 = class _I8 extends w6 {
  _parse($18) {
    let { ctx: q, status: K } = this._processInputParams($18), P = this._def;
    if (q.parsedType !== o$.array) return B$(q, { code: p$.invalid_type, expected: o$.array, received: q.parsedType }), q6;
    if (P.exactLength !== null) {
      let Y = q.data.length > P.exactLength.value, O = q.data.length < P.exactLength.value;
      if (Y || O) B$(q, { code: Y ? p$.too_big : p$.too_small, minimum: O ? P.exactLength.value : void 0, maximum: Y ? P.exactLength.value : void 0, type: "array", inclusive: true, exact: true, message: P.exactLength.message }), K.dirty();
    }
    if (P.minLength !== null) {
      if (q.data.length < P.minLength.value) B$(q, { code: p$.too_small, minimum: P.minLength.value, type: "array", inclusive: true, exact: false, message: P.minLength.message }), K.dirty();
    }
    if (P.maxLength !== null) {
      if (q.data.length > P.maxLength.value) B$(q, { code: p$.too_big, maximum: P.maxLength.value, type: "array", inclusive: true, exact: false, message: P.maxLength.message }), K.dirty();
    }
    if (q.common.async) return Promise.all([...q.data].map((Y, O) => {
      return P.type._parseAsync(new L8(q, Y, q.path, O));
    })).then((Y) => {
      return kq.mergeArray(K, Y);
    });
    let _ = [...q.data].map((Y, O) => {
      return P.type._parseSync(new L8(q, Y, q.path, O));
    });
    return kq.mergeArray(K, _);
  }
  get element() {
    return this._def.type;
  }
  min($18, q) {
    return new _I8({ ...this._def, minLength: { value: $18, message: s$.toString(q) } });
  }
  max($18, q) {
    return new _I8({ ...this._def, maxLength: { value: $18, message: s$.toString(q) } });
  }
  length($18, q) {
    return new _I8({ ...this._def, exactLength: { value: $18, message: s$.toString(q) } });
  }
  nonempty($18) {
    return this.min(1, $18);
  }
};
I8.create = ($18, q) => {
  return new I8({ type: $18, minLength: null, maxLength: null, exactLength: null, typeName: c$.ZodArray, ...z6(q) });
};
function z4($18) {
  if ($18 instanceof y6) {
    let q = {};
    for (let K in $18.shape) {
      let P = $18.shape[K];
      q[K] = D8.create(z4(P));
    }
    return new y6({ ...$18._def, shape: () => q });
  } else if ($18 instanceof I8) return new I8({ ...$18._def, type: z4($18.element) });
  else if ($18 instanceof D8) return D8.create(z4($18.unwrap()));
  else if ($18 instanceof wK) return wK.create(z4($18.unwrap()));
  else if ($18 instanceof B8) return B8.create($18.items.map((q) => z4(q)));
  else return $18;
}
var y6 = class _y6 extends w6 {
  constructor() {
    super(...arguments);
    this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null) return this._cached;
    let $18 = this._def.shape(), q = k6.objectKeys($18);
    return this._cached = { shape: $18, keys: q }, this._cached;
  }
  _parse($18) {
    if (this._getType($18) !== o$.object) {
      let J = this._getOrReturnCtx($18);
      return B$(J, { code: p$.invalid_type, expected: o$.object, received: J.parsedType }), q6;
    }
    let { status: K, ctx: P } = this._processInputParams($18), { shape: _, keys: Y } = this._getCached(), O = [];
    if (!(this._def.catchall instanceof i8 && this._def.unknownKeys === "strip")) {
      for (let J in P.data) if (!Y.includes(J)) O.push(J);
    }
    let z = [];
    for (let J of Y) {
      let T = _[J], X = P.data[J];
      z.push({ key: { status: "valid", value: J }, value: T._parse(new L8(P, X, P.path, J)), alwaysSet: J in P.data });
    }
    if (this._def.catchall instanceof i8) {
      let J = this._def.unknownKeys;
      if (J === "passthrough") for (let T of O) z.push({ key: { status: "valid", value: T }, value: { status: "valid", value: P.data[T] } });
      else if (J === "strict") {
        if (O.length > 0) B$(P, { code: p$.unrecognized_keys, keys: O }), K.dirty();
      } else if (J === "strip") ;
      else throw Error("Internal ZodObject error: invalid unknownKeys value.");
    } else {
      let J = this._def.catchall;
      for (let T of O) {
        let X = P.data[T];
        z.push({ key: { status: "valid", value: T }, value: J._parse(new L8(P, X, P.path, T)), alwaysSet: T in P.data });
      }
    }
    if (P.common.async) return Promise.resolve().then(async () => {
      let J = [];
      for (let T of z) {
        let X = await T.key, f = await T.value;
        J.push({ key: X, value: f, alwaysSet: T.alwaysSet });
      }
      return J;
    }).then((J) => {
      return kq.mergeObjectSync(K, J);
    });
    else return kq.mergeObjectSync(K, z);
  }
  get shape() {
    return this._def.shape();
  }
  strict($18) {
    return s$.errToObj, new _y6({ ...this._def, unknownKeys: "strict", ...$18 !== void 0 ? { errorMap: (q, K) => {
      var _a2, _b2;
      let P = ((_b2 = (_a2 = this._def).errorMap) == null ? void 0 : _b2.call(_a2, q, K).message) ?? K.defaultError;
      if (q.code === "unrecognized_keys") return { message: s$.errToObj($18).message ?? P };
      return { message: P };
    } } : {} });
  }
  strip() {
    return new _y6({ ...this._def, unknownKeys: "strip" });
  }
  passthrough() {
    return new _y6({ ...this._def, unknownKeys: "passthrough" });
  }
  extend($18) {
    return new _y6({ ...this._def, shape: () => ({ ...this._def.shape(), ...$18 }) });
  }
  merge($18) {
    return new _y6({ unknownKeys: $18._def.unknownKeys, catchall: $18._def.catchall, shape: () => ({ ...this._def.shape(), ...$18._def.shape() }), typeName: c$.ZodObject });
  }
  setKey($18, q) {
    return this.augment({ [$18]: q });
  }
  catchall($18) {
    return new _y6({ ...this._def, catchall: $18 });
  }
  pick($18) {
    let q = {};
    for (let K of k6.objectKeys($18)) if ($18[K] && this.shape[K]) q[K] = this.shape[K];
    return new _y6({ ...this._def, shape: () => q });
  }
  omit($18) {
    let q = {};
    for (let K of k6.objectKeys(this.shape)) if (!$18[K]) q[K] = this.shape[K];
    return new _y6({ ...this._def, shape: () => q });
  }
  deepPartial() {
    return z4(this);
  }
  partial($18) {
    let q = {};
    for (let K of k6.objectKeys(this.shape)) {
      let P = this.shape[K];
      if ($18 && !$18[K]) q[K] = P;
      else q[K] = P.optional();
    }
    return new _y6({ ...this._def, shape: () => q });
  }
  required($18) {
    let q = {};
    for (let K of k6.objectKeys(this.shape)) if ($18 && !$18[K]) q[K] = this.shape[K];
    else {
      let _ = this.shape[K];
      while (_ instanceof D8) _ = _._def.innerType;
      q[K] = _;
    }
    return new _y6({ ...this._def, shape: () => q });
  }
  keyof() {
    return kA(k6.objectKeys(this.shape));
  }
};
y6.create = ($18, q) => {
  return new y6({ shape: () => $18, unknownKeys: "strip", catchall: i8.create(), typeName: c$.ZodObject, ...z6(q) });
};
y6.strictCreate = ($18, q) => {
  return new y6({ shape: () => $18, unknownKeys: "strict", catchall: i8.create(), typeName: c$.ZodObject, ...z6(q) });
};
y6.lazycreate = ($18, q) => {
  return new y6({ shape: $18, unknownKeys: "strip", catchall: i8.create(), typeName: c$.ZodObject, ...z6(q) });
};
var w4 = class extends w6 {
  _parse($18) {
    let { ctx: q } = this._processInputParams($18), K = this._def.options;
    function P(_) {
      for (let O of _) if (O.result.status === "valid") return O.result;
      for (let O of _) if (O.result.status === "dirty") return q.common.issues.push(...O.ctx.common.issues), O.result;
      let Y = _.map((O) => new aq(O.ctx.common.issues));
      return B$(q, { code: p$.invalid_union, unionErrors: Y }), q6;
    }
    if (q.common.async) return Promise.all(K.map(async (_) => {
      let Y = { ...q, common: { ...q.common, issues: [] }, parent: null };
      return { result: await _._parseAsync({ data: q.data, path: q.path, parent: Y }), ctx: Y };
    })).then(P);
    else {
      let _ = void 0, Y = [];
      for (let z of K) {
        let J = { ...q, common: { ...q.common, issues: [] }, parent: null }, T = z._parseSync({ data: q.data, path: q.path, parent: J });
        if (T.status === "valid") return T;
        else if (T.status === "dirty" && !_) _ = { result: T, ctx: J };
        if (J.common.issues.length) Y.push(J.common.issues);
      }
      if (_) return q.common.issues.push(..._.ctx.common.issues), _.result;
      let O = Y.map((z) => new aq(z));
      return B$(q, { code: p$.invalid_union, unionErrors: O }), q6;
    }
  }
  get options() {
    return this._def.options;
  }
};
w4.create = ($18, q) => {
  return new w4({ options: $18, typeName: c$.ZodUnion, ...z6(q) });
};
var TK = ($18) => {
  if ($18 instanceof Z4) return TK($18.schema);
  else if ($18 instanceof g8) return TK($18.innerType());
  else if ($18 instanceof X4) return [$18.value];
  else if ($18 instanceof tK) return $18.options;
  else if ($18 instanceof A4) return k6.objectValues($18.enum);
  else if ($18 instanceof k4) return TK($18._def.innerType);
  else if ($18 instanceof J4) return [void 0];
  else if ($18 instanceof T4) return [null];
  else if ($18 instanceof D8) return [void 0, ...TK($18.unwrap())];
  else if ($18 instanceof wK) return [null, ...TK($18.unwrap())];
  else if ($18 instanceof W5) return TK($18.unwrap());
  else if ($18 instanceof V4) return TK($18.unwrap());
  else if ($18 instanceof G4) return TK($18._def.innerType);
  else return [];
};
var z5 = class _z5 extends w6 {
  _parse($18) {
    let { ctx: q } = this._processInputParams($18);
    if (q.parsedType !== o$.object) return B$(q, { code: p$.invalid_type, expected: o$.object, received: q.parsedType }), q6;
    let K = this.discriminator, P = q.data[K], _ = this.optionsMap.get(P);
    if (!_) return B$(q, { code: p$.invalid_union_discriminator, options: Array.from(this.optionsMap.keys()), path: [K] }), q6;
    if (q.common.async) return _._parseAsync({ data: q.data, path: q.path, parent: q });
    else return _._parseSync({ data: q.data, path: q.path, parent: q });
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  static create($18, q, K) {
    let P = /* @__PURE__ */ new Map();
    for (let _ of q) {
      let Y = TK(_.shape[$18]);
      if (!Y.length) throw Error(`A discriminator value for key \`${$18}\` could not be extracted from all schema options`);
      for (let O of Y) {
        if (P.has(O)) throw Error(`Discriminator property ${String($18)} has duplicate value ${String(O)}`);
        P.set(O, _);
      }
    }
    return new _z5({ typeName: c$.ZodDiscriminatedUnion, discriminator: $18, options: q, optionsMap: P, ...z6(K) });
  }
};
function pv($18, q) {
  let K = n8($18), P = n8(q);
  if ($18 === q) return { valid: true, data: $18 };
  else if (K === o$.object && P === o$.object) {
    let _ = k6.objectKeys(q), Y = k6.objectKeys($18).filter((z) => _.indexOf(z) !== -1), O = { ...$18, ...q };
    for (let z of Y) {
      let J = pv($18[z], q[z]);
      if (!J.valid) return { valid: false };
      O[z] = J.data;
    }
    return { valid: true, data: O };
  } else if (K === o$.array && P === o$.array) {
    if ($18.length !== q.length) return { valid: false };
    let _ = [];
    for (let Y = 0; Y < $18.length; Y++) {
      let O = $18[Y], z = q[Y], J = pv(O, z);
      if (!J.valid) return { valid: false };
      _.push(J.data);
    }
    return { valid: true, data: _ };
  } else if (K === o$.date && P === o$.date && +$18 === +q) return { valid: true, data: $18 };
  else return { valid: false };
}
var f4 = class extends w6 {
  _parse($18) {
    let { status: q, ctx: K } = this._processInputParams($18), P = (_, Y) => {
      if (j5(_) || j5(Y)) return q6;
      let O = pv(_.value, Y.value);
      if (!O.valid) return B$(K, { code: p$.invalid_intersection_types }), q6;
      if (v5(_) || v5(Y)) q.dirty();
      return { status: q.value, value: O.data };
    };
    if (K.common.async) return Promise.all([this._def.left._parseAsync({ data: K.data, path: K.path, parent: K }), this._def.right._parseAsync({ data: K.data, path: K.path, parent: K })]).then(([_, Y]) => P(_, Y));
    else return P(this._def.left._parseSync({ data: K.data, path: K.path, parent: K }), this._def.right._parseSync({ data: K.data, path: K.path, parent: K }));
  }
};
f4.create = ($18, q, K) => {
  return new f4({ left: $18, right: q, typeName: c$.ZodIntersection, ...z6(K) });
};
var B8 = class _B8 extends w6 {
  _parse($18) {
    let { status: q, ctx: K } = this._processInputParams($18);
    if (K.parsedType !== o$.array) return B$(K, { code: p$.invalid_type, expected: o$.array, received: K.parsedType }), q6;
    if (K.data.length < this._def.items.length) return B$(K, { code: p$.too_small, minimum: this._def.items.length, inclusive: true, exact: false, type: "array" }), q6;
    if (!this._def.rest && K.data.length > this._def.items.length) B$(K, { code: p$.too_big, maximum: this._def.items.length, inclusive: true, exact: false, type: "array" }), q.dirty();
    let _ = [...K.data].map((Y, O) => {
      let z = this._def.items[O] || this._def.rest;
      if (!z) return null;
      return z._parse(new L8(K, Y, K.path, O));
    }).filter((Y) => !!Y);
    if (K.common.async) return Promise.all(_).then((Y) => {
      return kq.mergeArray(q, Y);
    });
    else return kq.mergeArray(q, _);
  }
  get items() {
    return this._def.items;
  }
  rest($18) {
    return new _B8({ ...this._def, rest: $18 });
  }
};
B8.create = ($18, q) => {
  if (!Array.isArray($18)) throw Error("You must pass an array of schemas to z.tuple([ ... ])");
  return new B8({ items: $18, typeName: c$.ZodTuple, rest: null, ...z6(q) });
};
var f7 = class _f7 extends w6 {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse($18) {
    let { status: q, ctx: K } = this._processInputParams($18);
    if (K.parsedType !== o$.object) return B$(K, { code: p$.invalid_type, expected: o$.object, received: K.parsedType }), q6;
    let P = [], _ = this._def.keyType, Y = this._def.valueType;
    for (let O in K.data) P.push({ key: _._parse(new L8(K, O, K.path, O)), value: Y._parse(new L8(K, K.data[O], K.path, O)), alwaysSet: O in K.data });
    if (K.common.async) return kq.mergeObjectAsync(q, P);
    else return kq.mergeObjectSync(q, P);
  }
  get element() {
    return this._def.valueType;
  }
  static create($18, q, K) {
    if (q instanceof w6) return new _f7({ keyType: $18, valueType: q, typeName: c$.ZodRecord, ...z6(K) });
    return new _f7({ keyType: R8.create(), valueType: $18, typeName: c$.ZodRecord, ...z6(q) });
  }
};
var Z7 = class extends w6 {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse($18) {
    let { status: q, ctx: K } = this._processInputParams($18);
    if (K.parsedType !== o$.map) return B$(K, { code: p$.invalid_type, expected: o$.map, received: K.parsedType }), q6;
    let P = this._def.keyType, _ = this._def.valueType, Y = [...K.data.entries()].map(([O, z], J) => {
      return { key: P._parse(new L8(K, O, K.path, [J, "key"])), value: _._parse(new L8(K, z, K.path, [J, "value"])) };
    });
    if (K.common.async) {
      let O = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (let z of Y) {
          let J = await z.key, T = await z.value;
          if (J.status === "aborted" || T.status === "aborted") return q6;
          if (J.status === "dirty" || T.status === "dirty") q.dirty();
          O.set(J.value, T.value);
        }
        return { status: q.value, value: O };
      });
    } else {
      let O = /* @__PURE__ */ new Map();
      for (let z of Y) {
        let { key: J, value: T } = z;
        if (J.status === "aborted" || T.status === "aborted") return q6;
        if (J.status === "dirty" || T.status === "dirty") q.dirty();
        O.set(J.value, T.value);
      }
      return { status: q.value, value: O };
    }
  }
};
Z7.create = ($18, q, K) => {
  return new Z7({ valueType: q, keyType: $18, typeName: c$.ZodMap, ...z6(K) });
};
var G_ = class _G_ extends w6 {
  _parse($18) {
    let { status: q, ctx: K } = this._processInputParams($18);
    if (K.parsedType !== o$.set) return B$(K, { code: p$.invalid_type, expected: o$.set, received: K.parsedType }), q6;
    let P = this._def;
    if (P.minSize !== null) {
      if (K.data.size < P.minSize.value) B$(K, { code: p$.too_small, minimum: P.minSize.value, type: "set", inclusive: true, exact: false, message: P.minSize.message }), q.dirty();
    }
    if (P.maxSize !== null) {
      if (K.data.size > P.maxSize.value) B$(K, { code: p$.too_big, maximum: P.maxSize.value, type: "set", inclusive: true, exact: false, message: P.maxSize.message }), q.dirty();
    }
    let _ = this._def.valueType;
    function Y(z) {
      let J = /* @__PURE__ */ new Set();
      for (let T of z) {
        if (T.status === "aborted") return q6;
        if (T.status === "dirty") q.dirty();
        J.add(T.value);
      }
      return { status: q.value, value: J };
    }
    let O = [...K.data.values()].map((z, J) => _._parse(new L8(K, z, K.path, J)));
    if (K.common.async) return Promise.all(O).then((z) => Y(z));
    else return Y(O);
  }
  min($18, q) {
    return new _G_({ ...this._def, minSize: { value: $18, message: s$.toString(q) } });
  }
  max($18, q) {
    return new _G_({ ...this._def, maxSize: { value: $18, message: s$.toString(q) } });
  }
  size($18, q) {
    return this.min($18, q).max($18, q);
  }
  nonempty($18) {
    return this.min(1, $18);
  }
};
G_.create = ($18, q) => {
  return new G_({ valueType: $18, minSize: null, maxSize: null, typeName: c$.ZodSet, ...z6(q) });
};
var W4 = class _W4 extends w6 {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse($18) {
    let { ctx: q } = this._processInputParams($18);
    if (q.parsedType !== o$.function) return B$(q, { code: p$.invalid_type, expected: o$.function, received: q.parsedType }), q6;
    function K(O, z) {
      return J7({ data: O, path: q.path, errorMaps: [q.common.contextualErrorMap, q.schemaErrorMap, j4(), JK].filter((J) => !!J), issueData: { code: p$.invalid_arguments, argumentsError: z } });
    }
    function P(O, z) {
      return J7({ data: O, path: q.path, errorMaps: [q.common.contextualErrorMap, q.schemaErrorMap, j4(), JK].filter((J) => !!J), issueData: { code: p$.invalid_return_type, returnTypeError: z } });
    }
    let _ = { errorMap: q.common.contextualErrorMap }, Y = q.data;
    if (this._def.returns instanceof V_) {
      let O = this;
      return Rq(async function(...z) {
        let J = new aq([]), T = await O._def.args.parseAsync(z, _).catch((V) => {
          throw J.addIssue(K(z, V)), J;
        }), X = await Reflect.apply(Y, this, T);
        return await O._def.returns._def.type.parseAsync(X, _).catch((V) => {
          throw J.addIssue(P(X, V)), J;
        });
      });
    } else {
      let O = this;
      return Rq(function(...z) {
        let J = O._def.args.safeParse(z, _);
        if (!J.success) throw new aq([K(z, J.error)]);
        let T = Reflect.apply(Y, this, J.data), X = O._def.returns.safeParse(T, _);
        if (!X.success) throw new aq([P(T, X.error)]);
        return X.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...$18) {
    return new _W4({ ...this._def, args: B8.create($18).rest(nK.create()) });
  }
  returns($18) {
    return new _W4({ ...this._def, returns: $18 });
  }
  implement($18) {
    return this.parse($18);
  }
  strictImplement($18) {
    return this.parse($18);
  }
  static create($18, q, K) {
    return new _W4({ args: $18 ? $18 : B8.create([]).rest(nK.create()), returns: q || nK.create(), typeName: c$.ZodFunction, ...z6(K) });
  }
};
var Z4 = class extends w6 {
  get schema() {
    return this._def.getter();
  }
  _parse($18) {
    let { ctx: q } = this._processInputParams($18);
    return this._def.getter()._parse({ data: q.data, path: q.path, parent: q });
  }
};
Z4.create = ($18, q) => {
  return new Z4({ getter: $18, typeName: c$.ZodLazy, ...z6(q) });
};
var X4 = class extends w6 {
  _parse($18) {
    if ($18.data !== this._def.value) {
      let q = this._getOrReturnCtx($18);
      return B$(q, { received: q.data, code: p$.invalid_literal, expected: this._def.value }), q6;
    }
    return { status: "valid", value: $18.data };
  }
  get value() {
    return this._def.value;
  }
};
X4.create = ($18, q) => {
  return new X4({ value: $18, typeName: c$.ZodLiteral, ...z6(q) });
};
function kA($18, q) {
  return new tK({ values: $18, typeName: c$.ZodEnum, ...z6(q) });
}
var tK = class _tK extends w6 {
  _parse($18) {
    if (typeof $18.data !== "string") {
      let q = this._getOrReturnCtx($18), K = this._def.values;
      return B$(q, { expected: k6.joinValues(K), received: q.parsedType, code: p$.invalid_type }), q6;
    }
    if (!this._cache) this._cache = new Set(this._def.values);
    if (!this._cache.has($18.data)) {
      let q = this._getOrReturnCtx($18), K = this._def.values;
      return B$(q, { received: q.data, code: p$.invalid_enum_value, options: K }), q6;
    }
    return Rq($18.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    let $18 = {};
    for (let q of this._def.values) $18[q] = q;
    return $18;
  }
  get Values() {
    let $18 = {};
    for (let q of this._def.values) $18[q] = q;
    return $18;
  }
  get Enum() {
    let $18 = {};
    for (let q of this._def.values) $18[q] = q;
    return $18;
  }
  extract($18, q = this._def) {
    return _tK.create($18, { ...this._def, ...q });
  }
  exclude($18, q = this._def) {
    return _tK.create(this.options.filter((K) => !$18.includes(K)), { ...this._def, ...q });
  }
};
tK.create = kA;
var A4 = class extends w6 {
  _parse($18) {
    let q = k6.getValidEnumValues(this._def.values), K = this._getOrReturnCtx($18);
    if (K.parsedType !== o$.string && K.parsedType !== o$.number) {
      let P = k6.objectValues(q);
      return B$(K, { expected: k6.joinValues(P), received: K.parsedType, code: p$.invalid_type }), q6;
    }
    if (!this._cache) this._cache = new Set(k6.getValidEnumValues(this._def.values));
    if (!this._cache.has($18.data)) {
      let P = k6.objectValues(q);
      return B$(K, { received: K.data, code: p$.invalid_enum_value, options: P }), q6;
    }
    return Rq($18.data);
  }
  get enum() {
    return this._def.values;
  }
};
A4.create = ($18, q) => {
  return new A4({ values: $18, typeName: c$.ZodNativeEnum, ...z6(q) });
};
var V_ = class extends w6 {
  unwrap() {
    return this._def.type;
  }
  _parse($18) {
    let { ctx: q } = this._processInputParams($18);
    if (q.parsedType !== o$.promise && q.common.async === false) return B$(q, { code: p$.invalid_type, expected: o$.promise, received: q.parsedType }), q6;
    let K = q.parsedType === o$.promise ? q.data : Promise.resolve(q.data);
    return Rq(K.then((P) => {
      return this._def.type.parseAsync(P, { path: q.path, errorMap: q.common.contextualErrorMap });
    }));
  }
};
V_.create = ($18, q) => {
  return new V_({ type: $18, typeName: c$.ZodPromise, ...z6(q) });
};
var g8 = class extends w6 {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === c$.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse($18) {
    let { status: q, ctx: K } = this._processInputParams($18), P = this._def.effect || null, _ = { addIssue: (Y) => {
      if (B$(K, Y), Y.fatal) q.abort();
      else q.dirty();
    }, get path() {
      return K.path;
    } };
    if (_.addIssue = _.addIssue.bind(_), P.type === "preprocess") {
      let Y = P.transform(K.data, _);
      if (K.common.async) return Promise.resolve(Y).then(async (O) => {
        if (q.value === "aborted") return q6;
        let z = await this._def.schema._parseAsync({ data: O, path: K.path, parent: K });
        if (z.status === "aborted") return q6;
        if (z.status === "dirty") return X_(z.value);
        if (q.value === "dirty") return X_(z.value);
        return z;
      });
      else {
        if (q.value === "aborted") return q6;
        let O = this._def.schema._parseSync({ data: Y, path: K.path, parent: K });
        if (O.status === "aborted") return q6;
        if (O.status === "dirty") return X_(O.value);
        if (q.value === "dirty") return X_(O.value);
        return O;
      }
    }
    if (P.type === "refinement") {
      let Y = (O) => {
        let z = P.refinement(O, _);
        if (K.common.async) return Promise.resolve(z);
        if (z instanceof Promise) throw Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        return O;
      };
      if (K.common.async === false) {
        let O = this._def.schema._parseSync({ data: K.data, path: K.path, parent: K });
        if (O.status === "aborted") return q6;
        if (O.status === "dirty") q.dirty();
        return Y(O.value), { status: q.value, value: O.value };
      } else return this._def.schema._parseAsync({ data: K.data, path: K.path, parent: K }).then((O) => {
        if (O.status === "aborted") return q6;
        if (O.status === "dirty") q.dirty();
        return Y(O.value).then(() => {
          return { status: q.value, value: O.value };
        });
      });
    }
    if (P.type === "transform") if (K.common.async === false) {
      let Y = this._def.schema._parseSync({ data: K.data, path: K.path, parent: K });
      if (!oK(Y)) return q6;
      let O = P.transform(Y.value, _);
      if (O instanceof Promise) throw Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
      return { status: q.value, value: O };
    } else return this._def.schema._parseAsync({ data: K.data, path: K.path, parent: K }).then((Y) => {
      if (!oK(Y)) return q6;
      return Promise.resolve(P.transform(Y.value, _)).then((O) => ({ status: q.value, value: O }));
    });
    k6.assertNever(P);
  }
};
g8.create = ($18, q, K) => {
  return new g8({ schema: $18, typeName: c$.ZodEffects, effect: q, ...z6(K) });
};
g8.createWithPreprocess = ($18, q, K) => {
  return new g8({ schema: q, effect: { type: "preprocess", transform: $18 }, typeName: c$.ZodEffects, ...z6(K) });
};
var D8 = class extends w6 {
  _parse($18) {
    if (this._getType($18) === o$.undefined) return Rq(void 0);
    return this._def.innerType._parse($18);
  }
  unwrap() {
    return this._def.innerType;
  }
};
D8.create = ($18, q) => {
  return new D8({ innerType: $18, typeName: c$.ZodOptional, ...z6(q) });
};
var wK = class extends w6 {
  _parse($18) {
    if (this._getType($18) === o$.null) return Rq(null);
    return this._def.innerType._parse($18);
  }
  unwrap() {
    return this._def.innerType;
  }
};
wK.create = ($18, q) => {
  return new wK({ innerType: $18, typeName: c$.ZodNullable, ...z6(q) });
};
var k4 = class extends w6 {
  _parse($18) {
    let { ctx: q } = this._processInputParams($18), K = q.data;
    if (q.parsedType === o$.undefined) K = this._def.defaultValue();
    return this._def.innerType._parse({ data: K, path: q.path, parent: q });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
k4.create = ($18, q) => {
  return new k4({ innerType: $18, typeName: c$.ZodDefault, defaultValue: typeof q.default === "function" ? q.default : () => q.default, ...z6(q) });
};
var G4 = class extends w6 {
  _parse($18) {
    let { ctx: q } = this._processInputParams($18), K = { ...q, common: { ...q.common, issues: [] } }, P = this._def.innerType._parse({ data: K.data, path: K.path, parent: { ...K } });
    if (v4(P)) return P.then((_) => {
      return { status: "valid", value: _.status === "valid" ? _.value : this._def.catchValue({ get error() {
        return new aq(K.common.issues);
      }, input: K.data }) };
    });
    else return { status: "valid", value: P.status === "valid" ? P.value : this._def.catchValue({ get error() {
      return new aq(K.common.issues);
    }, input: K.data }) };
  }
  removeCatch() {
    return this._def.innerType;
  }
};
G4.create = ($18, q) => {
  return new G4({ innerType: $18, typeName: c$.ZodCatch, catchValue: typeof q.catch === "function" ? q.catch : () => q.catch, ...z6(q) });
};
var X7 = class extends w6 {
  _parse($18) {
    if (this._getType($18) !== o$.nan) {
      let K = this._getOrReturnCtx($18);
      return B$(K, { code: p$.invalid_type, expected: o$.nan, received: K.parsedType }), q6;
    }
    return { status: "valid", value: $18.data };
  }
};
X7.create = ($18) => {
  return new X7({ typeName: c$.ZodNaN, ...z6($18) });
};
var $g = Symbol("zod_brand");
var W5 = class extends w6 {
  _parse($18) {
    let { ctx: q } = this._processInputParams($18), K = q.data;
    return this._def.type._parse({ data: K, path: q.path, parent: q });
  }
  unwrap() {
    return this._def.type;
  }
};
var A7 = class _A7 extends w6 {
  _parse($18) {
    let { status: q, ctx: K } = this._processInputParams($18);
    if (K.common.async) return (async () => {
      let _ = await this._def.in._parseAsync({ data: K.data, path: K.path, parent: K });
      if (_.status === "aborted") return q6;
      if (_.status === "dirty") return q.dirty(), X_(_.value);
      else return this._def.out._parseAsync({ data: _.value, path: K.path, parent: K });
    })();
    else {
      let P = this._def.in._parseSync({ data: K.data, path: K.path, parent: K });
      if (P.status === "aborted") return q6;
      if (P.status === "dirty") return q.dirty(), { status: "dirty", value: P.value };
      else return this._def.out._parseSync({ data: P.value, path: K.path, parent: K });
    }
  }
  static create($18, q) {
    return new _A7({ in: $18, out: q, typeName: c$.ZodPipeline });
  }
};
var V4 = class extends w6 {
  _parse($18) {
    let q = this._def.innerType._parse($18), K = (P) => {
      if (oK(P)) P.value = Object.freeze(P.value);
      return P;
    };
    return v4(q) ? q.then((P) => K(P)) : K(q);
  }
  unwrap() {
    return this._def.innerType;
  }
};
V4.create = ($18, q) => {
  return new V4({ innerType: $18, typeName: c$.ZodReadonly, ...z6(q) });
};
function fA($18, q) {
  let K = typeof $18 === "function" ? $18(q) : typeof $18 === "string" ? { message: $18 } : $18;
  return typeof K === "string" ? { message: K } : K;
}
function GA($18, q = {}, K) {
  if ($18) return k_.create().superRefine((P, _) => {
    let Y = $18(P);
    if (Y instanceof Promise) return Y.then((O) => {
      if (!O) {
        let z = fA(q, P), J = z.fatal ?? K ?? true;
        _.addIssue({ code: "custom", ...z, fatal: J });
      }
    });
    if (!Y) {
      let O = fA(q, P), z = O.fatal ?? K ?? true;
      _.addIssue({ code: "custom", ...O, fatal: z });
    }
    return;
  });
  return k_.create();
}
var qg = { object: y6.lazycreate };
var c$;
(function($18) {
  $18.ZodString = "ZodString", $18.ZodNumber = "ZodNumber", $18.ZodNaN = "ZodNaN", $18.ZodBigInt = "ZodBigInt", $18.ZodBoolean = "ZodBoolean", $18.ZodDate = "ZodDate", $18.ZodSymbol = "ZodSymbol", $18.ZodUndefined = "ZodUndefined", $18.ZodNull = "ZodNull", $18.ZodAny = "ZodAny", $18.ZodUnknown = "ZodUnknown", $18.ZodNever = "ZodNever", $18.ZodVoid = "ZodVoid", $18.ZodArray = "ZodArray", $18.ZodObject = "ZodObject", $18.ZodUnion = "ZodUnion", $18.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", $18.ZodIntersection = "ZodIntersection", $18.ZodTuple = "ZodTuple", $18.ZodRecord = "ZodRecord", $18.ZodMap = "ZodMap", $18.ZodSet = "ZodSet", $18.ZodFunction = "ZodFunction", $18.ZodLazy = "ZodLazy", $18.ZodLiteral = "ZodLiteral", $18.ZodEnum = "ZodEnum", $18.ZodEffects = "ZodEffects", $18.ZodNativeEnum = "ZodNativeEnum", $18.ZodOptional = "ZodOptional", $18.ZodNullable = "ZodNullable", $18.ZodDefault = "ZodDefault", $18.ZodCatch = "ZodCatch", $18.ZodPromise = "ZodPromise", $18.ZodBranded = "ZodBranded", $18.ZodPipeline = "ZodPipeline", $18.ZodReadonly = "ZodReadonly";
})(c$ || (c$ = {}));
var Kg = ($18, q = { message: `Input not instance of ${$18.name}` }) => GA((K) => K instanceof $18, q);
var VA = R8.create;
var SA = iK.create;
var _g = X7.create;
var Pg = BK.create;
var MA = H4.create;
var Og = A_.create;
var Yg = T7.create;
var jg = J4.create;
var vg = T4.create;
var zg = k_.create;
var Wg = nK.create;
var Hg = i8.create;
var Jg = w7.create;
var Tg = I8.create;
var wg = y6.create;
var fg = y6.strictCreate;
var Zg = w4.create;
var Xg = z5.create;
var Ag = f4.create;
var kg = B8.create;
var Gg = f7.create;
var Vg = Z7.create;
var Sg = G_.create;
var Mg = W4.create;
var Ng = Z4.create;
var Cg = X4.create;
var Eg = tK.create;
var hg = A4.create;
var Rg = V_.create;
var Ig = g8.create;
var Dg = D8.create;
var Lg = wK.create;
var gg = g8.createWithPreprocess;
var bg = A7.create;
var yg = () => VA().optional();
var ug = () => SA().optional();
var xg = () => MA().optional();
var pg = { string: ($18) => R8.create({ ...$18, coerce: true }), number: ($18) => iK.create({ ...$18, coerce: true }), boolean: ($18) => H4.create({ ...$18, coerce: true }), bigint: ($18) => BK.create({ ...$18, coerce: true }), date: ($18) => A_.create({ ...$18, coerce: true }) };
var cg = q6;
function cv($18, q) {
  var _a2, _b2, _c;
  let K = { type: "array" };
  if (((_a2 = $18.type) == null ? void 0 : _a2._def) && ((_c = (_b2 = $18.type) == null ? void 0 : _b2._def) == null ? void 0 : _c.typeName) !== c$.ZodAny) K.items = K6($18.type._def, { ...q, currentPath: [...q.currentPath, "items"] });
  if ($18.minLength) G6(K, "minItems", $18.minLength.value, $18.minLength.message, q);
  if ($18.maxLength) G6(K, "maxItems", $18.maxLength.value, $18.maxLength.message, q);
  if ($18.exactLength) G6(K, "minItems", $18.exactLength.value, $18.exactLength.message, q), G6(K, "maxItems", $18.exactLength.value, $18.exactLength.message, q);
  return K;
}
function mv($18, q) {
  let K = { type: "integer", format: "int64" };
  if (!$18.checks) return K;
  for (let P of $18.checks) switch (P.kind) {
    case "min":
      if (q.target === "jsonSchema7") if (P.inclusive) G6(K, "minimum", P.value, P.message, q);
      else G6(K, "exclusiveMinimum", P.value, P.message, q);
      else {
        if (!P.inclusive) K.exclusiveMinimum = true;
        G6(K, "minimum", P.value, P.message, q);
      }
      break;
    case "max":
      if (q.target === "jsonSchema7") if (P.inclusive) G6(K, "maximum", P.value, P.message, q);
      else G6(K, "exclusiveMaximum", P.value, P.message, q);
      else {
        if (!P.inclusive) K.exclusiveMaximum = true;
        G6(K, "maximum", P.value, P.message, q);
      }
      break;
    case "multipleOf":
      G6(K, "multipleOf", P.value, P.message, q);
      break;
  }
  return K;
}
function dv() {
  return { type: "boolean" };
}
function k7($18, q) {
  return K6($18.type._def, q);
}
var lv = ($18, q) => {
  return K6($18.innerType._def, q);
};
function H5($18, q, K) {
  let P = K ?? q.dateStrategy;
  if (Array.isArray(P)) return { anyOf: P.map((_) => H5($18, q, _)) };
  switch (P) {
    case "string":
    case "format:date-time":
      return { type: "string", format: "date-time" };
    case "format:date":
      return { type: "string", format: "date" };
    case "integer":
      return mg($18, q);
  }
}
var mg = ($18, q) => {
  let K = { type: "integer", format: "unix-time" };
  if (q.target === "openApi3") return K;
  for (let P of $18.checks) switch (P.kind) {
    case "min":
      G6(K, "minimum", P.value, P.message, q);
      break;
    case "max":
      G6(K, "maximum", P.value, P.message, q);
      break;
  }
  return K;
};
function rv($18, q) {
  return { ...K6($18.innerType._def, q), default: $18.defaultValue() };
}
function ov($18, q) {
  return q.effectStrategy === "input" ? K6($18.schema._def, q) : D6(q);
}
function nv($18) {
  return { type: "string", enum: Array.from($18.values) };
}
var dg = ($18) => {
  if ("type" in $18 && $18.type === "string") return false;
  return "allOf" in $18;
};
function iv($18, q) {
  let K = [K6($18.left._def, { ...q, currentPath: [...q.currentPath, "allOf", "0"] }), K6($18.right._def, { ...q, currentPath: [...q.currentPath, "allOf", "1"] })].filter((Y) => !!Y), P = q.target === "jsonSchema2019-09" ? { unevaluatedProperties: false } : void 0, _ = [];
  return K.forEach((Y) => {
    if (dg(Y)) {
      if (_.push(...Y.allOf), Y.unevaluatedProperties === void 0) P = void 0;
    } else {
      let O = Y;
      if ("additionalProperties" in Y && Y.additionalProperties === false) {
        let { additionalProperties: z, ...J } = Y;
        O = J;
      } else P = void 0;
      _.push(O);
    }
  }), _.length ? { allOf: _, ...P } : void 0;
}
function Bv($18, q) {
  let K = typeof $18.value;
  if (K !== "bigint" && K !== "number" && K !== "boolean" && K !== "string") return { type: Array.isArray($18.value) ? "array" : "object" };
  if (q.target === "openApi3") return { type: K === "bigint" ? "integer" : K, enum: [$18.value] };
  return { type: K === "bigint" ? "integer" : K, const: $18.value };
}
var tv = void 0;
var X8 = { cuid: /^[cC][^\s-]{8,}$/, cuid2: /^[0-9a-z]+$/, ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/, email: /^(?!\.)(?!.*\.\.)([a-zA-Z0-9_'+\-\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\-]*\.)+[a-zA-Z]{2,}$/, emoji: () => {
  if (tv === void 0) tv = RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", "u");
  return tv;
}, uuid: /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/, ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/, ipv4Cidr: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/, ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/, ipv6Cidr: /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/, base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/, base64url: /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/, nanoid: /^[a-zA-Z0-9_-]{21}$/, jwt: /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/ };
function G7($18, q) {
  let K = { type: "string" };
  if ($18.checks) for (let P of $18.checks) switch (P.kind) {
    case "min":
      G6(K, "minLength", typeof K.minLength === "number" ? Math.max(K.minLength, P.value) : P.value, P.message, q);
      break;
    case "max":
      G6(K, "maxLength", typeof K.maxLength === "number" ? Math.min(K.maxLength, P.value) : P.value, P.message, q);
      break;
    case "email":
      switch (q.emailStrategy) {
        case "format:email":
          b8(K, "email", P.message, q);
          break;
        case "format:idn-email":
          b8(K, "idn-email", P.message, q);
          break;
        case "pattern:zod":
          uq(K, X8.email, P.message, q);
          break;
      }
      break;
    case "url":
      b8(K, "uri", P.message, q);
      break;
    case "uuid":
      b8(K, "uuid", P.message, q);
      break;
    case "regex":
      uq(K, P.regex, P.message, q);
      break;
    case "cuid":
      uq(K, X8.cuid, P.message, q);
      break;
    case "cuid2":
      uq(K, X8.cuid2, P.message, q);
      break;
    case "startsWith":
      uq(K, RegExp(`^${Uv(P.value, q)}`), P.message, q);
      break;
    case "endsWith":
      uq(K, RegExp(`${Uv(P.value, q)}$`), P.message, q);
      break;
    case "datetime":
      b8(K, "date-time", P.message, q);
      break;
    case "date":
      b8(K, "date", P.message, q);
      break;
    case "time":
      b8(K, "time", P.message, q);
      break;
    case "duration":
      b8(K, "duration", P.message, q);
      break;
    case "length":
      G6(K, "minLength", typeof K.minLength === "number" ? Math.max(K.minLength, P.value) : P.value, P.message, q), G6(K, "maxLength", typeof K.maxLength === "number" ? Math.min(K.maxLength, P.value) : P.value, P.message, q);
      break;
    case "includes":
      uq(K, RegExp(Uv(P.value, q)), P.message, q);
      break;
    case "ip":
      if (P.version !== "v6") b8(K, "ipv4", P.message, q);
      if (P.version !== "v4") b8(K, "ipv6", P.message, q);
      break;
    case "base64url":
      uq(K, X8.base64url, P.message, q);
      break;
    case "jwt":
      uq(K, X8.jwt, P.message, q);
      break;
    case "cidr":
      if (P.version !== "v6") uq(K, X8.ipv4Cidr, P.message, q);
      if (P.version !== "v4") uq(K, X8.ipv6Cidr, P.message, q);
      break;
    case "emoji":
      uq(K, X8.emoji(), P.message, q);
      break;
    case "ulid":
      uq(K, X8.ulid, P.message, q);
      break;
    case "base64":
      switch (q.base64Strategy) {
        case "format:binary":
          b8(K, "binary", P.message, q);
          break;
        case "contentEncoding:base64":
          G6(K, "contentEncoding", "base64", P.message, q);
          break;
        case "pattern:zod":
          uq(K, X8.base64, P.message, q);
          break;
      }
      break;
    case "nanoid":
      uq(K, X8.nanoid, P.message, q);
      break;
    case "toLowerCase":
    case "toUpperCase":
    case "trim":
      break;
    default:
      /* @__PURE__ */ ((_) => {
      })(P);
  }
  return K;
}
function Uv($18, q) {
  return q.patternStrategy === "escape" ? rg($18) : $18;
}
var lg = new Set("ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789");
function rg($18) {
  let q = "";
  for (let K = 0; K < $18.length; K++) {
    if (!lg.has($18[K])) q += "\\";
    q += $18[K];
  }
  return q;
}
function b8($18, q, K, P) {
  var _a2;
  if ($18.format || ((_a2 = $18.anyOf) == null ? void 0 : _a2.some((_) => _.format))) {
    if (!$18.anyOf) $18.anyOf = [];
    if ($18.format) {
      if ($18.anyOf.push({ format: $18.format, ...$18.errorMessage && P.errorMessages && { errorMessage: { format: $18.errorMessage.format } } }), delete $18.format, $18.errorMessage) {
        if (delete $18.errorMessage.format, Object.keys($18.errorMessage).length === 0) delete $18.errorMessage;
      }
    }
    $18.anyOf.push({ format: q, ...K && P.errorMessages && { errorMessage: { format: K } } });
  } else G6($18, "format", q, K, P);
}
function uq($18, q, K, P) {
  var _a2;
  if ($18.pattern || ((_a2 = $18.allOf) == null ? void 0 : _a2.some((_) => _.pattern))) {
    if (!$18.allOf) $18.allOf = [];
    if ($18.pattern) {
      if ($18.allOf.push({ pattern: $18.pattern, ...$18.errorMessage && P.errorMessages && { errorMessage: { pattern: $18.errorMessage.pattern } } }), delete $18.pattern, $18.errorMessage) {
        if (delete $18.errorMessage.pattern, Object.keys($18.errorMessage).length === 0) delete $18.errorMessage;
      }
    }
    $18.allOf.push({ pattern: NA(q, P), ...K && P.errorMessages && { errorMessage: { pattern: K } } });
  } else G6($18, "pattern", NA(q, P), K, P);
}
function NA($18, q) {
  var _a2;
  if (!q.applyRegexFlags || !$18.flags) return $18.source;
  let K = { i: $18.flags.includes("i"), m: $18.flags.includes("m"), s: $18.flags.includes("s") }, P = K.i ? $18.source.toLowerCase() : $18.source, _ = "", Y = false, O = false, z = false;
  for (let J = 0; J < P.length; J++) {
    if (Y) {
      _ += P[J], Y = false;
      continue;
    }
    if (K.i) {
      if (O) {
        if (P[J].match(/[a-z]/)) {
          if (z) _ += P[J], _ += `${P[J - 2]}-${P[J]}`.toUpperCase(), z = false;
          else if (P[J + 1] === "-" && ((_a2 = P[J + 2]) == null ? void 0 : _a2.match(/[a-z]/))) _ += P[J], z = true;
          else _ += `${P[J]}${P[J].toUpperCase()}`;
          continue;
        }
      } else if (P[J].match(/[a-z]/)) {
        _ += `[${P[J]}${P[J].toUpperCase()}]`;
        continue;
      }
    }
    if (K.m) {
      if (P[J] === "^") {
        _ += `(^|(?<=[\r
]))`;
        continue;
      } else if (P[J] === "$") {
        _ += `($|(?=[\r
]))`;
        continue;
      }
    }
    if (K.s && P[J] === ".") {
      _ += O ? `${P[J]}\r
` : `[${P[J]}\r
]`;
      continue;
    }
    if (_ += P[J], P[J] === "\\") Y = true;
    else if (O && P[J] === "]") O = false;
    else if (!O && P[J] === "[") O = true;
  }
  try {
    new RegExp(_);
  } catch {
    return console.warn(`Could not convert regex pattern at ${q.currentPath.join("/")} to a flag-independent form! Falling back to the flag-ignorant source`), $18.source;
  }
  return _;
}
function V7($18, q) {
  var _a2, _b2, _c, _d2, _e, _f;
  if (q.target === "openAi") console.warn("Warning: OpenAI may not support records in schemas! Try an array of key-value pairs instead.");
  if (q.target === "openApi3" && ((_a2 = $18.keyType) == null ? void 0 : _a2._def.typeName) === c$.ZodEnum) return { type: "object", required: $18.keyType._def.values, properties: $18.keyType._def.values.reduce((P, _) => ({ ...P, [_]: K6($18.valueType._def, { ...q, currentPath: [...q.currentPath, "properties", _] }) ?? D6(q) }), {}), additionalProperties: q.rejectedAdditionalProperties };
  let K = { type: "object", additionalProperties: K6($18.valueType._def, { ...q, currentPath: [...q.currentPath, "additionalProperties"] }) ?? q.allowedAdditionalProperties };
  if (q.target === "openApi3") return K;
  if (((_b2 = $18.keyType) == null ? void 0 : _b2._def.typeName) === c$.ZodString && ((_c = $18.keyType._def.checks) == null ? void 0 : _c.length)) {
    let { type: P, ..._ } = G7($18.keyType._def, q);
    return { ...K, propertyNames: _ };
  } else if (((_d2 = $18.keyType) == null ? void 0 : _d2._def.typeName) === c$.ZodEnum) return { ...K, propertyNames: { enum: $18.keyType._def.values } };
  else if (((_e = $18.keyType) == null ? void 0 : _e._def.typeName) === c$.ZodBranded && $18.keyType._def.type._def.typeName === c$.ZodString && ((_f = $18.keyType._def.type._def.checks) == null ? void 0 : _f.length)) {
    let { type: P, ..._ } = k7($18.keyType._def, q);
    return { ...K, propertyNames: _ };
  }
  return K;
}
function Fv($18, q) {
  if (q.mapStrategy === "record") return V7($18, q);
  let K = K6($18.keyType._def, { ...q, currentPath: [...q.currentPath, "items", "items", "0"] }) || D6(q), P = K6($18.valueType._def, { ...q, currentPath: [...q.currentPath, "items", "items", "1"] }) || D6(q);
  return { type: "array", maxItems: 125, items: { type: "array", items: [K, P], minItems: 2, maxItems: 2 } };
}
function av($18) {
  let q = $18.values, P = Object.keys($18.values).filter((Y) => {
    return typeof q[q[Y]] !== "number";
  }).map((Y) => q[Y]), _ = Array.from(new Set(P.map((Y) => typeof Y)));
  return { type: _.length === 1 ? _[0] === "string" ? "string" : "number" : ["string", "number"], enum: P };
}
function Qv($18) {
  return $18.target === "openAi" ? void 0 : { not: D6({ ...$18, currentPath: [...$18.currentPath, "not"] }) };
}
function ev($18) {
  return $18.target === "openApi3" ? { enum: ["null"], nullable: true } : { type: "null" };
}
var S4 = { ZodString: "string", ZodNumber: "number", ZodBigInt: "integer", ZodBoolean: "boolean", ZodNull: "null" };
function sv($18, q) {
  if (q.target === "openApi3") return CA($18, q);
  let K = $18.options instanceof Map ? Array.from($18.options.values()) : $18.options;
  if (K.every((P) => P._def.typeName in S4 && (!P._def.checks || !P._def.checks.length))) {
    let P = K.reduce((_, Y) => {
      let O = S4[Y._def.typeName];
      return O && !_.includes(O) ? [..._, O] : _;
    }, []);
    return { type: P.length > 1 ? P : P[0] };
  } else if (K.every((P) => P._def.typeName === "ZodLiteral" && !P.description)) {
    let P = K.reduce((_, Y) => {
      let O = typeof Y._def.value;
      switch (O) {
        case "string":
        case "number":
        case "boolean":
          return [..._, O];
        case "bigint":
          return [..._, "integer"];
        case "object":
          if (Y._def.value === null) return [..._, "null"];
          return _;
        case "symbol":
        case "undefined":
        case "function":
        default:
          return _;
      }
    }, []);
    if (P.length === K.length) {
      let _ = P.filter((Y, O, z) => z.indexOf(Y) === O);
      return { type: _.length > 1 ? _ : _[0], enum: K.reduce((Y, O) => {
        return Y.includes(O._def.value) ? Y : [...Y, O._def.value];
      }, []) };
    }
  } else if (K.every((P) => P._def.typeName === "ZodEnum")) return { type: "string", enum: K.reduce((P, _) => [...P, ..._._def.values.filter((Y) => !P.includes(Y))], []) };
  return CA($18, q);
}
var CA = ($18, q) => {
  let K = ($18.options instanceof Map ? Array.from($18.options.values()) : $18.options).map((P, _) => K6(P._def, { ...q, currentPath: [...q.currentPath, "anyOf", `${_}`] })).filter((P) => !!P && (!q.strictUnions || typeof P === "object" && Object.keys(P).length > 0));
  return K.length ? { anyOf: K } : void 0;
};
function $z($18, q) {
  if (["ZodString", "ZodNumber", "ZodBigInt", "ZodBoolean", "ZodNull"].includes($18.innerType._def.typeName) && (!$18.innerType._def.checks || !$18.innerType._def.checks.length)) {
    if (q.target === "openApi3") return { type: S4[$18.innerType._def.typeName], nullable: true };
    return { type: [S4[$18.innerType._def.typeName], "null"] };
  }
  if (q.target === "openApi3") {
    let P = K6($18.innerType._def, { ...q, currentPath: [...q.currentPath] });
    if (P && "$ref" in P) return { allOf: [P], nullable: true };
    return P && { ...P, nullable: true };
  }
  let K = K6($18.innerType._def, { ...q, currentPath: [...q.currentPath, "anyOf", "0"] });
  return K && { anyOf: [K, { type: "null" }] };
}
function qz($18, q) {
  let K = { type: "number" };
  if (!$18.checks) return K;
  for (let P of $18.checks) switch (P.kind) {
    case "int":
      K.type = "integer", Y5(K, "type", P.message, q);
      break;
    case "min":
      if (q.target === "jsonSchema7") if (P.inclusive) G6(K, "minimum", P.value, P.message, q);
      else G6(K, "exclusiveMinimum", P.value, P.message, q);
      else {
        if (!P.inclusive) K.exclusiveMinimum = true;
        G6(K, "minimum", P.value, P.message, q);
      }
      break;
    case "max":
      if (q.target === "jsonSchema7") if (P.inclusive) G6(K, "maximum", P.value, P.message, q);
      else G6(K, "exclusiveMaximum", P.value, P.message, q);
      else {
        if (!P.inclusive) K.exclusiveMaximum = true;
        G6(K, "maximum", P.value, P.message, q);
      }
      break;
    case "multipleOf":
      G6(K, "multipleOf", P.value, P.message, q);
      break;
  }
  return K;
}
function Kz($18, q) {
  let K = q.target === "openAi", P = { type: "object", properties: {} }, _ = [], Y = $18.shape();
  for (let z in Y) {
    let J = Y[z];
    if (J === void 0 || J._def === void 0) continue;
    let T = ng(J);
    if (T && K) {
      if (J._def.typeName === "ZodOptional") J = J._def.innerType;
      if (!J.isNullable()) J = J.nullable();
      T = false;
    }
    let X = K6(J._def, { ...q, currentPath: [...q.currentPath, "properties", z], propertyPath: [...q.currentPath, "properties", z] });
    if (X === void 0) continue;
    if (P.properties[z] = X, !T) _.push(z);
  }
  if (_.length) P.required = _;
  let O = og($18, q);
  if (O !== void 0) P.additionalProperties = O;
  return P;
}
function og($18, q) {
  if ($18.catchall._def.typeName !== "ZodNever") return K6($18.catchall._def, { ...q, currentPath: [...q.currentPath, "additionalProperties"] });
  switch ($18.unknownKeys) {
    case "passthrough":
      return q.allowedAdditionalProperties;
    case "strict":
      return q.rejectedAdditionalProperties;
    case "strip":
      return q.removeAdditionalStrategy === "strict" ? q.allowedAdditionalProperties : q.rejectedAdditionalProperties;
  }
}
function ng($18) {
  try {
    return $18.isOptional();
  } catch {
    return true;
  }
}
var _z = ($18, q) => {
  var _a2;
  if (q.currentPath.toString() === ((_a2 = q.propertyPath) == null ? void 0 : _a2.toString())) return K6($18.innerType._def, q);
  let K = K6($18.innerType._def, { ...q, currentPath: [...q.currentPath, "anyOf", "1"] });
  return K ? { anyOf: [{ not: D6(q) }, K] } : D6(q);
};
var Pz = ($18, q) => {
  if (q.pipeStrategy === "input") return K6($18.in._def, q);
  else if (q.pipeStrategy === "output") return K6($18.out._def, q);
  let K = K6($18.in._def, { ...q, currentPath: [...q.currentPath, "allOf", "0"] }), P = K6($18.out._def, { ...q, currentPath: [...q.currentPath, "allOf", K ? "1" : "0"] });
  return { allOf: [K, P].filter((_) => _ !== void 0) };
};
function Oz($18, q) {
  return K6($18.type._def, q);
}
function Yz($18, q) {
  let P = { type: "array", uniqueItems: true, items: K6($18.valueType._def, { ...q, currentPath: [...q.currentPath, "items"] }) };
  if ($18.minSize) G6(P, "minItems", $18.minSize.value, $18.minSize.message, q);
  if ($18.maxSize) G6(P, "maxItems", $18.maxSize.value, $18.maxSize.message, q);
  return P;
}
function jz($18, q) {
  if ($18.rest) return { type: "array", minItems: $18.items.length, items: $18.items.map((K, P) => K6(K._def, { ...q, currentPath: [...q.currentPath, "items", `${P}`] })).reduce((K, P) => P === void 0 ? K : [...K, P], []), additionalItems: K6($18.rest._def, { ...q, currentPath: [...q.currentPath, "additionalItems"] }) };
  else return { type: "array", minItems: $18.items.length, maxItems: $18.items.length, items: $18.items.map((K, P) => K6(K._def, { ...q, currentPath: [...q.currentPath, "items", `${P}`] })).reduce((K, P) => P === void 0 ? K : [...K, P], []) };
}
function vz($18) {
  return { not: D6($18) };
}
function zz($18) {
  return D6($18);
}
var Wz = ($18, q) => {
  return K6($18.innerType._def, q);
};
var Hz = ($18, q, K) => {
  switch (q) {
    case c$.ZodString:
      return G7($18, K);
    case c$.ZodNumber:
      return qz($18, K);
    case c$.ZodObject:
      return Kz($18, K);
    case c$.ZodBigInt:
      return mv($18, K);
    case c$.ZodBoolean:
      return dv();
    case c$.ZodDate:
      return H5($18, K);
    case c$.ZodUndefined:
      return vz(K);
    case c$.ZodNull:
      return ev(K);
    case c$.ZodArray:
      return cv($18, K);
    case c$.ZodUnion:
    case c$.ZodDiscriminatedUnion:
      return sv($18, K);
    case c$.ZodIntersection:
      return iv($18, K);
    case c$.ZodTuple:
      return jz($18, K);
    case c$.ZodRecord:
      return V7($18, K);
    case c$.ZodLiteral:
      return Bv($18, K);
    case c$.ZodEnum:
      return nv($18);
    case c$.ZodNativeEnum:
      return av($18);
    case c$.ZodNullable:
      return $z($18, K);
    case c$.ZodOptional:
      return _z($18, K);
    case c$.ZodMap:
      return Fv($18, K);
    case c$.ZodSet:
      return Yz($18, K);
    case c$.ZodLazy:
      return () => $18.getter()._def;
    case c$.ZodPromise:
      return Oz($18, K);
    case c$.ZodNaN:
    case c$.ZodNever:
      return Qv(K);
    case c$.ZodEffects:
      return ov($18, K);
    case c$.ZodAny:
      return D6(K);
    case c$.ZodUnknown:
      return zz(K);
    case c$.ZodDefault:
      return rv($18, K);
    case c$.ZodBranded:
      return k7($18, K);
    case c$.ZodReadonly:
      return Wz($18, K);
    case c$.ZodCatch:
      return lv($18, K);
    case c$.ZodPipeline:
      return Pz($18, K);
    case c$.ZodFunction:
    case c$.ZodVoid:
    case c$.ZodSymbol:
      return;
    default:
      return /* @__PURE__ */ ((P) => {
        return;
      })(q);
  }
};
function K6($18, q, K = false) {
  var _a2;
  let P = q.seen.get($18);
  if (q.override) {
    let z = (_a2 = q.override) == null ? void 0 : _a2.call(q, $18, q, P, K);
    if (z !== gv) return z;
  }
  if (P && !K) {
    let z = ig(P, q);
    if (z !== void 0) return z;
  }
  let _ = { def: $18, path: q.currentPath, jsonSchema: void 0 };
  q.seen.set($18, _);
  let Y = Hz($18, $18.typeName, q), O = typeof Y === "function" ? K6(Y(), q) : Y;
  if (O) Bg($18, q, O);
  if (q.postProcess) {
    let z = q.postProcess(O, $18, q);
    return _.jsonSchema = O, z;
  }
  return _.jsonSchema = O, O;
}
var ig = ($18, q) => {
  switch (q.$refStrategy) {
    case "root":
      return { $ref: $18.path.join("/") };
    case "relative":
      return { $ref: H7(q.currentPath, $18.path) };
    case "none":
    case "seen":
      if ($18.path.length < q.currentPath.length && $18.path.every((K, P) => q.currentPath[P] === K)) return console.warn(`Recursive reference detected at ${q.currentPath.join("/")}! Defaulting to any`), D6(q);
      return q.$refStrategy === "seen" ? D6(q) : void 0;
  }
};
var Bg = ($18, q, K) => {
  if ($18.description) {
    if (K.description = $18.description, q.markdownDescription) K.markdownDescription = $18.description;
  }
  return K;
};
var Jz = ($18, q) => {
  let K = yv(q), P = typeof q === "object" && q.definitions ? Object.entries(q.definitions).reduce((J, [T, X]) => ({ ...J, [T]: K6(X._def, { ...K, currentPath: [...K.basePath, K.definitionPath, T] }, true) ?? D6(K) }), {}) : void 0, _ = typeof q === "string" ? q : (q == null ? void 0 : q.nameStrategy) === "title" ? void 0 : q == null ? void 0 : q.name, Y = K6($18._def, _ === void 0 ? K : { ...K, currentPath: [...K.basePath, K.definitionPath, _] }, false) ?? D6(K), O = typeof q === "object" && q.name !== void 0 && q.nameStrategy === "title" ? q.name : void 0;
  if (O !== void 0) Y.title = O;
  if (K.flags.hasReferencedOpenAiAnyType) {
    if (!P) P = {};
    if (!P[K.openAiAnyTypeName]) P[K.openAiAnyTypeName] = { type: ["string", "number", "integer", "boolean", "array", "null"], items: { $ref: K.$refStrategy === "relative" ? "1" : [...K.basePath, K.definitionPath, K.openAiAnyTypeName].join("/") } };
  }
  let z = _ === void 0 ? P ? { ...Y, [K.definitionPath]: P } : Y : { $ref: [...K.$refStrategy === "relative" ? [] : K.basePath, K.definitionPath, _].join("/"), [K.definitionPath]: { ...P, [_]: Y } };
  if (K.target === "jsonSchema7") z.$schema = "http://json-schema.org/draft-07/schema#";
  else if (K.target === "jsonSchema2019-09" || K.target === "openAi") z.$schema = "https://json-schema.org/draft/2019-09/schema#";
  if (K.target === "openAi" && ("anyOf" in z || "oneOf" in z || "allOf" in z || "type" in z && Array.isArray(z.type))) console.warn("Warning: OpenAI may not support schemas with unions as roots! Try wrapping it in an object property.");
  return z;
};
function UK($18, q) {
  let K = typeof $18;
  if (K !== typeof q) return false;
  if (Array.isArray($18)) {
    if (!Array.isArray(q)) return false;
    let P = $18.length;
    if (P !== q.length) return false;
    for (let _ = 0; _ < P; _++) if (!UK($18[_], q[_])) return false;
    return true;
  }
  if (K === "object") {
    if (!$18 || !q) return $18 === q;
    let P = Object.keys($18), _ = Object.keys(q);
    if (P.length !== _.length) return false;
    for (let O of P) if (!UK($18[O], q[O])) return false;
    return true;
  }
  return $18 === q;
}
function Y8($18) {
  return encodeURI(tg($18));
}
function tg($18) {
  return $18.replace(/~/g, "~0").replace(/\//g, "~1");
}
var Ug = { prefixItems: true, items: true, allOf: true, anyOf: true, oneOf: true };
var Fg = { $defs: true, definitions: true, properties: true, patternProperties: true, dependentSchemas: true };
var ag = { id: true, $id: true, $ref: true, $schema: true, $anchor: true, $vocabulary: true, $comment: true, default: true, enum: true, const: true, required: true, type: true, maximum: true, minimum: true, exclusiveMaximum: true, exclusiveMinimum: true, multipleOf: true, maxLength: true, minLength: true, pattern: true, format: true, maxItems: true, minItems: true, uniqueItems: true, maxProperties: true, minProperties: true };
var Qg = typeof self < "u" && self.location && self.location.origin !== "null" ? new URL(self.location.origin + self.location.pathname + location.search) : new URL("https://github.com/cfworker");
function y8($18, q = /* @__PURE__ */ Object.create(null), K = Qg, P = "") {
  if ($18 && typeof $18 === "object" && !Array.isArray($18)) {
    let Y = $18.$id || $18.id;
    if (Y) {
      let O = new URL(Y, K.href);
      if (O.hash.length > 1) q[O.href] = $18;
      else if (O.hash = "", P === "") K = O;
      else y8($18, q, K);
    }
  } else if ($18 !== true && $18 !== false) return q;
  let _ = K.href + (P ? "#" + P : "");
  if (q[_] !== void 0) throw Error(`Duplicate schema URI "${_}".`);
  if (q[_] = $18, $18 === true || $18 === false) return q;
  if ($18.__absolute_uri__ === void 0) Object.defineProperty($18, "__absolute_uri__", { enumerable: false, value: _ });
  if ($18.$ref && $18.__absolute_ref__ === void 0) {
    let Y = new URL($18.$ref, K.href);
    Y.hash = Y.hash, Object.defineProperty($18, "__absolute_ref__", { enumerable: false, value: Y.href });
  }
  if ($18.$recursiveRef && $18.__absolute_recursive_ref__ === void 0) {
    let Y = new URL($18.$recursiveRef, K.href);
    Y.hash = Y.hash, Object.defineProperty($18, "__absolute_recursive_ref__", { enumerable: false, value: Y.href });
  }
  if ($18.$anchor) {
    let Y = new URL("#" + $18.$anchor, K.href);
    q[Y.href] = $18;
  }
  for (let Y in $18) {
    if (ag[Y]) continue;
    let O = `${P}/${Y8(Y)}`, z = $18[Y];
    if (Array.isArray(z)) {
      if (Ug[Y]) {
        let J = z.length;
        for (let T = 0; T < J; T++) y8(z[T], q, K, `${O}/${T}`);
      }
    } else if (Fg[Y]) for (let J in z) y8(z[J], q, K, `${O}/${Y8(J)}`);
    else y8(z, q, K, O);
  }
  return q;
}
var eg = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
var sg = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
var $b = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d(?::?\d\d)?)?$/i;
var qb = /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i;
var Kb = /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
var _b = /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i;
var Pb = /^(?:(?:https?|ftp):\/\/)(?:\S+(?::\S*)?@)?(?:(?!10(?:\.\d{1,3}){3})(?!127(?:\.\d{1,3}){3})(?!169\.254(?:\.\d{1,3}){2})(?!192\.168(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z\u{00a1}-\u{ffff}0-9]+-?)*[a-z\u{00a1}-\u{ffff}0-9]+)(?:\.(?:[a-z\u{00a1}-\u{ffff}0-9]+-?)*[a-z\u{00a1}-\u{ffff}0-9]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu;
var Ob = /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i;
var Yb = /^(?:\/(?:[^~/]|~0|~1)*)*$/;
var jb = /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i;
var vb = /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/;
var zb = ($18) => {
  if ($18[0] === '"') return false;
  let [q, K, ...P] = $18.split("@");
  if (!q || !K || P.length !== 0 || q.length > 64 || K.length > 253) return false;
  if (q[0] === "." || q.endsWith(".") || q.includes("..")) return false;
  if (!/^[a-z0-9.-]+$/i.test(K) || !/^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+$/i.test(q)) return false;
  return K.split(".").every((_) => /^[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?$/i.test(_));
};
var Wb = /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/;
var Hb = /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i;
var Jb = ($18) => $18.length > 1 && $18.length < 80 && (/^P\d+([.,]\d+)?W$/.test($18) || /^P[\dYMDTHS]*(\d[.,]\d+)?[YMDHS]$/.test($18) && /^P([.,\d]+Y)?([.,\d]+M)?([.,\d]+D)?(T([.,\d]+H)?([.,\d]+M)?([.,\d]+S)?)?$/.test($18));
function t8($18) {
  return $18.test.bind($18);
}
var Tz = { date: EA, time: hA.bind(void 0, false), "date-time": fb, duration: Jb, uri: Ab, "uri-reference": t8(Kb), "uri-template": t8(_b), url: t8(Pb), email: zb, hostname: t8(qb), ipv4: t8(Wb), ipv6: t8(Hb), regex: Gb, uuid: t8(Ob), "json-pointer": t8(Yb), "json-pointer-uri-fragment": t8(jb), "relative-json-pointer": t8(vb) };
function Tb($18) {
  return $18 % 4 === 0 && ($18 % 100 !== 0 || $18 % 400 === 0);
}
function EA($18) {
  let q = $18.match(eg);
  if (!q) return false;
  let K = +q[1], P = +q[2], _ = +q[3];
  return P >= 1 && P <= 12 && _ >= 1 && _ <= (P == 2 && Tb(K) ? 29 : sg[P]);
}
function hA($18, q) {
  let K = q.match($b);
  if (!K) return false;
  let P = +K[1], _ = +K[2], Y = +K[3], O = !!K[5];
  return (P <= 23 && _ <= 59 && Y <= 59 || P == 23 && _ == 59 && Y == 60) && (!$18 || O);
}
var wb = /t|\s/i;
function fb($18) {
  let q = $18.split(wb);
  return q.length == 2 && EA(q[0]) && hA(true, q[1]);
}
var Zb = /\/|:/;
var Xb = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
function Ab($18) {
  return Zb.test($18) && Xb.test($18);
}
var kb = /[^\\]\\Z/;
function Gb($18) {
  if (kb.test($18)) return false;
  try {
    return new RegExp($18, "u"), true;
  } catch (q) {
    return false;
  }
}
function RA($18) {
  let q = 0, K = $18.length, P = 0, _;
  while (P < K) if (q++, _ = $18.charCodeAt(P++), _ >= 55296 && _ <= 56319 && P < K) {
    if (_ = $18.charCodeAt(P), (_ & 64512) == 56320) P++;
  }
  return q;
}
function b6($18, q, K = "2019-09", P = y8(q), _ = true, Y = null, O = "#", z = "#", J = /* @__PURE__ */ Object.create(null)) {
  if (q === true) return { valid: true, errors: [] };
  if (q === false) return { valid: false, errors: [{ instanceLocation: O, keyword: "false", keywordLocation: O, error: "False boolean schema." }] };
  let T = typeof $18, X;
  switch (T) {
    case "boolean":
    case "number":
    case "string":
      X = T;
      break;
    case "object":
      if ($18 === null) X = "null";
      else if (Array.isArray($18)) X = "array";
      else X = "object";
      break;
    default:
      throw Error(`Instances of "${T}" type are not supported.`);
  }
  let { $ref: f, $recursiveRef: V, $recursiveAnchor: M, type: N, const: h, enum: E, required: I, not: D, anyOf: g, allOf: b, oneOf: y, if: p, then: n, else: s, format: q$, properties: c, patternProperties: U, additionalProperties: j, unevaluatedProperties: H, minProperties: Z, maxProperties: W, propertyNames: w, dependentRequired: G, dependentSchemas: S, dependencies: A, prefixItems: v, items: k, additionalItems: R, unevaluatedItems: C, contains: L, minContains: x, maxContains: l, minItems: a, maxItems: f$, uniqueItems: $$, minimum: B, maximum: H$, exclusiveMinimum: Q, exclusiveMaximum: v$, multipleOf: t$, minLength: m, maxLength: r, pattern: J$, __absolute_ref__: e, __absolute_recursive_ref__: _$2 } = q, Y$ = [];
  if (M === true && Y === null) Y = q;
  if (V === "#") {
    let o = Y === null ? P[_$2] : Y, W$ = `${z}/$recursiveRef`, t = b6($18, Y === null ? q : Y, K, P, _, o, O, W$, J);
    if (!t.valid) Y$.push({ instanceLocation: O, keyword: "$recursiveRef", keywordLocation: W$, error: "A subschema had errors." }, ...t.errors);
  }
  if (f !== void 0) {
    let W$ = P[e || f];
    if (W$ === void 0) {
      let X$ = `Unresolved $ref "${f}".`;
      if (e && e !== f) X$ += `  Absolute URI "${e}".`;
      throw X$ += `
Known schemas:
- ${Object.keys(P).join(`
- `)}`, Error(X$);
    }
    let t = `${z}/$ref`, F = b6($18, W$, K, P, _, Y, O, t, J);
    if (!F.valid) Y$.push({ instanceLocation: O, keyword: "$ref", keywordLocation: t, error: "A subschema had errors." }, ...F.errors);
    if (K === "4" || K === "7") return { valid: Y$.length === 0, errors: Y$ };
  }
  if (Array.isArray(N)) {
    let o = N.length, W$ = false;
    for (let t = 0; t < o; t++) if (X === N[t] || N[t] === "integer" && X === "number" && $18 % 1 === 0 && $18 === $18) {
      W$ = true;
      break;
    }
    if (!W$) Y$.push({ instanceLocation: O, keyword: "type", keywordLocation: `${z}/type`, error: `Instance type "${X}" is invalid. Expected "${N.join('", "')}".` });
  } else if (N === "integer") {
    if (X !== "number" || $18 % 1 || $18 !== $18) Y$.push({ instanceLocation: O, keyword: "type", keywordLocation: `${z}/type`, error: `Instance type "${X}" is invalid. Expected "${N}".` });
  } else if (N !== void 0 && X !== N) Y$.push({ instanceLocation: O, keyword: "type", keywordLocation: `${z}/type`, error: `Instance type "${X}" is invalid. Expected "${N}".` });
  if (h !== void 0) {
    if (X === "object" || X === "array") {
      if (!UK($18, h)) Y$.push({ instanceLocation: O, keyword: "const", keywordLocation: `${z}/const`, error: `Instance does not match ${JSON.stringify(h)}.` });
    } else if ($18 !== h) Y$.push({ instanceLocation: O, keyword: "const", keywordLocation: `${z}/const`, error: `Instance does not match ${JSON.stringify(h)}.` });
  }
  if (E !== void 0) {
    if (X === "object" || X === "array") {
      if (!E.some((o) => UK($18, o))) Y$.push({ instanceLocation: O, keyword: "enum", keywordLocation: `${z}/enum`, error: `Instance does not match any of ${JSON.stringify(E)}.` });
    } else if (!E.some((o) => $18 === o)) Y$.push({ instanceLocation: O, keyword: "enum", keywordLocation: `${z}/enum`, error: `Instance does not match any of ${JSON.stringify(E)}.` });
  }
  if (D !== void 0) {
    let o = `${z}/not`;
    if (b6($18, D, K, P, _, Y, O, o).valid) Y$.push({ instanceLocation: O, keyword: "not", keywordLocation: o, error: 'Instance matched "not" schema.' });
  }
  let d = [];
  if (g !== void 0) {
    let o = `${z}/anyOf`, W$ = Y$.length, t = false;
    for (let F = 0; F < g.length; F++) {
      let X$ = g[F], z$ = Object.create(J), j$ = b6($18, X$, K, P, _, M === true ? Y : null, O, `${o}/${F}`, z$);
      if (Y$.push(...j$.errors), t = t || j$.valid, j$.valid) d.push(z$);
    }
    if (t) Y$.length = W$;
    else Y$.splice(W$, 0, { instanceLocation: O, keyword: "anyOf", keywordLocation: o, error: "Instance does not match any subschemas." });
  }
  if (b !== void 0) {
    let o = `${z}/allOf`, W$ = Y$.length, t = true;
    for (let F = 0; F < b.length; F++) {
      let X$ = b[F], z$ = Object.create(J), j$ = b6($18, X$, K, P, _, M === true ? Y : null, O, `${o}/${F}`, z$);
      if (Y$.push(...j$.errors), t = t && j$.valid, j$.valid) d.push(z$);
    }
    if (t) Y$.length = W$;
    else Y$.splice(W$, 0, { instanceLocation: O, keyword: "allOf", keywordLocation: o, error: "Instance does not match every subschema." });
  }
  if (y !== void 0) {
    let o = `${z}/oneOf`, W$ = Y$.length, t = y.filter((F, X$) => {
      let z$ = Object.create(J), j$ = b6($18, F, K, P, _, M === true ? Y : null, O, `${o}/${X$}`, z$);
      if (Y$.push(...j$.errors), j$.valid) d.push(z$);
      return j$.valid;
    }).length;
    if (t === 1) Y$.length = W$;
    else Y$.splice(W$, 0, { instanceLocation: O, keyword: "oneOf", keywordLocation: o, error: `Instance does not match exactly one subschema (${t} matches).` });
  }
  if (X === "object" || X === "array") Object.assign(J, ...d);
  if (p !== void 0) {
    let o = `${z}/if`;
    if (b6($18, p, K, P, _, Y, O, o, J).valid) {
      if (n !== void 0) {
        let t = b6($18, n, K, P, _, Y, O, `${z}/then`, J);
        if (!t.valid) Y$.push({ instanceLocation: O, keyword: "if", keywordLocation: o, error: 'Instance does not match "then" schema.' }, ...t.errors);
      }
    } else if (s !== void 0) {
      let t = b6($18, s, K, P, _, Y, O, `${z}/else`, J);
      if (!t.valid) Y$.push({ instanceLocation: O, keyword: "if", keywordLocation: o, error: 'Instance does not match "else" schema.' }, ...t.errors);
    }
  }
  if (X === "object") {
    if (I !== void 0) {
      for (let F of I) if (!(F in $18)) Y$.push({ instanceLocation: O, keyword: "required", keywordLocation: `${z}/required`, error: `Instance does not have required property "${F}".` });
    }
    let o = Object.keys($18);
    if (Z !== void 0 && o.length < Z) Y$.push({ instanceLocation: O, keyword: "minProperties", keywordLocation: `${z}/minProperties`, error: `Instance does not have at least ${Z} properties.` });
    if (W !== void 0 && o.length > W) Y$.push({ instanceLocation: O, keyword: "maxProperties", keywordLocation: `${z}/maxProperties`, error: `Instance does not have at least ${W} properties.` });
    if (w !== void 0) {
      let F = `${z}/propertyNames`;
      for (let X$ in $18) {
        let z$ = `${O}/${Y8(X$)}`, j$ = b6(X$, w, K, P, _, Y, z$, F);
        if (!j$.valid) Y$.push({ instanceLocation: O, keyword: "propertyNames", keywordLocation: F, error: `Property name "${X$}" does not match schema.` }, ...j$.errors);
      }
    }
    if (G !== void 0) {
      let F = `${z}/dependantRequired`;
      for (let X$ in G) if (X$ in $18) {
        let z$ = G[X$];
        for (let j$ of z$) if (!(j$ in $18)) Y$.push({ instanceLocation: O, keyword: "dependentRequired", keywordLocation: F, error: `Instance has "${X$}" but does not have "${j$}".` });
      }
    }
    if (S !== void 0) for (let F in S) {
      let X$ = `${z}/dependentSchemas`;
      if (F in $18) {
        let z$ = b6($18, S[F], K, P, _, Y, O, `${X$}/${Y8(F)}`, J);
        if (!z$.valid) Y$.push({ instanceLocation: O, keyword: "dependentSchemas", keywordLocation: X$, error: `Instance has "${F}" but does not match dependant schema.` }, ...z$.errors);
      }
    }
    if (A !== void 0) {
      let F = `${z}/dependencies`;
      for (let X$ in A) if (X$ in $18) {
        let z$ = A[X$];
        if (Array.isArray(z$)) {
          for (let j$ of z$) if (!(j$ in $18)) Y$.push({ instanceLocation: O, keyword: "dependencies", keywordLocation: F, error: `Instance has "${X$}" but does not have "${j$}".` });
        } else {
          let j$ = b6($18, z$, K, P, _, Y, O, `${F}/${Y8(X$)}`);
          if (!j$.valid) Y$.push({ instanceLocation: O, keyword: "dependencies", keywordLocation: F, error: `Instance has "${X$}" but does not match dependant schema.` }, ...j$.errors);
        }
      }
    }
    let W$ = /* @__PURE__ */ Object.create(null), t = false;
    if (c !== void 0) {
      let F = `${z}/properties`;
      for (let X$ in c) {
        if (!(X$ in $18)) continue;
        let z$ = `${O}/${Y8(X$)}`, j$ = b6($18[X$], c[X$], K, P, _, Y, z$, `${F}/${Y8(X$)}`);
        if (j$.valid) J[X$] = W$[X$] = true;
        else if (t = _, Y$.push({ instanceLocation: O, keyword: "properties", keywordLocation: F, error: `Property "${X$}" does not match schema.` }, ...j$.errors), t) break;
      }
    }
    if (!t && U !== void 0) {
      let F = `${z}/patternProperties`;
      for (let X$ in U) {
        let z$ = new RegExp(X$, "u"), j$ = U[X$];
        for (let X6 in $18) {
          if (!z$.test(X6)) continue;
          let Z$ = `${O}/${Y8(X6)}`, A$ = b6($18[X6], j$, K, P, _, Y, Z$, `${F}/${Y8(X$)}`);
          if (A$.valid) J[X6] = W$[X6] = true;
          else t = _, Y$.push({ instanceLocation: O, keyword: "patternProperties", keywordLocation: F, error: `Property "${X6}" matches pattern "${X$}" but does not match associated schema.` }, ...A$.errors);
        }
      }
    }
    if (!t && j !== void 0) {
      let F = `${z}/additionalProperties`;
      for (let X$ in $18) {
        if (W$[X$]) continue;
        let z$ = `${O}/${Y8(X$)}`, j$ = b6($18[X$], j, K, P, _, Y, z$, F);
        if (j$.valid) J[X$] = true;
        else t = _, Y$.push({ instanceLocation: O, keyword: "additionalProperties", keywordLocation: F, error: `Property "${X$}" does not match additional properties schema.` }, ...j$.errors);
      }
    } else if (!t && H !== void 0) {
      let F = `${z}/unevaluatedProperties`;
      for (let X$ in $18) if (!J[X$]) {
        let z$ = `${O}/${Y8(X$)}`, j$ = b6($18[X$], H, K, P, _, Y, z$, F);
        if (j$.valid) J[X$] = true;
        else Y$.push({ instanceLocation: O, keyword: "unevaluatedProperties", keywordLocation: F, error: `Property "${X$}" does not match unevaluated properties schema.` }, ...j$.errors);
      }
    }
  } else if (X === "array") {
    if (f$ !== void 0 && $18.length > f$) Y$.push({ instanceLocation: O, keyword: "maxItems", keywordLocation: `${z}/maxItems`, error: `Array has too many items (${$18.length} > ${f$}).` });
    if (a !== void 0 && $18.length < a) Y$.push({ instanceLocation: O, keyword: "minItems", keywordLocation: `${z}/minItems`, error: `Array has too few items (${$18.length} < ${a}).` });
    let o = $18.length, W$ = 0, t = false;
    if (v !== void 0) {
      let F = `${z}/prefixItems`, X$ = Math.min(v.length, o);
      for (; W$ < X$; W$++) {
        let z$ = b6($18[W$], v[W$], K, P, _, Y, `${O}/${W$}`, `${F}/${W$}`);
        if (J[W$] = true, !z$.valid) {
          if (t = _, Y$.push({ instanceLocation: O, keyword: "prefixItems", keywordLocation: F, error: "Items did not match schema." }, ...z$.errors), t) break;
        }
      }
    }
    if (k !== void 0) {
      let F = `${z}/items`;
      if (Array.isArray(k)) {
        let X$ = Math.min(k.length, o);
        for (; W$ < X$; W$++) {
          let z$ = b6($18[W$], k[W$], K, P, _, Y, `${O}/${W$}`, `${F}/${W$}`);
          if (J[W$] = true, !z$.valid) {
            if (t = _, Y$.push({ instanceLocation: O, keyword: "items", keywordLocation: F, error: "Items did not match schema." }, ...z$.errors), t) break;
          }
        }
      } else for (; W$ < o; W$++) {
        let X$ = b6($18[W$], k, K, P, _, Y, `${O}/${W$}`, F);
        if (J[W$] = true, !X$.valid) {
          if (t = _, Y$.push({ instanceLocation: O, keyword: "items", keywordLocation: F, error: "Items did not match schema." }, ...X$.errors), t) break;
        }
      }
      if (!t && R !== void 0) {
        let X$ = `${z}/additionalItems`;
        for (; W$ < o; W$++) {
          let z$ = b6($18[W$], R, K, P, _, Y, `${O}/${W$}`, X$);
          if (J[W$] = true, !z$.valid) t = _, Y$.push({ instanceLocation: O, keyword: "additionalItems", keywordLocation: X$, error: "Items did not match additional items schema." }, ...z$.errors);
        }
      }
    }
    if (L !== void 0) if (o === 0 && x === void 0) Y$.push({ instanceLocation: O, keyword: "contains", keywordLocation: `${z}/contains`, error: "Array is empty. It must contain at least one item matching the schema." });
    else if (x !== void 0 && o < x) Y$.push({ instanceLocation: O, keyword: "minContains", keywordLocation: `${z}/minContains`, error: `Array has less items (${o}) than minContains (${x}).` });
    else {
      let F = `${z}/contains`, X$ = Y$.length, z$ = 0;
      for (let j$ = 0; j$ < o; j$++) {
        let X6 = b6($18[j$], L, K, P, _, Y, `${O}/${j$}`, F);
        if (X6.valid) J[j$] = true, z$++;
        else Y$.push(...X6.errors);
      }
      if (z$ >= (x || 0)) Y$.length = X$;
      if (x === void 0 && l === void 0 && z$ === 0) Y$.splice(X$, 0, { instanceLocation: O, keyword: "contains", keywordLocation: F, error: "Array does not contain item matching schema." });
      else if (x !== void 0 && z$ < x) Y$.push({ instanceLocation: O, keyword: "minContains", keywordLocation: `${z}/minContains`, error: `Array must contain at least ${x} items matching schema. Only ${z$} items were found.` });
      else if (l !== void 0 && z$ > l) Y$.push({ instanceLocation: O, keyword: "maxContains", keywordLocation: `${z}/maxContains`, error: `Array may contain at most ${l} items matching schema. ${z$} items were found.` });
    }
    if (!t && C !== void 0) {
      let F = `${z}/unevaluatedItems`;
      for (W$; W$ < o; W$++) {
        if (J[W$]) continue;
        let X$ = b6($18[W$], C, K, P, _, Y, `${O}/${W$}`, F);
        if (J[W$] = true, !X$.valid) Y$.push({ instanceLocation: O, keyword: "unevaluatedItems", keywordLocation: F, error: "Items did not match unevaluated items schema." }, ...X$.errors);
      }
    }
    if ($$) for (let F = 0; F < o; F++) {
      let X$ = $18[F], z$ = typeof X$ === "object" && X$ !== null;
      for (let j$ = 0; j$ < o; j$++) {
        if (F === j$) continue;
        let X6 = $18[j$];
        if (X$ === X6 || z$ && (typeof X6 === "object" && X6 !== null) && UK(X$, X6)) Y$.push({ instanceLocation: O, keyword: "uniqueItems", keywordLocation: `${z}/uniqueItems`, error: `Duplicate items at indexes ${F} and ${j$}.` }), F = Number.MAX_SAFE_INTEGER, j$ = Number.MAX_SAFE_INTEGER;
      }
    }
  } else if (X === "number") {
    if (K === "4") {
      if (B !== void 0 && (Q === true && $18 <= B || $18 < B)) Y$.push({ instanceLocation: O, keyword: "minimum", keywordLocation: `${z}/minimum`, error: `${$18} is less than ${Q ? "or equal to " : ""} ${B}.` });
      if (H$ !== void 0 && (v$ === true && $18 >= H$ || $18 > H$)) Y$.push({ instanceLocation: O, keyword: "maximum", keywordLocation: `${z}/maximum`, error: `${$18} is greater than ${v$ ? "or equal to " : ""} ${H$}.` });
    } else {
      if (B !== void 0 && $18 < B) Y$.push({ instanceLocation: O, keyword: "minimum", keywordLocation: `${z}/minimum`, error: `${$18} is less than ${B}.` });
      if (H$ !== void 0 && $18 > H$) Y$.push({ instanceLocation: O, keyword: "maximum", keywordLocation: `${z}/maximum`, error: `${$18} is greater than ${H$}.` });
      if (Q !== void 0 && $18 <= Q) Y$.push({ instanceLocation: O, keyword: "exclusiveMinimum", keywordLocation: `${z}/exclusiveMinimum`, error: `${$18} is less than ${Q}.` });
      if (v$ !== void 0 && $18 >= v$) Y$.push({ instanceLocation: O, keyword: "exclusiveMaximum", keywordLocation: `${z}/exclusiveMaximum`, error: `${$18} is greater than or equal to ${v$}.` });
    }
    if (t$ !== void 0) {
      let o = $18 % t$;
      if (Math.abs(0 - o) >= 11920929e-14 && Math.abs(t$ - o) >= 11920929e-14) Y$.push({ instanceLocation: O, keyword: "multipleOf", keywordLocation: `${z}/multipleOf`, error: `${$18} is not a multiple of ${t$}.` });
    }
  } else if (X === "string") {
    let o = m === void 0 && r === void 0 ? 0 : RA($18);
    if (m !== void 0 && o < m) Y$.push({ instanceLocation: O, keyword: "minLength", keywordLocation: `${z}/minLength`, error: `String is too short (${o} < ${m}).` });
    if (r !== void 0 && o > r) Y$.push({ instanceLocation: O, keyword: "maxLength", keywordLocation: `${z}/maxLength`, error: `String is too long (${o} > ${r}).` });
    if (J$ !== void 0 && !new RegExp(J$, "u").test($18)) Y$.push({ instanceLocation: O, keyword: "pattern", keywordLocation: `${z}/pattern`, error: "String does not match pattern." });
    if (q$ !== void 0 && Tz[q$] && !Tz[q$]($18)) Y$.push({ instanceLocation: O, keyword: "format", keywordLocation: `${z}/format`, error: `String does not match format "${q$}".` });
  }
  return { valid: Y$.length === 0, errors: Y$ };
}
var wz = class {
  constructor($18, q = "2019-09", K = true) {
    __publicField(this, "schema");
    __publicField(this, "draft");
    __publicField(this, "shortCircuit");
    __publicField(this, "lookup");
    this.schema = $18, this.draft = q, this.shortCircuit = K, this.lookup = y8($18);
  }
  validate($18) {
    return b6($18, this.schema, this.draft, this.lookup, this.shortCircuit);
  }
  addSchema($18, q) {
    if (q) $18 = { ...$18, $id: q };
    y8($18, this.lookup);
  }
};
var Vb = {};
Z6(Vb, { Validator: () => wz, deepCompareStrict: () => UK, toJsonSchema: () => fz, validatesOnlyStrings: () => J5 });
function fz($18) {
  if (o8($18)) {
    let q = WA($18, true);
    if (Y4(q)) {
      let K = O5(q, true);
      return O4(K);
    } else return O4($18);
  }
  if (HK($18)) return Jz($18);
  return $18;
}
function J5($18) {
  if (!$18 || typeof $18 !== "object" || Object.keys($18).length === 0 || Array.isArray($18)) return false;
  if ("type" in $18) {
    if (typeof $18.type === "string") return $18.type === "string";
    if (Array.isArray($18.type)) return $18.type.every((q) => q === "string");
    return false;
  }
  if ("enum" in $18) return Array.isArray($18.enum) && $18.enum.length > 0 && $18.enum.every((q) => typeof q === "string");
  if ("const" in $18) return typeof $18.const === "string";
  if ("allOf" in $18 && Array.isArray($18.allOf)) return $18.allOf.some((q) => J5(q));
  if ("anyOf" in $18 && Array.isArray($18.anyOf) || "oneOf" in $18 && Array.isArray($18.oneOf)) {
    let q = "anyOf" in $18 ? $18.anyOf : $18.oneOf;
    return q.length > 0 && q.every((K) => J5(K));
  }
  if ("not" in $18) return false;
  if ("$ref" in $18 && typeof $18.$ref === "string") {
    let q = $18.$ref, K = y8($18);
    if (K[q]) return J5(K[q]);
    return false;
  }
  return false;
}
var Sb = {};
Z6(Sb, { Graph: () => T5 });
function Mb($18, q) {
  if ($18 !== void 0 && !m_($18)) return $18;
  else if (CP(q)) try {
    let K = q.getName();
    return K = K.startsWith("Runnable") ? K.slice(8) : K, K;
  } catch {
    return q.getName();
  }
  else return q.name ?? "UnknownSchema";
}
function Nb($18) {
  if (CP($18.data)) return { type: "runnable", data: { id: $18.data.lc_id, name: $18.data.getName() } };
  else return { type: "schema", data: { ...fz($18.data.schema), title: $18.data.name } };
}
var T5 = class $11 {
  constructor(q) {
    __publicField(this, "nodes", {});
    __publicField(this, "edges", []);
    this.nodes = (q == null ? void 0 : q.nodes) ?? this.nodes, this.edges = (q == null ? void 0 : q.edges) ?? this.edges;
  }
  toJSON() {
    let q = {};
    return Object.values(this.nodes).forEach((K, P) => {
      q[K.id] = m_(K.id) ? P : K.id;
    }), { nodes: Object.values(this.nodes).map((K) => ({ id: q[K.id], ...Nb(K) })), edges: this.edges.map((K) => {
      let P = { source: q[K.source], target: q[K.target] };
      if (typeof K.data < "u") P.data = K.data;
      if (typeof K.conditional < "u") P.conditional = K.conditional;
      return P;
    }) };
  }
  addNode(q, K, P) {
    if (K !== void 0 && this.nodes[K] !== void 0) throw Error(`Node with id ${K} already exists`);
    let _ = K ?? nq(), Y = { id: _, data: q, name: Mb(K, q), metadata: P };
    return this.nodes[_] = Y, Y;
  }
  removeNode(q) {
    delete this.nodes[q.id], this.edges = this.edges.filter((K) => K.source !== q.id && K.target !== q.id);
  }
  addEdge(q, K, P, _) {
    if (this.nodes[q.id] === void 0) throw Error(`Source node ${q.id} not in graph`);
    if (this.nodes[K.id] === void 0) throw Error(`Target node ${K.id} not in graph`);
    let Y = { source: q.id, target: K.id, data: P, conditional: _ };
    return this.edges.push(Y), Y;
  }
  firstNode() {
    return IA(this);
  }
  lastNode() {
    return DA(this);
  }
  extend(q, K = "") {
    let P = K;
    if (Object.values(q.nodes).map((T) => T.id).every(m_)) P = "";
    let Y = (T) => {
      return P ? `${P}:${T}` : T;
    };
    Object.entries(q.nodes).forEach(([T, X]) => {
      this.nodes[Y(T)] = { ...X, id: Y(T) };
    });
    let O = q.edges.map((T) => {
      return { ...T, source: Y(T.source), target: Y(T.target) };
    });
    this.edges = [...this.edges, ...O];
    let z = q.firstNode(), J = q.lastNode();
    return [z ? { id: Y(z.id), data: z.data } : void 0, J ? { id: Y(J.id), data: J.data } : void 0];
  }
  trimFirstNode() {
    let q = this.firstNode();
    if (q && IA(this, [q.id])) this.removeNode(q);
  }
  trimLastNode() {
    let q = this.lastNode();
    if (q && DA(this, [q.id])) this.removeNode(q);
  }
  reid() {
    let q = Object.fromEntries(Object.values(this.nodes).map((_) => [_.id, _.name])), K = /* @__PURE__ */ new Map();
    Object.values(q).forEach((_) => {
      K.set(_, (K.get(_) || 0) + 1);
    });
    let P = (_) => {
      let Y = q[_];
      if (m_(_) && K.get(Y) === 1) return Y;
      else return _;
    };
    return new $11({ nodes: Object.fromEntries(Object.entries(this.nodes).map(([_, Y]) => [P(_), { ...Y, id: P(_) }])), edges: this.edges.map((_) => ({ ..._, source: P(_.source), target: P(_.target) })) });
  }
  drawMermaid(q) {
    let { withStyles: K, curveStyle: P, nodeColors: _ = { default: "fill:#f2f0ff,line-height:1.2", first: "fill-opacity:0", last: "fill:#bfb6fc" }, wrapLabelNWords: Y } = q ?? {}, O = this.reid(), z = O.firstNode(), J = O.lastNode();
    return HA(O.nodes, O.edges, { firstNode: z == null ? void 0 : z.id, lastNode: J == null ? void 0 : J.id, withStyles: K, curveStyle: P, nodeColors: _, wrapLabelNWords: Y });
  }
  async drawMermaidPng(q) {
    let K = this.drawMermaid(q);
    return JA(K, { backgroundColor: q == null ? void 0 : q.backgroundColor });
  }
};
function IA($18, q = []) {
  let K = new Set($18.edges.filter((_) => !q.includes(_.source)).map((_) => _.target)), P = [];
  for (let _ of Object.values($18.nodes)) if (!q.includes(_.id) && !K.has(_.id)) P.push(_);
  return P.length === 1 ? P[0] : void 0;
}
function DA($18, q = []) {
  let K = new Set($18.edges.filter((_) => !q.includes(_.target)).map((_) => _.source)), P = [];
  for (let _ of Object.values($18.nodes)) if (!q.includes(_.id) && !K.has(_.id)) P.push(_);
  return P.length === 1 ? P[0] : void 0;
}
function LA($18) {
  let q = new TextEncoder(), K = new ReadableStream({ async start(P) {
    for await (let _ of $18) P.enqueue(q.encode(`event: data
data: ${JSON.stringify(_)}

`));
    P.enqueue(q.encode(`event: end

`)), P.close();
  } });
  return yq.fromReadableStream(K);
}
function Zz($18) {
  return typeof $18 === "object" && $18 !== null && typeof $18[Symbol.iterator] === "function" && typeof $18.next === "function";
}
var gA = ($18) => $18 != null && typeof $18 === "object" && "next" in $18 && typeof $18.next === "function";
function w5($18) {
  return typeof $18 === "object" && $18 !== null && typeof $18[Symbol.asyncIterator] === "function";
}
function* Xz($18, q) {
  while (true) {
    let { value: K, done: P } = tq.runWithConfig(YK($18), q.next.bind(q), true);
    if (P) break;
    else yield K;
  }
}
async function* f5($18, q) {
  let K = q[Symbol.asyncIterator]();
  while (true) {
    let { value: P, done: _ } = await tq.runWithConfig(YK($18), K.next.bind(q), true);
    if (_) break;
    else yield P;
  }
}
var Az = q8(C1(), 1);
function Hq($18, q) {
  return $18 && !Array.isArray($18) && !($18 instanceof Date) && typeof $18 === "object" ? $18 : { [q]: $18 };
}
var xq = class extends RK {
  constructor() {
    super(...arguments);
    __publicField(this, "lc_runnable", true);
    __publicField(this, "name");
  }
  getName($18) {
    let q = this.name ?? this.constructor.lc_name() ?? this.constructor.name;
    return $18 ? `${q}${$18}` : q;
  }
  withRetry($18) {
    return new yA({ bound: this, kwargs: {}, config: {}, maxAttemptNumber: $18 == null ? void 0 : $18.stopAfterAttempt, ...$18 });
  }
  withConfig($18) {
    return new Z5({ bound: this, config: $18, kwargs: {} });
  }
  withFallbacks($18) {
    let q = Array.isArray($18) ? $18 : $18.fallbacks;
    return new hb({ runnable: this, fallbacks: q });
  }
  _getOptionsList($18, q = 0) {
    if (Array.isArray($18) && $18.length !== q) throw Error(`Passed "options" must be an array with the same length as the inputs, but got ${$18.length} options for ${q} inputs`);
    if (Array.isArray($18)) return $18.map(N6);
    if (q > 1 && !Array.isArray($18) && $18.runId) {
      console.warn("Provided runId will be used only for the first element of the batch.");
      let K = Object.fromEntries(Object.entries($18).filter(([P]) => P !== "runId"));
      return Array.from({ length: q }, (P, _) => N6(_ === 0 ? $18 : K));
    }
    return Array.from({ length: q }, () => N6($18));
  }
  async batch($18, q, K) {
    var _a2;
    let P = this._getOptionsList(q ?? {}, $18.length), _ = ((_a2 = P[0]) == null ? void 0 : _a2.maxConcurrency) ?? (K == null ? void 0 : K.maxConcurrency), Y = new NP({ maxConcurrency: _, onFailedAttempt: (z) => {
      throw z;
    } }), O = $18.map((z, J) => Y.call(async () => {
      try {
        return await this.invoke(z, P[J]);
      } catch (T) {
        if (K == null ? void 0 : K.returnExceptions) return T;
        throw T;
      }
    }));
    return Promise.all(O);
  }
  async *_streamIterator($18, q) {
    yield this.invoke($18, q);
  }
  async stream($18, q) {
    let K = N6(q), P = new uK({ generator: this._streamIterator($18, K), config: K });
    return await P.setup, yq.fromAsyncGenerator(P);
  }
  _separateRunnableConfigFromCallOptions($18) {
    let q;
    if ($18 === void 0) q = N6($18);
    else q = N6({ callbacks: $18.callbacks, tags: $18.tags, metadata: $18.metadata, runName: $18.runName, configurable: $18.configurable, recursionLimit: $18.recursionLimit, maxConcurrency: $18.maxConcurrency, runId: $18.runId, timeout: $18.timeout, signal: $18.signal });
    let K = { ...$18 };
    return delete K.callbacks, delete K.tags, delete K.metadata, delete K.runName, delete K.configurable, delete K.recursionLimit, delete K.maxConcurrency, delete K.runId, delete K.timeout, delete K.signal, [q, K];
  }
  async _callWithConfig($18, q, K) {
    var _a2;
    let P = N6(K), Y = await ((_a2 = await w8(P)) == null ? void 0 : _a2.handleChainStart(this.toJSON(), Hq(q, "input"), P.runId, P == null ? void 0 : P.runType, void 0, void 0, (P == null ? void 0 : P.runName) ?? this.getName()));
    delete P.runId;
    let O;
    try {
      let z = $18.call(this, q, P, Y);
      O = await m8(z, K == null ? void 0 : K.signal);
    } catch (z) {
      throw await (Y == null ? void 0 : Y.handleChainError(z)), z;
    }
    return await (Y == null ? void 0 : Y.handleChainEnd(Hq(O, "output"))), O;
  }
  async _batchWithConfig($18, q, K, P) {
    var _a2;
    let _ = this._getOptionsList(K ?? {}, q.length), Y = await Promise.all(_.map(w8)), O = await Promise.all(Y.map(async (J, T) => {
      let X = await (J == null ? void 0 : J.handleChainStart(this.toJSON(), Hq(q[T], "input"), _[T].runId, _[T].runType, void 0, void 0, _[T].runName ?? this.getName()));
      return delete _[T].runId, X;
    })), z;
    try {
      let J = $18.call(this, q, _, O, P);
      z = await m8(J, (_a2 = _ == null ? void 0 : _[0]) == null ? void 0 : _a2.signal);
    } catch (J) {
      throw await Promise.all(O.map((T) => T == null ? void 0 : T.handleChainError(J))), J;
    }
    return await Promise.all(O.map((J) => J == null ? void 0 : J.handleChainEnd(Hq(z, "output")))), z;
  }
  _concatOutputChunks($18, q) {
    return K9($18, q);
  }
  async *_transformStreamWithConfig($18, q, K) {
    let P, _ = true, Y, O = true, z = N6(K), J = await w8(z), T = this;
    async function* X() {
      for await (let V of $18) {
        if (_) if (P === void 0) P = V;
        else try {
          P = T._concatOutputChunks(P, V);
        } catch {
          P = void 0, _ = false;
        }
        yield V;
      }
    }
    let f;
    try {
      let V = await uY(q.bind(this), X(), async () => J == null ? void 0 : J.handleChainStart(this.toJSON(), { input: "" }, z.runId, z.runType, void 0, void 0, z.runName ?? this.getName()), K == null ? void 0 : K.signal, z);
      delete z.runId, f = V.setup;
      let M = f == null ? void 0 : f.handlers.find(NX), N = V.output;
      if (M !== void 0 && f !== void 0) N = M.tapOutputIterable(f.runId, N);
      let h = f == null ? void 0 : f.handlers.find(mY);
      if (h !== void 0 && f !== void 0) N = h.tapOutputIterable(f.runId, N);
      for await (let E of N) if (yield E, O) if (Y === void 0) Y = E;
      else try {
        Y = this._concatOutputChunks(Y, E);
      } catch {
        Y = void 0, O = false;
      }
    } catch (V) {
      throw await (f == null ? void 0 : f.handleChainError(V, void 0, void 0, void 0, { inputs: Hq(P, "input") })), V;
    }
    await (f == null ? void 0 : f.handleChainEnd(Y ?? {}, void 0, void 0, void 0, { inputs: Hq(P, "input") }));
  }
  getGraph($18) {
    let q = new T5(), K = q.addNode({ name: `${this.getName()}Input`, schema: S_.any() }), P = q.addNode(this), _ = q.addNode({ name: `${this.getName()}Output`, schema: S_.any() });
    return q.addEdge(K, P), q.addEdge(P, _), q;
  }
  pipe($18) {
    return new uA({ first: this, last: M_($18) });
  }
  pick($18) {
    return this.pipe(new Ib($18));
  }
  assign($18) {
    return this.pipe(new Rb(new kz({ steps: $18 })));
  }
  async *transform($18, q) {
    let K;
    for await (let P of $18) if (K === void 0) K = P;
    else K = this._concatOutputChunks(K, P);
    yield* this._streamIterator(K, N6(q));
  }
  async *streamLog($18, q, K) {
    let P = new v9({ ...K, autoClose: false, _schemaFormat: "original" }), _ = N6(q);
    yield* this._streamLog($18, P, _);
  }
  async *_streamLog($18, q, K) {
    let { callbacks: P } = K;
    if (P === void 0) K.callbacks = [q];
    else if (Array.isArray(P)) K.callbacks = P.concat([q]);
    else {
      let z = P.copy();
      z.addHandler(q, true), K.callbacks = z;
    }
    let _ = this.stream($18, K);
    async function Y() {
      try {
        let z = await _;
        for await (let J of z) {
          let T = new d8({ ops: [{ op: "add", path: "/streamed_output/-", value: J }] });
          await q.writer.write(T);
        }
      } finally {
        await q.writer.close();
      }
    }
    let O = Y();
    try {
      for await (let z of q) yield z;
    } finally {
      await O;
    }
  }
  streamEvents($18, q, K) {
    let P;
    if (q.version === "v1") P = this._streamEventsV1($18, q, K);
    else if (q.version === "v2") P = this._streamEventsV2($18, q, K);
    else throw Error('Only versions "v1" and "v2" of the schema are currently supported.');
    if (q.encoding === "text/event-stream") return LA(P);
    else return yq.fromAsyncGenerator(P);
  }
  async *_streamEventsV2($18, q, K) {
    var _a2;
    let P = new CX({ ...K, autoClose: false }), _ = N6(q), Y = _.runId ?? nq();
    _.runId = Y;
    let O = _.callbacks;
    if (O === void 0) _.callbacks = [P];
    else if (Array.isArray(O)) _.callbacks = O.concat(P);
    else {
      let M = O.copy();
      M.addHandler(P, true), _.callbacks = M;
    }
    let z = new AbortController(), J = this;
    async function T() {
      let M, N = null;
      try {
        if (q == null ? void 0 : q.signal) if ("any" in AbortSignal) M = AbortSignal.any([z.signal, q.signal]);
        else M = q.signal, N = () => {
          z.abort();
        }, q.signal.addEventListener("abort", N, { once: true });
        else M = z.signal;
        let h = await J.stream($18, { ..._, signal: M }), E = P.tapOutputIterable(Y, h);
        for await (let I of E) if (z.signal.aborted) break;
      } finally {
        if (await P.finish(), M && N) M.removeEventListener("abort", N);
      }
    }
    let X = T(), f = false, V;
    try {
      for await (let M of P) {
        if (!f) {
          M.data.input = $18, f = true, V = M.run_id, yield M;
          continue;
        }
        if (M.run_id === V && M.event.endsWith("_end")) {
          if ((_a2 = M.data) == null ? void 0 : _a2.input) delete M.data.input;
        }
        yield M;
      }
    } finally {
      z.abort(), await X;
    }
  }
  async *_streamEventsV1($18, q, K) {
    let P, _ = false, Y = N6(q), O = Y.tags ?? [], z = Y.metadata ?? {}, J = Y.runName ?? this.getName(), T = new v9({ ...K, autoClose: false, _schemaFormat: "streaming_events" }), X = new hX({ ...K }), f = this._streamLog($18, T, Y);
    for await (let M of f) {
      if (!P) P = j9.fromRunLogPatch(M);
      else P = P.concat(M);
      if (P.state === void 0) throw Error('Internal error: "streamEvents" state is missing. Please open a bug report.');
      if (!_) {
        _ = true;
        let I = { ...P.state }, D = { run_id: I.id, event: `on_${I.type}_start`, name: J, tags: O, metadata: z, data: { input: $18 } };
        if (X.includeEvent(D, I.type)) yield D;
      }
      let N = M.ops.filter((I) => I.path.startsWith("/logs/")).map((I) => I.path.split("/")[2]), h = [...new Set(N)];
      for (let I of h) {
        let D, g = {}, b = P.state.logs[I];
        if (b.end_time === void 0) if (b.streamed_output.length > 0) D = "stream";
        else D = "start";
        else D = "end";
        if (D === "start") {
          if (b.inputs !== void 0) g.input = b.inputs;
        } else if (D === "end") {
          if (b.inputs !== void 0) g.input = b.inputs;
          g.output = b.final_output;
        } else if (D === "stream") {
          let y = b.streamed_output.length;
          if (y !== 1) throw Error(`Expected exactly one chunk of streamed output, got ${y} instead. Encountered in: "${b.name}"`);
          g = { chunk: b.streamed_output[0] }, b.streamed_output = [];
        }
        yield { event: `on_${b.type}_${D}`, name: b.name, run_id: b.id, tags: b.tags, metadata: b.metadata, data: g };
      }
      let { state: E } = P;
      if (E.streamed_output.length > 0) {
        let I = E.streamed_output.length;
        if (I !== 1) throw Error(`Expected exactly one chunk of streamed output, got ${I} instead. Encountered in: "${E.name}"`);
        let D = { chunk: E.streamed_output[0] };
        E.streamed_output = [];
        let g = { event: `on_${E.type}_stream`, run_id: E.id, tags: O, metadata: z, name: J, data: D };
        if (X.includeEvent(g, E.type)) yield g;
      }
    }
    let V = P == null ? void 0 : P.state;
    if (V !== void 0) {
      let M = { event: `on_${V.type}_end`, name: J, run_id: V.id, tags: O, metadata: z, data: { output: V.final_output } };
      if (X.includeEvent(M, V.type)) yield M;
    }
  }
  static isRunnable($18) {
    return CP($18);
  }
  withListeners({ onStart: $18, onEnd: q, onError: K }) {
    return new Z5({ bound: this, config: {}, configFactories: [(P) => ({ callbacks: [new dY({ config: P, onStart: $18, onEnd: q, onError: K })] })] });
  }
  asTool($18) {
    return Db(this, $18);
  }
};
var Z5 = class $12 extends xq {
  constructor(q) {
    super(q);
    __publicField(this, "lc_namespace", ["langchain_core", "runnables"]);
    __publicField(this, "lc_serializable", true);
    __publicField(this, "bound");
    __publicField(this, "config");
    __publicField(this, "kwargs");
    __publicField(this, "configFactories");
    this.bound = q.bound, this.kwargs = q.kwargs, this.config = q.config, this.configFactories = q.configFactories;
  }
  static lc_name() {
    return "RunnableBinding";
  }
  getName(q) {
    return this.bound.getName(q);
  }
  async _mergeConfig(...q) {
    let K = yY(this.config, ...q);
    return yY(K, ...this.configFactories ? await Promise.all(this.configFactories.map(async (P) => await P(K))) : []);
  }
  withConfig(q) {
    return new this.constructor({ bound: this.bound, kwargs: this.kwargs, config: { ...this.config, ...q } });
  }
  withRetry(q) {
    return new yA({ bound: this.bound, kwargs: this.kwargs, config: this.config, maxAttemptNumber: q == null ? void 0 : q.stopAfterAttempt, ...q });
  }
  async invoke(q, K) {
    return this.bound.invoke(q, await this._mergeConfig(K, this.kwargs));
  }
  async batch(q, K, P) {
    let _ = Array.isArray(K) ? await Promise.all(K.map(async (Y) => this._mergeConfig(N6(Y), this.kwargs))) : await this._mergeConfig(N6(K), this.kwargs);
    return this.bound.batch(q, _, P);
  }
  _concatOutputChunks(q, K) {
    return this.bound._concatOutputChunks(q, K);
  }
  async *_streamIterator(q, K) {
    yield* this.bound._streamIterator(q, await this._mergeConfig(N6(K), this.kwargs));
  }
  async stream(q, K) {
    return this.bound.stream(q, await this._mergeConfig(N6(K), this.kwargs));
  }
  async *transform(q, K) {
    yield* this.bound.transform(q, await this._mergeConfig(N6(K), this.kwargs));
  }
  streamEvents(q, K, P) {
    let _ = this, Y = async function* () {
      yield* _.bound.streamEvents(q, { ...await _._mergeConfig(N6(K), _.kwargs), version: K.version }, P);
    };
    return yq.fromAsyncGenerator(Y());
  }
  static isRunnableBinding(q) {
    return q.bound && xq.isRunnable(q.bound);
  }
  withListeners({ onStart: q, onEnd: K, onError: P }) {
    return new $12({ bound: this.bound, kwargs: this.kwargs, config: this.config, configFactories: [(_) => ({ callbacks: [new dY({ config: _, onStart: q, onEnd: K, onError: P })] })] });
  }
};
var yA = class extends Z5 {
  constructor($18) {
    super($18);
    __publicField(this, "lc_namespace", ["langchain_core", "runnables"]);
    __publicField(this, "maxAttemptNumber", 3);
    __publicField(this, "onFailedAttempt", () => {
    });
    this.maxAttemptNumber = $18.maxAttemptNumber ?? this.maxAttemptNumber, this.onFailedAttempt = $18.onFailedAttempt ?? this.onFailedAttempt;
  }
  static lc_name() {
    return "RunnableRetry";
  }
  _patchConfigForRetry($18, q, K) {
    let P = $18 > 1 ? `retry:attempt:${$18}` : void 0;
    return hq(q, { callbacks: K == null ? void 0 : K.getChild(P) });
  }
  async _invoke($18, q, K) {
    return Az.default((P) => super.invoke($18, this._patchConfigForRetry(P, q, K)), { onFailedAttempt: (P) => this.onFailedAttempt(P, $18), retries: Math.max(this.maxAttemptNumber - 1, 0), randomize: true });
  }
  async invoke($18, q) {
    return this._callWithConfig(this._invoke.bind(this), $18, q);
  }
  async _batch($18, q, K, P) {
    let _ = {};
    try {
      await Az.default(async (Y) => {
        let O = $18.map((f, V) => V).filter((f) => _[f.toString()] === void 0 || _[f.toString()] instanceof Error), z = O.map((f) => $18[f]), J = O.map((f) => this._patchConfigForRetry(Y, q == null ? void 0 : q[f], K == null ? void 0 : K[f])), T = await super.batch(z, J, { ...P, returnExceptions: true }), X;
        for (let f = 0; f < T.length; f += 1) {
          let V = T[f], M = O[f];
          if (V instanceof Error) {
            if (X === void 0) X = V, X.input = z[f];
          }
          _[M.toString()] = V;
        }
        if (X) throw X;
        return T;
      }, { onFailedAttempt: (Y) => this.onFailedAttempt(Y, Y.input), retries: Math.max(this.maxAttemptNumber - 1, 0), randomize: true });
    } catch (Y) {
      if ((P == null ? void 0 : P.returnExceptions) !== true) throw Y;
    }
    return Object.keys(_).sort((Y, O) => parseInt(Y, 10) - parseInt(O, 10)).map((Y) => _[parseInt(Y, 10)]);
  }
  async batch($18, q, K) {
    return this._batchWithConfig(this._batch.bind(this), $18, q, K);
  }
};
var uA = class $13 extends xq {
  constructor(q) {
    super(q);
    __publicField(this, "first");
    __publicField(this, "middle", []);
    __publicField(this, "last");
    __publicField(this, "omitSequenceTags", false);
    __publicField(this, "lc_serializable", true);
    __publicField(this, "lc_namespace", ["langchain_core", "runnables"]);
    this.first = q.first, this.middle = q.middle ?? this.middle, this.last = q.last, this.name = q.name, this.omitSequenceTags = q.omitSequenceTags ?? this.omitSequenceTags;
  }
  static lc_name() {
    return "RunnableSequence";
  }
  get steps() {
    return [this.first, ...this.middle, this.last];
  }
  async invoke(q, K) {
    var _a2, _b2;
    let P = N6(K), Y = await ((_a2 = await w8(P)) == null ? void 0 : _a2.handleChainStart(this.toJSON(), Hq(q, "input"), P.runId, void 0, void 0, void 0, P == null ? void 0 : P.runName));
    delete P.runId;
    let O = q, z;
    try {
      let J = [this.first, ...this.middle];
      for (let T = 0; T < J.length; T += 1) {
        let f = J[T].invoke(O, hq(P, { callbacks: Y == null ? void 0 : Y.getChild(this.omitSequenceTags ? void 0 : `seq:step:${T + 1}`) }));
        O = await m8(f, K == null ? void 0 : K.signal);
      }
      if ((_b2 = K == null ? void 0 : K.signal) == null ? void 0 : _b2.aborted) throw o_(K.signal);
      z = await this.last.invoke(O, hq(P, { callbacks: Y == null ? void 0 : Y.getChild(this.omitSequenceTags ? void 0 : `seq:step:${this.steps.length}`) }));
    } catch (J) {
      throw await (Y == null ? void 0 : Y.handleChainError(J)), J;
    }
    return await (Y == null ? void 0 : Y.handleChainEnd(Hq(z, "output"))), z;
  }
  async batch(q, K, P) {
    var _a2;
    let _ = this._getOptionsList(K ?? {}, q.length), Y = await Promise.all(_.map(w8)), O = await Promise.all(Y.map(async (J, T) => {
      let X = await (J == null ? void 0 : J.handleChainStart(this.toJSON(), Hq(q[T], "input"), _[T].runId, void 0, void 0, void 0, _[T].runName));
      return delete _[T].runId, X;
    })), z = q;
    try {
      for (let J = 0; J < this.steps.length; J += 1) {
        let X = this.steps[J].batch(z, O.map((f, V) => {
          let M = f == null ? void 0 : f.getChild(this.omitSequenceTags ? void 0 : `seq:step:${J + 1}`);
          return hq(_[V], { callbacks: M });
        }), P);
        z = await m8(X, (_a2 = _[0]) == null ? void 0 : _a2.signal);
      }
    } catch (J) {
      throw await Promise.all(O.map((T) => T == null ? void 0 : T.handleChainError(J))), J;
    }
    return await Promise.all(O.map((J) => J == null ? void 0 : J.handleChainEnd(Hq(z, "output")))), z;
  }
  _concatOutputChunks(q, K) {
    return this.last._concatOutputChunks(q, K);
  }
  async *_streamIterator(q, K) {
    var _a2;
    let P = await w8(K), { runId: _, ...Y } = K ?? {}, O = await (P == null ? void 0 : P.handleChainStart(this.toJSON(), Hq(q, "input"), _, void 0, void 0, void 0, Y == null ? void 0 : Y.runName)), z = [this.first, ...this.middle, this.last], J = true, T;
    async function* X() {
      yield q;
    }
    try {
      let f = z[0].transform(X(), hq(Y, { callbacks: O == null ? void 0 : O.getChild(this.omitSequenceTags ? void 0 : "seq:step:1") }));
      for (let V = 1; V < z.length; V += 1) f = await z[V].transform(f, hq(Y, { callbacks: O == null ? void 0 : O.getChild(this.omitSequenceTags ? void 0 : `seq:step:${V + 1}`) }));
      for await (let V of f) if ((_a2 = K == null ? void 0 : K.signal) == null ? void 0 : _a2.throwIfAborted(), yield V, J) if (T === void 0) T = V;
      else try {
        T = this._concatOutputChunks(T, V);
      } catch {
        T = void 0, J = false;
      }
    } catch (f) {
      throw await (O == null ? void 0 : O.handleChainError(f)), f;
    }
    await (O == null ? void 0 : O.handleChainEnd(Hq(T, "output")));
  }
  getGraph(q) {
    let K = new T5(), P = null;
    return this.steps.forEach((_, Y) => {
      let O = _.getGraph(q);
      if (Y !== 0) O.trimFirstNode();
      if (Y !== this.steps.length - 1) O.trimLastNode();
      K.extend(O);
      let z = O.firstNode();
      if (!z) throw Error(`Runnable ${_} has no first node`);
      if (P) K.addEdge(P, z);
      P = O.lastNode();
    }), K;
  }
  pipe(q) {
    if ($13.isRunnableSequence(q)) return new $13({ first: this.first, middle: this.middle.concat([this.last, q.first, ...q.middle]), last: q.last, name: this.name ?? q.name });
    else return new $13({ first: this.first, middle: [...this.middle, this.last], last: M_(q), name: this.name });
  }
  static isRunnableSequence(q) {
    return Array.isArray(q.middle) && xq.isRunnable(q);
  }
  static from([q, ...K], P) {
    let _ = {};
    if (typeof P === "string") _.name = P;
    else if (P !== void 0) _ = P;
    return new $13({ ..._, first: M_(q), middle: K.slice(0, -1).map(M_), last: M_(K[K.length - 1]) });
  }
};
var kz = class $14 extends xq {
  constructor(q) {
    super(q);
    __publicField(this, "lc_namespace", ["langchain_core", "runnables"]);
    __publicField(this, "lc_serializable", true);
    __publicField(this, "steps");
    this.steps = {};
    for (let [K, P] of Object.entries(q.steps)) this.steps[K] = M_(P);
  }
  static lc_name() {
    return "RunnableMap";
  }
  getStepsKeys() {
    return Object.keys(this.steps);
  }
  static from(q) {
    return new $14({ steps: q });
  }
  async invoke(q, K) {
    var _a2;
    let P = N6(K), Y = await ((_a2 = await w8(P)) == null ? void 0 : _a2.handleChainStart(this.toJSON(), { input: q }, P.runId, void 0, void 0, void 0, P == null ? void 0 : P.runName));
    delete P.runId;
    let O = {};
    try {
      let z = Object.entries(this.steps).map(async ([J, T]) => {
        O[J] = await T.invoke(q, hq(P, { callbacks: Y == null ? void 0 : Y.getChild(`map:key:${J}`) }));
      });
      await m8(Promise.all(z), K == null ? void 0 : K.signal);
    } catch (z) {
      throw await (Y == null ? void 0 : Y.handleChainError(z)), z;
    }
    return await (Y == null ? void 0 : Y.handleChainEnd(O)), O;
  }
  async *_transform(q, K, P) {
    let _ = { ...this.steps }, Y = q9(q, Object.keys(_).length), O = new Map(Object.entries(_).map(([z, J], T) => {
      let X = J.transform(Y[T], hq(P, { callbacks: K == null ? void 0 : K.getChild(`map:key:${z}`) }));
      return [z, X.next().then((f) => ({ key: z, gen: X, result: f }))];
    }));
    while (O.size) {
      let z = Promise.race(O.values()), { key: J, result: T, gen: X } = await m8(z, P == null ? void 0 : P.signal);
      if (O.delete(J), !T.done) yield { [J]: T.value }, O.set(J, X.next().then((f) => ({ key: J, gen: X, result: f })));
    }
  }
  transform(q, K) {
    return this._transformStreamWithConfig(q, this._transform.bind(this), K);
  }
  async stream(q, K) {
    async function* P() {
      yield q;
    }
    let _ = N6(K), Y = new uK({ generator: this.transform(P(), _), config: _ });
    return await Y.setup, yq.fromAsyncGenerator(Y);
  }
};
var Cb = class $15 extends xq {
  constructor(q) {
    super(q);
    __publicField(this, "lc_serializable", false);
    __publicField(this, "lc_namespace", ["langchain_core", "runnables"]);
    __publicField(this, "func");
    if (!e1(q.func)) throw Error("RunnableTraceable requires a function that is wrapped in traceable higher-order function");
    this.func = q.func;
  }
  async invoke(q, K) {
    let [P] = this._getOptionsList(K ?? {}, 1), _ = await w8(P), Y = this.func(hq(P, { callbacks: _ }), q);
    return m8(Y, P == null ? void 0 : P.signal);
  }
  async *_streamIterator(q, K) {
    var _a2, _b2;
    let [P] = this._getOptionsList(K ?? {}, 1), _ = await this.invoke(q, K);
    if (w5(_)) {
      for await (let Y of _) (_a2 = P == null ? void 0 : P.signal) == null ? void 0 : _a2.throwIfAborted(), yield Y;
      return;
    }
    if (gA(_)) {
      while (true) {
        (_b2 = P == null ? void 0 : P.signal) == null ? void 0 : _b2.throwIfAborted();
        let Y = _.next();
        if (Y.done) break;
        yield Y.value;
      }
      return;
    }
    yield _;
  }
  static from(q) {
    return new $15({ func: q });
  }
};
function Eb($18) {
  if (e1($18)) throw Error("RunnableLambda requires a function that is not wrapped in traceable higher-order function. This shouldn't happen.");
}
var xA = class $16 extends xq {
  constructor(q) {
    if (e1(q.func)) return Cb.from(q.func);
    super(q);
    __publicField(this, "lc_namespace", ["langchain_core", "runnables"]);
    __publicField(this, "func");
    Eb(q.func), this.func = q.func;
  }
  static lc_name() {
    return "RunnableLambda";
  }
  static from(q) {
    return new $16({ func: q });
  }
  async _invoke(q, K, P) {
    return new Promise((_, Y) => {
      let O = hq(K, { callbacks: P == null ? void 0 : P.getChild(), recursionLimit: ((K == null ? void 0 : K.recursionLimit) ?? $9) - 1 });
      tq.runWithConfig(YK(O), async () => {
        var _a2, _b2;
        try {
          let z = await this.func(q, { ...O });
          if (z && xq.isRunnable(z)) {
            if ((K == null ? void 0 : K.recursionLimit) === 0) throw Error("Recursion limit reached.");
            z = await z.invoke(q, { ...O, recursionLimit: (O.recursionLimit ?? $9) - 1 });
          } else if (w5(z)) {
            let J;
            for await (let T of f5(O, z)) if ((_a2 = K == null ? void 0 : K.signal) == null ? void 0 : _a2.throwIfAborted(), J === void 0) J = T;
            else try {
              J = this._concatOutputChunks(J, T);
            } catch {
              J = T;
            }
            z = J;
          } else if (Zz(z)) {
            let J;
            for (let T of Xz(O, z)) if ((_b2 = K == null ? void 0 : K.signal) == null ? void 0 : _b2.throwIfAborted(), J === void 0) J = T;
            else try {
              J = this._concatOutputChunks(J, T);
            } catch {
              J = T;
            }
            z = J;
          }
          _(z);
        } catch (z) {
          Y(z);
        }
      });
    });
  }
  async invoke(q, K) {
    return this._callWithConfig(this._invoke.bind(this), q, K);
  }
  async *_transform(q, K, P) {
    var _a2, _b2;
    let _;
    for await (let z of q) if (_ === void 0) _ = z;
    else try {
      _ = this._concatOutputChunks(_, z);
    } catch {
      _ = z;
    }
    let Y = hq(P, { callbacks: K == null ? void 0 : K.getChild(), recursionLimit: ((P == null ? void 0 : P.recursionLimit) ?? $9) - 1 }), O = await new Promise((z, J) => {
      tq.runWithConfig(YK(Y), async () => {
        try {
          let T = await this.func(_, { ...Y, config: Y });
          z(T);
        } catch (T) {
          J(T);
        }
      });
    });
    if (O && xq.isRunnable(O)) {
      if ((P == null ? void 0 : P.recursionLimit) === 0) throw Error("Recursion limit reached.");
      let z = await O.stream(_, Y);
      for await (let J of z) yield J;
    } else if (w5(O)) for await (let z of f5(Y, O)) (_a2 = P == null ? void 0 : P.signal) == null ? void 0 : _a2.throwIfAborted(), yield z;
    else if (Zz(O)) for (let z of Xz(Y, O)) (_b2 = P == null ? void 0 : P.signal) == null ? void 0 : _b2.throwIfAborted(), yield z;
    else yield O;
  }
  transform(q, K) {
    return this._transformStreamWithConfig(q, this._transform.bind(this), K);
  }
  async stream(q, K) {
    async function* P() {
      yield q;
    }
    let _ = N6(K), Y = new uK({ generator: this.transform(P(), _), config: _ });
    return await Y.setup, yq.fromAsyncGenerator(Y);
  }
};
var hb = class extends xq {
  constructor($18) {
    super($18);
    __publicField(this, "lc_namespace", ["langchain_core", "runnables"]);
    __publicField(this, "lc_serializable", true);
    __publicField(this, "runnable");
    __publicField(this, "fallbacks");
    this.runnable = $18.runnable, this.fallbacks = $18.fallbacks;
  }
  static lc_name() {
    return "RunnableWithFallbacks";
  }
  *runnables() {
    yield this.runnable;
    for (let $18 of this.fallbacks) yield $18;
  }
  async invoke($18, q) {
    let K = N6(q), P = await w8(K), { runId: _, ...Y } = K, O = await (P == null ? void 0 : P.handleChainStart(this.toJSON(), Hq($18, "input"), _, void 0, void 0, void 0, Y == null ? void 0 : Y.runName)), z = hq(Y, { callbacks: O == null ? void 0 : O.getChild() });
    return await tq.runWithConfig(z, async () => {
      var _a2;
      let T;
      for (let X of this.runnables()) {
        (_a2 = K == null ? void 0 : K.signal) == null ? void 0 : _a2.throwIfAborted();
        try {
          let f = await X.invoke($18, z);
          return await (O == null ? void 0 : O.handleChainEnd(Hq(f, "output"))), f;
        } catch (f) {
          if (T === void 0) T = f;
        }
      }
      if (T === void 0) throw Error("No error stored at end of fallback.");
      throw await (O == null ? void 0 : O.handleChainError(T)), T;
    });
  }
  async *_streamIterator($18, q) {
    var _a2;
    let K = N6(q), P = await w8(K), { runId: _, ...Y } = K, O = await (P == null ? void 0 : P.handleChainStart(this.toJSON(), Hq($18, "input"), _, void 0, void 0, void 0, Y == null ? void 0 : Y.runName)), z, J;
    for (let X of this.runnables()) {
      (_a2 = K == null ? void 0 : K.signal) == null ? void 0 : _a2.throwIfAborted();
      let f = hq(Y, { callbacks: O == null ? void 0 : O.getChild() });
      try {
        let V = await X.stream($18, f);
        J = f5(f, V);
        break;
      } catch (V) {
        if (z === void 0) z = V;
      }
    }
    if (J === void 0) {
      let X = z ?? Error("No error stored at end of fallback.");
      throw await (O == null ? void 0 : O.handleChainError(X)), X;
    }
    let T;
    try {
      for await (let X of J) {
        yield X;
        try {
          T = T === void 0 ? T : this._concatOutputChunks(T, X);
        } catch {
          T = void 0;
        }
      }
    } catch (X) {
      throw await (O == null ? void 0 : O.handleChainError(X)), X;
    }
    await (O == null ? void 0 : O.handleChainEnd(Hq(T, "output")));
  }
  async batch($18, q, K) {
    var _a2;
    if (K == null ? void 0 : K.returnExceptions) throw Error("Not implemented.");
    let P = this._getOptionsList(q ?? {}, $18.length), _ = await Promise.all(P.map((z) => w8(z))), Y = await Promise.all(_.map(async (z, J) => {
      let T = await (z == null ? void 0 : z.handleChainStart(this.toJSON(), Hq($18[J], "input"), P[J].runId, void 0, void 0, void 0, P[J].runName));
      return delete P[J].runId, T;
    })), O;
    for (let z of this.runnables()) {
      (_a2 = P[0].signal) == null ? void 0 : _a2.throwIfAborted();
      try {
        let J = await z.batch($18, Y.map((T, X) => hq(P[X], { callbacks: T == null ? void 0 : T.getChild() })), K);
        return await Promise.all(Y.map((T, X) => T == null ? void 0 : T.handleChainEnd(Hq(J[X], "output")))), J;
      } catch (J) {
        if (O === void 0) O = J;
      }
    }
    if (!O) throw Error("No error stored at end of fallbacks.");
    throw await Promise.all(Y.map((z) => z == null ? void 0 : z.handleChainError(O))), O;
  }
};
function M_($18) {
  if (typeof $18 === "function") return new xA({ func: $18 });
  else if (xq.isRunnable($18)) return $18;
  else if (!Array.isArray($18) && typeof $18 === "object") {
    let q = {};
    for (let [K, P] of Object.entries($18)) q[K] = M_(P);
    return new kz({ steps: q });
  } else throw Error(`Expected a Runnable, function or object.
Instead got an unsupported type.`);
}
var Rb = class extends xq {
  constructor($18) {
    if ($18 instanceof kz) $18 = { mapper: $18 };
    super($18);
    __publicField(this, "lc_namespace", ["langchain_core", "runnables"]);
    __publicField(this, "lc_serializable", true);
    __publicField(this, "mapper");
    this.mapper = $18.mapper;
  }
  static lc_name() {
    return "RunnableAssign";
  }
  async invoke($18, q) {
    let K = await this.mapper.invoke($18, q);
    return { ...$18, ...K };
  }
  async *_transform($18, q, K) {
    let P = this.mapper.getStepsKeys(), [_, Y] = q9($18), O = this.mapper.transform(Y, hq(K, { callbacks: q == null ? void 0 : q.getChild() })), z = O.next();
    for await (let J of _) {
      if (typeof J !== "object" || Array.isArray(J)) throw Error(`RunnableAssign can only be used with objects as input, got ${typeof J}`);
      let T = Object.fromEntries(Object.entries(J).filter(([X]) => !P.includes(X)));
      if (Object.keys(T).length > 0) yield T;
    }
    yield (await z).value;
    for await (let J of O) yield J;
  }
  transform($18, q) {
    return this._transformStreamWithConfig($18, this._transform.bind(this), q);
  }
  async stream($18, q) {
    async function* K() {
      yield $18;
    }
    let P = N6(q), _ = new uK({ generator: this.transform(K(), P), config: P });
    return await _.setup, yq.fromAsyncGenerator(_);
  }
};
var Ib = class extends xq {
  constructor($18) {
    if (typeof $18 === "string" || Array.isArray($18)) $18 = { keys: $18 };
    super($18);
    __publicField(this, "lc_namespace", ["langchain_core", "runnables"]);
    __publicField(this, "lc_serializable", true);
    __publicField(this, "keys");
    this.keys = $18.keys;
  }
  static lc_name() {
    return "RunnablePick";
  }
  async _pick($18) {
    if (typeof this.keys === "string") return $18[this.keys];
    else {
      let q = this.keys.map((K) => [K, $18[K]]).filter((K) => K[1] !== void 0);
      return q.length === 0 ? void 0 : Object.fromEntries(q);
    }
  }
  async invoke($18, q) {
    return this._callWithConfig(this._pick.bind(this), $18, q);
  }
  async *_transform($18) {
    for await (let q of $18) {
      let K = await this._pick(q);
      if (K !== void 0) yield K;
    }
  }
  transform($18, q) {
    return this._transformStreamWithConfig($18, this._transform.bind(this), q);
  }
  async stream($18, q) {
    async function* K() {
      yield $18;
    }
    let P = N6(q), _ = new uK({ generator: this.transform(K(), P), config: P });
    return await _.setup, yq.fromAsyncGenerator(_);
  }
};
var bA = class extends Z5 {
  constructor($18) {
    let q = uA.from([xA.from(async (K) => {
      let P;
      if (LO(K)) try {
        P = await YA(this.schema, K.args);
      } catch {
        throw new sJ("Received tool input did not match expected schema", JSON.stringify(K.args));
      }
      else P = K;
      return P;
    }).withConfig({ runName: `${$18.name}:parse_input` }), $18.bound]).withConfig({ runName: $18.name });
    super({ bound: q, config: $18.config ?? {} });
    __publicField(this, "name");
    __publicField(this, "description");
    __publicField(this, "schema");
    this.name = $18.name, this.description = $18.description, this.schema = $18.schema;
  }
  static lc_name() {
    return "RunnableToolLike";
  }
};
function Db($18, q) {
  let K = q.name ?? $18.getName(), P = q.description ?? jA(q.schema);
  if (vA(q.schema)) return new bA({ name: K, description: P, schema: S_.object({ input: S_.string() }).transform((_) => _.input), bound: $18 });
  return new bA({ name: K, description: P, schema: q.schema, bound: $18 });
}
var S7 = class extends xq {
  constructor() {
    super(...arguments);
    __publicField(this, "lc_namespace", ["langchain_core", "documents", "transformers"]);
  }
  invoke($18, q) {
    return this.transformDocuments($18);
  }
};
var pA = class extends S7 {
  async transformDocuments($18) {
    let q = [];
    for (let K of $18) {
      let P = await this._transformDocument(K);
      q.push(P);
    }
    return q;
  }
};
var Lb = {};
Z6(Lb, { BaseDocumentTransformer: () => S7, Document: () => W1, MappingDocumentTransformer: () => pA });
var dA = q8(mA(), 1);
var ob = Object.defineProperty;
var nb = ($18, q, K) => q in $18 ? ob($18, q, { enumerable: true, configurable: true, writable: true, value: K }) : $18[q] = K;
var ib = ($18, q, K) => {
  return nb($18, typeof q !== "symbol" ? q + "" : q, K), K;
};
function Bb($18, q) {
  let K = Array.from({ length: $18.length }, (P, _) => ({ start: _, end: _ + 1 }));
  while (K.length > 1) {
    let P = null;
    for (let _ = 0; _ < K.length - 1; _++) {
      let Y = $18.slice(K[_].start, K[_ + 1].end), O = q.get(Y.join(","));
      if (O == null) continue;
      if (P == null || O < P[0]) P = [O, _];
    }
    if (P != null) {
      let _ = P[1];
      K[_] = { start: K[_].start, end: K[_ + 1].end }, K.splice(_ + 1, 1);
    } else break;
  }
  return K;
}
function tb($18, q) {
  if ($18.length === 1) return [q.get($18.join(","))];
  return Bb($18, q).map((K) => q.get($18.slice(K.start, K.end).join(","))).filter((K) => K != null);
}
function Ub($18) {
  return $18.replace(/[\\^$*+?.()|[\]{}]/g, "\\$&");
}
var Sz = class {
  constructor($18, q) {
    __publicField(this, "specialTokens");
    __publicField(this, "inverseSpecialTokens");
    __publicField(this, "patStr");
    __publicField(this, "textEncoder", new TextEncoder());
    __publicField(this, "textDecoder", new TextDecoder("utf-8"));
    __publicField(this, "rankMap", /* @__PURE__ */ new Map());
    __publicField(this, "textMap", /* @__PURE__ */ new Map());
    this.patStr = $18.pat_str;
    let K = $18.bpe_ranks.split(`
`).filter(Boolean).reduce((P, _) => {
      let [Y, O, ...z] = _.split(" "), J = Number.parseInt(O, 10);
      return z.forEach((T, X) => P[T] = J + X), P;
    }, {});
    for (let [P, _] of Object.entries(K)) {
      let Y = dA.default.toByteArray(P);
      this.rankMap.set(Y.join(","), _), this.textMap.set(_, Y);
    }
    this.specialTokens = { ...$18.special_tokens, ...q }, this.inverseSpecialTokens = Object.entries(this.specialTokens).reduce((P, [_, Y]) => {
      return P[Y] = this.textEncoder.encode(_), P;
    }, {});
  }
  encode($18, q = [], K = "all") {
    let P = new RegExp(this.patStr, "ug"), _ = Sz.specialTokenRegex(Object.keys(this.specialTokens)), Y = [], O = new Set(q === "all" ? Object.keys(this.specialTokens) : q), z = new Set(K === "all" ? Object.keys(this.specialTokens).filter((T) => !O.has(T)) : K);
    if (z.size > 0) {
      let T = Sz.specialTokenRegex([...z]), X = $18.match(T);
      if (X != null) throw Error(`The text contains a special token that is not allowed: ${X[0]}`);
    }
    let J = 0;
    while (true) {
      let T = null, X = J;
      while (true) {
        if (_.lastIndex = X, T = _.exec($18), T == null || O.has(T[0])) break;
        X = T.index + 1;
      }
      let f = (T == null ? void 0 : T.index) ?? $18.length;
      for (let M of $18.substring(J, f).matchAll(P)) {
        let N = this.textEncoder.encode(M[0]), h = this.rankMap.get(N.join(","));
        if (h != null) {
          Y.push(h);
          continue;
        }
        Y.push(...tb(N, this.rankMap));
      }
      if (T == null) break;
      let V = this.specialTokens[T[0]];
      Y.push(V), J = T.index + T[0].length;
    }
    return Y;
  }
  decode($18) {
    let q = [], K = 0;
    for (let Y = 0; Y < $18.length; ++Y) {
      let O = $18[Y], z = this.textMap.get(O) ?? this.inverseSpecialTokens[O];
      if (z != null) q.push(z), K += z.length;
    }
    let P = new Uint8Array(K), _ = 0;
    for (let Y of q) P.set(Y, _), _ += Y.length;
    return this.textDecoder.decode(P);
  }
};
var X5 = Sz;
ib(X5, "specialTokenRegex", ($18) => {
  return new RegExp($18.map((q) => Ub(q)).join("|"), "g");
});
function Mz($18) {
  switch ($18) {
    case "gpt2":
      return "gpt2";
    case "code-cushman-001":
    case "code-cushman-002":
    case "code-davinci-001":
    case "code-davinci-002":
    case "cushman-codex":
    case "davinci-codex":
    case "davinci-002":
    case "text-davinci-002":
    case "text-davinci-003":
      return "p50k_base";
    case "code-davinci-edit-001":
    case "text-davinci-edit-001":
      return "p50k_edit";
    case "ada":
    case "babbage":
    case "babbage-002":
    case "code-search-ada-code-001":
    case "code-search-babbage-code-001":
    case "curie":
    case "davinci":
    case "text-ada-001":
    case "text-babbage-001":
    case "text-curie-001":
    case "text-davinci-001":
    case "text-search-ada-doc-001":
    case "text-search-babbage-doc-001":
    case "text-search-curie-doc-001":
    case "text-search-davinci-doc-001":
    case "text-similarity-ada-001":
    case "text-similarity-babbage-001":
    case "text-similarity-curie-001":
    case "text-similarity-davinci-001":
      return "r50k_base";
    case "gpt-3.5-turbo-instruct-0914":
    case "gpt-3.5-turbo-instruct":
    case "gpt-3.5-turbo-16k-0613":
    case "gpt-3.5-turbo-16k":
    case "gpt-3.5-turbo-0613":
    case "gpt-3.5-turbo-0301":
    case "gpt-3.5-turbo":
    case "gpt-4-32k-0613":
    case "gpt-4-32k-0314":
    case "gpt-4-32k":
    case "gpt-4-0613":
    case "gpt-4-0314":
    case "gpt-4":
    case "gpt-3.5-turbo-1106":
    case "gpt-35-turbo":
    case "gpt-4-1106-preview":
    case "gpt-4-vision-preview":
    case "gpt-3.5-turbo-0125":
    case "gpt-4-turbo":
    case "gpt-4-turbo-2024-04-09":
    case "gpt-4-turbo-preview":
    case "gpt-4-0125-preview":
    case "text-embedding-ada-002":
    case "text-embedding-3-small":
    case "text-embedding-3-large":
      return "cl100k_base";
    case "gpt-4o":
    case "gpt-4o-2024-05-13":
    case "gpt-4o-2024-08-06":
    case "gpt-4o-2024-11-20":
    case "gpt-4o-mini-2024-07-18":
    case "gpt-4o-mini":
    case "gpt-4o-search-preview":
    case "gpt-4o-search-preview-2025-03-11":
    case "gpt-4o-mini-search-preview":
    case "gpt-4o-mini-search-preview-2025-03-11":
    case "gpt-4o-audio-preview":
    case "gpt-4o-audio-preview-2024-12-17":
    case "gpt-4o-audio-preview-2024-10-01":
    case "gpt-4o-mini-audio-preview":
    case "gpt-4o-mini-audio-preview-2024-12-17":
    case "o1":
    case "o1-2024-12-17":
    case "o1-mini":
    case "o1-mini-2024-09-12":
    case "o1-preview":
    case "o1-preview-2024-09-12":
    case "o1-pro":
    case "o1-pro-2025-03-19":
    case "o3":
    case "o3-2025-04-16":
    case "o3-mini":
    case "o3-mini-2025-01-31":
    case "o4-mini":
    case "o4-mini-2025-04-16":
    case "chatgpt-4o-latest":
    case "gpt-4o-realtime":
    case "gpt-4o-realtime-preview-2024-10-01":
    case "gpt-4o-realtime-preview-2024-12-17":
    case "gpt-4o-mini-realtime-preview":
    case "gpt-4o-mini-realtime-preview-2024-12-17":
    case "gpt-4.1":
    case "gpt-4.1-2025-04-14":
    case "gpt-4.1-mini":
    case "gpt-4.1-mini-2025-04-14":
    case "gpt-4.1-nano":
    case "gpt-4.1-nano-2025-04-14":
    case "gpt-4.5-preview":
    case "gpt-4.5-preview-2025-02-27":
    case "gpt-5":
    case "gpt-5-2025-08-07":
    case "gpt-5-nano":
    case "gpt-5-nano-2025-08-07":
    case "gpt-5-mini":
    case "gpt-5-mini-2025-08-07":
    case "gpt-5-chat-latest":
      return "o200k_base";
    default:
      throw Error("Unknown model");
  }
}
var Fb = {};
Z6(Fb, { encodingForModel: () => Qb, getEncoding: () => Nz });
var A5 = {};
var ab = new NP({});
async function Nz($18) {
  if (!($18 in A5)) A5[$18] = ab.fetch(`https://tiktoken.pages.dev/js/${$18}.json`).then((q) => q.json()).then((q) => new X5(q)).catch((q) => {
    throw delete A5[$18], q;
  });
  return await A5[$18];
}
async function Qb($18) {
  return Nz(Mz($18));
}
var lA = class extends S7 {
  constructor($18) {
    super($18);
    __publicField(this, "lc_namespace", ["langchain", "document_transformers", "text_splitters"]);
    __publicField(this, "chunkSize", 1e3);
    __publicField(this, "chunkOverlap", 200);
    __publicField(this, "keepSeparator", false);
    __publicField(this, "lengthFunction");
    if (this.chunkSize = ($18 == null ? void 0 : $18.chunkSize) ?? this.chunkSize, this.chunkOverlap = ($18 == null ? void 0 : $18.chunkOverlap) ?? this.chunkOverlap, this.keepSeparator = ($18 == null ? void 0 : $18.keepSeparator) ?? this.keepSeparator, this.lengthFunction = ($18 == null ? void 0 : $18.lengthFunction) ?? ((q) => q.length), this.chunkOverlap >= this.chunkSize) throw Error("Cannot have chunkOverlap >= chunkSize");
  }
  async transformDocuments($18, q = {}) {
    return this.splitDocuments($18, q);
  }
  splitOnSeparator($18, q) {
    let K;
    if (q) if (this.keepSeparator) {
      let P = q.replace(/[/\-\\^$*+?.()|[\]{}]/g, "\\$&");
      K = $18.split(new RegExp(`(?=${P})`));
    } else K = $18.split(q);
    else K = $18.split("");
    return K.filter((P) => P !== "");
  }
  async createDocuments($18, q = [], K = {}) {
    let P = q.length > 0 ? q : [...Array($18.length)].map(() => ({})), { chunkHeader: _ = "", chunkOverlapHeader: Y = "(cont'd) ", appendChunkOverlapHeader: O = false } = K, z = [];
    for (let J = 0; J < $18.length; J += 1) {
      let T = $18[J], X = 1, f = null, V = -1;
      for (let M of await this.splitText(T)) {
        let N = _, h = T.indexOf(M, V + 1);
        if (f === null) {
          let g = this.numberOfNewLines(T, 0, h);
          X += g;
        } else {
          let g = V + await this.lengthFunction(f);
          if (g < h) {
            let b = this.numberOfNewLines(T, g, h);
            X += b;
          } else if (g > h) {
            let b = this.numberOfNewLines(T, h, g);
            X -= b;
          }
          if (O) N += Y;
        }
        let E = this.numberOfNewLines(M), I = P[J].loc && typeof P[J].loc === "object" ? { ...P[J].loc } : {};
        I.lines = { from: X, to: X + E };
        let D = { ...P[J], loc: I };
        N += M, z.push(new W1({ pageContent: N, metadata: D })), X += E, f = M, V = h;
      }
    }
    return z;
  }
  numberOfNewLines($18, q, K) {
    return ($18.slice(q, K).match(/\n/g) || []).length;
  }
  async splitDocuments($18, q = {}) {
    let K = $18.filter((Y) => Y.pageContent !== void 0), P = K.map((Y) => Y.pageContent), _ = K.map((Y) => Y.metadata);
    return this.createDocuments(P, _, q);
  }
  joinDocs($18, q) {
    let K = $18.join(q).trim();
    return K === "" ? null : K;
  }
  async mergeSplits($18, q) {
    let K = [], P = [], _ = 0;
    for (let O of $18) {
      let z = await this.lengthFunction(O);
      if (_ + z + P.length * q.length > this.chunkSize) {
        if (_ > this.chunkSize) console.warn(`Created a chunk of size ${_}, +
which is longer than the specified ${this.chunkSize}`);
        if (P.length > 0) {
          let J = this.joinDocs(P, q);
          if (J !== null) K.push(J);
          while (_ > this.chunkOverlap || _ + z + P.length * q.length > this.chunkSize && _ > 0) _ -= await this.lengthFunction(P[0]), P.shift();
        }
      }
      P.push(O), _ += z;
    }
    let Y = this.joinDocs(P, q);
    if (Y !== null) K.push(Y);
    return K;
  }
};
var Cz = class $17 extends lA {
  constructor(q) {
    super(q);
    __publicField(this, "separators", [`

`, `
`, " ", ""]);
    this.separators = (q == null ? void 0 : q.separators) ?? this.separators, this.keepSeparator = (q == null ? void 0 : q.keepSeparator) ?? true;
  }
  static lc_name() {
    return "RecursiveCharacterTextSplitter";
  }
  async _splitText(q, K) {
    let P = [], _ = K[K.length - 1], Y;
    for (let T = 0; T < K.length; T += 1) {
      let X = K[T];
      if (X === "") {
        _ = X;
        break;
      }
      if (q.includes(X)) {
        _ = X, Y = K.slice(T + 1);
        break;
      }
    }
    let O = this.splitOnSeparator(q, _), z = [], J = this.keepSeparator ? "" : _;
    for (let T of O) if (await this.lengthFunction(T) < this.chunkSize) z.push(T);
    else {
      if (z.length) {
        let X = await this.mergeSplits(z, J);
        P.push(...X), z = [];
      }
      if (!Y) P.push(T);
      else {
        let X = await this._splitText(T, Y);
        P.push(...X);
      }
    }
    if (z.length) {
      let T = await this.mergeSplits(z, J);
      P.push(...T);
    }
    return P;
  }
  async splitText(q) {
    return this._splitText(q, this.separators);
  }
  static fromLanguage(q, K) {
    return new $17({ ...K, separators: $17.getSeparatorsForLanguage(q) });
  }
  static getSeparatorsForLanguage(q) {
    if (q === "cpp") return [`
class `, `
void `, `
int `, `
float `, `
double `, `
if `, `
for `, `
while `, `
switch `, `
case `, `

`, `
`, " ", ""];
    else if (q === "go") return [`
func `, `
var `, `
const `, `
type `, `
if `, `
for `, `
switch `, `
case `, `

`, `
`, " ", ""];
    else if (q === "java") return [`
class `, `
public `, `
protected `, `
private `, `
static `, `
if `, `
for `, `
while `, `
switch `, `
case `, `

`, `
`, " ", ""];
    else if (q === "js") return [`
function `, `
const `, `
let `, `
var `, `
class `, `
if `, `
for `, `
while `, `
switch `, `
case `, `
default `, `

`, `
`, " ", ""];
    else if (q === "php") return [`
function `, `
class `, `
if `, `
foreach `, `
while `, `
do `, `
switch `, `
case `, `

`, `
`, " ", ""];
    else if (q === "proto") return [`
message `, `
service `, `
enum `, `
option `, `
import `, `
syntax `, `

`, `
`, " ", ""];
    else if (q === "python") return [`
class `, `
def `, `
	def `, `

`, `
`, " ", ""];
    else if (q === "rst") return [`
===
`, `
---
`, `
***
`, `
.. `, `

`, `
`, " ", ""];
    else if (q === "ruby") return [`
def `, `
class `, `
if `, `
unless `, `
while `, `
for `, `
do `, `
begin `, `
rescue `, `

`, `
`, " ", ""];
    else if (q === "rust") return [`
fn `, `
const `, `
let `, `
if `, `
while `, `
for `, `
loop `, `
match `, `
const `, `

`, `
`, " ", ""];
    else if (q === "scala") return [`
class `, `
object `, `
def `, `
val `, `
var `, `
if `, `
for `, `
while `, `
match `, `
case `, `

`, `
`, " ", ""];
    else if (q === "swift") return [`
func `, `
class `, `
struct `, `
enum `, `
if `, `
for `, `
while `, `
do `, `
switch `, `
case `, `

`, `
`, " ", ""];
    else if (q === "markdown") return [`
## `, `
### `, `
#### `, `
##### `, `
###### `, "```\n\n", `

***

`, `

---

`, `

___

`, `

`, `
`, " ", ""];
    else if (q === "latex") return [`
\\chapter{`, `
\\section{`, `
\\subsection{`, `
\\subsubsection{`, `
\\begin{enumerate}`, `
\\begin{itemize}`, `
\\begin{description}`, `
\\begin{list}`, `
\\begin{quote}`, `
\\begin{quotation}`, `
\\begin{verse}`, `
\\begin{verbatim}`, `
\\begin{align}`, "$$", "$", `

`, `
`, " ", ""];
    else if (q === "html") return ["<body>", "<div>", "<p>", "<br>", "<li>", "<h1>", "<h2>", "<h3>", "<h4>", "<h5>", "<h6>", "<span>", "<table>", "<tr>", "<td>", "<th>", "<ul>", "<ol>", "<header>", "<footer>", "<nav>", "<head>", "<style>", "<script>", "<meta>", "<title>", " ", ""];
    else if (q === "sol") return [`
pragma `, `
using `, `
contract `, `
interface `, `
library `, `
constructor `, `
type `, `
function `, `
event `, `
modifier `, `
error `, `
struct `, `
enum `, `
if `, `
for `, `
while `, `
do while `, `
assembly `, `

`, `
`, " ", ""];
    else throw Error(`Language ${q} is not supported.`);
  }
};
var NJ = q8(rG(), 1);
var oG = ($18) => {
  $18 = 1831565813 + ($18 |= 0) | 0;
  let q = Math.imul($18 ^ $18 >>> 15, 1 | $18);
  return q = q + Math.imul(q ^ q >>> 7, 61 | q) ^ q, ((q ^ q >>> 14) >>> 0) / 4294967296;
};
var iG = class {
  constructor($18) {
    this.dictionaries = void 0, this.length = void 0, this.separator = void 0, this.style = void 0, this.seed = void 0;
    let { length: q, separator: K, dictionaries: P, style: _, seed: Y } = $18;
    this.dictionaries = P, this.separator = K, this.length = q, this.style = _, this.seed = Y;
  }
  generate() {
    if (!this.dictionaries) throw Error('Cannot find any dictionary. Please provide at least one, or leave the "dictionary" field empty in the config object');
    if (this.length <= 0) throw Error("Invalid length provided");
    if (this.length > this.dictionaries.length) throw Error(`The length cannot be bigger than the number of dictionaries.
Length provided: ${this.length}. Number of dictionaries provided: ${this.dictionaries.length}`);
    let $18 = this.seed;
    return this.dictionaries.slice(0, this.length).reduce((q, K) => {
      let P;
      $18 ? (P = ((Y) => {
        if (typeof Y == "string") {
          let O = Y.split("").map((J) => J.charCodeAt(0)).reduce((J, T) => J + T, 1), z = Math.floor(Number(O));
          return oG(z);
        }
        return oG(Y);
      })($18), $18 = 4294967296 * P) : P = Math.random();
      let _ = K[Math.floor(P * K.length)] || "";
      if (this.style === "lowerCase") _ = _.toLowerCase();
      else if (this.style === "capital") {
        let [Y, ...O] = _.split("");
        _ = Y.toUpperCase() + O.join("");
      } else this.style === "upperCase" && (_ = _.toUpperCase());
      return q ? `${q}${this.separator}${_}` : `${_}`;
    }, "");
  }
};
var nG = { separator: "_", dictionaries: [] };
var I5 = ($18) => {
  let q = [...$18 && $18.dictionaries || nG.dictionaries], K = { ...nG, ...$18, length: $18 && $18.length || q.length, dictionaries: q };
  if (!$18 || !$18.dictionaries || !$18.dictionaries.length) throw Error('A "dictionaries" array must be provided. This is a breaking change introduced starting from Unique Name Generator v4. Read more about the breaking change here: https://github.com/andreasonny83/unique-names-generator#migration-guide');
  return new iG(K).generate();
};
var D5 = ["Aaren", "Aarika", "Abagael", "Abagail", "Abbe", "Abbey", "Abbi", "Abbie", "Abby", "Abbye", "Abigael", "Abigail", "Abigale", "Abra", "Ada", "Adah", "Adaline", "Adan", "Adara", "Adda", "Addi", "Addia", "Addie", "Addy", "Adel", "Adela", "Adelaida", "Adelaide", "Adele", "Adelheid", "Adelice", "Adelina", "Adelind", "Adeline", "Adella", "Adelle", "Adena", "Adey", "Adi", "Adiana", "Adina", "Adora", "Adore", "Adoree", "Adorne", "Adrea", "Adria", "Adriaens", "Adrian", "Adriana", "Adriane", "Adrianna", "Adrianne", "Adriena", "Adrienne", "Aeriel", "Aeriela", "Aeriell", "Afton", "Ag", "Agace", "Agata", "Agatha", "Agathe", "Aggi", "Aggie", "Aggy", "Agna", "Agnella", "Agnes", "Agnese", "Agnesse", "Agneta", "Agnola", "Agretha", "Aida", "Aidan", "Aigneis", "Aila", "Aile", "Ailee", "Aileen", "Ailene", "Ailey", "Aili", "Ailina", "Ailis", "Ailsun", "Ailyn", "Aime", "Aimee", "Aimil", "Aindrea", "Ainslee", "Ainsley", "Ainslie", "Ajay", "Alaine", "Alameda", "Alana", "Alanah", "Alane", "Alanna", "Alayne", "Alberta", "Albertina", "Albertine", "Albina", "Alecia", "Aleda", "Aleece", "Aleen", "Alejandra", "Alejandrina", "Alena", "Alene", "Alessandra", "Aleta", "Alethea", "Alex", "Alexa", "Alexandra", "Alexandrina", "Alexi", "Alexia", "Alexina", "Alexine", "Alexis", "Alfi", "Alfie", "Alfreda", "Alfy", "Ali", "Alia", "Alica", "Alice", "Alicea", "Alicia", "Alida", "Alidia", "Alie", "Alika", "Alikee", "Alina", "Aline", "Alis", "Alisa", "Alisha", "Alison", "Alissa", "Alisun", "Alix", "Aliza", "Alla", "Alleen", "Allegra", "Allene", "Alli", "Allianora", "Allie", "Allina", "Allis", "Allison", "Allissa", "Allix", "Allsun", "Allx", "Ally", "Allyce", "Allyn", "Allys", "Allyson", "Alma", "Almeda", "Almeria", "Almeta", "Almira", "Almire", "Aloise", "Aloisia", "Aloysia", "Alta", "Althea", "Alvera", "Alverta", "Alvina", "Alvinia", "Alvira", "Alyce", "Alyda", "Alys", "Alysa", "Alyse", "Alysia", "Alyson", "Alyss", "Alyssa", "Amabel", "Amabelle", "Amalea", "Amalee", "Amaleta", "Amalia", "Amalie", "Amalita", "Amalle", "Amanda", "Amandi", "Amandie", "Amandy", "Amara", "Amargo", "Amata", "Amber", "Amberly", "Ambur", "Ame", "Amelia", "Amelie", "Amelina", "Ameline", "Amelita", "Ami", "Amie", "Amii", "Amil", "Amitie", "Amity", "Ammamaria", "Amy", "Amye", "Ana", "Anabal", "Anabel", "Anabella", "Anabelle", "Analiese", "Analise", "Anallese", "Anallise", "Anastasia", "Anastasie", "Anastassia", "Anatola", "Andee", "Andeee", "Anderea", "Andi", "Andie", "Andra", "Andrea", "Andreana", "Andree", "Andrei", "Andria", "Andriana", "Andriette", "Andromache", "Andy", "Anestassia", "Anet", "Anett", "Anetta", "Anette", "Ange", "Angel", "Angela", "Angele", "Angelia", "Angelica", "Angelika", "Angelina", "Angeline", "Angelique", "Angelita", "Angelle", "Angie", "Angil", "Angy", "Ania", "Anica", "Anissa", "Anita", "Anitra", "Anjanette", "Anjela", "Ann", "Ann-marie", "Anna", "Anna-diana", "Anna-diane", "Anna-maria", "Annabal", "Annabel", "Annabela", "Annabell", "Annabella", "Annabelle", "Annadiana", "Annadiane", "Annalee", "Annaliese", "Annalise", "Annamaria", "Annamarie", "Anne", "Anne-corinne", "Anne-marie", "Annecorinne", "Anneliese", "Annelise", "Annemarie", "Annetta", "Annette", "Anni", "Annice", "Annie", "Annis", "Annissa", "Annmaria", "Annmarie", "Annnora", "Annora", "Anny", "Anselma", "Ansley", "Anstice", "Anthe", "Anthea", "Anthia", "Anthiathia", "Antoinette", "Antonella", "Antonetta", "Antonia", "Antonie", "Antonietta", "Antonina", "Anya", "Appolonia", "April", "Aprilette", "Ara", "Arabel", "Arabela", "Arabele", "Arabella", "Arabelle", "Arda", "Ardath", "Ardeen", "Ardelia", "Ardelis", "Ardella", "Ardelle", "Arden", "Ardene", "Ardenia", "Ardine", "Ardis", "Ardisj", "Ardith", "Ardra", "Ardyce", "Ardys", "Ardyth", "Aretha", "Ariadne", "Ariana", "Aridatha", "Ariel", "Ariela", "Ariella", "Arielle", "Arlana", "Arlee", "Arleen", "Arlen", "Arlena", "Arlene", "Arleta", "Arlette", "Arleyne", "Arlie", "Arliene", "Arlina", "Arlinda", "Arline", "Arluene", "Arly", "Arlyn", "Arlyne", "Aryn", "Ashely", "Ashia", "Ashien", "Ashil", "Ashla", "Ashlan", "Ashlee", "Ashleigh", "Ashlen", "Ashley", "Ashli", "Ashlie", "Ashly", "Asia", "Astra", "Astrid", "Astrix", "Atalanta", "Athena", "Athene", "Atlanta", "Atlante", "Auberta", "Aubine", "Aubree", "Aubrette", "Aubrey", "Aubrie", "Aubry", "Audi", "Audie", "Audra", "Audre", "Audrey", "Audrie", "Audry", "Audrye", "Audy", "Augusta", "Auguste", "Augustina", "Augustine", "Aundrea", "Aura", "Aurea", "Aurel", "Aurelea", "Aurelia", "Aurelie", "Auria", "Aurie", "Aurilia", "Aurlie", "Auroora", "Aurora", "Aurore", "Austin", "Austina", "Austine", "Ava", "Aveline", "Averil", "Averyl", "Avie", "Avis", "Aviva", "Avivah", "Avril", "Avrit", "Ayn", "Bab", "Babara", "Babb", "Babbette", "Babbie", "Babette", "Babita", "Babs", "Bambi", "Bambie", "Bamby", "Barb", "Barbabra", "Barbara", "Barbara-anne", "Barbaraanne", "Barbe", "Barbee", "Barbette", "Barbey", "Barbi", "Barbie", "Barbra", "Barby", "Bari", "Barrie", "Barry", "Basia", "Bathsheba", "Batsheva", "Bea", "Beatrice", "Beatrisa", "Beatrix", "Beatriz", "Bebe", "Becca", "Becka", "Becki", "Beckie", "Becky", "Bee", "Beilul", "Beitris", "Bekki", "Bel", "Belia", "Belicia", "Belinda", "Belita", "Bell", "Bella", "Bellanca", "Belle", "Bellina", "Belva", "Belvia", "Bendite", "Benedetta", "Benedicta", "Benedikta", "Benetta", "Benita", "Benni", "Bennie", "Benny", "Benoite", "Berenice", "Beret", "Berget", "Berna", "Bernadene", "Bernadette", "Bernadina", "Bernadine", "Bernardina", "Bernardine", "Bernelle", "Bernete", "Bernetta", "Bernette", "Berni", "Bernice", "Bernie", "Bernita", "Berny", "Berri", "Berrie", "Berry", "Bert", "Berta", "Berte", "Bertha", "Berthe", "Berti", "Bertie", "Bertina", "Bertine", "Berty", "Beryl", "Beryle", "Bess", "Bessie", "Bessy", "Beth", "Bethanne", "Bethany", "Bethena", "Bethina", "Betsey", "Betsy", "Betta", "Bette", "Bette-ann", "Betteann", "Betteanne", "Betti", "Bettina", "Bettine", "Betty", "Bettye", "Beulah", "Bev", "Beverie", "Beverlee", "Beverley", "Beverlie", "Beverly", "Bevvy", "Bianca", "Bianka", "Bibbie", "Bibby", "Bibbye", "Bibi", "Biddie", "Biddy", "Bidget", "Bili", "Bill", "Billi", "Billie", "Billy", "Billye", "Binni", "Binnie", "Binny", "Bird", "Birdie", "Birgit", "Birgitta", "Blair", "Blaire", "Blake", "Blakelee", "Blakeley", "Blanca", "Blanch", "Blancha", "Blanche", "Blinni", "Blinnie", "Blinny", "Bliss", "Blisse", "Blithe", "Blondell", "Blondelle", "Blondie", "Blondy", "Blythe", "Bobbe", "Bobbee", "Bobbette", "Bobbi", "Bobbie", "Bobby", "Bobbye", "Bobette", "Bobina", "Bobine", "Bobinette", "Bonita", "Bonnee", "Bonni", "Bonnibelle", "Bonnie", "Bonny", "Brana", "Brandais", "Brande", "Brandea", "Brandi", "Brandice", "Brandie", "Brandise", "Brandy", "Breanne", "Brear", "Bree", "Breena", "Bren", "Brena", "Brenda", "Brenn", "Brenna", "Brett", "Bria", "Briana", "Brianna", "Brianne", "Bride", "Bridget", "Bridgette", "Bridie", "Brier", "Brietta", "Brigid", "Brigida", "Brigit", "Brigitta", "Brigitte", "Brina", "Briney", "Brinn", "Brinna", "Briny", "Brit", "Brita", "Britney", "Britni", "Britt", "Britta", "Brittan", "Brittaney", "Brittani", "Brittany", "Britte", "Britteny", "Brittne", "Brittney", "Brittni", "Brook", "Brooke", "Brooks", "Brunhilda", "Brunhilde", "Bryana", "Bryn", "Bryna", "Brynn", "Brynna", "Brynne", "Buffy", "Bunni", "Bunnie", "Bunny", "Cacilia", "Cacilie", "Cahra", "Cairistiona", "Caitlin", "Caitrin", "Cal", "Calida", "Calla", "Calley", "Calli", "Callida", "Callie", "Cally", "Calypso", "Cam", "Camala", "Camel", "Camella", "Camellia", "Cami", "Camila", "Camile", "Camilla", "Camille", "Cammi", "Cammie", "Cammy", "Candace", "Candi", "Candice", "Candida", "Candide", "Candie", "Candis", "Candra", "Candy", "Caprice", "Cara", "Caralie", "Caren", "Carena", "Caresa", "Caressa", "Caresse", "Carey", "Cari", "Caria", "Carie", "Caril", "Carilyn", "Carin", "Carina", "Carine", "Cariotta", "Carissa", "Carita", "Caritta", "Carla", "Carlee", "Carleen", "Carlen", "Carlene", "Carley", "Carlie", "Carlin", "Carlina", "Carline", "Carlita", "Carlota", "Carlotta", "Carly", "Carlye", "Carlyn", "Carlynn", "Carlynne", "Carma", "Carmel", "Carmela", "Carmelia", "Carmelina", "Carmelita", "Carmella", "Carmelle", "Carmen", "Carmencita", "Carmina", "Carmine", "Carmita", "Carmon", "Caro", "Carol", "Carol-jean", "Carola", "Carolan", "Carolann", "Carole", "Carolee", "Carolin", "Carolina", "Caroline", "Caroljean", "Carolyn", "Carolyne", "Carolynn", "Caron", "Carree", "Carri", "Carrie", "Carrissa", "Carroll", "Carry", "Cary", "Caryl", "Caryn", "Casandra", "Casey", "Casi", "Casie", "Cass", "Cassandra", "Cassandre", "Cassandry", "Cassaundra", "Cassey", "Cassi", "Cassie", "Cassondra", "Cassy", "Catarina", "Cate", "Caterina", "Catha", "Catharina", "Catharine", "Cathe", "Cathee", "Catherin", "Catherina", "Catherine", "Cathi", "Cathie", "Cathleen", "Cathlene", "Cathrin", "Cathrine", "Cathryn", "Cathy", "Cathyleen", "Cati", "Catie", "Catina", "Catlaina", "Catlee", "Catlin", "Catrina", "Catriona", "Caty", "Caye", "Cayla", "Cecelia", "Cecil", "Cecile", "Ceciley", "Cecilia", "Cecilla", "Cecily", "Ceil", "Cele", "Celene", "Celesta", "Celeste", "Celestia", "Celestina", "Celestine", "Celestyn", "Celestyna", "Celia", "Celie", "Celina", "Celinda", "Celine", "Celinka", "Celisse", "Celka", "Celle", "Cesya", "Chad", "Chanda", "Chandal", "Chandra", "Channa", "Chantal", "Chantalle", "Charil", "Charin", "Charis", "Charissa", "Charisse", "Charita", "Charity", "Charla", "Charlean", "Charleen", "Charlena", "Charlene", "Charline", "Charlot", "Charlotta", "Charlotte", "Charmain", "Charmaine", "Charmane", "Charmian", "Charmine", "Charmion", "Charo", "Charyl", "Chastity", "Chelsae", "Chelsea", "Chelsey", "Chelsie", "Chelsy", "Cher", "Chere", "Cherey", "Cheri", "Cherianne", "Cherice", "Cherida", "Cherie", "Cherilyn", "Cherilynn", "Cherin", "Cherise", "Cherish", "Cherlyn", "Cherri", "Cherrita", "Cherry", "Chery", "Cherye", "Cheryl", "Cheslie", "Chiarra", "Chickie", "Chicky", "Chiquia", "Chiquita", "Chlo", "Chloe", "Chloette", "Chloris", "Chris", "Chrissie", "Chrissy", "Christa", "Christabel", "Christabella", "Christal", "Christalle", "Christan", "Christean", "Christel", "Christen", "Christi", "Christian", "Christiana", "Christiane", "Christie", "Christin", "Christina", "Christine", "Christy", "Christye", "Christyna", "Chrysa", "Chrysler", "Chrystal", "Chryste", "Chrystel", "Cicely", "Cicily", "Ciel", "Cilka", "Cinda", "Cindee", "Cindelyn", "Cinderella", "Cindi", "Cindie", "Cindra", "Cindy", "Cinnamon", "Cissiee", "Cissy", "Clair", "Claire", "Clara", "Clarabelle", "Clare", "Claresta", "Clareta", "Claretta", "Clarette", "Clarey", "Clari", "Claribel", "Clarice", "Clarie", "Clarinda", "Clarine", "Clarissa", "Clarisse", "Clarita", "Clary", "Claude", "Claudelle", "Claudetta", "Claudette", "Claudia", "Claudie", "Claudina", "Claudine", "Clea", "Clem", "Clemence", "Clementia", "Clementina", "Clementine", "Clemmie", "Clemmy", "Cleo", "Cleopatra", "Clerissa", "Clio", "Clo", "Cloe", "Cloris", "Clotilda", "Clovis", "Codee", "Codi", "Codie", "Cody", "Coleen", "Colene", "Coletta", "Colette", "Colleen", "Collen", "Collete", "Collette", "Collie", "Colline", "Colly", "Con", "Concettina", "Conchita", "Concordia", "Conni", "Connie", "Conny", "Consolata", "Constance", "Constancia", "Constancy", "Constanta", "Constantia", "Constantina", "Constantine", "Consuela", "Consuelo", "Cookie", "Cora", "Corabel", "Corabella", "Corabelle", "Coral", "Coralie", "Coraline", "Coralyn", "Cordelia", "Cordelie", "Cordey", "Cordi", "Cordie", "Cordula", "Cordy", "Coreen", "Corella", "Corenda", "Corene", "Coretta", "Corette", "Corey", "Cori", "Corie", "Corilla", "Corina", "Corine", "Corinna", "Corinne", "Coriss", "Corissa", "Corliss", "Corly", "Cornela", "Cornelia", "Cornelle", "Cornie", "Corny", "Correna", "Correy", "Corri", "Corrianne", "Corrie", "Corrina", "Corrine", "Corrinne", "Corry", "Cortney", "Cory", "Cosetta", "Cosette", "Costanza", "Courtenay", "Courtnay", "Courtney", "Crin", "Cris", "Crissie", "Crissy", "Crista", "Cristabel", "Cristal", "Cristen", "Cristi", "Cristie", "Cristin", "Cristina", "Cristine", "Cristionna", "Cristy", "Crysta", "Crystal", "Crystie", "Cthrine", "Cyb", "Cybil", "Cybill", "Cymbre", "Cynde", "Cyndi", "Cyndia", "Cyndie", "Cyndy", "Cynthea", "Cynthia", "Cynthie", "Cynthy", "Dacey", "Dacia", "Dacie", "Dacy", "Dael", "Daffi", "Daffie", "Daffy", "Dagmar", "Dahlia", "Daile", "Daisey", "Daisi", "Daisie", "Daisy", "Dale", "Dalenna", "Dalia", "Dalila", "Dallas", "Daloris", "Damara", "Damaris", "Damita", "Dana", "Danell", "Danella", "Danette", "Dani", "Dania", "Danica", "Danice", "Daniela", "Daniele", "Daniella", "Danielle", "Danika", "Danila", "Danit", "Danita", "Danna", "Danni", "Dannie", "Danny", "Dannye", "Danya", "Danyelle", "Danyette", "Daphene", "Daphna", "Daphne", "Dara", "Darb", "Darbie", "Darby", "Darcee", "Darcey", "Darci", "Darcie", "Darcy", "Darda", "Dareen", "Darell", "Darelle", "Dari", "Daria", "Darice", "Darla", "Darleen", "Darlene", "Darline", "Darlleen", "Daron", "Darrelle", "Darryl", "Darsey", "Darsie", "Darya", "Daryl", "Daryn", "Dasha", "Dasi", "Dasie", "Dasya", "Datha", "Daune", "Daveen", "Daveta", "Davida", "Davina", "Davine", "Davita", "Dawn", "Dawna", "Dayle", "Dayna", "Ddene", "De", "Deana", "Deane", "Deanna", "Deanne", "Deb", "Debbi", "Debbie", "Debby", "Debee", "Debera", "Debi", "Debor", "Debora", "Deborah", "Debra", "Dede", "Dedie", "Dedra", "Dee", "Deeann", "Deeanne", "Deedee", "Deena", "Deerdre", "Deeyn", "Dehlia", "Deidre", "Deina", "Deirdre", "Del", "Dela", "Delcina", "Delcine", "Delia", "Delila", "Delilah", "Delinda", "Dell", "Della", "Delly", "Delora", "Delores", "Deloria", "Deloris", "Delphine", "Delphinia", "Demeter", "Demetra", "Demetria", "Demetris", "Dena", "Deni", "Denice", "Denise", "Denna", "Denni", "Dennie", "Denny", "Deny", "Denys", "Denyse", "Deonne", "Desdemona", "Desirae", "Desiree", "Desiri", "Deva", "Devan", "Devi", "Devin", "Devina", "Devinne", "Devon", "Devondra", "Devonna", "Devonne", "Devora", "Di", "Diahann", "Dian", "Diana", "Diandra", "Diane", "Diane-marie", "Dianemarie", "Diann", "Dianna", "Dianne", "Diannne", "Didi", "Dido", "Diena", "Dierdre", "Dina", "Dinah", "Dinnie", "Dinny", "Dion", "Dione", "Dionis", "Dionne", "Dita", "Dix", "Dixie", "Dniren", "Dode", "Dodi", "Dodie", "Dody", "Doe", "Doll", "Dolley", "Dolli", "Dollie", "Dolly", "Dolores", "Dolorita", "Doloritas", "Domeniga", "Dominga", "Domini", "Dominica", "Dominique", "Dona", "Donella", "Donelle", "Donetta", "Donia", "Donica", "Donielle", "Donna", "Donnamarie", "Donni", "Donnie", "Donny", "Dora", "Doralia", "Doralin", "Doralyn", "Doralynn", "Doralynne", "Dore", "Doreen", "Dorelia", "Dorella", "Dorelle", "Dorena", "Dorene", "Doretta", "Dorette", "Dorey", "Dori", "Doria", "Dorian", "Dorice", "Dorie", "Dorine", "Doris", "Dorisa", "Dorise", "Dorita", "Doro", "Dorolice", "Dorolisa", "Dorotea", "Doroteya", "Dorothea", "Dorothee", "Dorothy", "Dorree", "Dorri", "Dorrie", "Dorris", "Dorry", "Dorthea", "Dorthy", "Dory", "Dosi", "Dot", "Doti", "Dotti", "Dottie", "Dotty", "Dre", "Dreddy", "Dredi", "Drona", "Dru", "Druci", "Drucie", "Drucill", "Drucy", "Drusi", "Drusie", "Drusilla", "Drusy", "Dulce", "Dulcea", "Dulci", "Dulcia", "Dulciana", "Dulcie", "Dulcine", "Dulcinea", "Dulcy", "Dulsea", "Dusty", "Dyan", "Dyana", "Dyane", "Dyann", "Dyanna", "Dyanne", "Dyna", "Dynah", "Eachelle", "Eada", "Eadie", "Eadith", "Ealasaid", "Eartha", "Easter", "Eba", "Ebba", "Ebonee", "Ebony", "Eda", "Eddi", "Eddie", "Eddy", "Ede", "Edee", "Edeline", "Eden", "Edi", "Edie", "Edin", "Edita", "Edith", "Editha", "Edithe", "Ediva", "Edna", "Edwina", "Edy", "Edyth", "Edythe", "Effie", "Eileen", "Eilis", "Eimile", "Eirena", "Ekaterina", "Elaina", "Elaine", "Elana", "Elane", "Elayne", "Elberta", "Elbertina", "Elbertine", "Eleanor", "Eleanora", "Eleanore", "Electra", "Eleen", "Elena", "Elene", "Eleni", "Elenore", "Eleonora", "Eleonore", "Elfie", "Elfreda", "Elfrida", "Elfrieda", "Elga", "Elianora", "Elianore", "Elicia", "Elie", "Elinor", "Elinore", "Elisa", "Elisabet", "Elisabeth", "Elisabetta", "Elise", "Elisha", "Elissa", "Elita", "Eliza", "Elizabet", "Elizabeth", "Elka", "Elke", "Ella", "Elladine", "Elle", "Ellen", "Ellene", "Ellette", "Elli", "Ellie", "Ellissa", "Elly", "Ellyn", "Ellynn", "Elmira", "Elna", "Elnora", "Elnore", "Eloisa", "Eloise", "Elonore", "Elora", "Elsa", "Elsbeth", "Else", "Elset", "Elsey", "Elsi", "Elsie", "Elsinore", "Elspeth", "Elsy", "Elva", "Elvera", "Elvina", "Elvira", "Elwira", "Elyn", "Elyse", "Elysee", "Elysha", "Elysia", "Elyssa", "Em", "Ema", "Emalee", "Emalia", "Emelda", "Emelia", "Emelina", "Emeline", "Emelita", "Emelyne", "Emera", "Emilee", "Emili", "Emilia", "Emilie", "Emiline", "Emily", "Emlyn", "Emlynn", "Emlynne", "Emma", "Emmalee", "Emmaline", "Emmalyn", "Emmalynn", "Emmalynne", "Emmeline", "Emmey", "Emmi", "Emmie", "Emmy", "Emmye", "Emogene", "Emyle", "Emylee", "Engracia", "Enid", "Enrica", "Enrichetta", "Enrika", "Enriqueta", "Eolanda", "Eolande", "Eran", "Erda", "Erena", "Erica", "Ericha", "Ericka", "Erika", "Erin", "Erina", "Erinn", "Erinna", "Erma", "Ermengarde", "Ermentrude", "Ermina", "Erminia", "Erminie", "Erna", "Ernaline", "Ernesta", "Ernestine", "Ertha", "Eryn", "Esma", "Esmaria", "Esme", "Esmeralda", "Essa", "Essie", "Essy", "Esta", "Estel", "Estele", "Estell", "Estella", "Estelle", "Ester", "Esther", "Estrella", "Estrellita", "Ethel", "Ethelda", "Ethelin", "Ethelind", "Etheline", "Ethelyn", "Ethyl", "Etta", "Etti", "Ettie", "Etty", "Eudora", "Eugenia", "Eugenie", "Eugine", "Eula", "Eulalie", "Eunice", "Euphemia", "Eustacia", "Eva", "Evaleen", "Evangelia", "Evangelin", "Evangelina", "Evangeline", "Evania", "Evanne", "Eve", "Eveleen", "Evelina", "Eveline", "Evelyn", "Evey", "Evie", "Evita", "Evonne", "Evvie", "Evvy", "Evy", "Eyde", "Eydie", "Ezmeralda", "Fae", "Faina", "Faith", "Fallon", "Fan", "Fanchette", "Fanchon", "Fancie", "Fancy", "Fanechka", "Fania", "Fanni", "Fannie", "Fanny", "Fanya", "Fara", "Farah", "Farand", "Farica", "Farra", "Farrah", "Farrand", "Faun", "Faunie", "Faustina", "Faustine", "Fawn", "Fawne", "Fawnia", "Fay", "Faydra", "Faye", "Fayette", "Fayina", "Fayre", "Fayth", "Faythe", "Federica", "Fedora", "Felecia", "Felicdad", "Felice", "Felicia", "Felicity", "Felicle", "Felipa", "Felisha", "Felita", "Feliza", "Fenelia", "Feodora", "Ferdinanda", "Ferdinande", "Fern", "Fernanda", "Fernande", "Fernandina", "Ferne", "Fey", "Fiann", "Fianna", "Fidela", "Fidelia", "Fidelity", "Fifi", "Fifine", "Filia", "Filide", "Filippa", "Fina", "Fiona", "Fionna", "Fionnula", "Fiorenze", "Fleur", "Fleurette", "Flo", "Flor", "Flora", "Florance", "Flore", "Florella", "Florence", "Florencia", "Florentia", "Florenza", "Florette", "Flori", "Floria", "Florida", "Florie", "Florina", "Florinda", "Floris", "Florri", "Florrie", "Florry", "Flory", "Flossi", "Flossie", "Flossy", "Flss", "Fran", "Francene", "Frances", "Francesca", "Francine", "Francisca", "Franciska", "Francoise", "Francyne", "Frank", "Frankie", "Franky", "Franni", "Frannie", "Franny", "Frayda", "Fred", "Freda", "Freddi", "Freddie", "Freddy", "Fredelia", "Frederica", "Fredericka", "Frederique", "Fredi", "Fredia", "Fredra", "Fredrika", "Freida", "Frieda", "Friederike", "Fulvia", "Gabbey", "Gabbi", "Gabbie", "Gabey", "Gabi", "Gabie", "Gabriel", "Gabriela", "Gabriell", "Gabriella", "Gabrielle", "Gabriellia", "Gabrila", "Gaby", "Gae", "Gael", "Gail", "Gale", "Galina", "Garland", "Garnet", "Garnette", "Gates", "Gavra", "Gavrielle", "Gay", "Gaye", "Gayel", "Gayla", "Gayle", "Gayleen", "Gaylene", "Gaynor", "Gelya", "Gena", "Gene", "Geneva", "Genevieve", "Genevra", "Genia", "Genna", "Genni", "Gennie", "Gennifer", "Genny", "Genovera", "Genvieve", "George", "Georgeanna", "Georgeanne", "Georgena", "Georgeta", "Georgetta", "Georgette", "Georgia", "Georgiana", "Georgianna", "Georgianne", "Georgie", "Georgina", "Georgine", "Geralda", "Geraldine", "Gerda", "Gerhardine", "Geri", "Gerianna", "Gerianne", "Gerladina", "Germain", "Germaine", "Germana", "Gerri", "Gerrie", "Gerrilee", "Gerry", "Gert", "Gerta", "Gerti", "Gertie", "Gertrud", "Gertruda", "Gertrude", "Gertrudis", "Gerty", "Giacinta", "Giana", "Gianina", "Gianna", "Gigi", "Gilberta", "Gilberte", "Gilbertina", "Gilbertine", "Gilda", "Gilemette", "Gill", "Gillan", "Gilli", "Gillian", "Gillie", "Gilligan", "Gilly", "Gina", "Ginelle", "Ginevra", "Ginger", "Ginni", "Ginnie", "Ginnifer", "Ginny", "Giorgia", "Giovanna", "Gipsy", "Giralda", "Gisela", "Gisele", "Gisella", "Giselle", "Giuditta", "Giulia", "Giulietta", "Giustina", "Gizela", "Glad", "Gladi", "Gladys", "Gleda", "Glen", "Glenda", "Glenine", "Glenn", "Glenna", "Glennie", "Glennis", "Glori", "Gloria", "Gloriana", "Gloriane", "Glory", "Glyn", "Glynda", "Glynis", "Glynnis", "Gnni", "Godiva", "Golda", "Goldarina", "Goldi", "Goldia", "Goldie", "Goldina", "Goldy", "Grace", "Gracia", "Gracie", "Grata", "Gratia", "Gratiana", "Gray", "Grayce", "Grazia", "Greer", "Greta", "Gretal", "Gretchen", "Grete", "Gretel", "Grethel", "Gretna", "Gretta", "Grier", "Griselda", "Grissel", "Guendolen", "Guenevere", "Guenna", "Guglielma", "Gui", "Guillema", "Guillemette", "Guinevere", "Guinna", "Gunilla", "Gus", "Gusella", "Gussi", "Gussie", "Gussy", "Gusta", "Gusti", "Gustie", "Gusty", "Gwen", "Gwendolen", "Gwendolin", "Gwendolyn", "Gweneth", "Gwenette", "Gwenneth", "Gwenni", "Gwennie", "Gwenny", "Gwenora", "Gwenore", "Gwyn", "Gwyneth", "Gwynne", "Gypsy", "Hadria", "Hailee", "Haily", "Haleigh", "Halette", "Haley", "Hali", "Halie", "Halimeda", "Halley", "Halli", "Hallie", "Hally", "Hana", "Hanna", "Hannah", "Hanni", "Hannie", "Hannis", "Hanny", "Happy", "Harlene", "Harley", "Harli", "Harlie", "Harmonia", "Harmonie", "Harmony", "Harri", "Harrie", "Harriet", "Harriett", "Harrietta", "Harriette", "Harriot", "Harriott", "Hatti", "Hattie", "Hatty", "Hayley", "Hazel", "Heath", "Heather", "Heda", "Hedda", "Heddi", "Heddie", "Hedi", "Hedvig", "Hedvige", "Hedwig", "Hedwiga", "Hedy", "Heida", "Heidi", "Heidie", "Helaina", "Helaine", "Helen", "Helen-elizabeth", "Helena", "Helene", "Helenka", "Helga", "Helge", "Helli", "Heloise", "Helsa", "Helyn", "Hendrika", "Henka", "Henrie", "Henrieta", "Henrietta", "Henriette", "Henryetta", "Hephzibah", "Hermia", "Hermina", "Hermine", "Herminia", "Hermione", "Herta", "Hertha", "Hester", "Hesther", "Hestia", "Hetti", "Hettie", "Hetty", "Hilary", "Hilda", "Hildagard", "Hildagarde", "Hilde", "Hildegaard", "Hildegarde", "Hildy", "Hillary", "Hilliary", "Hinda", "Holli", "Hollie", "Holly", "Holly-anne", "Hollyanne", "Honey", "Honor", "Honoria", "Hope", "Horatia", "Hortense", "Hortensia", "Hulda", "Hyacinth", "Hyacintha", "Hyacinthe", "Hyacinthia", "Hyacinthie", "Hynda", "Ianthe", "Ibbie", "Ibby", "Ida", "Idalia", "Idalina", "Idaline", "Idell", "Idelle", "Idette", "Ileana", "Ileane", "Ilene", "Ilise", "Ilka", "Illa", "Ilsa", "Ilse", "Ilysa", "Ilyse", "Ilyssa", "Imelda", "Imogen", "Imogene", "Imojean", "Ina", "Indira", "Ines", "Inesita", "Inessa", "Inez", "Inga", "Ingaberg", "Ingaborg", "Inge", "Ingeberg", "Ingeborg", "Inger", "Ingrid", "Ingunna", "Inna", "Iolande", "Iolanthe", "Iona", "Iormina", "Ira", "Irena", "Irene", "Irina", "Iris", "Irita", "Irma", "Isa", "Isabel", "Isabelita", "Isabella", "Isabelle", "Isadora", "Isahella", "Iseabal", "Isidora", "Isis", "Isobel", "Issi", "Issie", "Issy", "Ivett", "Ivette", "Ivie", "Ivonne", "Ivory", "Ivy", "Izabel", "Jacenta", "Jacinda", "Jacinta", "Jacintha", "Jacinthe", "Jackelyn", "Jacki", "Jackie", "Jacklin", "Jacklyn", "Jackquelin", "Jackqueline", "Jacky", "Jaclin", "Jaclyn", "Jacquelin", "Jacqueline", "Jacquelyn", "Jacquelynn", "Jacquenetta", "Jacquenette", "Jacquetta", "Jacquette", "Jacqui", "Jacquie", "Jacynth", "Jada", "Jade", "Jaime", "Jaimie", "Jaine", "Jami", "Jamie", "Jamima", "Jammie", "Jan", "Jana", "Janaya", "Janaye", "Jandy", "Jane", "Janean", "Janeczka", "Janeen", "Janel", "Janela", "Janella", "Janelle", "Janene", "Janenna", "Janessa", "Janet", "Janeta", "Janetta", "Janette", "Janeva", "Janey", "Jania", "Janice", "Janie", "Janifer", "Janina", "Janine", "Janis", "Janith", "Janka", "Janna", "Jannel", "Jannelle", "Janot", "Jany", "Jaquelin", "Jaquelyn", "Jaquenetta", "Jaquenette", "Jaquith", "Jasmin", "Jasmina", "Jasmine", "Jayme", "Jaymee", "Jayne", "Jaynell", "Jazmin", "Jean", "Jeana", "Jeane", "Jeanelle", "Jeanette", "Jeanie", "Jeanine", "Jeanna", "Jeanne", "Jeannette", "Jeannie", "Jeannine", "Jehanna", "Jelene", "Jemie", "Jemima", "Jemimah", "Jemmie", "Jemmy", "Jen", "Jena", "Jenda", "Jenelle", "Jeni", "Jenica", "Jeniece", "Jenifer", "Jeniffer", "Jenilee", "Jenine", "Jenn", "Jenna", "Jennee", "Jennette", "Jenni", "Jennica", "Jennie", "Jennifer", "Jennilee", "Jennine", "Jenny", "Jeralee", "Jere", "Jeri", "Jermaine", "Jerrie", "Jerrilee", "Jerrilyn", "Jerrine", "Jerry", "Jerrylee", "Jess", "Jessa", "Jessalin", "Jessalyn", "Jessamine", "Jessamyn", "Jesse", "Jesselyn", "Jessi", "Jessica", "Jessie", "Jessika", "Jessy", "Jewel", "Jewell", "Jewelle", "Jill", "Jillana", "Jillane", "Jillayne", "Jilleen", "Jillene", "Jilli", "Jillian", "Jillie", "Jilly", "Jinny", "Jo", "Jo-ann", "Jo-anne", "Joan", "Joana", "Joane", "Joanie", "Joann", "Joanna", "Joanne", "Joannes", "Jobey", "Jobi", "Jobie", "Jobina", "Joby", "Jobye", "Jobyna", "Jocelin", "Joceline", "Jocelyn", "Jocelyne", "Jodee", "Jodi", "Jodie", "Jody", "Joeann", "Joela", "Joelie", "Joell", "Joella", "Joelle", "Joellen", "Joelly", "Joellyn", "Joelynn", "Joete", "Joey", "Johanna", "Johannah", "Johna", "Johnath", "Johnette", "Johnna", "Joice", "Jojo", "Jolee", "Joleen", "Jolene", "Joletta", "Joli", "Jolie", "Joline", "Joly", "Jolyn", "Jolynn", "Jonell", "Joni", "Jonie", "Jonis", "Jordain", "Jordan", "Jordana", "Jordanna", "Jorey", "Jori", "Jorie", "Jorrie", "Jorry", "Joscelin", "Josee", "Josefa", "Josefina", "Josepha", "Josephina", "Josephine", "Josey", "Josi", "Josie", "Josselyn", "Josy", "Jourdan", "Joy", "Joya", "Joyan", "Joyann", "Joyce", "Joycelin", "Joye", "Jsandye", "Juana", "Juanita", "Judi", "Judie", "Judith", "Juditha", "Judy", "Judye", "Juieta", "Julee", "Juli", "Julia", "Juliana", "Juliane", "Juliann", "Julianna", "Julianne", "Julie", "Julienne", "Juliet", "Julieta", "Julietta", "Juliette", "Julina", "Juline", "Julissa", "Julita", "June", "Junette", "Junia", "Junie", "Junina", "Justina", "Justine", "Justinn", "Jyoti", "Kacey", "Kacie", "Kacy", "Kaela", "Kai", "Kaia", "Kaila", "Kaile", "Kailey", "Kaitlin", "Kaitlyn", "Kaitlynn", "Kaja", "Kakalina", "Kala", "Kaleena", "Kali", "Kalie", "Kalila", "Kalina", "Kalinda", "Kalindi", "Kalli", "Kally", "Kameko", "Kamila", "Kamilah", "Kamillah", "Kandace", "Kandy", "Kania", "Kanya", "Kara", "Kara-lynn", "Karalee", "Karalynn", "Kare", "Karee", "Karel", "Karen", "Karena", "Kari", "Karia", "Karie", "Karil", "Karilynn", "Karin", "Karina", "Karine", "Kariotta", "Karisa", "Karissa", "Karita", "Karla", "Karlee", "Karleen", "Karlen", "Karlene", "Karlie", "Karlotta", "Karlotte", "Karly", "Karlyn", "Karmen", "Karna", "Karol", "Karola", "Karole", "Karolina", "Karoline", "Karoly", "Karon", "Karrah", "Karrie", "Karry", "Kary", "Karyl", "Karylin", "Karyn", "Kasey", "Kass", "Kassandra", "Kassey", "Kassi", "Kassia", "Kassie", "Kat", "Kata", "Katalin", "Kate", "Katee", "Katerina", "Katerine", "Katey", "Kath", "Katha", "Katharina", "Katharine", "Katharyn", "Kathe", "Katherina", "Katherine", "Katheryn", "Kathi", "Kathie", "Kathleen", "Kathlin", "Kathrine", "Kathryn", "Kathryne", "Kathy", "Kathye", "Kati", "Katie", "Katina", "Katine", "Katinka", "Katleen", "Katlin", "Katrina", "Katrine", "Katrinka", "Katti", "Kattie", "Katuscha", "Katusha", "Katy", "Katya", "Kay", "Kaycee", "Kaye", "Kayla", "Kayle", "Kaylee", "Kayley", "Kaylil", "Kaylyn", "Keeley", "Keelia", "Keely", "Kelcey", "Kelci", "Kelcie", "Kelcy", "Kelila", "Kellen", "Kelley", "Kelli", "Kellia", "Kellie", "Kellina", "Kellsie", "Kelly", "Kellyann", "Kelsey", "Kelsi", "Kelsy", "Kendra", "Kendre", "Kenna", "Keri", "Keriann", "Kerianne", "Kerri", "Kerrie", "Kerrill", "Kerrin", "Kerry", "Kerstin", "Kesley", "Keslie", "Kessia", "Kessiah", "Ketti", "Kettie", "Ketty", "Kevina", "Kevyn", "Ki", "Kiah", "Kial", "Kiele", "Kiersten", "Kikelia", "Kiley", "Kim", "Kimberlee", "Kimberley", "Kimberli", "Kimberly", "Kimberlyn", "Kimbra", "Kimmi", "Kimmie", "Kimmy", "Kinna", "Kip", "Kipp", "Kippie", "Kippy", "Kira", "Kirbee", "Kirbie", "Kirby", "Kiri", "Kirsten", "Kirsteni", "Kirsti", "Kirstin", "Kirstyn", "Kissee", "Kissiah", "Kissie", "Kit", "Kitti", "Kittie", "Kitty", "Kizzee", "Kizzie", "Klara", "Klarika", "Klarrisa", "Konstance", "Konstanze", "Koo", "Kora", "Koral", "Koralle", "Kordula", "Kore", "Korella", "Koren", "Koressa", "Kori", "Korie", "Korney", "Korrie", "Korry", "Kris", "Krissie", "Krissy", "Krista", "Kristal", "Kristan", "Kriste", "Kristel", "Kristen", "Kristi", "Kristien", "Kristin", "Kristina", "Kristine", "Kristy", "Kristyn", "Krysta", "Krystal", "Krystalle", "Krystle", "Krystyna", "Kyla", "Kyle", "Kylen", "Kylie", "Kylila", "Kylynn", "Kym", "Kynthia", "Kyrstin", "Lacee", "Lacey", "Lacie", "Lacy", "Ladonna", "Laetitia", "Laina", "Lainey", "Lana", "Lanae", "Lane", "Lanette", "Laney", "Lani", "Lanie", "Lanita", "Lanna", "Lanni", "Lanny", "Lara", "Laraine", "Lari", "Larina", "Larine", "Larisa", "Larissa", "Lark", "Laryssa", "Latashia", "Latia", "Latisha", "Latrena", "Latrina", "Laura", "Lauraine", "Laural", "Lauralee", "Laure", "Lauree", "Laureen", "Laurel", "Laurella", "Lauren", "Laurena", "Laurene", "Lauretta", "Laurette", "Lauri", "Laurianne", "Laurice", "Laurie", "Lauryn", "Lavena", "Laverna", "Laverne", "Lavina", "Lavinia", "Lavinie", "Layla", "Layne", "Layney", "Lea", "Leah", "Leandra", "Leann", "Leanna", "Leanor", "Leanora", "Lebbie", "Leda", "Lee", "Leeann", "Leeanne", "Leela", "Leelah", "Leena", "Leesa", "Leese", "Legra", "Leia", "Leigh", "Leigha", "Leila", "Leilah", "Leisha", "Lela", "Lelah", "Leland", "Lelia", "Lena", "Lenee", "Lenette", "Lenka", "Lenna", "Lenora", "Lenore", "Leodora", "Leoine", "Leola", "Leoline", "Leona", "Leonanie", "Leone", "Leonelle", "Leonie", "Leonora", "Leonore", "Leontine", "Leontyne", "Leora", "Leshia", "Lesley", "Lesli", "Leslie", "Lesly", "Lesya", "Leta", "Lethia", "Leticia", "Letisha", "Letitia", "Letizia", "Letta", "Letti", "Lettie", "Letty", "Lexi", "Lexie", "Lexine", "Lexis", "Lexy", "Leyla", "Lezlie", "Lia", "Lian", "Liana", "Liane", "Lianna", "Lianne", "Lib", "Libbey", "Libbi", "Libbie", "Libby", "Licha", "Lida", "Lidia", "Liesa", "Lil", "Lila", "Lilah", "Lilas", "Lilia", "Lilian", "Liliane", "Lilias", "Lilith", "Lilla", "Lilli", "Lillian", "Lillis", "Lilllie", "Lilly", "Lily", "Lilyan", "Lin", "Lina", "Lind", "Linda", "Lindi", "Lindie", "Lindsay", "Lindsey", "Lindsy", "Lindy", "Linea", "Linell", "Linet", "Linette", "Linn", "Linnea", "Linnell", "Linnet", "Linnie", "Linzy", "Lira", "Lisa", "Lisabeth", "Lisbeth", "Lise", "Lisetta", "Lisette", "Lisha", "Lishe", "Lissa", "Lissi", "Lissie", "Lissy", "Lita", "Liuka", "Liv", "Liva", "Livia", "Livvie", "Livvy", "Livvyy", "Livy", "Liz", "Liza", "Lizabeth", "Lizbeth", "Lizette", "Lizzie", "Lizzy", "Loella", "Lois", "Loise", "Lola", "Loleta", "Lolita", "Lolly", "Lona", "Lonee", "Loni", "Lonna", "Lonni", "Lonnie", "Lora", "Lorain", "Loraine", "Loralee", "Loralie", "Loralyn", "Loree", "Loreen", "Lorelei", "Lorelle", "Loren", "Lorena", "Lorene", "Lorenza", "Loretta", "Lorette", "Lori", "Loria", "Lorianna", "Lorianne", "Lorie", "Lorilee", "Lorilyn", "Lorinda", "Lorine", "Lorita", "Lorna", "Lorne", "Lorraine", "Lorrayne", "Lorri", "Lorrie", "Lorrin", "Lorry", "Lory", "Lotta", "Lotte", "Lotti", "Lottie", "Lotty", "Lou", "Louella", "Louisa", "Louise", "Louisette", "Loutitia", "Lu", "Luce", "Luci", "Lucia", "Luciana", "Lucie", "Lucienne", "Lucila", "Lucilia", "Lucille", "Lucina", "Lucinda", "Lucine", "Lucita", "Lucky", "Lucretia", "Lucy", "Ludovika", "Luella", "Luelle", "Luisa", "Luise", "Lula", "Lulita", "Lulu", "Lura", "Lurette", "Lurleen", "Lurlene", "Lurline", "Lusa", "Luz", "Lyda", "Lydia", "Lydie", "Lyn", "Lynda", "Lynde", "Lyndel", "Lyndell", "Lyndsay", "Lyndsey", "Lyndsie", "Lyndy", "Lynea", "Lynelle", "Lynett", "Lynette", "Lynn", "Lynna", "Lynne", "Lynnea", "Lynnell", "Lynnelle", "Lynnet", "Lynnett", "Lynnette", "Lynsey", "Lyssa", "Mab", "Mabel", "Mabelle", "Mable", "Mada", "Madalena", "Madalyn", "Maddalena", "Maddi", "Maddie", "Maddy", "Madel", "Madelaine", "Madeleine", "Madelena", "Madelene", "Madelin", "Madelina", "Madeline", "Madella", "Madelle", "Madelon", "Madelyn", "Madge", "Madlen", "Madlin", "Madonna", "Mady", "Mae", "Maegan", "Mag", "Magda", "Magdaia", "Magdalen", "Magdalena", "Magdalene", "Maggee", "Maggi", "Maggie", "Maggy", "Mahala", "Mahalia", "Maia", "Maible", "Maiga", "Maighdiln", "Mair", "Maire", "Maisey", "Maisie", "Maitilde", "Mala", "Malanie", "Malena", "Malia", "Malina", "Malinda", "Malinde", "Malissa", "Malissia", "Mallissa", "Mallorie", "Mallory", "Malorie", "Malory", "Malva", "Malvina", "Malynda", "Mame", "Mamie", "Manda", "Mandi", "Mandie", "Mandy", "Manon", "Manya", "Mara", "Marabel", "Marcela", "Marcelia", "Marcella", "Marcelle", "Marcellina", "Marcelline", "Marchelle", "Marci", "Marcia", "Marcie", "Marcile", "Marcille", "Marcy", "Mareah", "Maren", "Marena", "Maressa", "Marga", "Margalit", "Margalo", "Margaret", "Margareta", "Margarete", "Margaretha", "Margarethe", "Margaretta", "Margarette", "Margarita", "Margaux", "Marge", "Margeaux", "Margery", "Marget", "Margette", "Margi", "Margie", "Margit", "Margo", "Margot", "Margret", "Marguerite", "Margy", "Mari", "Maria", "Mariam", "Marian", "Mariana", "Mariann", "Marianna", "Marianne", "Maribel", "Maribelle", "Maribeth", "Marice", "Maridel", "Marie", "Marie-ann", "Marie-jeanne", "Marieann", "Mariejeanne", "Mariel", "Mariele", "Marielle", "Mariellen", "Marietta", "Mariette", "Marigold", "Marijo", "Marika", "Marilee", "Marilin", "Marillin", "Marilyn", "Marin", "Marina", "Marinna", "Marion", "Mariquilla", "Maris", "Marisa", "Mariska", "Marissa", "Marita", "Maritsa", "Mariya", "Marj", "Marja", "Marje", "Marji", "Marjie", "Marjorie", "Marjory", "Marjy", "Marketa", "Marla", "Marlane", "Marleah", "Marlee", "Marleen", "Marlena", "Marlene", "Marley", "Marlie", "Marline", "Marlo", "Marlyn", "Marna", "Marne", "Marney", "Marni", "Marnia", "Marnie", "Marquita", "Marrilee", "Marris", "Marrissa", "Marsha", "Marsiella", "Marta", "Martelle", "Martguerita", "Martha", "Marthe", "Marthena", "Marti", "Martica", "Martie", "Martina", "Martita", "Marty", "Martynne", "Mary", "Marya", "Maryann", "Maryanna", "Maryanne", "Marybelle", "Marybeth", "Maryellen", "Maryjane", "Maryjo", "Maryl", "Marylee", "Marylin", "Marylinda", "Marylou", "Marylynne", "Maryrose", "Marys", "Marysa", "Masha", "Matelda", "Mathilda", "Mathilde", "Matilda", "Matilde", "Matti", "Mattie", "Matty", "Maud", "Maude", "Maudie", "Maura", "Maure", "Maureen", "Maureene", "Maurene", "Maurine", "Maurise", "Maurita", "Maurizia", "Mavis", "Mavra", "Max", "Maxi", "Maxie", "Maxine", "Maxy", "May", "Maybelle", "Maye", "Mead", "Meade", "Meagan", "Meaghan", "Meara", "Mechelle", "Meg", "Megan", "Megen", "Meggi", "Meggie", "Meggy", "Meghan", "Meghann", "Mehetabel", "Mei", "Mel", "Mela", "Melamie", "Melania", "Melanie", "Melantha", "Melany", "Melba", "Melesa", "Melessa", "Melicent", "Melina", "Melinda", "Melinde", "Melisa", "Melisande", "Melisandra", "Melisenda", "Melisent", "Melissa", "Melisse", "Melita", "Melitta", "Mella", "Melli", "Mellicent", "Mellie", "Mellisa", "Mellisent", "Melloney", "Melly", "Melodee", "Melodie", "Melody", "Melonie", "Melony", "Melosa", "Melva", "Mercedes", "Merci", "Mercie", "Mercy", "Meredith", "Meredithe", "Meridel", "Meridith", "Meriel", "Merilee", "Merilyn", "Meris", "Merissa", "Merl", "Merla", "Merle", "Merlina", "Merline", "Merna", "Merola", "Merralee", "Merridie", "Merrie", "Merrielle", "Merrile", "Merrilee", "Merrili", "Merrill", "Merrily", "Merry", "Mersey", "Meryl", "Meta", "Mia", "Micaela", "Michaela", "Michaelina", "Michaeline", "Michaella", "Michal", "Michel", "Michele", "Michelina", "Micheline", "Michell", "Michelle", "Micki", "Mickie", "Micky", "Midge", "Mignon", "Mignonne", "Miguela", "Miguelita", "Mikaela", "Mil", "Mildred", "Mildrid", "Milena", "Milicent", "Milissent", "Milka", "Milli", "Millicent", "Millie", "Millisent", "Milly", "Milzie", "Mimi", "Min", "Mina", "Minda", "Mindy", "Minerva", "Minetta", "Minette", "Minna", "Minnaminnie", "Minne", "Minni", "Minnie", "Minnnie", "Minny", "Minta", "Miquela", "Mira", "Mirabel", "Mirabella", "Mirabelle", "Miran", "Miranda", "Mireielle", "Mireille", "Mirella", "Mirelle", "Miriam", "Mirilla", "Mirna", "Misha", "Missie", "Missy", "Misti", "Misty", "Mitzi", "Modesta", "Modestia", "Modestine", "Modesty", "Moina", "Moira", "Moll", "Mollee", "Molli", "Mollie", "Molly", "Mommy", "Mona", "Monah", "Monica", "Monika", "Monique", "Mora", "Moreen", "Morena", "Morgan", "Morgana", "Morganica", "Morganne", "Morgen", "Moria", "Morissa", "Morna", "Moselle", "Moyna", "Moyra", "Mozelle", "Muffin", "Mufi", "Mufinella", "Muire", "Mureil", "Murial", "Muriel", "Murielle", "Myra", "Myrah", "Myranda", "Myriam", "Myrilla", "Myrle", "Myrlene", "Myrna", "Myrta", "Myrtia", "Myrtice", "Myrtie", "Myrtle", "Nada", "Nadean", "Nadeen", "Nadia", "Nadine", "Nadiya", "Nady", "Nadya", "Nalani", "Nan", "Nana", "Nananne", "Nance", "Nancee", "Nancey", "Nanci", "Nancie", "Nancy", "Nanete", "Nanette", "Nani", "Nanice", "Nanine", "Nannette", "Nanni", "Nannie", "Nanny", "Nanon", "Naoma", "Naomi", "Nara", "Nari", "Nariko", "Nat", "Nata", "Natala", "Natalee", "Natalie", "Natalina", "Nataline", "Natalya", "Natasha", "Natassia", "Nathalia", "Nathalie", "Natividad", "Natka", "Natty", "Neala", "Neda", "Nedda", "Nedi", "Neely", "Neila", "Neile", "Neilla", "Neille", "Nelia", "Nelie", "Nell", "Nelle", "Nelli", "Nellie", "Nelly", "Nerissa", "Nerita", "Nert", "Nerta", "Nerte", "Nerti", "Nertie", "Nerty", "Nessa", "Nessi", "Nessie", "Nessy", "Nesta", "Netta", "Netti", "Nettie", "Nettle", "Netty", "Nevsa", "Neysa", "Nichol", "Nichole", "Nicholle", "Nicki", "Nickie", "Nicky", "Nicol", "Nicola", "Nicole", "Nicolea", "Nicolette", "Nicoli", "Nicolina", "Nicoline", "Nicolle", "Nikaniki", "Nike", "Niki", "Nikki", "Nikkie", "Nikoletta", "Nikolia", "Nina", "Ninetta", "Ninette", "Ninnetta", "Ninnette", "Ninon", "Nissa", "Nisse", "Nissie", "Nissy", "Nita", "Nixie", "Noami", "Noel", "Noelani", "Noell", "Noella", "Noelle", "Noellyn", "Noelyn", "Noemi", "Nola", "Nolana", "Nolie", "Nollie", "Nomi", "Nona", "Nonah", "Noni", "Nonie", "Nonna", "Nonnah", "Nora", "Norah", "Norean", "Noreen", "Norene", "Norina", "Norine", "Norma", "Norri", "Norrie", "Norry", "Novelia", "Nydia", "Nyssa", "Octavia", "Odele", "Odelia", "Odelinda", "Odella", "Odelle", "Odessa", "Odetta", "Odette", "Odilia", "Odille", "Ofelia", "Ofella", "Ofilia", "Ola", "Olenka", "Olga", "Olia", "Olimpia", "Olive", "Olivette", "Olivia", "Olivie", "Oliy", "Ollie", "Olly", "Olva", "Olwen", "Olympe", "Olympia", "Olympie", "Ondrea", "Oneida", "Onida", "Oona", "Opal", "Opalina", "Opaline", "Ophelia", "Ophelie", "Ora", "Oralee", "Oralia", "Oralie", "Oralla", "Oralle", "Orel", "Orelee", "Orelia", "Orelie", "Orella", "Orelle", "Oriana", "Orly", "Orsa", "Orsola", "Ortensia", "Otha", "Othelia", "Othella", "Othilia", "Othilie", "Ottilie", "Page", "Paige", "Paloma", "Pam", "Pamela", "Pamelina", "Pamella", "Pammi", "Pammie", "Pammy", "Pandora", "Pansie", "Pansy", "Paola", "Paolina", "Papagena", "Pat", "Patience", "Patrica", "Patrice", "Patricia", "Patrizia", "Patsy", "Patti", "Pattie", "Patty", "Paula", "Paule", "Pauletta", "Paulette", "Pauli", "Paulie", "Paulina", "Pauline", "Paulita", "Pauly", "Pavia", "Pavla", "Pearl", "Pearla", "Pearle", "Pearline", "Peg", "Pegeen", "Peggi", "Peggie", "Peggy", "Pen", "Penelopa", "Penelope", "Penni", "Pennie", "Penny", "Pepi", "Pepita", "Peri", "Peria", "Perl", "Perla", "Perle", "Perri", "Perrine", "Perry", "Persis", "Pet", "Peta", "Petra", "Petrina", "Petronella", "Petronia", "Petronilla", "Petronille", "Petunia", "Phaedra", "Phaidra", "Phebe", "Phedra", "Phelia", "Phil", "Philipa", "Philippa", "Philippe", "Philippine", "Philis", "Phillida", "Phillie", "Phillis", "Philly", "Philomena", "Phoebe", "Phylis", "Phyllida", "Phyllis", "Phyllys", "Phylys", "Pia", "Pier", "Pierette", "Pierrette", "Pietra", "Piper", "Pippa", "Pippy", "Polly", "Pollyanna", "Pooh", "Poppy", "Portia", "Pris", "Prisca", "Priscella", "Priscilla", "Prissie", "Pru", "Prudence", "Prudi", "Prudy", "Prue", "Queenie", "Quentin", "Querida", "Quinn", "Quinta", "Quintana", "Quintilla", "Quintina", "Rachael", "Rachel", "Rachele", "Rachelle", "Rae", "Raeann", "Raf", "Rafa", "Rafaela", "Rafaelia", "Rafaelita", "Rahal", "Rahel", "Raina", "Raine", "Rakel", "Ralina", "Ramona", "Ramonda", "Rana", "Randa", "Randee", "Randene", "Randi", "Randie", "Randy", "Ranee", "Rani", "Rania", "Ranice", "Ranique", "Ranna", "Raphaela", "Raquel", "Raquela", "Rasia", "Rasla", "Raven", "Ray", "Raychel", "Raye", "Rayna", "Raynell", "Rayshell", "Rea", "Reba", "Rebbecca", "Rebe", "Rebeca", "Rebecca", "Rebecka", "Rebeka", "Rebekah", "Rebekkah", "Ree", "Reeba", "Reena", "Reeta", "Reeva", "Regan", "Reggi", "Reggie", "Regina", "Regine", "Reiko", "Reina", "Reine", "Remy", "Rena", "Renae", "Renata", "Renate", "Rene", "Renee", "Renell", "Renelle", "Renie", "Rennie", "Reta", "Retha", "Revkah", "Rey", "Reyna", "Rhea", "Rheba", "Rheta", "Rhetta", "Rhiamon", "Rhianna", "Rhianon", "Rhoda", "Rhodia", "Rhodie", "Rhody", "Rhona", "Rhonda", "Riane", "Riannon", "Rianon", "Rica", "Ricca", "Rici", "Ricki", "Rickie", "Ricky", "Riki", "Rikki", "Rina", "Risa", "Rita", "Riva", "Rivalee", "Rivi", "Rivkah", "Rivy", "Roana", "Roanna", "Roanne", "Robbi", "Robbie", "Robbin", "Robby", "Robbyn", "Robena", "Robenia", "Roberta", "Robin", "Robina", "Robinet", "Robinett", "Robinetta", "Robinette", "Robinia", "Roby", "Robyn", "Roch", "Rochell", "Rochella", "Rochelle", "Rochette", "Roda", "Rodi", "Rodie", "Rodina", "Rois", "Romola", "Romona", "Romonda", "Romy", "Rona", "Ronalda", "Ronda", "Ronica", "Ronna", "Ronni", "Ronnica", "Ronnie", "Ronny", "Roobbie", "Rora", "Rori", "Rorie", "Rory", "Ros", "Rosa", "Rosabel", "Rosabella", "Rosabelle", "Rosaleen", "Rosalia", "Rosalie", "Rosalind", "Rosalinda", "Rosalinde", "Rosaline", "Rosalyn", "Rosalynd", "Rosamond", "Rosamund", "Rosana", "Rosanna", "Rosanne", "Rose", "Roseann", "Roseanna", "Roseanne", "Roselia", "Roselin", "Roseline", "Rosella", "Roselle", "Rosemaria", "Rosemarie", "Rosemary", "Rosemonde", "Rosene", "Rosetta", "Rosette", "Roshelle", "Rosie", "Rosina", "Rosita", "Roslyn", "Rosmunda", "Rosy", "Row", "Rowe", "Rowena", "Roxana", "Roxane", "Roxanna", "Roxanne", "Roxi", "Roxie", "Roxine", "Roxy", "Roz", "Rozalie", "Rozalin", "Rozamond", "Rozanna", "Rozanne", "Roze", "Rozele", "Rozella", "Rozelle", "Rozina", "Rubetta", "Rubi", "Rubia", "Rubie", "Rubina", "Ruby", "Ruperta", "Ruth", "Ruthann", "Ruthanne", "Ruthe", "Ruthi", "Ruthie", "Ruthy", "Ryann", "Rycca", "Saba", "Sabina", "Sabine", "Sabra", "Sabrina", "Sacha", "Sada", "Sadella", "Sadie", "Sadye", "Saidee", "Sal", "Salaidh", "Sallee", "Salli", "Sallie", "Sally", "Sallyann", "Sallyanne", "Saloma", "Salome", "Salomi", "Sam", "Samantha", "Samara", "Samaria", "Sammy", "Sande", "Sandi", "Sandie", "Sandra", "Sandy", "Sandye", "Sapphira", "Sapphire", "Sara", "Sara-ann", "Saraann", "Sarah", "Sarajane", "Saree", "Sarena", "Sarene", "Sarette", "Sari", "Sarina", "Sarine", "Sarita", "Sascha", "Sasha", "Sashenka", "Saudra", "Saundra", "Savina", "Sayre", "Scarlet", "Scarlett", "Sean", "Seana", "Seka", "Sela", "Selena", "Selene", "Selestina", "Selia", "Selie", "Selina", "Selinda", "Seline", "Sella", "Selle", "Selma", "Sena", "Sephira", "Serena", "Serene", "Shae", "Shaina", "Shaine", "Shalna", "Shalne", "Shana", "Shanda", "Shandee", "Shandeigh", "Shandie", "Shandra", "Shandy", "Shane", "Shani", "Shanie", "Shanna", "Shannah", "Shannen", "Shannon", "Shanon", "Shanta", "Shantee", "Shara", "Sharai", "Shari", "Sharia", "Sharity", "Sharl", "Sharla", "Sharleen", "Sharlene", "Sharline", "Sharon", "Sharona", "Sharron", "Sharyl", "Shaun", "Shauna", "Shawn", "Shawna", "Shawnee", "Shay", "Shayla", "Shaylah", "Shaylyn", "Shaylynn", "Shayna", "Shayne", "Shea", "Sheba", "Sheela", "Sheelagh", "Sheelah", "Sheena", "Sheeree", "Sheila", "Sheila-kathryn", "Sheilah", "Shel", "Shela", "Shelagh", "Shelba", "Shelbi", "Shelby", "Shelia", "Shell", "Shelley", "Shelli", "Shellie", "Shelly", "Shena", "Sher", "Sheree", "Sheri", "Sherie", "Sherill", "Sherilyn", "Sherline", "Sherri", "Sherrie", "Sherry", "Sherye", "Sheryl", "Shina", "Shir", "Shirl", "Shirlee", "Shirleen", "Shirlene", "Shirley", "Shirline", "Shoshana", "Shoshanna", "Siana", "Sianna", "Sib", "Sibbie", "Sibby", "Sibeal", "Sibel", "Sibella", "Sibelle", "Sibilla", "Sibley", "Sibyl", "Sibylla", "Sibylle", "Sidoney", "Sidonia", "Sidonnie", "Sigrid", "Sile", "Sileas", "Silva", "Silvana", "Silvia", "Silvie", "Simona", "Simone", "Simonette", "Simonne", "Sindee", "Siobhan", "Sioux", "Siouxie", "Sisely", "Sisile", "Sissie", "Sissy", "Siusan", "Sofia", "Sofie", "Sondra", "Sonia", "Sonja", "Sonni", "Sonnie", "Sonnnie", "Sonny", "Sonya", "Sophey", "Sophi", "Sophia", "Sophie", "Sophronia", "Sorcha", "Sosanna", "Stace", "Stacee", "Stacey", "Staci", "Stacia", "Stacie", "Stacy", "Stafani", "Star", "Starla", "Starlene", "Starlin", "Starr", "Stefa", "Stefania", "Stefanie", "Steffane", "Steffi", "Steffie", "Stella", "Stepha", "Stephana", "Stephani", "Stephanie", "Stephannie", "Stephenie", "Stephi", "Stephie", "Stephine", "Stesha", "Stevana", "Stevena", "Stoddard", "Storm", "Stormi", "Stormie", "Stormy", "Sue", "Suellen", "Sukey", "Suki", "Sula", "Sunny", "Sunshine", "Susan", "Susana", "Susanetta", "Susann", "Susanna", "Susannah", "Susanne", "Susette", "Susi", "Susie", "Susy", "Suzann", "Suzanna", "Suzanne", "Suzette", "Suzi", "Suzie", "Suzy", "Sybil", "Sybila", "Sybilla", "Sybille", "Sybyl", "Sydel", "Sydelle", "Sydney", "Sylvia", "Tabatha", "Tabbatha", "Tabbi", "Tabbie", "Tabbitha", "Tabby", "Tabina", "Tabitha", "Taffy", "Talia", "Tallia", "Tallie", "Tallou", "Tallulah", "Tally", "Talya", "Talyah", "Tamar", "Tamara", "Tamarah", "Tamarra", "Tamera", "Tami", "Tamiko", "Tamma", "Tammara", "Tammi", "Tammie", "Tammy", "Tamqrah", "Tamra", "Tana", "Tandi", "Tandie", "Tandy", "Tanhya", "Tani", "Tania", "Tanitansy", "Tansy", "Tanya", "Tara", "Tarah", "Tarra", "Tarrah", "Taryn", "Tasha", "Tasia", "Tate", "Tatiana", "Tatiania", "Tatum", "Tawnya", "Tawsha", "Ted", "Tedda", "Teddi", "Teddie", "Teddy", "Tedi", "Tedra", "Teena", "Teirtza", "Teodora", "Tera", "Teresa", "Terese", "Teresina", "Teresita", "Teressa", "Teri", "Teriann", "Terra", "Terri", "Terrie", "Terrijo", "Terry", "Terrye", "Tersina", "Terza", "Tess", "Tessa", "Tessi", "Tessie", "Tessy", "Thalia", "Thea", "Theadora", "Theda", "Thekla", "Thelma", "Theo", "Theodora", "Theodosia", "Theresa", "Therese", "Theresina", "Theresita", "Theressa", "Therine", "Thia", "Thomasa", "Thomasin", "Thomasina", "Thomasine", "Tiena", "Tierney", "Tiertza", "Tiff", "Tiffani", "Tiffanie", "Tiffany", "Tiffi", "Tiffie", "Tiffy", "Tilda", "Tildi", "Tildie", "Tildy", "Tillie", "Tilly", "Tim", "Timi", "Timmi", "Timmie", "Timmy", "Timothea", "Tina", "Tine", "Tiphani", "Tiphanie", "Tiphany", "Tish", "Tisha", "Tobe", "Tobey", "Tobi", "Toby", "Tobye", "Toinette", "Toma", "Tomasina", "Tomasine", "Tomi", "Tommi", "Tommie", "Tommy", "Toni", "Tonia", "Tonie", "Tony", "Tonya", "Tonye", "Tootsie", "Torey", "Tori", "Torie", "Torrie", "Tory", "Tova", "Tove", "Tracee", "Tracey", "Traci", "Tracie", "Tracy", "Trenna", "Tresa", "Trescha", "Tressa", "Tricia", "Trina", "Trish", "Trisha", "Trista", "Trix", "Trixi", "Trixie", "Trixy", "Truda", "Trude", "Trudey", "Trudi", "Trudie", "Trudy", "Trula", "Tuesday", "Twila", "Twyla", "Tybi", "Tybie", "Tyne", "Ula", "Ulla", "Ulrica", "Ulrika", "Ulrikaumeko", "Ulrike", "Umeko", "Una", "Ursa", "Ursala", "Ursola", "Ursula", "Ursulina", "Ursuline", "Uta", "Val", "Valaree", "Valaria", "Vale", "Valeda", "Valencia", "Valene", "Valenka", "Valentia", "Valentina", "Valentine", "Valera", "Valeria", "Valerie", "Valery", "Valerye", "Valida", "Valina", "Valli", "Vallie", "Vally", "Valma", "Valry", "Van", "Vanda", "Vanessa", "Vania", "Vanna", "Vanni", "Vannie", "Vanny", "Vanya", "Veda", "Velma", "Velvet", "Venita", "Venus", "Vera", "Veradis", "Vere", "Verena", "Verene", "Veriee", "Verile", "Verina", "Verine", "Verla", "Verna", "Vernice", "Veronica", "Veronika", "Veronike", "Veronique", "Vevay", "Vi", "Vicki", "Vickie", "Vicky", "Victoria", "Vida", "Viki", "Vikki", "Vikky", "Vilhelmina", "Vilma", "Vin", "Vina", "Vinita", "Vinni", "Vinnie", "Vinny", "Viola", "Violante", "Viole", "Violet", "Violetta", "Violette", "Virgie", "Virgina", "Virginia", "Virginie", "Vita", "Vitia", "Vitoria", "Vittoria", "Viv", "Viva", "Vivi", "Vivia", "Vivian", "Viviana", "Vivianna", "Vivianne", "Vivie", "Vivien", "Viviene", "Vivienne", "Viviyan", "Vivyan", "Vivyanne", "Vonni", "Vonnie", "Vonny", "Vyky", "Wallie", "Wallis", "Walliw", "Wally", "Waly", "Wanda", "Wandie", "Wandis", "Waneta", "Wanids", "Wenda", "Wendeline", "Wendi", "Wendie", "Wendy", "Wendye", "Wenona", "Wenonah", "Whitney", "Wileen", "Wilhelmina", "Wilhelmine", "Wilie", "Willa", "Willabella", "Willamina", "Willetta", "Willette", "Willi", "Willie", "Willow", "Willy", "Willyt", "Wilma", "Wilmette", "Wilona", "Wilone", "Wilow", "Windy", "Wini", "Winifred", "Winna", "Winnah", "Winne", "Winni", "Winnie", "Winnifred", "Winny", "Winona", "Winonah", "Wren", "Wrennie", "Wylma", "Wynn", "Wynne", "Wynnie", "Wynny", "Xaviera", "Xena", "Xenia", "Xylia", "Xylina", "Yalonda", "Yasmeen", "Yasmin", "Yelena", "Yetta", "Yettie", "Yetty", "Yevette", "Ynes", "Ynez", "Yoko", "Yolanda", "Yolande", "Yolane", "Yolanthe", "Yoshi", "Yoshiko", "Yovonnda", "Ysabel", "Yvette", "Yvonne", "Zabrina", "Zahara", "Zandra", "Zaneta", "Zara", "Zarah", "Zaria", "Zarla", "Zea", "Zelda", "Zelma", "Zena", "Zenia", "Zia", "Zilvia", "Zita", "Zitella", "Zoe", "Zola", "Zonda", "Zondra", "Zonnya", "Zora", "Zorah", "Zorana", "Zorina", "Zorine", "Zsazsa", "Zulema", "Zuzana"];
var n$ = {};
lq(n$, { xid: () => nm, void: () => wd, uuidv7: () => xm, uuidv6: () => um, uuidv4: () => ym, uuid: () => bm, util: () => l$, url: () => pm, uppercase: () => q7, unknown: () => g4, union: () => sW, undefined: () => Jd, ulid: () => om, uint64: () => Wd, uint32: () => jd, tuple: () => zV, trim: () => j7, treeifyError: () => QY, transform: () => KH, toUpperCase: () => z7, toLowerCase: () => v7, toJSONSchema: () => O4, templateLiteral: () => Ld, symbol: () => Hd, superRefine: () => yV, success: () => Rd, stringbool: () => pd, stringFormat: () => $d, string: () => LW, strictObject: () => Ad, startsWith: () => _7, size: () => eP, setErrorMap: () => ld, set: () => Md, safeParseAsync: () => SW, safeParse: () => VW, safeEncodeAsync: () => IW, safeEncode: () => hW, safeDecodeAsync: () => DW, safeDecode: () => RW, registry: () => x9, regexes: () => f8, regex: () => sP, refine: () => bV, record: () => WV, readonly: () => hV, property: () => Mv, promise: () => gd, prettifyError: () => eY, preprocess: () => md, prefault: () => GV, positive: () => kv, pipe: () => m5, partialRecord: () => Vd, parseAsync: () => GW, parse: () => kW, overwrite: () => zK, optional: () => p5, object: () => Xd, number: () => UG, nullish: () => hd, nullable: () => c5, null: () => sG, normalize: () => Y7, nonpositive: () => Vv, nonoptional: () => VV, nonnegative: () => Sv, never: () => QW, negative: () => Gv, nativeEnum: () => Nd, nanoid: () => dm, nan: () => Id, multipleOf: () => f_, minSize: () => Z_, minLength: () => rK, mime: () => O7, maxSize: () => q4, maxLength: () => K4, map: () => Sd, lte: () => Z8, lt: () => jK, lowercase: () => $72, looseObject: () => kd, locales: () => tP, literal: () => Cd, length: () => _4, lazy: () => DV, ksuid: () => im, keyof: () => Zd, jwt: () => sm, json: () => cd, iso: () => u5, ipv6: () => tm, ipv4: () => Bm, intersection: () => jV, int64: () => zd, int32: () => Yd, int: () => gW, instanceof: () => xd, includes: () => K7, httpUrl: () => cm, hostname: () => qd, hex: () => Kd, hash: () => _d, guid: () => gm, gte: () => Fq, gt: () => vK, globalRegistry: () => Wq, getErrorMap: () => rd, function: () => bd, formatError: () => uP, float64: () => Od, float32: () => Pd, flattenError: () => yP, file: () => Ed, enum: () => qH, endsWith: () => P7, encodeAsync: () => CW, encode: () => MW, emoji: () => mm, email: () => Lm, e164: () => em, discriminatedUnion: () => Gd, decodeAsync: () => EW, decode: () => NW, date: () => fd, custom: () => ud, cuid2: () => rm, cuid: () => lm, core: () => WK, config: () => r6, coerce: () => vH, codec: () => Dd, clone: () => o6, cidrv6: () => Fm, cidrv4: () => Um, check: () => yd, catch: () => NV, boolean: () => FG, bigint: () => vd, base64url: () => Qm, base64: () => am, array: () => r5, any: () => Td, _function: () => bd, _default: () => AV, _ZodString: () => bW, ZodXID: () => dW, ZodVoid: () => _V, ZodUnknown: () => qV, ZodUnion: () => eW, ZodUndefined: () => QG, ZodUUID: () => kK, ZodURL: () => d5, ZodULID: () => mW, ZodType: () => T6, ZodTuple: () => vV, ZodTransform: () => fV, ZodTemplateLiteral: () => RV, ZodSymbol: () => aG, ZodSuccess: () => SV, ZodStringFormat: () => h6, ZodString: () => y7, ZodSet: () => JV, ZodRecord: () => $H, ZodRealError: () => Qq, ZodReadonly: () => EV, ZodPromise: () => LV, ZodPrefault: () => kV, ZodPipe: () => OH, ZodOptional: () => _H, ZodObject: () => o5, ZodNumberFormat: () => b4, ZodNumber: () => x7, ZodNullable: () => ZV, ZodNull: () => eG, ZodNonOptional: () => PH, ZodNever: () => KV, ZodNanoID: () => xW, ZodNaN: () => CV, ZodMap: () => HV, ZodLiteral: () => TV, ZodLazy: () => IV, ZodKSUID: () => lW, ZodJWT: () => FW, ZodIssueCode: () => dd, ZodIntersection: () => YV, ZodISOTime: () => b5, ZodISODuration: () => y5, ZodISODateTime: () => L5, ZodISODate: () => g5, ZodIPv6: () => oW, ZodIPv4: () => rW, ZodGUID: () => x5, ZodFunction: () => gV, ZodFirstPartyTypeKind: () => jH, ZodFile: () => wV, ZodError: () => Im, ZodEnum: () => b7, ZodEmoji: () => uW, ZodEmail: () => yW, ZodE164: () => UW, ZodDiscriminatedUnion: () => OV, ZodDefault: () => XV, ZodDate: () => l5, ZodCustomStringFormat: () => u7, ZodCustom: () => n5, ZodCodec: () => YH, ZodCatch: () => MV, ZodCUID2: () => cW, ZodCUID: () => pW, ZodCIDRv6: () => iW, ZodCIDRv4: () => nW, ZodBoolean: () => p7, ZodBigIntFormat: () => aW, ZodBigInt: () => c7, ZodBase64URL: () => tW, ZodBase64: () => BW, ZodArray: () => PV, ZodAny: () => $V, TimePrecision: () => t3, NEVER: () => lY, $output: () => o3, $input: () => n3, $brand: () => rY });
var u5 = {};
lq(u5, { time: () => XW, duration: () => AW, datetime: () => fW, date: () => ZW, ZodISOTime: () => b5, ZodISODuration: () => y5, ZodISODateTime: () => L5, ZodISODate: () => g5 });
var L5 = O$("ZodISODateTime", ($18, q) => {
  jj.init($18, q), h6.init($18, q);
});
function fW($18) {
  return U3(L5, $18);
}
var g5 = O$("ZodISODate", ($18, q) => {
  vj.init($18, q), h6.init($18, q);
});
function ZW($18) {
  return F3(g5, $18);
}
var b5 = O$("ZodISOTime", ($18, q) => {
  zj.init($18, q), h6.init($18, q);
});
function XW($18) {
  return a3(b5, $18);
}
var y5 = O$("ZodISODuration", ($18, q) => {
  Wj.init($18, q), h6.init($18, q);
});
function AW($18) {
  return Q3(y5, $18);
}
var tG = ($18, q) => {
  bP.init($18, q), $18.name = "ZodError", Object.defineProperties($18, { format: { value: (K) => uP($18, K) }, flatten: { value: (K) => yP($18, K) }, addIssue: { value: (K) => {
    $18.issues.push(K), $18.message = JSON.stringify($18.issues, B_, 2);
  } }, addIssues: { value: (K) => {
    $18.issues.push(...K), $18.message = JSON.stringify($18.issues, B_, 2);
  } }, isEmpty: { get() {
    return $18.issues.length === 0;
  } } });
};
var Im = O$("ZodError", tG);
var Qq = O$("ZodError", tG, { Parent: Error });
var kW = F_(Qq);
var GW = a_(Qq);
var VW = e_(Qq);
var SW = s_(Qq);
var MW = T9(Qq);
var NW = w9(Qq);
var CW = f9(Qq);
var EW = Z9(Qq);
var hW = X9(Qq);
var RW = A9(Qq);
var IW = k9(Qq);
var DW = G9(Qq);
var T6 = O$("ZodType", ($18, q) => {
  return P6.init($18, q), $18.def = q, $18.type = q.type, Object.defineProperty($18, "_def", { value: q }), $18.check = (...K) => {
    return $18.clone(l$.mergeDefs(q, { checks: [...q.checks ?? [], ...K.map((P) => typeof P === "function" ? { _zod: { check: P, def: { check: "custom" }, onattach: [] } } : P)] }));
  }, $18.clone = (K, P) => o6($18, K, P), $18.brand = () => $18, $18.register = (K, P) => {
    return K.add($18, P), $18;
  }, $18.parse = (K, P) => kW($18, K, P, { callee: $18.parse }), $18.safeParse = (K, P) => VW($18, K, P), $18.parseAsync = async (K, P) => GW($18, K, P, { callee: $18.parseAsync }), $18.safeParseAsync = async (K, P) => SW($18, K, P), $18.spa = $18.safeParseAsync, $18.encode = (K, P) => MW($18, K, P), $18.decode = (K, P) => NW($18, K, P), $18.encodeAsync = async (K, P) => CW($18, K, P), $18.decodeAsync = async (K, P) => EW($18, K, P), $18.safeEncode = (K, P) => hW($18, K, P), $18.safeDecode = (K, P) => RW($18, K, P), $18.safeEncodeAsync = async (K, P) => IW($18, K, P), $18.safeDecodeAsync = async (K, P) => DW($18, K, P), $18.refine = (K, P) => $18.check(bV(K, P)), $18.superRefine = (K) => $18.check(yV(K)), $18.overwrite = (K) => $18.check(zK(K)), $18.optional = () => p5($18), $18.nullable = () => c5($18), $18.nullish = () => p5(c5($18)), $18.nonoptional = (K) => VV($18, K), $18.array = () => r5($18), $18.or = (K) => sW([$18, K]), $18.and = (K) => jV($18, K), $18.transform = (K) => m5($18, KH(K)), $18.default = (K) => AV($18, K), $18.prefault = (K) => GV($18, K), $18.catch = (K) => NV($18, K), $18.pipe = (K) => m5($18, K), $18.readonly = () => hV($18), $18.describe = (K) => {
    let P = $18.clone();
    return Wq.add(P, { description: K }), P;
  }, Object.defineProperty($18, "description", { get() {
    var _a2;
    return (_a2 = Wq.get($18)) == null ? void 0 : _a2.description;
  }, configurable: true }), $18.meta = (...K) => {
    if (K.length === 0) return Wq.get($18);
    let P = $18.clone();
    return Wq.add(P, K[0]), P;
  }, $18.isOptional = () => $18.safeParse(void 0).success, $18.isNullable = () => $18.safeParse(null).success, $18;
});
var bW = O$("_ZodString", ($18, q) => {
  w_.init($18, q), T6.init($18, q);
  let K = $18._zod.bag;
  $18.format = K.format ?? null, $18.minLength = K.minimum ?? null, $18.maxLength = K.maximum ?? null, $18.regex = (...P) => $18.check(sP(...P)), $18.includes = (...P) => $18.check(K7(...P)), $18.startsWith = (...P) => $18.check(_7(...P)), $18.endsWith = (...P) => $18.check(P7(...P)), $18.min = (...P) => $18.check(rK(...P)), $18.max = (...P) => $18.check(K4(...P)), $18.length = (...P) => $18.check(_4(...P)), $18.nonempty = (...P) => $18.check(rK(1, ...P)), $18.lowercase = (P) => $18.check($72(P)), $18.uppercase = (P) => $18.check(q7(P)), $18.trim = () => $18.check(j7()), $18.normalize = (...P) => $18.check(Y7(...P)), $18.toLowerCase = () => $18.check(v7()), $18.toUpperCase = () => $18.check(z7());
});
var y7 = O$("ZodString", ($18, q) => {
  w_.init($18, q), bW.init($18, q), $18.email = (K) => $18.check(p9(yW, K)), $18.url = (K) => $18.check(aP(d5, K)), $18.jwt = (K) => $18.check(K5(FW, K)), $18.emoji = (K) => $18.check(r9(uW, K)), $18.guid = (K) => $18.check(FP(x5, K)), $18.uuid = (K) => $18.check(c9(kK, K)), $18.uuidv4 = (K) => $18.check(m9(kK, K)), $18.uuidv6 = (K) => $18.check(d9(kK, K)), $18.uuidv7 = (K) => $18.check(l9(kK, K)), $18.nanoid = (K) => $18.check(o9(xW, K)), $18.guid = (K) => $18.check(FP(x5, K)), $18.cuid = (K) => $18.check(n9(pW, K)), $18.cuid2 = (K) => $18.check(i9(cW, K)), $18.ulid = (K) => $18.check(B9(mW, K)), $18.base64 = (K) => $18.check(s9(BW, K)), $18.base64url = (K) => $18.check($52(tW, K)), $18.xid = (K) => $18.check(t9(dW, K)), $18.ksuid = (K) => $18.check(U9(lW, K)), $18.ipv4 = (K) => $18.check(F9(rW, K)), $18.ipv6 = (K) => $18.check(a9(oW, K)), $18.cidrv4 = (K) => $18.check(Q9(nW, K)), $18.cidrv6 = (K) => $18.check(e9(iW, K)), $18.e164 = (K) => $18.check(q5(UW, K)), $18.datetime = (K) => $18.check(fW(K)), $18.date = (K) => $18.check(ZW(K)), $18.time = (K) => $18.check(XW(K)), $18.duration = (K) => $18.check(AW(K));
});
function LW($18) {
  return i3(y7, $18);
}
var h6 = O$("ZodStringFormat", ($18, q) => {
  E6.init($18, q), bW.init($18, q);
});
var yW = O$("ZodEmail", ($18, q) => {
  e2.init($18, q), h6.init($18, q);
});
function Lm($18) {
  return p9(yW, $18);
}
var x5 = O$("ZodGUID", ($18, q) => {
  a2.init($18, q), h6.init($18, q);
});
function gm($18) {
  return FP(x5, $18);
}
var kK = O$("ZodUUID", ($18, q) => {
  Q2.init($18, q), h6.init($18, q);
});
function bm($18) {
  return c9(kK, $18);
}
function ym($18) {
  return m9(kK, $18);
}
function um($18) {
  return d9(kK, $18);
}
function xm($18) {
  return l9(kK, $18);
}
var d5 = O$("ZodURL", ($18, q) => {
  s2.init($18, q), h6.init($18, q);
});
function pm($18) {
  return aP(d5, $18);
}
function cm($18) {
  return aP(d5, { protocol: /^https?$/, hostname: f8.domain, ...l$.normalizeParams($18) });
}
var uW = O$("ZodEmoji", ($18, q) => {
  $j.init($18, q), h6.init($18, q);
});
function mm($18) {
  return r9(uW, $18);
}
var xW = O$("ZodNanoID", ($18, q) => {
  qj.init($18, q), h6.init($18, q);
});
function dm($18) {
  return o9(xW, $18);
}
var pW = O$("ZodCUID", ($18, q) => {
  Kj.init($18, q), h6.init($18, q);
});
function lm($18) {
  return n9(pW, $18);
}
var cW = O$("ZodCUID2", ($18, q) => {
  _j.init($18, q), h6.init($18, q);
});
function rm($18) {
  return i9(cW, $18);
}
var mW = O$("ZodULID", ($18, q) => {
  Pj.init($18, q), h6.init($18, q);
});
function om($18) {
  return B9(mW, $18);
}
var dW = O$("ZodXID", ($18, q) => {
  Oj.init($18, q), h6.init($18, q);
});
function nm($18) {
  return t9(dW, $18);
}
var lW = O$("ZodKSUID", ($18, q) => {
  Yj.init($18, q), h6.init($18, q);
});
function im($18) {
  return U9(lW, $18);
}
var rW = O$("ZodIPv4", ($18, q) => {
  Hj.init($18, q), h6.init($18, q);
});
function Bm($18) {
  return F9(rW, $18);
}
var oW = O$("ZodIPv6", ($18, q) => {
  Jj.init($18, q), h6.init($18, q);
});
function tm($18) {
  return a9(oW, $18);
}
var nW = O$("ZodCIDRv4", ($18, q) => {
  Tj.init($18, q), h6.init($18, q);
});
function Um($18) {
  return Q9(nW, $18);
}
var iW = O$("ZodCIDRv6", ($18, q) => {
  wj.init($18, q), h6.init($18, q);
});
function Fm($18) {
  return e9(iW, $18);
}
var BW = O$("ZodBase64", ($18, q) => {
  Zj.init($18, q), h6.init($18, q);
});
function am($18) {
  return s9(BW, $18);
}
var tW = O$("ZodBase64URL", ($18, q) => {
  Xj.init($18, q), h6.init($18, q);
});
function Qm($18) {
  return $52(tW, $18);
}
var UW = O$("ZodE164", ($18, q) => {
  Aj.init($18, q), h6.init($18, q);
});
function em($18) {
  return q5(UW, $18);
}
var FW = O$("ZodJWT", ($18, q) => {
  kj.init($18, q), h6.init($18, q);
});
function sm($18) {
  return K5(FW, $18);
}
var u7 = O$("ZodCustomStringFormat", ($18, q) => {
  Gj.init($18, q), h6.init($18, q);
});
function $d($18, q, K = {}) {
  return P4(u7, $18, q, K);
}
function qd($18) {
  return P4(u7, "hostname", f8.hostname, $18);
}
function Kd($18) {
  return P4(u7, "hex", f8.hex, $18);
}
function _d($18, q) {
  let K = (q == null ? void 0 : q.enc) ?? "hex", P = `${$18}_${K}`, _ = f8[P];
  if (!_) throw Error(`Unrecognized hash format: ${P}`);
  return P4(u7, P, _, q);
}
var x7 = O$("ZodNumber", ($18, q) => {
  D9.init($18, q), T6.init($18, q), $18.gt = (P, _) => $18.check(vK(P, _)), $18.gte = (P, _) => $18.check(Fq(P, _)), $18.min = (P, _) => $18.check(Fq(P, _)), $18.lt = (P, _) => $18.check(jK(P, _)), $18.lte = (P, _) => $18.check(Z8(P, _)), $18.max = (P, _) => $18.check(Z8(P, _)), $18.int = (P) => $18.check(gW(P)), $18.safe = (P) => $18.check(gW(P)), $18.positive = (P) => $18.check(vK(0, P)), $18.nonnegative = (P) => $18.check(Fq(0, P)), $18.negative = (P) => $18.check(jK(0, P)), $18.nonpositive = (P) => $18.check(Z8(0, P)), $18.multipleOf = (P, _) => $18.check(f_(P, _)), $18.step = (P, _) => $18.check(f_(P, _)), $18.finite = () => $18;
  let K = $18._zod.bag;
  $18.minValue = Math.max(K.minimum ?? Number.NEGATIVE_INFINITY, K.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null, $18.maxValue = Math.min(K.maximum ?? Number.POSITIVE_INFINITY, K.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null, $18.isInt = (K.format ?? "").includes("int") || Number.isSafeInteger(K.multipleOf ?? 0.5), $18.isFinite = true, $18.format = K.format ?? null;
});
function UG($18) {
  return e3(x7, $18);
}
var b4 = O$("ZodNumberFormat", ($18, q) => {
  Vj.init($18, q), x7.init($18, q);
});
function gW($18) {
  return $v(b4, $18);
}
function Pd($18) {
  return qv(b4, $18);
}
function Od($18) {
  return Kv(b4, $18);
}
function Yd($18) {
  return _v(b4, $18);
}
function jd($18) {
  return Pv(b4, $18);
}
var p7 = O$("ZodBoolean", ($18, q) => {
  mP.init($18, q), T6.init($18, q);
});
function FG($18) {
  return Ov(p7, $18);
}
var c7 = O$("ZodBigInt", ($18, q) => {
  L9.init($18, q), T6.init($18, q), $18.gte = (P, _) => $18.check(Fq(P, _)), $18.min = (P, _) => $18.check(Fq(P, _)), $18.gt = (P, _) => $18.check(vK(P, _)), $18.gte = (P, _) => $18.check(Fq(P, _)), $18.min = (P, _) => $18.check(Fq(P, _)), $18.lt = (P, _) => $18.check(jK(P, _)), $18.lte = (P, _) => $18.check(Z8(P, _)), $18.max = (P, _) => $18.check(Z8(P, _)), $18.positive = (P) => $18.check(vK(BigInt(0), P)), $18.negative = (P) => $18.check(jK(BigInt(0), P)), $18.nonpositive = (P) => $18.check(Z8(BigInt(0), P)), $18.nonnegative = (P) => $18.check(Fq(BigInt(0), P)), $18.multipleOf = (P, _) => $18.check(f_(P, _));
  let K = $18._zod.bag;
  $18.minValue = K.minimum ?? null, $18.maxValue = K.maximum ?? null, $18.format = K.format ?? null;
});
function vd($18) {
  return jv(c7, $18);
}
var aW = O$("ZodBigIntFormat", ($18, q) => {
  Sj.init($18, q), c7.init($18, q);
});
function zd($18) {
  return zv(aW, $18);
}
function Wd($18) {
  return Wv(aW, $18);
}
var aG = O$("ZodSymbol", ($18, q) => {
  Mj.init($18, q), T6.init($18, q);
});
function Hd($18) {
  return Hv(aG, $18);
}
var QG = O$("ZodUndefined", ($18, q) => {
  Nj.init($18, q), T6.init($18, q);
});
function Jd($18) {
  return Jv(QG, $18);
}
var eG = O$("ZodNull", ($18, q) => {
  Cj.init($18, q), T6.init($18, q);
});
function sG($18) {
  return Tv(eG, $18);
}
var $V = O$("ZodAny", ($18, q) => {
  Ej.init($18, q), T6.init($18, q);
});
function Td() {
  return wv($V);
}
var qV = O$("ZodUnknown", ($18, q) => {
  g9.init($18, q), T6.init($18, q);
});
function g4() {
  return _5(qV);
}
var KV = O$("ZodNever", ($18, q) => {
  dP.init($18, q), T6.init($18, q);
});
function QW($18) {
  return QP(KV, $18);
}
var _V = O$("ZodVoid", ($18, q) => {
  hj.init($18, q), T6.init($18, q);
});
function wd($18) {
  return fv(_V, $18);
}
var l5 = O$("ZodDate", ($18, q) => {
  Rj.init($18, q), T6.init($18, q), $18.min = (P, _) => $18.check(Fq(P, _)), $18.max = (P, _) => $18.check(Z8(P, _));
  let K = $18._zod.bag;
  $18.minDate = K.minimum ? new Date(K.minimum) : null, $18.maxDate = K.maximum ? new Date(K.maximum) : null;
});
function fd($18) {
  return Zv(l5, $18);
}
var PV = O$("ZodArray", ($18, q) => {
  Ij.init($18, q), T6.init($18, q), $18.element = q.element, $18.min = (K, P) => $18.check(rK(K, P)), $18.nonempty = (K) => $18.check(rK(1, K)), $18.max = (K, P) => $18.check(K4(K, P)), $18.length = (K, P) => $18.check(_4(K, P)), $18.unwrap = () => $18.element;
});
function r5($18, q) {
  return Nv(PV, $18, q);
}
function Zd($18) {
  let q = $18._zod.def.shape;
  return qH(Object.keys(q));
}
var o5 = O$("ZodObject", ($18, q) => {
  Dj.init($18, q), T6.init($18, q), l$.defineLazy($18, "shape", () => {
    return q.shape;
  }), $18.keyof = () => qH(Object.keys($18._zod.def.shape)), $18.catchall = (K) => $18.clone({ ...$18._zod.def, catchall: K }), $18.passthrough = () => $18.clone({ ...$18._zod.def, catchall: g4() }), $18.loose = () => $18.clone({ ...$18._zod.def, catchall: g4() }), $18.strict = () => $18.clone({ ...$18._zod.def, catchall: QW() }), $18.strip = () => $18.clone({ ...$18._zod.def, catchall: void 0 }), $18.extend = (K) => {
    return l$.extend($18, K);
  }, $18.safeExtend = (K) => {
    return l$.safeExtend($18, K);
  }, $18.merge = (K) => l$.merge($18, K), $18.pick = (K) => l$.pick($18, K), $18.omit = (K) => l$.omit($18, K), $18.partial = (...K) => l$.partial(_H, $18, K[0]), $18.required = (...K) => l$.required(PH, $18, K[0]);
});
function Xd($18, q) {
  let K = { type: "object", shape: $18 ?? {}, ...l$.normalizeParams(q) };
  return new o5(K);
}
function Ad($18, q) {
  return new o5({ type: "object", shape: $18, catchall: QW(), ...l$.normalizeParams(q) });
}
function kd($18, q) {
  return new o5({ type: "object", shape: $18, catchall: g4(), ...l$.normalizeParams(q) });
}
var eW = O$("ZodUnion", ($18, q) => {
  b9.init($18, q), T6.init($18, q), $18.options = q.options;
});
function sW($18, q) {
  return new eW({ type: "union", options: $18, ...l$.normalizeParams(q) });
}
var OV = O$("ZodDiscriminatedUnion", ($18, q) => {
  eW.init($18, q), Lj.init($18, q);
});
function Gd($18, q, K) {
  return new OV({ type: "union", options: q, discriminator: $18, ...l$.normalizeParams(K) });
}
var YV = O$("ZodIntersection", ($18, q) => {
  gj.init($18, q), T6.init($18, q);
});
function jV($18, q) {
  return new YV({ type: "intersection", left: $18, right: q });
}
var vV = O$("ZodTuple", ($18, q) => {
  y9.init($18, q), T6.init($18, q), $18.rest = (K) => $18.clone({ ...$18._zod.def, rest: K });
});
function zV($18, q, K) {
  let P = q instanceof P6, _ = P ? K : q;
  return new vV({ type: "tuple", items: $18, rest: P ? q : null, ...l$.normalizeParams(_) });
}
var $H = O$("ZodRecord", ($18, q) => {
  bj.init($18, q), T6.init($18, q), $18.keyType = q.keyType, $18.valueType = q.valueType;
});
function WV($18, q, K) {
  return new $H({ type: "record", keyType: $18, valueType: q, ...l$.normalizeParams(K) });
}
function Vd($18, q, K) {
  let P = o6($18);
  return P._zod.values = void 0, new $H({ type: "record", keyType: P, valueType: q, ...l$.normalizeParams(K) });
}
var HV = O$("ZodMap", ($18, q) => {
  yj.init($18, q), T6.init($18, q), $18.keyType = q.keyType, $18.valueType = q.valueType;
});
function Sd($18, q, K) {
  return new HV({ type: "map", keyType: $18, valueType: q, ...l$.normalizeParams(K) });
}
var JV = O$("ZodSet", ($18, q) => {
  uj.init($18, q), T6.init($18, q), $18.min = (...K) => $18.check(Z_(...K)), $18.nonempty = (K) => $18.check(Z_(1, K)), $18.max = (...K) => $18.check(q4(...K)), $18.size = (...K) => $18.check(eP(...K));
});
function Md($18, q) {
  return new JV({ type: "set", valueType: $18, ...l$.normalizeParams(q) });
}
var b7 = O$("ZodEnum", ($18, q) => {
  xj.init($18, q), T6.init($18, q), $18.enum = q.entries, $18.options = Object.values(q.entries);
  let K = new Set(Object.keys(q.entries));
  $18.extract = (P, _) => {
    let Y = {};
    for (let O of P) if (K.has(O)) Y[O] = q.entries[O];
    else throw Error(`Key ${O} not found in enum`);
    return new b7({ ...q, checks: [], ...l$.normalizeParams(_), entries: Y });
  }, $18.exclude = (P, _) => {
    let Y = { ...q.entries };
    for (let O of P) if (K.has(O)) delete Y[O];
    else throw Error(`Key ${O} not found in enum`);
    return new b7({ ...q, checks: [], ...l$.normalizeParams(_), entries: Y });
  };
});
function qH($18, q) {
  let K = Array.isArray($18) ? Object.fromEntries($18.map((P) => [P, P])) : $18;
  return new b7({ type: "enum", entries: K, ...l$.normalizeParams(q) });
}
function Nd($18, q) {
  return new b7({ type: "enum", entries: $18, ...l$.normalizeParams(q) });
}
var TV = O$("ZodLiteral", ($18, q) => {
  pj.init($18, q), T6.init($18, q), $18.values = new Set(q.values), Object.defineProperty($18, "value", { get() {
    if (q.values.length > 1) throw Error("This schema contains multiple valid literal values. Use `.values` instead.");
    return q.values[0];
  } });
});
function Cd($18, q) {
  return new TV({ type: "literal", values: Array.isArray($18) ? $18 : [$18], ...l$.normalizeParams(q) });
}
var wV = O$("ZodFile", ($18, q) => {
  cj.init($18, q), T6.init($18, q), $18.min = (K, P) => $18.check(Z_(K, P)), $18.max = (K, P) => $18.check(q4(K, P)), $18.mime = (K, P) => $18.check(O7(Array.isArray(K) ? K : [K], P));
});
function Ed($18) {
  return Cv(wV, $18);
}
var fV = O$("ZodTransform", ($18, q) => {
  mj.init($18, q), T6.init($18, q), $18._zod.parse = (K, P) => {
    if (P.direction === "backward") throw new H_($18.constructor.name);
    K.addIssue = (Y) => {
      if (typeof Y === "string") K.issues.push(l$.issue(Y, K.value, q));
      else {
        let O = Y;
        if (O.fatal) O.continue = false;
        O.code ?? (O.code = "custom"), O.input ?? (O.input = K.value), O.inst ?? (O.inst = $18), K.issues.push(l$.issue(O));
      }
    };
    let _ = q.transform(K.value, K);
    if (_ instanceof Promise) return _.then((Y) => {
      return K.value = Y, K;
    });
    return K.value = _, K;
  };
});
function KH($18) {
  return new fV({ type: "transform", transform: $18 });
}
var _H = O$("ZodOptional", ($18, q) => {
  u9.init($18, q), T6.init($18, q), $18.unwrap = () => $18._zod.def.innerType;
});
function p5($18) {
  return new _H({ type: "optional", innerType: $18 });
}
var ZV = O$("ZodNullable", ($18, q) => {
  dj.init($18, q), T6.init($18, q), $18.unwrap = () => $18._zod.def.innerType;
});
function c5($18) {
  return new ZV({ type: "nullable", innerType: $18 });
}
function hd($18) {
  return p5(c5($18));
}
var XV = O$("ZodDefault", ($18, q) => {
  lj.init($18, q), T6.init($18, q), $18.unwrap = () => $18._zod.def.innerType, $18.removeDefault = $18.unwrap;
});
function AV($18, q) {
  return new XV({ type: "default", innerType: $18, get defaultValue() {
    return typeof q === "function" ? q() : l$.shallowClone(q);
  } });
}
var kV = O$("ZodPrefault", ($18, q) => {
  rj.init($18, q), T6.init($18, q), $18.unwrap = () => $18._zod.def.innerType;
});
function GV($18, q) {
  return new kV({ type: "prefault", innerType: $18, get defaultValue() {
    return typeof q === "function" ? q() : l$.shallowClone(q);
  } });
}
var PH = O$("ZodNonOptional", ($18, q) => {
  oj.init($18, q), T6.init($18, q), $18.unwrap = () => $18._zod.def.innerType;
});
function VV($18, q) {
  return new PH({ type: "nonoptional", innerType: $18, ...l$.normalizeParams(q) });
}
var SV = O$("ZodSuccess", ($18, q) => {
  nj.init($18, q), T6.init($18, q), $18.unwrap = () => $18._zod.def.innerType;
});
function Rd($18) {
  return new SV({ type: "success", innerType: $18 });
}
var MV = O$("ZodCatch", ($18, q) => {
  ij.init($18, q), T6.init($18, q), $18.unwrap = () => $18._zod.def.innerType, $18.removeCatch = $18.unwrap;
});
function NV($18, q) {
  return new MV({ type: "catch", innerType: $18, catchValue: typeof q === "function" ? q : () => q });
}
var CV = O$("ZodNaN", ($18, q) => {
  Bj.init($18, q), T6.init($18, q);
});
function Id($18) {
  return Av(CV, $18);
}
var OH = O$("ZodPipe", ($18, q) => {
  tj.init($18, q), T6.init($18, q), $18.in = q.in, $18.out = q.out;
});
function m5($18, q) {
  return new OH({ type: "pipe", in: $18, out: q });
}
var YH = O$("ZodCodec", ($18, q) => {
  OH.init($18, q), lP.init($18, q);
});
function Dd($18, q, K) {
  return new YH({ type: "pipe", in: $18, out: q, transform: K.decode, reverseTransform: K.encode });
}
var EV = O$("ZodReadonly", ($18, q) => {
  Uj.init($18, q), T6.init($18, q), $18.unwrap = () => $18._zod.def.innerType;
});
function hV($18) {
  return new EV({ type: "readonly", innerType: $18 });
}
var RV = O$("ZodTemplateLiteral", ($18, q) => {
  Fj.init($18, q), T6.init($18, q);
});
function Ld($18, q) {
  return new RV({ type: "template_literal", parts: $18, ...l$.normalizeParams(q) });
}
var IV = O$("ZodLazy", ($18, q) => {
  ej.init($18, q), T6.init($18, q), $18.unwrap = () => $18._zod.def.getter();
});
function DV($18) {
  return new IV({ type: "lazy", getter: $18 });
}
var LV = O$("ZodPromise", ($18, q) => {
  Qj.init($18, q), T6.init($18, q), $18.unwrap = () => $18._zod.def.innerType;
});
function gd($18) {
  return new LV({ type: "promise", innerType: $18 });
}
var gV = O$("ZodFunction", ($18, q) => {
  aj.init($18, q), T6.init($18, q);
});
function bd($18) {
  return new gV({ type: "function", input: Array.isArray($18 == null ? void 0 : $18.input) ? zV($18 == null ? void 0 : $18.input) : ($18 == null ? void 0 : $18.input) ?? r5(g4()), output: ($18 == null ? void 0 : $18.output) ?? g4() });
}
var n5 = O$("ZodCustom", ($18, q) => {
  sj.init($18, q), T6.init($18, q);
});
function yd($18) {
  let q = new I6({ check: "custom" });
  return q._zod.check = $18, q;
}
function ud($18, q) {
  return Ev(n5, $18 ?? (() => true), q);
}
function bV($18, q = {}) {
  return hv(n5, $18, q);
}
function yV($18) {
  return Rv($18);
}
function xd($18, q = { error: `Input not instance of ${$18.name}` }) {
  let K = new n5({ type: "custom", check: "custom", fn: (P) => P instanceof $18, abort: true, ...l$.normalizeParams(q) });
  return K._zod.bag.Class = $18, K;
}
var pd = (...$18) => Iv({ Codec: YH, Boolean: p7, String: y7 }, ...$18);
function cd($18) {
  let q = DV(() => {
    return sW([LW($18), UG(), FG(), sG(), r5(q), WV(LW(), q)]);
  });
  return q;
}
function md($18, q) {
  return m5(KH($18), q);
}
var dd = { invalid_type: "invalid_type", too_big: "too_big", too_small: "too_small", invalid_format: "invalid_format", not_multiple_of: "not_multiple_of", unrecognized_keys: "unrecognized_keys", invalid_union: "invalid_union", invalid_key: "invalid_key", invalid_element: "invalid_element", invalid_value: "invalid_value", custom: "custom" };
function ld($18) {
  r6({ customError: $18 });
}
function rd() {
  return r6().customError;
}
var jH;
/* @__PURE__ */ (function($18) {
})(jH || (jH = {}));
var vH = {};
lq(vH, { string: () => od, number: () => nd, date: () => td, boolean: () => id, bigint: () => Bd });
function od($18) {
  return B3(y7, $18);
}
function nd($18) {
  return s3(x7, $18);
}
function id($18) {
  return Yv(p7, $18);
}
function Bd($18) {
  return vv(c7, $18);
}
function td($18) {
  return Xv(l5, $18);
}
r6(rP());
function d4() {
  if (typeof process < "u" && process.versions && process.versions.node) return "node";
  if (typeof globalThis < "u" && typeof globalThis.window < "u" && typeof globalThis.window.document < "u") return "browser";
  return "unknown";
}
var N0 = class {
  constructor() {
    __publicField(this, "store", {});
    if (typeof globalThis < "u" && globalThis.window && globalThis.window.ENV) this.store = { ...globalThis.window.ENV };
    if (typeof globalThis < "u" && globalThis.__ENV__) this.store = { ...this.store, ...globalThis.__ENV__ };
  }
  get($18) {
    let q = this.store[$18];
    return q !== void 0 ? String(q) : void 0;
  }
  set($18, q) {
    this.store[$18] = q;
  }
  has($18) {
    return $18 in this.store;
  }
  getAll() {
    return { ...this.store };
  }
};
var C0 = class {
  constructor() {
    __publicField(this, "runtime");
    __publicField(this, "browserStore");
    __publicField(this, "cache", /* @__PURE__ */ new Map());
    if (this.runtime = d4(), this.runtime === "browser") this.browserStore = new N0();
  }
  getRuntime() {
    return this.runtime;
  }
  isNode() {
    return this.runtime === "node";
  }
  isBrowser() {
    return this.runtime === "browser";
  }
  get($18, q) {
    if (this.cache.has($18)) {
      let P = this.cache.get($18);
      return P === void 0 && q !== void 0 ? q : P;
    }
    let K;
    switch (this.runtime) {
      case "node":
        if (typeof process < "u" && process.env) K = process.env[$18];
        break;
      case "browser":
        if (this.browserStore) K = this.browserStore.get($18);
        break;
      default:
        K = void 0;
    }
    return this.cache.set($18, K), K === void 0 && q !== void 0 ? q : K;
  }
  set($18, q) {
    let K = String(q);
    switch (this.cache.delete($18), this.runtime) {
      case "node":
        if (typeof process < "u" && process.env) process.env[$18] = K;
        break;
      case "browser":
        if (this.browserStore) this.browserStore.set($18, q);
        break;
    }
  }
  has($18) {
    return this.get($18) !== void 0;
  }
  getAll() {
    switch (this.runtime) {
      case "node":
        if (typeof process < "u" && process.env) return { ...process.env };
        break;
      case "browser":
        if (this.browserStore) return this.browserStore.getAll();
        break;
    }
    return {};
  }
  getBoolean($18, q = false) {
    let K = this.get($18);
    if (K === void 0) return q;
    return ["true", "1", "yes", "on"].includes(K.toLowerCase());
  }
  getNumber($18, q) {
    let K = this.get($18);
    if (K === void 0) return q;
    let P = Number(K);
    return isNaN(P) ? q : P;
  }
  clearCache() {
    this.cache.clear();
  }
};
var UH = null;
function l4() {
  if (!UH) UH = new C0();
  return UH;
}
function q_($18, q) {
  return l4().get($18, q);
}
function fP$($18, q) {
  l4().set($18, q);
}
function ZP$($18) {
  return l4().has($18);
}
function XP$($18, q = false) {
  return l4().getBoolean($18, q);
}
function E0($18, q) {
  return l4().getNumber($18, q);
}
function AP$($18) {
  let q = l4();
  if (q.isBrowser()) Object.entries($18).forEach(([K, P]) => {
    if (P !== void 0) q.set(K, P);
  });
}
var kP$ = d4();
function an($18, q = [".env", ".env.local"]) {
  if (typeof process > "u" || !process.cwd) return null;
  let K = () => ({}), P = (HH(), J6(WH)), _ = $18 || process.cwd();
  while (true) {
    for (let O of q) {
      let z = P.join(_, O);
      if (K.existsSync(z)) return z;
    }
    let Y = P.dirname(_);
    if (Y === _) break;
    _ = Y;
  }
  return null;
}
function GP$($18) {
  if (typeof process > "u" || !process.cwd) return false;
  try {
    let q = M0(), K = $18 || an();
    if (!K) return false;
    let P = q.config({ path: K });
    if (P.error) {
      if (typeof console < "u" && console.warn) console.warn(`Failed to parse .env file at ${K}:`, P.error);
      return false;
    }
    return true;
  } catch (q) {
    if (typeof console < "u" && console.warn) console.warn("Failed to load .env file:", q);
    return false;
  }
}
var vO = class {
  constructor($18) {
    __publicField(this, "globalStore");
    this.globalStore = $18;
  }
  clear() {
    console.clear();
  }
  filterByLabel($18) {
    h0($18, this.globalStore.cache).forEach((K) => {
      a7(K);
    });
  }
  filterByNamespace(...$18) {
    R0($18, this.globalStore.cache).forEach((K) => {
      a7(K);
    });
  }
  filterByLevel($18) {
    I0($18, this.globalStore.cache).forEach((K) => {
      a7(K);
    });
  }
  renderAll() {
    this.globalStore.cache.forEach(($18) => {
      a7($18);
    });
  }
};
var r4 = class {
  constructor($18 = {}) {
    __publicField(this, "config");
    __publicField(this, "pidCounter", 1);
    __publicField(this, "labels", /* @__PURE__ */ new Map());
    __publicField(this, "_listenerCounter", 0);
    __publicField(this, "_levelsToListeners", /* @__PURE__ */ new Map());
    __publicField(this, "_cache", []);
    this.config = $18;
  }
  get cache() {
    return this._cache;
  }
  get configuration() {
    return this.config;
  }
  get pid() {
    let $18 = this.pidCounter;
    return this.pidCounter++, $18;
  }
  get tools() {
    return new vO(this);
  }
  addLogToCache($18) {
    if (this._cache.length < (this.config.cacheSize ?? 300)) this._cache.push($18);
  }
  clearCache() {
    this._cache = [];
  }
  getLabel($18) {
    return this.labels.get($18);
  }
  setLabel($18, q) {
    this.labels.set($18, q);
  }
  addListener($18, q) {
    let K = this._listenerCounter += 1;
    return Q7({ ...z8.levels, ...this.config.levels ?? {} }, $18).forEach((_) => {
      if (this._levelsToListeners.has(_)) this._levelsToListeners.get(_).set(K, q);
      else this._levelsToListeners.set(_, /* @__PURE__ */ new Map([[K, q]]));
    }), K;
  }
  removeListener($18) {
    this._levelsToListeners.forEach((q) => {
      q.delete($18);
    });
  }
  getListeners($18) {
    var _a2;
    return Array.from(((_a2 = this._levelsToListeners.get($18)) == null ? void 0 : _a2.values()) ?? []);
  }
};
function FH($18) {
  return globalThis.$adzeGlobal = new r4($18), globalThis.$adzeGlobal;
}
function zO($18) {
  let q = globalThis.$adzeGlobal;
  if (Qn(q)) return q;
  let K = new r4($18);
  return globalThis.$adzeGlobal = K, K;
}
function Qn($18) {
  return $18 instanceof r4;
}
function CK() {
  return typeof window < "u" && typeof window.location < "u" && typeof window.navigator.userAgent < "u" && !en();
}
function en() {
  return typeof Deno < "u";
}
function D0($18) {
  return CK();
}
function L0() {
  let $18 = false;
  if (CK()) $18 = new URLSearchParams(globalThis.location.search).get("ADZE_ENV") === "test";
  return globalThis.$ADZE_ENV === "test" || $18;
}
function g0() {
  let $18 = globalThis;
  if (D0($18)) return $18.navigator.userAgent.includes("Firefox");
  return false;
}
function o4($18) {
  return Object.prototype.toString.call($18) === "[object String]";
}
function n4($18) {
  return $18 !== null && typeof $18 === "number" && !isNaN(Number($18));
}
function WO($18) {
  return eH.includes($18);
}
function b0($18) {
  return x0.includes($18);
}
function y0($18) {
  return QH.includes($18);
}
function aH($18) {
  return $18.every((q) => o4(q));
}
function u0($18) {
  return Array.isArray($18) && $18.length === 3 && $18[1] === "-";
}
function p0() {
  var _a2;
  return (_a2 = Error().stack) == null ? void 0 : _a2.replace(/^Error\n/, `
`);
}
function c0($18) {
  if (n4($18.activeLevel)) return $18.activeLevel;
  return $18.levels[$18.activeLevel].level;
}
var qJ = q8(d0(), 1);
var l0 = qJ.default ?? qJ;
function KJ($18) {
  return $18.charAt(0).toUpperCase() + $18.slice(1);
}
function _J($18) {
  return Object.values($18).map((q) => q.level);
}
function PJ($18, q, K) {
  return $18.filter((P) => P >= q && P <= K);
}
function OJ($18, q = false, K) {
  let _ = (q && K ? 9 + K.length : 9) - $18.length, Y = $18;
  for (let O = 0; O <= _; O += 1) Y += " ";
  return Y;
}
function YJ($18, q) {
  return q.reduce((K, P) => {
    return l0[P](K);
  }, $18);
}
function a7($18) {
  if ($18.data) console[$18.data.method](...$18.data.message);
}
function r0($18) {
  return $18.filter((q) => q !== "");
}
function o0($18) {
  return typeof $18 === "object" && $18 !== null;
}
function Q7($18, q) {
  if (q === "*") return Object.values($18).map((K) => K.level);
  if (o4(q)) return [$18[q].level];
  if (n4(q)) return [q];
  if (u0(q)) {
    if (aH(q)) {
      let K = $18[q[0]].level, P = $18[q[2]].level;
      return PJ(_J($18), K, P);
    }
    return PJ(_J($18), q[0], q[2]);
  }
  if (Array.isArray(q) && aH(q)) return q.map((K) => $18[K].level);
  return q;
}
function jJ($18, q, K) {
  if (q.length === 0) return false;
  return $18 === "include" ? !q.includes(K) : q.includes(K);
}
function vJ($18, q) {
  if ($18.length === 0) return false;
  if ($18.length > 0 && q.length === 0) return true;
  return !q.map((K) => $18.includes(K)).includes(true);
}
function zJ($18, q) {
  if ($18.length === 0) return false;
  if ($18.length > 0 && q.length === 0) return true;
  return q.map((K) => $18.includes(K)).includes(true);
}
function h0($18, q) {
  return q.filter((K) => {
    var _a2, _b2;
    return ((_b2 = (_a2 = K.data) == null ? void 0 : _a2.label) == null ? void 0 : _b2.name) === $18;
  });
}
function R0($18, q) {
  return q.filter((K) => {
    var _a2;
    if ((_a2 = K.data) == null ? void 0 : _a2.namespace) return K.data.namespace.map((_) => $18.includes(_)).includes(true);
    return false;
  });
}
function I0($18, q) {
  return q.filter((K) => {
    var _a2;
    let P = Q7(K.configuration.levels, $18);
    if (((_a2 = K.data) == null ? void 0 : _a2.level) === void 0) return false;
    return jJ("exclude", P, K.data.level);
  });
}
function WJ($18) {
  if ($18 && $18.length > 0) return $18.reduce((q, K) => `${q}#${K} `, "");
  return "";
}
function HJ($18) {
  return $18 ? `[${$18.name}] ` : "";
}
function JJ($18) {
  return $18 !== void 0 ? `(Count: ${$18}) ` : "";
}
function TJ($18, q) {
  return $18 !== void 0 && !$18 ? `${q ? " " : ""}Assertion failed:` : "";
}
function wJ($18, q) {
  return $18 !== void 0 && $18 ? `${q ? " " : ""}Expression passed:` : "";
}
var HO = -1;
var i4 = 0;
var B4 = 1;
var t4 = 2;
var e7 = 3;
var s7 = 4;
var $1 = 5;
var q1 = 6;
var JO = 7;
var TO = 8;
var n0 = typeof self === "object" ? self : globalThis;
var sn = ($18, q) => {
  let K = (_, Y) => {
    return $18.set(Y, _), _;
  }, P = (_) => {
    if ($18.has(_)) return $18.get(_);
    let [Y, O] = q[_];
    switch (Y) {
      case i4:
      case HO:
        return K(O, _);
      case B4: {
        let z = K([], _);
        for (let J of O) z.push(P(J));
        return z;
      }
      case t4: {
        let z = K({}, _);
        for (let [J, T] of O) z[P(J)] = P(T);
        return z;
      }
      case e7:
        return K(new Date(O), _);
      case s7: {
        let { source: z, flags: J } = O;
        return K(new RegExp(z, J), _);
      }
      case $1: {
        let z = K(/* @__PURE__ */ new Map(), _);
        for (let [J, T] of O) z.set(P(J), P(T));
        return z;
      }
      case q1: {
        let z = K(/* @__PURE__ */ new Set(), _);
        for (let J of O) z.add(P(J));
        return z;
      }
      case JO: {
        let { name: z, message: J } = O;
        return K(new n0[z](J), _);
      }
      case TO:
        return K(BigInt(O), _);
      case "BigInt":
        return K(Object(BigInt(O)), _);
    }
    return K(new n0[Y](O), _);
  };
  return P;
};
var fJ = ($18) => sn(/* @__PURE__ */ new Map(), $18)(0);
var U4 = "";
var { toString: $i } = {};
var { keys: qi } = Object;
var K1 = ($18) => {
  let q = typeof $18;
  if (q !== "object" || !$18) return [i4, q];
  let K = $i.call($18).slice(8, -1);
  switch (K) {
    case "Array":
      return [B4, U4];
    case "Object":
      return [t4, U4];
    case "Date":
      return [e7, U4];
    case "RegExp":
      return [s7, U4];
    case "Map":
      return [$1, U4];
    case "Set":
      return [q1, U4];
  }
  if (K.includes("Array")) return [B4, K];
  if (K.includes("Error")) return [JO, K];
  return [t4, K];
};
var wO = ([$18, q]) => $18 === i4 && (q === "function" || q === "symbol");
var Ki = ($18, q, K, P) => {
  let _ = (O, z) => {
    let J = P.push(O) - 1;
    return K.set(z, J), J;
  }, Y = (O) => {
    if (K.has(O)) return K.get(O);
    let [z, J] = K1(O);
    switch (z) {
      case i4: {
        let X = O;
        switch (J) {
          case "bigint":
            z = TO, X = O.toString();
            break;
          case "function":
          case "symbol":
            if ($18) throw TypeError("unable to serialize " + J);
            X = null;
            break;
          case "undefined":
            return _([HO], O);
        }
        return _([z, X], O);
      }
      case B4: {
        if (J) return _([J, [...O]], O);
        let X = [], f = _([z, X], O);
        for (let V of O) X.push(Y(V));
        return f;
      }
      case t4: {
        if (J) switch (J) {
          case "BigInt":
            return _([J, O.toString()], O);
          case "Boolean":
          case "Number":
          case "String":
            return _([J, O.valueOf()], O);
        }
        if (q && "toJSON" in O) return Y(O.toJSON());
        let X = [], f = _([z, X], O);
        for (let V of qi(O)) if ($18 || !wO(K1(O[V]))) X.push([Y(V), Y(O[V])]);
        return f;
      }
      case e7:
        return _([z, O.toISOString()], O);
      case s7: {
        let { source: X, flags: f } = O;
        return _([z, { source: X, flags: f }], O);
      }
      case $1: {
        let X = [], f = _([z, X], O);
        for (let [V, M] of O) if ($18 || !(wO(K1(V)) || wO(K1(M)))) X.push([Y(V), Y(M)]);
        return f;
      }
      case q1: {
        let X = [], f = _([z, X], O);
        for (let V of O) if ($18 || !wO(K1(V))) X.push(Y(V));
        return f;
      }
    }
    let { message: T } = O;
    return _([z, { name: J, message: T }], O);
  };
  return Y;
};
var ZJ = ($18, { json: q, lossy: K } = {}) => {
  let P = [];
  return Ki(!(q || K), !!q, /* @__PURE__ */ new Map(), P)($18), P;
};
var XJ = typeof structuredClone === "function" ? ($18, q) => q && ("json" in q || "lossy" in q) ? fJ(ZJ($18, q)) : structuredClone($18) : ($18, q) => fJ(ZJ($18, q));
function AJ($18, q, K, P) {
  let { formatters: _, middleware: Y = [], ...O } = q.exportValues();
  return class extends $18 {
    constructor() {
      super(...arguments);
      __publicField(this, "_cfg", new F4({ ...XJ(O), formatters: { ..._ }, middleware: [...Y] }));
      __publicField(this, "_modifierData", XJ(K));
      __publicField(this, "modifierQueue", [...P]);
    }
  };
}
function kJ([$18, q]) {
  return `${$18}s ${q / 1e6}ms`;
}
function i0() {
  return kJ(fO());
}
function fO($18) {
  let q = performance.now() * 1e-3, K = Math.floor(q), P = Math.floor(q % 1 * 1e9);
  if ($18 === void 0) return [K, P];
  let _ = K - $18[0], Y = P - $18[1];
  if (Y < 0) _ -= 1, Y += 1e9;
  return [_, Y];
}
function a4($18) {
  let q = (Y) => `${Math.floor(Math.abs(Y))}`.padStart(2, "0"), K = -$18.getTimezoneOffset(), _ = `${K >= 0 ? "+" : "-"}${q(K / 60)}:${q(K % 60)}`;
  return `${$18.getFullYear()}-${q($18.getMonth() + 1)}-${q($18.getDate())}T${q($18.getHours())}:${q($18.getMinutes())}:${q($18.getSeconds())}${_}`;
}
function B0($18) {
  let q = (h, E = 2) => String(h).padStart(E, "0"), K = q($18.getDate()), _ = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"][$18.getMonth()], Y = $18.getFullYear(), O = q($18.getHours()), z = q($18.getMinutes()), J = q($18.getSeconds()), T = -$18.getTimezoneOffset(), X = T >= 0 ? "+" : "-", f = Math.abs(T), V = q(Math.floor(f / 60)), M = q(f % 60), N = `${X}${V}${M}`;
  return `${K}/${_}/${Y}:${O}:${z}:${J} ${N}`;
}
var x8 = class {
  constructor($18, q) {
    __publicField(this, "cfg");
    __publicField(this, "level");
    __publicField(this, "timestampFormatFunction", ($18) => a4($18));
    this.cfg = $18, this.level = q;
  }
  get timestampFormatter() {
    return this.cfg.timestampFormatter ? this.cfg.timestampFormatter : this.timestampFormatFunction;
  }
  print($18, q, K) {
    if (this.level.level > c0(this.cfg)) return [];
    if (this.failsFilters($18)) return [];
    if ($18.assertion === true) return [];
    if ($18.if === false) return [];
    if ($18.method && !y0($18.method)) {
      if (b0($18.method) && WO($18.method)) return K;
    }
    let P = CK() ? this.formatBrowser($18, q, K) : this.formatServer($18, q, K);
    if ($18.stacktrace) P.push($18.stacktrace);
    return P;
  }
  failsFilters($18) {
    if (this.failsLevelSelector()) return true;
    if (this.failsNamespacesFilter($18)) return true;
    if (this.failsLabelsFilter($18)) return true;
    return false;
  }
  failsLevelSelector() {
    var _a2;
    if (((_a2 = this.cfg.filters) == null ? void 0 : _a2.levels) === void 0) return false;
    let $18 = Q7(this.cfg.levels, this.cfg.filters.levels.values);
    if (jJ(this.cfg.filters.levels.type, $18, this.level.level)) return true;
    return false;
  }
  failsNamespacesFilter($18) {
    var _a2;
    if (((_a2 = this.cfg.filters) == null ? void 0 : _a2.namespaces) === void 0) return false;
    if (this.cfg.filters.namespaces.values.length > 0 && $18.namespace === void 0) return true;
    if (this.cfg.filters.namespaces.type === "include") {
      let K = $18.namespace ?? [];
      return vJ(this.cfg.filters.namespaces.values, K);
    }
    let q = $18.namespace ?? [];
    return zJ(this.cfg.filters.namespaces.values, q);
  }
  failsLabelsFilter($18) {
    var _a2;
    if (((_a2 = this.cfg.filters) == null ? void 0 : _a2.labels) === void 0) return false;
    if (this.cfg.filters.labels.values.length > 0 && $18.label === void 0) return true;
    let q = $18.label ? [$18.label.name] : [];
    if (this.cfg.filters.labels.type === "include") return vJ(this.cfg.filters.labels.values, q);
    return zJ(this.cfg.filters.labels.values, q);
  }
};
var ZO = class extends x8 {
  constructor() {
    super(...arguments);
    __publicField(this, "timestampFormatFunction", ($18) => B0($18));
  }
  formatBrowser($18, q, K) {
    return this.formatMessage($18, q, K);
  }
  formatServer($18, q, K) {
    return this.formatMessage($18, q, K);
  }
  formatMessage($18, q, K) {
    if (this.cfg.meta.hostname === void 0) console.warn(Error("Adze: 'hostname' is required for the common log format. Please provide this value in your log's meta data."));
    let P = this.cfg.meta.hostname, _ = this.cfg.meta.ident ?? "-", Y = this.cfg.meta.user ?? "-", O = K[0];
    return [`${P} ${_} ${Y} [${q}] ${O}`];
  }
};
var t0 = ZO;
function U0($18) {
  return typeof $18.name === "string" && typeof $18.hostname === "string";
}
var XO = class extends x8 {
  constructor() {
    super(...arguments);
    __publicField(this, "timestampFormatFunction", ($18) => a4($18));
  }
  formatBrowser($18, q, K) {
    return this.formatMessage($18, q, K);
  }
  formatServer($18, q, K) {
    return this.formatMessage($18, q, K);
  }
  formatMessage($18, q, K) {
    let P = zO(), _ = [...K], Y = _.shift();
    if (U0(this.cfg.meta)) {
      let { src: O, err: z, req_id: J, req: T, res: X, latency: f, hostname: V, name: M, ...N } = this.cfg.meta, { namespace: h, label: E } = $18, I = { v: 1, level: this.level.level, levelName: this.level.levelName, name: M, hostname: V, msg: Y, args: _, pid: P.pid, time: q, meta: Object.keys(N).length > 0 ? N : void 0, namespace: h, label: E == null ? void 0 : E.name, src: O, err: z, req_id: J, req: T, res: X, latency: f };
      return [JSON.stringify(I)];
    }
    return console.warn(Error("Adze: Required fields are missing from the log meta for generating a JSON log.")), [..._];
  }
};
var F0 = XO;
var AO = class extends x8 {
  formatBrowser($18, q, K) {
    let P = this.formatLeader(), _ = this.formatMeta($18, q);
    if (this.cfg.withEmoji) return [P, "font-size: 12px;", this.level.style, _, ...K];
    return [P, this.level.style, _, ...K];
  }
  formatServer($18, q, K) {
    let P = [], Y = `${OJ(this.formatLeader(false), this.cfg.withEmoji, this.level.emoji)} `, O = this.formatMeta($18, q), z = YJ(Y, this.level.terminalStyle);
    return P.push(z), O !== "" && P.push(O), [z, O, ...K];
  }
  formatLeader($18 = true) {
    let q = $18 ? "%c" : "", K = " " + KJ(this.level.levelName);
    if (this.cfg.withEmoji) return `${q}${this.formatEmoji($18)}${q}${K}`;
    return `${q}${K}`;
  }
  formatEmoji($18) {
    let q = $18 ? " " : "";
    return this.level.emoji ? `${this.level.emoji}${q}` : "";
  }
  formatMeta($18, q) {
    var _a2;
    let K = this.cfg.showTimestamp ? `${q} ` : "", P = WJ($18.namespace), _ = HJ($18.label), Y = this.formatTime($18), O = JJ((_a2 = $18.label) == null ? void 0 : _a2.count), z = TJ($18.assertion, this.cfg.withEmoji), J = wJ($18.if, this.cfg.withEmoji), T = z !== "" ? z : J !== "" ? J : "";
    return K + P + _ + Y + O + T;
  }
  formatTime($18) {
    var _a2;
    let q = this.cfg.withEmoji ? " " : "Time elapsed: ";
    if ($18.timeNow) return `(${q}${$18.timeNow})`;
    return ((_a2 = $18.label) == null ? void 0 : _a2.timeElapsed) ? `(${q}${$18.label.timeElapsed})` : "";
  }
};
var GJ = AO;
var _1 = class extends x8 {
  constructor() {
    super(...arguments);
    __publicField(this, "timestampFormatFunction", ($18) => a4($18));
  }
  formatBrowser($18, q, K) {
    return this.formatMessage(q, $18, K);
  }
  formatServer($18, q, K) {
    return this.formatMessage(q, $18, K);
  }
  formatMessage($18, q, K) {
    let P = "", { appname: _, hostname: Y, port: O } = this.cfg.meta, z = n4(O) ? `/${O}` : "", J = o4(_) ? `${_}${z}` : "", T = o4(Y) ? ` on ${Y}: ` : "", X = this.formatNamespace(q.namespace), f = q.label ? `[${q.label.name}] ` : "";
    return P = `${J}${T}${X}${f}`, [`[${$18}] ${this.level.levelName.toUpperCase()}: ${P}${K[0]} `, K.map((V) => o0(V) ? JSON.stringify(V) : V).slice(1).join(" ")];
  }
  formatNamespace($18) {
    if ($18 && $18.length > 0) return `${$18.reduce((K, P, _) => {
      return _ === $18.length - 1 ? `${K}${P}` : `${K}${P}/`;
    }, "")} `;
    return "";
  }
};
var QH = ["group", "groupCollapsed"];
var a0 = ["dir", "dirxml", "table", ...QH];
var eH = ["error", "warn", "info", "log", "debug", ...a0];
var sH = ["clear", "groupEnd"];
var x0 = [...a0, ...sH];
var n7$ = [...eH, ...sH];
var z8 = { activeLevel: "log", cache: false, cacheSize: 300, dump: false, format: "pretty", meta: {}, middleware: [], showTimestamp: false, silent: false, withEmoji: false, levels: { alert: _i(), error: Pi(), warn: Oi(), info: Yi(), fail: ji(), success: vi(), log: zi(), debug: Wi(), verbose: Hi() }, formatters: { default: GJ, pretty: GJ, standard: _1, common: t0, json: F0 } };
function _i($18 = {}) {
  return { levelName: "alert", level: 0, style: "padding-right: 24px; font-size: 12px; border-radius: 4px; background: linear-gradient(to right, #fc8585, #fc2323); color: #fff; border-color: #b70101;", terminalStyle: ["white", "bold", "bgRed"], method: "error", emoji: "", ...$18 };
}
function Pi($18 = {}) {
  return { levelName: "error", level: 1, style: "padding-right: 24px; font-size: 12px; border-radius: 4px; background: linear-gradient(to right, #fff, #ffd1d1); color: #a4000f; border-color: #e3bbbb;", terminalStyle: ["white", "bgRed"], method: "error", emoji: "", ...$18 };
}
function Oi($18 = {}) {
  return { levelName: "warn", level: 2, style: `font-size: 12px; border-radius: 4px;  background: linear-gradient(to right, #fff, #fff0a8); color: #715100; border-color: #e3d696; padding-right: ${g0() ? "44px" : "30px"};`, terminalStyle: ["white", "bgYellow"], method: "warn", emoji: "", ...$18 };
}
function Yi($18 = {}) {
  return { levelName: "info", level: 3, style: "padding-right: 44px; font-size: 12px; border-radius: 4px; background: linear-gradient(to right, #d8ebff, #b2d7ff); color: #465464; border-color: #96b5d7;", terminalStyle: ["white", "bgBlue"], method: "info", emoji: "", ...$18 };
}
function ji($18 = {}) {
  return { levelName: "fail", level: 4, style: "padding-right: 44px; font-size: 12px; border-radius: 4px; background: linear-gradient(to right, #ffe8e8, #ffd1d1); color: #a4000f; border-color: #e3bbbb;", terminalStyle: ["white", "bgRed"], method: "info", emoji: "", ...$18 };
}
function vi($18 = {}) {
  return { levelName: "success", level: 5, style: "font-size: 12px; border-radius: 4px; padding-right: 22px; background: linear-gradient(to right, #e6f6e4, #ceedc9); color: #4e594d; border-color: #b7d1b3;", terminalStyle: ["white", "bgGreen"], method: "info", emoji: "", ...$18 };
}
function zi($18 = {}) {
  return { levelName: "log", level: 6, style: "font-size: 12px; border-radius: 4px; padding-right: 51px; background: linear-gradient(to right, #ecedef, #d9dce0); color: #333435; border-color: #bfc1c5;", terminalStyle: ["white", "bgBlackBright"], method: "log", emoji: "", ...$18 };
}
function Wi($18 = {}) {
  return { levelName: "debug", level: 7, style: "font-size: 12px; padding-right: 36px; border-right: 1px solid #d9dce0; color: #465464; border-color: #999999;", terminalStyle: ["white", "bgBlack"], method: "debug", emoji: "", ...$18 };
}
function Hi($18 = {}) {
  return { levelName: "verbose", level: 8, style: "font-size: 12px; padding-right: 22px; color: #999999;", terminalStyle: ["black", "italic"], method: "debug", emoji: "", ...$18 };
}
var F4 = class {
  constructor($18) {
    __publicField(this, "logCfg");
    __publicField(this, "glblCfg");
    var _a2;
    this.logCfg = $18 ?? {}, this.glblCfg = (_a2 = globalThis.$adzeGlobal) == null ? void 0 : _a2.configuration;
  }
  updateConfiguration($18) {
    this.logCfg = $18;
  }
  get activeLevel() {
    var _a2;
    return ((_a2 = this.glblCfg) == null ? void 0 : _a2.activeLevel) ?? this.logCfg.activeLevel ?? z8.activeLevel;
  }
  set activeLevel($18) {
    this.logCfg.activeLevel = $18;
  }
  get cache() {
    var _a2;
    return ((_a2 = this.glblCfg) == null ? void 0 : _a2.cache) ?? this.logCfg.cache ?? z8.cache;
  }
  set cache($18) {
    this.logCfg.cache = $18;
  }
  get cacheSize() {
    var _a2;
    return ((_a2 = this.glblCfg) == null ? void 0 : _a2.cacheSize) ?? this.logCfg.cacheSize ?? z8.cacheSize;
  }
  set cacheSize($18) {
    this.logCfg.cacheSize = $18;
  }
  get dump() {
    var _a2;
    return ((_a2 = this.glblCfg) == null ? void 0 : _a2.dump) ?? this.logCfg.dump ?? z8.dump;
  }
  set dump($18) {
    this.logCfg.dump = $18;
  }
  get meta() {
    var _a2;
    return { ...this.logCfg.meta, ...(_a2 = this.glblCfg) == null ? void 0 : _a2.meta };
  }
  set meta($18) {
    this.logCfg.meta = $18;
  }
  get silent() {
    var _a2;
    return ((_a2 = this.glblCfg) == null ? void 0 : _a2.silent) ?? this.logCfg.silent ?? z8.silent;
  }
  set silent($18) {
    this.logCfg.silent = $18;
  }
  get showTimestamp() {
    var _a2;
    return ((_a2 = this.glblCfg) == null ? void 0 : _a2.showTimestamp) ?? this.logCfg.showTimestamp ?? z8.showTimestamp;
  }
  set showTimestamp($18) {
    this.logCfg.showTimestamp = $18;
  }
  get withEmoji() {
    var _a2;
    return ((_a2 = this.glblCfg) == null ? void 0 : _a2.withEmoji) ?? this.logCfg.withEmoji ?? z8.withEmoji;
  }
  set withEmoji($18) {
    this.logCfg.withEmoji = $18;
  }
  get format() {
    var _a2;
    return ((_a2 = this.glblCfg) == null ? void 0 : _a2.format) ?? this.logCfg.format ?? z8.format;
  }
  set format($18) {
    this.logCfg.format = $18;
  }
  get levels() {
    var _a2;
    return { ...z8.levels, ...this.logCfg.levels ?? {}, ...((_a2 = this.glblCfg) == null ? void 0 : _a2.levels) ?? {} };
  }
  set levels($18) {
    this.logCfg.levels = $18;
  }
  get middleware() {
    var _a2;
    return [...((_a2 = this.glblCfg) == null ? void 0 : _a2.middleware) ?? [], ...this.logCfg.middleware ?? []];
  }
  set middleware($18) {
    this.logCfg.middleware = $18;
  }
  get filters() {
    var _a2;
    return ((_a2 = this.glblCfg) == null ? void 0 : _a2.filters) ?? this.logCfg.filters;
  }
  set filters($18) {
    this.logCfg.filters = $18;
  }
  get timestampFormatter() {
    var _a2;
    return ((_a2 = this.glblCfg) == null ? void 0 : _a2.timestampFormatter) ?? this.logCfg.timestampFormatter;
  }
  set timestampFormatter($18) {
    this.logCfg.timestampFormatter = $18;
  }
  get formatters() {
    var _a2;
    return { ...z8.formatters, ...this.logCfg.formatters ?? {}, ...((_a2 = this.glblCfg) == null ? void 0 : _a2.formatters) ?? {} };
  }
  set formatters($18) {
    this.logCfg.formatters = $18;
  }
  exportValues() {
    return { activeLevel: this.logCfg.activeLevel, cache: this.logCfg.cache, cacheSize: this.logCfg.cacheSize, dump: this.logCfg.dump, meta: this.logCfg.meta, silent: this.logCfg.silent, showTimestamp: this.logCfg.showTimestamp, withEmoji: this.logCfg.withEmoji, format: this.logCfg.format, levels: this.logCfg.levels, middleware: this.logCfg.middleware, filters: this.logCfg.filters, timestampFormatter: this.logCfg.timestampFormatter, formatters: this.logCfg.formatters };
  }
};
function Ji($18) {
  return typeof $18 === "function";
}
var Q4 = class _Q4 {
  constructor($18, q) {
    __publicField(this, "globalStore");
    __publicField(this, "_cfg");
    __publicField(this, "_modifierData");
    __publicField(this, "_data");
    __publicField(this, "modifierQueue", []);
    this.globalStore = zO($18), this._modifierData = q ?? {}, this._cfg = new F4($18), this.doHook((K) => {
      if (K.constructed) K.constructed(this);
    });
  }
  get data() {
    return this._data;
  }
  get modifierData() {
    return this._modifierData;
  }
  get configuration() {
    return this._cfg;
  }
  alert(...$18) {
    this.terminate("alert", $18);
  }
  static alert(...$18) {
    new this().alert(...$18);
  }
  error(...$18) {
    this.terminate("error", $18);
  }
  static error(...$18) {
    new this().error(...$18);
  }
  warn(...$18) {
    this.terminate("warn", $18);
  }
  static warn(...$18) {
    new this().warn(...$18);
  }
  info(...$18) {
    this.terminate("info", $18);
  }
  static info(...$18) {
    new this().info(...$18);
  }
  fail(...$18) {
    this.terminate("fail", $18);
  }
  static fail(...$18) {
    new this().fail(...$18);
  }
  success(...$18) {
    this.terminate("success", $18);
  }
  static success(...$18) {
    new this().success(...$18);
  }
  log(...$18) {
    this.terminate("log", $18);
  }
  static log($18, ...q) {
    new this().log(...[$18, ...q]);
  }
  debug(...$18) {
    this.terminate("debug", $18);
  }
  static debug(...$18) {
    new this().debug(...$18);
  }
  verbose(...$18) {
    this.terminate("verbose", $18);
  }
  static verbose(...$18) {
    new this().verbose(...$18);
  }
  clear() {
    console.clear();
  }
  static clear() {
    console.clear();
  }
  clr() {
    console.clear();
  }
  static clr() {
    console.clear();
  }
  custom($18, ...q) {
    if (!this._cfg.levels[$18]) return console.warn(Error("Custom log level not found in configuration.")), this;
    return this.terminate($18, q), this;
  }
  static custom($18, ...q) {
    return new this().custom($18, ...q);
  }
  seal($18) {
    if ($18) this._cfg.updateConfiguration($18);
    return AJ(_Q4, this._cfg, this.modifierData, this.modifierQueue);
  }
  static seal($18) {
    return new this().seal($18);
  }
  sealTag($18, q) {
    return this._cfg = new F4({ ...this._cfg.exportValues(), ...q }), (K, ...P) => {
      let _ = String.raw({ raw: K }, ...P), Y = AJ(_Q4, this._cfg, this.modifierData, this.modifierQueue), O = $18;
      if (Ji(Y[O])) Y[O](_);
    };
  }
  static sealTag($18, q) {
    return new this().sealTag($18, q);
  }
  thread($18, q) {
    if (this.runModifierQueue(), this._modifierData.label) {
      if (!this._modifierData.label.context) this._modifierData.label.context = {};
      this._modifierData.label.context = { ...this._modifierData.label.context, [$18]: q };
    }
  }
  static thread($18, q) {
    new this().thread($18, q);
  }
  assert($18) {
    return this.modifierQueue.push(["assert", (q) => {
      return q.assertion = $18, q;
    }]), this;
  }
  static assert($18) {
    return new this().assert($18);
  }
  get closeThread() {
    return this.modifierQueue.push(["closeThread", ($18) => {
      var _a2;
      if ((_a2 = $18.label) == null ? void 0 : _a2.context) $18.label.context = void 0;
      return $18;
    }]), this;
  }
  static get closeThread() {
    return new this().closeThread;
  }
  get count() {
    return this.modifierQueue.push(["count", ($18) => {
      if ($18.label) $18.label.count = $18.label.count !== void 0 ? $18.label.count + 1 : 1;
      return $18;
    }]), this;
  }
  static get count() {
    return new this().count;
  }
  get countClear() {
    return this.modifierQueue.push(["countClear", ($18) => {
      if ($18.label) delete $18.label.count;
      return $18;
    }]), this;
  }
  static get countClear() {
    return new this().countClear;
  }
  get countReset() {
    return this.modifierQueue.push(["countReset", ($18) => {
      if ($18.label) $18.label.count = 0;
      return $18;
    }]), this;
  }
  static get countReset() {
    return new this().countReset;
  }
  get dir() {
    return this.modifierQueue.push(["dir", ($18) => {
      return $18.method = "dir", $18;
    }]), this;
  }
  static get dir() {
    return new this().dir;
  }
  get dirxml() {
    return this.modifierQueue.push(["dirxml", ($18) => {
      return $18.method = "dirxml", $18;
    }]), this;
  }
  static get dirxml() {
    return new this().dirxml;
  }
  get dump() {
    return this.modifierQueue.push(["dump", ($18, q) => {
      return q._cfg.dump = true, $18;
    }]), this;
  }
  static get dump() {
    return new this().dump;
  }
  format($18) {
    return this.modifierQueue.push(["format", (q, K) => {
      if (Object.keys(K._cfg.formatters).includes($18)) return K._cfg.format = $18, q;
      return console.warn(Error(`Adze: Formatter "${$18}" not found in configuration.`)), q;
    }]), this;
  }
  static format($18) {
    return new this().format($18);
  }
  get group() {
    return this.modifierQueue.push(["group", ($18) => {
      return $18.method = "group", $18;
    }]), this;
  }
  static get group() {
    return new this().group;
  }
  get groupCollapsed() {
    return this.modifierQueue.push(["groupCollapsed", ($18) => {
      return $18.method = "groupCollapsed", $18;
    }]), this;
  }
  static get groupCollapsed() {
    return new this().groupCollapsed;
  }
  get groupEnd() {
    return this.modifierQueue.push(["groupEnd", ($18) => {
      return $18.method = "groupEnd", $18;
    }]), this;
  }
  static get groupEnd() {
    return new this().groupEnd;
  }
  if($18) {
    return this.modifierQueue.push(["if", (q) => {
      return q.if = $18, q;
    }]), this;
  }
  static if($18) {
    return new this().if($18);
  }
  test($18) {
    return this.if($18);
  }
  static test($18) {
    return new this().if($18);
  }
  label($18) {
    return this.modifierQueue.unshift(["label", (q) => {
      let K = this.globalStore.getLabel($18) ?? { name: $18 };
      return q.label = K, this.globalStore.setLabel($18, K), q;
    }]), this;
  }
  static label($18) {
    return new this().label($18);
  }
  meta($18) {
    return this.modifierQueue.push(["meta", (q, K) => {
      return K._cfg.meta = { ...K._cfg.meta, ...$18 }, q;
    }]), this;
  }
  static meta($18) {
    return new this().meta($18);
  }
  namespace(...$18) {
    return this.modifierQueue.push(["namespace", (q) => {
      let K = q.namespace ?? [];
      return q.namespace = K.length > 0 ? [...K, ...$18] : $18, q;
    }]), this;
  }
  static namespace(...$18) {
    return new this().namespace(...$18);
  }
  ns(...$18) {
    return this.namespace(...$18);
  }
  static ns(...$18) {
    return new this().namespace(...$18);
  }
  get silent() {
    return this.modifierQueue.push(["silent", ($18, q) => {
      return q._cfg.silent = true, $18;
    }]), this;
  }
  static get silent() {
    return new this().silent;
  }
  get table() {
    return this.modifierQueue.push(["table", ($18) => {
      return $18.method = "table", $18;
    }]), this;
  }
  static get table() {
    return new this().table;
  }
  get time() {
    return this.modifierQueue.push(["time", ($18) => {
      let q = fO();
      if ($18.label) $18.label.timeStart = q;
      return $18;
    }]), this;
  }
  static get time() {
    return new this().time;
  }
  get timeEnd() {
    return this.modifierQueue.push(["timeEnd", ($18) => {
      var _a2;
      if ((_a2 = $18.label) == null ? void 0 : _a2.timeStart) $18.label.timeElapsed = kJ(fO($18.label.timeStart));
      return $18;
    }]), this;
  }
  static get timeEnd() {
    return new this().timeEnd;
  }
  get timeNow() {
    return this.modifierQueue.push(["timeNow", ($18) => {
      return $18.timeNow = i0(), $18;
    }]), this;
  }
  static get timeNow() {
    return new this().timeNow;
  }
  get timestamp() {
    return this.modifierQueue.push(["timestamp", ($18, q) => {
      return q._cfg.showTimestamp = true, $18;
    }]), this;
  }
  static get timestamp() {
    return new this().timestamp;
  }
  get trace() {
    return this.modifierQueue.push(["trace", ($18) => {
      return $18.stacktrace = p0(), $18;
    }]), this;
  }
  static get trace() {
    return new this().trace;
  }
  get withEmoji() {
    return this.modifierQueue.push(["withEmoji", ($18, q) => {
      return q._cfg.withEmoji = true, $18;
    }]), this;
  }
  static get withEmoji() {
    return new this().withEmoji;
  }
  print($18) {
    if (L0()) return;
    if ($18.silent) return;
    if ($18.message.length < 1) return;
    if (WO($18.method)) console[$18.method](...$18.message);
    else console[$18.method]();
  }
  terminate($18, q) {
    var _a2;
    this.doHook((I) => {
      if (I.beforeTerminated) I.beforeTerminated(this, $18, q);
    }), this.runModifierQueue();
    let K = this.getLevelConfig($18), _ = new (this.selectFormatter(this._cfg.format))(this._cfg, K), Y = _.timestampFormatter(/* @__PURE__ */ new Date()), O = r0(_.print(this.modifierData, Y, q));
    if (this._cfg.dump && ((_a2 = this.modifierData.label) == null ? void 0 : _a2.context)) O.push(this.modifierData.label.context);
    this.doHook((I) => {
      if (I.beforeFormatApplied) O = I.beforeFormatApplied(this, this._cfg.format, O);
    });
    let { activeLevel: z, cache: J, cacheSize: T, dump: X, format: f, meta: V, showTimestamp: M, silent: N, withEmoji: h } = this._cfg, E = { activeLevel: z, cache: J, cacheSize: T, dump: X, format: f, meta: V, showTimestamp: M, silent: N, withEmoji: h, ...K, ...this._modifierData, terminator: $18, args: q, timestamp: Y, message: O };
    if (this.doHook((I) => {
      if (I.afterFormatApplied) I.afterFormatApplied(this, this._cfg.format, O);
    }), this._data = E, this._cfg.cache) this.globalStore.addLogToCache(this);
    this.doHook((I) => {
      if (I.beforePrint) I.beforePrint(this);
    }), this.print(this._data), this.doHook((I) => {
      if (I.afterTerminated) I.afterTerminated(this, $18, q);
    }), this.globalStore.getListeners(K.level).forEach((I) => {
      I(this);
    });
  }
  selectFormatter($18) {
    return this._cfg.formatters[$18];
  }
  getLevelConfig($18) {
    return this._cfg.levels[$18];
  }
  runModifierQueue() {
    this.modifierQueue.forEach(([$18, q]) => {
      let K = q(this.modifierData, this);
      this.doHook((P) => {
        if (P.beforeModifierApplied) P.beforeModifierApplied(this, $18, K);
      }), this._modifierData = K, this.doHook((P) => {
        if (P.afterModifierApplied) P.afterModifierApplied(this, $18, K);
      });
    });
  }
  doHook($18) {
    var _a2;
    (_a2 = this._cfg.middleware) == null ? void 0 : _a2.forEach((q) => {
      $18(q);
    });
  }
};
var wi = ["black", "red", "green", "yellow", "blue", "magenta", "cyan", "white", "gray", "blackBright", "redBright", "greenBright", "yellowBright", "blueBright", "magentaBright", "cyanBright", "whiteBright", "bgBlack", "bgRed", "bgGreen", "bgYellow", "bgBlue", "bgMagenta", "bgCyan", "bgWhite", "bgBlackBright", "bgRedBright", "bgGreenBright", "bgYellowBright", "bgBlueBright", "bgMagentaBright", "bgCyanBright", "bgWhiteBright", "reset", "bold", "dim", "italic", "underline", "inverse", "hidden", "strikethrough"];
var Q0 = Object.freeze(wi);
var e0 = Q4;
var X1$ = { __noop: () => {
} };
var kO = { trace: 10, verbose: 10, debug: 20, success: 27, progress: 28, log: 29, info: 30, warn: 40, error: 50, fatal: 60, alert: 60 };
var fi = { 10: "trace", 20: "debug", 27: "success", 28: "progress", 29: "log", 30: "info", 40: "warn", 50: "error", 60: "fatal" };
function s0($18, q) {
  let K = kO[$18.toLowerCase()] || 30, P = kO[q.toLowerCase()] || 30;
  return K >= P;
}
function VJ($18) {
  try {
    let q = /* @__PURE__ */ new WeakSet();
    return JSON.stringify($18, (K, P) => {
      if (typeof P === "object" && P !== null) {
        if (q.has(P)) return "[Circular]";
        q.add(P);
      }
      return P;
    });
  } catch {
    return String($18);
  }
}
function $M($18) {
  if (!$18) return false;
  let q = $18.toLowerCase().trim();
  return q === "true" || q === "1" || q === "yes" || q === "on";
}
var Zi = "info";
var GO = q_("LOG_LEVEL") || Zi;
var G1$ = { fatal: 60, error: 50, warn: 40, info: 30, log: 29, progress: 28, success: 27, debug: 20, trace: 10 };
var SJ = $M(q_("LOG_JSON_FORMAT"));
var MJ = $M(q_("LOG_TIMESTAMPS") ?? "true");
function Xi($18 = 100) {
  let q = [];
  return { write(K) {
    if (q.push(K), q.length > $18) q.shift();
  }, clear() {
    q.length = 0;
  }, recentLogs() {
    return q.map((K) => {
      let P = MJ ? new Date(K.time).toISOString() : "", _ = fi[K.level ?? 30] || "info";
      return `${P} ${_} ${K.msg}`.trim();
    }).join(`
`);
  } };
}
var P1 = Xi();
var qM = () => {
  let $18 = GO.toLowerCase();
  if ($18 === "trace") return "verbose";
  if ($18 === "debug") return "debug";
  if ($18 === "log") return "log";
  if ($18 === "info") return "info";
  if ($18 === "warn") return "warn";
  if ($18 === "error") return "error";
  if ($18 === "fatal") return "alert";
  return "info";
};
var Ai = qM();
var KM = { alert: { levelName: "alert", level: 0, style: "font-size: 12px; color: #ff0000;", terminalStyle: ["bgRed", "white", "bold"], method: "error", emoji: "" }, error: { levelName: "error", level: 1, style: "font-size: 12px; color: #ff0000;", terminalStyle: ["bgRed", "whiteBright", "bold"], method: "error", emoji: "" }, warn: { levelName: "warn", level: 2, style: "font-size: 12px; color: #ffaa00;", terminalStyle: ["bgYellow", "black", "bold"], method: "warn", emoji: "" }, info: { levelName: "info", level: 3, style: "font-size: 12px; color: #0099ff;", terminalStyle: ["cyan"], method: "info", emoji: "" }, fail: { levelName: "fail", level: 4, style: "font-size: 12px; color: #ff6600;", terminalStyle: ["red", "underline"], method: "error", emoji: "" }, success: { levelName: "success", level: 5, style: "font-size: 12px; color: #00cc00;", terminalStyle: ["green"], method: "log", emoji: "" }, log: { levelName: "log", level: 6, style: "font-size: 12px; color: #888888;", terminalStyle: ["white"], method: "log", emoji: "" }, debug: { levelName: "debug", level: 7, style: "font-size: 12px; color: #9b59b6;", terminalStyle: ["gray", "dim"], method: "debug", emoji: "" }, verbose: { levelName: "verbose", level: 8, style: "font-size: 12px; color: #666666;", terminalStyle: ["gray", "dim", "italic"], method: "debug", emoji: "" } };
var ki = FH({ activeLevel: Ai, format: SJ ? "json" : "pretty", timestampFormatter: MJ ? void 0 : () => "", withEmoji: false, levels: KM });
ki.addListener("*", ($18) => {
  try {
    let q = $18.data, K = Array.isArray(q == null ? void 0 : q.message) ? q.message.map((_) => typeof _ === "string" ? _ : VJ(_)).join(" ") : typeof (q == null ? void 0 : q.message) === "string" ? q.message : "", P = { time: Date.now(), level: typeof (q == null ? void 0 : q.level) === "number" ? q.level : void 0, msg: K };
    P1.write(P);
  } catch {
  }
});
function Gi($18) {
  let q = e0, K = [];
  if (typeof $18.namespace === "string") K.push($18.namespace);
  if (Array.isArray($18.namespaces)) K.push(...$18.namespaces);
  if (K.length > 0) q = q.ns(...K);
  let P = { ...$18 };
  if (delete P.namespace, delete P.namespaces, SJ) {
    if (!P.name) P.name = "elizaos";
    if (!P.hostname) {
      let Y = "unknown";
      if (typeof process < "u" && process.platform) try {
        Y = (TH(), J6(JH)).hostname();
      } catch {
        Y = "localhost";
      }
      else if (typeof window < "u" && window.location) Y = window.location.hostname || "browser";
      P.hostname = Y;
    }
  }
  let _ = { activeLevel: qM(), format: SJ ? "json" : "pretty", timestampFormatter: MJ ? void 0 : () => "", withEmoji: false, levels: KM };
  return q.meta(P).seal(_);
}
function Vi($18) {
  let q = GO, K = {}, P;
  if (typeof $18 === "object" && $18 !== null) {
    if ("level" in $18) q = $18.level;
    if ("maxMemoryLogs" in $18 && typeof $18.maxMemoryLogs === "number") P = $18.maxMemoryLogs;
    let { level: _, maxMemoryLogs: Y, ...O } = $18;
    K = O;
  }
  return { level: q, base: K, maxMemoryLogs: P };
}
function O1($18 = false) {
  let { level: q, base: K, maxMemoryLogs: P } = Vi($18);
  if (typeof P === "number" && P > 0) P1.clear();
  if (typeof $18 === "object" && $18 && "__forceType" in $18 && $18.__forceType === "browser") {
    let n = (typeof q === "number" ? "info" : q || GO).toLowerCase(), s = (...U) => {
      return U.map((j) => {
        if (typeof j === "string") return j;
        if (j instanceof Error) return j.message;
        return VJ(j);
      }).join(" ");
    }, q$ = (U, ...j) => {
      if (!s0(U, n)) return;
      let H = s(...j), Z = U === "fatal" ? "error" : U === "trace" || U === "verbose" ? "debug" : U === "success" || U === "progress" ? "info" : U === "log" ? "log" : console[U] ? U : "log";
      if (typeof console[Z] === "function") console[Z](H);
    }, c = (U, j, ...H) => {
      if (typeof U === "string") return j !== void 0 ? [U, j, ...H] : [U, ...H];
      if (U instanceof Error) return j !== void 0 ? [U.message, j, ...H] : [U.message, ...H];
      if (j !== void 0) return [j, U, ...H];
      return [U, ...H];
    };
    return { level: n, trace: (U, j, ...H) => q$("trace", ...c(U, j, ...H)), debug: (U, j, ...H) => q$("debug", ...c(U, j, ...H)), info: (U, j, ...H) => q$("info", ...c(U, j, ...H)), warn: (U, j, ...H) => q$("warn", ...c(U, j, ...H)), error: (U, j, ...H) => q$("error", ...c(U, j, ...H)), fatal: (U, j, ...H) => q$("fatal", ...c(U, j, ...H)), success: (U, j, ...H) => q$("success", ...c(U, j, ...H)), progress: (U, j, ...H) => q$("progress", ...c(U, j, ...H)), log: (U, j, ...H) => q$("log", ...c(U, j, ...H)), clear: () => {
      if (typeof console.clear === "function") console.clear();
    }, child: (U) => O1({ level: n, ...K, ...U, __forceType: "browser" }) };
  }
  let Y = Gi(K), z = (typeof q === "number" ? "info" : q || GO).toLowerCase(), J = (p, n) => {
  }, T = (p, ...n) => {
    if (!s0(p, z)) return;
    J(p, n);
    try {
      let c = "";
      if (n.length > 0) c = n.map((j) => {
        if (typeof j === "string") return j;
        if (j instanceof Error) return j.message;
        return VJ(j);
      }).join(" ");
      if (K.namespace) c = `#${K.namespace}  ${c}`;
      let U = { time: Date.now(), level: kO[p.toLowerCase()] || kO.info, msg: c };
      P1.write(U);
    } catch {
    }
    let s = p, q$ = n;
    if (p === "fatal") s = "alert";
    else if (p === "progress") s = "info", q$ = ["[PROGRESS]", ...n];
    else if (p === "success") s = "info", q$ = ["[SUCCESS]", ...n];
    else if (p === "trace") s = "verbose";
    try {
      Y[s](...q$);
    } catch (c) {
      console.log(`[${p.toUpperCase()}]`, ...n);
    }
  }, X = (p, n, ...s) => {
    if (typeof p === "string") return n !== void 0 ? [p, n, ...s] : [p, ...s];
    if (p instanceof Error) return n !== void 0 ? [p.message, { error: p }, n, ...s] : [p.message, { error: p }, ...s];
    if (n !== void 0) return [n, p, ...s];
    return [p, ...s];
  };
  return { level: z, trace: (p, n, ...s) => T("verbose", ...X(p, n, ...s)), debug: (p, n, ...s) => T("debug", ...X(p, n, ...s)), info: (p, n, ...s) => T("info", ...X(p, n, ...s)), warn: (p, n, ...s) => T("warn", ...X(p, n, ...s)), error: (p, n, ...s) => T("error", ...X(p, n, ...s)), fatal: (p, n, ...s) => T("fatal", ...X(p, n, ...s)), success: (p, n, ...s) => T("success", ...X(p, n, ...s)), progress: (p, n, ...s) => T("progress", ...X(p, n, ...s)), log: (p, n, ...s) => T("log", ...X(p, n, ...s)), clear: () => {
    try {
      if (typeof (console == null ? void 0 : console.clear) === "function") console.clear();
    } catch {
    }
    P1.clear();
  }, child: (p) => {
    return O1({ level: z, ...K, ...p });
  } };
}
var j6 = O1();
var V1$ = j6;
var S1$ = () => P1.recentLogs();
var $K = j6;
function PM($18) {
  return $18.replace(new RegExp("(?<!{){{(?![{#\\/!>])([\\s\\S]*?)}}", "g"), (q, K) => {
    if (K.trim() === "else") return `{{${K}}}`;
    return `{{{${K}}}}`;
  });
}
var OM = ({ state: $18, template: q }) => {
  let K = typeof q === "function" ? q({ state: $18 }) : q, P = NJ.default.compile(PM(K));
  return YM(P($18), 10);
};
var Y1 = ({ state: $18, template: q }) => {
  let K = typeof q === "function" ? q({ state: $18 }) : q, P = NJ.default.compile(PM(K)), O = Object.keys($18).filter((J) => !["text", "values", "data"].includes(J)).reduce((J, T) => {
    return J[T] = $18[T], J;
  }, {});
  return YM(P({ ...O, ...$18.values }), 10);
};
var L1$ = ($18, q) => {
  return q.length > 0 ? `${$18 ? `${$18}
` : $18}${q}
` : "";
};
var YM = ($18, q) => {
  let K = Array.from({ length: q }, () => I5({ dictionaries: [D5] })), P = $18;
  for (let _ = 0; _ < K.length; _++) P = P.replaceAll(`{{name${_ + 1}}}`, K[_]);
  return P;
};
var g1$ = ({ messages: $18, entities: q, conversationHeader: K = true }) => {
  let P = {};
  return $18.forEach((O) => {
    if (O.roomId) {
      if (!P[O.roomId]) P[O.roomId] = [];
      P[O.roomId].push(O);
    }
  }), Object.values(P).forEach((O) => {
    O.sort((z, J) => (z.createdAt || 0) - (J.createdAt || 0));
  }), Object.entries(P).sort(([, O], [, z]) => {
    var _a2, _b2;
    return (((_a2 = z[z.length - 1]) == null ? void 0 : _a2.createdAt) || 0) - (((_b2 = O[O.length - 1]) == null ? void 0 : _b2.createdAt) || 0);
  }).map(([O, z]) => {
    let J = z.filter((X) => X.entityId).map((X) => {
      let f = q.find((N) => N.id === X.entityId);
      if (!f) $K.warn({ entityId: X.entityId }, "core::prompts:formatPosts - no entity for");
      let V = (f == null ? void 0 : f.names[0]) || "Unknown User", M = (f == null ? void 0 : f.names[0]) || "unknown";
      return `Name: ${V} (@${M} EntityID:${X.entityId})
MessageID: ${X.id}${X.content.inReplyTo ? `
In reply to: ${X.content.inReplyTo}` : ""}
Source: ${X.content.source}
Date: ${jM(X.createdAt || 0)}
Text:
${X.content.text}`;
    });
    return `${K ? `Conversation: ${O.slice(-5)}
` : ""}${J.join(`

`)}`;
  }).join(`

`);
};
var b1$ = ({ messages: $18, entities: q }) => {
  return $18.reverse().filter((P) => P.entityId).map((P) => {
    var _a2;
    let _ = P.content.text, Y = P.content.actions, O = P.content.thought, z = ((_a2 = q.find((b) => b.id === P.entityId)) == null ? void 0 : _a2.names[0]) || "Unknown User", J = P.content.attachments, T = J && J.length > 0 ? ` (Attachments: ${J.map((b) => {
      let y = [`[${b.id} - ${b.title} (${b.url})]`];
      if (b.text) y.push(`Text: ${b.text}`);
      if (b.description) y.push(`Description: ${b.description}`);
      return y.join(`
`);
    }).join(J.every((b) => !b.text && !b.description) ? ", " : `
`)})` : null, X = new Date(P.createdAt || 0), f = X.getHours().toString().padStart(2, "0"), V = X.getMinutes().toString().padStart(2, "0"), M = `${f}:${V}`, N = jM(P.createdAt || 0), h = O ? `(${z}'s internal thought: ${O})` : null, E = `${M} (${N}) [${P.entityId}]`, I = _ ? `${E} ${z}: ${_}` : null, D = Y && Y.length > 0 ? `${I ? "" : E} (${z}'s actions: ${Y.join(", ")})` : null;
    return [I, h, D, T].filter(Boolean).join(`
`);
  }).join(`
`);
};
var jM = ($18) => {
  let K = (/* @__PURE__ */ new Date()).getTime() - $18, P = Math.abs(K), _ = Math.floor(P / 1e3), Y = Math.floor(_ / 60), O = Math.floor(Y / 60), z = Math.floor(O / 24);
  if (P < 6e4) return "just now";
  if (Y < 60) return `${Y} minute${Y !== 1 ? "s" : ""} ago`;
  if (O < 24) return `${O} hour${O !== 1 ? "s" : ""} ago`;
  return `${z} day${z !== 1 ? "s" : ""} ago`;
};
var Si = /```json\n([\s\S]*?)\n```/;
function K_($18) {
  if (!$18) return null;
  let q = $18.match(/<response>([\s\S]*?)<\/response>/), K;
  if (q) K = q[1], $K.debug("Found response XML block");
  else {
    let z = ((J) => {
      let T = 0, X = J.length;
      while (T < X) {
        let f = J.indexOf("<", T);
        if (f === -1) break;
        if (J.startsWith("</", f) || J.startsWith("<!--", f) || J.startsWith("<?", f)) {
          T = f + 1;
          continue;
        }
        let V = f + 1, M = "";
        while (V < X) {
          let g = J[V];
          if (/^[A-Za-z0-9_-]$/.test(g)) {
            M += g, V++;
            continue;
          }
          break;
        }
        if (!M) {
          T = f + 1;
          continue;
        }
        let N = J.indexOf(">", V);
        if (N === -1) break;
        let h = J.slice(f, N + 1);
        if (/\/\s*>$/.test(h)) {
          T = N + 1;
          continue;
        }
        let E = `</${M}>`, I = 1, D = N + 1;
        while (I > 0 && D < X) {
          let g = J.indexOf(`<${M}`, D), b = J.indexOf(E, D);
          if (b === -1) break;
          if (g !== -1 && g < b) {
            let y = J.indexOf(">", g + 1);
            if (y === -1) break;
            let p = J.slice(g, y + 1);
            if (/\/\s*>$/.test(p)) D = y + 1;
            else I++, D = y + 1;
          } else I--, D = b + E.length;
        }
        if (I === 0) {
          let g = D - E.length, b = J.slice(N + 1, g);
          return { tag: M, content: b };
        }
        T = N + 1;
      }
      return null;
    })($18);
    if (!z) return $K.warn("Could not find XML block in text"), $K.debug({ textPreview: $18.substring(0, 200) + "..." }, "Text content"), null;
    K = z.content, $K.debug(`Found XML block with tag: ${z.tag}`);
  }
  let P = {}, Y = ((O) => {
    let z = [], J = O.length, T = 0;
    while (T < J) {
      let X = O.indexOf("<", T);
      if (X === -1) break;
      if (O.startsWith("</", X) || O.startsWith("<!--", X) || O.startsWith("<?", X)) {
        T = X + 1;
        continue;
      }
      let f = X + 1, V = "";
      while (f < J) {
        let y = O[f];
        if (/^[A-Za-z0-9_-]$/.test(y)) {
          V += y, f++;
          continue;
        }
        break;
      }
      if (!V) {
        T = X + 1;
        continue;
      }
      let M = O.indexOf(">", f);
      if (M === -1) break;
      let N = O.slice(X, M + 1);
      if (/\/\s*>$/.test(N)) {
        T = M + 1;
        continue;
      }
      let h = `</${V}>`, E = 1, I = M + 1;
      while (E > 0 && I < J) {
        let y = O.indexOf(`<${V}`, I), p = O.indexOf(h, I);
        if (p === -1) break;
        if (y !== -1 && y < p) {
          let n = O.indexOf(">", y + 1);
          if (n === -1) break;
          let s = O.slice(y, n + 1);
          if (!/\/\s*>$/.test(s)) E++;
          I = n + 1;
        } else E--, I = p + h.length;
      }
      if (E !== 0) {
        T = M + 1;
        continue;
      }
      let D = I - h.length, b = O.slice(M + 1, D).replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&amp;/g, "&").replace(/&quot;/g, '"').replace(/&apos;/g, "'").trim();
      z.push({ key: V, value: b }), T = I;
    }
    return z;
  })(K);
  for (let { key: O, value: z } of Y) if (O === "actions" || O === "providers" || O === "evaluators") P[O] = z ? z.split(",").map((J) => J.trim()) : [];
  else if (O === "simple") P[O] = z.toLowerCase() === "true";
  else P[O] = z;
  if (Object.keys(P).length === 0) return $K.warn("No key-value pairs extracted from XML content"), $K.debug({ xmlPreview: K.substring(0, 200) + "..." }, "XML content was"), null;
  return P;
}
function y1$($18) {
  let q = null, K = $18.match(Si);
  try {
    if (K) q = JSON.parse(_M(K[1].trim()));
    else q = JSON.parse(_M($18.trim()));
  } catch (P) {
    return null;
  }
  if (q && typeof q === "object" && !Array.isArray(q)) return q;
  return null;
}
var _M = ($18) => {
  return $18 = $18.replace(/\{\s+/, "{").replace(/\s+\}/, "}").trim(), $18 = $18.replace(/("[\w\d_-]+")\s*: \s*(?!"|\[)([\s\S]+?)(?=(,\s*"|\}$))/g, '$1: "$2"'), $18 = $18.replace(/"([^"]+)"\s*:\s*'([^']*)'/g, (q, K, P) => `"${K}": "${P}"`), $18 = $18.replace(/("[\w\d_-]+")\s*:\s*([A-Za-z_]+)(?!["\w])/g, '$1: "$2"'), $18;
};
function vM($18, q) {
  if ($18.length <= q) return $18;
  let K = $18.lastIndexOf(".", q - 1);
  if (K !== -1) {
    let Y = $18.slice(0, K + 1).trim();
    if (Y.length > 0) return Y;
  }
  let P = $18.lastIndexOf(" ", q - 1);
  if (P !== -1) {
    let Y = $18.slice(0, P).trim();
    if (Y.length > 0) return `${Y}...`;
  }
  return `${$18.slice(0, q - 3).trim()}...`;
}
async function u1$($18, q = 512, K = 20) {
  $K.debug("[splitChunks] Starting text split");
  let P = 3.5, Y = await new Cz({ chunkSize: Number(Math.floor(q * P)), chunkOverlap: Number(Math.floor(K * P)) }).splitText($18);
  return $K.debug({ numberOfChunks: Y.length, averageChunkSize: Y.reduce((O, z) => O + z.length, 0) / Y.length }, "[splitChunks] Split complete"), Y;
}
async function x1$($18, q, K) {
  if (!$18) throw Error("Trim tokens received a null prompt");
  if ($18.length < q / 5) return $18;
  if (q <= 0) throw Error("maxTokens must be positive");
  let P = await K.useModel(M6.TEXT_TOKENIZER_ENCODE, { prompt: $18 });
  if (P.length <= q) return $18;
  let _ = P.slice(-q);
  return await K.useModel(M6.TEXT_TOKENIZER_DECODE, { tokens: _ });
}
function CJ() {
  let $18 = /* @__PURE__ */ new WeakSet();
  return function(q, K) {
    if (typeof K === "object" && K !== null) {
      if ($18.has(K)) return "[Circular]";
      $18.add(K);
    }
    return K;
  };
}
function SO($18) {
  if (!$18) return false;
  if (typeof $18 === "boolean") return $18;
  let q = ["YES", "Y", "TRUE", "T", "1", "ON", "ENABLE"], K = ["NO", "N", "FALSE", "F", "0", "OFF", "DISABLE"], P = $18.trim().toUpperCase();
  if (q.includes(P)) return true;
  if (K.includes(P)) return false;
  return false;
}
var Mi = n$.string().regex(/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i, "Invalid UUID format");
function Ni($18) {
  let q = Mi.safeParse($18);
  return q.success ? q.data : null;
}
function MO($18) {
  if (typeof $18 === "number") $18 = $18.toString();
  if (typeof $18 !== "string") throw TypeError("Value must be string");
  let q = Ni($18);
  if (q) return q;
  let K = encodeURIComponent($18), _ = Ci(K).slice(0, 16);
  return _[8] = _[8] & 63 | 128, _[6] = _[6] & 15 | 0, hi(_);
}
async function p1$($18) {
  if (!EJ()) return;
  let q = $18.map(async (K) => {
    let P = encodeURIComponent(K), _ = await zM(P);
    u_.set(P, _);
  });
  await Promise.all(q);
}
var u_ = /* @__PURE__ */ new Map();
var VO = null;
function EJ() {
  if (VO !== null) return VO;
  try {
    if (typeof globalThis < "u" && globalThis.crypto && globalThis.crypto.subtle && typeof globalThis.crypto.subtle.digest === "function") return VO = true, true;
  } catch {
  }
  return VO = false, false;
}
function Ci($18) {
  let q = u_.get($18);
  if (q) return q;
  let K = WM($18);
  if (u_.set($18, K), EJ()) zM($18).then((P) => {
    u_.set($18, P);
  }).catch(() => {
  });
  if (u_.size > 1e4) Array.from(u_.keys()).slice(0, 5e3).forEach((_) => u_.delete(_));
  return K;
}
async function zM($18) {
  if (EJ()) try {
    let K = new TextEncoder().encode($18), P = await globalThis.crypto.subtle.digest("SHA-1", K);
    return new Uint8Array(P);
  } catch {
  }
  return WM($18);
}
function WM($18) {
  let q = Ei($18), K = q.length, P = new Uint8Array(K + 9 + 63 >>> 6 << 6);
  P.set(q), P[K] = 128;
  let _ = K * 8, Y = new DataView(P.buffer);
  Y.setUint32(P.length - 4, _ >>> 0, false), Y.setUint32(P.length - 8, Math.floor(_ / 4294967296) >>> 0, false);
  let O = 1732584193, z = 4023233417, J = 2562383102, T = 271733878, X = 3285377520, f = new Uint32Array(80);
  for (let N = 0; N < P.length; N += 64) {
    for (let b = 0; b < 16; b++) f[b] = Y.getUint32(N + b * 4, false);
    for (let b = 16; b < 80; b++) {
      let y = f[b - 3] ^ f[b - 8] ^ f[b - 14] ^ f[b - 16];
      f[b] = y << 1 | y >>> 31;
    }
    let h = O, E = z, I = J, D = T, g = X;
    for (let b = 0; b < 80; b++) {
      let y, p;
      if (b < 20) y = E & I | ~E & D, p = 1518500249;
      else if (b < 40) y = E ^ I ^ D, p = 1859775393;
      else if (b < 60) y = E & I | E & D | I & D, p = 2400959708;
      else y = E ^ I ^ D, p = 3395469782;
      let n = (h << 5 | h >>> 27) + y + g + p + f[b] >>> 0;
      g = D, D = I, I = (E << 30 | E >>> 2) >>> 0, E = h, h = n;
    }
    O = O + h >>> 0, z = z + E >>> 0, J = J + I >>> 0, T = T + D >>> 0, X = X + g >>> 0;
  }
  let V = new Uint8Array(20), M = new DataView(V.buffer);
  return M.setUint32(0, O, false), M.setUint32(4, z, false), M.setUint32(8, J, false), M.setUint32(12, T, false), M.setUint32(16, X, false), V;
}
function Ei($18) {
  if (typeof TextEncoder < "u") return new TextEncoder().encode($18);
  let q = [];
  for (let K = 0; K < $18.length; K++) {
    let P = $18.charCodeAt(K);
    if (P < 128) q.push(P);
    else if (P < 2048) q.push(192 | P >> 6, 128 | P & 63);
    else if (P < 55296 || P >= 57344) q.push(224 | P >> 12, 128 | P >> 6 & 63, 128 | P & 63);
    else {
      K++;
      let _ = 65536 + ((P & 1023) << 10 | $18.charCodeAt(K) & 1023);
      q.push(240 | _ >> 18, 128 | _ >> 12 & 63, 128 | _ >> 6 & 63, 128 | _ & 63);
    }
  }
  return new Uint8Array(q);
}
function hi($18) {
  let q = [];
  for (let K = 0; K < $18.length; K++) {
    let P = $18[K].toString(16).padStart(2, "0");
    q.push(P);
  }
  return q.slice(0, 4).join("") + "-" + q.slice(4, 6).join("") + "-" + q.slice(6, 8).join("") + "-" + q.slice(8, 10).join("") + "-" + q.slice(10, 16).join("");
}
var c1$ = ($18) => {
  if ($18.startsWith("image/")) return "image";
  if ($18.startsWith("video/")) return "video";
  if ($18.startsWith("audio/")) return "audio";
  if ($18.includes("pdf") || $18.includes("document") || $18.startsWith("text/")) return "document";
  return;
};
function HM($18) {
  return `http://localhost:${q_("SERVER_PORT", "3000")}${$18}`;
}
var JM = n$.string().regex(/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i, "Invalid UUID format").describe("Unique identifier for the character in UUID format");
var Ri = n$.object({ id: n$.string().describe("Unique identifier for the media"), url: n$.string().describe("URL of the media file"), title: n$.string().optional().describe("Media title"), source: n$.string().optional().describe("Media source"), description: n$.string().optional().describe("Media description"), text: n$.string().optional().describe("Text content associated with the media"), contentType: n$.nativeEnum(qP).optional().describe("Type of media content") }).loose().describe("Media attachment with URL and metadata");
var Ii = n$.object({ text: n$.string().optional().describe("The main text content of the message"), thought: n$.string().optional().describe("Internal thought process or reasoning"), actions: n$.array(n$.string()).optional().describe("Actions to be taken in response"), providers: n$.array(n$.string()).optional().describe("Data providers to use (e.g., KNOWLEDGE)"), source: n$.string().optional().describe("Source of the content"), target: n$.string().optional().describe("Target of the content"), url: n$.string().optional().describe("Related URL"), inReplyTo: JM.optional().describe("UUID of message this is replying to"), attachments: n$.array(Ri).optional().describe("Array of media attachments (images, videos, documents, etc.)"), channelType: n$.enum(KP).optional().describe("Type of channel this content is for") }).catchall(n$.unknown()).describe("Content structure for messages in conversation examples");
var Di = n$.object({ name: n$.string().describe("Name of the speaker (can use {{name1}} placeholder for dynamic names)"), content: Ii }).describe("A single message in a conversation example");
var Li = n$.object({ directory: n$.string().describe("Path to a directory containing knowledge files"), shared: n$.boolean().optional().describe("Whether this knowledge is shared across characters") }).describe("Directory-based knowledge source");
var gi = n$.union([n$.string().describe("File path to a knowledge document"), n$.object({ path: n$.string().describe("Path to a knowledge file"), shared: n$.boolean().optional().describe("Whether this knowledge is shared across characters") }), Li]).describe("Knowledge source - can be a file path, file object, or directory");
var bi = n$.union([n$.string().describe("Template string with placeholders"), n$.function().optional()]).describe("Template for generating text - can be a string template or function");
var yi = n$.object({ all: n$.array(n$.string()).optional().describe("Style guidelines applied to all types of responses"), chat: n$.array(n$.string()).optional().describe("Style guidelines specific to chat/conversation responses"), post: n$.array(n$.string()).optional().describe("Style guidelines specific to social media posts") }).optional().describe("Style configuration defining how the character communicates across different contexts");
var ui = n$.record(n$.string(), n$.union([n$.string(), n$.boolean(), n$.number(), n$.object({}).loose(), n$.array(n$.any())])).optional().describe("Character-specific settings like avatar URL, preferences, and configuration");
var xi = n$.record(n$.string(), n$.union([n$.string(), n$.boolean(), n$.number()])).optional().describe("Secret values and API keys (should not be committed to version control)");
var pi = n$.object({ id: JM.optional().describe("Unique identifier for the character"), name: n$.string().min(1, "Character name is required").describe('The name of the character (e.g., "Eliza")'), username: n$.string().optional().describe("Username for the character on various platforms"), system: n$.string().optional().describe("System prompt that defines the character's core behavior and response style"), templates: n$.record(n$.string(), bi).optional().describe("Custom templates for generating different types of content"), bio: n$.union([n$.string(), n$.array(n$.string())]).describe("Character biography - can be a single string or array of biographical points"), messageExamples: n$.array(n$.array(Di)).optional().describe("Example conversations showing how the character responds in different scenarios"), postExamples: n$.array(n$.string()).optional().describe("Example social media posts demonstrating the character's voice and topics"), topics: n$.array(n$.string()).optional().describe("Topics the character is knowledgeable about and engages with"), adjectives: n$.array(n$.string()).optional().describe("Adjectives that describe the character's personality and traits"), knowledge: n$.array(gi).optional().describe("Knowledge sources (files, directories) the character can reference"), plugins: n$.array(n$.string()).optional().describe('List of plugin package names to load (e.g., ["@elizaos/plugin-sql", "@elizaos/plugin-bootstrap"] - these are commonly required)'), settings: ui, secrets: xi, style: yi }).strict().describe("Complete character definition including personality, behavior, and capabilities");
function TM($18) {
  let q = pi.safeParse($18);
  if (q.success) return { success: true, data: q.data };
  return { success: false, error: { message: `Character validation failed: ${q.error.message}`, issues: q.error.issues } };
}
function o1$($18) {
  try {
    let q = JSON.parse($18);
    return TM(q);
  } catch (q) {
    return { success: false, error: { message: `Invalid JSON: ${q instanceof Error ? q.message : "Unknown JSON parsing error"}` } };
  }
}
function n1$($18) {
  return TM($18).success;
}
function EK() {
  return typeof Buffer < "u" && typeof Buffer.from === "function";
}
function ci($18) {
  let q = $18.replace(/[^0-9a-fA-F]/g, "");
  if (EK()) return Buffer.from(q, "hex");
  let K = new Uint8Array(q.length / 2);
  for (let P = 0; P < K.length; P++) K[P] = parseInt(q.substr(P * 2, 2), 16);
  return K;
}
function mi($18, q = "utf8") {
  if (EK()) {
    let P = q === "utf-8" ? "utf8" : q;
    return Buffer.from($18, P);
  }
  if (q === "base64") {
    let P = atob($18), _ = new Uint8Array(P.length);
    for (let Y = 0; Y < P.length; Y++) _[Y] = P.charCodeAt(Y);
    return _;
  }
  return new TextEncoder().encode($18);
}
function wM($18) {
  if (EK() && Buffer.isBuffer($18)) return $18.toString("hex");
  let q = $18 instanceof Uint8Array ? $18 : new Uint8Array($18), K = "";
  for (let P = 0; P < q.length; P++) {
    let _ = q[P].toString(16);
    K += _.length === 1 ? "0" + _ : _;
  }
  return K;
}
function di($18, q = "utf8") {
  if (EK() && Buffer.isBuffer($18)) {
    let _ = q === "utf-8" ? "utf8" : q;
    return $18.toString(_);
  }
  let K = $18 instanceof Uint8Array ? $18 : new Uint8Array($18);
  if (q === "hex") return wM(K);
  if (q === "base64") {
    let _ = "";
    for (let Y = 0; Y < K.length; Y++) _ += String.fromCharCode(K[Y]);
    return btoa(_);
  }
  return new TextDecoder().decode(K);
}
function li($18) {
  if (!$18) return false;
  if (EK() && Buffer.isBuffer($18)) return true;
  return $18 instanceof Uint8Array || $18 instanceof ArrayBuffer || typeof $18 === "object" && $18.buffer instanceof ArrayBuffer && typeof $18.byteLength === "number" && !Array.isArray($18);
}
function ri($18) {
  if (EK()) return Buffer.alloc($18);
  return new Uint8Array($18);
}
function oi($18) {
  if (EK()) return Buffer.from($18);
  return new Uint8Array($18);
}
function ni($18) {
  if (EK() && $18.every((_) => Buffer.isBuffer(_))) return Buffer.concat($18);
  let q = 0;
  for (let _ of $18) q += _.length;
  let K = new Uint8Array(q), P = 0;
  for (let _ of $18) {
    let Y = _ instanceof Uint8Array ? _ : new Uint8Array(_);
    K.set(Y, P), P += Y.length;
  }
  return K;
}
function ii($18, q, K) {
  if (EK() && Buffer.isBuffer($18)) return $18.slice(q, K);
  return ($18 instanceof Uint8Array ? $18 : new Uint8Array($18)).slice(q, K);
}
function Bi($18, q) {
  if ($18.length !== q.length) return false;
  let K = $18 instanceof Uint8Array ? $18 : new Uint8Array($18), P = q instanceof Uint8Array ? q : new Uint8Array(q);
  for (let _ = 0; _ < K.length; _++) if (K[_] !== P[_]) return false;
  return true;
}
function ti($18) {
  return $18.length;
}
function Ui($18) {
  let q = new Uint8Array($18), K = typeof globalThis < "u" ? globalThis.crypto || globalThis.webcrypto : void 0;
  if (K && typeof K.getRandomValues === "function") K.getRandomValues(q);
  else for (let P = 0; P < $18; P++) q[P] = Math.floor(Math.random() * 256);
  return q;
}
var __ = { fromHex: ci, fromString: mi, fromBytes: oi, toHex: wM, toString: di, isBuffer: li, alloc: ri, concat: ni, slice: ii, equals: Bi, byteLength: ti, randomBytes: Ui };
var U1$ = ($18, q) => {
  if (!$18.length || q <= 0) return "";
  let K = $18.filter((O) => O.examples && Array.isArray(O.examples) && O.examples.length > 0);
  if (!K.length) return "";
  let P = K.map((O) => [...O.examples || []]), _ = [], Y = P.map((O, z) => O.length > 0 ? z : -1).filter((O) => O !== -1);
  while (_.length < q && Y.length > 0) {
    let O = Math.floor(Math.random() * Y.length), z = Y[O], J = P[z], T = Math.floor(Math.random() * J.length);
    if (_.push(J.splice(T, 1)[0]), J.length === 0) Y.splice(O, 1);
  }
  return Fi(_);
};
var Fi = ($18) => {
  return $18.map((K) => {
    let P = Array.from({ length: 5 }, () => I5({ dictionaries: [D5] }));
    return `
${K.map((Y) => {
      let O = `${Y.name}: ${Y.content.text}`;
      for (let z = 0; z < P.length; z++) O = O.replaceAll(`{{name${z + 1}}}`, P[z]);
      return O;
    }).join(`
`)}`;
  }).join(`
`);
};
function F1$($18) {
  if (!($18 == null ? void 0 : $18.length)) return "";
  return [...$18].sort(() => Math.random() - 0.5).map((q) => q.name).join(", ");
}
function a1$($18) {
  if (!($18 == null ? void 0 : $18.length)) return "";
  return [...$18].sort(() => Math.random() - 0.5).map((q) => `- **${q.name}**: ${q.description || "No description available"}`).join(`
`);
}
var ai = class {
  constructor() {
    __publicField(this, "db");
  }
};
function s1$($18) {
  return { ...$18, createdAt: Date.now(), metadata: { type: "message", timestamp: Date.now(), scope: $18.agentId ? "private" : "shared" } };
}
function $9$($18) {
  return $18.type === "document";
}
function q9$($18) {
  return $18.type === "fragment";
}
function K9$($18) {
  return $18.type === "message";
}
function _9$($18) {
  return $18.type === "description";
}
function P9$($18) {
  return $18.type !== "document" && $18.type !== "fragment" && $18.type !== "message" && $18.type !== "description";
}
function O9$($18) {
  var _a2;
  return ((_a2 = $18.metadata) == null ? void 0 : _a2.type) === "document";
}
function Y9$($18) {
  var _a2;
  return ((_a2 = $18.metadata) == null ? void 0 : _a2.type) === "fragment";
}
function j9$($18, q = "") {
  return $18.content.text ?? q;
}
var fM = `<task>Decide on behalf of {{agentName}} whether they should respond to the message, ignore it or stop the conversation.</task>

<providers>
{{providers}}
</providers>

<instructions>Decide if {{agentName}} should respond to or interact with the conversation.

IMPORTANT RULES FOR RESPONDING:
- If YOUR name ({{agentName}}) is directly mentioned  RESPOND
- If someone uses a DIFFERENT name (not {{agentName}})  IGNORE (they're talking to someone else)
- If you're actively participating in a conversation and the message continues that thread  RESPOND
- If someone tells you to stop or be quiet  STOP
- Otherwise  IGNORE

The key distinction is:
- "Talking TO {{agentName}}" (your name mentioned, replies to you, continuing your conversation)  RESPOND
- "Talking ABOUT {{agentName}}" or to someone else  IGNORE
</instructions>

<output>
Do NOT include any thinking, reasoning, or <think> sections in your response.
Go directly to the XML response format without any preamble or explanation.

Respond using XML format like this:
<response>
  <name>{{agentName}}</name>
  <reasoning>Your reasoning here</reasoning>
  <action>RESPOND | IGNORE | STOP</action>
</response>

IMPORTANT: Your response must ONLY contain the <response></response> XML block above. Do not include any text, thinking, or reasoning before or after this XML block. Start your response immediately with <response> and end with </response>.
</output>`;
var ZM = `<task>Generate dialog and actions for the character {{agentName}}.</task>

<providers>
{{providers}}
</providers>

<instructions>
Write a thought and plan for {{agentName}} and decide what actions to take. Also include the providers that {{agentName}} will use to have the right context for responding and acting, if any.

IMPORTANT ACTION ORDERING RULES:
- Actions are executed in the ORDER you list them - the order MATTERS!
- REPLY should come FIRST to acknowledge the user's request before executing other actions
- Common patterns:
  - For requests requiring tool use: REPLY,CALL_MCP_TOOL (acknowledge first, then gather info)
  - For task execution: REPLY,SEND_MESSAGE or REPLY,EVM_SWAP_TOKENS (acknowledge first, then do the task)
  - For multi-step operations: REPLY,ACTION1,ACTION2 (acknowledge first, then complete all steps)
- REPLY is used to acknowledge and inform the user about what you're going to do
- Follow-up actions execute the actual tasks after acknowledgment
- Use IGNORE only when you should not respond at all
- If you use IGNORE, do not include any other actions. IGNORE should be used alone when you should not respond or take any actions.

IMPORTANT PROVIDER SELECTION RULES:
- Only include providers if they are needed to respond accurately.
- If the message mentions images, photos, pictures, attachments, or visual content, OR if you see "(Attachments:" in the conversation, you MUST include "ATTACHMENTS" in your providers list
- If the message asks about or references specific people, include "ENTITIES" in your providers list  
- If the message asks about relationships or connections between people, include "RELATIONSHIPS" in your providers list
- If the message asks about facts or specific information, include "FACTS" in your providers list
- If the message asks about the environment or world context, include "WORLD" in your providers list
- If no additional context is needed, you may leave the providers list empty.

IMPORTANT CODE BLOCK FORMATTING RULES:
- If {{agentName}} includes code examples, snippets, or multi-line code in the response, ALWAYS wrap the code with \`\`\` fenced code blocks (specify the language if known, e.g., \`\`\`python).
- ONLY use fenced code blocks for actual code. Do NOT wrap non-code text, instructions, or single words in fenced code blocks.
- If including inline code (short single words or function names), use single backticks (\`) as appropriate.
- This ensures the user sees clearly formatted and copyable code when relevant.

First, think about what you want to do next and plan your actions. Then, write the next message and include the actions you plan to take.
</instructions>

<keys>
"thought" should be a short description of what the agent is thinking about and planning.
"actions" should be a comma-separated list of the actions {{agentName}} plans to take based on the thought, IN THE ORDER THEY SHOULD BE EXECUTED (if none, use IGNORE, if simply responding with text, use REPLY)
"providers" should be a comma-separated list of the providers that {{agentName}} will use to have the right context for responding and acting (NEVER use "IGNORE" as a provider - use specific provider names like ATTACHMENTS, ENTITIES, FACTS, KNOWLEDGE, etc.)
"text" should be the text of the next message for {{agentName}} which they will send to the conversation.
</keys>

<output>
Do NOT include any thinking, reasoning, or <think> sections in your response. 
Go directly to the XML response format without any preamble or explanation.

Respond using XML format like this:
<response>
    <thought>Your thought here</thought>
    <actions>ACTION1,ACTION2</actions>
    <providers>PROVIDER1,PROVIDER2</providers>
    <text>Your response text here</text>
</response>

IMPORTANT: Your response must ONLY contain the <response></response> XML block above. Do not include any text, thinking, or reasoning before or after this XML block. Start your response immediately with <response> and end with </response>.
</output>`;
var z9$ = `# Task: Create a post in the voice and style and perspective of {{agentName}} @{{twitterUserName}}.

Example task outputs:
1. A post about the importance of AI in our lives
<response>
  <thought>I am thinking about writing a post about the importance of AI in our lives</thought>
  <post>AI is changing the world and it is important to understand how it works</post>
  <imagePrompt>A futuristic cityscape with flying cars and people using AI to do things</imagePrompt>
</response>

2. A post about dogs
<response>
  <thought>I am thinking about writing a post about dogs</thought>
  <post>Dogs are man's best friend and they are loyal and loving</post>
  <imagePrompt>A dog playing with a ball in a park</imagePrompt>
</response>

3. A post about finding a new job
<response>
  <thought>Getting a job is hard, I bet there's a good tweet in that</thought>
  <post>Just keep going!</post>
  <imagePrompt>A person looking at a computer screen with a job search website</imagePrompt>
</response>

{{providers}}

Write a post that is {{adjective}} about {{topic}} (without mentioning {{topic}} directly), from the perspective of {{agentName}}. Do not add commentary or acknowledge this request, just write the post.
Your response should be 1, 2, or 3 sentences (choose the length at random).
Your response should not contain any questions. Brief, concise statements only. The total character count MUST be less than 280. No emojis. Use \\n\\n (double spaces) between statements if there are multiple statements in your response.

Your output should be formatted in XML like this:
<response>
  <thought>Your thought here</thought>
  <post>Your post text here</post>
  <imagePrompt>Optional image prompt here</imagePrompt>
</response>

The "post" field should be the post you want to send. Do not including any thinking or internal reflection in the "post" field.
The "imagePrompt" field is optional and should be a prompt for an image that is relevant to the post. It should be a single sentence that captures the essence of the post. ONLY USE THIS FIELD if it makes sense that the post would benefit from an image.
The "thought" field should be a short description of what the agent is thinking about before responding, including a brief justification for the response. Includate an explanation how the post is relevant to the topic but unique and different than other posts.

Do NOT include any thinking, reasoning, or <think> sections in your response. 
Go directly to the XML response format without any preamble or explanation.

IMPORTANT: Your response must ONLY contain the <response></response> XML block above. Do not include any text, thinking, or reasoning before or after this XML block. Start your response immediately with <response> and end with </response>.`;
var W9$ = "Respond with only a YES or a NO.";
var XM = `<task>Analyze the provided image and generate a comprehensive description with multiple levels of detail.</task>

<instructions>
Carefully examine the image and provide:
1. A concise, descriptive title that captures the main subject or scene
2. A brief summary description (1-2 sentences) highlighting the key elements
3. An extensive, detailed description that covers all visible elements, composition, lighting, colors, mood, and any other relevant details

Be objective and descriptive. Focus on what you can actually see in the image rather than making assumptions about context or meaning.
</instructions>

<output>
Do NOT include any thinking, reasoning, or <think> sections in your response. 
Go directly to the XML response format without any preamble or explanation.

Respond using XML format like this:
<response>
  <title>A concise, descriptive title for the image</title>
  <description>A brief 1-2 sentence summary of the key elements in the image</description>
  <text>An extensive, detailed description covering all visible elements, composition, lighting, colors, mood, setting, objects, people, activities, and any other relevant details you can observe in the image</text>
</response>

IMPORTANT: Your response must ONLY contain the <response></response> XML block above. Do not include any text, thinking, or reasoning before or after this XML block. Start your response immediately with <response> and end with </response>.
</output>`;
var AM = `<task>
Determine the next step the assistant should take in this conversation to help the user reach their goal.
</task>

{{recentMessages}}

# Multi-Step Workflow

In each step, decide:

1. **Which providers (if any)** should be called to gather necessary data.
2. **Which action (if any)** should be executed after providers return.
3. Decide whether the task is complete. If so, set \`isFinish: true\`. Do not select the \`REPLY\` action; replies are handled separately after task completion.

You can select **multiple providers** and at most **one action** per step.

If the task is fully resolved and no further steps are needed, mark the step as \`isFinish: true\`.

---

{{actionsWithDescriptions}}

{{providersWithDescriptions}}

These are the actions or data provider calls that have already been used in this run. Use this to avoid redundancy and guide your next move.

{{actionResults}}

<keys>
"thought" Clearly explain your reasoning for the selected providers and/or action, and how this step contributes to resolving the user's request.
"action"  Name of the action to execute after providers return (can be empty if no action is needed).
"providers" List of provider names to call in this step (can be empty if none are needed).
"isFinish" Set to true only if the task is fully complete.
</keys>

 IMPORTANT: Do **not** mark the task as \`isFinish: true\` immediately after calling an action. Wait for the action to complete before deciding the task is finished.

<output>
<response>
  <thought>Your thought here</thought>
  <action>ACTION</action>
  <providers>PROVIDER1,PROVIDER2</providers>
  <isFinish>true | false</isFinish>
</response>
</output>`;
var kM = `<task>
Summarize what the assistant has done so far and provide a final response to the user based on the completed steps.
</task>

# Context Information
{{bio}}

---

{{system}}

---

{{messageDirections}}

# Conversation Summary
Below is the users original request and conversation so far:
{{recentMessages}}

# Execution Trace
Here are the actions taken by the assistant to fulfill the request:
{{actionResults}}

# Assistants Last Reasoning Step
{{recentMessage}}

# Instructions

 - Review the execution trace and last reasoning step carefully

 - Your final output MUST be in this XML format:
<output>
<response>
  <thought>Your thought here</thought>
  <text>Your final message to the user</text>
</response>
</output>
`;
async function w9$($18, q, K) {
  var _a2;
  let P = qK($18, K), _ = await $18.getWorld(P);
  if (!_ || !((_a2 = _.metadata) == null ? void 0 : _a2.roles)) return "NONE";
  if (_.metadata.roles[q]) return _.metadata.roles[q];
  if (_.metadata.roles[q]) return _.metadata.roles[q];
  return "NONE";
}
async function f9$($18, q) {
  var _a2, _b2;
  if (!q) return j6.error("User ID is required to find server"), null;
  let K = await $18.getAllWorlds();
  if (!K || K.length === 0) return j6.info("No worlds found for this agent"), null;
  let P = [];
  for (let _ of K) if (((_b2 = (_a2 = _.metadata) == null ? void 0 : _a2.ownership) == null ? void 0 : _b2.ownerId) === q) P.push(_);
  return P.length ? P : null;
}
var Vq = [];
for (let $18 = 0; $18 < 256; ++$18) Vq.push(($18 + 256).toString(16).slice(1));
function GM($18, q = 0) {
  return (Vq[$18[q + 0]] + Vq[$18[q + 1]] + Vq[$18[q + 2]] + Vq[$18[q + 3]] + "-" + Vq[$18[q + 4]] + Vq[$18[q + 5]] + "-" + Vq[$18[q + 6]] + Vq[$18[q + 7]] + "-" + Vq[$18[q + 8]] + Vq[$18[q + 9]] + "-" + Vq[$18[q + 10]] + Vq[$18[q + 11]] + Vq[$18[q + 12]] + Vq[$18[q + 13]] + Vq[$18[q + 14]] + Vq[$18[q + 15]]).toLowerCase();
}
var hJ;
var Qi = new Uint8Array(16);
function RJ() {
  if (!hJ) {
    if (typeof crypto > "u" || !crypto.getRandomValues) throw Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    hJ = crypto.getRandomValues.bind(crypto);
  }
  return hJ(Qi);
}
var ei = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var IJ = { randomUUID: ei };
function si($18, q, K) {
  var _a2;
  if (IJ.randomUUID && !q && !$18) return IJ.randomUUID();
  $18 = $18 || {};
  let P = $18.random ?? ((_a2 = $18.rng) == null ? void 0 : _a2.call($18)) ?? RJ();
  if (P.length < 16) throw Error("Random bytes length must be >= 16");
  if (P[6] = P[6] & 15 | 64, P[8] = P[8] & 63 | 128, q) {
    if (K = K || 0, K < 0 || K + 16 > q.length) throw RangeError(`UUID byte range ${K}:${K + 15} is out of buffer bounds`);
    for (let _ = 0; _ < 16; ++_) q[K + _] = P[_];
    return q;
  }
  return GM(P);
}
var Iq = si;
var j1 = /* @__PURE__ */ new Map();
var DJ = class {
  async handleMessage($18, q, K, P) {
    let _ = { maxRetries: (P == null ? void 0 : P.maxRetries) ?? 3, timeoutDuration: (P == null ? void 0 : P.timeoutDuration) ?? 36e5, useMultiStep: (P == null ? void 0 : P.useMultiStep) ?? SO($18.getSetting("USE_MULTI_STEP")), maxMultiStepIterations: (P == null ? void 0 : P.maxMultiStepIterations) ?? parseInt($18.getSetting("MAX_MULTISTEP_ITERATIONS") || "6") }, Y = void 0, O = Iq();
    try {
      if ($18.logger.info(`[MessageService] Message received from ${q.entityId} in room ${q.roomId}`), !j1.has($18.agentId)) j1.set($18.agentId, /* @__PURE__ */ new Map());
      let z = j1.get($18.agentId);
      if (!z) throw Error("Agent responses map not found");
      let J = z.get(q.roomId);
      if (J) j6.warn(`[MessageService] Updating response ID for room ${q.roomId} from ${J} to ${O}`);
      z.set(q.roomId, O);
      let T = $18.startRun(), X = Date.now();
      await $18.emitEvent("RUN_STARTED", { runtime: $18, runId: T, messageId: q.id, roomId: q.roomId, entityId: q.entityId, startTime: X, status: "started", source: "messageHandler", metadata: q.content });
      let f = new Promise((N, h) => {
        Y = setTimeout(async () => {
          await $18.emitEvent("RUN_TIMEOUT", { runtime: $18, runId: T, messageId: q.id, roomId: q.roomId, entityId: q.entityId, startTime: X, status: "timeout", endTime: Date.now(), duration: Date.now() - X, error: "Run exceeded timeout", source: "messageHandler" }), h(Error("Run exceeded timeout"));
        }, _.timeoutDuration);
      }), V = this.processMessage($18, q, K, O, T, X, _), M = await Promise.race([V, f]);
      return clearTimeout(Y), M;
    } catch (z) {
      throw clearTimeout(Y), $18.logger.error({ error: z }, "[MessageService] Error in handleMessage:"), z;
    }
  }
  async processMessage($18, q, K, P, _, Y, O) {
    var _a2, _b2, _c, _d2, _e, _f, _g2, _h, _i2;
    try {
      let z = j1.get($18.agentId);
      if (!z) throw Error("Agent responses map not found");
      if (q.entityId === $18.agentId) return $18.logger.debug(`[MessageService] Skipping message from self (${$18.agentId})`), await this.emitRunEnded($18, _, q, Y, "self"), { didRespond: false, responseContent: null, responseMessages: [], state: {}, mode: "none" };
      $18.logger.debug(`[MessageService] Processing message: ${vM(q.content.text || "", 50)}...`), $18.logger.debug("[MessageService] Saving message to memory and queueing embeddings");
      let J;
      if (q.id) {
        let q$ = await $18.getMemoryById(q.id);
        if (q$) $18.logger.debug("[MessageService] Memory already exists, skipping creation"), J = q$;
        else {
          let c = await $18.createMemory(q, "messages");
          J = { ...q, id: c };
        }
        await $18.queueEmbeddingGeneration(J, "high");
      } else {
        let q$ = await $18.createMemory(q, "messages");
        q.id = q$, J = { ...q, id: q$ }, await $18.queueEmbeddingGeneration(J, "normal");
      }
      let T = await $18.getParticipantUserState(q.roomId, $18.agentId);
      if (SO($18.getSetting("BOOTSTRAP_DEFLLMOFF")) && T === null) return $18.logger.debug("[MessageService] LLM is off by default"), await this.emitRunEnded($18, _, q, Y, "off"), { didRespond: false, responseContent: null, responseMessages: [], state: {}, mode: "none" };
      if (T === "MUTED" && !((_a2 = q.content.text) == null ? void 0 : _a2.toLowerCase().includes($18.character.name.toLowerCase()))) return $18.logger.debug(`[MessageService] Ignoring muted room ${q.roomId}`), await this.emitRunEnded($18, _, q, Y, "muted"), { didRespond: false, responseContent: null, responseMessages: [], state: {}, mode: "none" };
      let f = await $18.composeState(q, ["ANXIETY", "ENTITIES", "CHARACTER", "RECENT_MESSAGES", "ACTIONS"], true), V = q.content.mentionContext, M = await $18.getRoom(q.roomId);
      if (q.content.attachments && q.content.attachments.length > 0) {
        if (q.content.attachments = await this.processAttachments($18, q.content.attachments), q.id) await $18.updateMemory({ id: q.id, content: q.content });
      }
      let N = this.shouldRespond($18, q, M ?? void 0, V);
      $18.logger.debug(`[MessageService] Response decision: ${JSON.stringify(N)}`);
      let h = true;
      if (N.skipEvaluation) $18.logger.debug(`[MessageService] Skipping evaluation for ${$18.character.name} (${N.reason})`), h = N.shouldRespond;
      else {
        let q$ = Y1({ state: f, template: ((_b2 = $18.character.templates) == null ? void 0 : _b2.shouldRespondTemplate) || fM });
        $18.logger.debug(`[MessageService] Using LLM evaluation for ${$18.character.name} (${N.reason})`);
        let c = await $18.useModel(M6.TEXT_SMALL, { prompt: q$ });
        $18.logger.debug(`[MessageService] LLM evaluation result:
${c}`);
        let U = K_(c);
        $18.logger.debug({ responseObject: U }, "[MessageService] Parsed evaluation result:");
        let j = ["IGNORE", "NONE"];
        h = (U == null ? void 0 : U.action) && !j.includes(U.action.toUpperCase());
      }
      let E = null, I = [], D = "none";
      if (h) {
        let q$ = O.useMultiStep ? await this.runMultiStepCore($18, q, f, K, O) : await this.runSingleShotCore($18, q, f, O);
        if (E = q$.responseContent, I = q$.responseMessages, f = q$.state, D = q$.mode, z.get(q.roomId) !== P) return $18.logger.info(`Response discarded - newer message being processed for agent: ${$18.agentId}, room: ${q.roomId}`), { didRespond: false, responseContent: null, responseMessages: [], state: f, mode: "none" };
        if (E && q.id) E.inReplyTo = qK($18, q.id);
        if (((_c = E == null ? void 0 : E.providers) == null ? void 0 : _c.length) && E.providers.length > 0) f = await $18.composeState(q, E.providers || []);
        if (E) {
          if (D === "simple") {
            if (E.providers && E.providers.length > 0) $18.logger.debug({ providers: E.providers }, "[MessageService] Simple response used providers");
            if (K) await K(E);
          } else if (D === "actions") await $18.processActions(q, I, f, async (U) => {
            if ($18.logger.debug({ content: U }, "action callback"), E.actionCallbacks = U, K) return K(U);
            return [];
          });
        }
      } else {
        $18.logger.debug("[MessageService] Agent decided not to respond (shouldRespond is false).");
        let q$ = z.get(q.roomId), c = SO($18.getSetting("BOOTSTRAP_KEEP_RESP"));
        if (q$ !== P && !c) return $18.logger.info(`Ignore response discarded - newer message being processed for agent: ${$18.agentId}, room: ${q.roomId}`), await this.emitRunEnded($18, _, q, Y, "replaced"), { didRespond: false, responseContent: null, responseMessages: [], state: f, mode: "none" };
        if (!q.id) return $18.logger.error("[MessageService] Message ID is missing, cannot create ignore response."), await this.emitRunEnded($18, _, q, Y, "noMessageId"), { didRespond: false, responseContent: null, responseMessages: [], state: f, mode: "none" };
        let U = { thought: "Agent decided not to respond to this message.", actions: ["IGNORE"], simple: true, inReplyTo: qK($18, q.id) };
        if (K) await K(U);
        let j = { id: z1(Iq()), entityId: $18.agentId, agentId: $18.agentId, content: U, roomId: q.roomId, createdAt: Date.now() };
        await $18.createMemory(j, "messages"), $18.logger.debug("[MessageService] Saved ignore response to memory", `memoryId: ${j.id}`);
      }
      if (z.delete(q.roomId), z.size === 0) j1.delete($18.agentId);
      await $18.evaluate(q, f, h, async (q$) => {
        if ($18.logger.debug({ content: q$ }, "evaluate callback"), E) E.evalCallbacks = q$;
        if (K) return K(q$);
        return [];
      }, I);
      let g = "noname";
      if (q.metadata && "entityName" in q.metadata) g = q.metadata.entityName;
      let b = ((_d2 = q.content) == null ? void 0 : _d2.channelType) === "DM", y = g;
      if (!b) {
        let q$ = await $18.getRoomsByIds([q.roomId]);
        if (q$ == null ? void 0 : q$.length) {
          let c = q$[0];
          if (c.name) y = c.name;
          if (c.worldId) {
            let U = await $18.getWorld(c.worldId);
            if (U) y = U.name + "-" + y;
          }
        }
      }
      let p = /* @__PURE__ */ new Date(), n = ((_i2 = (_h = (_g2 = (_f = (_e = f.data) == null ? void 0 : _e.providers) == null ? void 0 : _f.ACTIONS) == null ? void 0 : _g2.data) == null ? void 0 : _h.actionsData) == null ? void 0 : _i2.map((q$) => q$.name)) || [-1], s = { at: p.toString(), timestamp: parseInt("" + p.getTime() / 1e3), messageId: q.id, userEntityId: q.entityId, input: q.content.text, thought: E == null ? void 0 : E.thought, simple: E == null ? void 0 : E.simple, availableActions: n, actions: E == null ? void 0 : E.actions, providers: E == null ? void 0 : E.providers, irt: E == null ? void 0 : E.inReplyTo, output: E == null ? void 0 : E.text, entityName: g, source: q.content.source, channelType: q.content.channelType, roomName: y };
      return await $18.emitEvent("RUN_ENDED", { runtime: $18, runId: _, messageId: q.id, roomId: q.roomId, entityId: q.entityId, startTime: Y, status: "completed", endTime: Date.now(), duration: Date.now() - Y, source: "messageHandler", entityName: g, responseContent: E, metadata: s }), { didRespond: h, responseContent: E, responseMessages: I, state: f, mode: D };
    } catch (z) {
      throw console.error("error is", z), await $18.emitEvent("RUN_ENDED", { runtime: $18, runId: _, messageId: q.id, roomId: q.roomId, entityId: q.entityId, startTime: Y, status: "error", endTime: Date.now(), duration: Date.now() - Y, error: z.message, source: "messageHandler" }), z;
    }
  }
  shouldRespond($18, q, K, P) {
    var _a2, _b2;
    if (!K) return { shouldRespond: false, skipEvaluation: true, reason: "no room context" };
    function _(N) {
      if (!N || typeof N !== "string") return [];
      return N.trim().replace(/^\[|\]$/g, "").split(",").map((E) => E.trim()).filter(Boolean);
    }
    let Y = ["DM", "VOICE_DM", "SELF", "API"], O = ["client_chat"], z = _($18.getSetting("ALWAYS_RESPOND_CHANNELS") || $18.getSetting("SHOULD_RESPOND_BYPASS_TYPES")), J = _($18.getSetting("ALWAYS_RESPOND_SOURCES") || $18.getSetting("SHOULD_RESPOND_BYPASS_SOURCES")), T = new Set([...Y.map((N) => N.toString()), ...z].map((N) => N.trim().toLowerCase())), X = [...O, ...J].map((N) => N.trim().toLowerCase()), f = (_a2 = K.type) == null ? void 0 : _a2.toString().toLowerCase(), V = ((_b2 = q.content.source) == null ? void 0 : _b2.toLowerCase()) || "";
    if (T.has(f)) return { shouldRespond: true, skipEvaluation: true, reason: `private channel: ${f}` };
    if (X.some((N) => V.includes(N))) return { shouldRespond: true, skipEvaluation: true, reason: `whitelisted source: ${V}` };
    if (!!((P == null ? void 0 : P.isMention) || (P == null ? void 0 : P.isReply))) return { shouldRespond: true, skipEvaluation: true, reason: `platform ${(P == null ? void 0 : P.isMention) ? "mention" : "reply"}` };
    return { shouldRespond: false, skipEvaluation: false, reason: "needs LLM evaluation" };
  }
  async processAttachments($18, q) {
    var _a2, _b2, _c, _d2;
    if (!q || q.length === 0) return [];
    $18.logger.debug(`[MessageService] Processing ${q.length} attachment(s)`);
    let K = [];
    for (let P of q) try {
      let _ = { ...P }, Y = /^(http|https):\/\//.test(P.url), O = Y ? P.url : HM(P.url);
      if (P.contentType === "image" && !P.description) {
        $18.logger.debug(`[MessageService] Generating description for image: ${P.url}`);
        let z = O;
        if (!Y) {
          let J = await fetch(O);
          if (!J.ok) throw Error(`Failed to fetch image: ${J.statusText}`);
          let T = await J.arrayBuffer(), X = Buffer.from(T);
          z = `data:${J.headers.get("content-type") || "application/octet-stream"};base64,${X.toString("base64")}`;
        }
        try {
          let J = await $18.useModel(M6.IMAGE_DESCRIPTION, { prompt: XM, imageUrl: z });
          if (typeof J === "string") {
            let T = K_(J);
            if (T && (T.description || T.text)) _.description = T.description || "", _.title = T.title || "Image", _.text = T.text || T.description || "", $18.logger.debug(`[MessageService] Generated description: ${(_a2 = _.description) == null ? void 0 : _a2.substring(0, 100)}...`);
            else {
              let X = J, f = X.match(/<title>([^<]+)<\/title>/), V = X.match(/<description>([^<]+)<\/description>/), M = X.match(/<text>([^<]+)<\/text>/);
              if (f || V || M) _.title = (f == null ? void 0 : f[1]) || "Image", _.description = (V == null ? void 0 : V[1]) || "", _.text = (M == null ? void 0 : M[1]) || (V == null ? void 0 : V[1]) || "", $18.logger.debug(`[MessageService] Used fallback XML parsing - description: ${(_b2 = _.description) == null ? void 0 : _b2.substring(0, 100)}...`);
              else $18.logger.warn("[MessageService] Failed to parse XML response for image description");
            }
          } else if (J && typeof J === "object" && "description" in J) _.description = J.description, _.title = J.title || "Image", _.text = J.description, $18.logger.debug(`[MessageService] Generated description: ${(_c = _.description) == null ? void 0 : _c.substring(0, 100)}...`);
          else $18.logger.warn("[MessageService] Unexpected response format for image description");
        } catch (J) {
          $18.logger.error({ error: J }, "[MessageService] Error generating image description:");
        }
      } else if (P.contentType === "document" && !P.text) {
        let z = await fetch(O);
        if (!z.ok) throw Error(`Failed to fetch document: ${z.statusText}`);
        let J = z.headers.get("content-type") || "";
        if (J.startsWith("text/plain")) {
          $18.logger.debug(`[MessageService] Processing plain text document: ${P.url}`);
          let X = await z.text();
          _.text = X, _.title = _.title || "Text File", $18.logger.debug(`[MessageService] Extracted text content (first 100 chars): ${(_d2 = _.text) == null ? void 0 : _d2.substring(0, 100)}...`);
        } else $18.logger.warn(`[MessageService] Skipping non-plain-text document: ${J}`);
      }
      K.push(_);
    } catch (_) {
      $18.logger.error({ error: _, attachmentUrl: P.url }, `[MessageService] Failed to process attachment ${P.url}:`), K.push(P);
    }
    return K;
  }
  async runSingleShotCore($18, q, K, P) {
    var _a2, _b2, _c;
    if (K = await $18.composeState(q, ["ACTIONS"]), !((_a2 = K.values) == null ? void 0 : _a2.actionNames)) $18.logger.warn("actionNames data missing from state, even though it was requested");
    let _ = Y1({ state: K, template: ((_b2 = $18.character.templates) == null ? void 0 : _b2.messageHandlerTemplate) || ZM }), Y = null, O = 0;
    while (O < P.maxRetries && (!(Y == null ? void 0 : Y.thought) || !(Y == null ? void 0 : Y.actions))) {
      let T = await $18.useModel(M6.TEXT_LARGE, { prompt: _ });
      $18.logger.debug({ response: T }, "[MessageService] *** Raw LLM Response ***");
      let X = K_(T);
      if ($18.logger.debug({ parsedXml: X }, "[MessageService] *** Parsed XML Content ***"), X) Y = { ...X, thought: X.thought || "", actions: X.actions || ["IGNORE"], providers: X.providers || [], text: X.text || "", simple: X.simple || false };
      else Y = null;
      if (O++, !(Y == null ? void 0 : Y.thought) || !(Y == null ? void 0 : Y.actions)) $18.logger.warn({ response: T, parsedXml: X, responseContent: Y }, "[MessageService] *** Missing required fields (thought or actions), retrying... ***");
    }
    if (!Y) return { responseContent: null, responseMessages: [], state: K, mode: "none" };
    if (Y.actions && Y.actions.length > 1) {
      let T = (f) => typeof f === "string" && f.toUpperCase() === "IGNORE";
      if (Y.actions.some(T)) if (!Y.text || Y.text.trim() === "") Y.actions = ["IGNORE"];
      else {
        let f = Y.actions.filter((V) => !T(V));
        Y.actions = f.length ? f : ["REPLY"];
      }
    }
    let z = ((_c = Y.actions) == null ? void 0 : _c.length) === 1 && typeof Y.actions[0] === "string" && Y.actions[0].toUpperCase() === "REPLY" && (!Y.providers || Y.providers.length === 0);
    Y.simple = z;
    let J = [{ id: z1(Iq()), entityId: $18.agentId, agentId: $18.agentId, content: Y, roomId: q.roomId, createdAt: Date.now() }];
    return { responseContent: Y, responseMessages: J, state: K, mode: z && Y.text ? "simple" : "actions" };
  }
  async runMultiStepCore($18, q, K, P, _) {
    var _a2, _b2, _c, _d2, _e;
    let Y = [], O = K, z = 0;
    while (z < _.maxMultiStepIterations) {
      z++, $18.logger.debug(`[MultiStep] Starting iteration ${z}/${_.maxMultiStepIterations}`), O = await $18.composeState(q, ["RECENT_MESSAGES", "ACTION_STATE"]), O.data.actionResults = Y;
      let M = Y1({ state: O, template: ((_a2 = $18.character.templates) == null ? void 0 : _a2.multiStepDecisionTemplate) || AM }), N = await $18.useModel(M6.TEXT_LARGE, { prompt: M }), h = K_(N);
      if (!h) {
        $18.logger.warn(`[MultiStep] Failed to parse step result at iteration ${z}`), Y.push({ data: { actionName: "parse_error" }, success: false, error: "Failed to parse step result" });
        break;
      }
      let { thought: E, providers: I = [], action: D, isFinish: g } = h;
      if (g === "true" || g === true) {
        if ($18.logger.info(`[MultiStep] Task marked as complete at iteration ${z}`), P) await P({ text: "", thought: E ?? "" });
        break;
      }
      if ((!I || I.length === 0) && !D) {
        $18.logger.warn(`[MultiStep] No providers or action specified at iteration ${z}, forcing completion`);
        break;
      }
      try {
        for (let b of I) {
          let y = $18.providers.find((s) => s.name === b);
          if (!y) {
            $18.logger.warn(`[MultiStep] Provider not found: ${b}`), Y.push({ data: { actionName: b }, success: false, error: `Provider not found: ${b}` });
            continue;
          }
          let p = await y.get($18, q, K);
          if (!p) {
            $18.logger.warn(`[MultiStep] Provider returned no result: ${b}`), Y.push({ data: { actionName: b }, success: false, error: "Provider returned no result" });
            continue;
          }
          let n = !!p.text;
          if (Y.push({ data: { actionName: b }, success: n, text: n ? p.text : void 0, error: n ? void 0 : "Provider returned no result" }), P) await P({ text: ` Provider executed: ${b}`, actions: [b], thought: E ?? "" });
        }
        if (D) {
          let b = { text: ` Executing action: ${D}`, actions: [D], thought: E ?? "" };
          await $18.processActions(q, [{ id: Iq(), entityId: $18.agentId, roomId: q.roomId, createdAt: Date.now(), content: b }], K, async () => {
            return [];
          });
          let p = ((_d2 = (_c = (_b2 = $18.stateCache) == null ? void 0 : _b2.get(`${q.id}_action_results`)) == null ? void 0 : _c.values) == null ? void 0 : _d2.actionResults) || [], n = p.length > 0 ? p[0] : null, s = (n == null ? void 0 : n.success) ?? false;
          Y.push({ data: { actionName: D }, success: s, text: n == null ? void 0 : n.text, values: n == null ? void 0 : n.values, error: s ? void 0 : n == null ? void 0 : n.text });
        }
      } catch (b) {
        $18.logger.error({ err: b }, "[MultiStep] Error executing step"), Y.push({ data: { actionName: D || "unknown" }, success: false, error: b instanceof Error ? b.message : String(b) });
      }
    }
    if (z >= _.maxMultiStepIterations) $18.logger.warn(`[MultiStep] Reached maximum iterations (${_.maxMultiStepIterations}), forcing completion`);
    O = await $18.composeState(q, ["RECENT_MESSAGES", "ACTION_STATE"]);
    let J = Y1({ state: O, template: ((_e = $18.character.templates) == null ? void 0 : _e.multiStepSummaryTemplate) || kM }), T = await $18.useModel(M6.TEXT_LARGE, { prompt: J }), X = K_(T), f = null;
    if (X == null ? void 0 : X.text) f = { actions: ["MULTI_STEP_SUMMARY"], text: X.text, thought: X.thought || "Final user-facing message after task completion.", simple: true };
    let V = f ? [{ id: z1(Iq()), entityId: $18.agentId, agentId: $18.agentId, content: f, roomId: q.roomId, createdAt: Date.now() }] : [];
    return { responseContent: f, responseMessages: V, state: O, mode: f ? "simple" : "none" };
  }
  async emitRunEnded($18, q, K, P, _) {
    await $18.emitEvent("RUN_ENDED", { runtime: $18, runId: q, messageId: K.id, roomId: K.roomId, entityId: K.entityId, startTime: P, status: _, endTime: Date.now(), duration: Date.now() - P, source: "messageHandler" });
  }
  async deleteMessage($18, q) {
    try {
      if (!q.id) {
        $18.logger.error("[MessageService] Cannot delete memory: message ID is missing");
        return;
      }
      $18.logger.info("[MessageService] Deleting memory for message", q.id, "from room", q.roomId), await $18.deleteMemory(q.id), $18.logger.debug({ messageId: q.id }, "[MessageService] Successfully deleted memory for message");
    } catch (K) {
      throw $18.logger.error({ error: K }, "[MessageService] Error in deleteMessage:"), K;
    }
  }
  async clearChannel($18, q, K) {
    try {
      $18.logger.info(`[MessageService] Clearing message memories from channel ${K} -> room ${q}`);
      let P = await $18.getMemoriesByRoomIds({ tableName: "messages", roomIds: [q] });
      $18.logger.info(`[MessageService] Found ${P.length} message memories to delete from channel ${K}`);
      let _ = 0;
      for (let Y of P) if (Y.id) try {
        await $18.deleteMemory(Y.id), _++;
      } catch (O) {
        $18.logger.warn({ error: O, memoryId: Y.id }, `[MessageService] Failed to delete message memory ${Y.id}:`);
      }
      $18.logger.info(`[MessageService] Successfully cleared ${_}/${P.length} message memories from channel ${K}`);
    } catch (P) {
      throw $18.logger.error({ error: P }, "[MessageService] Error in clearChannel:"), P;
    }
  }
};
var hK = ($18) => {
  switch ($18) {
    case 97:
    case 101:
    case 105:
    case 111:
    case 117:
    case 121:
      return true;
    default:
      return false;
  }
};
var $B = ($18) => {
  switch ($18) {
    case 97:
    case 101:
    case 105:
    case 111:
    case 117:
    case 121:
    case 119:
    case 120:
    case 89:
      return true;
    default:
      return false;
  }
};
var qB = ($18) => {
  switch ($18) {
    case 99:
    case 100:
    case 101:
    case 103:
    case 104:
    case 107:
    case 109:
    case 110:
    case 114:
    case 116:
      return true;
    default:
      return false;
  }
};
var KB = ($18) => {
  switch ($18) {
    case 98:
    case 100:
    case 102:
    case 103:
    case 109:
    case 110:
    case 112:
    case 114:
    case 116:
      return true;
    default:
      return false;
  }
};
var VM = ($18, q) => {
  return q >= 2 && hK($18[q - 2]) && (q === 2 && !hK($18[q - 1]) || q >= 3 && !hK($18[q - 3]) && !$B($18[q - 1]));
};
var _B = ($18) => {
  if ($18.length < 3) return $18;
  if ($18.length <= 6) switch ($18) {
    case "ski":
      return "ski";
    case "skies":
      return "sky";
    case "dying":
      return "die";
    case "lying":
      return "lie";
    case "tying":
      return "tie";
    case "idly":
      return "idl";
    case "gently":
      return "gentl";
    case "ugly":
      return "ugli";
    case "early":
      return "earli";
    case "only":
      return "onli";
    case "singly":
      return "singl";
    case "sky":
    case "news":
    case "howe":
    case "atlas":
    case "cosmos":
    case "bias":
    case "andes":
      return $18;
  }
  let q = $18.charCodeAt(0) === 39 ? 1 : 0, K = $18.length - q, P = Array(K), _ = false;
  for (let X = 0; X < K; ++X) {
    let f = $18.charCodeAt(X + q);
    if (f === 121 && (X === 0 || hK(P[X - 1]))) {
      _ = true, P[X] = 89;
      continue;
    }
    P[X] = f;
  }
  if (P[K - 1] === 39) --K;
  if (K >= 2 && P[K - 2] === 39 && P[K - 1] === 115) K -= 2;
  let Y = 0;
  while (Y < K && !hK(P[Y])) ++Y;
  if (Y < K) ++Y;
  let O = Y;
  if (K >= 5 && (P[0] === 103 && P[1] === 101 && P[2] === 110 && P[3] === 101 && P[4] === 114 || P[0] === 97 && P[1] === 114 && P[2] === 115 && P[3] === 101 && P[4] === 110)) O = 5;
  else if (K >= 6 && P[0] === 99 && P[1] === 111 && P[2] === 109 && P[3] === 109 && P[4] === 117 && P[5] === 110) O = 6;
  else {
    while (O < K && hK(P[O])) ++O;
    if (O < K) ++O;
  }
  let z = O;
  while (z < K && !hK(P[z])) ++z;
  while (z < K && hK(P[z])) ++z;
  if (z < K) ++z;
  if (K >= 3) {
    if (P[K - 1] === 115) {
      if (K >= 4 && P[K - 2] === 101 && P[K - 3] === 115 && P[K - 4] === 115) K -= 2;
      else if (P[K - 2] === 101 && P[K - 3] === 105) K -= K >= 5 ? 2 : 1;
      else if (P[K - 2] !== 117 && P[K - 2] !== 115 && Y < K - 1) K -= 1;
    } else if (P[K - 1] === 100 && P[K - 2] === 101 && P[K - 3] === 105) K -= K >= 5 ? 2 : 1;
  }
  if (K === 6 && (P[0] === 105 && P[1] === 110 && P[2] === 110 && P[3] === 105 && P[4] === 110 && P[5] === 103 || P[0] === 111 && P[1] === 117 && P[2] === 116 && P[3] === 105 && P[4] === 110 && P[5] === 103 || P[0] === 101 && P[1] === 120 && P[2] === 99 && P[3] === 101 && P[4] === 101 && P[5] === 100) || K === 7 && (P[0] === 99 && P[1] === 97 && P[2] === 110 && P[3] === 110 && P[4] === 105 && P[5] === 110 && P[6] === 103 || P[0] === 104 && P[1] === 101 && P[2] === 114 && P[3] === 114 && P[4] === 105 && P[5] === 110 && P[6] === 103 || P[0] === 101 && P[1] === 97 && P[2] === 114 && P[3] === 114 && P[4] === 105 && P[5] === 110 && P[6] === 103 || P[0] === 112 && P[1] === 114 && P[2] === 111 && P[3] === 99 && P[4] === 101 && P[5] === 101 && P[6] === 100 || P[0] === 115 && P[1] === 117 && P[2] === 99 && P[3] === 99 && P[4] === 101 && P[5] === 101 && P[6] === 100)) {
    let X = "";
    for (let f = 0; f < K; ++f) X += String.fromCharCode(P[f]);
    return X;
  }
  let J = K >= 2 && P[K - 1] === 121 && P[K - 2] === 108 ? K - 2 : K;
  if (J >= 3) if (P[J - 3] === 101 && P[J - 2] === 101 && P[J - 1] === 100) {
    if (J >= O + 3) K = J - 1;
  } else {
    if (P[J - 2] === 101 && P[J - 1] === 100) J -= 2;
    else if (P[J - 3] === 105 && P[J - 2] === 110 && P[J - 1] === 103) J -= 3;
    else J = -1;
    if (J >= 0 && Y <= J) {
      if (K = J, K >= 2) {
        if (P[K - 1] === 116 && P[K - 2] === 97 || P[K - 1] === 108 && P[K - 2] === 98 || P[K - 1] === 122 && P[K - 2] === 105) P[K] = 101, ++K;
        else if (P[K - 2] === P[K - 1] && KB(P[K - 1])) --K;
        else if (O >= K && VM(P, K)) P[K] = 101, ++K;
      }
    }
  }
  if (K >= 3 && (P[K - 1] === 89 || P[K - 1] === 121) && !hK(P[K - 2])) P[K - 1] = 105;
  if (K >= O + 2) switch (P[K - 1]) {
    case 108:
      if (K >= O + 6 && P[K - 2] === 97 && P[K - 3] === 110 && P[K - 4] === 111 && P[K - 5] === 105 && P[K - 6] === 116) if (K >= 7 && P[K - 7] === 97) {
        if (K >= O + 7) K -= 4, P[K - 1] = 101;
      } else K -= 2;
      break;
    case 110:
      if (K >= O + 5 && P[K - 2] === 111 && P[K - 3] === 105 && P[K - 4] === 116 && P[K - 5] === 97) if (K >= 7 && P[K - 6] === 122 && P[K - 7] === 105) {
        if (K >= O + 7) K -= 4, P[K - 1] = 101;
      } else K -= 2, P[K - 1] = 101;
      break;
    case 114:
      if (K >= O + 4) {
        if (P[K - 2] === 101) {
          if (P[K - 3] === 122 && P[K - 4] === 105) --K;
        } else if (P[K - 2] === 111) {
          if (P[K - 3] === 116 && P[K - 4] === 97) --K, P[K - 1] = 101;
        }
      }
      break;
    case 115:
      if (K >= O + 7 && P[K - 2] === 115 && P[K - 3] === 101 && P[K - 4] === 110 && (P[K - 5] === 108 && P[K - 6] === 117 && P[K - 7] === 102 || P[K - 5] === 115 && P[K - 6] === 117 && P[K - 7] === 111 || P[K - 5] === 101 && P[K - 6] === 118 && P[K - 7] === 105)) K -= 4;
      break;
    case 109:
      if (K >= O + 5 && P[K - 2] === 115 && P[K - 3] === 105 && P[K - 4] === 108 && P[K - 5] === 97) K -= 3;
      break;
    case 105:
      if (P[K - 2] === 99) {
        if (K >= O + 4 && (P[K - 4] === 101 || P[K - 4] === 97) && P[K - 3] === 110) P[K - 1] = 101;
      } else if (P[K - 2] === 103) {
        if (K >= O + 3 && K >= 4 && P[K - 2] === 103 && P[K - 3] === 111 && P[K - 4] === 108) --K;
      } else if (P[K - 2] === 116) {
        if (K >= O + 5 && P[K - 3] === 105) {
          if (P[K - 4] === 108) {
            if (K >= 6 && P[K - 5] === 105 && P[K - 6] === 98) {
              if (K >= O + 6) K -= 3, P[K - 2] = 108, P[K - 1] = 101;
            } else if (P[K - 4] === 108 && P[K - 5] === 97) K -= 3;
          } else if (P[K - 4] === 118 && P[K - 5] === 105) K -= 2, P[K - 1] = 101;
        }
      } else if (P[K - 2] === 108 && K >= 3) {
        if (P[K - 3] === 98) {
          if (K >= 4 && P[K - 4] === 97) {
            if (K >= O + 4) P[K - 1] = 101;
          } else if (K >= O + 3) P[K - 1] = 101;
        } else if (P[K - 3] === 108) {
          if (K >= 5 && P[K - 4] === 117 && P[K - 5] === 102) {
            if (K >= O + 5) K -= 2;
          } else if (K >= O + 4 && P[K - 4] === 97) K -= 2;
        } else if (P[K - 3] === 115) {
          if (K >= 6 && P[K - 4] === 115 && P[K - 5] === 101 && P[K - 6] === 108) {
            if (K >= O + 6) K -= 2;
          } else if (K >= O + 5 && P[K - 4] === 117 && P[K - 5] === 111) K -= 2;
        } else if (K >= 5 && P[K - 3] === 116 && P[K - 4] === 110 && P[K - 5] === 101) {
          if (K >= O + 5) K -= 2;
        } else if (qB(P[K - 3])) K -= 2;
      }
  }
  if (K >= O + 3) switch (P[K - 1]) {
    case 108:
      if (P[K - 3] === 99) {
        if (K >= O + 4 && P[K - 4] === 105 && P[K - 2] === 97) K -= 2;
      } else if (P[K - 3] === 102) {
        if (P[K - 2] === 117) K -= 3;
      } else if (P[K - 3] === 110) {
        if (K >= O + 6 && P[K - 2] === 97 && P[K - 4] === 111 && P[K - 5] === 105 && P[K - 6] === 116) if (K >= 7 && P[K - 7] === 97) {
          if (K >= O + 7) K -= 4, P[K - 1] = 101;
        } else K -= 2;
      }
      break;
    case 101:
      if (P[K - 2] === 122) {
        if (K >= O + 5 && P[K - 3] === 105 && P[K - 4] === 108 && P[K - 5] === 97) K -= 3;
      } else if (P[K - 2] === 116) {
        if (K >= O + 5 && P[K - 3] === 97 && P[K - 4] === 99 && P[K - 5] === 105) K -= 3;
      } else if (P[K - 2] === 118) {
        if (K >= z + 5 && P[K - 3] === 105 && P[K - 4] === 116 && P[K - 5] === 97) K -= 5;
      }
      break;
    case 105:
      if (K >= O + 5 && P[K - 2] === 116 && P[K - 3] === 105 && P[K - 4] === 99 && P[K - 5] === 105) K -= 3;
      break;
    case 115:
      if (K >= O + 4 && P[K - 2] === 115 && P[K - 3] === 101 && P[K - 4] === 110) K -= 4;
  }
  if (K >= z + 2) switch (P[K - 1]) {
    case 110:
      if (K >= z + 3 && P[K - 2] === 111 && P[K - 3] === 105 && (P[K - 4] === 115 || P[K - 4] === 116)) K -= 3;
      break;
    case 108:
      if (P[K - 2] === 97) K -= 2;
      break;
    case 114:
      if (P[K - 2] === 101) K -= 2;
      break;
    case 99:
      if (P[K - 2] === 105) K -= 2;
      break;
    case 109:
      if (K >= z + 3 && P[K - 2] === 115 && P[K - 3] === 105) K -= 3;
      break;
    case 105:
      if (K >= z + 3 && P[K - 2] === 116 && P[K - 3] === 105) K -= 3;
      break;
    case 115:
      if (K >= z + 3 && P[K - 2] === 117 && P[K - 3] === 111) K -= 3;
      break;
    case 116:
      if (K >= z + 3 && P[K - 2] === 110) {
        if (P[K - 3] === 97) K -= 3;
        else if (P[K - 3] === 101) if (K >= 4 && P[K - 4] === 109) {
          if (K >= 5 && P[K - 5] === 101) {
            if (K >= z + 5) K -= 5;
          } else if (K >= z + 4) K -= 4;
        } else K -= 3;
      }
      break;
    case 101:
      if (P[K - 2] === 99) {
        if (K >= z + 4 && P[K - 3] === 110 && (P[K - 4] === 97 || P[K - 4] === 101)) K -= 4;
      } else if (P[K - 2] === 108) {
        if (K >= z + 4 && P[K - 3] === 98 && (P[K - 4] === 97 || P[K - 4] === 105)) K -= 4;
      } else if (P[K - 2] === 116) {
        if (K >= z + 3 && P[K - 3] === 97) K -= 3;
      } else if (K >= z + 3 && (P[K - 2] === 118 || P[K - 2] === 122) && P[K - 3] === 105) K -= 3;
  }
  if (K >= O + 1 && (K >= z + 1 && P[K - 1] === 108 && P[K - 2] === 108 || P[K - 1] === 101 && (K >= z + 1 || !VM(P, K - 1)))) --K;
  let T = "";
  if (_) for (let X = 0; X < K; ++X) T += String.fromCharCode(P[X] === 89 ? 121 : P[X]);
  else for (let X = 0; X < K; ++X) T += String.fromCharCode(P[X]);
  return T;
};
var PB = { k1: 1.2, b: 0.75, minLength: 2, stopWords: /* @__PURE__ */ new Set(["a", "an", "and", "are", "as", "at", "be", "by", "for", "from", "has", "he", "in", "is", "it", "its", "of", "on", "that", "the", "to", "was", "were", "will", "with"]), stemming: false, stemWords: ($18) => $18 };
var _LJ = class _LJ {
  constructor($18 = {}) {
    __publicField(this, "stopWords");
    __publicField(this, "minLength");
    __publicField(this, "stemming");
    __publicField(this, "stemmingRules");
    let q = { ..._LJ.DEFAULT_OPTIONS, ...$18 };
    this.stopWords = q.stopWords, this.minLength = q.minLength, this.stemming = q.stemming, this.stemmingRules = q.stemmingRules.map((K) => ({ ...K, pattern: typeof K.pattern === "string" ? new RegExp(K.pattern) : K.pattern }));
  }
  tokenize($18, q = false) {
    if (!$18) throw Error("Input text cannot be null or empty");
    let K = Date.now(), P = $18.split(/\s+/).filter((z) => z.length > 0), Y = this.cleanText($18).split(/\s+/).filter((z) => this.isValidToken(z)).map((z) => this.stemming ? this.stemWord(z) : z), O = q ? { originalWordCount: P.length, stopWordsRemoved: P.length - Y.length, stemmedWords: this.stemming ? Y.length : 0, processingTimeMs: Date.now() - K } : { originalWordCount: 0, stopWordsRemoved: 0, stemmedWords: 0, processingTimeMs: 0 };
    return { tokens: Y, stats: O };
  }
  cleanText($18) {
    return $18.toLowerCase().normalize("NFKD").replace(/[\u0000-\u001F\u007F-\u009F\u200B-\u200D\uFEFF]/g, "").replace(/[\u0300-\u036f]/g, "").replace(/[\p{Emoji_Presentation}\p{Extended_Pictographic}]/gu, "").replace(/[]/g, "").replace(/[\p{P}]/gu, " ").replace(/[^a-z0-9\u3040-\u30FF\u3400-\u4DBF\u4E00-\u9FFF\uAC00-\uD7AF\s]/gu, " ").replace(/\s+/g, " ").trim();
  }
  isValidToken($18) {
    let q = /^\d+$/.test($18);
    return ($18.length >= this.minLength || q) && !this.stopWords.has($18);
  }
  stemWord($18) {
    if ($18.length < 3) return $18;
    let q = false, K = $18;
    for (let P of this.stemmingRules) {
      let _ = K.match(P.pattern);
      if (_) {
        if (!P.minMeasure || this.measure(K.substring(0, _.index)) >= P.minMeasure) {
          if (typeof P.replacement === "string") K = K.replace(P.pattern, P.replacement);
          else K = K.replace(P.pattern, (...Y) => P.replacement(...Y));
          q = true;
        }
      }
    }
    if (q && K !== $18) return K;
    return _B(K);
  }
  isConsonant($18, q) {
    let K = $18[q];
    if ("aeiou".includes(K)) return false;
    return K !== "y" || (q === 0 ? true : !this.isConsonant($18, q - 1));
  }
  measure($18) {
    let q = 0, K = false;
    for (let P = 0; P < $18.length; P++) if (this.isConsonant($18, P)) {
      if (K) q++, K = false;
    } else K = true;
    return q;
  }
};
__publicField(_LJ, "DEFAULT_OPTIONS", { stopWords: /* @__PURE__ */ new Set(), minLength: 2, stemming: false, stemmingRules: [] });
var LJ = _LJ;
var gJ = class {
  constructor($18, q = {}) {
    __publicField(this, "termFrequencySaturation");
    __publicField(this, "lengthNormalizationFactor");
    __publicField(this, "tokenizer");
    __publicField(this, "documentLengths");
    __publicField(this, "averageDocLength");
    __publicField(this, "termToIndex");
    __publicField(this, "documentFrequency");
    __publicField(this, "termFrequencies");
    __publicField(this, "fieldBoosts");
    __publicField(this, "documents");
    let K = { ...PB, ...q };
    if (this.termFrequencySaturation = K.k1, this.lengthNormalizationFactor = K.b, this.tokenizer = new LJ(K), this.fieldBoosts = K.fieldBoosts || {}, this.documents = [], this.documentLengths = new Uint32Array(0), this.termToIndex = /* @__PURE__ */ new Map(), this.documentFrequency = new Uint32Array(0), this.averageDocLength = 0, this.termFrequencies = /* @__PURE__ */ new Map(), $18 && $18.length > 0) {
      this.documents = [...$18];
      let { documentLengths: P, termToIndex: _, documentFrequency: Y, averageDocLength: O, termFrequencies: z } = this.processDocuments($18);
      this.documentLengths = P, this.termToIndex = _, this.documentFrequency = Y, this.averageDocLength = O, this.termFrequencies = z;
    }
  }
  processDocuments($18) {
    let q = $18.length, K = new Uint32Array(q), P = /* @__PURE__ */ new Map(), _ = /* @__PURE__ */ new Map(), Y = /* @__PURE__ */ new Map(), O = 0, z = 0;
    $18.forEach((T, X) => {
      let f = 0, V = /* @__PURE__ */ new Map();
      Object.entries(T).forEach(([M, N]) => {
        if (typeof N !== "string") return;
        let h = this.fieldBoosts[M] || 1, { tokens: E } = this.tokenizer.tokenize(N), I = E.length * h;
        f += I, E.forEach((D) => {
          if (!P.has(D)) P.set(D, z++);
          let g = P.get(D);
          if (!_.has(D)) _.set(D, /* @__PURE__ */ new Set());
          _.get(D).add(X);
          let b = V.get(g) || 0;
          V.set(g, b + h);
        });
      }), K[X] = f, O += f, V.forEach((M, N) => {
        if (!Y.has(N)) Y.set(N, /* @__PURE__ */ new Map());
        Y.get(N).set(X, M);
      });
    });
    let J = new Uint32Array(P.size);
    return _.forEach((T, X) => {
      let f = P.get(X);
      J[f] = T.size;
    }), { documentLengths: K, termToIndex: P, documentFrequency: J, averageDocLength: q > 0 ? O / q : 0, termFrequencies: Y };
  }
  recalculateAverageLength() {
    if (this.documentLengths.length === 0) {
      this.averageDocLength = 0;
      return;
    }
    let $18 = this.documentLengths.reduce((q, K) => q + K, 0);
    this.averageDocLength = $18 / this.documentLengths.length;
  }
  search($18, q = 10) {
    let { tokens: K } = this.tokenizer.tokenize($18), P = new Float32Array(this.documentLengths.length).fill(0);
    return K.forEach((_) => {
      let Y = this.termToIndex.get(_);
      if (Y === void 0) return;
      let O = this.calculateIdf(Y);
      if (O <= 0) return;
      let z = this.termFrequencies.get(Y);
      if (!z) return;
      z.forEach((J, T) => {
        let X = this.documentLengths[T], f = J * (this.termFrequencySaturation + 1), V = J + this.termFrequencySaturation * (1 - this.lengthNormalizationFactor + this.lengthNormalizationFactor * X / this.averageDocLength);
        P[T] += O * (f / V);
      });
    }), Array.from({ length: P.length }, (_, Y) => ({ index: Y, score: P[Y] })).filter((_) => _.score > 0).sort((_, Y) => Y.score - _.score).slice(0, q);
  }
  searchPhrase($18, q = 10) {
    var _a2;
    let { tokens: K } = this.tokenizer.tokenize($18);
    if (K.length === 0) return [];
    let P = null;
    for (let Y of K) {
      let O = this.termToIndex.get(Y);
      if (O === void 0) return [];
      let z = (_a2 = this.termFrequencies.get(O)) == null ? void 0 : _a2.keys();
      if (!z) return [];
      let J = new Set(z);
      if (P === null) P = J;
      else P = new Set([...P].filter((T) => J.has(T)));
      if (P.size === 0) return [];
    }
    if (P === null || P.size === 0) return [];
    let _ = /* @__PURE__ */ new Map();
    return P.forEach((Y) => {
      let O = this.getDocument(Y), z = false;
      Object.entries(O).forEach(([J, T]) => {
        if (typeof T !== "string" || z) return;
        let X = this.fieldBoosts[J] || 1, { tokens: f } = this.tokenizer.tokenize(T);
        for (let V = 0; V <= f.length - K.length; V++) {
          let M = true;
          for (let N = 0; N < K.length; N++) if (f[V + N] !== K[N]) {
            M = false;
            break;
          }
          if (M) {
            let N = this.calculatePhraseScore(K, Y) * X;
            _.set(Y, (_.get(Y) || 0) + N), z = true;
            break;
          }
        }
      });
    }), Array.from(_.entries()).map(([Y, O]) => ({ index: Y, score: O })).sort((Y, O) => O.score - Y.score).slice(0, q);
  }
  calculatePhraseScore($18, q) {
    return $18.reduce((K, P) => {
      var _a2;
      let _ = this.termToIndex.get(P);
      if (_ === void 0) return K;
      let Y = this.calculateIdf(_), O = ((_a2 = this.termFrequencies.get(_)) == null ? void 0 : _a2.get(q)) || 0, z = this.documentLengths[q], J = O * (this.termFrequencySaturation + 1), T = O + this.termFrequencySaturation * (1 - this.lengthNormalizationFactor + this.lengthNormalizationFactor * z / this.averageDocLength);
      return K + Y * (J / T);
    }, 0);
  }
  async addDocument($18) {
    if (!$18) throw Error("Document cannot be null");
    let q = this.documentLengths.length;
    this.documents.push($18);
    let K = new Uint32Array(q + 1);
    K.set(this.documentLengths, 0), this.documentLengths = K;
    let P = 0, _ = /* @__PURE__ */ new Map();
    Object.entries($18).forEach(([Y, O]) => {
      if (typeof O !== "string") return;
      let z = this.fieldBoosts[Y] || 1, { tokens: J } = this.tokenizer.tokenize(O);
      P += J.length * z, J.forEach((T) => {
        let X;
        if (!this.termToIndex.has(T)) {
          if (X = this.termToIndex.size, this.termToIndex.set(T, X), this.documentFrequency.length <= X) {
            let V = this.documentFrequency, M = Math.max(X + 1, V.length * 2 || 1);
            this.documentFrequency = new Uint32Array(M), this.documentFrequency.set(V, 0);
          }
          this.documentFrequency[X] = 0;
        } else X = this.termToIndex.get(T);
        let f = _.get(X) || 0;
        _.set(X, f + z);
      });
    }), this.documentLengths[q] = P, _.forEach((Y, O) => {
      if (!this.termFrequencies.has(O)) this.termFrequencies.set(O, /* @__PURE__ */ new Map());
      if (this.termFrequencies.get(O).set(q, Y), O < this.documentFrequency.length) this.documentFrequency[O]++;
      else console.error(`Error: termIndexVal ${O} is out of bounds for documentFrequency (length ${this.documentFrequency.length}). This indicates an issue with array resizing or term indexing.`);
    }), this.recalculateAverageLength();
  }
  calculateIdf($18) {
    if ($18 < 0 || $18 >= this.documentFrequency.length) return 0;
    let q = this.documentFrequency[$18];
    if (q <= 0 || q > this.documentLengths.length) return 0;
    let P = this.documentLengths.length - q + 0.5, _ = q + 0.5;
    return Math.log(1 + P / _);
  }
  getTermFrequency($18, q) {
    var _a2;
    return ((_a2 = this.termFrequencies.get($18)) == null ? void 0 : _a2.get(q)) || 0;
  }
  getDocument($18) {
    if ($18 < 0 || $18 >= this.documents.length) throw Error(`Document index ${$18} out of bounds (0-${this.documents.length - 1})`);
    return this.documents[$18];
  }
  clearDocuments() {
    this.documents = [], this.documentLengths = new Uint32Array(0), this.termToIndex.clear(), this.documentFrequency = new Uint32Array(0), this.averageDocLength = 0, this.termFrequencies.clear();
  }
  getDocumentCount() {
    return this.documents.length;
  }
  async addDocuments($18) {
    return Promise.all($18.map((q) => this.addDocument(q)));
  }
};
var OB = {};
var YB = class {
  constructor($18) {
    __publicField(this, "permits");
    __publicField(this, "waiting", []);
    this.permits = $18;
  }
  async acquire() {
    if (this.permits > 0) return this.permits -= 1, Promise.resolve();
    return new Promise(($18) => {
      this.waiting.push($18);
    });
  }
  release() {
    this.permits += 1;
    let $18 = this.waiting.shift();
    if ($18 && this.permits > 0) this.permits -= 1, $18();
  }
};
var _$;
var bJ = class {
  constructor($18) {
    __privateAdd(this, _$, 32);
    __publicField(this, "agentId");
    __publicField(this, "character");
    __publicField(this, "adapter");
    __publicField(this, "actions", []);
    __publicField(this, "evaluators", []);
    __publicField(this, "providers", []);
    __publicField(this, "plugins", []);
    __publicField(this, "events", {});
    __publicField(this, "stateCache", /* @__PURE__ */ new Map());
    __publicField(this, "fetch", fetch);
    __publicField(this, "services", /* @__PURE__ */ new Map());
    __publicField(this, "serviceTypes", /* @__PURE__ */ new Map());
    __publicField(this, "models", /* @__PURE__ */ new Map());
    __publicField(this, "routes", []);
    __publicField(this, "taskWorkers", /* @__PURE__ */ new Map());
    __publicField(this, "sendHandlers", /* @__PURE__ */ new Map());
    __publicField(this, "eventHandlers", /* @__PURE__ */ new Map());
    __publicField(this, "elizaOS");
    __publicField(this, "allAvailablePlugins", /* @__PURE__ */ new Map());
    __publicField(this, "characterPlugins", []);
    __publicField(this, "logger");
    __publicField(this, "settings");
    __publicField(this, "servicePromiseHandlers", /* @__PURE__ */ new Map());
    __publicField(this, "servicePromises", /* @__PURE__ */ new Map());
    __publicField(this, "serviceRegistrationStatus", /* @__PURE__ */ new Map());
    __publicField(this, "initPromise");
    __publicField(this, "initResolver");
    __publicField(this, "initRejecter");
    __publicField(this, "migratedPlugins", /* @__PURE__ */ new Set());
    __publicField(this, "currentRunId");
    __publicField(this, "currentActionContext");
    __publicField(this, "maxWorkingMemoryEntries", 50);
    __publicField(this, "messageService", null);
    var _a2, _b2, _c, _d2;
    if (this.agentId = ((_a2 = $18.character) == null ? void 0 : _a2.id) ?? ($18 == null ? void 0 : $18.agentId) ?? MO(((_b2 = $18.character) == null ? void 0 : _b2.name) ?? Iq()), this.character = $18.character, this.initPromise = new Promise((q, K) => {
      this.initResolver = q, this.initRejecter = K;
    }), this.logger = O1({ namespace: (_c = this.character) == null ? void 0 : _c.name }), __privateSet(this, _$, $18.conversationLength ?? __privateGet(this, _$)), $18.adapter) this.registerDatabaseAdapter($18.adapter);
    if (this.fetch = $18.fetch ?? this.fetch, this.settings = $18.settings ?? OB, this.plugins = [], this.characterPlugins = ($18 == null ? void 0 : $18.plugins) ?? [], $18.allAvailablePlugins) {
      for (let q of $18.allAvailablePlugins) if (q == null ? void 0 : q.name) this.allAvailablePlugins.set(q.name, q);
    }
    if (this.logger.debug(`Success: Agent ID: ${this.agentId}`), this.currentRunId = void 0, (_d2 = $18.settings) == null ? void 0 : _d2.MAX_WORKING_MEMORY_ENTRIES) this.maxWorkingMemoryEntries = parseInt($18.settings.MAX_WORKING_MEMORY_ENTRIES, 10) || 50;
    else this.maxWorkingMemoryEntries = E0("MAX_WORKING_MEMORY_ENTRIES", 50);
  }
  createRunId() {
    return Iq();
  }
  startRun() {
    return this.currentRunId = this.createRunId(), this.currentRunId;
  }
  endRun() {
    this.currentRunId = void 0;
  }
  getCurrentRunId() {
    if (!this.currentRunId) this.currentRunId = this.createRunId();
    return this.currentRunId;
  }
  async registerPlugin($18) {
    if (!($18 == null ? void 0 : $18.name)) throw this.logger.error("*** registerPlugin: Plugin or plugin name is undefined"), Error("*** registerPlugin: Plugin or plugin name is undefined");
    if (this.plugins.find((K) => K.name === $18.name)) {
      this.logger.warn(`${this.character.name}(${this.agentId}) - Plugin ${$18.name} is already registered. Skipping re-registration.`);
      return;
    }
    if (this.plugins.push($18), this.logger.debug(`Success: Plugin ${$18.name} added to active plugins for ${this.character.name}(${this.agentId}).`), $18.init) try {
      await $18.init($18.config || {}, this), this.logger.debug(`Success: Plugin ${$18.name} initialized successfully`);
    } catch (K) {
      let P = K instanceof Error ? K.message : String(K);
      if (P.includes("API key") || P.includes("environment variables") || P.includes("Invalid plugin configuration")) console.warn(`Plugin ${$18.name} requires configuration. ${P}`), console.warn("Please check your environment variables and ensure all required API keys are set."), console.warn("You can set these in your .env file.");
      else throw K;
    }
    if ($18.adapter) this.logger.debug(`Registering database adapter for plugin ${$18.name}`), this.registerDatabaseAdapter($18.adapter);
    if ($18.actions) for (let K of $18.actions) this.registerAction(K);
    if ($18.evaluators) for (let K of $18.evaluators) this.registerEvaluator(K);
    if ($18.providers) for (let K of $18.providers) this.registerProvider(K);
    if ($18.models) for (let [K, P] of Object.entries($18.models)) this.registerModel(K, P, $18.name, $18 == null ? void 0 : $18.priority);
    if ($18.routes) for (let K of $18.routes) {
      let P = K.path.startsWith("/") ? K.path : `/${K.path}`;
      this.routes.push({ ...K, path: "/" + $18.name + P });
    }
    if ($18.events) for (let [K, P] of Object.entries($18.events)) for (let _ of P) this.registerEvent(K, _);
    if ($18.services) for (let K of $18.services) {
      let P = K.serviceType, _ = K.name || "Unknown";
      if (this.logger.debug(`Plugin ${$18.name} registering service: ${P}`), !this.servicePromises.has(P)) this._createServiceResolver(P);
      this.serviceRegistrationStatus.set(P, "pending"), this.registerService(K).catch((Y) => {
        this.logger.error(`Plugin ${$18.name} failed to register service ${P}: ${Y instanceof Error ? Y.message : String(Y)}`);
        let O = this.servicePromiseHandlers.get(P);
        if (O) {
          let z = Error(`Service ${P} from plugin ${$18.name} failed to register: ${Y instanceof Error ? Y.message : String(Y)}`);
          O.reject(z), this.servicePromiseHandlers.delete(P), this.servicePromises.delete(P);
        }
        this.serviceRegistrationStatus.set(P, "failed");
      });
    }
  }
  getAllServices() {
    return this.services;
  }
  async stop() {
    this.logger.debug(`runtime::stop - character ${this.character.name}`);
    for (let [$18, q] of this.services) {
      this.logger.debug(`runtime::stop - requesting service stop for ${$18}`);
      for (let K of q) await K.stop();
    }
    this.elizaOS = void 0;
  }
  async initialize($18) {
    var _a2, _b2;
    try {
      let q = [], K = this.characterPlugins;
      for (let T of K) if (T) q.push(this.registerPlugin(T));
      if (await Promise.all(q), !this.adapter) throw this.logger.error("Database adapter not initialized. Make sure @elizaos/plugin-sql is included in your plugins."), Error("Database adapter not initialized. The SQL plugin (@elizaos/plugin-sql) is required for agent initialization. Please ensure it is included in your character configuration.");
      if (!await this.adapter.isReady()) await this.adapter.init();
      if (this.messageService = new DJ(), ($18 == null ? void 0 : $18.skipMigrations) ?? false) this.logger.info("Skipping plugin migrations (skipMigrations=true)");
      else this.logger.info("Running plugin migrations..."), await this.runPluginMigrations(), this.logger.info("Plugin migrations completed.");
      let _ = await this.ensureAgentExists({ ...this.character, id: this.agentId });
      if (!_) {
        let T = `Agent ${this.agentId} does not exist in database after ensureAgentExists call`;
        throw Error(T);
      }
      if (_.settings) {
        this.character.settings = { ..._.settings, ...this.character.settings };
        let T = _.settings.secrets && typeof _.settings.secrets === "object" ? _.settings.secrets : {}, X = this.character.settings.secrets && typeof this.character.settings.secrets === "object" ? this.character.settings.secrets : {}, f = this.character.secrets && typeof this.character.secrets === "object" ? this.character.secrets : {}, V = { ...T, ...f, ...X };
        if (Object.keys(V).length > 0) this.character.secrets = V, this.character.settings.secrets = V;
      }
      try {
        let T = await this.getWorld(this.agentId);
        if ((_a2 = T == null ? void 0 : T.metadata) == null ? void 0 : _a2.settings) {
          let X = T.metadata.settings;
          for (let [f, V] of Object.entries(X)) if (typeof V === "object" && V.value !== null && V.value !== void 0) {
            if (!((_b2 = this.character.settings) == null ? void 0 : _b2[f])) this.character.settings = { ...this.character.settings, [f]: V.value };
          }
          this.logger.debug(`Loaded ${Object.keys(X).length} settings from world metadata`);
        }
      } catch (T) {
        this.logger.warn("Failed to load settings from world metadata:", T instanceof Error ? T.message : String(T));
      }
      let Y = await this.getEntityById(this.agentId);
      if (!Y) {
        if (!await this.createEntity({ id: this.agentId, names: [this.character.name], metadata: {}, agentId: _.id })) {
          let X = `Failed to create entity for agent ${this.agentId}`;
          throw Error(X);
        }
        if (Y = await this.getEntityById(this.agentId), !Y) throw Error(`Agent entity not found for ${this.agentId}`);
        this.logger.debug(`Success: Agent entity created successfully for ${this.character.name}`);
      }
      if (!await this.getRoom(this.agentId)) await this.createRoom({ id: this.agentId, name: this.character.name, source: "elizaos", type: "SELF", channelId: this.agentId, serverId: this.agentId, worldId: this.agentId });
      if (!(await this.adapter.getParticipantsForRoom(this.agentId)).includes(this.agentId)) {
        if (!await this.addParticipant(this.agentId, this.agentId)) {
          let X = `Failed to add agent ${this.agentId} as participant to its own room`;
          throw Error(X);
        }
        this.logger.debug(`Agent ${this.character.name} linked to its own room successfully`);
      }
      if (!this.getModel(M6.TEXT_EMBEDDING)) this.logger.warn(`[AgentRuntime][${this.character.name}] No TEXT_EMBEDDING model registered. Skipping embedding dimension setup.`);
      else await this.ensureEmbeddingDimension();
      if (this.initResolver) this.initResolver(), this.initResolver = void 0;
    } catch (q) {
      let K = q instanceof Error ? q.message : String(q);
      if (this.logger.error(`Runtime initialization failed: ${K}`), this.initRejecter) this.initRejecter(q), this.initRejecter = void 0;
      for (let [P, _] of this.servicePromises) {
        let Y = this.servicePromiseHandlers.get(P);
        if (Y) {
          let O = Error(`Service ${P} failed to start due to runtime initialization failure: ${K}`);
          Y.reject(O), this.servicePromiseHandlers.delete(P), this.servicePromises.delete(P), this.serviceRegistrationStatus.set(P, "failed");
        }
      }
      throw q;
    }
  }
  async runPluginMigrations() {
    if (!this.adapter) {
      this.logger.warn("Database adapter not found, skipping plugin migrations.");
      return;
    }
    if (typeof this.adapter.runPluginMigrations !== "function") {
      this.logger.warn("Database adapter does not support plugin migrations.");
      return;
    }
    let $18 = this.plugins.filter((q) => q.schema).map((q) => ({ name: q.name, schema: q.schema }));
    if ($18.length === 0) {
      this.logger.info("No plugins with schemas found, skipping migrations.");
      return;
    }
    this.logger.info(`Found ${$18.length} plugins with schemas to migrate.`);
    try {
      let P = { verbose: true, force: process.env.ELIZA_ALLOW_DESTRUCTIVE_MIGRATIONS === "true", dryRun: false };
      await this.adapter.runPluginMigrations($18, P), this.logger.info("Plugin migrations completed successfully.");
    } catch (q) {
      throw this.logger.error(q instanceof Error ? q : Error(String(q)), "Failed to run plugin migrations"), q;
    }
  }
  async getConnection() {
    if (!this.adapter) throw Error("Database adapter not registered");
    return this.adapter.getConnection();
  }
  setSetting($18, q, K = false) {
    if (K) {
      if (!this.character.secrets) this.character.secrets = {};
      this.character.secrets[$18] = q;
    } else {
      if (!this.character.settings) this.character.settings = {};
      this.character.settings[$18] = q;
    }
    this.saveSettingsToDatabase().catch((P) => {
      this.logger.error(`Failed to save settings to database: ${P}`);
    });
  }
  async saveSettingsToDatabase() {
    try {
      if (!this.adapter) {
        this.logger.warn("No database adapter available, settings will not be persisted");
        return;
      }
      await this.adapter.updateAgent(this.agentId, { settings: this.character.settings }), this.logger.debug(`Settings saved to database for agent ${this.agentId}`);
    } catch ($18) {
      this.logger.error(`Error saving settings to database: ${$18}`);
    }
  }
  getSetting($18) {
    var _a2, _b2, _c;
    let q = ((_a2 = this.character.secrets) == null ? void 0 : _a2[$18]) || ((_b2 = this.character.settings) == null ? void 0 : _b2[$18]) || typeof this.character.settings === "object" && this.character.settings !== null && "secrets" in this.character.settings && ((_c = this.character.settings.secrets) == null ? void 0 : _c[$18]) || this.settings[$18], K = NO(q, x_());
    if (K === "true") return true;
    if (K === "false") return false;
    return K || null;
  }
  getConversationLength() {
    return __privateGet(this, _$);
  }
  registerDatabaseAdapter($18) {
    if (this.adapter) this.logger.warn("Database adapter already registered. Additional adapters will be ignored. This may lead to unexpected behavior.");
    else this.adapter = $18, this.logger.debug("Success: Database adapter registered successfully.");
  }
  registerProvider($18) {
    this.providers.push($18), this.logger.debug(`Success: Provider ${$18.name} registered successfully.`);
  }
  registerAction($18) {
    if (this.actions.find((q) => q.name === $18.name)) this.logger.warn(`${this.character.name}(${this.agentId}) - Action ${$18.name} already exists. Skipping registration.`);
    else try {
      this.actions.push($18), this.logger.success(`${this.character.name}(${this.agentId}) - Action ${$18.name} registered successfully.`);
    } catch (q) {
      console.error("Error registering action", q);
    }
  }
  registerEvaluator($18) {
    this.evaluators.push($18);
  }
  updateActionPlan($18, q) {
    return { ...$18, ...q };
  }
  updateActionStep($18, q, K) {
    var _a2;
    if (!$18.steps || q < 0 || q >= $18.steps.length) return this.logger.warn(`Invalid step index: ${q} for plan with ${((_a2 = $18.steps) == null ? void 0 : _a2.length) || 0} steps`), $18;
    return { ...$18, steps: $18.steps.map((P, _) => _ === q ? { ...P, ...K } : P) };
  }
  async processActions($18, q, K, P) {
    var _a2, _b2, _c, _d2, _e, _f, _g2, _h, _i2, _j2, _k;
    let _ = [];
    for (let f of q) if (((_a2 = f.content) == null ? void 0 : _a2.actions) && f.content.actions.length > 0) _.push(...f.content.actions);
    let Y = _.length > 1, O = this.getCurrentRunId(), z = this.createRunId(), J = null, T = ((_c = (_b2 = q[0]) == null ? void 0 : _b2.content) == null ? void 0 : _c.thought) || `Executing ${_.length} actions: ${_.join(", ")}`;
    if (Y) J = { runId: z, totalSteps: _.length, currentStep: 0, steps: _.map((f) => ({ action: f, status: "pending" })), thought: T, startTime: Date.now() };
    let X = 0;
    for (let f of q) {
      let h = function(E) {
        return E.toLowerCase().replace(/_/g, "");
      };
      if (!((_d2 = f.content) == null ? void 0 : _d2.actions) || f.content.actions.length === 0) {
        this.logger.warn("No action found in the response content.");
        continue;
      }
      let V = f.content.actions, M = [], N = K;
      this.logger.debug(`Found actions: ${this.actions.map((E) => h(E.name))}`);
      for (let E of V) {
        if (J) J = this.updateActionPlan(J, { currentStep: X + 1 });
        if (N = await this.composeState($18, ["RECENT_MESSAGES", "ACTION_STATE"]), J && N.data) N.data.actionPlan = J, N.data.actionResults = M;
        this.logger.debug(`Success: Calling action: ${E}`);
        let I = h(E), D = this.actions.find((g) => h(g.name) === I);
        if (!D) D = this.actions.find((g) => h(g.name).includes(I) || I.includes(h(g.name)));
        if (D) this.logger.debug(`Success: Found action: ${D == null ? void 0 : D.name}`);
        else {
          this.logger.debug("Attempting to find action in similes.");
          for (let g of this.actions) {
            if ((_e = g.similes) == null ? void 0 : _e.find((p) => h(p) === I)) {
              D = g, this.logger.debug(`Success: Action found in similes (exact match): ${D.name}`);
              break;
            }
            if ((_f = g.similes) == null ? void 0 : _f.find((p) => h(p).includes(I) || I.includes(h(p)))) {
              D = g, this.logger.debug(`Success: Action found in similes (fuzzy match): ${D.name}`);
              break;
            }
          }
        }
        if (!D) {
          let g = `No action found for: ${E}`;
          if (this.logger.error(g), J && J.steps[X]) J = this.updateActionStep(J, X, { status: "failed", error: g });
          let b = { id: Iq(), entityId: $18.entityId, roomId: $18.roomId, worldId: $18.worldId, content: { thought: g, source: "auto", type: "action_result", actionName: E, actionStatus: "failed", runId: z } };
          await this.createMemory(b, "messages"), X++;
          continue;
        }
        if (!D.handler) {
          if (this.logger.error(`Action ${D.name} has no handler.`), J && J.steps[X]) J = this.updateActionStep(J, X, { status: "failed", error: "No handler" });
          X++;
          continue;
        }
        try {
          this.logger.debug(`Executing handler for action: ${D.name}`);
          let g = Iq();
          this.currentActionContext = { actionName: D.name, actionId: g, prompts: [] };
          let y = { actionContext: { previousResults: M, getPreviousResult: (j) => {
            return M.find((H) => {
              var _a3;
              return ((_a3 = H.data) == null ? void 0 : _a3.actionName) === j;
            });
          } } };
          if (J) y.actionPlan = { totalSteps: J.totalSteps, currentStep: J.currentStep, steps: J.steps, thought: J.thought };
          try {
            this.logger.debug(`Creating action start message for: ${D.name}`), await this.emitEvent("ACTION_STARTED", { messageId: g, roomId: $18.roomId, world: $18.worldId, content: { text: `Executing action: ${D.name}`, actions: [D.name], actionStatus: "executing", actionId: g, runId: z, type: "agent_action", thought: T, source: (_g2 = $18.content) == null ? void 0 : _g2.source } });
          } catch (j) {
            this.logger.error("Failed to create action start message:", String(j));
          }
          let p = [], n = async (j) => {
            return p.push(j), [];
          }, s = await D.handler(this, $18, N, y, n, q), q$ = s === void 0 || s === null || typeof s === "boolean", c = null;
          if (!q$) {
            if (typeof s === "object" && s !== null && ("values" in s || "data" in s || "text" in s)) c = { ...s, success: "success" in s ? s.success : true };
            else c = { success: true, data: { actionName: D.name, legacyResult: s } };
            if (M.push(c), c.values) N = { ...N, values: { ...N.values, ...c.values }, data: { ...N.data || {}, actionResults: [...((_h = N.data) == null ? void 0 : _h.actionResults) || [], c], actionPlan: J } };
            if (c && N.data) {
              if (!N.data.workingMemory) N.data.workingMemory = {};
              let j = `action_${E}_${Iq()}`, H = { actionName: D.name, result: c, timestamp: Date.now() };
              N.data.workingMemory[j] = H;
              let Z = Object.entries(N.data.workingMemory);
              if (Z.length > this.maxWorkingMemoryEntries) {
                let W = Z.sort((w, G) => {
                  let S = w[1], A = G[1], v = (S == null ? void 0 : S.timestamp) ?? 0;
                  return ((A == null ? void 0 : A.timestamp) ?? 0) - v;
                });
                N.data.workingMemory = Object.fromEntries(W.slice(0, this.maxWorkingMemoryEntries));
              }
            }
            if (J && J.steps[X]) J = this.updateActionStep(J, X, { status: "completed", result: c });
          }
          try {
            let H = (c == null ? void 0 : c.success) !== false ? "completed" : "failed";
            await this.emitEvent("ACTION_COMPLETED", { messageId: g, roomId: $18.roomId, world: $18.worldId, content: { text: `Action ${D.name} ${H}`, actions: [D.name], actionStatus: H, actionId: g, type: "agent_action", thought: T, actionResult: c, source: (_i2 = $18.content) == null ? void 0 : _i2.source } });
          } catch (j) {
            let H = j instanceof Error ? j.message : String(j);
            this.logger.error(`Failed to emit ACTION_COMPLETED event for action ${D.name} (${g}): ${H}`);
          }
          if (P) for (let j of p) await P(j);
          let U = { id: g, entityId: this.agentId, roomId: $18.roomId, worldId: $18.worldId, content: { text: (c == null ? void 0 : c.text) || `Executed action: ${D.name}`, source: "action", type: "action_result", actionName: D.name, actionStatus: (c == null ? void 0 : c.success) ? "completed" : "failed", actionResult: q$ ? { legacy: s } : c, runId: z, ...J && { planStep: `${J.currentStep}/${J.totalSteps}`, planThought: J.thought } }, metadata: { type: "action_result", actionName: D.name, runId: z, parentRunId: O, actionId: g, ...J && { totalSteps: J.totalSteps, currentStep: J.currentStep } } };
          await this.createMemory(U, "messages"), this.logger.debug(`Action ${D.name} completed`, JSON.stringify({ isLegacyReturn: q$, result: q$ ? s : void 0, hasValues: c ? !!c.values : false, hasData: c ? !!c.data : false, hasText: c ? !!c.text : false })), await this.adapter.log({ entityId: $18.entityId, roomId: $18.roomId, type: "action", body: { action: D.name, actionId: g, message: $18.content.text, messageId: $18.id, state: N, responses: q, result: q$ ? { legacy: s } : c, isLegacyReturn: q$, prompts: ((_j2 = this.currentActionContext) == null ? void 0 : _j2.prompts) || [], promptCount: ((_k = this.currentActionContext) == null ? void 0 : _k.prompts.length) || 0, runId: z, parentRunId: O, ...J && { planStep: `${J.currentStep}/${J.totalSteps}`, planThought: J.thought } } }), this.currentActionContext = void 0;
        } catch (g) {
          let b = g instanceof Error ? g.message : String(g);
          if (this.logger.error(g), J && J.steps[X]) J = this.updateActionStep(J, X, { status: "failed", error: b });
          this.currentActionContext = void 0;
          let y = { success: false, data: { actionName: D.name, error: b, errorObject: g } };
          M.push(y);
          let p = { id: Iq(), content: { thought: b, source: "auto", type: "action_result", actionName: D.name, actionStatus: "failed", error: b, runId: z, ...J && { planStep: `${J.currentStep}/${J.totalSteps}`, planThought: J.thought } }, entityId: this.agentId, roomId: $18.roomId, worldId: $18.worldId, metadata: { type: "action_result", actionName: D.name, runId: z, parentRunId: O, error: true, ...J && { totalSteps: J.totalSteps, currentStep: J.currentStep } } };
          if (await this.createMemory(p, "messages"), (g == null ? void 0 : g.critical) || (g == null ? void 0 : g.code) === "CRITICAL_ERROR") throw g;
        }
        X++;
      }
      if ($18.id) this.stateCache.set(`${$18.id}_action_results`, { values: { actionResults: M }, data: { actionResults: M, actionPlan: J }, text: JSON.stringify(M) });
    }
  }
  getActionResults($18) {
    var _a2, _b2, _c;
    return ((_c = (_b2 = (_a2 = this.stateCache) == null ? void 0 : _a2.get(`${$18}_action_results`)) == null ? void 0 : _b2.data) == null ? void 0 : _c.actionResults) || [];
  }
  async evaluate($18, q, K, P, _) {
    try {
      let Y = this.evaluators.map(async (z) => {
        try {
          if (!z.handler) return null;
          if (!K && !z.alwaysRun) return null;
          if (await z.validate(this, $18, q)) return z;
          return null;
        } catch (J) {
          return this.logger.error({ error: J, evaluatorName: z.name }, `Error validating evaluator ${z.name}`), null;
        }
      }), O = (await Promise.all(Y)).filter(Boolean);
      if (O.length === 0) return [];
      return q = await this.composeState($18, ["RECENT_MESSAGES", "EVALUATORS"]), await Promise.all(O.map(async (z) => {
        try {
          if (z.handler) await z.handler(this, $18, q, {}, P, _), this.adapter.log({ entityId: $18.entityId, roomId: $18.roomId, type: "evaluator", body: { evaluator: z.name, messageId: $18.id, message: $18.content.text, state: q, runId: this.getCurrentRunId() } });
        } catch (J) {
          this.logger.error({ error: J, evaluatorName: z.name }, `Error executing evaluator ${z.name}`);
        }
      })), O;
    } catch (Y) {
      return this.logger.error({ error: Y, messageId: $18.id, roomId: $18.roomId }, "Error in evaluate method"), [];
    }
  }
  async ensureConnections($18, q, K, P) {
    var _a2, _b2;
    if (!$18) {
      console.trace(), this.logger.error("ensureConnections - no entities");
      return;
    }
    if (!q || q.length === 0) {
      console.trace(), this.logger.error("ensureConnections - no rooms");
      return;
    }
    await this.ensureWorldExists({ ...P, agentId: this.agentId });
    let _ = q[0], Y = (b, y) => b.reduce((p, n, s) => {
      if (s % y === 0) p.push([]);
      return p[p.length - 1].push(n), p;
    }, []), O = q.map((b) => b.id), J = (_a2 = await this.getRoomsByIds(O)) == null ? void 0 : _a2.map((b) => b.id), T = O.filter((b) => !(J == null ? void 0 : J.includes(b))), X = { worldId: P.id, serverId: P.serverId, source: K, agentId: this.agentId };
    if (T.length) {
      this.logger.debug("runtime/ensureConnections - create", T.length.toLocaleString(), "rooms");
      let b = q.filter((y) => T.includes(y.id)).map((y) => ({ ...y, ...X }));
      await this.createRooms(b);
    }
    let f = $18.map((b) => b.id), M = (_b2 = await this.adapter.getEntitiesByIds(f)) == null ? void 0 : _b2.map((b) => b.id), N = $18.filter((b) => !(M == null ? void 0 : M.includes(b.id))), h = { roomId: _.id, channelId: _.channelId, type: _.type }, E = { worldId: P.id, serverId: P.serverId };
    if (N.length) {
      this.logger.debug("runtime/ensureConnections - creating", N.length.toLocaleString(), "entities...");
      let b = { ...h, ...E, source: K, agentId: this.agentId }, y = N.map((n) => ({ ...n, ...b })), p = Y(y, 5e3);
      for (let n of p) await this.createEntities(n);
    }
    await this.ensureParticipantInRoom(this.agentId, _.id);
    let D = (await this.getParticipantsForRoom(_.id)).filter(Boolean), g = f.filter((b) => !D.includes(b));
    if (g.length) {
      this.logger.debug("runtime/ensureConnections - Missing", g.length.toLocaleString(), "connections in", _.id);
      let b = Y(g, 5e3);
      for (let y of b) await this.addParticipantsRoom(y, _.id);
    }
    this.logger.success("Success: Successfully connected world");
  }
  async ensureConnection({ entityId: $18, roomId: q, worldId: K, worldName: P, userName: _, name: Y, source: O, type: z, channelId: J, serverId: T, userId: X, metadata: f }) {
    var _a2, _b2, _c;
    if (!K && T) K = qK(this, T);
    let V = [Y, _].filter(Boolean), M = { [O]: { id: X, name: Y, userName: _ } };
    try {
      let N = await this.getEntityById($18);
      if (!N) try {
        if (await this.createEntity({ id: $18, names: V, metadata: M, agentId: this.agentId })) this.logger.debug(`Created new entity ${$18} for user ${Y || _ || "unknown"}`);
        else throw Error(`Failed to create entity ${$18}`);
      } catch (h) {
        if (((_a2 = h.message) == null ? void 0 : _a2.includes("duplicate key")) || h.code === "23505") this.logger.debug(`Entity ${$18} exists in database but not for this agent. This is normal in multi-agent setups.`);
        else throw h;
      }
      else await this.adapter.updateEntity({ id: $18, names: [.../* @__PURE__ */ new Set([...N.names || [], ...V])].filter(Boolean), metadata: { ...N.metadata, [O]: { ...(_b2 = N.metadata) == null ? void 0 : _b2[O], id: X, name: Y, userName: _ } }, agentId: this.agentId });
      await this.ensureWorldExists({ id: K, name: P || T ? `World for server ${T}` : `World for room ${q}`, agentId: this.agentId, serverId: T || "default", metadata: f }), await this.ensureRoomExists({ id: q, name: Y || "default", source: O || "default", type: z || "DM", channelId: J, serverId: T, worldId: K });
      try {
        await this.ensureParticipantInRoom($18, q);
      } catch (h) {
        if ((_c = h.message) == null ? void 0 : _c.includes("not found")) {
          if (!await this.addParticipant($18, q)) throw Error(`Failed to add participant ${$18} to room ${q}`);
          this.logger.debug(`Added participant ${$18} to room ${q} directly`);
        } else throw h;
      }
      await this.ensureParticipantInRoom(this.agentId, q), this.logger.debug(`Success: Successfully connected entity ${$18} in room ${q}`);
    } catch (N) {
      throw this.logger.error(`Failed to ensure connection: ${N instanceof Error ? N.message : String(N)}`), N;
    }
  }
  async ensureParticipantInRoom($18, q) {
    let K = await this.getEntityById($18);
    if (!K && $18 !== this.agentId) this.logger.warn(`Entity ${$18} not directly accessible to agent ${this.agentId}. Will attempt to add as participant anyway.`);
    else if (!K && $18 === this.agentId) throw Error(`Agent entity ${$18} not found, cannot add as participant.`);
    else if (!K) throw Error(`User entity ${$18} not found, cannot add as participant.`);
    if (!(await this.adapter.getParticipantsForRoom(q)).includes($18)) {
      if (!await this.addParticipant($18, q)) throw Error(`Failed to add participant ${$18} to room ${q}`);
      if ($18 === this.agentId) this.logger.debug(`Agent ${this.character.name} linked to room ${q} successfully.`);
      else this.logger.debug(`User ${$18} linked to room ${q} successfully.`);
    }
  }
  async removeParticipant($18, q) {
    return await this.adapter.removeParticipant($18, q);
  }
  async getParticipantsForEntity($18) {
    return await this.adapter.getParticipantsForEntity($18);
  }
  async getParticipantsForRoom($18) {
    return await this.adapter.getParticipantsForRoom($18);
  }
  async addParticipant($18, q) {
    return await this.adapter.addParticipantsRoom([$18], q);
  }
  async addParticipantsRoom($18, q) {
    return await this.adapter.addParticipantsRoom($18, q);
  }
  async ensureWorldExists({ id: $18, name: q, serverId: K, metadata: P }) {
    if (!await this.getWorld($18)) this.logger.debug("Creating world:", JSON.stringify({ id: $18, name: q, serverId: K, agentId: this.agentId })), await this.adapter.createWorld({ id: $18, name: q, agentId: this.agentId, serverId: K || "default", metadata: P }), this.logger.debug(`World ${$18} created successfully.`);
  }
  async ensureRoomExists({ id: $18, name: q, source: K, type: P, channelId: _, serverId: Y, worldId: O, metadata: z }) {
    if (!O) throw Error("worldId is required");
    if (!await this.getRoom($18)) await this.createRoom({ id: $18, name: q, agentId: this.agentId, source: K, type: P, channelId: _, serverId: Y, worldId: O, metadata: z }), this.logger.debug(`Room ${$18} created successfully.`);
  }
  async composeState($18, q = null, K = false, P = false) {
    var _a2;
    let _ = K ? q : null, Y = { values: {}, data: {}, text: "" }, O = P || !$18.id ? Y : await this.stateCache.get($18.id) || Y, z = /* @__PURE__ */ new Set();
    if (_ && _.length > 0) _.forEach((h) => z.add(h));
    else this.providers.filter((h) => !h.private && !h.dynamic).forEach((h) => z.add(h.name));
    if (!_ && q && q.length > 0) q.forEach((h) => z.add(h));
    let J = Array.from(new Set(this.providers.filter((h) => z.has(h.name)))).sort((h, E) => (h.position || 0) - (E.position || 0)), T = await Promise.all(J.map(async (h) => {
      let E = Date.now();
      try {
        let I = await h.get(this, $18, O), D = Date.now() - E;
        if (D > 100) this.logger.debug(`${h.name} Provider took ${D}ms to respond`);
        return { ...I, providerName: h.name };
      } catch (I) {
        return console.error("provider error", h.name, I), { values: {}, text: "", data: {}, providerName: h.name };
      }
    })), X = { ...((_a2 = O.data) == null ? void 0 : _a2.providers) || {} };
    for (let h of T) X[h.providerName] = h;
    let f = [];
    for (let h of J) {
      let E = X[h.name];
      if (E && E.text && E.text.trim() !== "") f.push(E.text);
    }
    let V = f.join(`
`), M = { ...O.values || {} };
    for (let h of J) {
      let E = X[h.name];
      if (E && E.values && typeof E.values === "object") Object.assign(M, E.values);
    }
    for (let h in X) if (!J.some((E) => E.name === h)) {
      let E = X[h];
      if (E && E.values && typeof E.values === "object") Object.assign(M, E.values);
    }
    let N = { values: { ...M, providers: V }, data: { ...O.data || {}, providers: X }, text: V };
    if ($18.id) this.stateCache.set($18.id, N);
    return N;
  }
  getService($18) {
    let q = this.services.get($18);
    if (!q || q.length === 0) return this.logger.debug(`Service ${$18} not found`), null;
    return q[0];
  }
  getTypedService($18) {
    return this.getService($18);
  }
  getServicesByType($18) {
    let q = this.services.get($18);
    if (!q || q.length === 0) return this.logger.debug(`No services found for type ${$18}`), [];
    return q;
  }
  getRegisteredServiceTypes() {
    return Array.from(this.services.keys());
  }
  hasService($18) {
    let q = this.services.get($18);
    return q !== void 0 && q.length > 0;
  }
  getServiceRegistrationStatus($18) {
    return this.serviceRegistrationStatus.get($18) || "unknown";
  }
  getServiceHealth() {
    let $18 = {};
    for (let [q, K] of this.services) $18[q] = { status: this.getServiceRegistrationStatus(q), instances: K.length, hasPromise: this.servicePromises.has(q) };
    for (let [q, K] of this.serviceRegistrationStatus) if (!$18[q]) $18[q] = { status: K, instances: 0, hasPromise: this.servicePromises.has(q) };
    return $18;
  }
  async registerService($18) {
    var _a2, _b2, _c, _d2, _e;
    let q = $18.serviceType, K = $18.name || "Unknown";
    if (!q) {
      this.logger.warn(`Service ${K} is missing serviceType. Please define a static serviceType property.`);
      return;
    }
    this.logger.info(`Registering service: ${q}`), this.serviceRegistrationStatus.set(q, "registering");
    try {
      this.logger.debug(`Service ${q} waiting for initialization...`);
      let P = new Promise((O, z) => {
        setTimeout(() => {
          z(Error(`Service ${q} registration timed out waiting for runtime initialization (30s timeout)`));
        }, 3e4);
      });
      if (await Promise.race([this.initPromise, P]), typeof $18.start !== "function") throw Error(`Service ${q} does not have a static start method. All services must implement static async start(runtime: IAgentRuntime): Promise<Service>.`);
      let _ = await $18.start(this);
      if (!_) throw Error(`Service ${q}  start() method returned null or undefined. It must return a Service instance.`);
      if (!this.services.has(q)) this.services.set(q, []);
      if (!this.serviceTypes.has(q)) this.serviceTypes.set(q, []);
      this.services.get(q).push(_), this.serviceTypes.get(q).push($18);
      let Y = this.servicePromiseHandlers.get(q);
      if (Y) Y.resolve(_), this.servicePromiseHandlers.delete(q);
      else this.logger.debug(`${this.character.name} - Service ${q} has no servicePromiseHandler`);
      if (typeof $18.registerSendHandlers === "function") $18.registerSendHandlers(this, _);
      this.serviceRegistrationStatus.set(q, "registered"), this.logger.info(`Service ${q} registered successfully`);
    } catch (P) {
      let _ = P instanceof Error ? P.message : String(P), Y = P instanceof Error ? P.stack : void 0;
      if (this.logger.error(`Failed to register service ${q}: ${_}`), (_a2 = P == null ? void 0 : P.message) == null ? void 0 : _a2.includes("timed out waiting for runtime initialization")) this.logger.error(`Service ${q} failed due to runtime initialization timeout. Check if runtime.initialize() is being called and completing successfully.`);
      else if ((_b2 = P == null ? void 0 : P.message) == null ? void 0 : _b2.includes("Not implemented")) {
        if (this.logger.error(`Service ${q} failed because it does not implement the static start() method. All services must override the base Service.start() method. Add: static async start(runtime: IAgentRuntime): Promise<${K}> { return new ${K}(runtime); }`), Y) this.logger.debug(`Stack trace: ${Y}`);
      } else if (((_c = P == null ? void 0 : P.message) == null ? void 0 : _c.includes("Service")) && ((_d2 = P == null ? void 0 : P.message) == null ? void 0 : _d2.includes("failed to start"))) this.logger.error(`Service ${q} (${K}) failed to start. Check service implementation and dependencies.`);
      else if ((_e = P == null ? void 0 : P.message) == null ? void 0 : _e.includes("does not have a static start method")) this.logger.error(`Service ${q} (${K}) is missing required static start() method implementation.`);
      else if (Y) this.logger.debug(`Service ${q} (${K}) error stack: ${Y}`);
      this.serviceRegistrationStatus.set(q, "failed");
      let O = this.servicePromiseHandlers.get(q);
      if (O) O.reject(P), this.servicePromiseHandlers.delete(q), this.servicePromises.delete(q);
      throw P;
    }
  }
  _createServiceResolver($18) {
    let q, K;
    if (this.servicePromises.set($18, new Promise((P, _) => {
      q = P, K = _;
    })), !q) throw Error(`Failed to create resolver for service ${$18}`);
    if (!K) throw Error(`Failed to create rejecter for service ${$18}`);
    return this.servicePromiseHandlers.set($18, { resolve: q, reject: K }), this.servicePromises.get($18);
  }
  getServiceLoadPromise($18) {
    let q = this.servicePromises.get($18);
    if (!q) q = this._createServiceResolver($18);
    return q;
  }
  registerModel($18, q, K, P) {
    var _a2, _b2;
    let _ = typeof $18 === "string" ? $18 : M6[$18];
    if (!this.models.has(_)) this.models.set(_, []);
    let Y = Date.now();
    (_a2 = this.models.get(_)) == null ? void 0 : _a2.push({ handler: q, provider: K, priority: P || 0, registrationOrder: Y }), (_b2 = this.models.get(_)) == null ? void 0 : _b2.sort((O, z) => {
      if ((z.priority || 0) !== (O.priority || 0)) return (z.priority || 0) - (O.priority || 0);
      return (O.registrationOrder || 0) - (z.registrationOrder || 0);
    });
  }
  getModel($18, q) {
    let K = typeof $18 === "string" ? $18 : M6[$18], P = this.models.get(K);
    if (!(P == null ? void 0 : P.length)) return;
    if (q) {
      let _ = P.find((Y) => Y.provider === q);
      if (_) return this.logger.debug(`[AgentRuntime][${this.character.name}] Using model ${K} from provider ${q}`), _.handler;
      else this.logger.warn(`[AgentRuntime][${this.character.name}] No model found for provider ${q}`);
    }
    return this.logger.debug(`[AgentRuntime][${this.character.name}] Using model ${K} from provider ${P[0].provider}`), P[0].handler;
  }
  getModelSettings($18) {
    let q = {}, K = (z, J) => {
      if ($18) {
        let V = `${$18}_${z}`, M = this.getSetting(V);
        if (M !== null && M !== void 0) {
          let N = Number(M);
          if (!isNaN(N)) return N;
        }
      }
      let T = `DEFAULT_${z}`, X = this.getSetting(T);
      if (X !== null && X !== void 0) {
        let V = Number(X);
        if (!isNaN(V)) return V;
      }
      let f = this.getSetting(J);
      if (f !== null && f !== void 0) {
        let V = Number(f);
        if (!isNaN(V)) return V;
      }
      return null;
    }, P = K("MAX_TOKENS", _P.MODEL_MAX_TOKEN), _ = K("TEMPERATURE", _P.MODEL_TEMPERATURE), Y = K("FREQUENCY_PENALTY", _P.MODEL_FREQ_PENALTY), O = K("PRESENCE_PENALTY", _P.MODEL_PRESENCE_PENALTY);
    if (P !== null) q.maxTokens = P;
    if (_ !== null) q.temperature = _;
    if (Y !== null) q.frequencyPenalty = Y;
    if (O !== null) q.presencePenalty = O;
    return Object.keys(q).length > 0 ? q : null;
  }
  async useModel($18, q, K) {
    var _a2, _b2;
    let P = typeof $18 === "string" ? $18 : M6[$18], _ = (q == null ? void 0 : q.prompt) || (q == null ? void 0 : q.input) || (Array.isArray(q == null ? void 0 : q.messages) ? JSON.stringify(q.messages) : null), Y = this.getModel(P, K);
    if (!Y) {
      let T = `No handler found for delegate type: ${P}`;
      throw Error(T);
    }
    if (![M6.TRANSCRIPTION, M6.IMAGE, M6.AUDIO, M6.VIDEO].includes(P)) this.logger.debug(`[useModel] ${P} input: ` + JSON.stringify(q, CJ(), 2).replace(/\\n/g, `
`));
    else {
      let T = "unknown size";
      if (Buffer.isBuffer(q)) T = `${q.length} bytes`;
      else if (typeof Blob < "u" && q instanceof Blob) T = `${q.size} bytes`;
      else if (typeof q === "object" && q !== null) {
        if ("audio" in q && Buffer.isBuffer(q.audio)) T = `${q.audio.length} bytes`;
        else if ("audio" in q && typeof Blob < "u" && q.audio instanceof Blob) T = `${q.audio.size} bytes`;
      }
      this.logger.debug(`[useModel] ${P} input: <binary data: ${T}>`);
    }
    let z;
    if (q === null || q === void 0 || typeof q !== "object" || Array.isArray(q) || __.isBuffer(q)) z = q;
    else {
      let T = this.getModelSettings(P);
      if (T) z = { ...T, ...q };
      else z = q;
    }
    let J = typeof performance < "u" && typeof performance.now === "function" ? performance.now() : Date.now();
    try {
      let T = await Y(this, z), X = (typeof performance < "u" && typeof performance.now === "function" ? performance.now() : Date.now()) - J;
      if (this.logger.debug(`[useModel] ${P} output (took ${Number(X.toFixed(2)).toLocaleString()}ms):`, Array.isArray(T) ? `${JSON.stringify(T.slice(0, 5))}...${JSON.stringify(T.slice(-5))} (${T.length} items)` : JSON.stringify(T, CJ(), 2).replace(/\\n/g, `
`)), P !== M6.TEXT_EMBEDDING && _) {
        if (this.currentActionContext) this.currentActionContext.prompts.push({ modelType: P, prompt: _, timestamp: Date.now() });
      }
      return this.adapter.log({ entityId: this.agentId, roomId: this.agentId, body: { modelType: $18, modelKey: P, params: { ...typeof q === "object" && !Array.isArray(q) && q ? q : {}, prompt: _ }, prompt: _, runId: this.getCurrentRunId(), timestamp: Date.now(), executionTime: X, provider: K || ((_b2 = (_a2 = this.models.get(P)) == null ? void 0 : _a2[0]) == null ? void 0 : _b2.provider) || "unknown", actionContext: this.currentActionContext ? { actionName: this.currentActionContext.actionName, actionId: this.currentActionContext.actionId } : void 0, response: Array.isArray(T) && T.every((f) => typeof f === "number") ? "[array]" : T }, type: `useModel:${P}` }), T;
    } catch (T) {
      throw T;
    }
  }
  async generateText($18, q) {
    var _a2, _b2;
    if (!($18 == null ? void 0 : $18.trim())) throw Error("Input cannot be empty");
    let K = (q == null ? void 0 : q.includeCharacter) ?? true, P = (q == null ? void 0 : q.modelType) ?? M6.TEXT_LARGE, _ = $18;
    if (K && this.character) {
      let z = this.character, J = [], T = Array.isArray(z.bio) ? z.bio.join(" ") : z.bio;
      if (T) J.push(`# About ${z.name}
${T}`);
      if (z.system) J.push(z.system);
      let X = [...((_a2 = z.style) == null ? void 0 : _a2.all) || [], ...((_b2 = z.style) == null ? void 0 : _b2.chat) || []];
      if (X.length > 0) J.push(`Style:
${X.map((f) => `- ${f}`).join(`
`)}`);
      if (J.length > 0) _ = `${J.join(`

`)}

${$18}`;
    }
    let Y = { prompt: _, maxTokens: q == null ? void 0 : q.maxTokens, temperature: q == null ? void 0 : q.temperature, frequencyPenalty: q == null ? void 0 : q.frequencyPenalty, presencePenalty: q == null ? void 0 : q.presencePenalty, stopSequences: q == null ? void 0 : q.stopSequences };
    return { text: await this.useModel(P, Y) };
  }
  registerEvent($18, q) {
    if (!this.events[$18]) this.events[$18] = [];
    this.events[$18].push(q);
  }
  getEvent($18) {
    return this.events[$18];
  }
  async emitEvent($18, q) {
    let K = Array.isArray($18) ? $18 : [$18];
    for (let P of K) {
      let _ = this.events[P];
      if (!_) continue;
      try {
        let Y = { runtime: this };
        if (typeof q === "object" && q) Y = { ...q, ...Y };
        await Promise.all(_.map((O) => O(Y)));
      } catch (Y) {
        this.logger.error(`Error during emitEvent for ${P} (handler execution): ${Y}`);
      }
    }
  }
  async ensureEmbeddingDimension() {
    if (this.logger.debug(`[AgentRuntime][${this.character.name}] Starting ensureEmbeddingDimension`), !this.adapter) throw Error(`[AgentRuntime][${this.character.name}] Database adapter not initialized before ensureEmbeddingDimension`);
    try {
      if (!this.getModel(M6.TEXT_EMBEDDING)) throw Error(`[AgentRuntime][${this.character.name}] No TEXT_EMBEDDING model registered`);
      this.logger.debug(`[AgentRuntime][${this.character.name}] Getting embedding dimensions`);
      let q = await this.useModel(M6.TEXT_EMBEDDING, null);
      if (!q || !q.length) throw Error(`[AgentRuntime][${this.character.name}] Invalid embedding received`);
      this.logger.debug(`[AgentRuntime][${this.character.name}] Setting embedding dimension: ${q.length}`), await this.adapter.ensureEmbeddingDimension(q.length), this.logger.debug(`[AgentRuntime][${this.character.name}] Successfully set embedding dimension`);
    } catch ($18) {
      throw this.logger.debug(`[AgentRuntime][${this.character.name}] Error in ensureEmbeddingDimension: ${$18}`), $18;
    }
  }
  registerTaskWorker($18) {
    if (this.taskWorkers.has($18.name)) this.logger.warn(`Task definition ${$18.name} already registered. Will be overwritten.`);
    this.taskWorkers.set($18.name, $18);
  }
  getTaskWorker($18) {
    return this.taskWorkers.get($18);
  }
  get db() {
    return this.adapter.db;
  }
  async init() {
    await this.adapter.init();
  }
  async close() {
    if (this.adapter) await this.adapter.close();
  }
  async getAgent($18) {
    return await this.adapter.getAgent($18);
  }
  async getAgents() {
    return await this.adapter.getAgents();
  }
  async createAgent($18) {
    return await this.adapter.createAgent($18);
  }
  async updateAgent($18, q) {
    return await this.adapter.updateAgent($18, q);
  }
  async deleteAgent($18) {
    return await this.adapter.deleteAgent($18);
  }
  async ensureAgentExists($18) {
    var _a2, _b2, _c, _d2;
    if (!$18.id) throw Error("Agent id is required");
    let q = await this.adapter.getAgent($18.id);
    if (q) {
      let _ = { ...q.settings, ...$18.settings }, Y = typeof ((_a2 = q.settings) == null ? void 0 : _a2.secrets) === "object" || typeof ((_b2 = $18.settings) == null ? void 0 : _b2.secrets) === "object" ? { ...typeof ((_c = q.settings) == null ? void 0 : _c.secrets) === "object" ? q.settings.secrets : {}, ...typeof ((_d2 = $18.settings) == null ? void 0 : _d2.secrets) === "object" ? $18.settings.secrets : {} } : void 0;
      if (Y) _.secrets = Y;
      let O = { ...q, ...$18, settings: _, id: $18.id, updatedAt: Date.now() };
      await this.adapter.updateAgent($18.id, O);
      let z = await this.adapter.getAgent($18.id);
      if (!z) throw Error(`Failed to retrieve agent after update: ${$18.id}`);
      return this.logger.debug(`Updated existing agent ${$18.id} on restart (merged ${Object.keys(q.settings || {}).length} DB settings with ${Object.keys($18.settings || {}).length} character settings)`), z;
    }
    let K = { ...$18, id: $18.id };
    if (!await this.adapter.createAgent(K)) throw Error(`Failed to create agent: ${$18.id}`);
    return this.logger.debug(`Created new agent ${$18.id}`), K;
  }
  async getEntityById($18) {
    let q = await this.adapter.getEntitiesByIds([$18]);
    if (!(q == null ? void 0 : q.length)) return null;
    return q[0];
  }
  async getEntitiesByIds($18) {
    return await this.adapter.getEntitiesByIds($18);
  }
  async getEntitiesForRoom($18, q) {
    return await this.adapter.getEntitiesForRoom($18, q);
  }
  async createEntity($18) {
    if (!$18.agentId) $18.agentId = this.agentId;
    return await this.createEntities([$18]);
  }
  async createEntities($18) {
    return $18.forEach((q) => {
      q.agentId = this.agentId;
    }), await this.adapter.createEntities($18);
  }
  async updateEntity($18) {
    await this.adapter.updateEntity($18);
  }
  async getComponent($18, q, K, P) {
    return await this.adapter.getComponent($18, q, K, P);
  }
  async getComponents($18, q, K) {
    return await this.adapter.getComponents($18, q, K);
  }
  async createComponent($18) {
    return await this.adapter.createComponent($18);
  }
  async updateComponent($18) {
    await this.adapter.updateComponent($18);
  }
  async deleteComponent($18) {
    await this.adapter.deleteComponent($18);
  }
  async addEmbeddingToMemory($18) {
    if ($18.embedding) return $18;
    let q = $18.content.text;
    if (!q) throw Error("Cannot generate embedding: Memory content is empty");
    try {
      $18.embedding = await this.useModel(M6.TEXT_EMBEDDING, { text: q });
    } catch (K) {
      this.logger.error("Failed to generate embedding:", K), $18.embedding = await this.useModel(M6.TEXT_EMBEDDING, null);
    }
    return $18;
  }
  async queueEmbeddingGeneration($18, q) {
    var _a2;
    if (q = q || "normal", !$18) return;
    if ($18.embedding) return;
    if (!((_a2 = $18.content) == null ? void 0 : _a2.text)) {
      this.logger.debug("Skipping embedding generation for memory without text content");
      return;
    }
    await this.emitEvent("EMBEDDING_GENERATION_REQUESTED", { runtime: this, memory: $18, priority: q, source: "runtime", retryCount: 0, maxRetries: 3, runId: this.getCurrentRunId() });
  }
  async getMemories($18) {
    return await this.adapter.getMemories($18);
  }
  async getAllMemories() {
    let $18 = ["memories", "messages", "facts", "documents"], q = [];
    for (let K of $18) try {
      let P = await this.adapter.getMemories({ agentId: this.agentId, tableName: K, count: 1e4 });
      q.push(...P);
    } catch (P) {
      this.logger.debug(`Failed to get memories from table ${K}: ${P}`);
    }
    return q;
  }
  async getMemoryById($18) {
    return await this.adapter.getMemoryById($18);
  }
  async getMemoriesByIds($18, q) {
    return await this.adapter.getMemoriesByIds($18, q);
  }
  async getMemoriesByRoomIds($18) {
    return await this.adapter.getMemoriesByRoomIds($18);
  }
  async getCachedEmbeddings($18) {
    return await this.adapter.getCachedEmbeddings($18);
  }
  async log($18) {
    await this.adapter.log($18);
  }
  async searchMemories($18) {
    let q = await this.adapter.searchMemories($18);
    if ($18.query) return await this.rerankMemories($18.query, q);
    return q;
  }
  async rerankMemories($18, q) {
    let K = q.map((Y) => ({ title: Y.id, content: Y.content.text }));
    return new gJ(K).search($18, q.length).map((Y) => q[Y.index]);
  }
  async createMemory($18, q, K) {
    if (K !== void 0) $18.unique = K;
    return await this.adapter.createMemory($18, q, K);
  }
  async updateMemory($18) {
    return await this.adapter.updateMemory($18);
  }
  async deleteMemory($18) {
    await this.adapter.deleteMemory($18);
  }
  async deleteManyMemories($18) {
    await this.adapter.deleteManyMemories($18);
  }
  async clearAllAgentMemories() {
    this.logger.info(`Clearing all memories for agent ${this.character.name} (${this.agentId})`);
    let q = (await this.getAllMemories()).map((K) => K.id).filter((K) => K !== void 0);
    if (q.length === 0) {
      this.logger.info("No memories found to delete");
      return;
    }
    this.logger.info(`Found ${q.length} memories to delete`), await this.adapter.deleteManyMemories(q), this.logger.info(`Successfully cleared all ${q.length} memories for agent`);
  }
  async deleteAllMemories($18, q) {
    await this.adapter.deleteAllMemories($18, q);
  }
  async countMemories($18, q, K) {
    return await this.adapter.countMemories($18, q, K);
  }
  async getLogs($18) {
    return await this.adapter.getLogs($18);
  }
  async deleteLog($18) {
    await this.adapter.deleteLog($18);
  }
  async createWorld($18) {
    return await this.adapter.createWorld($18);
  }
  async getWorld($18) {
    return await this.adapter.getWorld($18);
  }
  async removeWorld($18) {
    await this.adapter.removeWorld($18);
  }
  async getAllWorlds() {
    return await this.adapter.getAllWorlds();
  }
  async updateWorld($18) {
    await this.adapter.updateWorld($18);
  }
  async getRoom($18) {
    let q = await this.adapter.getRoomsByIds([$18]);
    if (!(q == null ? void 0 : q.length)) return null;
    return q[0];
  }
  async getRoomsByIds($18) {
    return await this.adapter.getRoomsByIds($18);
  }
  async createRoom({ id: $18, name: q, source: K, type: P, channelId: _, serverId: Y, worldId: O }) {
    if (!O) throw Error("worldId is required");
    let z = await this.adapter.createRooms([{ id: $18, name: q, source: K, type: P, channelId: _, serverId: Y, worldId: O }]);
    if (!z.length) throw Error("Failed to create room");
    return z[0];
  }
  async createRooms($18) {
    return await this.adapter.createRooms($18);
  }
  async deleteRoom($18) {
    await this.adapter.deleteRoom($18);
  }
  async deleteRoomsByWorldId($18) {
    await this.adapter.deleteRoomsByWorldId($18);
  }
  async updateRoom($18) {
    await this.adapter.updateRoom($18);
  }
  async getRoomsForParticipant($18) {
    return await this.adapter.getRoomsForParticipant($18);
  }
  async getRoomsForParticipants($18) {
    return await this.adapter.getRoomsForParticipants($18);
  }
  async getRooms($18) {
    return await this.adapter.getRoomsByWorld($18);
  }
  async getRoomsByWorld($18) {
    return await this.adapter.getRoomsByWorld($18);
  }
  async getParticipantUserState($18, q) {
    return await this.adapter.getParticipantUserState($18, q);
  }
  async setParticipantUserState($18, q, K) {
    await this.adapter.setParticipantUserState($18, q, K);
  }
  async createRelationship($18) {
    return await this.adapter.createRelationship($18);
  }
  async updateRelationship($18) {
    await this.adapter.updateRelationship($18);
  }
  async getRelationship($18) {
    return await this.adapter.getRelationship($18);
  }
  async getRelationships($18) {
    return await this.adapter.getRelationships($18);
  }
  async getCache($18) {
    return await this.adapter.getCache($18);
  }
  async setCache($18, q) {
    return await this.adapter.setCache($18, q);
  }
  async deleteCache($18) {
    return await this.adapter.deleteCache($18);
  }
  async createTask($18) {
    return await this.adapter.createTask($18);
  }
  async getTasks($18) {
    return await this.adapter.getTasks($18);
  }
  async getTask($18) {
    return await this.adapter.getTask($18);
  }
  async getTasksByName($18) {
    return await this.adapter.getTasksByName($18);
  }
  async updateTask($18, q) {
    await this.adapter.updateTask($18, q);
  }
  async deleteTask($18) {
    await this.adapter.deleteTask($18);
  }
  on($18, q) {
    var _a2;
    if (!this.eventHandlers.has($18)) this.eventHandlers.set($18, []);
    (_a2 = this.eventHandlers.get($18)) == null ? void 0 : _a2.push(q);
  }
  off($18, q) {
    if (!this.eventHandlers.has($18)) return;
    let K = this.eventHandlers.get($18), P = K.indexOf(q);
    if (P !== -1) K.splice(P, 1);
  }
  emit($18, q) {
    if (!this.eventHandlers.has($18)) return;
    for (let K of this.eventHandlers.get($18)) K(q);
  }
  async sendControlMessage($18) {
    try {
      let { roomId: q, action: K, target: P } = $18, _ = { type: "control", payload: { action: K, target: P }, roomId: q };
      await this.emitEvent("CONTROL_MESSAGE", { runtime: this, message: _, source: "agent" }), this.logger.debug(`Sent control message: ${K} to room ${q}`);
    } catch (q) {
      this.logger.error(`Error sending control message: ${q}`);
    }
  }
  registerSendHandler($18, q) {
    if (this.sendHandlers.has($18)) this.logger.warn(`Send handler for source '${$18}' already registered. Overwriting.`);
    this.sendHandlers.set($18, q), this.logger.info(`Registered send handler for source: ${$18}`);
  }
  async sendMessageToTarget($18, q) {
    let K = this.sendHandlers.get($18.source);
    if (!K) {
      let P = `No send handler registered for source: ${$18.source}`;
      throw this.logger.error(P), Error(P);
    }
    try {
      await K(this, $18, q);
    } catch (P) {
      throw this.logger.error(`Error executing send handler for source ${$18.source}:`, P), P;
    }
  }
  async getMemoriesByWorldId($18) {
    return await this.adapter.getMemoriesByWorldId($18);
  }
  async runMigrations($18) {
    if (this.adapter && "runMigrations" in this.adapter) await this.adapter.runMigrations($18);
    else this.logger.warn("Database adapter does not support migrations.");
  }
  async isReady() {
    if (!this.adapter) throw Error("Database adapter not registered");
    return await this.adapter.isReady();
  }
  hasElizaOS() {
    return this.elizaOS !== void 0;
  }
};
_$ = new WeakMap();
async function jB($18) {
  let q = {};
  for (let [P, _] of Object.entries(process.env)) if (_ !== void 0) q[P] = _;
  if (!$18.settings) $18.settings = {};
  let K = $18.settings.secrets && typeof $18.settings.secrets === "object" ? { ...$18.settings.secrets } : {};
  return $18.settings.secrets = { ...q, ...K }, true;
}
async function SM($18, q) {
  if (d4() !== "node") return false;
  if (q == null ? void 0 : q.skipEnvMerge) return false;
  return jB($18);
}
function vB() {
  var _a2, _b2;
  try {
    return typeof process < "u" && (((_a2 = process.versions) == null ? void 0 : _a2.node) !== void 0 || ((_b2 = process.versions) == null ? void 0 : _b2.bun) !== void 0);
  } catch {
    return false;
  }
}
function yJ() {
  if (vB()) return dq(), J6(mq);
  return $P("crypto-browserify");
}
function uJ($18) {
  let K = yJ().createHash($18);
  return { update(P) {
    return K.update(P), this;
  }, digest() {
    return new Uint8Array(K.digest());
  } };
}
function MM($18, q, K) {
  if ($18 !== "aes-256-cbc") throw Error(`Unsupported algorithm: ${$18}. Only 'aes-256-cbc' is currently supported.`);
  return yJ().createCipheriv($18, q, K);
}
function NM($18, q, K) {
  if ($18 !== "aes-256-cbc") throw Error(`Unsupported algorithm: ${$18}. Only 'aes-256-cbc' is currently supported.`);
  return yJ().createDecipheriv($18, q, K);
}
function WB($18) {
  return { name: $18.name, description: $18.description, usageDescription: $18.usageDescription || "", value: null, required: $18.required, validation: $18.validation || void 0, public: $18.public || false, secret: $18.secret || false, dependsOn: $18.dependsOn || [], onSetAction: $18.onSetAction || void 0, visibleIf: $18.visibleIf || void 0 };
}
var e4 = null;
var xJ = false;
var HB = 3e5;
function x_() {
  let $18 = q_("SECRET_SALT", "secretsalt") || "secretsalt", q = Date.now();
  if (e4 !== null) {
    if (q - e4.timestamp < HB && e4.value === $18) return e4.value;
  }
  if ($18 === "secretsalt" && !xJ) j6.warn("SECRET_SALT is not set or using default value"), xJ = true;
  return e4 = { value: $18, timestamp: q }, $18;
}
function a9$() {
  e4 = null, xJ = false;
}
function hM($18, q) {
  if ($18 === void 0 || $18 === null) return j6.debug("Attempted to encrypt undefined or null value"), $18;
  if (typeof $18 === "boolean" || typeof $18 === "number") return j6.debug("Value is a boolean or number, returning as is"), $18;
  if (typeof $18 !== "string") return j6.debug(`Value is not a string (type: ${typeof $18}), returning as is`), $18;
  let K = $18.split(":");
  if (K.length === 2) try {
    if (__.fromHex(K[0]).length === 16) return j6.debug("Value appears to be already encrypted, skipping re-encryption"), $18;
  } catch (z) {
  }
  let P = uJ("sha256").update(q).digest().slice(0, 32), _ = __.randomBytes(16), Y = MM("aes-256-cbc", P, _), O = Y.update($18, "utf8", "hex");
  return O += Y.final("hex"), `${__.toHex(_)}:${O}`;
}
function NO($18, q) {
  try {
    if ($18 === void 0 || $18 === null) return $18;
    if (typeof $18 === "boolean" || typeof $18 === "number") return $18;
    if (typeof $18 !== "string") return j6.debug(`Value is not a string (type: ${typeof $18}), returning as is`), $18;
    let K = $18.split(":");
    if (K.length !== 2) return $18;
    let P = __.fromHex(K[0]), _ = K[1];
    if (P.length !== 16) {
      if (P.length) j6.debug(`Invalid IV length (${P.length}) - expected 16 bytes`);
      return $18;
    }
    let Y = uJ("sha256").update(q).digest().slice(0, 32), O = NM("aes-256-cbc", Y, P), z = O.update(_, "hex", "utf8");
    return z += O.final("utf8"), z;
  } catch (K) {
    return j6.error(`Error decrypting value: ${K}`), $18;
  }
}
function JB($18, q) {
  let K = { ...$18 };
  if ($18.secret === true && typeof $18.value === "string" && $18.value) K.value = hM($18.value, q);
  return K;
}
function TB($18, q) {
  let K = { ...$18 };
  if ($18.secret === true && typeof $18.value === "string" && $18.value) K.value = NO($18.value, q);
  return K;
}
function wB($18, q) {
  let K = {};
  for (let [P, _] of Object.entries($18)) K[P] = JB(_, q);
  return K;
}
function RM($18, q) {
  let K = {};
  for (let [P, _] of Object.entries($18)) K[P] = TB(_, q);
  return K;
}
async function Q9$($18, q, K) {
  let P = qK($18, q), _ = await $18.getWorld(P);
  if (!_) return j6.error(`No world found for server ${q}`), false;
  if (!_.metadata) _.metadata = {};
  let Y = x_(), O = wB(K, Y);
  return _.metadata.settings = O, await $18.updateWorld(_), true;
}
async function e9$($18, q) {
  var _a2;
  let K = qK($18, q), P = await $18.getWorld(K);
  if (!P || !((_a2 = P.metadata) == null ? void 0 : _a2.settings)) return null;
  let _ = P.metadata.settings, Y = x_();
  return RM(_, Y);
}
async function s9$($18, q, K) {
  var _a2;
  if ((_a2 = q.metadata) == null ? void 0 : _a2.settings) {
    j6.info(`Onboarding state already exists for server ${q.serverId}`);
    let _ = q.metadata.settings, Y = x_();
    return RM(_, Y);
  }
  let P = {};
  if (K.settings) for (let [_, Y] of Object.entries(K.settings)) P[_] = WB(Y);
  if (!q.metadata) q.metadata = {};
  return q.metadata.settings = P, await $18.updateWorld(q), j6.info(`Initialized settings config for server ${q.serverId}`), P;
}
function $5$($18) {
  var _a2;
  let q = JSON.parse(JSON.stringify($18)), K = x_();
  if ((_a2 = q.settings) == null ? void 0 : _a2.secrets) q.settings.secrets = CM(q.settings.secrets, K);
  if (q.secrets) q.secrets = CM(q.secrets, K);
  return q;
}
function q5$($18, q) {
  var _a2;
  let K = JSON.parse(JSON.stringify($18)), P = x_();
  if ((_a2 = K.settings) == null ? void 0 : _a2.secrets) K.settings.secrets = EM(K.settings.secrets, P);
  if (K.secrets) K.secrets = EM(K.secrets, P);
  return K;
}
function CM($18, q) {
  let K = {};
  for (let [P, _] of Object.entries($18)) if (typeof _ === "string" && _) K[P] = hM(_, q);
  else K[P] = _;
  return K;
}
function EM($18, q) {
  let K = {};
  for (let [P, _] of Object.entries($18)) if (typeof _ === "string" && _) K[P] = NO(_, q);
  else K[P] = _;
  return K;
}
var IM = class {
  constructor($18) {
    __publicField(this, "serviceType");
    __publicField(this, "startFn");
    __publicField(this, "stopFn");
    __publicField(this, "description");
    this.serviceType = $18, this.description = "";
  }
  withDescription($18) {
    return this.description = $18, this;
  }
  withStart($18) {
    return this.startFn = $18, this;
  }
  withStop($18) {
    return this.stopFn = $18, this;
  }
  build() {
    var _a2;
    let $18 = this.serviceType, q = this.description, K = this.startFn, P = this.stopFn;
    return _a2 = class extends RO {
      constructor() {
        super(...arguments);
        __publicField(this, "capabilityDescription", q);
      }
      static async start(_) {
        if (!K) throw Error(`Start function not defined for service ${$18}`);
        return K(_);
      }
      async stop() {
        if (P) await P();
      }
    }, __publicField(_a2, "serviceType", $18), _a2;
  }
};
function fB($18) {
  return new IM($18);
}
function P5$($18) {
  return fB($18.serviceType).withDescription($18.description).withStart($18.start).withStop($18.stop || (() => Promise.resolve())).build();
}
var DM = /* @__PURE__ */ new Set();
function ZB() {
  if (process.env.ELIZA_NO_AUTO_INSTALL === "true") return false;
  if (process.env.ELIZA_NO_PLUGIN_AUTO_INSTALL === "true") return false;
  if (process.env.CI === "true") return false;
  if (process.env.ELIZA_TEST_MODE === "true") return false;
  return true;
}
async function XB($18) {
  try {
    if (!ZB()) return j6.debug(`Auto-install disabled or not allowed in this environment. Skipping install for ${$18}.`), false;
    if (DM.has($18)) return j6.debug(`Auto-install already attempted for ${$18}. Skipping.`), false;
    if (DM.add($18), typeof Bun > "u" || typeof Bun.spawn !== "function") return j6.warn(`Bun runtime not available. Cannot auto-install ${$18}. Please run: bun add ${$18}`), false;
    try {
      if (await Bun.spawn(["bun", "--version"], { stdout: "pipe", stderr: "pipe" }).exited !== 0) return j6.warn(`Bun not available on PATH. Cannot auto-install ${$18}. Please run: bun add ${$18}`), false;
    } catch {
      return j6.warn(`Bun not available on PATH. Cannot auto-install ${$18}. Please run: bun add ${$18}`), false;
    }
    j6.info(`Attempting to auto-install missing plugin: ${$18}`);
    let K = await Bun.spawn(["bun", "add", $18], { cwd: process.cwd(), env: process.env, stdout: "inherit", stderr: "inherit" }).exited;
    if (K === 0) return j6.info(`Successfully installed ${$18}. Retrying import...`), true;
    return j6.error(`bun add ${$18} failed with exit code ${K}. Please install manually.`), false;
  } catch (q) {
    let K = q instanceof Error ? q.message : String(q);
    return j6.error(`Unexpected error during auto-install of ${$18}: ${K}`), false;
  }
}
function LM($18) {
  if (!$18 || typeof $18 !== "object") return false;
  let q = $18;
  if (!q.name) return false;
  return !!(q.init || q.services || q.providers || q.actions || q.evaluators || q.description);
}
function AB($18) {
  let q = [];
  if (!$18) return q.push("Plugin is null or undefined"), { isValid: false, errors: q };
  let K = $18;
  if (!K.name) q.push("Plugin must have a name");
  if (K.actions) {
    if (!Array.isArray(K.actions)) q.push("Plugin actions must be an array");
    else if (K.actions.filter((_) => typeof _ !== "object" || !_).length > 0) q.push("Plugin actions must be an array of action objects");
  }
  if (K.services) {
    if (!Array.isArray(K.services)) q.push("Plugin services must be an array");
    else if (K.services.filter((_) => typeof _ !== "function" && (typeof _ !== "object" || !_)).length > 0) q.push("Plugin services must be an array of service classes or objects");
  }
  if (K.providers && !Array.isArray(K.providers)) q.push("Plugin providers must be an array");
  if (K.evaluators && !Array.isArray(K.evaluators)) q.push("Plugin evaluators must be an array");
  return { isValid: q.length === 0, errors: q };
}
async function kB($18) {
  try {
    let q;
    try {
      q = await import($18);
    } catch (Y) {
      if (j6.warn(`Failed to load plugin ${$18}: ${Y}`), !await XB($18)) return null;
      try {
        q = await import($18);
      } catch (z) {
        return j6.error(`Auto-install attempted for ${$18} but import still failed: ${z}`), null;
      }
    }
    if (!q) return j6.error(`Failed to load module for plugin ${$18}.`), null;
    let K = `${$18.replace(/^@elizaos\/plugin-/, "").replace(/^@elizaos\//, "").replace(/-./g, (Y) => Y[1].toUpperCase())}Plugin`, P = q, _ = [P[K], P.default, ...Object.values(P)];
    for (let Y of _) {
      if (LM(Y)) return Y;
      if (typeof Y === "function" && Y.length === 0) try {
        let O = Y();
        if (LM(O)) return O;
      } catch (O) {
        j6.debug(`Factory export threw for ${$18}: ${O}`);
      }
    }
    return j6.warn(`Could not find a valid plugin export in ${$18}.`), null;
  } catch (q) {
    return j6.error(`Error loading plugin ${$18}: ${q}`), null;
  }
}
function v1($18) {
  let q = $18.match(/^@[^/]+\/plugin-(.+)$/);
  if (q) return q[1];
  return $18;
}
function bM($18, q = false) {
  let K = [], P = /* @__PURE__ */ new Set(), _ = /* @__PURE__ */ new Set(), Y = /* @__PURE__ */ new Map();
  for (let [J, T] of $18.entries()) {
    if (Y.set(J, T), T.name !== J) Y.set(T.name, T);
    if (!T.name.startsWith("@")) Y.set(`@elizaos/plugin-${T.name}`, T);
    let X = v1(J);
    if (X !== J) Y.set(X, T);
  }
  function O(J) {
    let T = Y.get(J);
    if (!T) {
      let V = v1(J), M = Y.get(V);
      if (!M) {
        j6.warn(`Plugin dependency "${J}" not found and will be skipped.`);
        return;
      }
      return O(M.name);
    }
    let X = T.name;
    if (P.has(X)) return;
    if (_.has(X)) {
      j6.error(`Circular dependency detected involving plugin: ${X}`);
      return;
    }
    _.add(X);
    let f = [...T.dependencies || []];
    if (q) f.push(...T.testDependencies || []);
    for (let V of f) O(V);
    _.delete(X), P.add(X), K.push(X);
  }
  for (let J of $18.values()) if (!P.has(J.name)) O(J.name);
  let z = K.map((J) => {
    for (let T of $18.values()) if (T.name === J) return T;
    return null;
  }).filter((J) => Boolean(J));
  return j6.info({ plugins: z.map((J) => J.name) }, "Final plugins being loaded:"), z;
}
async function GB($18) {
  if (typeof $18 === "string") return kB($18);
  let q = AB($18);
  if (!q.isValid) return j6.error(`Invalid plugin provided: ${q.errors.join(", ")}`), null;
  return $18;
}
function gM($18, q, K, P) {
  let _ = v1($18);
  if (!(q.has($18) || q.has(_) || Array.from(K.keys()).some((O) => v1(O) === _) || Array.from(K.values()).some((O) => v1(O.name) === _ || O.name === $18 || O.name === _))) q.add($18), q.add(_), P.push($18);
}
async function VB($18, q = false) {
  let K = /* @__PURE__ */ new Map(), P = [...$18], _ = /* @__PURE__ */ new Set();
  while (P.length > 0) {
    let Y = P.shift(), O = await GB(Y);
    if (!O) continue;
    let z = O.name;
    if (!K.has(z)) {
      K.set(z, O);
      for (let J of O.dependencies ?? []) gM(J, _, K, P);
      if (q) for (let J of O.testDependencies ?? []) gM(J, _, K, P);
    }
  }
  return bM(K, q);
}
async function yM($18, q = false) {
  if (d4() === "node") return VB($18, q);
  let P = $18.filter((Y) => typeof Y !== "string");
  if ($18.some((Y) => typeof Y === "string")) j6.warn("Browser environment: String plugin references are not supported. Only Plugin objects will be used. Skipped plugins: " + $18.filter((Y) => typeof Y === "string").join(", "));
  let _ = /* @__PURE__ */ new Map();
  for (let Y of P) _.set(Y.name, Y);
  return bM(_, q);
}
var SB = class extends EventTarget {
  constructor() {
    super(...arguments);
    __publicField(this, "runtimes", /* @__PURE__ */ new Map());
    __publicField(this, "initFunctions", /* @__PURE__ */ new Map());
    __publicField(this, "editableMode", false);
  }
  async addAgents($18, q) {
    let K = $18.map(async (_) => {
      let Y = _.character;
      await SM(Y, { skipEnvMerge: q == null ? void 0 : q.isTestMode });
      let O = _.plugins ? await yM(_.plugins, (q == null ? void 0 : q.isTestMode) || false) : [], z = new bJ({ character: Y, plugins: O, settings: _.settings || {} });
      if (z.elizaOS = this, this.runtimes.set(z.agentId, z), typeof _.init === "function") this.initFunctions.set(z.agentId, _.init);
      let { settings: J, ...T } = Y, { secrets: X, ...f } = J || {};
      return this.dispatchEvent(new CustomEvent("agent:added", { detail: { agentId: z.agentId, character: { ...T, settings: f } } })), z.agentId;
    }), P = await Promise.all(K);
    return this.dispatchEvent(new CustomEvent("agents:added", { detail: { agentIds: P, count: P.length } })), P;
  }
  registerAgent($18) {
    if (this.runtimes.has($18.agentId)) throw Error(`Agent ${$18.agentId} already registered`);
    $18.elizaOS = this, this.runtimes.set($18.agentId, $18), this.dispatchEvent(new CustomEvent("agent:registered", { detail: { agentId: $18.agentId, runtime: $18 } }));
  }
  async updateAgent($18, q) {
    if (!this.editableMode) throw Error("Editable mode not enabled");
    let K = this.runtimes.get($18);
    if (!K) throw Error(`Agent ${$18} not found`);
    Object.assign(K.character, q), this.dispatchEvent(new CustomEvent("agent:updated", { detail: { agentId: $18, updates: q } }));
  }
  async deleteAgents($18) {
    await this.stopAgents($18);
    for (let q of $18) this.runtimes.delete(q), this.initFunctions.delete(q);
    this.dispatchEvent(new CustomEvent("agents:deleted", { detail: { agentIds: $18, count: $18.length } }));
  }
  async startAgents($18) {
    let q = $18 || Array.from(this.runtimes.keys());
    await Promise.all(q.map(async (K) => {
      let P = this.runtimes.get(K);
      if (!P) throw Error(`Agent ${K} not found`);
      await P.initialize(), this.dispatchEvent(new CustomEvent("agent:started", { detail: { agentId: K } }));
    }));
    for (let K of q) {
      let P = this.initFunctions.get(K);
      if (P) {
        let _ = this.runtimes.get(K);
        if (_) await P(_), this.initFunctions.delete(K);
      }
    }
    this.dispatchEvent(new CustomEvent("agents:started", { detail: { agentIds: q, count: q.length } }));
  }
  async stopAgents($18) {
    let q = $18 || Array.from(this.runtimes.keys());
    await Promise.all(q.map(async (K) => {
      let P = this.runtimes.get(K);
      if (P) await P.stop();
    })), this.dispatchEvent(new CustomEvent("agents:stopped", { detail: { agentIds: q, count: q.length } }));
  }
  getAgent($18) {
    return this.runtimes.get($18);
  }
  getAgents() {
    return Array.from(this.runtimes.values());
  }
  getAgentsByIds($18) {
    return $18.map((q) => this.runtimes.get(q)).filter((q) => q !== void 0);
  }
  getAgentsByNames($18) {
    let q = new Set($18.map((K) => K.toLowerCase()));
    return this.getAgents().filter((K) => q.has(K.character.name.toLowerCase()));
  }
  getAgentById($18) {
    return this.getAgent($18);
  }
  getAgentByName($18) {
    let q = $18.toLowerCase();
    return this.getAgents().find((K) => K.character.name.toLowerCase() === q);
  }
  getAgentByCharacterName($18) {
    return this.getAgentByName($18);
  }
  getAgentByCharacterId($18) {
    return this.getAgents().find((q) => q.character.id === $18);
  }
  async sendMessage($18, q, K) {
    let P = this.runtimes.get($18);
    if (!P) throw Error(`Agent ${$18} not found`);
    if (!P.messageService) throw Error("messageService is not initialized on runtime");
    let _ = q.id || Iq(), Y = { ...q, id: _, agentId: q.agentId || P.agentId, createdAt: q.createdAt || Date.now(), entityId: q.entityId, roomId: q.roomId, content: q.content };
    await P.ensureConnection({ entityId: Y.entityId, roomId: Y.roomId, worldId: q.worldId || Y.roomId, source: Y.content.source || "unknown", channelId: Y.roomId });
    let O = { maxRetries: K == null ? void 0 : K.maxRetries, timeoutDuration: K == null ? void 0 : K.timeoutDuration, useMultiStep: K == null ? void 0 : K.useMultiStep, maxMultiStepIterations: K == null ? void 0 : K.maxMultiStepIterations };
    if (!!(K == null ? void 0 : K.onResponse)) {
      let J = async (T) => {
        try {
          if (K.onResponse) await K.onResponse(T);
        } catch (X) {
          if (K.onError) await K.onError(X instanceof Error ? X : Error(String(X)));
        }
        return [];
      };
      return P.messageService.handleMessage(P, Y, J, O).then(() => {
        if (K.onComplete) K.onComplete();
      }).catch((T) => {
        if (K.onError) K.onError(T);
      }), this.dispatchEvent(new CustomEvent("message:sent", { detail: { agentId: $18, messageId: _, mode: "async" } })), { messageId: _, userMessage: Y };
    } else {
      let J = await P.messageService.handleMessage(P, Y, void 0, O);
      if (K == null ? void 0 : K.onComplete) await K.onComplete();
      return this.dispatchEvent(new CustomEvent("message:sent", { detail: { agentId: $18, messageId: _, mode: "sync", result: J } })), { messageId: _, userMessage: Y, result: J };
    }
  }
  async sendMessages($18) {
    let q = await Promise.all($18.map(async ({ agentId: K, message: P, options: _ }) => {
      try {
        let Y = await this.sendMessage(K, P, _);
        return { agentId: K, result: Y };
      } catch (Y) {
        return { agentId: K, result: { messageId: P.id || "", userMessage: P }, error: Y instanceof Error ? Y : Error(String(Y)) };
      }
    }));
    return this.dispatchEvent(new CustomEvent("messages:sent", { detail: { results: q, count: $18.length } })), q;
  }
  async validateApiKeys($18) {
    let q = /* @__PURE__ */ new Map(), K = $18 || Array.from(this.runtimes.keys());
    for (let P of K) {
      let _ = this.runtimes.get(P);
      if (_) {
        let Y = !!(_.getSetting("OPENAI_API_KEY") || _.getSetting("ANTHROPIC_API_KEY"));
        q.set(P, Y);
      }
    }
    return q;
  }
  async healthCheck($18) {
    let q = /* @__PURE__ */ new Map(), K = $18 || Array.from(this.runtimes.keys());
    for (let P of K) {
      let Y = { alive: !!this.runtimes.get(P), responsive: true };
      if (typeof process < "u") Y.memoryUsage = process.memoryUsage().heapUsed, Y.uptime = process.uptime();
      q.set(P, Y);
    }
    return q;
  }
  getRuntimeAccessor() {
    return { getAgent: ($18) => this.getAgent($18), getAgents: () => this.getAgents(), getState: ($18) => {
      let q = this.getAgent($18);
      if (!q) return;
      let K = q;
      if (K.stateCache && K.stateCache.size > 0) {
        let P = Array.from(K.stateCache.values());
        return P[P.length - 1];
      }
      return;
    } };
  }
  enableEditableMode() {
    this.editableMode = true, this.dispatchEvent(new CustomEvent("mode:editable", { detail: { editable: true } }));
  }
};
var MB = `# Task: Resolve Entity Name
Message Sender: {{senderName}} (ID: {{senderId}})
Agent: {{agentName}} (ID: {{agentId}})

# Entities in Room:
{{#if entitiesInRoom}}
{{entitiesInRoom}}
{{/if}}

{{recentMessages}}

# Instructions:
1. Analyze the context to identify which entity is being referenced
2. Consider special references like "me" (the message sender) or "you" (agent the message is directed to)
3. Look for usernames/handles in standard formats (e.g. @username, user#1234)
4. Consider context from recent messages for pronouns and references
5. If multiple matches exist, use context to disambiguate
6. Consider recent interactions and relationship strength when resolving ambiguity

Do NOT include any thinking, reasoning, or <think> sections in your response. 
Go directly to the XML response format without any preamble or explanation.

Return an XML response with:
<response>
  <entityId>exact-id-if-known-otherwise-null</entityId>
  <type>EXACT_MATCH | USERNAME_MATCH | NAME_MATCH | RELATIONSHIP_MATCH | AMBIGUOUS | UNKNOWN</type>
  <matches>
    <match>
      <name>matched-name</name>
      <reason>why this entity matches</reason>
    </match>
  </matches>
</response>

IMPORTANT: Your response must ONLY contain the <response></response> XML block above. Do not include any text, thinking, or reasoning before or after this XML block. Start your response immediately with <response> and end with </response>.`;
async function NB($18, q, K, P, _) {
  var _a2;
  let Y = [], O = await $18.getMemories({ tableName: "messages", roomId: P, count: 20 });
  for (let z of K) {
    let J = [], T = 0, X = O.filter((M) => M.entityId === q && M.content.inReplyTo === z.id || M.entityId === z.id && M.content.inReplyTo === q);
    J.push(...X);
    let f = _.find((M) => M.sourceEntityId === q && M.targetEntityId === z.id || M.targetEntityId === q && M.sourceEntityId === z.id);
    if ((_a2 = f == null ? void 0 : f.metadata) == null ? void 0 : _a2.interactions) T = f.metadata.interactions;
    T += X.length;
    let V = [...new Set(J)];
    Y.push({ entity: z, interactions: V.slice(-5), count: Math.round(T) });
  }
  return Y.sort((z, J) => J.count - z.count);
}
async function k5$($18, q, K) {
  var _a2, _b2, _c;
  let P = K.data.room ?? await $18.getRoom(q.roomId);
  if (!P) return j6.warn("Room not found for entity search"), null;
  let _ = P.worldId ? await $18.getWorld(P.worldId) : null, Y = await $18.getEntitiesForRoom(P.id, true), O = await Promise.all(Y.map(async (h) => {
    var _a3;
    if (!h.components) return h;
    let E = ((_a3 = _ == null ? void 0 : _.metadata) == null ? void 0 : _a3.roles) || {};
    return h.components = h.components.filter((I) => {
      if (I.sourceEntityId === q.entityId) return true;
      if (_ && I.sourceEntityId) {
        let D = E[I.sourceEntityId];
        if (D === "OWNER" || D === "ADMIN") return true;
      }
      if (I.sourceEntityId === $18.agentId) return true;
      return false;
    }), h;
  })), z = await $18.getRelationships({ entityId: q.entityId }), J = await Promise.all(z.map(async (h) => {
    let E = h.sourceEntityId === q.entityId ? h.targetEntityId : h.sourceEntityId;
    return $18.getEntityById(E);
  })), T = [...O, ...J.filter((h) => h !== null)], X = await NB($18, q.entityId, T, P.id, z), f = OM({ state: { roomName: P.name || P.id, worldName: (_ == null ? void 0 : _.name) || "Unknown", entitiesInRoom: JSON.stringify(O, null, 2), entityId: q.entityId, senderId: q.entityId }, template: MB }), V = await $18.useModel(M6.TEXT_SMALL, { prompt: f, stopSequences: [] }), M = K_(V);
  if (!M) return j6.warn("Failed to parse entity resolution result"), null;
  if (M.type === "EXACT_MATCH" && M.entityId) {
    let h = await $18.getEntityById(M.entityId);
    if (h) {
      if (h.components) {
        let E = ((_a2 = _ == null ? void 0 : _.metadata) == null ? void 0 : _a2.roles) || {};
        h.components = h.components.filter((I) => {
          if (I.sourceEntityId === q.entityId) return true;
          if (_ && I.sourceEntityId) {
            let D = E[I.sourceEntityId];
            if (D === "OWNER" || D === "ADMIN") return true;
          }
          if (I.sourceEntityId === $18.agentId) return true;
          return false;
        });
      }
      return h;
    }
  }
  let N = [];
  if ((_b2 = M.matches) == null ? void 0 : _b2.match) N = Array.isArray(M.matches.match) ? M.matches.match : [M.matches.match];
  if (N.length > 0 && ((_c = N[0]) == null ? void 0 : _c.name)) {
    let h = N[0].name.toLowerCase(), E = T.find((I) => {
      var _a3;
      if (I.names.some((D) => D.toLowerCase() === h)) return true;
      return (_a3 = I.components) == null ? void 0 : _a3.some((D) => {
        var _a4, _b3;
        return ((_a4 = D.data.username) == null ? void 0 : _a4.toLowerCase()) === h || ((_b3 = D.data.handle) == null ? void 0 : _b3.toLowerCase()) === h;
      });
    });
    if (E) if (M.type === "RELATIONSHIP_MATCH") {
      let I = X.find((D) => D.entity.id === E.id);
      if (I && I.count > 0) return E;
    } else return E;
  }
  return null;
}
var qK = ($18, q) => {
  if (q === $18.agentId) return $18.agentId;
  let K = `${q}:${$18.agentId}`;
  return MO(K);
};
async function G5$({ runtime: $18, roomId: q }) {
  var _a2;
  let [K, P] = await Promise.all([$18.getRoom(q), $18.getEntitiesForRoom(q, true)]), _ = /* @__PURE__ */ new Map();
  for (let Y of P) {
    if (_.has(Y.id)) continue;
    let O = {};
    for (let J of Y.components || []) Object.assign(O, J.data);
    let z = {};
    for (let [J, T] of Object.entries(O)) {
      if (!z[J]) {
        z[J] = T;
        continue;
      }
      if (Array.isArray(z[J]) && Array.isArray(T)) z[J] = [.../* @__PURE__ */ new Set([...z[J], ...T])];
      else if (typeof z[J] === "object" && typeof T === "object") z[J] = { ...z[J], ...T };
    }
    _.set(Y.id, { id: Y.id, name: (K == null ? void 0 : K.source) ? ((_a2 = Y.metadata[K.source]) == null ? void 0 : _a2.name) || Y.names[0] : Y.names[0], names: Y.names, data: JSON.stringify({ ...z, ...Y.metadata }) });
  }
  return Array.from(_.values());
}
function V5$({ entities: $18 }) {
  return $18.map((K) => {
    return `"${K.names.join('" aka "')}"
ID: ${K.id}${K.metadata && Object.keys(K.metadata).length > 0 ? `
Data: ${JSON.stringify(K.metadata)}
` : `
`}`;
  }).join(`
`);
}
var M5$ = true;
var N5$ = false;
var C5$ = { check: async () => ({ status: "not-applicable", environment: "browser" }), isHealthy: () => true };
export {
  bJ as AgentRuntime,
  dM as AgentStatus,
  gJ as BM25,
  __ as BufferUtils,
  KP as ChannelType,
  qP as ContentType,
  ai as DatabaseAdapter,
  DJ as DefaultMessageService,
  SB as ElizaOS,
  C0 as Environment,
  IO as EventType,
  _P as MODEL_SETTINGS,
  cM as MemoryType,
  M6 as ModelType,
  lM as PlatformPrefix,
  mM as Role,
  nM as SOCKET_MESSAGE_TYPE,
  YB as Semaphore,
  RO as Service,
  IM as ServiceBuilder,
  DB as ServiceType,
  rM as TEEMode,
  oM as TeeType,
  uB as VECTOR_DIMS,
  X1$ as __loggerTestHooks,
  L1$ as addHeader,
  ri as alloc,
  z1 as asUUID,
  W9$ as booleanFooter,
  ti as byteLength,
  pi as characterSchema,
  a9$ as clearSaltCache,
  U1$ as composeActionExamples,
  OM as composePrompt,
  Y1 as composePromptFromState,
  ni as concat,
  Ii as contentSchema,
  O1 as createLogger,
  s1$ as createMessageMemory,
  fB as createService,
  gB as createServiceError,
  WB as createSettingFromConfig,
  qK as createUniqueUuid,
  kP$ as currentRuntime,
  G1$ as customLevels,
  EM as decryptObjectValues,
  NO as decryptSecret,
  NO as decryptStringValue,
  q5$ as decryptedCharacter,
  P5$ as defineService,
  d4 as detectEnvironment,
  Li as directoryItemSchema,
  V1$ as elizaLogger,
  CM as encryptObjectValues,
  hM as encryptStringValue,
  $5$ as encryptedCharacter,
  Bi as equals,
  k5$ as findEntityByName,
  an as findEnvFile,
  f9$ as findWorldsForOwner,
  F1$ as formatActionNames,
  a1$ as formatActions,
  V5$ as formatEntities,
  b1$ as formatMessages,
  g1$ as formatPosts,
  jM as formatTimestamp,
  oi as fromBytes,
  ci as fromHex,
  mi as fromString,
  XP$ as getBooleanEnv,
  c1$ as getContentTypeFromMimeType,
  G5$ as getEntityDetails,
  q_ as getEnv,
  l4 as getEnvironment,
  HM as getLocalServerUrl,
  j9$ as getMemoryText,
  E0 as getNumberEnv,
  x_ as getSalt,
  LB as getTypedService,
  w9$ as getUserServerRole,
  e9$ as getWorldSettings,
  ZP$ as hasEnv,
  XM as imageDescriptionTemplate,
  AP$ as initBrowserEnvironment,
  s9$ as initializeOnboarding,
  M5$ as isBrowser,
  li as isBuffer,
  P9$ as isCustomMetadata,
  _9$ as isDescriptionMetadata,
  O9$ as isDocumentMemory,
  $9$ as isDocumentMetadata,
  Y9$ as isFragmentMemory,
  q9$ as isFragmentMetadata,
  K9$ as isMessageMetadata,
  N5$ as isNode,
  n1$ as isValidCharacter,
  gi as knowledgeItemSchema,
  GP$ as loadEnvFile,
  j6 as logger,
  Ri as mediaSchema,
  Di as messageExampleSchema,
  ZM as messageHandlerTemplate,
  AM as multiStepDecisionTemplate,
  kM as multiStepSummaryTemplate,
  _M as normalizeJsonString,
  o1$ as parseAndValidateCharacter,
  SO as parseBooleanFromText,
  y1$ as parseJSONObjectFromText,
  K_ as parseKeyValueXml,
  z9$ as postCreationTemplate,
  p1$ as prewarmUuidCache,
  Ui as randomBytes,
  S1$ as recentLogs,
  CJ as safeReplacer,
  JB as saltSettingValue,
  wB as saltWorldSettings,
  xi as secretsSchema,
  C5$ as serverHealth,
  fP$ as setEnv,
  ui as settingsSchema,
  fM as shouldRespondTemplate,
  ii as slice,
  u1$ as splitChunks,
  MO as stringToUuid,
  yi as styleSchema,
  bi as templateTypeSchema,
  wM as toHex,
  di as toString,
  x1$ as trimTokens,
  vM as truncateToCompleteSentence,
  TB as unsaltSettingValue,
  RM as unsaltWorldSettings,
  Q9$ as updateWorldSettings,
  JM as uuidSchema,
  TM as validateCharacter,
  Ni as validateUuid
};
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/*!
* https://github.com/Starcounter-Jack/JSON-Patch
* (c) 2017-2022 Joachim Wester
* MIT licensed
*/
//# sourceMappingURL=@elizaos_core.js.map
