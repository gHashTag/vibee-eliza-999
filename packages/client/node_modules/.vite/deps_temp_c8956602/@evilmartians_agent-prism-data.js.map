{
  "version": 3,
  "sources": ["../../../../../node_modules/@evilmartians/agent-prism-data/src/common/get-duration-ms.ts", "../../../../../node_modules/@evilmartians/agent-prism-data/src/common/format-duration.ts", "../../../../../node_modules/@evilmartians/agent-prism-data/src/common/get-timeline-data.ts", "../../../../../node_modules/@evilmartians/agent-prism-data/src/common/flatten-spans.ts", "../../../../../node_modules/@evilmartians/agent-prism-data/src/common/find-time-range.ts", "../../../../../node_modules/@evilmartians/agent-prism-types/src/constants/span-mappings.ts", "../../../../../node_modules/@evilmartians/agent-prism-data/src/open-telemetry/utils/get-open-telemetry-attribute-value.ts", "../../../../../node_modules/@evilmartians/agent-prism-data/src/open-telemetry/utils/categorize-open-inference.ts", "../../../../../node_modules/@evilmartians/agent-prism-data/src/open-telemetry/utils/categorize-open-telemetry-gen-ai.ts", "../../../../../node_modules/@evilmartians/agent-prism-data/src/open-telemetry/utils/open-telemetry-category-mappers.ts", "../../../../../node_modules/@evilmartians/agent-prism-data/src/open-telemetry/utils/categorize-standard-open-telemetry.ts", "../../../../../node_modules/@evilmartians/agent-prism-data/src/open-telemetry/utils/convert-nano-timestamp-to-date.ts", "../../../../../node_modules/@evilmartians/agent-prism-data/src/open-telemetry/utils/generate-open-telemetry-span-title.ts", "../../../../../node_modules/@evilmartians/agent-prism-data/src/open-telemetry/utils/get-open-telemetry-span-standard.ts", "../../../../../node_modules/@evilmartians/agent-prism-data/src/open-telemetry/adapter.ts", "../../../../../node_modules/@evilmartians/agent-prism-data/src/langfuse/adapter.ts"],
  "sourcesContent": ["import type { TraceSpan } from \"@evilmartians/agent-prism-types\";\n\nexport const getDurationMs = (spanCard: TraceSpan): number => {\n  const startMs = +spanCard.startTime;\n  const endMs = +spanCard.endTime;\n  return endMs - startMs;\n};\n", "export const formatDuration = (durationMs: number): string => {\n  if (durationMs < 1000) return `${Math.round(durationMs)}ms`;\n  if (durationMs < 60000) return `${Math.round(durationMs / 1000)}s`;\n  if (durationMs < 3600000) {\n    const m = Math.floor(durationMs / 60000);\n    const s = Math.floor((durationMs % 60000) / 1000);\n    return s > 0 ? `${m}m ${s}s` : `${m}m`;\n  }\n  const h = Math.floor(durationMs / 3600000);\n  const m = Math.floor((durationMs % 3600000) / 60000);\n  return m > 0 ? `${h}h ${m}m` : `${h}h`;\n};\n", "import type { TraceSpan } from \"@evilmartians/agent-prism-types\";\n\nimport { getDurationMs } from \"./get-duration-ms.ts\";\n\nexport const getTimelineData = ({\n  spanCard,\n  minStart,\n  maxEnd,\n}: {\n  spanCard: TraceSpan;\n  minStart: number;\n  maxEnd: number;\n}) => {\n  const startMs = +spanCard.startTime;\n  const totalRange = maxEnd - minStart;\n  const durationMs = getDurationMs(spanCard);\n  const startPercent = ((startMs - minStart) / totalRange) * 100;\n  const widthPercent = (durationMs / totalRange) * 100;\n\n  return {\n    durationMs,\n    startPercent,\n    widthPercent,\n  };\n};\n", "import type { TraceSpan } from \"@evilmartians/agent-prism-types\";\n\n/**\n * Flattens a tree of TraceSpan objects into a single array\n * @param spans - Array of root spans that may contain children\n * @returns Flattened array of all spans\n */\nexport const flattenSpans = (spans: TraceSpan[]): TraceSpan[] => {\n  const result: TraceSpan[] = [];\n\n  const traverse = (items: TraceSpan[]) => {\n    items.forEach((item) => {\n      result.push(item);\n      if (item.children?.length) {\n        traverse(item.children);\n      }\n    });\n  };\n\n  traverse(spans);\n  return result;\n};\n", "import type { TraceSpan } from \"@evilmartians/agent-prism-types\";\n\nexport function findTimeRange(cards: TraceSpan[]): {\n  minStart: number;\n  maxEnd: number;\n} {\n  return cards.reduce(\n    (acc, c) => {\n      const start = +new Date(c.startTime);\n      const end = +new Date(c.endTime);\n      return {\n        minStart: Math.min(acc.minStart, start),\n        maxEnd: Math.max(acc.maxEnd, end),\n      };\n    },\n    {\n      minStart: cards.length > 0 ? +new Date(cards[0].startTime) : Infinity,\n      maxEnd: cards.length > 0 ? +new Date(cards[0].endTime) : -Infinity,\n    },\n  );\n}\n", "import type { TraceSpanCategory } from \"../types\";\n\n// OpenTelemetry GenAI attribute constants\nexport const OPENTELEMETRY_GENAI_ATTRIBUTES = {\n  OPERATION_NAME: \"gen_ai.operation.name\",\n  SYSTEM: \"gen_ai.system\",\n  MODEL: \"gen_ai.request.model\",\n  AGENT_NAME: \"gen_ai.agent.name\",\n  TOOL_NAME: \"gen_ai.tool.name\",\n  // Usage and cost attributes\n  USAGE_INPUT_TOKENS: \"gen_ai.usage.input_tokens\",\n  USAGE_OUTPUT_TOKENS: \"gen_ai.usage.output_tokens\",\n  USAGE_TOTAL_TOKENS: \"gen_ai.usage.total_tokens\",\n  USAGE_COST: \"gen_ai.usage.cost\",\n  USAGE_INPUT_COST: \"gen_ai.usage.input_cost\",\n  USAGE_OUTPUT_COST: \"gen_ai.usage.output_cost\",\n  // Request attributes\n  REQUEST_TEMPERATURE: \"gen_ai.request.temperature\",\n  REQUEST_PROMPT: \"gen_ai.request.prompt\",\n  // Response attributes\n  RESPONSE_TEXT: \"gen_ai.response.text\",\n} as const;\n\nexport const OPENINFERENCE_ATTRIBUTES = {\n  SPAN_KIND: \"openinference.span.kind\",\n  LLM_MODEL: \"llm.model_name\",\n  INPUT_MESSAGES: \"llm.input_messages\",\n  RETRIEVAL_DOCUMENTS: \"retrieval.documents\",\n  EMBEDDING_MODEL: \"embedding.model_name\",\n} as const;\n\nexport const STANDARD_OPENTELEMETRY_ATTRIBUTES = {\n  HTTP_METHOD: \"http.method\",\n  HTTP_URL: \"http.url\",\n  DB_SYSTEM: \"db.system\",\n  DB_OPERATION: \"db.operation.name\",\n  DB_COLLECTION: \"db.collection.name\",\n  DB_QUERY_TEXT: \"db.query.text\",\n  FUNCTION_NAME: \"function.name\",\n} as const;\n\n// OpenTelemetry GenAI operation name mappings\nexport const OPENTELEMETRY_GENAI_MAPPINGS: Record<string, TraceSpanCategory> = {\n  // LLM operations\n  chat: \"llm_call\",\n  generate_content: \"llm_call\",\n  text_completion: \"llm_call\",\n\n  // Tool operations\n  execute_tool: \"tool_execution\",\n\n  // Agent operations\n  invoke_agent: \"agent_invocation\",\n  create_agent: \"create_agent\",\n\n  // Embedding operations\n  embeddings: \"embedding\",\n} as const;\n\n// OpenInference span kind mappings\nexport const OPENINFERENCE_MAPPINGS: Record<string, TraceSpanCategory> = {\n  LLM: \"llm_call\",\n  TOOL: \"tool_execution\",\n  CHAIN: \"chain_operation\",\n  AGENT: \"agent_invocation\",\n  RETRIEVER: \"retrieval\",\n  EMBEDDING: \"embedding\",\n} as const;\n\n// Standard OpenTelemetry detection patterns\nexport const STANDARD_OPENTELEMETRY_PATTERNS = {\n  HTTP_KEYWORDS: [],\n  DATABASE_KEYWORDS: [],\n  FUNCTION_KEYWORDS: [\"tool\", \"function\"],\n  LLM_KEYWORDS: [\"openai\", \"anthropic\", \"gpt\", \"claude\"],\n  CHAIN_KEYWORDS: [\"chain\", \"workflow\", \"langchain\"],\n  AGENT_KEYWORDS: [\"agent\"],\n  RETRIEVAL_KEYWORDS: [\"pinecone\", \"chroma\", \"retrieval\", \"vector\", \"search\"],\n} as const;\n\nexport const INPUT_OUTPUT_ATTRIBUTES = {\n  INPUT_VALUE: \"input.value\",\n  OUTPUT_VALUE: \"output.value\",\n} as const;\n", "import { type OpenTelemetrySpan } from \"@evilmartians/agent-prism-types\";\n\nexport function getOpenTelemetryAttributeValue(\n  span: OpenTelemetrySpan,\n  key: string,\n): string | number | boolean | undefined {\n  const attr = span.attributes.find((a) => a.key === key);\n\n  if (!attr) {\n    return undefined;\n  }\n\n  const { value } = attr;\n\n  if (value.stringValue !== undefined) {\n    return value.stringValue;\n  }\n\n  if (value.intValue !== undefined) {\n    return parseFloat(value.intValue);\n  }\n\n  if (value.boolValue !== undefined) {\n    return value.boolValue;\n  }\n\n  return undefined;\n}\n", "import {\n  OPENINFERENCE_ATTRIBUTES,\n  OPENINFERENCE_MAPPINGS,\n  type OpenTelemetrySpan,\n  type TraceSpanCategory,\n} from \"@evilmartians/agent-prism-types\";\n\nimport { getOpenTelemetryAttributeValue } from \"./get-open-telemetry-attribute-value\";\n\nexport function categorizeOpenInference(\n  span: OpenTelemetrySpan,\n): TraceSpanCategory {\n  const spanKind = getOpenTelemetryAttributeValue(\n    span,\n    OPENINFERENCE_ATTRIBUTES.SPAN_KIND,\n  );\n\n  if (typeof spanKind === \"string\") {\n    const category = OPENINFERENCE_MAPPINGS[spanKind];\n\n    if (category) return category;\n  }\n\n  return \"unknown\";\n}\n", "import {\n  OPENTELEMETRY_GENAI_ATTRIBUTES,\n  OPENTELEMETRY_GENAI_MAPPINGS,\n  type OpenTelemetrySpan,\n  type TraceSpanCategory,\n} from \"@evilmartians/agent-prism-types\";\n\nimport { getOpenTelemetryAttributeValue } from \"./get-open-telemetry-attribute-value\";\n\nexport function categorizeOpenTelemetryGenAI(\n  span: OpenTelemetrySpan,\n): TraceSpanCategory {\n  const operationName = getOpenTelemetryAttributeValue(\n    span,\n    OPENTELEMETRY_GENAI_ATTRIBUTES.OPERATION_NAME,\n  );\n\n  if (typeof operationName === \"string\") {\n    const category = OPENTELEMETRY_GENAI_MAPPINGS[operationName];\n\n    if (category) return category;\n  }\n\n  return \"unknown\";\n}\n", "import {\n  STANDARD_OPENTELEMETRY_ATTRIBUTES,\n  STANDARD_OPENTELEMETRY_PATTERNS,\n  type OpenTelemetrySpan,\n} from \"@evilmartians/agent-prism-types\";\n\nimport { getOpenTelemetryAttributeValue } from \"./get-open-telemetry-attribute-value\";\n\nexport const openTelemetryCategoryMappers = {\n  isHttpCall: (span: OpenTelemetrySpan): boolean => {\n    return (\n      getOpenTelemetryAttributeValue(\n        span,\n        STANDARD_OPENTELEMETRY_ATTRIBUTES.HTTP_METHOD,\n      ) !== undefined\n    );\n  },\n\n  isDatabaseCall: (span: OpenTelemetrySpan): boolean => {\n    return (\n      getOpenTelemetryAttributeValue(\n        span,\n        STANDARD_OPENTELEMETRY_ATTRIBUTES.DB_SYSTEM,\n      ) !== undefined\n    );\n  },\n\n  isFunctionCall: (span: OpenTelemetrySpan): boolean => {\n    const name = span.name.toLowerCase();\n\n    return (\n      STANDARD_OPENTELEMETRY_PATTERNS.FUNCTION_KEYWORDS.some((keyword) =>\n        name.includes(keyword),\n      ) ||\n      getOpenTelemetryAttributeValue(\n        span,\n        STANDARD_OPENTELEMETRY_ATTRIBUTES.FUNCTION_NAME,\n      ) !== undefined\n    );\n  },\n\n  isLLMCall: (span: OpenTelemetrySpan): boolean => {\n    const name = span.name.toLowerCase();\n\n    return STANDARD_OPENTELEMETRY_PATTERNS.LLM_KEYWORDS.some((keyword) =>\n      name.includes(keyword),\n    );\n  },\n\n  isChainOperation: (span: OpenTelemetrySpan): boolean => {\n    const name = span.name.toLowerCase();\n\n    return STANDARD_OPENTELEMETRY_PATTERNS.CHAIN_KEYWORDS.some((keyword) =>\n      name.includes(keyword),\n    );\n  },\n\n  isAgentOperation: (span: OpenTelemetrySpan): boolean => {\n    const name = span.name.toLowerCase();\n\n    return STANDARD_OPENTELEMETRY_PATTERNS.AGENT_KEYWORDS.some((keyword) =>\n      name.includes(keyword),\n    );\n  },\n\n  isRetrievalOperation: (span: OpenTelemetrySpan): boolean => {\n    const name = span.name.toLowerCase();\n\n    return STANDARD_OPENTELEMETRY_PATTERNS.RETRIEVAL_KEYWORDS.some((keyword) =>\n      name.includes(keyword),\n    );\n  },\n};\n", "import type {\n  OpenTelemetrySpan,\n  TraceSpanCategory,\n} from \"@evilmartians/agent-prism-types\";\n\nimport { openTelemetryCategoryMappers } from \"./open-telemetry-category-mappers\";\n\nexport function categorizeStandardOpenTelemetry(\n  span: OpenTelemetrySpan,\n): TraceSpanCategory {\n  // Priority order for detection\n  if (openTelemetryCategoryMappers.isLLMCall(span)) return \"llm_call\";\n  if (openTelemetryCategoryMappers.isAgentOperation(span))\n    return \"agent_invocation\";\n  if (openTelemetryCategoryMappers.isChainOperation(span))\n    return \"chain_operation\";\n  if (openTelemetryCategoryMappers.isRetrievalOperation(span))\n    return \"retrieval\";\n  if (openTelemetryCategoryMappers.isFunctionCall(span))\n    return \"tool_execution\";\n  if (openTelemetryCategoryMappers.isHttpCall(span)) return \"tool_execution\";\n  if (openTelemetryCategoryMappers.isDatabaseCall(span))\n    return \"tool_execution\";\n\n  return \"unknown\";\n}\n", "export function convertNanoTimestampToDate(nanoString: string): Date {\n  const nanoseconds = BigInt(nanoString);\n  const milliseconds = Number(nanoseconds / 1_000_000n);\n\n  return new Date(milliseconds);\n}\n", "import {\n  OPENTELEMETRY_GENAI_ATTRIBUTES,\n  STANDARD_OPENTELEMETRY_ATTRIBUTES,\n  type OpenTelemetrySpan,\n} from \"@evilmartians/agent-prism-types\";\n\nimport { getOpenTelemetryAttributeValue } from \"./get-open-telemetry-attribute-value\";\n\nexport function generateOpenTelemetrySpanTitle(\n  span: OpenTelemetrySpan,\n): string {\n  const { name } = span;\n\n  // For LLM operations, use model name\n  const model = getOpenTelemetryAttributeValue(\n    span,\n    OPENTELEMETRY_GENAI_ATTRIBUTES.MODEL,\n  );\n\n  if (model) {\n    return `${model} - ${name}`;\n  }\n\n  // For vector DB operations, use collection name\n  const collection = getOpenTelemetryAttributeValue(\n    span,\n    STANDARD_OPENTELEMETRY_ATTRIBUTES.DB_COLLECTION,\n  );\n  const operation = getOpenTelemetryAttributeValue(\n    span,\n    STANDARD_OPENTELEMETRY_ATTRIBUTES.DB_OPERATION,\n  );\n\n  if (collection && operation) {\n    return `${collection} - ${operation}`;\n  }\n\n  // For HTTP operations, use method and URL\n  const method = getOpenTelemetryAttributeValue(\n    span,\n    STANDARD_OPENTELEMETRY_ATTRIBUTES.HTTP_METHOD,\n  );\n  const url = getOpenTelemetryAttributeValue(\n    span,\n    STANDARD_OPENTELEMETRY_ATTRIBUTES.HTTP_URL,\n  );\n\n  if (method && url) {\n    return `${method} ${url}`;\n  }\n\n  return name;\n}\n", "import {\n  OPENTELEMETRY_GENAI_ATTRIBUTES,\n  OPENINFERENCE_ATTRIBUTES,\n  type OpenTelemetrySpan,\n  type OpenTelemetryStandard,\n} from \"@evilmartians/agent-prism-types\";\n\nimport { getOpenTelemetryAttributeValue } from \"./get-open-telemetry-attribute-value\";\n\nexport function getOpenTelemetrySpanStandard(\n  span: OpenTelemetrySpan,\n): OpenTelemetryStandard {\n  // Check for OpenTelemetry GenAI attributes\n  if (\n    getOpenTelemetryAttributeValue(\n      span,\n      OPENTELEMETRY_GENAI_ATTRIBUTES.OPERATION_NAME,\n    ) ||\n    getOpenTelemetryAttributeValue(span, OPENTELEMETRY_GENAI_ATTRIBUTES.SYSTEM)\n  ) {\n    return \"opentelemetry_genai\";\n  }\n\n  // Check for OpenInference attributes\n  if (\n    getOpenTelemetryAttributeValue(span, OPENINFERENCE_ATTRIBUTES.SPAN_KIND) ||\n    getOpenTelemetryAttributeValue(span, OPENINFERENCE_ATTRIBUTES.LLM_MODEL)\n  ) {\n    return \"openinference\";\n  }\n\n  // Default to standard OpenTelemetry\n  return \"standard\";\n}\n", "import type { InputOutputData } from \"@evilmartians/agent-prism-types\";\n\nimport {\n  INPUT_OUTPUT_ATTRIBUTES,\n  OPENTELEMETRY_GENAI_ATTRIBUTES,\n  type OpenTelemetryDocument,\n  type OpenTelemetrySpan,\n  type TraceSpan,\n  type TraceSpanCategory,\n  type TraceSpanStatus,\n} from \"@evilmartians/agent-prism-types\";\n\nimport type { SpanAdapter } from \"../types\";\n\nimport { categorizeOpenInference } from \"./utils/categorize-open-inference\";\nimport { categorizeOpenTelemetryGenAI } from \"./utils/categorize-open-telemetry-gen-ai\";\nimport { categorizeStandardOpenTelemetry } from \"./utils/categorize-standard-open-telemetry\";\nimport { convertNanoTimestampToDate } from \"./utils/convert-nano-timestamp-to-date\";\nimport { generateOpenTelemetrySpanTitle } from \"./utils/generate-open-telemetry-span-title\";\nimport { getOpenTelemetryAttributeValue } from \"./utils/get-open-telemetry-attribute-value\";\nimport { getOpenTelemetrySpanStandard } from \"./utils/get-open-telemetry-span-standard\";\n\nexport const openTelemetrySpanAdapter: SpanAdapter<\n  OpenTelemetryDocument,\n  OpenTelemetrySpan\n> = {\n  convertRawDocumentsToSpans(\n    documents: OpenTelemetryDocument | OpenTelemetryDocument[],\n  ): TraceSpan[] {\n    const docArray = Array.isArray(documents) ? documents : [documents];\n\n    // Extract all spans from all documents, resource spans and scope spans\n    const allSpans: OpenTelemetrySpan[] = [];\n\n    docArray.forEach((document) => {\n      document.resourceSpans.forEach((resourceSpan) => {\n        resourceSpan.scopeSpans.forEach((scopeSpan) => {\n          allSpans.push(...scopeSpan.spans);\n        });\n      });\n    });\n\n    // Convert the flat array of spans to a tree structure\n    return this.convertRawSpansToSpanTree(allSpans);\n  },\n\n  convertRawSpansToSpanTree(spans: OpenTelemetrySpan[]): TraceSpan[] {\n    const spanMap = new Map<string, TraceSpan>();\n    const rootSpans: TraceSpan[] = [];\n\n    // First pass: create all span objects\n    spans.forEach((span) => {\n      const convertedSpan = this.convertRawSpanToTraceSpan(span);\n      spanMap.set(convertedSpan.id, convertedSpan);\n    });\n\n    // Second pass: build parent-child relationships\n    spans.forEach((span) => {\n      const convertedSpan = spanMap.get(span.spanId)!;\n      const parentSpanId = span.parentSpanId;\n\n      if (parentSpanId) {\n        const parent = spanMap.get(parentSpanId);\n        if (parent) {\n          if (!parent.children) {\n            parent.children = [];\n          }\n          parent.children.push(convertedSpan);\n        }\n      } else {\n        rootSpans.push(convertedSpan);\n      }\n    });\n\n    return rootSpans;\n  },\n\n  convertRawSpanToTraceSpan(\n    span: OpenTelemetrySpan,\n    children: TraceSpan[] = [],\n  ): TraceSpan {\n    const duration = this.getSpanDuration(span);\n    const status = this.getSpanStatus(span);\n    const type = this.getSpanCategory(span);\n    const tokensCount = this.getSpanTokensCount(span);\n    const cost = this.getSpanCost(span);\n    const ioData = this.getSpanInputOutput(span);\n    const title = generateOpenTelemetrySpanTitle(span);\n\n    return {\n      id: span.spanId,\n      title,\n      type,\n      status,\n      attributes: span.attributes,\n      duration,\n      tokensCount,\n      raw: JSON.stringify(span, null, 2),\n      cost,\n      startTime: convertNanoTimestampToDate(span.startTimeUnixNano),\n      endTime: convertNanoTimestampToDate(span.endTimeUnixNano),\n      children,\n      input: ioData.input,\n      output: ioData.output,\n    };\n  },\n\n  getSpanDuration(span: OpenTelemetrySpan): number {\n    // Convert string nanosecond timestamps to BigInt for precise arithmetic\n    const startNano = BigInt(span.startTimeUnixNano);\n    const endNano = BigInt(span.endTimeUnixNano);\n\n    // Calculate duration in nanoseconds\n    const durationNano = endNano - startNano;\n\n    // Divide by 1_000_000 to get milliseconds\n    return Number(durationNano / BigInt(1_000_000));\n  },\n\n  getSpanCost(span: OpenTelemetrySpan): number {\n    const inputCost = getOpenTelemetryAttributeValue(\n      span,\n      OPENTELEMETRY_GENAI_ATTRIBUTES.USAGE_INPUT_COST,\n    );\n\n    const outputCost = getOpenTelemetryAttributeValue(\n      span,\n      OPENTELEMETRY_GENAI_ATTRIBUTES.USAGE_OUTPUT_COST,\n    );\n\n    let totalCost = 0;\n\n    if (typeof inputCost === \"number\") {\n      totalCost += inputCost;\n    }\n\n    if (typeof outputCost === \"number\") {\n      totalCost += outputCost;\n    }\n\n    // If both are missing, use fallback\n    if (totalCost === 0) {\n      const fallbackCost = getOpenTelemetryAttributeValue(\n        span,\n        \"gen_ai.usage.cost\",\n      );\n\n      if (typeof fallbackCost === \"number\") {\n        totalCost = fallbackCost;\n      }\n    }\n\n    return totalCost;\n  },\n\n  getSpanTokensCount(span: OpenTelemetrySpan): number {\n    const totalTokens = getOpenTelemetryAttributeValue(\n      span,\n      OPENTELEMETRY_GENAI_ATTRIBUTES.USAGE_TOTAL_TOKENS,\n    );\n    const inputTokens = getOpenTelemetryAttributeValue(\n      span,\n      OPENTELEMETRY_GENAI_ATTRIBUTES.USAGE_INPUT_TOKENS,\n    );\n    const outputTokens = getOpenTelemetryAttributeValue(\n      span,\n      OPENTELEMETRY_GENAI_ATTRIBUTES.USAGE_OUTPUT_TOKENS,\n    );\n\n    if (typeof totalTokens === \"number\") {\n      return totalTokens;\n    }\n\n    const input = typeof inputTokens === \"number\" ? inputTokens : 0;\n    const output = typeof outputTokens === \"number\" ? outputTokens : 0;\n\n    return input + output;\n  },\n\n  getSpanInputOutput(span: OpenTelemetrySpan): InputOutputData {\n    const input = getOpenTelemetryAttributeValue(\n      span,\n      INPUT_OUTPUT_ATTRIBUTES.INPUT_VALUE,\n    );\n    const output = getOpenTelemetryAttributeValue(\n      span,\n      INPUT_OUTPUT_ATTRIBUTES.OUTPUT_VALUE,\n    );\n\n    return {\n      input: typeof input === \"string\" ? input : undefined,\n      output: typeof output === \"string\" ? output : undefined,\n    };\n  },\n\n  getSpanStatus(span: OpenTelemetrySpan): TraceSpanStatus {\n    switch (span.status.code) {\n      case \"STATUS_CODE_OK\":\n        return \"success\";\n      case \"STATUS_CODE_ERROR\":\n        return \"error\";\n      default:\n        return \"warning\";\n    }\n  },\n\n  getSpanCategory(span: OpenTelemetrySpan): TraceSpanCategory {\n    const standard = getOpenTelemetrySpanStandard(span);\n\n    switch (standard) {\n      case \"opentelemetry_genai\": {\n        const category = categorizeOpenTelemetryGenAI(span);\n        return category !== \"unknown\"\n          ? category\n          : categorizeStandardOpenTelemetry(span);\n      }\n\n      case \"openinference\": {\n        const category = categorizeOpenInference(span);\n        return category !== \"unknown\"\n          ? category\n          : categorizeStandardOpenTelemetry(span);\n      }\n\n      case \"standard\":\n      default: {\n        return categorizeStandardOpenTelemetry(span);\n      }\n    }\n  },\n};\n", "import type {\n  InputOutputData,\n  LangfuseDocument,\n  LangfuseObservation,\n  TraceSpan,\n  TraceSpanCategory,\n  TraceSpanStatus,\n} from \"@evilmartians/agent-prism-types\";\n\nimport type { SpanAdapter } from \"../types\";\n\nexport const langfuseSpanAdapter: SpanAdapter<\n  LangfuseDocument,\n  LangfuseObservation\n> = {\n  convertRawDocumentsToSpans(documents: LangfuseDocument[]): TraceSpan[] {\n    // Handle both single document and array of documents\n    const docArray = Array.isArray(documents) ? documents : [documents];\n\n    // Extract all spans from all documents, resource spans and scope spans\n    const allObservations: LangfuseObservation[] = [];\n\n    docArray.forEach((document) => {\n      document.observations.forEach((observation) => {\n        allObservations.push(observation);\n      });\n    });\n\n    // Convert the flat array of spans to a tree structure\n    return this.convertRawSpansToSpanTree(allObservations);\n  },\n  convertRawSpansToSpanTree(spans: LangfuseObservation[]): TraceSpan[] {\n    const spanMap = new Map<string, TraceSpan>();\n    const rootSpans: TraceSpan[] = [];\n\n    // First pass: create all span objects\n    spans.forEach((span) => {\n      const convertedSpan = this.convertRawSpanToTraceSpan(span);\n      spanMap.set(convertedSpan.id, convertedSpan);\n    });\n\n    // Second pass: build parent-child relationships\n    spans.forEach((span) => {\n      const convertedSpan = spanMap.get(span.id)!;\n      const parentSpanId = span.parentObservationId;\n\n      if (parentSpanId) {\n        const parent = spanMap.get(parentSpanId);\n        if (parent) {\n          if (!parent.children) {\n            parent.children = [];\n          }\n          parent.children.push(convertedSpan);\n        }\n      } else {\n        rootSpans.push(convertedSpan);\n      }\n    });\n\n    return rootSpans;\n  },\n  convertRawSpanToTraceSpan(\n    span: LangfuseObservation,\n    children: TraceSpan[] = [],\n  ): TraceSpan {\n    const duration = this.getSpanDuration(span);\n    const status = this.getSpanStatus(span);\n    const tokensCount = this.getSpanTokensCount(span);\n    const cost = this.getSpanCost(span);\n    const ioData = this.getSpanInputOutput(span);\n    const type = this.getSpanCategory(span);\n\n    return {\n      id: span.id,\n      title: span.name,\n      type,\n      status,\n      duration,\n      tokensCount,\n      raw: JSON.stringify(span, null, 2),\n      cost,\n      startTime: new Date(span.startTime),\n      endTime: new Date(span.endTime),\n      children,\n      input: ioData.input,\n      output: ioData.output,\n    };\n  },\n  getSpanDuration(span: LangfuseObservation): number {\n    if (!span.endTime || !span.startTime) {\n      return 0;\n    }\n    try {\n      return (\n        new Date(span.endTime).getTime() - new Date(span.startTime).getTime()\n      );\n    } catch {\n      return 0;\n    }\n  },\n  getSpanCost(span: LangfuseObservation): number {\n    return span.costDetails?.total || 0;\n  },\n  getSpanTokensCount(span: LangfuseObservation): number {\n    return span.usageDetails?.total || 0;\n  },\n  getSpanInputOutput(span: LangfuseObservation): InputOutputData {\n    return {\n      input: typeof span.input === \"string\" ? span.input : undefined,\n      output: typeof span.output === \"string\" ? span.output : undefined,\n    };\n  },\n  getSpanStatus(): TraceSpanStatus {\n    return \"success\";\n  },\n  getSpanCategory(span: LangfuseObservation): TraceSpanCategory {\n    switch (span.type) {\n      case \"SPAN\":\n        return \"span\";\n      case \"TOOL\":\n        return \"tool_execution\";\n      case \"GENERATION\":\n        return \"llm_call\";\n      case \"EVENT\":\n        return \"event\";\n      case \"AGENT\":\n        return \"agent_invocation\";\n      case \"CHAIN\":\n        return \"chain_operation\";\n      case \"RETRIEVER\":\n        return \"retrieval\";\n      case \"EMBEDDING\":\n        return \"embedding\";\n      case \"GUARDRAIL\":\n        return \"guardrail\";\n      case \"UNKNOWN\":\n        return \"unknown\";\n      default:\n        return \"unknown\";\n    }\n  },\n};\n"],
  "mappings": ";;;AAEO,IAAM,gBAAgB,CAAC,aAAgC;AAC5D,QAAM,UAAU,CAAC,SAAS;AAC1B,QAAM,QAAQ,CAAC,SAAS;AACxB,SAAO,QAAQ;AACjB;;;ACNO,IAAM,iBAAiB,CAAC,eAA+B;AAC5D,MAAI,aAAa,IAAM,QAAO,GAAG,KAAK,MAAM,UAAU,CAAC;AACvD,MAAI,aAAa,IAAO,QAAO,GAAG,KAAK,MAAM,aAAa,GAAI,CAAC;AAC/D,MAAI,aAAa,MAAS;AACxB,UAAMA,KAAI,KAAK,MAAM,aAAa,GAAK;AACvC,UAAM,IAAI,KAAK,MAAO,aAAa,MAAS,GAAI;AAChD,WAAO,IAAI,IAAI,GAAGA,EAAC,KAAK,CAAC,MAAM,GAAGA,EAAC;AAAA,EACrC;AACA,QAAM,IAAI,KAAK,MAAM,aAAa,IAAO;AACzC,QAAM,IAAI,KAAK,MAAO,aAAa,OAAW,GAAK;AACnD,SAAO,IAAI,IAAI,GAAG,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC;AACrC;;;ACPO,IAAM,kBAAkB,CAAC;AAAA,EAC9B;AAAA,EACA;AAAA,EACA;AACF,MAIM;AACJ,QAAM,UAAU,CAAC,SAAS;AAC1B,QAAM,aAAa,SAAS;AAC5B,QAAM,aAAa,cAAc,QAAQ;AACzC,QAAM,gBAAiB,UAAU,YAAY,aAAc;AAC3D,QAAM,eAAgB,aAAa,aAAc;AAEjD,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACF;;;ACjBO,IAAM,eAAe,CAAC,UAAoC;AAC/D,QAAM,SAAsB,CAAC;AAE7B,QAAM,WAAW,CAAC,UAAuB;AACvC,UAAM,QAAQ,CAAC,SAAS;AAX5B;AAYM,aAAO,KAAK,IAAI;AAChB,WAAI,UAAK,aAAL,mBAAe,QAAQ;AACzB,iBAAS,KAAK,QAAQ;AAAA,MACxB;AAAA,IACF,CAAC;AAAA,EACH;AAEA,WAAS,KAAK;AACd,SAAO;AACT;;;ACnBO,SAAS,cAAc,OAG5B;AACA,SAAO,MAAM;AAAA,IACX,CAAC,KAAK,MAAM;AACV,YAAM,QAAQ,CAAC,IAAI,KAAK,EAAE,SAAS;AACnC,YAAM,MAAM,CAAC,IAAI,KAAK,EAAE,OAAO;AAC/B,aAAO;AAAA,QACL,UAAU,KAAK,IAAI,IAAI,UAAU,KAAK;AAAA,QACtC,QAAQ,KAAK,IAAI,IAAI,QAAQ,GAAG;AAAA,MAClC;AAAA,IACF;AAAA,IACA;AAAA,MACE,UAAU,MAAM,SAAS,IAAI,CAAC,IAAI,KAAK,MAAM,CAAC,EAAE,SAAS,IAAI;AAAA,MAC7D,QAAQ,MAAM,SAAS,IAAI,CAAC,IAAI,KAAK,MAAM,CAAC,EAAE,OAAO,IAAI;AAAA,IAC3D;AAAA,EACF;AACF;;;ACjBO,IAAM,iCAAiC;AAAA,EAC5C,gBAAgB;AAAA,EAChB,QAAQ;AAAA,EACR,OAAO;AAAA,EACP,YAAY;AAAA,EACZ,WAAW;AAAA;AAAA,EAEX,oBAAoB;AAAA,EACpB,qBAAqB;AAAA,EACrB,oBAAoB;AAAA,EACpB,YAAY;AAAA,EACZ,kBAAkB;AAAA,EAClB,mBAAmB;AAAA;AAAA,EAEnB,qBAAqB;AAAA,EACrB,gBAAgB;AAAA;AAAA,EAEhB,eAAe;AACjB;AAEO,IAAM,2BAA2B;AAAA,EACtC,WAAW;AAAA,EACX,WAAW;AAAA,EACX,gBAAgB;AAAA,EAChB,qBAAqB;AAAA,EACrB,iBAAiB;AACnB;AAEO,IAAM,oCAAoC;AAAA,EAC/C,aAAa;AAAA,EACb,UAAU;AAAA,EACV,WAAW;AAAA,EACX,cAAc;AAAA,EACd,eAAe;AAAA,EACf,eAAe;AAAA,EACf,eAAe;AACjB;AAGO,IAAM,+BAAkE;AAAA;AAAA,EAE7E,MAAM;AAAA,EACN,kBAAkB;AAAA,EAClB,iBAAiB;AAAA;AAAA,EAGjB,cAAc;AAAA;AAAA,EAGd,cAAc;AAAA,EACd,cAAc;AAAA;AAAA,EAGd,YAAY;AACd;AAGO,IAAM,yBAA4D;AAAA,EACvE,KAAK;AAAA,EACL,MAAM;AAAA,EACN,OAAO;AAAA,EACP,OAAO;AAAA,EACP,WAAW;AAAA,EACX,WAAW;AACb;AAGO,IAAM,kCAAkC;AAAA,EAC7C,eAAe,CAAC;AAAA,EAChB,mBAAmB,CAAC;AAAA,EACpB,mBAAmB,CAAC,QAAQ,UAAU;AAAA,EACtC,cAAc,CAAC,UAAU,aAAa,OAAO,QAAQ;AAAA,EACrD,gBAAgB,CAAC,SAAS,YAAY,WAAW;AAAA,EACjD,gBAAgB,CAAC,OAAO;AAAA,EACxB,oBAAoB,CAAC,YAAY,UAAU,aAAa,UAAU,QAAQ;AAC5E;AAEO,IAAM,0BAA0B;AAAA,EACrC,aAAa;AAAA,EACb,cAAc;AAChB;;;ACjFO,SAAS,+BACd,MACA,KACuC;AACvC,QAAM,OAAO,KAAK,WAAW,KAAK,CAAC,MAAM,EAAE,QAAQ,GAAG;AAEtD,MAAI,CAAC,MAAM;AACT,WAAO;AAAA,EACT;AAEA,QAAM,EAAE,MAAM,IAAI;AAElB,MAAI,MAAM,gBAAgB,QAAW;AACnC,WAAO,MAAM;AAAA,EACf;AAEA,MAAI,MAAM,aAAa,QAAW;AAChC,WAAO,WAAW,MAAM,QAAQ;AAAA,EAClC;AAEA,MAAI,MAAM,cAAc,QAAW;AACjC,WAAO,MAAM;AAAA,EACf;AAEA,SAAO;AACT;;;AClBO,SAAS,wBACd,MACmB;AACnB,QAAM,WAAW;AAAA,IACf;AAAA,IACA,yBAAyB;AAAA,EAC3B;AAEA,MAAI,OAAO,aAAa,UAAU;AAChC,UAAM,WAAW,uBAAuB,QAAQ;AAEhD,QAAI,SAAU,QAAO;AAAA,EACvB;AAEA,SAAO;AACT;;;ACfO,SAAS,6BACd,MACmB;AACnB,QAAM,gBAAgB;AAAA,IACpB;AAAA,IACA,+BAA+B;AAAA,EACjC;AAEA,MAAI,OAAO,kBAAkB,UAAU;AACrC,UAAM,WAAW,6BAA6B,aAAa;AAE3D,QAAI,SAAU,QAAO;AAAA,EACvB;AAEA,SAAO;AACT;;;AChBO,IAAM,+BAA+B;AAAA,EAC1C,YAAY,CAAC,SAAqC;AAChD,WACE;AAAA,MACE;AAAA,MACA,kCAAkC;AAAA,IACpC,MAAM;AAAA,EAEV;AAAA,EAEA,gBAAgB,CAAC,SAAqC;AACpD,WACE;AAAA,MACE;AAAA,MACA,kCAAkC;AAAA,IACpC,MAAM;AAAA,EAEV;AAAA,EAEA,gBAAgB,CAAC,SAAqC;AACpD,UAAM,OAAO,KAAK,KAAK,YAAY;AAEnC,WACE,gCAAgC,kBAAkB;AAAA,MAAK,CAAC,YACtD,KAAK,SAAS,OAAO;AAAA,IACvB,KACA;AAAA,MACE;AAAA,MACA,kCAAkC;AAAA,IACpC,MAAM;AAAA,EAEV;AAAA,EAEA,WAAW,CAAC,SAAqC;AAC/C,UAAM,OAAO,KAAK,KAAK,YAAY;AAEnC,WAAO,gCAAgC,aAAa;AAAA,MAAK,CAAC,YACxD,KAAK,SAAS,OAAO;AAAA,IACvB;AAAA,EACF;AAAA,EAEA,kBAAkB,CAAC,SAAqC;AACtD,UAAM,OAAO,KAAK,KAAK,YAAY;AAEnC,WAAO,gCAAgC,eAAe;AAAA,MAAK,CAAC,YAC1D,KAAK,SAAS,OAAO;AAAA,IACvB;AAAA,EACF;AAAA,EAEA,kBAAkB,CAAC,SAAqC;AACtD,UAAM,OAAO,KAAK,KAAK,YAAY;AAEnC,WAAO,gCAAgC,eAAe;AAAA,MAAK,CAAC,YAC1D,KAAK,SAAS,OAAO;AAAA,IACvB;AAAA,EACF;AAAA,EAEA,sBAAsB,CAAC,SAAqC;AAC1D,UAAM,OAAO,KAAK,KAAK,YAAY;AAEnC,WAAO,gCAAgC,mBAAmB;AAAA,MAAK,CAAC,YAC9D,KAAK,SAAS,OAAO;AAAA,IACvB;AAAA,EACF;AACF;;;ACjEO,SAAS,gCACd,MACmB;AAEnB,MAAI,6BAA6B,UAAU,IAAI,EAAG,QAAO;AACzD,MAAI,6BAA6B,iBAAiB,IAAI;AACpD,WAAO;AACT,MAAI,6BAA6B,iBAAiB,IAAI;AACpD,WAAO;AACT,MAAI,6BAA6B,qBAAqB,IAAI;AACxD,WAAO;AACT,MAAI,6BAA6B,eAAe,IAAI;AAClD,WAAO;AACT,MAAI,6BAA6B,WAAW,IAAI,EAAG,QAAO;AAC1D,MAAI,6BAA6B,eAAe,IAAI;AAClD,WAAO;AAET,SAAO;AACT;;;ACzBO,SAAS,2BAA2B,YAA0B;AACnE,QAAM,cAAc,OAAO,UAAU;AACrC,QAAM,eAAe,OAAO,cAAc,QAAU;AAEpD,SAAO,IAAI,KAAK,YAAY;AAC9B;;;ACGO,SAAS,+BACd,MACQ;AACR,QAAM,EAAE,KAAK,IAAI;AAGjB,QAAM,QAAQ;AAAA,IACZ;AAAA,IACA,+BAA+B;AAAA,EACjC;AAEA,MAAI,OAAO;AACT,WAAO,GAAG,KAAK,MAAM,IAAI;AAAA,EAC3B;AAGA,QAAM,aAAa;AAAA,IACjB;AAAA,IACA,kCAAkC;AAAA,EACpC;AACA,QAAM,YAAY;AAAA,IAChB;AAAA,IACA,kCAAkC;AAAA,EACpC;AAEA,MAAI,cAAc,WAAW;AAC3B,WAAO,GAAG,UAAU,MAAM,SAAS;AAAA,EACrC;AAGA,QAAM,SAAS;AAAA,IACb;AAAA,IACA,kCAAkC;AAAA,EACpC;AACA,QAAM,MAAM;AAAA,IACV;AAAA,IACA,kCAAkC;AAAA,EACpC;AAEA,MAAI,UAAU,KAAK;AACjB,WAAO,GAAG,MAAM,IAAI,GAAG;AAAA,EACzB;AAEA,SAAO;AACT;;;AC3CO,SAAS,6BACd,MACuB;AAEvB,MACE;AAAA,IACE;AAAA,IACA,+BAA+B;AAAA,EACjC,KACA,+BAA+B,MAAM,+BAA+B,MAAM,GAC1E;AACA,WAAO;AAAA,EACT;AAGA,MACE,+BAA+B,MAAM,yBAAyB,SAAS,KACvE,+BAA+B,MAAM,yBAAyB,SAAS,GACvE;AACA,WAAO;AAAA,EACT;AAGA,SAAO;AACT;;;ACXO,IAAM,2BAGT;AAAA,EACF,2BACE,WACa;AACb,UAAM,WAAW,MAAM,QAAQ,SAAS,IAAI,YAAY,CAAC,SAAS;AAGlE,UAAM,WAAgC,CAAC;AAEvC,aAAS,QAAQ,CAAC,aAAa;AAC7B,eAAS,cAAc,QAAQ,CAAC,iBAAiB;AAC/C,qBAAa,WAAW,QAAQ,CAAC,cAAc;AAC7C,mBAAS,KAAK,GAAG,UAAU,KAAK;AAAA,QAClC,CAAC;AAAA,MACH,CAAC;AAAA,IACH,CAAC;AAGD,WAAO,KAAK,0BAA0B,QAAQ;AAAA,EAChD;AAAA,EAEA,0BAA0B,OAAyC;AACjE,UAAM,UAAU,oBAAI,IAAuB;AAC3C,UAAM,YAAyB,CAAC;AAGhC,UAAM,QAAQ,CAAC,SAAS;AACtB,YAAM,gBAAgB,KAAK,0BAA0B,IAAI;AACzD,cAAQ,IAAI,cAAc,IAAI,aAAa;AAAA,IAC7C,CAAC;AAGD,UAAM,QAAQ,CAAC,SAAS;AACtB,YAAM,gBAAgB,QAAQ,IAAI,KAAK,MAAM;AAC7C,YAAM,eAAe,KAAK;AAE1B,UAAI,cAAc;AAChB,cAAM,SAAS,QAAQ,IAAI,YAAY;AACvC,YAAI,QAAQ;AACV,cAAI,CAAC,OAAO,UAAU;AACpB,mBAAO,WAAW,CAAC;AAAA,UACrB;AACA,iBAAO,SAAS,KAAK,aAAa;AAAA,QACpC;AAAA,MACF,OAAO;AACL,kBAAU,KAAK,aAAa;AAAA,MAC9B;AAAA,IACF,CAAC;AAED,WAAO;AAAA,EACT;AAAA,EAEA,0BACE,MACA,WAAwB,CAAC,GACd;AACX,UAAM,WAAW,KAAK,gBAAgB,IAAI;AAC1C,UAAM,SAAS,KAAK,cAAc,IAAI;AACtC,UAAM,OAAO,KAAK,gBAAgB,IAAI;AACtC,UAAM,cAAc,KAAK,mBAAmB,IAAI;AAChD,UAAM,OAAO,KAAK,YAAY,IAAI;AAClC,UAAM,SAAS,KAAK,mBAAmB,IAAI;AAC3C,UAAM,QAAQ,+BAA+B,IAAI;AAEjD,WAAO;AAAA,MACL,IAAI,KAAK;AAAA,MACT;AAAA,MACA;AAAA,MACA;AAAA,MACA,YAAY,KAAK;AAAA,MACjB;AAAA,MACA;AAAA,MACA,KAAK,KAAK,UAAU,MAAM,MAAM,CAAC;AAAA,MACjC;AAAA,MACA,WAAW,2BAA2B,KAAK,iBAAiB;AAAA,MAC5D,SAAS,2BAA2B,KAAK,eAAe;AAAA,MACxD;AAAA,MACA,OAAO,OAAO;AAAA,MACd,QAAQ,OAAO;AAAA,IACjB;AAAA,EACF;AAAA,EAEA,gBAAgB,MAAiC;AAE/C,UAAM,YAAY,OAAO,KAAK,iBAAiB;AAC/C,UAAM,UAAU,OAAO,KAAK,eAAe;AAG3C,UAAM,eAAe,UAAU;AAG/B,WAAO,OAAO,eAAe,OAAO,GAAS,CAAC;AAAA,EAChD;AAAA,EAEA,YAAY,MAAiC;AAC3C,UAAM,YAAY;AAAA,MAChB;AAAA,MACA,+BAA+B;AAAA,IACjC;AAEA,UAAM,aAAa;AAAA,MACjB;AAAA,MACA,+BAA+B;AAAA,IACjC;AAEA,QAAI,YAAY;AAEhB,QAAI,OAAO,cAAc,UAAU;AACjC,mBAAa;AAAA,IACf;AAEA,QAAI,OAAO,eAAe,UAAU;AAClC,mBAAa;AAAA,IACf;AAGA,QAAI,cAAc,GAAG;AACnB,YAAM,eAAe;AAAA,QACnB;AAAA,QACA;AAAA,MACF;AAEA,UAAI,OAAO,iBAAiB,UAAU;AACpC,oBAAY;AAAA,MACd;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AAAA,EAEA,mBAAmB,MAAiC;AAClD,UAAM,cAAc;AAAA,MAClB;AAAA,MACA,+BAA+B;AAAA,IACjC;AACA,UAAM,cAAc;AAAA,MAClB;AAAA,MACA,+BAA+B;AAAA,IACjC;AACA,UAAM,eAAe;AAAA,MACnB;AAAA,MACA,+BAA+B;AAAA,IACjC;AAEA,QAAI,OAAO,gBAAgB,UAAU;AACnC,aAAO;AAAA,IACT;AAEA,UAAM,QAAQ,OAAO,gBAAgB,WAAW,cAAc;AAC9D,UAAM,SAAS,OAAO,iBAAiB,WAAW,eAAe;AAEjE,WAAO,QAAQ;AAAA,EACjB;AAAA,EAEA,mBAAmB,MAA0C;AAC3D,UAAM,QAAQ;AAAA,MACZ;AAAA,MACA,wBAAwB;AAAA,IAC1B;AACA,UAAM,SAAS;AAAA,MACb;AAAA,MACA,wBAAwB;AAAA,IAC1B;AAEA,WAAO;AAAA,MACL,OAAO,OAAO,UAAU,WAAW,QAAQ;AAAA,MAC3C,QAAQ,OAAO,WAAW,WAAW,SAAS;AAAA,IAChD;AAAA,EACF;AAAA,EAEA,cAAc,MAA0C;AACtD,YAAQ,KAAK,OAAO,MAAM;AAAA,MACxB,KAAK;AACH,eAAO;AAAA,MACT,KAAK;AACH,eAAO;AAAA,MACT;AACE,eAAO;AAAA,IACX;AAAA,EACF;AAAA,EAEA,gBAAgB,MAA4C;AAC1D,UAAM,WAAW,6BAA6B,IAAI;AAElD,YAAQ,UAAU;AAAA,MAChB,KAAK,uBAAuB;AAC1B,cAAM,WAAW,6BAA6B,IAAI;AAClD,eAAO,aAAa,YAChB,WACA,gCAAgC,IAAI;AAAA,MAC1C;AAAA,MAEA,KAAK,iBAAiB;AACpB,cAAM,WAAW,wBAAwB,IAAI;AAC7C,eAAO,aAAa,YAChB,WACA,gCAAgC,IAAI;AAAA,MAC1C;AAAA,MAEA,KAAK;AAAA,MACL,SAAS;AACP,eAAO,gCAAgC,IAAI;AAAA,MAC7C;AAAA,IACF;AAAA,EACF;AACF;;;AC3NO,IAAM,sBAGT;AAAA,EACF,2BAA2B,WAA4C;AAErE,UAAM,WAAW,MAAM,QAAQ,SAAS,IAAI,YAAY,CAAC,SAAS;AAGlE,UAAM,kBAAyC,CAAC;AAEhD,aAAS,QAAQ,CAAC,aAAa;AAC7B,eAAS,aAAa,QAAQ,CAAC,gBAAgB;AAC7C,wBAAgB,KAAK,WAAW;AAAA,MAClC,CAAC;AAAA,IACH,CAAC;AAGD,WAAO,KAAK,0BAA0B,eAAe;AAAA,EACvD;AAAA,EACA,0BAA0B,OAA2C;AACnE,UAAM,UAAU,oBAAI,IAAuB;AAC3C,UAAM,YAAyB,CAAC;AAGhC,UAAM,QAAQ,CAAC,SAAS;AACtB,YAAM,gBAAgB,KAAK,0BAA0B,IAAI;AACzD,cAAQ,IAAI,cAAc,IAAI,aAAa;AAAA,IAC7C,CAAC;AAGD,UAAM,QAAQ,CAAC,SAAS;AACtB,YAAM,gBAAgB,QAAQ,IAAI,KAAK,EAAE;AACzC,YAAM,eAAe,KAAK;AAE1B,UAAI,cAAc;AAChB,cAAM,SAAS,QAAQ,IAAI,YAAY;AACvC,YAAI,QAAQ;AACV,cAAI,CAAC,OAAO,UAAU;AACpB,mBAAO,WAAW,CAAC;AAAA,UACrB;AACA,iBAAO,SAAS,KAAK,aAAa;AAAA,QACpC;AAAA,MACF,OAAO;AACL,kBAAU,KAAK,aAAa;AAAA,MAC9B;AAAA,IACF,CAAC;AAED,WAAO;AAAA,EACT;AAAA,EACA,0BACE,MACA,WAAwB,CAAC,GACd;AACX,UAAM,WAAW,KAAK,gBAAgB,IAAI;AAC1C,UAAM,SAAS,KAAK,cAAc,IAAI;AACtC,UAAM,cAAc,KAAK,mBAAmB,IAAI;AAChD,UAAM,OAAO,KAAK,YAAY,IAAI;AAClC,UAAM,SAAS,KAAK,mBAAmB,IAAI;AAC3C,UAAM,OAAO,KAAK,gBAAgB,IAAI;AAEtC,WAAO;AAAA,MACL,IAAI,KAAK;AAAA,MACT,OAAO,KAAK;AAAA,MACZ;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA,KAAK,KAAK,UAAU,MAAM,MAAM,CAAC;AAAA,MACjC;AAAA,MACA,WAAW,IAAI,KAAK,KAAK,SAAS;AAAA,MAClC,SAAS,IAAI,KAAK,KAAK,OAAO;AAAA,MAC9B;AAAA,MACA,OAAO,OAAO;AAAA,MACd,QAAQ,OAAO;AAAA,IACjB;AAAA,EACF;AAAA,EACA,gBAAgB,MAAmC;AACjD,QAAI,CAAC,KAAK,WAAW,CAAC,KAAK,WAAW;AACpC,aAAO;AAAA,IACT;AACA,QAAI;AACF,aACE,IAAI,KAAK,KAAK,OAAO,EAAE,QAAQ,IAAI,IAAI,KAAK,KAAK,SAAS,EAAE,QAAQ;AAAA,IAExE,QAAQ;AACN,aAAO;AAAA,IACT;AAAA,EACF;AAAA,EACA,YAAY,MAAmC;AApGjD;AAqGI,aAAO,UAAK,gBAAL,mBAAkB,UAAS;AAAA,EACpC;AAAA,EACA,mBAAmB,MAAmC;AAvGxD;AAwGI,aAAO,UAAK,iBAAL,mBAAmB,UAAS;AAAA,EACrC;AAAA,EACA,mBAAmB,MAA4C;AAC7D,WAAO;AAAA,MACL,OAAO,OAAO,KAAK,UAAU,WAAW,KAAK,QAAQ;AAAA,MACrD,QAAQ,OAAO,KAAK,WAAW,WAAW,KAAK,SAAS;AAAA,IAC1D;AAAA,EACF;AAAA,EACA,gBAAiC;AAC/B,WAAO;AAAA,EACT;AAAA,EACA,gBAAgB,MAA8C;AAC5D,YAAQ,KAAK,MAAM;AAAA,MACjB,KAAK;AACH,eAAO;AAAA,MACT,KAAK;AACH,eAAO;AAAA,MACT,KAAK;AACH,eAAO;AAAA,MACT,KAAK;AACH,eAAO;AAAA,MACT,KAAK;AACH,eAAO;AAAA,MACT,KAAK;AACH,eAAO;AAAA,MACT,KAAK;AACH,eAAO;AAAA,MACT,KAAK;AACH,eAAO;AAAA,MACT,KAAK;AACH,eAAO;AAAA,MACT,KAAK;AACH,eAAO;AAAA,MACT;AACE,eAAO;AAAA,IACX;AAAA,EACF;AACF;",
  "names": ["m"]
}
