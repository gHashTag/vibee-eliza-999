{
  "version": 3,
  "sources": ["../../src/interfaces/browser.ts", "../../src/interfaces/email.ts", "../../src/interfaces/lp.ts", "../../src/interfaces/message.ts", "../../src/interfaces/pdf.ts", "../../src/interfaces/post.ts", "../../src/interfaces/token.ts", "../../src/interfaces/transcription.ts", "../../src/interfaces/video.ts", "../../src/interfaces/wallet.ts", "../../src/interfaces/web-search.ts"],
  "sourcesContent": [
    "import { Service, ServiceType } from '@elizaos/core';\n\nexport interface BrowserNavigationOptions {\n  timeout?: number;\n  waitUntil?: 'load' | 'domcontentloaded' | 'networkidle0' | 'networkidle2';\n  viewport?: {\n    width: number;\n    height: number;\n  };\n  userAgent?: string;\n  headers?: Record<string, string>;\n}\n\nexport interface ScreenshotOptions {\n  fullPage?: boolean;\n  clip?: {\n    x: number;\n    y: number;\n    width: number;\n    height: number;\n  };\n  format?: 'png' | 'jpeg' | 'webp';\n  quality?: number;\n  omitBackground?: boolean;\n}\n\nexport interface ElementSelector {\n  selector: string;\n  text?: string;\n  timeout?: number;\n}\n\nexport interface ExtractedContent {\n  text: string;\n  html: string;\n  links: Array<{\n    url: string;\n    text: string;\n  }>;\n  images: Array<{\n    src: string;\n    alt?: string;\n  }>;\n  title?: string;\n  metadata?: Record<string, string>;\n}\n\nexport interface ClickOptions {\n  timeout?: number;\n  force?: boolean;\n  waitForNavigation?: boolean;\n}\n\nexport interface TypeOptions {\n  delay?: number;\n  timeout?: number;\n  clear?: boolean;\n}\n\n/**\n * Interface for browser automation services\n */\nexport abstract class IBrowserService extends Service {\n  static override readonly serviceType = ServiceType.BROWSER;\n\n  public readonly capabilityDescription = 'Web browser automation and scraping capabilities';\n\n  /**\n   * Navigate to a URL\n   * @param url - URL to navigate to\n   * @param options - Navigation options\n   * @returns Promise resolving when navigation completes\n   */\n  abstract navigate(url: string, options?: BrowserNavigationOptions): Promise<void>;\n\n  /**\n   * Take a screenshot of the current page\n   * @param options - Screenshot options\n   * @returns Promise resolving to screenshot buffer\n   */\n  abstract screenshot(options?: ScreenshotOptions): Promise<Buffer>;\n\n  /**\n   * Extract text and content from the current page\n   * @param selector - Optional CSS selector to extract from specific element\n   * @returns Promise resolving to extracted content\n   */\n  abstract extractContent(selector?: string): Promise<ExtractedContent>;\n\n  /**\n   * Click on an element\n   * @param selector - CSS selector or element selector\n   * @param options - Click options\n   * @returns Promise resolving when click completes\n   */\n  abstract click(selector: string | ElementSelector, options?: ClickOptions): Promise<void>;\n\n  /**\n   * Type text into an input field\n   * @param selector - CSS selector for input field\n   * @param text - Text to type\n   * @param options - Typing options\n   * @returns Promise resolving when typing completes\n   */\n  abstract type(selector: string, text: string, options?: TypeOptions): Promise<void>;\n\n  /**\n   * Wait for an element to appear\n   * @param selector - CSS selector or element selector\n   * @returns Promise resolving when element is found\n   */\n  abstract waitForElement(selector: string | ElementSelector): Promise<void>;\n\n  /**\n   * Evaluate JavaScript in the browser context\n   * @param script - JavaScript code to evaluate\n   * @param args - Arguments to pass to the script\n   * @returns Promise resolving to evaluation result\n   */\n  abstract evaluate<T = any>(script: string, ...args: any[]): Promise<T>;\n\n  /**\n   * Get the current page URL\n   * @returns Promise resolving to current URL\n   */\n  abstract getCurrentUrl(): Promise<string>;\n\n  /**\n   * Go back in browser history\n   * @returns Promise resolving when navigation completes\n   */\n  abstract goBack(): Promise<void>;\n\n  /**\n   * Go forward in browser history\n   * @returns Promise resolving when navigation completes\n   */\n  abstract goForward(): Promise<void>;\n\n  /**\n   * Refresh the current page\n   * @returns Promise resolving when refresh completes\n   */\n  abstract refresh(): Promise<void>;\n}\n",
    "import { Service, ServiceType } from '@elizaos/core';\n\nexport interface EmailAddress {\n  email: string;\n  name?: string;\n}\n\nexport interface EmailAttachment {\n  filename: string;\n  content: Buffer | string;\n  contentType?: string;\n  contentDisposition?: 'attachment' | 'inline';\n  cid?: string;\n}\n\nexport interface EmailMessage {\n  from: EmailAddress;\n  to: EmailAddress[];\n  cc?: EmailAddress[];\n  bcc?: EmailAddress[];\n  subject: string;\n  text?: string;\n  html?: string;\n  attachments?: EmailAttachment[];\n  replyTo?: EmailAddress;\n  date?: Date;\n  messageId?: string;\n  references?: string[];\n  inReplyTo?: string;\n  priority?: 'high' | 'normal' | 'low';\n}\n\nexport interface EmailSendOptions {\n  retry?: number;\n  timeout?: number;\n  trackOpens?: boolean;\n  trackClicks?: boolean;\n  tags?: string[];\n}\n\nexport interface EmailSearchOptions {\n  query?: string;\n  from?: string;\n  to?: string;\n  subject?: string;\n  folder?: string;\n  since?: Date;\n  before?: Date;\n  limit?: number;\n  offset?: number;\n  unread?: boolean;\n  flagged?: boolean;\n  hasAttachments?: boolean;\n}\n\nexport interface EmailFolder {\n  name: string;\n  path: string;\n  type: 'inbox' | 'sent' | 'drafts' | 'trash' | 'spam' | 'custom';\n  messageCount?: number;\n  unreadCount?: number;\n  children?: EmailFolder[];\n}\n\nexport interface EmailAccount {\n  email: string;\n  name?: string;\n  provider?: string;\n  folders?: EmailFolder[];\n  quotaUsed?: number;\n  quotaLimit?: number;\n}\n\n/**\n * Interface for email services\n */\nexport abstract class IEmailService extends Service {\n  static override readonly serviceType = ServiceType.EMAIL;\n\n  public readonly capabilityDescription = 'Email sending, receiving, and management capabilities';\n\n  /**\n   * Send an email\n   * @param message - Email message to send\n   * @param options - Send options\n   * @returns Promise resolving to message ID\n   */\n  abstract sendEmail(message: EmailMessage, options?: EmailSendOptions): Promise<string>;\n\n  /**\n   * Get emails from a folder\n   * @param options - Search options\n   * @returns Promise resolving to array of emails\n   */\n  abstract getEmails(options?: EmailSearchOptions): Promise<EmailMessage[]>;\n\n  /**\n   * Get a specific email by ID\n   * @param messageId - Message ID\n   * @returns Promise resolving to email message\n   */\n  abstract getEmail(messageId: string): Promise<EmailMessage>;\n\n  /**\n   * Delete an email\n   * @param messageId - Message ID\n   * @returns Promise resolving when deletion completes\n   */\n  abstract deleteEmail(messageId: string): Promise<void>;\n\n  /**\n   * Mark an email as read/unread\n   * @param messageId - Message ID\n   * @param read - True to mark as read, false for unread\n   * @returns Promise resolving when operation completes\n   */\n  abstract markEmailAsRead(messageId: string, read: boolean): Promise<void>;\n\n  /**\n   * Flag/unflag an email\n   * @param messageId - Message ID\n   * @param flagged - True to flag, false to unflag\n   * @returns Promise resolving when operation completes\n   */\n  abstract flagEmail(messageId: string, flagged: boolean): Promise<void>;\n\n  /**\n   * Move email to a different folder\n   * @param messageId - Message ID\n   * @param folderPath - Destination folder path\n   * @returns Promise resolving when move completes\n   */\n  abstract moveEmail(messageId: string, folderPath: string): Promise<void>;\n\n  /**\n   * Get available folders\n   * @returns Promise resolving to array of folders\n   */\n  abstract getFolders(): Promise<EmailFolder[]>;\n\n  /**\n   * Create a new folder\n   * @param folderName - Name of the folder\n   * @param parentPath - Optional parent folder path\n   * @returns Promise resolving when folder is created\n   */\n  abstract createFolder(folderName: string, parentPath?: string): Promise<void>;\n\n  /**\n   * Get account information\n   * @returns Promise resolving to account details\n   */\n  abstract getAccountInfo(): Promise<EmailAccount>;\n\n  /**\n   * Search emails\n   * @param query - Search query\n   * @param options - Search options\n   * @returns Promise resolving to search results\n   */\n  abstract searchEmails(query: string, options?: EmailSearchOptions): Promise<EmailMessage[]>;\n}\n",
    "import { Service, type Metadata } from '@elizaos/core';\nimport type { TokenBalance } from './token';\n\n/**\n * A standardized representation of a liquidity pool from any DEX.\n */\nexport type PoolInfo = {\n  id: string; // Unique identifier for the pool (e.g., LP token mint or a DEX-specific ID).\n  displayName?: string; // User-friendly name for the pool.\n  dex: string; // Identifier for the DEX (e.g., \"orca\", \"raydium\").\n  tokenA: {\n    mint: string;\n    symbol?: string;\n    reserve?: string;\n    decimals?: number;\n  };\n  tokenB: {\n    mint: string;\n    symbol?: string;\n    reserve?: string;\n    decimals?: number;\n  };\n  lpTokenMint?: string;\n  apr?: number; // Annual Percentage Rate.\n  apy?: number; // Annual Percentage Yield.\n  tvl?: number; // Total Value Locked in USD.\n  fee?: number; // Trading fee percentage.\n  metadata?: Metadata; // For DEX-specific extra data.\n};\n\n/**\n * A standardized representation of a user's position in a liquidity pool.\n */\nexport type LpPositionDetails = {\n  poolId: string;\n  dex: string;\n  lpTokenBalance: TokenBalance;\n  underlyingTokens: TokenBalance[]; // Array of two token balances.\n  valueUsd?: number;\n  accruedFees?: TokenBalance[];\n  rewards?: TokenBalance[];\n  metadata?: Metadata; // For additional DEX-specific position data.\n};\n\n/**\n * A standardized result for blockchain transactions.\n */\nexport type TransactionResult = {\n  success: boolean;\n  transactionId?: string;\n  error?: string;\n  data?: any;\n};\n\n/**\n * Abstract interface for a Liquidity Pool Service.\n * DEX-specific plugins (e.g., for Orca, Raydium) must implement this service\n * to allow the LP Manager to interact with them in a standardized way.\n */\nexport abstract class ILpService extends Service {\n  static override readonly serviceType = 'lp';\n\n  public readonly capabilityDescription = 'Provides standardized access to DEX liquidity pools.';\n\n  /**\n   * Returns the name of the DEX this service interacts with.\n   * @returns The name of the DEX (e.g., \"Orca\", \"Raydium\").\n   */\n  abstract getDexName(): string;\n\n  /**\n   * Fetches a list of available liquidity pools from the DEX.\n   * @param tokenAMint - Optional: Filter pools by the mint address of the first token.\n   * @param tokenBMint - Optional: Filter pools by the mint address of the second token.\n   * @returns A promise that resolves to an array of standardized PoolInfo objects.\n   */\n  abstract getPools(tokenAMint?: string, tokenBMint?: string): Promise<PoolInfo[]>;\n\n  /**\n   * Adds liquidity to a specified pool.\n   * @param params - The parameters for adding liquidity.\n   * @returns A promise resolving to a transaction result, including the LP tokens received.\n   */\n  abstract addLiquidity(params: {\n    userVault: any;\n    poolId: string;\n    tokenAAmountLamports: string;\n    tokenBAmountLamports?: string;\n    slippageBps: number;\n    tickLowerIndex?: number; // For concentrated liquidity\n    tickUpperIndex?: number; // For concentrated liquidity\n  }): Promise<TransactionResult & { lpTokensReceived?: TokenBalance }>;\n\n  /**\n   * Removes liquidity from a specified pool.\n   * @param params - The parameters for removing liquidity.\n   * @returns A promise resolving to a transaction result, including the tokens received.\n   */\n  abstract removeLiquidity(params: {\n    userVault: any;\n    poolId: string;\n    lpTokenAmountLamports: string;\n    slippageBps: number;\n  }): Promise<TransactionResult & { tokensReceived?: TokenBalance[] }>;\n\n  /**\n   * Fetches the details of a specific LP position for a user.\n   * @param userAccountPublicKey - The user's wallet public key.\n   * @param poolOrPositionIdentifier - The identifier for the pool or a specific position (e.g., position NFT mint).\n   * @returns A promise resolving to the position details or null if not found.\n   */\n  abstract getLpPositionDetails(\n    userAccountPublicKey: string,\n    poolOrPositionIdentifier: string\n  ): Promise<LpPositionDetails | null>;\n\n  /**\n   * Fetches the latest market data (e.g., APY, TVL) for a list of pools.\n   * @param poolIds - An array of pool IDs to fetch data for.\n   * @returns A promise resolving to a map of pool IDs to their partial market data.\n   */\n  abstract getMarketDataForPools(poolIds: string[]): Promise<Record<string, Partial<PoolInfo>>>;\n}\n",
    "import { Service, ServiceType, type UUID } from '@elizaos/core';\n\nexport interface MessageParticipant {\n  id: UUID;\n  name: string;\n  username?: string;\n  avatar?: string;\n  status?: 'online' | 'offline' | 'away' | 'busy';\n}\n\nexport interface MessageAttachment {\n  id: UUID;\n  filename: string;\n  url: string;\n  mimeType: string;\n  size: number;\n  width?: number;\n  height?: number;\n  duration?: number;\n  thumbnail?: string;\n}\n\nexport interface MessageReaction {\n  emoji: string;\n  count: number;\n  users: UUID[];\n  hasReacted: boolean;\n}\n\nexport interface MessageReference {\n  messageId: UUID;\n  channelId: UUID;\n  type: 'reply' | 'forward' | 'quote';\n}\n\nexport interface MessageContent {\n  text?: string;\n  html?: string;\n  markdown?: string;\n  attachments?: MessageAttachment[];\n  reactions?: MessageReaction[];\n  reference?: MessageReference;\n  mentions?: UUID[];\n  embeds?: Array<{\n    title?: string;\n    description?: string;\n    url?: string;\n    image?: string;\n    fields?: Array<{\n      name: string;\n      value: string;\n      inline?: boolean;\n    }>;\n  }>;\n}\n\nexport interface MessageInfo {\n  id: UUID;\n  channelId: UUID;\n  senderId: UUID;\n  content: MessageContent;\n  timestamp: Date;\n  edited?: Date;\n  deleted?: Date;\n  pinned?: boolean;\n  thread?: {\n    id: UUID;\n    messageCount: number;\n    participants: UUID[];\n    lastMessageAt: Date;\n  };\n}\n\nexport interface MessageSendOptions {\n  replyTo?: UUID;\n  ephemeral?: boolean;\n  silent?: boolean;\n  scheduled?: Date;\n  thread?: UUID;\n  nonce?: string;\n}\n\nexport interface MessageSearchOptions {\n  query?: string;\n  channelId?: UUID;\n  senderId?: UUID;\n  before?: Date;\n  after?: Date;\n  limit?: number;\n  offset?: number;\n  hasAttachments?: boolean;\n  pinned?: boolean;\n  mentions?: UUID;\n}\n\nexport interface MessageChannel {\n  id: UUID;\n  name: string;\n  type: 'text' | 'voice' | 'dm' | 'group' | 'announcement' | 'thread';\n  description?: string;\n  participants?: MessageParticipant[];\n  permissions?: {\n    canSend: boolean;\n    canRead: boolean;\n    canDelete: boolean;\n    canPin: boolean;\n    canManage: boolean;\n  };\n  lastMessageAt?: Date;\n  messageCount?: number;\n  unreadCount?: number;\n}\n\n/**\n * Interface for messaging services\n */\nexport abstract class IMessageService extends Service {\n  static override readonly serviceType = ServiceType.MESSAGE;\n\n  public readonly capabilityDescription = 'Message sending, receiving, and management capabilities';\n\n  /**\n   * Send a message to a channel\n   * @param channelId - Channel ID\n   * @param content - Message content\n   * @param options - Send options\n   * @returns Promise resolving to message ID\n   */\n  abstract sendMessage(\n    channelId: UUID,\n    content: MessageContent,\n    options?: MessageSendOptions\n  ): Promise<UUID>;\n\n  /**\n   * Get messages from a channel\n   * @param channelId - Channel ID\n   * @param options - Search options\n   * @returns Promise resolving to array of messages\n   */\n  abstract getMessages(channelId: UUID, options?: MessageSearchOptions): Promise<MessageInfo[]>;\n\n  /**\n   * Get a specific message by ID\n   * @param messageId - Message ID\n   * @returns Promise resolving to message\n   */\n  abstract getMessage(messageId: UUID): Promise<MessageInfo>;\n\n  /**\n   * Edit a message\n   * @param messageId - Message ID\n   * @param content - New message content\n   * @returns Promise resolving when edit completes\n   */\n  abstract editMessage(messageId: UUID, content: MessageContent): Promise<void>;\n\n  /**\n   * Delete a message\n   * @param messageId - Message ID\n   * @returns Promise resolving when deletion completes\n   */\n  abstract deleteMessage(messageId: UUID): Promise<void>;\n\n  /**\n   * Add a reaction to a message\n   * @param messageId - Message ID\n   * @param emoji - Reaction emoji\n   * @returns Promise resolving when reaction is added\n   */\n  abstract addReaction(messageId: UUID, emoji: string): Promise<void>;\n\n  /**\n   * Remove a reaction from a message\n   * @param messageId - Message ID\n   * @param emoji - Reaction emoji\n   * @returns Promise resolving when reaction is removed\n   */\n  abstract removeReaction(messageId: UUID, emoji: string): Promise<void>;\n\n  /**\n   * Pin a message\n   * @param messageId - Message ID\n   * @returns Promise resolving when message is pinned\n   */\n  abstract pinMessage(messageId: UUID): Promise<void>;\n\n  /**\n   * Unpin a message\n   * @param messageId - Message ID\n   * @returns Promise resolving when message is unpinned\n   */\n  abstract unpinMessage(messageId: UUID): Promise<void>;\n\n  /**\n   * Get available channels\n   * @returns Promise resolving to array of channels\n   */\n  abstract getChannels(): Promise<MessageChannel[]>;\n\n  /**\n   * Get channel information\n   * @param channelId - Channel ID\n   * @returns Promise resolving to channel info\n   */\n  abstract getChannel(channelId: UUID): Promise<MessageChannel>;\n\n  /**\n   * Create a new channel\n   * @param name - Channel name\n   * @param type - Channel type\n   * @param options - Channel options\n   * @returns Promise resolving to new channel ID\n   */\n  abstract createChannel(\n    name: string,\n    type: MessageChannel['type'],\n    options?: {\n      description?: string;\n      participants?: UUID[];\n      private?: boolean;\n    }\n  ): Promise<UUID>;\n\n  /**\n   * Search messages across channels\n   * @param query - Search query\n   * @param options - Search options\n   * @returns Promise resolving to search results\n   */\n  abstract searchMessages(query: string, options?: MessageSearchOptions): Promise<MessageInfo[]>;\n}\n",
    "import { Service, ServiceType } from '@elizaos/core';\n\nexport interface PdfExtractionResult {\n  text: string;\n  pageCount: number;\n  metadata?: {\n    title?: string;\n    author?: string;\n    createdAt?: Date;\n    modifiedAt?: Date;\n  };\n}\n\nexport interface PdfGenerationOptions {\n  format?: 'A4' | 'A3' | 'Letter';\n  orientation?: 'portrait' | 'landscape';\n  margins?: {\n    top?: number;\n    bottom?: number;\n    left?: number;\n    right?: number;\n  };\n  header?: string;\n  footer?: string;\n}\n\nexport interface PdfConversionOptions {\n  quality?: 'high' | 'medium' | 'low';\n  outputFormat?: 'pdf' | 'pdf/a';\n  compression?: boolean;\n}\n\n/**\n * Interface for PDF processing services\n */\nexport abstract class IPdfService extends Service {\n  static override readonly serviceType = ServiceType.PDF;\n\n  public readonly capabilityDescription = 'PDF processing, extraction, and generation capabilities';\n\n  /**\n   * Extract text and metadata from a PDF file\n   * @param pdfPath - Path to the PDF file or buffer\n   * @returns Promise resolving to extracted text and metadata\n   */\n  abstract extractText(pdfPath: string | Buffer): Promise<PdfExtractionResult>;\n\n  /**\n   * Generate a PDF from HTML content\n   * @param htmlContent - HTML content to convert to PDF\n   * @param options - PDF generation options\n   * @returns Promise resolving to PDF buffer\n   */\n  abstract generatePdf(htmlContent: string, options?: PdfGenerationOptions): Promise<Buffer>;\n\n  /**\n   * Convert a document to PDF format\n   * @param filePath - Path to the document file\n   * @param options - Conversion options\n   * @returns Promise resolving to PDF buffer\n   */\n  abstract convertToPdf(filePath: string, options?: PdfConversionOptions): Promise<Buffer>;\n\n  /**\n   * Merge multiple PDF files into one\n   * @param pdfPaths - Array of PDF file paths or buffers\n   * @returns Promise resolving to merged PDF buffer\n   */\n  abstract mergePdfs(pdfPaths: (string | Buffer)[]): Promise<Buffer>;\n\n  /**\n   * Split a PDF into individual pages\n   * @param pdfPath - Path to the PDF file or buffer\n   * @returns Promise resolving to array of page buffers\n   */\n  abstract splitPdf(pdfPath: string | Buffer): Promise<Buffer[]>;\n}\n",
    "import { Service, ServiceType, type UUID } from '@elizaos/core';\n\nexport interface PostMedia {\n  id: UUID;\n  url: string;\n  type: 'image' | 'video' | 'audio' | 'document';\n  mimeType: string;\n  size: number;\n  width?: number;\n  height?: number;\n  duration?: number;\n  thumbnail?: string;\n  description?: string;\n  altText?: string;\n}\n\nexport interface PostLocation {\n  name: string;\n  address?: string;\n  coordinates?: {\n    latitude: number;\n    longitude: number;\n  };\n  placeId?: string;\n}\n\nexport interface PostAuthor {\n  id: UUID;\n  username: string;\n  displayName: string;\n  avatar?: string;\n  verified?: boolean;\n  followerCount?: number;\n  followingCount?: number;\n  bio?: string;\n  website?: string;\n}\n\nexport interface PostEngagement {\n  likes: number;\n  shares: number;\n  comments: number;\n  views?: number;\n  hasLiked: boolean;\n  hasShared: boolean;\n  hasCommented: boolean;\n  hasSaved: boolean;\n}\n\nexport interface PostContent {\n  text?: string;\n  html?: string;\n  media?: PostMedia[];\n  location?: PostLocation;\n  tags?: string[];\n  mentions?: UUID[];\n  links?: Array<{\n    url: string;\n    title?: string;\n    description?: string;\n    image?: string;\n  }>;\n  poll?: {\n    question: string;\n    options: Array<{\n      text: string;\n      votes: number;\n    }>;\n    expiresAt?: Date;\n    multipleChoice?: boolean;\n  };\n}\n\nexport interface PostInfo {\n  id: UUID;\n  author: PostAuthor;\n  content: PostContent;\n  platform: string;\n  platformId: string;\n  url: string;\n  createdAt: Date;\n  editedAt?: Date;\n  scheduledAt?: Date;\n  engagement: PostEngagement;\n  visibility: 'public' | 'private' | 'followers' | 'friends' | 'unlisted';\n  replyTo?: UUID;\n  thread?: {\n    id: UUID;\n    position: number;\n    total: number;\n  };\n  crossPosted?: Array<{\n    platform: string;\n    platformId: string;\n    url: string;\n  }>;\n}\n\nexport interface PostCreateOptions {\n  platforms?: string[];\n  scheduledAt?: Date;\n  visibility?: PostInfo['visibility'];\n  replyTo?: UUID;\n  thread?: boolean;\n  location?: PostLocation;\n  tags?: string[];\n  mentions?: UUID[];\n  enableComments?: boolean;\n  enableSharing?: boolean;\n  contentWarning?: string;\n  sensitive?: boolean;\n}\n\nexport interface PostSearchOptions {\n  query?: string;\n  author?: UUID;\n  platform?: string;\n  tags?: string[];\n  mentions?: UUID[];\n  since?: Date;\n  before?: Date;\n  limit?: number;\n  offset?: number;\n  hasMedia?: boolean;\n  hasLocation?: boolean;\n  visibility?: PostInfo['visibility'];\n  sortBy?: 'date' | 'engagement' | 'relevance';\n}\n\nexport interface PostAnalytics {\n  postId: UUID;\n  platform: string;\n  impressions: number;\n  reach: number;\n  engagement: PostEngagement;\n  clicks: number;\n  shares: number;\n  saves: number;\n  demographics?: {\n    age?: Record<string, number>;\n    gender?: Record<string, number>;\n    location?: Record<string, number>;\n  };\n  topPerformingHours?: Array<{\n    hour: number;\n    engagement: number;\n  }>;\n}\n\n/**\n * Interface for social media posting services\n */\nexport abstract class IPostService extends Service {\n  static override readonly serviceType = ServiceType.POST;\n\n  public readonly capabilityDescription =\n    'Social media posting and content management capabilities';\n\n  /**\n   * Create and publish a new post\n   * @param content - Post content\n   * @param options - Publishing options\n   * @returns Promise resolving to post ID\n   */\n  abstract createPost(content: PostContent, options?: PostCreateOptions): Promise<UUID>;\n\n  /**\n   * Get posts from timeline or specific user\n   * @param options - Search options\n   * @returns Promise resolving to array of posts\n   */\n  abstract getPosts(options?: PostSearchOptions): Promise<PostInfo[]>;\n\n  /**\n   * Get a specific post by ID\n   * @param postId - Post ID\n   * @returns Promise resolving to post info\n   */\n  abstract getPost(postId: UUID): Promise<PostInfo>;\n\n  /**\n   * Edit an existing post\n   * @param postId - Post ID\n   * @param content - New post content\n   * @returns Promise resolving when edit completes\n   */\n  abstract editPost(postId: UUID, content: PostContent): Promise<void>;\n\n  /**\n   * Delete a post\n   * @param postId - Post ID\n   * @returns Promise resolving when deletion completes\n   */\n  abstract deletePost(postId: UUID): Promise<void>;\n\n  /**\n   * Like/unlike a post\n   * @param postId - Post ID\n   * @param like - True to like, false to unlike\n   * @returns Promise resolving when operation completes\n   */\n  abstract likePost(postId: UUID, like: boolean): Promise<void>;\n\n  /**\n   * Share/repost a post\n   * @param postId - Post ID\n   * @param comment - Optional comment when sharing\n   * @returns Promise resolving to share ID\n   */\n  abstract sharePost(postId: UUID, comment?: string): Promise<UUID>;\n\n  /**\n   * Save/unsave a post\n   * @param postId - Post ID\n   * @param save - True to save, false to unsave\n   * @returns Promise resolving when operation completes\n   */\n  abstract savePost(postId: UUID, save: boolean): Promise<void>;\n\n  /**\n   * Comment on a post\n   * @param postId - Post ID\n   * @param content - Comment content\n   * @returns Promise resolving to comment ID\n   */\n  abstract commentOnPost(postId: UUID, content: PostContent): Promise<UUID>;\n\n  /**\n   * Get comments for a post\n   * @param postId - Post ID\n   * @param options - Search options\n   * @returns Promise resolving to array of comments\n   */\n  abstract getComments(postId: UUID, options?: PostSearchOptions): Promise<PostInfo[]>;\n\n  /**\n   * Schedule a post for later publishing\n   * @param content - Post content\n   * @param scheduledAt - When to publish\n   * @param options - Publishing options\n   * @returns Promise resolving to scheduled post ID\n   */\n  abstract schedulePost(\n    content: PostContent,\n    scheduledAt: Date,\n    options?: PostCreateOptions\n  ): Promise<UUID>;\n\n  /**\n   * Get analytics for a post\n   * @param postId - Post ID\n   * @returns Promise resolving to post analytics\n   */\n  abstract getPostAnalytics(postId: UUID): Promise<PostAnalytics>;\n\n  /**\n   * Get trending posts\n   * @param options - Search options\n   * @returns Promise resolving to trending posts\n   */\n  abstract getTrendingPosts(options?: PostSearchOptions): Promise<PostInfo[]>;\n\n  /**\n   * Search posts across platforms\n   * @param query - Search query\n   * @param options - Search options\n   * @returns Promise resolving to search results\n   */\n  abstract searchPosts(query: string, options?: PostSearchOptions): Promise<PostInfo[]>;\n}\n",
    "import { Service, ServiceType } from '@elizaos/core';\n\n/**\n * A standardized representation of a token holding.\n */\nexport interface TokenBalance {\n  address: string; // Token mint address, or a native identifier like 'SOL' or 'ETH'\n  balance: string; // Raw balance as a string to handle large numbers with precision\n  decimals: number;\n  uiAmount?: number; // User-friendly balance, adjusted for decimals\n  name?: string;\n  symbol?: string;\n  logoURI?: string;\n}\n\n/**\n * Generic representation of token data that can be provided by various services.\n */\nexport interface TokenData {\n  id: string; // Unique identifier (e.g., contract address or a composite ID)\n  symbol: string;\n  name: string;\n  address: string; // Contract address\n  chain: string; // e.g., 'solana', 'ethereum', 'base'\n  sourceProvider: string; // e.g., 'birdeye', 'coinmarketcap'\n\n  price?: number;\n  priceChange24hPercent?: number;\n  priceChange24hUSD?: number; // Absolute change\n\n  volume24hUSD?: number;\n  marketCapUSD?: number;\n\n  liquidity?: number;\n  holders?: number;\n\n  logoURI?: string;\n  decimals?: number;\n\n  // Timestamps\n  lastUpdatedAt?: Date; // When this specific data point was last updated from the source\n\n  // Optional raw data from the provider\n  raw?: any;\n}\n\n/**\n * Interface for a generic service that provides token data.\n */\nexport abstract class ITokenDataService extends Service {\n  static override readonly serviceType = ServiceType.TOKEN_DATA;\n  public readonly capabilityDescription =\n    'Provides standardized access to token market data.' as string;\n\n  /**\n   * Fetches detailed information for a single token.\n   * @param address The token's contract address.\n   * @param chain The blockchain the token resides on.\n   * @returns A Promise resolving to TokenData or null if not found.\n   */\n  abstract getTokenDetails(address: string, chain: string): Promise<TokenData | null>;\n\n  /**\n   * Fetches a list of trending tokens.\n   * @param chain Optional: Filter by a specific blockchain.\n   * @param limit Optional: Number of tokens to return. Defaults to a service-specific value.\n   * @param timePeriod Optional: Time period for trending data (e.g., '24h', '7d'). Defaults to service-specific.\n   * @returns A Promise resolving to an array of TokenData.\n   */\n  abstract getTrendingTokens(\n    chain?: string,\n    limit?: number,\n    timePeriod?: string\n  ): Promise<TokenData[]>;\n\n  /**\n   * Searches for tokens based on a query string.\n   * @param query The search query (e.g., symbol, name, address).\n   * @param chain Optional: Filter by a specific blockchain.\n   * @param limit Optional: Number of results to return.\n   * @returns A Promise resolving to an array of TokenData.\n   */\n  abstract searchTokens(query: string, chain?: string, limit?: number): Promise<TokenData[]>;\n\n  /**\n   * Fetches data for multiple tokens by their addresses on a specific chain.\n   * @param addresses Array of token contract addresses.\n   * @param chain The blockchain the tokens reside on.\n   * @returns A Promise resolving to an array of TokenData. May not include all requested if some are not found.\n   */\n  abstract getTokensByAddresses(addresses: string[], chain: string): Promise<TokenData[]>;\n\n  // Future potential methods:\n  // getHistoricalPriceData(address: string, chain: string, timeFrame: string): Promise<any[]>;\n  // getTokenMarketChart(address: string, chain: string, days: number): Promise<any[]>;\n}\n",
    "import { Service, ServiceType } from '@elizaos/core';\n\nexport interface TranscriptionOptions {\n  language?: string;\n  model?: string;\n  temperature?: number;\n  prompt?: string;\n  response_format?: 'json' | 'text' | 'srt' | 'vtt' | 'verbose_json';\n  timestamp_granularities?: ('word' | 'segment')[];\n  word_timestamps?: boolean;\n  segment_timestamps?: boolean;\n}\n\nexport interface TranscriptionResult {\n  text: string;\n  language?: string;\n  duration?: number;\n  segments?: TranscriptionSegment[];\n  words?: TranscriptionWord[];\n  confidence?: number;\n}\n\nexport interface TranscriptionSegment {\n  id: number;\n  text: string;\n  start: number;\n  end: number;\n  confidence?: number;\n  tokens?: number[];\n  temperature?: number;\n  avg_logprob?: number;\n  compression_ratio?: number;\n  no_speech_prob?: number;\n}\n\nexport interface TranscriptionWord {\n  word: string;\n  start: number;\n  end: number;\n  confidence?: number;\n}\n\nexport interface SpeechToTextOptions {\n  language?: string;\n  model?: string;\n  continuous?: boolean;\n  interimResults?: boolean;\n  maxAlternatives?: number;\n}\n\nexport interface TextToSpeechOptions {\n  voice?: string;\n  model?: string;\n  speed?: number;\n  format?: 'mp3' | 'wav' | 'flac' | 'aac';\n  response_format?: 'mp3' | 'opus' | 'aac' | 'flac';\n}\n\n/**\n * Interface for audio transcription and speech services\n */\nexport abstract class ITranscriptionService extends Service {\n  static override readonly serviceType = ServiceType.TRANSCRIPTION;\n\n  public readonly capabilityDescription = 'Audio transcription and speech processing capabilities';\n\n  /**\n   * Transcribe audio file to text\n   * @param audioPath - Path to audio file or audio buffer\n   * @param options - Transcription options\n   * @returns Promise resolving to transcription result\n   */\n  abstract transcribeAudio(\n    audioPath: string | Buffer,\n    options?: TranscriptionOptions\n  ): Promise<TranscriptionResult>;\n\n  /**\n   * Transcribe video file to text (extracts audio first)\n   * @param videoPath - Path to video file or video buffer\n   * @param options - Transcription options\n   * @returns Promise resolving to transcription result\n   */\n  abstract transcribeVideo(\n    videoPath: string | Buffer,\n    options?: TranscriptionOptions\n  ): Promise<TranscriptionResult>;\n\n  /**\n   * Real-time speech to text from audio stream\n   * @param audioStream - Audio stream or buffer\n   * @param options - Speech to text options\n   * @returns Promise resolving to transcription result\n   */\n  abstract speechToText(\n    audioStream: NodeJS.ReadableStream | Buffer,\n    options?: SpeechToTextOptions\n  ): Promise<TranscriptionResult>;\n\n  /**\n   * Convert text to speech\n   * @param text - Text to convert to speech\n   * @param options - Text to speech options\n   * @returns Promise resolving to audio buffer\n   */\n  abstract textToSpeech(text: string, options?: TextToSpeechOptions): Promise<Buffer>;\n\n  /**\n   * Get supported languages for transcription\n   * @returns Promise resolving to array of supported language codes\n   */\n  abstract getSupportedLanguages(): Promise<string[]>;\n\n  /**\n   * Get available voices for text to speech\n   * @returns Promise resolving to array of available voices\n   */\n  abstract getAvailableVoices(): Promise<\n    Array<{\n      id: string;\n      name: string;\n      language: string;\n      gender?: 'male' | 'female' | 'neutral';\n    }>\n  >;\n\n  /**\n   * Detect language of audio file\n   * @param audioPath - Path to audio file or audio buffer\n   * @returns Promise resolving to detected language code\n   */\n  abstract detectLanguage(audioPath: string | Buffer): Promise<string>;\n}\n",
    "import { Service, ServiceType } from '@elizaos/core';\n\nexport interface VideoInfo {\n  title?: string;\n  duration?: number;\n  url: string;\n  thumbnail?: string;\n  description?: string;\n  uploader?: string;\n  viewCount?: number;\n  uploadDate?: Date;\n  formats?: VideoFormat[];\n}\n\nexport interface VideoFormat {\n  formatId: string;\n  url: string;\n  extension: string;\n  quality: string;\n  fileSize?: number;\n  videoCodec?: string;\n  audioCodec?: string;\n  resolution?: string;\n  fps?: number;\n  bitrate?: number;\n}\n\nexport interface VideoDownloadOptions {\n  format?: string;\n  quality?: 'best' | 'worst' | 'bestvideo' | 'bestaudio' | string;\n  outputPath?: string;\n  audioOnly?: boolean;\n  videoOnly?: boolean;\n  subtitles?: boolean;\n  embedSubs?: boolean;\n  writeInfoJson?: boolean;\n}\n\nexport interface VideoProcessingOptions {\n  startTime?: number;\n  endTime?: number;\n  outputFormat?: string;\n  resolution?: string;\n  bitrate?: string;\n  framerate?: number;\n  audioCodec?: string;\n  videoCodec?: string;\n}\n\n/**\n * Interface for video processing and download services\n */\nexport abstract class IVideoService extends Service {\n  static override readonly serviceType = ServiceType.VIDEO;\n\n  public readonly capabilityDescription = 'Video download, processing, and conversion capabilities';\n\n  /**\n   * Get video information without downloading\n   * @param url - Video URL\n   * @returns Promise resolving to video information\n   */\n  abstract getVideoInfo(url: string): Promise<VideoInfo>;\n\n  /**\n   * Download a video from URL\n   * @param url - Video URL\n   * @param options - Download options\n   * @returns Promise resolving to downloaded file path\n   */\n  abstract downloadVideo(url: string, options?: VideoDownloadOptions): Promise<string>;\n\n  /**\n   * Extract audio from video\n   * @param videoPath - Path to video file or video URL\n   * @param outputPath - Optional output path for audio file\n   * @returns Promise resolving to audio file path\n   */\n  abstract extractAudio(videoPath: string, outputPath?: string): Promise<string>;\n\n  /**\n   * Generate thumbnail from video\n   * @param videoPath - Path to video file or video URL\n   * @param timestamp - Timestamp in seconds to capture thumbnail\n   * @returns Promise resolving to thumbnail image path\n   */\n  abstract getThumbnail(videoPath: string, timestamp?: number): Promise<string>;\n\n  /**\n   * Convert video to different format\n   * @param videoPath - Path to input video file\n   * @param outputPath - Path for output video file\n   * @param options - Processing options\n   * @returns Promise resolving to converted video path\n   */\n  abstract convertVideo(\n    videoPath: string,\n    outputPath: string,\n    options?: VideoProcessingOptions\n  ): Promise<string>;\n\n  /**\n   * Get available formats for a video URL\n   * @param url - Video URL\n   * @returns Promise resolving to available formats\n   */\n  abstract getAvailableFormats(url: string): Promise<VideoFormat[]>;\n}\n",
    "import { Service, ServiceType } from '@elizaos/core';\nimport type { TokenBalance } from './token';\n\n/**\n * Represents a single asset holding within a wallet, including its value.\n * This extends a generic TokenBalance with wallet-specific valuation.\n */\nexport interface WalletAsset extends TokenBalance {\n  priceUsd?: number;\n  valueUsd?: number;\n}\n\n/**\n * Represents the entire portfolio of assets in a wallet.\n */\nexport interface WalletPortfolio {\n  totalValueUsd: number;\n  assets: WalletAsset[];\n}\n\n/**\n * Abstract interface for a Wallet Service.\n * Plugins that provide wallet functionality (e.g., for Solana, EVM) should implement this service.\n * It provides a standardized way for other plugins to query the state of a wallet.\n */\nexport abstract class IWalletService extends Service {\n  static override readonly serviceType = ServiceType.WALLET;\n\n  public readonly capabilityDescription =\n    'Provides standardized access to wallet balances and portfolios.';\n\n  /**\n   * Retrieves the entire portfolio of assets held by the wallet.\n   * @param owner - Optional: The specific wallet address/owner to query if the service manages multiple.\n   * @returns A promise that resolves to the wallet's portfolio.\n   */\n  abstract getPortfolio(owner?: string): Promise<WalletPortfolio>;\n\n  /**\n   * Retrieves the balance of a specific asset in the wallet.\n   * @param assetAddress - The mint address or native identifier of the asset.\n   * @param owner - Optional: The specific wallet address/owner to query.\n   * @returns A promise that resolves to the user-friendly (decimal-adjusted) balance of the asset held.\n   */\n  abstract getBalance(assetAddress: string, owner?: string): Promise<number>;\n\n  /**\n   * Transfers SOL from a specified keypair to a given public key.\n   * This is a low-level function primarily for Solana-based wallet services.\n   * @param from - The Keypair of the sender.\n   * @param to - The PublicKey of the recipient.\n   * @param lamports - The amount in lamports to transfer.\n   * @returns A promise that resolves with the transaction signature.\n   */\n  abstract transferSol(from: any, to: any, lamports: number): Promise<string>;\n}\n",
    "import { Service, ServiceType } from '@elizaos/core';\n\nexport interface SearchOptions {\n  limit?: number;\n  offset?: number;\n  language?: string;\n  region?: string;\n  dateRange?: {\n    start?: Date;\n    end?: Date;\n  };\n  fileType?: string;\n  site?: string;\n  sortBy?: 'relevance' | 'date' | 'popularity';\n  safeSearch?: 'strict' | 'moderate' | 'off';\n}\n\nexport interface SearchResult {\n  title: string;\n  url: string;\n  description: string;\n  displayUrl?: string;\n  thumbnail?: string;\n  publishedDate?: Date;\n  source?: string;\n  relevanceScore?: number;\n  snippet?: string;\n}\n\nexport interface SearchResponse {\n  query: string;\n  results: SearchResult[];\n  totalResults?: number;\n  searchTime?: number;\n  suggestions?: string[];\n  nextPageToken?: string;\n  relatedSearches?: string[];\n}\n\nexport interface NewsSearchOptions extends SearchOptions {\n  category?:\n    | 'general'\n    | 'business'\n    | 'entertainment'\n    | 'health'\n    | 'science'\n    | 'sports'\n    | 'technology';\n  freshness?: 'day' | 'week' | 'month';\n}\n\nexport interface ImageSearchOptions extends SearchOptions {\n  size?: 'small' | 'medium' | 'large' | 'wallpaper' | 'any';\n  color?:\n    | 'color'\n    | 'monochrome'\n    | 'red'\n    | 'orange'\n    | 'yellow'\n    | 'green'\n    | 'blue'\n    | 'purple'\n    | 'pink'\n    | 'brown'\n    | 'black'\n    | 'gray'\n    | 'white';\n  type?: 'photo' | 'clipart' | 'line' | 'animated';\n  layout?: 'square' | 'wide' | 'tall' | 'any';\n  license?: 'any' | 'public' | 'share' | 'sharecommercially' | 'modify';\n}\n\nexport interface VideoSearchOptions extends SearchOptions {\n  duration?: 'short' | 'medium' | 'long' | 'any';\n  resolution?: 'high' | 'standard' | 'any';\n  quality?: 'high' | 'standard' | 'any';\n}\n\n/**\n * Interface for web search services\n */\nexport abstract class IWebSearchService extends Service {\n  static override readonly serviceType = ServiceType.WEB_SEARCH;\n\n  public readonly capabilityDescription = 'Web search and content discovery capabilities';\n\n  /**\n   * Perform a general web search\n   * @param query - Search query\n   * @param options - Search options\n   * @returns Promise resolving to search results\n   */\n  abstract search(query: string, options?: SearchOptions): Promise<SearchResponse>;\n\n  /**\n   * Search for news articles\n   * @param query - Search query\n   * @param options - News search options\n   * @returns Promise resolving to news search results\n   */\n  abstract searchNews(query: string, options?: NewsSearchOptions): Promise<SearchResponse>;\n\n  /**\n   * Search for images\n   * @param query - Search query\n   * @param options - Image search options\n   * @returns Promise resolving to image search results\n   */\n  abstract searchImages(query: string, options?: ImageSearchOptions): Promise<SearchResponse>;\n\n  /**\n   * Search for videos\n   * @param query - Search query\n   * @param options - Video search options\n   * @returns Promise resolving to video search results\n   */\n  abstract searchVideos(query: string, options?: VideoSearchOptions): Promise<SearchResponse>;\n\n  /**\n   * Get search suggestions for a query\n   * @param query - Partial search query\n   * @returns Promise resolving to array of suggestions\n   */\n  abstract getSuggestions(query: string): Promise<string[]>;\n\n  /**\n   * Get trending searches\n   * @param region - Optional region code\n   * @returns Promise resolving to trending search queries\n   */\n  abstract getTrendingSearches(region?: string): Promise<string[]>;\n\n  /**\n   * Get detailed information about a specific URL\n   * @param url - URL to analyze\n   * @returns Promise resolving to page information\n   */\n  abstract getPageInfo(url: string): Promise<{\n    title: string;\n    description: string;\n    content: string;\n    metadata: Record<string, string>;\n    images: string[];\n    links: string[];\n  }>;\n}\n"
  ],
  "mappings": ";AAAA;AAAA;AA8DO,MAAe,wBAAwB,QAAQ;AAAA,SAC3B,cAAc,YAAY;AAAA,EAEnC,wBAAwB;AA+E1C;;;AChJA,oBAAS,yBAAS;AAAA;AA4EX,MAAe,sBAAsB,SAAQ;AAAA,SACzB,cAAc,aAAY;AAAA,EAEnC,wBAAwB;AAkF1C;;;ACjKA,oBAAS;AAAA;AA2DF,MAAe,mBAAmB,SAAQ;AAAA,SACtB,cAAc;AAAA,EAEvB,wBAAwB;AA4D1C;;;AC1HA,oBAAS,yBAAS;AAAA;AAoHX,MAAe,wBAAwB,SAAQ;AAAA,SAC3B,cAAc,aAAY;AAAA,EAEnC,wBAAwB;AAgH1C;;;ACvOA,oBAAS,yBAAS;AAAA;AAmCX,MAAe,oBAAoB,SAAQ;AAAA,SACvB,cAAc,aAAY;AAAA,EAEnC,wBAAwB;AAsC1C;;;AC5EA,oBAAS,yBAAS;AAAA;AAwJX,MAAe,qBAAqB,SAAQ;AAAA,SACxB,cAAc,aAAY;AAAA,EAEnC,wBACd;AAiHJ;;;AC7QA,oBAAS,yBAAS;AAAA;AAiDX,MAAe,0BAA0B,SAAQ;AAAA,SAC7B,cAAc,aAAY;AAAA,EACnC,wBACd;AA2CJ;;;AC/FA,oBAAS,yBAAS;AAAA;AA6DX,MAAe,8BAA8B,SAAQ;AAAA,SACjC,cAAc,aAAY;AAAA,EAEnC,wBAAwB;AAoE1C;;;ACpIA,oBAAS,yBAAS;AAAA;AAoDX,MAAe,sBAAsB,SAAQ;AAAA,SACzB,cAAc,aAAY;AAAA,EAEnC,wBAAwB;AAoD1C;;;AC3GA,oBAAS,0BAAS;AAAA;AAyBX,MAAe,uBAAuB,UAAQ;AAAA,SAC1B,cAAc,aAAY;AAAA,EAEnC,wBACd;AA0BJ;;;ACvDA,oBAAS,0BAAS;AAAA;AAiFX,MAAe,0BAA0B,UAAQ;AAAA,SAC7B,cAAc,cAAY;AAAA,EAEnC,wBAAwB;AA6D1C;",
  "debugId": "57102F0D253FCB5764756E2164756E21",
  "names": []
}